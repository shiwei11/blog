<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="shiwi"><meta name="copyright" content="SHIWIVI"><link rel="shortcut icon" href="/blog/images/favicon.ico" type="image/x-icon"><style>.preload{position:absolute;display:flex;flex-direction:column;align-items:center;justify-content:center;left:0;top:0;width:100%;height:100%;background-color:#000;z-index:100}.text{margin-bottom:10px;color:#00cff3;text-shadow:0 0 3px #00cff3;font-size:20px}.text span{display:inline-block}.dance{animation:dance .8s linear}.text span:nth-child(1){animation-delay:0s}.text span:nth-child(2){animation-delay:.1s}.text span:nth-child(3){animation-delay:.2s}.text span:nth-child(4){animation-delay:.3s}.text span:nth-child(5){animation-delay:.4s}.text span:nth-child(6){animation-delay:.5s}.text span:nth-child(7){animation-delay:.6s}.text span:nth-child(8){animation-delay:.7s}.text span:nth-child(9){animation-delay:.8s}.text span:nth-child(10){animation-delay:.9s}@keyframes dance{0%{transform:translateY(0)}50%{transform:translateY(-20px)}100%{transform:translateY(0)}}.loading{width:80%;max-width:260px;height:6px;background-color:#e1e4e8;border-radius:6px}.bar{display:flex;height:100%;background:linear-gradient(90deg,#ffd33d,#ea4aaa 10%,#b34bff 30%,#01feff 51%,#ffb33d 68%,#ea4aaa 85%,#b34bff);background-size:300% 100%;animation:bar 2s linear infinite}@keyframes bar{0%{background-position:100%}100%{background-position:0}}</style><body><div class="preload"><div class="text"><span>L</span> <span>o</span> <span>a</span> <span>d</span> <span>i</span> <span>n</span> <span>g</span> <span>.</span> <span>.</span> <span>.</span></div><div class="loading"><span class="bar"></span></div></div><script>let texts=document.querySelector('.text').querySelectorAll('span');let timer=setInterval(()=>{texts.forEach((item)=>{item.classList.toggle("dance")})},1700);window.onload=function(){clearInterval(timer);document.querySelector('.preload').style="display:none;"}</script><title>SHIWIVI-文章</title>
<link rel="stylesheet" href="https://at.alicdn.com/t/font_2856826_bu73u0ahu7a.css">

<link rel="stylesheet" href="/blog/css/index.css">
<link rel="stylesheet" href="/blog/css/article.css">
<link rel="stylesheet" href="/blog/css/atelier-cave.min.css">

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blog/atom.xml" title="SHWIVI's blog" type="application/atom+xml">
</head>
<body>
<div class="nav">
    <div class="card">
        <div class="head">
            <img src="/blog/images/head.jpg"  alt="头不见了.." title="狗">
        </div>
        <div class="cardText">
            <p>(ー`´ー)</p>
            <p>那不是bug，是彩蛋</p>
        </div> 
    </div>
    <ul class="label">
        
        <li><a href="/blog/index.html">首页</a></li>
        
        <li><a href="/blog/life">日常</a></li>
        
        <li><a href="/blog/record">一句</a></li>
        
        <li><a href="/blog/message">留言</a></li>
        
        <li><a href="/blog/about">关于</a></li>
          
    </ul>
        <ul class="tag">
            <li>#Document</li>
            <li>#Java</li>
            <li>#css</li>
            <li>#Life</li>
            <li>#Lua</li>
            <li>#PCB</li>
            <li>#Shell</li>
            <li>#C</li>
            <li>#html</li>
            <li>#硬件</li>
            <li>#javaScript</li>
            <li>#Firewall</li>
            <li>#Security</li>
            <li><a href="/blog/tags/Linux">#Linux</a></li>
            <li>#Python</li>
            <li>#Serve</li>
            <li>#Web</li>
        </ul>
    <div class="rsstag"><a href="/blog/atom.xml"><span class="iconfont icon-rss"></span>RSS订阅</a></div>
<div class="flower">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="84.6px" height="70.5px" viewBox="0 0 254 212" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>窗</title>
<desc>Created with Sketch.</desc>
<defs></defs>
<g id="植物" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
    <g id="Artboard" transform="translate(-885.000000, -503.000000)">
        <g id="植物-紫色盆" transform="translate(882.000000, 500.000000)">
            <ellipse id="Oval-12" fill="#B3B7C7" cx="140.5" cy="137" rx="39.5" ry="6"></ellipse>
            <g id="Group-5">
                <path d="M131.5,149 C137.746054,149 138.400559,136.953074 140.297813,118.503702 C141.504079,106.77367 149.145158,88.1140929 147,75 C142.297813,46.2539062 153.271934,32.5660626 150.170125,19.4282488 C148.031314,10.3692495 142.862042,3 131.5,3 C123.603887,3 113.698654,6.59314895 110.722909,11.2157433 C103.206874,22.8913341 114,46.5137576 114,75 C114,90.4435309 122.495151,106.751425 123.699377,118.476362 C125.595832,136.941172 125.250862,149 131.5,149 Z" id="Oval-11" fill="#BAC4F6"></path>
                <path d="M135.5,146.5 C132.598908,121.877878 130.965369,104.566553 130.599381,94.5660242 C130.050399,79.5652312 132.963841,77.0580598 132.164069,55.3464601 C131.630888,40.8720602 130.242865,30.4232402 128,24" id="Line-15" stroke="#FFFFFF" stroke-width="2" opacity="0.800892857" stroke-linecap="square"></path>
                <path d="M77.0442201,163.336077 C84.2239219,163.336077 101.067658,131.237823 101.067658,92.025606 C101.067658,52.8133888 90.9057581,-2.32627732 72.6560979,17.2440872 C50.0508064,41.4852946 69.5871262,36.5862429 74.0442201,63.8595149 C75.572858,73.2133576 77.0442201,94.5993942 77.0442201,104.613421 C77.0442201,143.825638 69.8645184,163.336077 77.0442201,163.336077 Z" id="Oval-9" fill="#BAC4F6" transform="translate(81.510722, 88.251316) rotate(-43.000000) translate(-81.510722, -88.251316) "></path>
                <path d="M42.5,50.5 C47.5132933,48.8699207 59.3816332,57.6317857 78.1050199,76.785595 C96.8284065,95.9394043 113.960067,116.844206 129.5,139.5" id="Line-17" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M155.281006,152.144255 C162.116643,152.144255 178.153197,121.584207 178.153197,84.2511084 C178.153197,72.6051871 184.354199,51.8242671 182.531201,39.8465879 C178.51025,13.4276595 163.058175,0.233079666 151.10317,13.0532528 C129.581164,36.1327785 143.297279,29.7382802 147.540781,55.7045685 C148.996164,64.6101585 153.500382,80.3852665 153.500382,89.9194035 C153.500382,127.252502 148.445368,152.144255 155.281006,152.144255 Z" id="Oval-9-Copy-2" fill="#E9EDFD" transform="translate(161.092971, 80.123972) scale(-1, 1) rotate(-20.000000) translate(-161.092971, -80.123972) "></path>
                <path d="M180.5,34.5 C181.290102,21.4892162 175.746138,28.9223292 163.868108,56.7993391 C157.546037,71.6368512 150.532373,85.3308057 144.827114,101.881203 C141.023608,112.914801 138.581237,128.787733 137.5,149.5" id="Line-20" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M60.3426107,183.894782 C69.2498271,183.894782 90.1463498,156.072081 90.1463498,122.083011 C90.1463498,88.0939419 67.5408019,29.4364067 54.8986583,57.2625442 C45.0326912,78.978146 51.0912584,74.0282851 56.6207779,97.6687014 C58.5172227,105.776593 67.8616068,124.363423 67.8616068,133.043561 C67.8616068,167.032631 51.4353942,183.894782 60.3426107,183.894782 Z" id="Oval-9-Copy" fill="#BAC4F6" transform="translate(69.895982, 116.944107) rotate(-71.000000) translate(-69.895982, -116.944107) "></path>
                <path d="M24.5,109.5 C22.4991751,103.669523 35.0833631,105.49608 62.2525641,114.979669 C79.4278854,120.974828 92.103247,119.378882 106.278649,126.191831 C111.777518,128.834684 120.517968,134.937407 132.5,144.5" id="Line-19" stroke="#FFFFFF" stroke-width="2" opacity="0.595424107" stroke-linecap="square"></path>
                <path d="M169.495543,159.559977 C178.40276,159.559977 199.299282,131.737276 199.299282,97.7482062 C199.299282,85.7856682 202.004463,66.329956 197.824033,53.1018748 C190.126639,28.745108 172.2443,14.8950801 164.051591,32.9277389 C154.185624,54.6433407 160.244191,49.6934798 165.77371,73.3338961 C167.670155,81.4417878 177.014539,100.028618 177.014539,108.708756 C177.014539,142.697825 160.588327,159.559977 169.495543,159.559977 Z" id="Oval-9-Copy-3" fill="#BAC4F6" transform="translate(179.479352, 92.134636) scale(-1, 1) rotate(-43.000000) translate(-179.479352, -92.134636) "></path>
                <path d="M213.5,60.5 C209.183273,60.8948914 201.740861,65.4428024 191.172763,74.1437328 C175.320617,87.1951284 177.797205,83.2393994 161.560337,103.262986 C150.735758,116.612043 142.715646,131.024381 137.5,146.5" id="Line-21" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M81.1425752,168.630026 C85.1025169,165.536181 98.2051544,147.96348 98.2051544,111.236918 C98.2051544,74.5103552 86.0176544,46.7369177 70.0176544,46.7369177 C54.0176544,46.7369177 59.5351666,70.3889964 66.8400325,93.0530589 C69.6371249,101.731312 78.9791535,122.814465 81.0032985,132.88325 C84.2653955,149.110029 78.6989273,170.539213 81.1425752,168.630026 Z" id="Oval-10" fill="#E9EDFD" transform="translate(78.936475, 107.743055) rotate(-52.000000) translate(-78.936475, -107.743055) "></path>
                <path d="M39.5,84.5 C46.5402399,84.832105 55.9862242,87.7506309 67.8379528,93.2555776 C85.6155457,101.512998 79.9127462,96.6348296 100.298442,112.739947 C113.888906,123.476691 125.956092,135.063376 136.5,147.5" id="Line-18" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M194.823347,177.534556 C197.785465,175.220296 209.085075,165.125173 213.530819,146.109724 C215.496552,137.701844 211.555235,124.000271 211.555235,111.853141 C211.555235,72.2337887 199.639103,43.8487815 182.378853,43.8487815 C165.118604,43.8487815 168.053621,58.2764613 175.933859,82.7256721 C183.814096,107.174883 191.693317,118.61017 193.876895,129.472028 C197.395933,146.976919 192.187224,179.594121 194.823347,177.534556 Z" id="Oval-10-Copy-2" fill="#E9EDFD" transform="translate(191.881132, 110.738214) scale(-1, 1) rotate(-52.000000) translate(-191.881132, -110.738214) "></path>
                <path d="M237.5,84.5 C231.839918,82.6252532 222.387737,84.7837206 209.143456,90.9754021 C189.277034,100.262925 198.344222,96.9653923 174.587666,113.911421 C158.749962,125.208774 147.387407,137.071634 140.5,149.5" id="Line-22" stroke="#FFFFFF" stroke-width="2" opacity="0.785044643" stroke-linecap="square"></path>
                <path d="M102.095097,154.049614 C106.979303,150.233654 123.140143,128.559423 123.140143,83.2607523 C123.140143,37.9620813 108.108037,3.70622602 88.3735811,3.70622602 C68.639125,3.70622602 75.4444439,32.8787829 84.4542911,60.8327171 C87.9042347,71.5365054 99.4267255,97.5405402 101.923313,109.959415 C105.946795,129.97358 99.0810936,156.404412 102.095097,154.049614 Z" id="Oval-10-Copy" fill="#E9EDFD" transform="translate(99.374086, 78.951409) rotate(-21.000000) translate(-99.374086, -78.951409) "></path>
                <path d="M70.5,27.5 C77.9697854,36.2141564 84.664658,44.2949462 90.5846178,51.7423694 C99.4645574,62.9135043 102.309139,65.8595669 108.078018,74.773869 C113.846897,83.6881711 108.232283,69.1486166 118.500716,94.8794382 C125.346337,112.033319 129.012765,128.573507 129.5,144.5" id="Line-16" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M193.001521,189.153265 C198.929205,189.153265 212.83568,162.652399 212.83568,130.278124 C212.83568,97.9038493 204.210737,49.7003434 189.378612,68.5372278 C174.540517,87.3816949 180.150684,86.5530431 183.830536,109.070321 C185.092606,116.793013 193.001521,132.403088 193.001521,140.670839 C193.001521,173.045114 187.073837,189.153265 193.001521,189.153265 Z" id="Oval-9-Copy-4" fill="#BAC4F6" transform="translate(196.248002, 126.727326) scale(-1, 1) rotate(-73.000000) translate(-196.248002, -126.727326) "></path>
                <path d="M234.5,116.5 C229.435614,115.997419 220.043174,117.148484 206.322678,119.953197 C185.741934,124.160265 185.201799,123.9696 168.145826,131.063968 C156.775178,135.793546 148.226569,140.93889 142.5,146.5" id="Line-23" stroke="#FFFFFF" stroke-width="2" opacity="0.733426339" stroke-linecap="square"></path>
            </g>
            <g id="Group-4" transform="translate(101.000000, 137.000000)">
                <path d="M0,0 C11.7955729,2 24.5052083,3 38.1289062,3 C51.7526042,3 65.3763021,2 79,0 L71.2109375,75.3409091 C61.9375,77.1136364 51.8945312,78 41.0820312,78 C30.2695313,78 19.4570312,77.1136364 8.64453125,75.3409091 L0,0 Z" id="Rectangle-9" fill="#FCDCCF"></path>
                <path d="M59.2621996,2.19791001 C63.6483775,1.86496527 70.2276443,1.1323286 79,0 L71.2109375,75.3409091 C63.3055851,76.5844933 57.2271178,77.3450382 52.9755357,77.6225437 L59.2621996,2.19791001 Z" id="Rectangle-9" fill="#ECC6B6"></path>
                <path d="M0,0 C10.9588352,1.33333333 23.3572727,2 37.1953125,2 C51.0333523,2 64.9682481,1.33333333 79,0 L76.7909585,21.3672948 L40.573652,23.0934676 L2.38711382,20.8047516 L0,0 Z" id="Rectangle-9" fill="#F3B096"></path>
            </g>
        </g>
    </g>
</g>
</svg>
</div>

</div>
<div class="menuBtn closed"> 
    <div class="menu-line"></div>
    <div class="menu-line"></div>
    <div class="menu-line"></div>
</div>
<div class="nightSky"><!--当关闭夜间背景模式时，子元素将在一段延时后才会被清除--></div>
<div class="main">
    <div class="msg">
        <div class="msgText"></div>
        <div class="msgBar"></div>
    </div>
    <div class="motto">
        <p> //sunny forever<br />
            while(life&lt;end){<br />
               love++;<br />
               beAwesome :)} </p>
     </div>
     <div class="mainContent">
    <div class="canvasWrapper"></div>
<div class="setWrapper">
    <ul class="setMenu">
        <div id="setBtn" class="setButton"><</div>
        <li class="searchContainer">
            <input id="searchInput" class="localSearch" placeholder="搜索..." type="search" >
            <span class="searchIco"></span>
        </li>
        <li id="toggleItem">
        主题：<span class="itemIco sun"></span>
        </li>
        <li class="setSize">
            <span id="increaseFontSize">+</span>
            <span class="fontSizeNum"></span>
            <span id="reduceFontSize">-</span>
        </li>
        <li id="clearBack">清除背景</li>
        <li id="disableBack">禁用背景</li>
    </ul> 
</div>
    <div class="resultContainer">
        <div id="searchResult" class="displayResult"></div>
    </div>
    <div class="tocWrapper"><div class="tocBtn">目 录</div><div class="tocBox"><!--tocBox用于容纳生成在toc外的目录--><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd"><span class="toc-number">1.</span> <span class="toc-text">systemd</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">配置文件路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.2.</span> <span class="toc-text">配置文件说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">配置文件语法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unit%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">unit的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unit%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.4.</span> <span class="toc-text">unit的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unit%E5%8D%95%E5%85%83%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">unit单元文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">2.1.</span> <span class="toc-text">单元文件路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unit-%E5%9D%97"><span class="toc-number">2.2.</span> <span class="toc-text">[Unit]块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Install-%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">[Install]块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Service类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Service-%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text">[Service]块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#service%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">service配置案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Target%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">Target类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%A2%84%E5%AE%9A%E4%B9%89Target"><span class="toc-number">4.2.</span> <span class="toc-text">运行级别与预定义Target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#target%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">target常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E4%B8%8Etarget"><span class="toc-number">4.4.</span> <span class="toc-text">开机自启动与target</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemctl"><span class="toc-number">5.</span> <span class="toc-text">systemctl</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">系统管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81"><span class="toc-number">5.2.</span> <span class="toc-text">查看系统状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">单元管理命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E5%85%83%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-number">5.4.</span> <span class="toc-text">常用的单元管理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#systemctl-status%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.4.1.</span> <span class="toc-text">systemctl status返回值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%8A%B6%E6%80%81%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">5.5.</span> <span class="toc-text">单元状态查询命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd-journald"><span class="toc-number">6.</span> <span class="toc-text">systemd-journald</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84"><span class="toc-number">6.1.</span> <span class="toc-text">日志文件存储路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#journalctl%E6%97%A5%E5%BF%97%E5%91%BD%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">journalctl日志命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">6.3.</span> <span class="toc-text">日志服务配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95-1"><span class="toc-number">6.4.</span> <span class="toc-text">配置文件语法</span></a></li></ol></li></ol></div></div>
        <div class="article">
        <h1 class="title">systemd</h1>
        <div class="art-info">
            <div><span><span class="iconfont icon-zishu-jzl"></span>字数：24978</span>
            <span><span class="iconfont icon-riqi"></span>写于：2025-07-21</span></div>
            <div><span><span class="iconfont icon-zuixinnew3"></span>最新更新：2025-07-21</span>
            <span><span class="iconfont icon-shijian"></span>阅读本文预计花费您72分钟</span></div>
        </div>
        <div class="art-content">
        <h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>systemd 是由Lennart Poettering(当时就职于Red Hat公司)领导开发的一套Linux服务和系统管理工具，用来为Linux提供一种更高效的启动管理机制以替代曾经的initd守护进程，并为用户提供并行化管理服务。systemd在Linux启动时会作为系统的第一个进程(PID为1)启动，然后由其负责启动系统的其它进程，大多数现代 Linux 发行版(如 Ubuntu、Debian、Fedora、CentOS、Arch Linux 等)都默认使用systemd来管理服务和系统进程，systemd主要提供以下功能：</p>
<ul>
<li>服务管理：管理各类服务的启动、自启动、停止</li>
<li>依赖管理：管理服务依赖关系，确保服务按正确顺序启动</li>
<li>日志记录：提供 journald 日志系统，收集和存储系统日志</li>
<li>设备和挂载管理：支持动态设备挂载和自动挂载</li>
<li>维护基本系统配置：管理系统主机名、日期、区域设置，维护已登录用户和网络时间同步等</li>
</ul>
<div class="broadcast color-yellow">
<div class="iconfont icon-dengpao14hao"></div>
systemd官网：<a target="_blank" rel="noopener" href="https://systemd.io/">https://systemd.io/</a></div>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h5><p>systemd 的配置文件路径是编译时指定的，用户无法修改，systemd所有的配置文件基本都存放在以下几个目录中，根据优先级顺序依次为：</p>
<ul>
<li><span class="strong">/etc/systemd/</span>：存放用户配置文件，<span class="tips">优先级最高</span>，如果其他目录中存在与该目录下的文件同名的配置文件，则该目录中的文件会覆盖其他路径中的同名文件</li>
<li><span class="strong">/run/systemd/</span>：运行时生成的配置文件目录，用于存放在运行时生成的单元文件等，<span class="tips">优先级次于用户配置文件</span>，通常由系统或服务动态创建</li>
<li><span class="strong">/usr/lib/systemd/(或 /lib/systemd/)</span>：系统提供的默认配置文件，<span class="tips">优先级最低</span>，方便用户覆盖</li>
</ul>
<p>除了以上目录外，用户还可以创建如/etc/systemd/*.conf.d/,/usr/lib/systemd/*.conf.d/等类似的drop-in配置子目录，这些drop-in将具有更高的优先级</p>
<h5 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h5><p>以上目录中通常同时包含多种不同类型的systemd配置文件，以<span class="tips">/etc/systemd/</span>为例，该目录下可能存在以下文件或目录：</p>
<ul>
<li>/etc/systemd/system.conf：系统级systemd配置文件，是systemd软件自身的配置文件，定义了很多影响 systemd 行为的全局设置。它控制系统级的资源管理、进程限制等</li>
<li>/etc/systemd/user.conf：用户级别的systemd配置文件，类似于 system.conf，该文件控制的是用户级别的服务行为</li>
<li>/etc/systemd/system/：存放全局的单元(Unit)文件，该目录中存放的单元文件通常是系统级的守护进程、服务、挂载单元、target单元、定时单元等，通常由管理员创建且需要root权限</li>
<li>/etc/systemd/user/：用于存放用户级别的单元文件，通常是一些仅在用户会话中运行的服务，不需要root权限</li>
<li>/etc/systemd/journald.conf：systemd日志系统journald的配置文件，用于定义日志的存储、大小、级别等参数</li>
<li>/etc/systemd/network/：该目录用于配置与网络相关的systemd 网络管理单元，包含网络接口配置文件(如静态IP配置)等</li>
<li>/etc/systemd/logind.conf：用于配置与systemd-logind相关服务，管理用户会话和登录等</li>
</ul>
<h5 id="配置文件语法"><a href="#配置文件语法" class="headerlink" title="配置文件语法"></a>配置文件语法</h5><p>systemd的配置文件语法参考了XDG Desktop Entry规范，而XDG的语法又受到Windows中.ini文件的影响，以下是systemd中各类配置文件的一些通用语法规则：</p>
<ul>
<li>配置文件都是纯文本文件，以<span class="tips">key=value</span>形式指定</li>
<li>空行和以<span class="tips">#</span>、<span class="tips">;</span>开头的文件会被忽略，因此这两个符号可用来写注释行</li>
<li>配置文件中，如果内容在一行中写不下，可以使用反斜杠<span class="tips">\</span>在下一行续写，systemd在读取时会将两行合并，并使用空格替换反斜杠。如果反斜杠后为注释行，则注释行会被忽略，systemd将合并注释行后的内容</li>
<li>配置文件中的布尔值可以以各种格式书写，如：1、yes、true、on等价；0、no、false、off等价</li>
<li>配置文件中的时间，不标注单位时默认以秒为单位，单位支持使用y(year,years)、M(months, month)、w(weeks, week)、d(days, day)、h(hours, hour, hr)、m(minutes, minute, min)、s(seconds, second, sec)、ms(msec)、us(usec)</li>
<li>配置文件支持使用C语言的转义字符</li>
</ul>
<h4 id="unit的类型"><a href="#unit的类型" class="headerlink" title="unit的类型"></a>unit的类型</h4><p>systemd将系统资源和服务抽象为各种单元(unit)，并使用单元配置文件来创建和管理单元，systemd一共提供了11种unit：</p>
<ul>
<li><span class="strong">Service unit</span> 用于定义和管理各类服务，如启动、停止、重启服务</li>
<li><span class="strong">Socket Unit</span> 用于管理网络或 FIFO管道，当有基于Socket的连接时自动启动对应的服务</li>
<li><span class="strong">Target unit</span> 将多个unit组合为一个组，进行统一的管理(开启、关闭、依赖等)</li>
<li><span class="strong">Mount Unit</span> 用于定义和管理挂载点</li>
<li><span class="strong">Automount Unit</span>用于自动挂载，通常与.mount 配合使用，仅在访问时才挂载资源</li>
<li><span class="strong">Path Unit</span> 用于监控文件或目录的状态变化，当条件满足时触发相关服务</li>
<li><span class="strong">Slice Unit</span> 切片单元，用于对一组进程进行系统资源的分配与限制</li>
<li><span class="strong">Scope Unit</span> 与service类似，但Scope是由systemd根据 D-bus 接口接收到的信息自动创建，通常用于管理非 Systemd启动的外部进程</li>
<li><span class="strong">Device Unit</span> 用于表示系统中的硬件设备</li>
<li><span class="strong">Swap Unit</span> 用于管理交换分区或交换文件</li>
<li><span class="strong">Timer Unit</span> 定时器，用来替代传统的crond等，以执行定时任务</li>
</ul>
<h4 id="unit的状态"><a href="#unit的状态" class="headerlink" title="unit的状态"></a>unit的状态</h4><p>系统中的unit通常可以处于以下状态，各种单元类型可能会在此基础之上具有许多额外的子状态</p>
<ul>
<li>active 活动状态，表示单元已经启动、激活等</li>
<li>inactive 停止</li>
<li>activating 正在启动</li>
<li>deactivating 正在停止</li>
<li>failed  失败</li>
<li>maintenance  单元已停止，且在进行维护操作</li>
<li>reloading 正在重新加载其配置</li>
</ul>
<h3 id="unit单元文件"><a href="#unit单元文件" class="headerlink" title="unit单元文件"></a>unit单元文件</h3><h4 id="单元文件路径"><a href="#单元文件路径" class="headerlink" title="单元文件路径"></a>单元文件路径</h4><p>unit单元文件目录位于systemd配置文件路径下，根据优先级顺序依次为：</p>
<ul>
<li><span class="strong">/etc/systemd/system/</span>：存放系统级单元文件，<span class="tips">优先级最高</span>，如果其他目录存在与系统单元文件同名的文件，则该目录中的文件会覆盖其他路径中的同名文件</li>
<li><span class="strong">/run/systemd/system/</span>：运行时生成的配置文件目录，用于存放在运行时生成的单元文件，<span class="tips">优先级次于用户配置文件</span>，通常由系统或服务动态创建</li>
<li><span class="strong">/usr/lib/systemd/system/(或 /lib/systemd/system/)</span>：系统提供的默认单元文件，<span class="tips">优先级较低</span>，通常由软件包管理器安装配置</li>
</ul>
<p>system目录用来存放系级单元文件，该路径下还存在user目录，如果需要存放用户单元文件，只需要将以上路径中的system改为user即可，单元文件名需要遵守以下规则：</p>
<ul>
<li>单元文件名前缀可以包含字母、数字和-._:\符号</li>
<li>必须包含单元类型后缀，如：game-start.service</li>
</ul>
<h4 id="Unit-块"><a href="#Unit-块" class="headerlink" title="[Unit]块"></a>[Unit]块</h4><p>[Unit]部分用来书写单元的通用信息，且所有类型的单元文件都会有该块，只列出了部分配置项，完整的[unit]块配置请参考：</p>
<div class="broadcast color-pink">
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html">https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html</a>
</div>

<ul>
<li><p><span class="strong">Description=</span><br>指定对该单元的简短描述，根据官方文档，这里的属性虽然是Description，但所指定的字符串应该是对该单元功能或身份的简洁”标识”或”标签”，方便用户快速识别，而不是详细描述它，如果需要详细描述，应该写在Documentation字段指向的外部文档中。Description所指定的字符串，systemcted会在状态消息中(如执行 systemctl status时)显示该字符串(因此应该开头大写)，如：Description=Nginx Web Server，systemd将在启动nginx时显示Starting Nginx Web Server</p>
</li>
<li><p><span class="strong">Documentation=</span><br>该单元以及其配置文件的相关文档，可以指定多个URI(可以是URL或URN)，使用空格进行分隔。这里的URI仅支持”http://“、”https://“、”file：”、”info：”、”man：” 类型的 URI，如：man:command(6)</p>
</li>
<li><p><span class="strong">Wants=</span><br>指定该单元的弱依赖单元，即使依赖单元启动失败，该单元仍会继续运行。此选项可以多次指定，也可以在一个选项中指定多个空格分隔的单位。注意，该选项配置的依赖关系不会影响服务的启动顺序，通常情况下，依赖单元和当前单元会同时启动。向单元文件附带的 .wants/ 目录添加单元的符号链接等同于在该配置项中添加单元。</p>
</li>
<li><p><span class="strong">Requires=</span><br>指定该单元的强依赖单元，该单位启动时，也将启动该选项配置的这些单元。如果依赖单元启动失败、中途被”显式”停止或重启，该单元也将相应地启动失败、停止、重启。但这并不意味着当此单元运行时，另一个单元必须始终处于活动状态，如：单元启动成功后，某些依赖单元完成使命正常退出，这将不会影响到当前的单元。向单元文件附带的 .requires/ 目录添加单元的符号链接等同于在该配置项中添加单元。</p>
</li>
<li><p><span class="strong">Requisite=</span><br>类似于requires，但是，该选项配置的是当前单元运行的必要前提条件，即当前单元运行前，这些单元必须已经运行，如果该选项指定的单元未启动，systemd将不再尝试启动当前单元，而将直接判定启动失败。因此，该设置通常与 After= 结合使用，以确保当前单元不会在Requisite配置的单元之前启动</p>
</li>
<li><p><span class="strong">BindsTo=</span><br>类似于requires，但BindsTo所绑定的依赖关系更强，除了拥有requires的特点外，BindsTo会将当前单元的生命周期绑定到依赖单元，当前单元的运行严格依赖于依赖单元的存续。BindsTo所绑定的单元如果停止，则当前单元也将停止。该配置项用于需要紧密关联的单元，例如一个服务与其挂载点的绑定，如果挂载点被卸载或停止，当前服务也停止</p>
</li>
<li><p><span class="strong">Upholds=</span><br>类似于Wants，但不同点在于，当前单元对Wants所指定单元的依赖是一次性的，systemd只会在启动当前单元时尝试启动Wants中指定的依赖，后续这些依赖是否停止，systemd都不再关心。而当前单元对Upholds所指定单元的依赖是持续性的，如果后续当前单元还在运行，而Upholds单元中途停止，systemd将不断尝试重启它们，即便它们不是强依赖单元。</p>
</li>
<li><p><span class="strong">Conflicts=</span><br>指定冲突单元，表示两个单元之间存在冲突关系，不能同时运行。如：假设A.service的配置文件中配置了Conflicts=B.service，则在启动A时，如果B正在运行，将关闭B。同样，如果启动B时，A正在运行，则将关闭A，即时B的配置中未显式声明Conflicts=A。注意，Conflicts同样不会指定服务的启动或关闭顺序，如果需要确保在启动A单元之前，先停止B单元，需要显式添加After或Before配置</p>
</li>
<li><p><span class="strong">Before=</span><br>定义单元的启动顺序，表示当前单元必须在Before所指定的单元之前启动，关闭时必须在这些单元之后关闭。如：A的配置文件配置了Before=B，则A必须在B之前启动，在B之后关闭。</p>
</li>
<li><p><span class="strong">After=</span><br>定义单元的启动顺序，表示当前单元必须在After所指定的单元之后启动，关闭时必须在这些单元之前关闭。如：A的配置文件配置了After=B，则A必须在B之后启动，在B之前关闭。</p>
</li>
<li><p><span class="strong">ConditionPathExists=</span><br>检查所指定的路径和文件是否存在，如果指定的绝对路径名不存在，将停止启动单元。可以在路径前加上一个<span class="tips">!</span>，表示当该文件不存在时，才启动该单元</p>
</li>
</ul>
<h4 id="Install-块"><a href="#Install-块" class="headerlink" title="[Install]块"></a>[Install]块</h4><p>[Install]块用于配置单元的安装和启用信息，</p>
<div class="broadcast color-green">
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options">https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options</a></div>

<ul>
<li><p><span class="strong">Alias=</span><br>定义单元的别名，<span class="tips">该别名必须与原单元文件名具有相同的后缀(即type)</span>，可以指定多个别名，空格分隔。指定了别名后，在使用systemctl enable开机自启用单元时，将在<span class="tips">/etc/systemd/system</span>对应目录中创建一个符号链接并指向<span class="tips">/usr/lib/systemd/system</span>目录中的原单元文件，此后，用户可以通过这些别名启动服务</p>
</li>
<li><p><span class="strong">WantedBy=</span><br>指定当前单元希望被哪些单元作为依赖使用(弱依赖)，可以指定多个值，空格分隔。指定了值后，当通过 systemctl enable 命令安装当前单元时(开机自启动)，将会在这些WantedBy所指定的每一个单元的<span class="tips">.wants/</span> 目录中创建一个当前单元的符号链接。这里通常会指定一个target类型的单元值，即指定当前单元在哪种Linux开机模式下会被启动，如：在服务A的配置文件中添加WantedBy　=　multi-user.target，则在执行systemctl enable A.service启用A单元后，systemd将在/etc/systemd/system/multi-user.target.wants目录中创建一个符号链接A.service，该符号链接指向/usr/lib/systemd/system/A.service，表示A服务会在Linux以常规多用户模式启动时开机自启动。当然配置的值也可以是其他unit类型，如：在服务A的配置文件中添加WantedBy　=　B.service，则A的符号链接将被添加到B.service.wants目录中，表示启动服务B时，希望启动A。指定服务依赖的功能和[Unit]块中的wants有点类似，不同点在于：</p>
<blockquote>
<blockquote>
<ul>
<li>Wants指定当前单元需要哪些依赖，WantedBy指定当前单元是其他单元的依赖</li>
<li>Wants指定单元运行时的依赖关系，单元的设置会在启动或加载时立即生效；WantedBy定义单元安装时依赖关系，需要使用 systemctl enable 使其生效</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<ul>
<li><p><span class="strong">RequiredBy=</span><br>指定当前单元必须被哪些单元作为依赖使用(强依赖)，这意味着当前单元的运行失败，将影响到其他单元的运行。用法与WantedBy类似，这里所指定的每一个单元，它们的<span class="tips">.Requires/</span>目录中将有可能被添加当前单元的符号链接(取决于当前单元是否开机自启动)</p>
</li>
<li><p><span class="strong">UpheldBy=</span><br>指定当前单元是哪些单元的维持性依赖，具体的依赖关系参考[Unit]块的Upholds，用法与WantedBy类似，但它没有类似的.Uphold目录，用于动态维持目标状态，使用场景较少</p>
</li>
<li><p><span class="strong">Also=</span><br>当使用systemctl enable 或 systemctl disable命令安装/卸载当前单元时，需要一起安装/卸载的其他单元，可以指定多个值，空格分隔</p>
</li>
</ul>
<h3 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h3><h4 id="Service-块"><a href="#Service-块" class="headerlink" title="[Service]块"></a>[Service]块</h4><p>[Service]块是service类型的单元文件专属块，也是必须块，[service]块的配置可参考:</p>
<div class="broadcast color-yellow">
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html">systemd.service — Service unit configuration</a>
</div>

<ul>
<li><p><span class="strong">Type=</span><br>用于定义服务的启动类型，指定systemd 如何识别服务的启动完成状态以及如何管理服务的主进程，它支持以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">simple</span>：systemd在启动服务时，会fork()一个systemd服务管理子进程，然后在子进程中运行该服务。当指定Type=simple时，systemd服务管理器会在fork()结束后立即返回服务已经启动的状态，即便此时服务的二进制文件还未真正执行，甚至可能会执行失败(如权限不足)，因此该值可能具有一些潜在风险(如systemctl start命令错误返回服务启动状态，systemd因为识别服务已经启动而继续启动其他依赖造成启动顺序错误)，该值适用于一些简单的单进程服务或脚本。当指定了 ExecStart= 但未指定 Type= 和 BusName=时，该值是默认值</li>
<li><span class="strong">exec</span>：类似于simple，但systemd服务管理器会等到fork()结束且服务的二进制文件被执行后才返回服务已启动的状态，因此该值不会存在二进制文件执行失败，但systemd识别为服务已经启动的情况。如果二进制文件执行失败，systemctl start 命令将正确报告服务启动失败状态。建议对长时间运行的服务使用 Type=exec</li>
<li><span class="strong">oneshot</span>：类似于simple，但oneshot表示该服务是一次性的短期任务，systemd会在该服务成功执行并退出后才视为服务启动完毕，然后开始执行后续任务。该类型适合用来配置哪些需要前期迅速执行完毕，为后续任务铺设环境的一次性任务，如初始化脚本、配置加载、清理上次登录的临时文件等任务。该选项通常需要配合 RemainAfterExit=true 配置项，来让systemd在返回其状态时返回值为”active”，否则，由于该服务会在执行完毕后退出，会导致其状态会直接从”activating”跳到”dead”或”deactivating”。当Type=和ExecStart=配置均未指定时，systemd将默认指定Type=oneshot</li>
<li><span class="strong">dbus</span>：dbus的行为类似于simple，但这种类型的单元必须指定 BusName= 配置，相反，如果指定了BusName=的值而未指定Type，则默认为Type=dbus。服务通过D-Bus总线注册完成后，systemd才会认为它已启动，该类型适用于基于D-Bus的服务</li>
<li><span class="strong">notify</span>：notify的行为类似于exec，不同之处在于服务在完成启动时会通过 sd_notify()或其他兼容的库的类似调用向systemd 发送”READY=1”消息，来告诉systemd当前服务已经启动完成。systemd会等待通知消息后再认为服务已启动。适用于需要执行一些初始化工作后，明确通知启动完成的服务</li>
<li><span class="strong">idle</span>：类似于simple，但服务的启动会延迟到所有其他任务完成后再运行，避免服务启动时，shell的输出混乱。该值仅用于避免控制台输出混乱，不用作通用的unit启动排序工具，因此服务启动延迟时间限制为5s，超时后无论如何都会启动服务。可用于非关键任务，让它们系统启动完成后再启动</li>
<li><span class="strong">forking</span>：服务会通过父进程创建子进程(fork)的方式运行，并且父进程会退出，子进程作为服务的主进程。这是传统UNIX守护进程设计模式的一种方式，当一个进程启动时，通常会绑定到启动它的终端tty，如果终端关闭，进程可能会受到 SIGHUP 信号的影响而退出，因此传统的守护进程(daemon)设计时，会先启动一个父进程，然后通过fork()创建子进程，然后父进程退出，子进程作为主进程继续运行。此时子进程可以在一个相对干净的环境中运行，且脱离了终端控制，成为孤儿进程并交由systemd接管。当Type=forking时，systemd会在父进程退出时，视为服务启动完成，由于这是传统UNIX的设计，因此对于现代项目，文档不建议使用此类型，而是建议改用 notify、notify-reload 或 dbus。如果一定要用该类型，建议同时PIDFile= 选项一起使用，以便 systemd 能够可靠地识别服务的主进程</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">ExitType=</span><br>指定退出类型，告诉systemd服务管理器何时认为当前unit已经关闭，有以下两个取值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">main</span>：默认值，当服务主进程退出时，认为该单元已经停止。由于oneshot类型的服务是在主进程退出后才视为服务开始启动，因此该值不能与Type=oneshot 一起使用，</li>
<li><span class="strong">cgroup</span>：只要 cgroup 中至少有一个进程尚未退出，该服务就会被视为正在运行</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">ExecStart=</span><br>启动服务时执行的命令，如果服务类型Type是oneshot，可以指定多个命令，否则<span class="text-red">只能指定一个命令！</span>通过该命令启动的进程将被视为守护进程的主进程(Type=forking的服务除外，因为此时子进程才是主进程)。当Type=oneshot时，可以指定多个要执行的命令，空格分隔，systemd会依次执行它们，如果其中一个命令失败，则该单元会被视为启动失败。可以在命令前添加”-“，则此时即便该命令执行失败，systemd也会继续执行后续命令，且不会视为单元启动失败。</p>
</li>
<li><p><span class="strong">RemainAfterExit=</span><br>一个boolean值，该值指定是否应将服务视为活动状态，即使其所有进程都已退出，默认为 no，通常Type=oneshot会用到该配置项</p>
</li>
<li><p><span class="strong">PIDFile=</span><br>指定一个PID文件路径，通常是/run目录下的路径，该配置项通常用来搭配Type=forking配置，以此告诉systemd服务管理器从该PID文件中读取服务主进程的PID，文档建议现代项目中尽量少使用</p>
</li>
<li><p><span class="strong">BusName=</span><br>指定服务应使用的D-Bus目标名称，该配置项是Type=dbus时的必须配置</p>
</li>
<li><p><span class="strong">ExecStartPre=</span><br>在 ExecStart= 所指定的命令执行前执行的其他命令。语法与 ExecStart= 相同，但允许指定多个命令，命令会依次执行。这些命令中任何一个命令(不以”-“前缀)执行失败，都将不再执行后续命令，并视为该单元启动失败。ExecStart所指定的命令只会在ExecStartPre所指定的所有命令(不以”-“前缀)成功退出后才开始执行</p>
</li>
<li><p><span class="strong">ExecStartPost=</span><br>在 ExecStart= 所指定的命令执行后执行的其他命令。语法与 ExecStart= 相同，但允许指定多个命令，命令会依次执行。这些命令中任何一个命令(不以”-“前缀)执行失败，都将不再执行后续命令，并视为该单元启动失败。ExecStartPost所指定的命令只会在ExecStart所指定命令成功启动后执行，具体执行时间取决于systemd何时收到服务启动通知，具体参考Type配置项各类型的服务何时视为启动成功</p>
</li>
<li><p><span class="strong">ExecReload=</span><br>服务的配置被重新加载时需要执行的命令，可以指定多个命令，遵循与ExecStart=相同的配置方案</p>
</li>
<li><p><span class="strong">ExecStop=</span><br>指定停止当前服务时用户需要输入的命令，该配置遵循与ExecStart=相同的配置方案，该配置项是可选的，如果没有设置该配置，则服务停止时，将通过发送 KillSignal= 或 RestartKillSignal= 中指定的信号来终止进程。</p>
</li>
<li><p><span class="strong">ExecStopPost=</span><br>在服务停止后执行的其他命令，服务停止的方式可以是通过执行ExecStop所指定的命令、启动失败停止、服务意外退出、收到系统信号终止等，这些都会触发systemd执行ExecStopPost所指定的命令。该配置项常用来设置一些服务停止后的清理工作，或者服务启动失败时，清理不完整的初始化数据</p>
</li>
<li><p><span class="strong">RestartSec=</span><br>指定重新启动服务之前的休眠时间，可以直接指定一个数值(单位为秒)，也可以是时间跨度(如：5min 20s)，默认为100ms</p>
</li>
<li><p><span class="strong">Restart=</span><br>配置在服务进程退出(exit)、终止(kill)或达到超时(timeout)时是否应重新启动服务，支持以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">no</span>：默认值，不重启服务</li>
<li><span class="strong">on-success</span>：仅当服务服务正常退出(退出代码是零)时才重启</li>
<li><span class="strong">on-failure</span>：服务因非零退出代码或异常信号失败时重启</li>
<li><span class="strong">on-abnormal</span>：服务因异常信号(如：SIGKILL、SIGSEGV等)终止时会重启</li>
<li><span class="strong">on-watchdog</span>：服务因看门狗超时被杀死时会重启，适用于需要高可靠性的服务，并启用了看门狗功能。systemd中，看门狗是用来监控服务或进程是否正常运行的进程，服务需要每隔一段时间就向看门狗发送一个报告，来表示服务在正常运行，如果超时时间内没有报告，systemd会认为服务卡住或挂起，然后会尝试重启或唤醒服务</li>
<li><span class="strong">on-abort</span>：服务因收到 SIGABRT信号终止时会重启，适用于需要响应服务主动触发中止操作的场景</li>
<li><span class="strong">always</span>：无论服务如何退出（成功、失败或异常），都进行重启</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<div class="broadcast color-pink">
<div class="iconfont icon-yinle1"></div>
以下配置项也可以写于[service]块中以指定执行环境，参考文档：
<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html">systemd.exec — Execution environment configuration</a></div>

<ul>
<li><p><span class="strong">StandardInput=</span><br>控制标准输入连接到何处，可取以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">null</span>：(默认)连接到/dev/null，进程的所有读取尝试都将导致立即 EOF</li>
<li><span class="strong">tty</span>：连接到 TTY，通常还需要用TTYPath指定tty的挂载路径</li>
<li><span class="strong">file:绝对路径</span>：连接到该文件</li>
<li><span class="strong">data</span>：传递一段文本或二进制数据给当前服务，传递内容通过StandardInputText=/StandardInputData=指定</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">StandardOutput=</span><br>控制标准输出连接到何处，可取以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">inherit</span>：将标准输入的文件描述符复制给标准输出</li>
<li><span class="strong">null</span>：连接到 /dev/null，丢弃所有输出</li>
<li><span class="strong">tty</span>：连接到 TTY，通常还需要用TTYPath指定tty的挂载路径</li>
<li><span class="strong">journal</span>：(默认)连接到journal日志</li>
<li><span class="strong">kmsg</span>：连接到内核日志缓冲区</li>
<li><span class="strong">journal+console</span>：连接到日志并输出一份到控制台</li>
<li><span class="strong">file:绝对路径</span>：连接到该文件</li>
<li><span class="strong">append:绝对路径</span>：以附加形式连接到该文件</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">StandardError=</span><br>控制标准错误输出连接到何处，可取与StandardOutput相似</p>
</li>
<li><p><span class="strong">StandardInputText=, StandardInputData=</span><br>指定一段文本或二进制数据，通过标准输入传递给当前服务，需要指定 StandardInput=data，否则该配置项不生效</p>
</li>
</ul>
<h4 id="service配置案例"><a href="#service配置案例" class="headerlink" title="service配置案例"></a>service配置案例</h4><div class="shell">e.g.Nginx的配置
[Unit]
Description=The NGINX HTTP and reverse proxy server
After=network.target</br>
[Service]
Type=forking
ExecStart=/usr/sbin/nginx
ExecReload=/usr/sbin/nginx -s reload
ExecStop=/usr/sbin/nginx -s stop
PIDFile=/run/nginx.pid
PrivateTmp=true</br>
[Install]
WantedBy=multi-user.target
</div>

<div class="show">写一个shell脚本，通过systemd管理，要求：
testA.sh的输出信息输出到终端而不是日志，testA.sh执行前输出启动提示文本
testA.sh弱依赖testB.sh
testB.sh的输出信息输出到日志
1.编写/myShell/testA.sh内容
#!/bin/bash
echo "脚本A开始执行"
sleep 5
echo "脚本A执行完毕"
2.编写/myShell/testB.sh内容
#!/bin/bash
echo "脚本B开始执行"
sleep 3
echo "脚本B执行完毕"
3.赋予脚本可执行权限
chmod +x testA.sh testB.sh
4.编写/etc/systemd/system/testA.service内容
[Unit]
Description=test A service
Wants=testB.service<br>
[Service]
Type=oneshot  #simple类型不会等待脚本执行完毕返回，oneshot则会等待脚本执行
ExecStart=/myShell/testA.sh
StandardOutput=tty
StandardError=tty
TTYPath=/dev/pts/0
ExecStartPre=/bin/echo "服务A启动"
5.编写/etc/systemd/system/testB.service内容
[Unit]
Description=test B service<br>
[Service]
Type=simple
ExecStart=/myShell/testB.sh
6.让systemd重新加载配置
systemctl daemon-reload
7.执行testA服务
systemctl start testA
</div>


<h3 id="Target类型"><a href="#Target类型" class="headerlink" title="Target类型"></a>Target类型</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>target 是一种特殊的单元类型，用于将多个相关的服务或单元组合到一起，然后一次性启动或关闭，这样就不需要手动一个个启动这些单元了。systemd预定义了一些target类型的单元，用于在特定情况启动(如：插入声卡、连接蓝牙时)，其中包括一些系统关闭或启动时会执行的单元，这些target类型的单元对应传统的 SysV 运行级别(runlevel)，用户也可以自行创建并配置target单元</p>
<p>target类型的Unit单元配置文件仅支持[Unit] 和 [Install]配置块，不存在专属[Target]块</p>
<h4 id="运行级别与预定义Target"><a href="#运行级别与预定义Target" class="headerlink" title="运行级别与预定义Target"></a>运行级别与预定义Target</h4><div class="table">

<table>
<thead>
<tr>
<th>运行级别(runlevel)</th>
<th>systemd target(target别名)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>poweroff.target(runlevel0.target)</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>rescue.target(runlevel1.target)</td>
<td>单用户状态，只启动系统核心，用于系统修复和维护</td>
</tr>
<tr>
<td>2</td>
<td>multi-user.target(runlevel2.target)</td>
<td>多用户状态，禁用NFS(网络文件系统)和网络服务，可用于停机维护</td>
</tr>
<tr>
<td>3</td>
<td>multi-user.target(runlevel3.target)</td>
<td>完全多用户状态，具有完整的功能</td>
</tr>
<tr>
<td>4</td>
<td>无</td>
<td>系统未使用，保留</td>
</tr>
<tr>
<td>5</td>
<td>graphical.target(runlevel5.target)</td>
<td>GUI模式，桌面版Linux专属</td>
</tr>
<tr>
<td>6</td>
<td>reboot.target(runlevel6.target)</td>
<td>系统重启</td>
</tr>
</tbody></table>
</div>

<div class="broadcast color-pink">
查看更多预定义的target：<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd.special.html">systemd.special — Special systemd units
</a>
</div>

<h4 id="target常用命令"><a href="#target常用命令" class="headerlink" title="target常用命令"></a>target常用命令</h4><ul>
<li><p><span class="strong">systemctl isolate target名</span>临时切换到该target(可以实现临时切换运行级别)</p>
</li>
<li><p><span class="strong">systemctl set-default target名</span>设置默认目标(持久化修改开机运行级别)</p>
</li>
</ul>
<h4 id="开机自启动与target"><a href="#开机自启动与target" class="headerlink" title="开机自启动与target"></a>开机自启动与target</h4><p>当用户执行<span class="tips">systemctl enable unit名</span>设置单元开机自启动时，systemd会在<span class="tips">/etc/systemd/system/multi-user.target.wants/</span>(假设当前开机默认启动target为multi-user.target)中创建一个该单元文件的符号链接，这样就实现了开机启动该单元的功能。相反，当用户执行<span class="tips">systemctl disable unit名</span>来禁止单元开机自启动时，systemd会删除<span class="tips">/etc/systemd/system/multi-user.target.wants/unit名 </span>符号链接，从而阻止其在系统启动时自动启动。</p>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>systemctl是systemd的提供的主要命令行工具，用来通过统一的接口来管理系统的各项服务，调用systemctl时会默认使用<span class="tips">-&zwnj;-system</span>选项，用于管理系统级单元，这可能需要root权限。如果需要管理用户级单元，应该显式指定<span class="strong">systemctl -&zwnj;-user</span></p>
<h4 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h4><p>在systemd被广泛运用到各发行版中后，Linux中传统的系统管理命令(如：halt、poweroff、reboot等)通常会调用systemd 提供的命令，如：执行 halt 实际上会调用 systemctl halt命令</p>
<ul>
<li><div class="strong">systemctl is-system-running</div>
检查系统是否正常运行，是则返回0，如果系统处于正在启动、维护、关闭状态，或者有失败的启动服务时，返回非零值</li>
<li><span class="strong">systemctl default</span>进入默认模式</li>
<li><span class="strong">systemctl rescue</span>进入救援模式</li>
<li><span class="strong">systemctl emergency</span>进入紧急模式</li>
<li><span class="strong">systemctl halt</span>关闭系统，但保持硬件的开机状态</li>
<li><span class="strong">systemctl poweroff</span>关闭系统并关闭系统电源</li>
<li><span class="strong">systemctl reboot</span>重启系统</li>
<li><span class="strong">systemctl soft-reboot</span>软重启，重新启动用户空间</li>
<li><div class="strong">systemctl suspend</div>挂起(暂停)系统，系统会将当前的会话状态(如打开的应用程序和文件)保存在内存中，并将设备置于低功耗状态</li>
<li><div class="strong">systemctl hibernate</div>
进入休眠状态，休眠模式会将系统的当前状态保存到硬盘(通常是交换分区或交换文件)，然后完全关闭电源，下次开机将从硬盘恢复系统状态</li>
<li><div class="strong">systemctl hybrid-sleep</div>
进入混合睡眠状态，该状态下，系统首先将当前会话状态保存在内存中，并备份一份到硬盘，然后将设备置于低功耗状态。如果之后系统正常唤醒，直接从内存加载数据。如果系统意外关闭(例如电源耗尽)，用户也可以从硬盘恢复数据</li>
<li><div class="strong">systemctl suspend-then-hibernate</div>挂起后休眠，在这种模式下，系统首先进入挂起状态(suspend)，将当前会话的状态保存在内存中，在一定时间后(通常是系统设置的超时设置)，如果没有用户活动，系统会自动切换到休眠状态(hibernate)，将会话状态保存到硬盘中并完全关闭电源，此模式适合用户需要短时间内离开电脑，但又希望在长时间未使用时确保数据安全的状况</li>
<li><div class="strong">systemctl sleep</div>进入睡眠状态，sleep模式在不同发行版中设置可能有所不同，可能执行suspend、hibernate、hybrid-sleep、suspend-then-hibernate中的任意一种，默认情况下，通常可能为suspend-then-hibernate</li>
</ul>
<div class="broadcast color-purple">
<div class="iconfont icon-fengche"></div>
详细文档：<a href="
https://www.freedesktop.org/software/systemd/man/latest/systemctl.html#System%20Commands">
https://www.freedesktop.org/software/systemd/man/latest/systemctl.html#System%20Commands</a></div>

<h4 id="查看系统状态"><a href="#查看系统状态" class="headerlink" title="查看系统状态"></a>查看系统状态</h4><ul>
<li><p><span class="strong">systemctl status</span>查看系统状态</p>
</li>
<li><p><span class="strong">systemctl -&zwnj;-failed</span>列出失败的单元</p>
</li>
<li><p><span class="strong">systemctl list-unit-files</span>列出已经安装的单元</p>
</li>
<li><p><span class="strong">systemctl status PID值</span>查看对应PID进程的状态</p>
</li>
<li><p><span class="strong">systemctl daemon-reload</span>重新加载systemd单元配置，扫描单元变动</p>
</li>
</ul>
<h4 id="单元管理命令"><a href="#单元管理命令" class="headerlink" title="单元管理命令"></a>单元管理命令</h4><p><span class="strong">systemctl [选项] 命令 单元名/模式</span></p>
<ul>
<li>-t unit类型(-&zwnj;-type=unit类型)：在列出unit单元信息时，默认会列出所有类型的单元，通过该选项可以指定只列出某几个类型的单元</li>
<li>-&zwnj;-state=状态：在列出unit单元信息时，默认会列出所有状态的单元，通过该选项可以指定只列出处于所指定状态的单元</li>
<li>-p 属性名(-&zwnj;-property=属性名)：显式属性时，默认显式所有属性，该选项可以用来指定只显示所指定的1个或多个属性</li>
<li>该命令中的单元名，可以使用模式(PATTERN)来匹配多个单元(模式支持使用<span class="tips">*</span>和<span class="tips">?</span>，也支持使用<span class="tips">[]</span>匹配字符范围)，也可以是具体的单元名，当指定具体单元名时，需要指定其完整的单元名，包括扩展名(如：sshd.socket)，以下情况可以省略扩展名：<blockquote>
<blockquote>
<ul>
<li>如果不指定拓展名，systemctl会默认扩展名为<span class="tips">.service</span>，因此如果操作对象的unit类型为service，可以不指定拓展名</li>
<li>挂载点会自动指定为<span class="tips">.mount</span>单元，如：<span class="tips">/home</span>等价于<span class="tips">home.mount</span></li>
<li>设备会自动指定为<span class="tips">.device</span>单元，如：<span class="tips">/dev/sda2</span>等价于<span class="tips">dev-sda2.device</span></li>
<li>某些命令只能用来处理特定类型的单元，此时可以省略单元类型，如：systemctl isolate默认单元类型为target</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="常用的单元管理命令"><a href="#常用的单元管理命令" class="headerlink" title="常用的单元管理命令"></a>常用的单元管理命令</h4><div class="table">

<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span class="strong">systemctl status 单元名或PID</span>单元名</td>
<td>查看单元或PID所属单元状态</td>
</tr>
<tr>
<td><span class="strong">systemctl start</span>单元名</td>
<td>启动单元，只能启动已经被systemd加载的单元</td>
</tr>
<tr>
<td><span class="strong">systemctl stop</span>单元名</td>
<td>停止单元</td>
</tr>
<tr>
<td><span class="strong">systemctl restart</span>单元名</td>
<td>重启单元，如果单元未启动，则启动单元</td>
</tr>
<tr>
<td>systemctl try-restart 单元名</td>
<td>重启已启动的单元，如果单元未启动，则不做任何操作</td>
</tr>
<tr>
<td><span class="strong">systemctl reload</span>单元名</td>
<td>让该单元重新加载其配置</td>
</tr>
<tr>
<td>systemctl reload-or-restart 单元名</td>
<td>尝试让单元重新加载其配置，如果加载失败，则尝试重启它。如果指定的单元尚未启动，则启动它</td>
</tr>
<tr>
<td>systemctl try-reload-or-restart  单元名</td>
<td>尝试让单元重新加载其配置，如果加载失败，则尝试重启它。如果指定的单元尚未启动，则不做任何操作</td>
</tr>
<tr>
<td><span class="strong">systemctl enable</span>单元名</td>
<td>开机自启动该单元</td>
</tr>
<tr>
<td><span class="strong">systemctl disable</span>单元名</td>
<td>取消开机自启动</td>
</tr>
<tr>
<td><span class="strong">systemctl reenable</span>单元名</td>
<td>重新启用单元</td>
</tr>
<tr>
<td><span class="strong">systemctl mask</span>单元名</td>
<td>屏蔽单元，该单元将无法手动启动，也无法作为依赖启动</td>
</tr>
<tr>
<td><span class="strong">systemctl unmask</span>单元名</td>
<td>取消屏蔽单元</td>
</tr>
</tbody></table>
</table>
</div>

<h5 id="systemctl-status返回值"><a href="#systemctl-status返回值" class="headerlink" title="systemctl status返回值"></a>systemctl status返回值</h5><ul>
<li><span class="strong">systemctl status</span> [单元名或PID]<br>如果指定了单元，则显示指定单元的运行时状态信息，以及这些单元最近的日志数据。如果指定了PID，那么显示指定PID所属单元的运行状态信息，以及这些单元最近的日志数据，默认输出10行日志，且会截断超长的部分。如果未指定任何单元或PID，那么显示整个系统的状态信息，此时若与 -&zwnj;-all 连用，则同时显示所有已加载单元(可以用-t选项限定单元类型)的状态信息。该命令旨在生成人类可读的输出，如果需要输出方便脚本分析的信息，应该使用systemctl show命令</li>
</ul>
<div class="shell">systemctl status nginx命令的返回值：
<span style="color:#55ff55;">●</span> nginx.service -  Nginx is an HTTP(S) server, HTTP(S) reverse proxy and IMAP/POP3 proxy server
   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; preset: enabled)
   Active: <span style="color:#55ff55;">active (running)</span>  since Thu 2023-03-09 10:32:25 CST; 1 years 8 months ago
     Docs: man:nginx(8)
 Main PID: 8473 (nginx)
      CPU: 140ms
   CGroup: /system.slice/nginx.service
           ├─6205 nginx: worker process
           └─8473 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf

<p>Nov 18 10:15:42 server-name nginx[1234]: 2021/11/18 10:15:42 [error] 2345#0: *1 open() …<br>Nov 18 10:15:53 server-name nginx[1234]: 2021/11/18 10:15:42 [error] 2345#0: *1 open() …</p>
</div>

<div class="show">以nginx为例，systemctl status nginx命令返回值主要包括以下部分：
1. 第一行包含一个符号●，单元的名称，以及单元的简要描述
符号●会根据单元的状态修改颜色和形状：
"inactive"或"maintenance"是一个白色圆圈 ○
"active"是一个绿点 ●
"deactivating"是一个白点 ●
"failed"或"error"是一个红叉 ×
"reloading"是一个绿色的顺时针圆箭头 ↻
2. 第二行为单元Loaded状态，表示单元是否已经加载到了内存中
loaded 表示服务配置文件已加载
error 表示加载时出现问题
not-found 表示未找到该单元的单元配置
bad-setting 表示文件配置文件无法解析
masked 表示单元文件被屏蔽
/lib/systemd/system/nginx.service 为该单元文件路径
enabled 表示服务被设置为开机自启动(disabled表示开机不自启，static表示服务是动态加载的，通常由其他服务触发运行)
preset: enabled：预设值，表示服务被系统默认配置为启用
3. 第三行为单元运行状态
服务状态值通过颜色标识，绿色表示服务正常运行，黄色表示服务处于警告状态(例如未完全启动或有错误)，红色表示服务启动失败或停止
服务状态值通常为"active"或"inactive"，也可能为"activating"(正在启动)或"deactivating"(正在关闭)，如果为"failed"，表示单元可能因为崩溃、错误退出、超时等情况进入了失败状态
since之后表示服务启动时间，以及服务已经运行时间
4. 第四行为文档信息，man:nginx(8)表示nginx的文档在man的第8部分
5. 第五行为主进程信息，包含主进程PID，主进程的命令名称
6. 第六部分通常为资源使用情况，通常可能包含内存使用情况，CPU的占用时间
7. 第七部分为控制组信息，表示该服务所属的 cgroup 路径
8. 第八部分为日志的部分信息
</div>

<h4 id="单元状态查询命令"><a href="#单元状态查询命令" class="headerlink" title="单元状态查询命令"></a>单元状态查询命令</h4><ul>
<li><p><span class="strong">systemctl 或 systemctl list-units </span> 单元名<br>列出systemd已经加载的单元，默认列出处于活动、失败状态和正在处于任务队列的单元，使用-&zwnj;-all选项可以列出所有单元，可以使用-&zwnj;-type选项和-&zwnj;-state选项过滤要列出的单元</p>
</li>
<li><p><span class="strong">systemctl list-sockets [PATTERN]</span> 单元名<br>列出已加载的套接字(socket)单元，并按照监听地址排序。使用-&zwnj;-show-types选项可以显示套接字类型，支持-&zwnj;-all和-&zwnj;-state选项<br><span class="strong">systemctl list-timers [PATTERN]</span><br>列出已加载的定时器(timer)单元，并按照下次执行的时间点排序，支持-&zwnj;-all和-&zwnj;-state选项</p>
</li>
<li><p><span class="strong">systemctl is-active</span> 单元名<br>检查指定的单元中，是否有处于活动(active)状态的单元。如果存在至少一个处于活动(active)状态的单元，返回状态0，否则返回非零值。命令还会在标准输出打印单元状态，使用-&zwnj;-quiet选项可以禁止该输出</p>
</li>
<li><p><span class="strong">systemctl is-failed</span> 单元名<br>检查指定的单元中，是否有处于失败(failed)状态的单元。如果存在至少一个处于失败(failed)状态的单元，返回状态0，否则返回非零值。命令还会在标准输出打印单元状态，使用-&zwnj;-quiet选项可以禁止该输出</p>
</li>
<li><p><span class="strong">systemctl show</span> [单元名或JOB]<br>以”属性=值”的形式显示指定单元或任务的所有属性。单元用其名称表示，而任务则用其id表示。如果没有指定任何单元或任务，那么显示管理器(systemd)自身的属性。默认不显示属性值为空的属性，使用-&zwnj;-all选项可以显示所有属性。可以使用-&zwnj;-property选项可以仅显示特定的属性</p>
</li>
<li><p><span class="strong">systemctl cat</span> 单元名<br>显示指定单元的单元文件内容，首行会显示该单元文件的绝对路径</p>
</li>
<li><p><span class="strong">systemctl set-property</span> 属性名 值<br>在运行时修改单元的属性值，主要用于修改单元的资源控制属性值而无需直接修改单元文件，并非所有属性都可以在运行时被修改。 作修改会立即生效，并永久保存在磁盘上，以确保永远有效。如果使用了 -&zwnj;-runtime选项，那么此修改仅临时有效，下次重启此单元后，将会恢复到原有的设置。设置属性的语法与单元文件中的写法相同。如：systemctl set-property foobar.service CPUShares=777，可以同时修改多个属性值，只需依次将各个属性用空格分隔即可。</p>
</li>
<li><p><span class="strong">systemctl list-dependencies</span> [单元名]<br>显示单元的依赖关系，即显示由 Requires=, Requisite=, ConsistsOf=, Wants=, BindsTo= 所形成的依赖关系。如果没有明确指定单元的名称，那么表示显示default.target的依赖关系树。默认情况下，仅以递归方式显示 target 单元的依赖关系树，而对于其他类型的单元，仅显示一层依赖关系(不递归)。 但如果使用了-&zwnj;-all 选项，那么将对所有类型的单元都强制递归的显示完整的依赖关系树。还可以使用 -&zwnj;-reverse, -&zwnj;-after, -&zwnj;-before 选项指定仅显示特定类型的依赖关系</p>
</li>
</ul>
<h3 id="systemd-journald"><a href="#systemd-journald" class="headerlink" title="systemd-journald"></a>systemd-journald</h3><p>systemd-journald是systemd内置的日志收集和存储服务</p>
<h4 id="日志文件存储路径"><a href="#日志文件存储路径" class="headerlink" title="日志文件存储路径"></a>日志文件存储路径</h4><p>systemd-journald保存日志的方式有两种：<span class="tips">volatile</span>(临时存储，存储于内存)和<span class="tips">persistent</span>(持久化存储，存储于磁盘)，当前使用哪种存储方式取决于配置文件中的Storage配置项：</p>
<ul>
<li>持久化日志的存储位置为：<span class="tips">/var/log/journal/</span></li>
<li>临时日志的存储位置为：<span class="tips">/run/log/journal/</span>，该路径下存储的日志会在系统重启时丢失</li>
</ul>
<p>systemd-journald收集的日志文件通常分为两种，一种是当前处于活跃状态的(active)，通常文件名为<span class="tips">system.journal</span>，活跃状态的文件是journald正在写入的文件，通过journalctl命令删除日志时无论如何不会删除活跃的日志文件；另一种是已经归档的(archived)日志文件，文件名通常包含日志时间范围和系统标识符的哈希值，类似于<span class="tips"><code>system@0-000027b7a-000158412d.journal</code></span>，journald不会向这类文件再写入东西，这些通常是旧的日志文件。</p>
<h4 id="journalctl日志命令"><a href="#journalctl日志命令" class="headerlink" title="journalctl日志命令"></a>journalctl日志命令</h4><p>systemd-journald是以二进制格式存储日志的，不能使用传统vim、cat等工具直接打开，需要使用<span class="tips">journalctl</span>命令</p>
<p><span class="strong">journalctl [选项]</span></p>
<ul>
<li>默认情况下将显示所有日志，旧的日志显示在前，以分页形式显示，长行会被截断为屏幕宽度，可以使用左右箭头查看截断部分</li>
<li>-r 倒叙查看，最新的日志排于前</li>
<li>字段=值：过滤出指定的字段，如：_PID=1234(查看该PID服务的日志)，_UID=1111(查看该用户的日志)</li>
<li>-n 值：显示指定数量的日志条目</li>
<li>-u 服务名：查看指定服务的日志</li>
<li>-&zwnj;-since 日期：查看指定日期之后的日志，规范的指定日期形式为”yyyy-MM-dd HH:mm:ss”</li>
<li>-&zwnj;-untile 日期：查看指定日期之前的日志，规范的指定日期形式为”yyyy-MM-dd HH:mm:ss”</li>
<li>-f 实时查看日志，类似于tail -f命令</li>
<li>-p 日志等级：查看指定等级以上的日志，可取值有emerg, alert, crit, err, warning, notice, info, debug，也可以使用0-7的值依次代替这些等级</li>
<li>-o 输出格式：指定日志的输出格式，常用的输出格式有<blockquote>
<blockquote>
<ul>
<li>short：简洁格式</li>
<li>verbose：详细格式</li>
<li>json：JSON格式</li>
<li>cat：仅显示日志内容，不包含其他信息</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>-&zwnj;-no-pager 禁用分页模式</li>
<li>-&zwnj;-disk-usage 显示所有日志文件在当前磁盘的占用情况</li>
<li>-&zwnj;-rotate 立即开始日志轮换，将当前活跃的日志文件立即归档并重命名，然后标记为archived，然后新建新的日志文件作为活跃文件</li>
<li>-&zwnj;-vacuum-size=值：删除最早的归档日志，直到日志所占用空间小于指定值，接受K、M、G、T单位</li>
<li>-&zwnj;-vacuum-time=值：删除早于指定时间跨度的归档日志，单位默认为s，接受m、h、days、weeks、months、years单位</li>
<li>-&zwnj;-vacuum-files=值：只保留指定数量的归档日志文件</li>
<li>-&zwnj;-sync 立即将日志同步到磁盘，在同步操作完成之前，此调用不会返回</li>
</ul>
<div class="broadcast color-purple">
完整命令和选项参考官方文档：<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/journalctl.html">journalctl命令</a></div>


<h4 id="日志服务配置文件"><a href="#日志服务配置文件" class="headerlink" title="日志服务配置文件"></a>日志服务配置文件</h4><p>日志配置文件<span class="tips">journald.conf</span>的主文件路径是systemd编译时指定的，无法修改，这些路径包括<span class="tips">/etc/systemd/</span>、<span class="tips">/run/systemd/</span>、<span class="tips">/usr/local/lib/systemd/</span>、<span class="tips">/usr/lib/systemd/</span>，它们的优先级也是固定的，journald会按照上述顺序查找配置文件，只会加载第一个找到的文件。主配置文件用来定义系统默认配置，一般情况下，绝大部分Linux发行版的主配置文件只有<span class="tips">/etc/systemd/journald.conf</span>文件，且该文件中的配置项是被注释掉的，这是因为日志的默认配置在编译时内置到了journald服务中，journald.conf文件中的内容只是对这些默认值的说明，用来帮助管理员了解可以配置的选项及其默认行为。</p>
<p>除了主配置文件，日志服务还会从<span class="tips">/usr/lib/systemd/journald.conf.d/</span>、<span class="tips">/usr/local/lib/systemd/journald.conf.d/</span>、<span class="tips">/etc/systemd/journald.conf.d/</span>路径中查找配置文件，这些路径中的配置会覆盖系统的默认主配置，且这些路径中的配置文件会按上述顺序全部加载，对于只接受单个值的配置项，后面的配置会覆盖前面的，而对于接受多个值的配置项，所有配置都将生效。换而言之，<span class="tips">/etc/systemd/journald.conf.d/</span>路径下的配置文件优先级将是最高的，同一目录中的配置文件会按文件名字典顺序加载。</p>
<p>通常情况下，如果要修改日志的配置，只需要修改/etc/systemd/journald.conf文件即可，如果需要为不同的Unit单元或服务定制专属日志配置，则可以在/etc/systemd/目录中新建journald.conf.d(该目录通常需要自行创建)，然后在该目录中创建新的日志配置文件，如：my-global-settings.conf，该文件的优先级将是最高的，/etc/systemd/journald.conf文件的默认配置如下：</p>
<div class="shell">[Journal]
#Storage=auto
#Compress=yes
#Seal=yes
#SplitMode=uid
#SyncIntervalSec=5m
#RateLimitIntervalSec=30s
#RateLimitBurst=10000
#SystemMaxUse=
#SystemKeepFree=
#SystemMaxFileSize=
#SystemMaxFiles=100
#RuntimeMaxUse=
#RuntimeKeepFree=
#RuntimeMaxFileSize=
#RuntimeMaxFiles=100
#MaxRetentionSec=
#MaxFileSec=1month
#ForwardToSyslog=yes
#ForwardToKMsg=no
#ForwardToConsole=no
#ForwardToWall=yes
#TTYPath=/dev/console
#MaxLevelStore=debug
#MaxLevelSyslog=debug
#MaxLevelKMsg=notice
#MaxLevelConsole=info
#MaxLevelWall=emerg
#LineMax=48K
#ReadKMsg=yes
#Audit=no
</div>

<h4 id="配置文件语法-1"><a href="#配置文件语法-1" class="headerlink" title="配置文件语法"></a>配置文件语法</h4><ul>
<li><p><span class="strong">Storage=</span><br>指定日志数据的存储方式，可以为以下值：</p>
<blockquote>
<blockquote>
<ul>
<li><span class="strong">volatile</span>：日志只存储于内存中，存储位置为：<span class="tips">/run/log/journal</span>,存储内容会在系统重启后丢失</li>
<li><span class="strong">persistent</span>：日志存储在磁盘上，存储位置为：<span class="tips">/var/log/journal</span>，但在系统引导初期(boot)以及磁盘无法写入时将回滚为volatile模式</li>
<li><span class="strong">auto</span>：如果目录/var/log/journal 存在，则写入磁盘，否则将回滚为volatile模式</li>
<li><span class="strong">none</span>：关闭日志存储，所有日志将被丢弃(但被转发到其他目标位置，如被转发到控制台、内核日志缓冲区或 syslog 套接字的配置仍将有效)</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">Compress=</span><br>指定日志是否压缩，需要指定一个boolean值，默认为yes，此时会将大于默认阈值512bytes的数据进行压缩。也可以直接指定一个值，表示进行压缩的阈值，可以使用K、M、G等单位</p>
</li>
<li><p><span class="strong">Seal=</span><br>指定是否为持久化的日志文件启用安全密封(FSS)，以保护日志文件免受纂改，需要指定一个boolean值，默认为yes</p>
</li>
<li><p><span class="strong">SplitMode=</span><br>指定日志的分割方式,可以取以下值:</p>
<blockquote>
<blockquote>
<ul>
<li><soan class="strong">none</soan>：默认值,不分割日志</li>
<li><soan class="strong">uid</soan>：按用户ID分割日志</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">RateLimitIntervalSec=,RateLimitBurst=</span><br>用于限制日志的写入速率，防止占用太多系统资源，默认值为30s内最多允许写入1000条日志，多余的日志会被丢弃。RateLimitIntervalSec用于指定限制时间，默认值为30，可以使用s、min、h、ms、us单位；RateLimitBurst用于指定上述时间内的限制写入条数，默认值为1000，二者需要搭配使用。当达到限制速率时，systemd-journald 会生成类似日志信息：”Rate limit reached for messages, suppressing X messages from Y services”，X表示被丢弃的日志数量，Y表示服务来源。将值设置为0表示不进行任何限制</p>
</li>
</ul>
<ul>
<li><p><span class="strong">RuntimeMaxUse=,SystemMaxUse=</span><br>指定内存，磁盘中日志最大占用空间，默认值均为当前文件系统大小的10%，上限为4G，当日志存储空间接近限制时，journald会删除旧的归档日志</p>
</li>
<li><p><span class="strong">RuntimeKeepFree=,SystemKeepFree=</span><br>指定需要为内存，磁盘保留多大空闲空间，默认值均为当前文件系统大小的15%，上限为4G。当内存或磁盘空间被非日志文件占用，剩余空间低于该设置的值时，journald将停止写入新日志，但不会去删除旧日志(是否删除旧日志取决于RuntimeMaxUse=或SystemMaxUse=设置的阈值)</p>
</li>
<li><p><span class="strong">RuntimeMaxFileSize=,SystemMaxFileSize=</span><br>指定单个日志文件的最大大小，达到此大小时，journald会创建一个新文件，默认值为SystemMaxUse= 和 RuntimeMaxUse= 的1/8，最大上限为128M，即如果SystemMaxUse的1/8超过了128M，上限仍为128M，如果启用了日志压缩，最大限制为4G</p>
</li>
<li><p><span class="strong">RuntimeMaxFiles=,SystemMaxFiles=</span><br>指定日志文件的最大数量，达到限制后，旧的日志文件会被删除，默认值为100</p>
</li>
<li><p><span class="strong">MaxFileSec=</span><br>指定单个日志文件能够记录数据的最长时间，一旦时间达到这个值，当前日志文件将被关闭并归档，journald 会启动一个新的日志文件来存储后续日志，默认值为1个月，可以使用year、month、week、day、h或m作为时间单位，默认单位为s，设置为0可以关闭此功能。如果日志数据量很大时，文件也有可能会因为达到SystemMaxFileSize值而被强制轮换，导致单个文件中记载的时间不足该指定值</p>
</li>
<li><p><span class="strong">MaxRetentionSec=</span><br>指定日志的最长保留时间。如果日志文件的最后修改时间早于这个时间阈值，它们将被删除。默认值为0，可以使用year、month、week、day、h或m作为时间单位，默认单位为s，设置为0可以关闭此功能。</p>
</li>
<li><p><span class="strong">SyncIntervalSec=</span><br>控制 journald 将内存中缓存的日志条目写入磁盘以持久化保存的时间间隔，默认值为5min写入一次。CRIT、ALERT 或 EMERG级别的日志会被立即写入磁盘而不受此设置影响，此设置仅适用于ERR、WARNING、NOTICE、INFO、DEBUG 级别的日志消息</p>
</li>
<li><p><span class="strong">ForwardToSyslog=, ForwardToKMsg=, ForwardToConsole=, ForwardToWall=, ForwardToSocket=</span><br>指定是否需要将日志转发到传统日志服务(syslog，默认为no)、内核日志缓冲区(/dev/kmsg，默认为no)、控制台(默认为no，可以通过TTYPath指定转发到哪个控制台)、所有登录用户(类似于wall命令，默认为yes)、Socket服务(该服务为/run/systemd/journal/socket上所监听的服务，如果要指定该配置则需要指定该服务的地址，默认无转发)，以上设置，默认仅启用转发到wall(且只有出现emerg级别的日志时才转发，参考MaxLevelSocket配置)</p>
</li>
<li><p><span class="strong">TTYPath=</span><br>指定日志转发的TTY设备设备路径，仅在 ForwardToConsole=yes 时生效，默认为/dev/console</p>
</li>
<li><p><span class="strong">MaxLevelStore=, MaxLevelSyslog=, MaxLevelKMsg=, MaxLevelConsole=, MaxLevelWall=, MaxLevelSocket=</span><br>指定存储、转发到syslog、内核日志缓冲区、控制台、所有登录用户、Socket服务的日志其日志等级，可选值有：emerg、alert、crit、err、warning、notice、info、debug，以下为默认值：</p>
<blockquote>
<blockquote>
<ul>
<li>MaxLevelStore=debug</li>
<li>MaxLevelSyslog=debug</li>
<li>MaxLevelKMsg=notice</li>
<li>MaxLevelConsole=info</li>
<li>MaxLevelWall=emerg</li>
<li>MaxLevelSocket=debug</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><span class="strong">ReadKMsg=</span><br>控制journald是否读取内核环形缓冲区(/dev/kmsg)中的日志消息，这些消息通常由内核及其模块生成，是系统启动、硬件事件和内核日志的重要来源，默认为yes</p>
</li>
<li><p><span class="strong">Audit=</span><br>控制 journald 是否从内核审计子系统(Audit Framework)读取审计日志，审计日志记录系统的安全相关事件(如用户登录、权限更改等)，通常由内核的审计功能生成，默认为yes</p>
</li>
<li><p><span class="strong">LineMax=</span><br>指定journald从stdout/stderr读取流数据，并将其转换为记录日志时允许的最大行长度，默认为48k，超出部分会被journald截断并添加…后缀，表示此行已被截断。可以使用K、M、G、T为单位，最小可设置的值为79(bytes)，小于该值的设置会被提升到79bytes</p>
</li>
</ul>

        </div>
    </div>
    <div class="post-nav">
        
            
                <div class="post-next">
                    <a href="/blog/2023/10/13/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/">下一篇：C语言 </a>
                </div>
                 
    </div>
    <div class="container">
        <!--设计来源于B站-季夏小贞-->
        <div class="bigHead"></div>
        <div class="ears"></div>
        <div class="body"></div>
        <div class="paws-front"></div>
        <div class="paws-back"></div>
        <div class="details"></div>
        <div class="tail"></div>
        <div class="sleep">
          <span class="s1">z</span>
          <span class="s2">z</span>
          <span class="s3">z</span>
          <span class="s4">z</span>
          <span class="s5">z</span>
        </div>
    </div>
</div>
<div class="right-menu">
    <a class="iconfont backTop" href="javascript:">&#xe655;</a>
    <div class="husky"></div>
  </div>
</div>

<script src="/blog/js/jquery.min.js"></script>
<script src="/blog/js/jquery.bumpytext.js"></script>
<script src="/blog/js/index.js"></script>
<script src="/blog/js/highlight.min.js"></script>
<script src="/blog/js/highlightjs-line-numbers.min.js"></script>
<script src="/blog/js/article.js"></script>

</body></html>