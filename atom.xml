<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHWIVI&#39;s blog</title>
  
  
  <link href="https://shiwei11.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://shiwei11.github.io/blog/"/>
  <updated>2022-09-28T16:08:38.709Z</updated>
  <id>https://shiwei11.github.io/blog/</id>
  
  <author>
    <name>SHIWIVI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web的发展旅程</title>
    <link href="https://shiwei11.github.io/blog/2022/09/18/History-of-browser/"/>
    <id>https://shiwei11.github.io/blog/2022/09/18/History-of-browser/</id>
    <published>2022-09-18T07:46:45.000Z</published>
    <updated>2022-09-28T16:08:38.709Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>了解这些历史解开了此前我心中的一些疑惑，比如：UA标识里为什么同时会有好几个内核的标识？CSS为什么需要写浏览器前缀来做兼容性？</div><h3 id="世界线的开端"><a href="#世界线的开端" class="headerlink" title="世界线的开端"></a>世界线的开端</h3><h4 id="超文本-Hyper-Text"><a href="#超文本-Hyper-Text" class="headerlink" title="超文本(Hyper Text )"></a>超文本(Hyper Text )</h4><p><span class="strong">超文本:</span>是指利用链接将非线性分布的节点上的信息联结，把各种不同空间的文字信息组织在一起形成的超级文本。它使得原先的线性文本变成可以通向四面八方的非线性文本，读者查阅文本时可以在任何一个关节点上停下来，进入其他文本，然后再点击、再进入另一文本，理论上，这个过程是可以无限重复的。从而，原先单一的文本变成了无限延伸、扩展的超级文本。</p><p>1945年，美国工程师Vannevar Bush(曼哈顿计划的主要组织者、雷神公司创始人之一)提出了一种基于静态缩微胶片页面的memex(memory extender)设备,人们可以在该设备中压缩和存储书籍、文件、通信记录及其索引，并以极快的速度对其进行检索查询。这意味着，人们不用再根据特定的程序，一步一步寻找信息，利用文本间的交叉引用链接,人们可以用非线性的方式查阅信息，由于条件所限，Vannevar Bush的思想在当时并没有变成现实，但这一开创性的信息组织方法，奠定了超文本的基础。</p><p>1960年，Ted Nelson在哈弗大学参加计算机编程课时，考虑编写一个文档系统来索引和管理他收藏的笔记，他在进入哈弗大学前曾担任电影制片人，因此他准备将电影镜头引入了该系统的设计中。所有信息都可以通过其他任何地方的链接访问，信息导航是非线性的，这取决于每个访问信息的人，人们可以从一个信息跳转到另外一则信息，就像从一个镜头切换到另外一个镜头。基于这个想法，1963年，Ted Nelson 首次提出了“超文本”的概念。</p><p>1968年，美国科学家Doug Engelbart在美国秋季联合计算机会议上展示了第一个超文本系统NLS(oN-Line System)，并首次展示了鼠标、第一个图形用户界面。</p><h4 id="万维网的诞生"><a href="#万维网的诞生" class="headerlink" title="万维网的诞生"></a>万维网的诞生</h4><p>1989年，工作于CERN(欧洲核子研究所)的Tim Berners Lee为查找存储在不同计算机上的信息而苦恼，不兼容的网络、磁盘、数据格式和字符编码使得人们查找信息十分困难且低效。于是，他向CERN的领导层提交了一个超文本项目提案，该提案提出建立一个用于CERN研究人员之间交流信息的系统，用以帮助处于不同网络、计算机系统、国家的研究人员共享信息和交流问题。</p><p>1990年，Tim Berners Lee开发出了构建Web所需要的三个基本技术：</p><ul><li><span class="strong">统一资源定位符(URL)</span></li><li><span class="strong">超文本标记语言(HTML)</span></li><li><span class="strong">超文本传输协议(HTTP)</span></li></ul><p>同年，在同事Robert Cailliau的帮助下，Tim Berners Lee发起建立了一个名为World Wide Web (万维网)的超文本项目。1990年12月，Tim Berners Lee和他的团队开发出了世界上第一个Web浏览器(WorldWideWeb，与万维网同名)，第一个Web服务器(CERN httpd)，并发布了世界上第一个网站：<a href="http://info.cern.ch/">http://info.cern.ch/</a>，万维网就此诞生！</p><p>1994年，W3C联盟(万维网联盟)正式成立，由Tim Berners-Lee 担任W3C联盟主任，这是一个非营利性技术组织，旨在对 web 技术进行标准化，以协调服务提供商、内容供应商、实验室等各方协同工作，致力在万维网发展方向上达成共识，并起草发布<span class="strong">W3C标准</span>，主要包括HTML、XHTML、CSS、DOM、ECMAScript标准的规划制定。</p><h4 id="浏览器的发展"><a href="#浏览器的发展" class="headerlink" title="浏览器的发展"></a>浏览器的发展</h4><p>WorldWideWeb浏览器最初只能在NeXTSTEP操作系统上使用(next公司老板是大名鼎鼎的乔布斯，后来next被苹果收购，NeXTSTEP系统和OpenStep结合，衍生出了MacOS)，为了解决这个问题，Tim Berners Lee的团队使用C语言重写了WorldWideWeb的许多组件，从而创建了libwww API。</p><p>1992年4月，在Robert Cailliau的指导下，赫尔辛基理工大学的4名硕士生小组联合开发出了第一个可运行于Unix的浏览器Erwise，该项目在学生毕业后被搁置了，Tim Berners Lee前往芬兰鼓励该小组毕业后继续开发该项目，但后期由于缺少资金该项目再次被搁置。</p><p>1992年，加州大学伯克利分校学生魏培源使用Viola语言将WWW浏览器的组件组合了起来，发布了第二个可以运行于Unix系统中的浏览器ViolaWWW，这是第一个支持添加扩展功能的浏览器，该浏览器得到了CERN的推崇，成为了第一个流行于万维网中的浏览器。</p><p>1993年，美国国家超级计算应用中心(NCSA)的俩名员工Marc Andreessen和Eric Bina在接触了ViolaWWW后，为Unix的X窗口系统设计出了Mosaic浏览器，这是第一款可以显示图形界面和图片的浏览器，设计之初就考虑到了非技术用户的使用体验，由此引发了Web网络的爆炸式发展，Web在短短几个月内从鲜为人知变成了无处不在，该浏览器也很快被移植到Amiga、Apple Macintosh和Windows等平台。</p><h3 id="内核的发展"><a href="#内核的发展" class="headerlink" title="内核的发展"></a>内核的发展</h3><h4 id="开拓者-网景导航者"><a href="#开拓者-网景导航者" class="headerlink" title="开拓者 网景导航者"></a>开拓者 网景导航者</h4><p>1994年4月，Mosaic浏览器的核心开发人员Marc Andreessen离开了NCSA，与几何图形发生器的发明人Jim Clark共同创办了网景公司（Netscape Communications Corporation），网景大量聘用了原有的Mosaic浏览器工程师，但由于Mosaic的版权在NCSA，于是开发团队重写了浏览器代码。</p><p>1994年11月，网景发布了大名鼎鼎的<span class="strong">网景导航者（Netscape Navigator）</span>浏览器1.0版本，这是全球第一款商业浏览器，由于公司目标是替代NCSA Mosaic成为全球第一的浏览器，因此将其内部代号定为了”Mozilla”，意为Mosaic杀手。1995年，网景开发出了<span class="strong">HTTP cookie、</span><span class="strong">Frame框架、</span><span class="strong">SSL</span>等一系列技术，并创建了<span class="strong">JavaScript</span>语言，网景导航者由于其功能更新迅速，又有新技术的加持，市场份额一度达到了86%。</p><p>意气风发的网景将目光转向了操作系统的开发，网景希望开发出一款基于浏览器的操作系统，类似于如今的Chrome OS。这引起了微软的警觉，这一跨越浏览器界限的作业系统，被微软视为是对Windows的直接威胁，微软担心网景抢占他们在操作系统和应用软件方面的市场份额。</p><h4 id="泥石流-IE"><a href="#泥石流-IE" class="headerlink" title="泥石流 IE"></a>泥石流 IE</h4><p>1995年，为了对抗网景导航者，微软从Spyglass公司(Spyglass是NCSA创建的商业化公司)购买了Mosaic浏览器的源代码和许可，同年8月，微软推出了基于此开发的<span class="strong">Internet Explorer</span>浏览器1.0版本。IE浏览器的发布引发了“浏览器大战”，网景和微软竭力为各自的产品推陈出新，以求占据更大的市场份额。</p><p>1996年，微软推出了IE3,这是第一款支持<span class="strong">CSS</span>的商用浏览器。</p><p>1997年9月，微软发布了<span class="strong">Trident</span>内核，并推出了第一个以该内核作为引擎的浏览器 IE4。事态开始逐渐失控，微软的团队制作了一个巨大的字母”E”模型并将它放在了网景总部的草坪上。网景的团队不甘示弱，推倒了模型并放上了Mozilla的恐龙吉祥物，并写上标语”Netscape 72，Microsoft 18”以嘲讽微软IE浏览器的市场份额比网景低。</p><p>随后，微软开始不讲武德，将IE集成到了Windows中进行捆绑发行，并投给了苹果1.5亿美元，让苹果撤销之前对微软的侵权指控，附加条件是让苹果在其Macintosh上内置IE浏览器。此外，微软在授权条款中，要求主机厂商们在桌面上展示IE的图标，并不得加入Netscape，否则以涨价方式作为处罚。</p><p>微软的垄断式发行卓有成效，当人们看到打开操作系统就有开箱即用的浏览器时，很少会有人再想到网景导航者了，更何况IE是免费的而网景导航者需要付费。微软的一系列操作让IE浏览器的市场份额很快暴涨，直至2002年，IE浏览器的市场份额达到恐怖的96%，比网景的峰值还高。</p><p>过高的市场占有率开始使微软养尊处优，没有了网景这一竞争对手的压力，微软放慢了对内核的更新进程，并开始奉行一套自己的Web标准，在IE浏览器中加入了VBScript，DHTML等不遵循W3C公开标准的专属技术，以巩固自己的霸主地位，IE浏览器开始变得臃肿而笨重。由于IE浏览器垄断了市场，不少网页开发者只能迎合微软的Web标准，公开的W3C标准反而不被关注，从而衍生出了一大堆只和IE专属技术契合的网站，使得一些网站只能使用IE浏览器打开。</p><p>此外，IE由于市场占有率高，已然成为了蠕虫病毒的主要攻击目标，IE浏览器一旦被发现安全漏洞，蠕虫病毒会由于IE的普及高速传播。IE的泥石流行径为web的发展带来了难以根治的后遗症，而微软的不正当竞争行径也使之背负了多年的反垄断指控。</p><h4 id="网景的继承-Mozilla火狐"><a href="#网景的继承-Mozilla火狐" class="headerlink" title="网景的继承 Mozilla火狐"></a>网景的继承 Mozilla火狐</h4><p>除了微软的垄断式打压，网景后期对浏览器的错误定位也成为了网景覆灭的导火索之一。网景在与微软的“浏览器大战”中过分追求为浏览器增加特色功能，将电子邮件、新闻组件、文件编辑等功能塞入了浏览器中，并将其更名为了 Netscape Communicator4.0（网景通讯家）。过多的组件造成整个软件渲染缓慢，臃肿不堪。并且其新增的“特色”功能并没有革命性的创新，反而逐渐脱离了W3C的标准，期间曾一度创造了臭名昭著的<span class="tips">&lt;blink&gt;</span>标签。欠缺的使用体验，再加上微软的流氓式打压，网景浏览器的市场份额一落千丈。</p><p>1998年1月，在与微软的“浏览器大战”中失利后，为了挽回市场，网景宣布旗下所有软件对公众免费，并开源了Netscape Communicator4.0的源代码。与此同时，网景发布了一个全新的开源项目Mozilla，其中包含了全新的排版引擎<span class="strong">Gecko</span>，并建立了非正式组织Mozilla，以支持后续的Netscape Communicator开发。</p><p>1998年10月，网景宣布Netscape Communicator5.0将使用全新的Gecko引擎，这引起了Netscape开发人员的不满，因为在此之前他们对旧引擎<span class="strong">Mariner</span>进行了长达六个月的改进工作，而此举意味着他们此前的努力将付诸东流。网景的盈利主要依靠网景导航者及其衍生产品的收益，主要支柱遭受巨大打击，此时的网景已经摇摇欲坠，内部进行了大量人员裁剪。诸多原因直接导致Netscape Communicator5.0的发布被极大地推迟了，而此前微软发布的IE4比旧版本的网景通讯家拥有更好的性能，包括对HTML4、CSS、DOM和ECMAScript等W3C标准的支持，市场的天平进一步向微软倾斜。</p><p>1998年11月，AOL(美国在线)公司以42亿美元、免税换股的方式收购了网景通讯公司。AOL在证实微软因滥用垄断能力而败诉后(此前微软因垄断问题在和苹果等公司打官司)，AOL向微软提出了索偿诉讼，指控微软在与网景的竞争中滥用垄断能力。2003年5月，微软和AOL达成和解协议，微软将向网景支付7.5亿美元，而AOL允许微软在7年无限制的使用和散布IE浏览器，AOL的这一举动带领网景走向了覆灭。</p><p>2000年11月，在推迟将近两年后，网景跳过了Netscape Communicator5.0，发布了基于Gecko引擎的Netscape 6，但此时已是IE5的天下。</p><p>2003年7月15日，AOL解散了网景公司，解雇了Gecko的开发人员，并将Gecko及其相关产品的知识产权交给了Mozilla组织，Mozilla组织接收了大量Gecko的开发人员。同一天，Mozilla基金会正式成立，其目的是保证Mozilla组织可以在没有网景以后能继续生存下去。</p><p>2004年11月，Mozilla发布了Firefox(火狐)1.0版本，起初，Firefox被命名为Phoenix，寓意网景导航者的欲火重生，但由于与一家科技公司重名而改为了Firebird，该名称又和一个数据库软件重名，最后Mozilla 将名称确定为了Firefox。</p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>Mozilla还负责运行维护MDN开发者平台，该平台提供了大量关于HTML、CSS、JavaScript和Web API的免费文档资料，是最好的Web开发资源平台之一。</div><h4 id="勤劳的蜜蜂-苹果safari"><a href="#勤劳的蜜蜂-苹果safari" class="headerlink" title="勤劳的蜜蜂 苹果safari"></a>勤劳的蜜蜂 苹果safari</h4><p>在safari之前，苹果Macintosh系列计算机所使用的默认浏览器为网景导航者、Cyberdog（苹果自行开发的浏览器，由于苹果经营不善该项目被裁掉）和IE。</p><p>2001年6月，苹果fork了由KDE社区(一个崇尚开源自由的软件社区)开发的开源渲染引擎KHTML和JS引擎KJS，然后利用适配器库将其移植到了苹果的Mac OS X系统上，并重命名为WebCore和JavaScriptCore。经过苹果二次开发的KHTML和KJS拥有了更为严谨的代码结构和更快的渲染速度，苹果将其命名为<span class="strong">Webkit</span>引擎。</p><p>2003年1月，苹果发布了首个以此为内核的<span class="strong">safari</span>浏览器</p><p>2005年6月，苹果开源了Webkit源代码，同年12月，添加了对SVG(矢量图)的支持</p><p>2007年，苹果开始对CSS进行拓展，使得CSS开始支持动画、过渡、2D和3D变换，并于2009年将其以草案的方式发布给了网维网联盟进行标准化，辛勤的苹果为CSS标准库提供了大量的草案和建议。</p><h4 id="新的引领-谷歌chrome"><a href="#新的引领-谷歌chrome" class="headerlink" title="新的引领 谷歌chrome"></a>新的引领 谷歌chrome</h4><p>Webkit的高效和稳定引来了谷歌的青睐，2008年9月，谷歌发布了以Webkit为引擎的<span class="strong">Chrome</span>浏览器,实际上，Chrome还使用了Mozilla等组织的诸多开源组件来增强性能。</p><p>2010年苹果发布了Webkit2，由于Webkit2使用的进程隔离技术与谷歌的沙箱设计存在冲突，谷歌决定在WebKit的基础上自行开发引擎。谷歌的工程师们fork了WebKit的Webcore渲染引擎，并对源代码作了大量的精简和修改，而JS引擎将谷歌自行开发。</p><p>2013年4月，谷歌发布并开源了全新的浏览器内核<span class="strong">Blink</span>，其名字来源于网景创建的臭名昭著的<span class="tips">&lt;blink&gt;</span>标签，谷歌的工程师戏虐的表示：”我们永远不会支持blink标签”。此外，谷歌还开发出了强悍的JavaScript解释器——V8引擎(基于Strongtalk)，大大加快了chrome的JS解析速度。</p><p>随着Blink的发布，Opera等浏览器厂商纷纷宣布将转向使用Blink引擎。2015年3月，微软宣布放弃IE浏览器的开发，转而使用Microsoft Edge取代IE。2020年，微软宣布Microsoft Edge浏览器将弃用EdgeHTML转而使用Blink内核。</p><h4 id="兢兢业业的Opear"><a href="#兢兢业业的Opear" class="headerlink" title="兢兢业业的Opear"></a>兢兢业业的Opear</h4><p>1994年，挪威电信公司Telenor的两名员工Jon Stephenson von Tetzchner和Geir Ivarsøy开始开发Opear浏览器，后来，他们离开了Telenor并创立了Opear Software，并于1995年4月发布了Opear浏览器</p><p>2003年1月，欧朋发布就基于<span class="strong">Presto</span>内核的Opera 7</p><p>2010年，欧朋首创了选项卡堆叠、鼠标手势等功能，这些功能后来也被其他浏览器大量应用</p><p>2013年2月，欧朋宣布放弃presto转而使用Webkit，2013年4月，欧朋跟随谷歌转而使用Blink引擎。</p><p>2016年2月，欧朋被360公司和昆仑万维收购</p><p>欧朋浏览器自发布以来严格遵守W3C标准，老老实实地开发使用符合W3C规范的技术拓展，然而“浏览器大战”与IE的横行造就了一大堆不符合W3C标准的网页，由于Opear不支持非标准的技术栈，这些网页在Opear上往往会解析错误，Opear的兢兢业业反而为其带来了负面的用户口碑，因为用户只会将页面的不解析归咎于浏览器的问题。</p><p>2001年10月，随着WindowsXP的发布，微软对MSN通讯软件进行了重大更新，随后就有用户反馈无法使用Opear浏览器进入MSN主页。微软随即甩锅解释是因为Opear浏览器不支持W3C的XHTML技术规范导致。Opear公司反驳表示，Opear浏览器比微软更能满足W3C标准，并给出了W3C验证服务结果：微软的MSN主页使用了非标准的编码。Opear公司还制作了一份标准XHTML的页面进行还击，经过测试，网景6、Opear 等浏览器能正确访问该页面，而IE 6则无法正常显示。随后，微软开始排挤Opear用户，谷歌在发布Chrome后也曾排挤Opear，直至Opear改用Blink引擎后才有所好转。</p><p>Opear在不断遭受排挤后开始考虑支持非标准拓展，Opear公司为浏览器添加了伪装功能，允许用户将Opear伪装为IE、Firefox等浏览器以解决某些网站排挤Opear的问题，兢兢业业的欧朋由于遵守W3C标准反而吃了不少亏，这不是欺负老实人吗!!（胡万腔）</p><h4 id="国产浏览器"><a href="#国产浏览器" class="headerlink" title="国产浏览器"></a>国产浏览器</h4><p>中国互联网发展最快的时间刚好遇上了IE浏览器霸榜的时代，由于IE的Trident内核市场占有率较高，许多网页设计者不得不将以IE的标准作为优先考量，直接导致许多政府机构、高校、企业、银行的网站只能在IE浏览器上正常访问，而在更支持W3C标准的safari、chrome、Firefox等浏览器反而会出现加载或解析错误的情况。为此，国内的浏览器厂商们整合了IE的Trident内核与苹果的Webkit内核，美其名曰双内核并以此作为宣传浏览器的噱头(其实都是别人家的内核)。兼容模式下，浏览器会启用Trident内核以适应脱离w3c标准的垃圾网页。</p><h3 id="浏览器UA标识"><a href="#浏览器UA标识" class="headerlink" title="浏览器UA标识"></a>浏览器UA标识</h3><p>UA为User Agent的简写，指浏览器等软件在网络协议中工作时，会向服务器等对等方提交一个特征字符串，方便对方识别应用类型、操作系统、软件版本号等信息。例如：由于手机屏幕和电脑屏幕尺寸相差巨大，网站设计者一般会为手机端和电脑端设计两个不同大小的网页(或者响应式网页)，当我们访问网站时，服务器会通过UA标识(或者屏幕大小)检测到我们使用的设备是手机还是电脑，从而返回相应的网页。浏览器UA的语法格式通常为：</p><div class="show"><span class="strong">&lt;product> /&lt;version> (&lt;system-information>) &lt;platform> (&lt;platform-details>) &lt;extensions></span></div><p>UA也起源于著名的“浏览器之战”，当时，由于网景首先开创使用了JavaScript、Frames框架等技术，使得网景导航者浏览器的使用体验一骑绝尘，当时的网景导航者支持图片嵌入、网页嵌入等技术，而Mosaic、Samba等一些比较旧的浏览器只支持显示简单的HTML文档。为了提高网站的使用体验，网站设计者们往往希望网页拥有比较前沿的技术设计，但用户的浏览器却不一定支持网站的新颖技术。解决这一问题，UA嗅探技术诞生了。通过UA，网站会动态识别访问用户的浏览器，如：如果是网景导航者，则返回带有Frames框架技术的高级网页内容，如果为Mosaic，则只需返回简单的HTML文档即可。</p><p>起初，网景的UA长这样：</p><div class="show"><code>Mozilla/1.0 (win3.1)</code></div><p>后来，IE浏览器诞生，IE及其他浏览器逐步追上了网景的脚步，并开始支持网景的特色功能，但由于它们起步较晚，绝大多数网站仍只支持为带有Mozilla标识的浏览器返回高级网页。于是乎，微软等公司的在UA中添加了Mozilla的标识来“欺骗”Web服务器，于是，IE浏览器的标识写为了：</p><div class="show"><code>Mozilla/1.22 (compatible;MSIE 2.0;Windows 95)</code></div><p>后来，网景飞升，留下了遗孤Mozilla ，Mozilla 打造 Gecko并发布了Firefox，Firefox的UA写为了</p><div class="show"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0</code></div><p>再后来，KDE社区开发出了KHTML引擎，并发布了嵌入式浏览器 Konqueror，但网页不给他们分发高级内容，他们很烦，于是他们也伪装成了Mozilla，并且表示KHTML跟Gecko一样好~</p><div class="show"><code>Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)</code></div><p>后来，苹果基于KHTML开发出了WebKit，他们又在KHTML的UA上套了一层娃</p><div class="show"><code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5</code></div><p>再再后来，谷歌又在WebKit基础上开发出了blink，他们也想套娃</p><div class="show"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13</code></div><p>于是，人人都是网景Mozilla</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>参考：<a href="https://webaim.org/blog/user-agent-string-history/">user-agent-string-history</a></div><h3 id="代码兼容性"><a href="#代码兼容性" class="headerlink" title="代码兼容性"></a>代码兼容性</h3><h4 id="CSS浏览器前缀"><a href="#CSS浏览器前缀" class="headerlink" title="CSS浏览器前缀"></a>CSS浏览器前缀</h4><p>为了兼容旧版本的浏览器，对于比较新颖的CSS样式我们需要添加浏览器前缀</p><div class="table"><table><thead><tr><th>浏览器</th><th>内核</th><th>前缀</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>-ms-</td></tr><tr><td>Firefox</td><td>Gecko</td><td>-moz-</td></tr><tr><td>Opera</td><td>Presto</td><td>-o-</td></tr><tr><td>Safari</td><td>WebKit</td><td>-webkit-</td></tr><tr><td>Chrome</td><td>WebKit</td><td>-webkit-</td></tr></tbody></table></div><h4 id="渲染内核"><a href="#渲染内核" class="headerlink" title="渲染内核"></a>渲染内核</h4><h5 id="双核浏览器"><a href="#双核浏览器" class="headerlink" title="双核浏览器"></a>双核浏览器</h5><p>对于双核浏览器，我们可以使用<span class="tips">meta</span>标签指定内核渲染网页，国内的双核浏览器一般是Trident内核和webkit内核，因此选其一。</p><div class="show">使用webkit渲染网页，用于提高渲染速度&lt;meta name="renderer" content="webkit"> 使用IE兼容内核，用于兼容为低版本IE浏览器&lt;meta name="renderer" content="ie-comp">使用IE标准内核，用于网站用了IE专属技术&lt;meta name="renderer" content="ie-stand"></div><h5 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h5><p><span class="tips">X-UA-Compatible</span>是IE8的一个专有<meta>属性，它用来指示IE8以上浏览器采用何种IE版本去渲染网页</p><p>常用值有：</p><div class="show">使用最高版本的IE内核渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;启用谷歌内嵌框架Chrome Frame(谷歌推出的IE插件)进行渲染，没有则使用最高版本的IE内核渲染（推荐使用）&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" /></div><p>其他还支持</p><div class="show">使用IE7内核渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=7" />值可并列，该值表示IE8降级使用IE7内核渲染，若有IE9则使用IE9&lt;meta http-equiv="X-UA-Compatible" content="IE=7;IE=9" /></div>]]></content>
    
    
    <summary type="html">了解Web发展的历史，本文包括超文本的由来、内核的发展、UA标识的语法组成，以及如何指定渲染引擎</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>基于certbot获取TLS证书</title>
    <link href="https://shiwei11.github.io/blog/2022/07/29/lets-encrypt/"/>
    <id>https://shiwei11.github.io/blog/2022/07/29/lets-encrypt/</id>
    <published>2022-07-29T06:58:33.000Z</published>
    <updated>2022-08-27T11:43:55.470Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>Let’s Encrypt 官网：<a href="https://letsencrypt.org/">https://letsencrypt.org/</a></div><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><h4 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title="Let’s Encrypt"></a>Let’s Encrypt</h4><p>Let’s Encrypt 是由 ISRG (Internet Security Research Group)推出的免费安全证书计划，我们可以利用Let’s Encrypt 提供的TLS证书，在我们的网站上部署HTTPS 服务。</p><h4 id="ISRG"><a href="#ISRG" class="headerlink" title="ISRG"></a>ISRG</h4><p>ISRG（Internet Security Research Group ，互联网安全研究小组）是一个公益性的组织，该公益组织旨在减少资金、技术、教育障碍，以保护互联网上的通信，推动全球网站的HTTPS化。ISRG成立于2013 年 5 月，起初由Mozilla、电子前沿基金会(EFF)、密歇根大学、思科和 Akamai共同建立，后来又得了谷歌、亚马逊、讯飞、IBM、RedHat、Linux基金会等大厂商的赞助，所以他们的技术和证书安全是可以保障的。</p><h4 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h4><p>Certbot 是由电子前沿基金会 (EFF)制作的免费开源软件工具，用于在网站上申请、管理、使用由Let’s Encrypt颁发的证书，证书每60天更新一次。</p><h3 id="前置需要"><a href="#前置需要" class="headerlink" title="前置需要"></a>前置需要</h3><ul><li>一台可用的服务器，并拥有<span class="tips">root</span>权限</li><li>安装了Web服务，以<span class="tips">Nginx</span>为例</li><li>一个可用的域名，并解析到了该服务器上</li></ul><h3 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h3><h4 id="官方安装"><a href="#官方安装" class="headerlink" title="官方安装"></a>官方安装</h4><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>certbot官方文档：<a href="https://certbot.eff.org/">https://certbot.eff.org/</a></div><p>官网文档里给出了不同系统的详细安装方法，但在安装过程中会遇到不少问题，有些甚至涉及到需要重新编译Linux内核，这在已经部署业务的服务器上往往是无法实现的。</p><p>以CentOS7为例，根据官方的文档，安装Certbot需要先添加EPEL存储库，然后从中安装snapd软件包，但安装snapd需要解决诸多依赖问题：</p><ul><li>安装snapd需要Linux内核支持 SquashFS 文件系统</li><li>手动编译安装的SquashFS 文件系统，yum可能无法识别</li><li>内核编译时需要启用CONFIG_DEVPTS_MULTIPLE_INSTANCES 选项，如果没有需要重新编译内核</li></ul><h4 id="通过pip3安装"><a href="#通过pip3安装" class="headerlink" title="通过pip3安装"></a>通过pip3安装</h4><p>如果无法安装snapd，那只能绕过它，通过其他包管理工具安装，以pip（python包管理工具）为例</p><p>安装python并通过pip安装certbot</p><pre><code>yum install -y python3 && pip3 install certbot</code></pre><h5 id="pip3版本较低报错问题"><a href="#pip3版本较低报错问题" class="headerlink" title="pip3版本较低报错问题"></a>pip3版本较低报错问题</h5><p>在安装certbot时，如果yum源中的pip3版本较低，可能会导致模块导入失败，从而报错</p><div class="shell">Complete output from command python setup.py egg_info:            =============================DEBUG ASSISTANCE==========================            If you are seeing an error here please try the following to            successfully install cryptography:            Upgrade to the latest pip and try again. This will fix errors for most            users. See: https://pip.pypa.io/en/stable/installing/#upgrading-pip            =============================DEBUG ASSISTANCE==========================    Traceback (most recent call last):      File "&lt;string>", line 1, in &lt;module>      File "/tmp/pip-build-2bwzqu_0/cryptography/setup.py", line 14, in &lt;module>        from setuptools_rust import RustExtension    ModuleNotFoundError: No module named 'setuptools_rust'    ----------------------------------------Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-2bwzqu_0/cryptography/</div><p>此时根据报错提示，升级pip3到最新版本即可</p><pre><code>sudo pip3 install --upgrade pip</code></pre><p>升级完毕再安装certbot</p><pre><code>pip3 install certbot</code></pre><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><h4 id="验证域名"><a href="#验证域名" class="headerlink" title="验证域名"></a>验证域名</h4><p>申请证书前，Let’s Encrypt需要先验证域名，以确认用户拥有对域名的控制权。验证通过后，certbot会立马进入申请流程，因此下述命令会同时验证域名和申请证书。certbot针对不同的web服务器和需求，有多种不同的验证方式：</p><h5 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1. Nginx"></a>1. Nginx</h5><p>如果部署了Nginx，可以直接执行（但要确保安装了certbot-nginx插件）</p><pre><code>sudo certbot --nginx</code></pre><p>certbot将自动获取域名，并在进入证书申请流程时让你确认域名，也可以在执行上述命令时通过添加<span class="tips">-d</span>参数来指定域名，如：</p><div class="show"><code>sudo certbot -&zwnj;-nginx -d  shiwivi.me -d  www.shiwivi.me</code></div><p>可以通过<span class="tips">-&zwnj;-email</span>来添加邮箱，Let’s Encrypt会在证书即将到期时发邮件通知你更新证书。</p><div class="show"><code>sudo certbot -&zwnj;-nginx --email xxxx@gmail.com -d  shiwivi.me -d  www.shiwivi.me</code></div><p>如果不添加上述参数，certbot会在验证通过后要求你添加，邮箱一般只需要在首次验证证书或者更改邮箱时添加。</p><h5 id="2-Apache"><a href="#2-Apache" class="headerlink" title="2. Apache"></a>2. Apache</h5><p>Apache中的验证方法与上类似</p><pre><code>sudo certbot --apache</code></pre><h5 id="3-Webroot模式"><a href="#3-Webroot模式" class="headerlink" title="3. Webroot模式"></a>3. Webroot模式</h5><p>上述方法会重启我们的web服务以重新加载配置文件，如果我们希望在颁发证书时，不重启web服务，则可以使用webroot模式。webroot模式下，certbot 会利用已经部署的 web 服务，在其 web 服务根目录下创建名为<span class="tips">/.well-known/acme-challenge</span>的隐藏文件，然后由 Let’s Encrypt 服务端通过域名来访问该隐藏文件，从而完成验证。</p><p>因此，在执行命令时，我们需要添加<span class="tips">-w</span>参数来引导certbot找到web服务的根目录</p><pre><code>certbot certonly --webroot -w 网站根目录 -d 域名</code></pre><p>如：Nginx默认放置网页的根目录为：<span class="tips">/usr/local/nginx/html</span>，则对应命令为</p><div class="show"><code>certbot certonly --webroot -w /usr/local/nginx/html -d shiwivi.me</code></div><h5 id="3-Standalone模式"><a href="#3-Standalone模式" class="headerlink" title="3. Standalone模式"></a>3. Standalone模式</h5><p>如果服务器上没有部署任何web服务，或者不想使用已部署的服务，则可以使用Standalone模式，该模式下，certbot 会自动运行一个 web server 来进行验证。该服务需要占用<span class="tips">80</span>端口，如果我们自己的服务器上已经有 web server 正在运行 （如 Nginx 或 Apache ）并且占用了80端口，则使用Standalone前应该关闭相关服务或修改端口。</p><pre><code>certbot certonly --standalone -d 域名</code></pre><p>可以在命令中指定验证的端口和协议</p><div class="show"><code>certbot certonly --standalone --&lt;challenge-type>-address  -d 域名</code></div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>更多验证方法详见官方文档：<a href="https://eff-certbot.readthedocs.io/en/stable/">https://eff-certbot.readthedocs.io/en/stable/</a></div><h4 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h4><p>certbot完成认证后会开始进入申请流程，初次申请证书，可能需要经历以下流程：</p><ul><li>certbot会提示你阅读并同意使用者条款</li><li>让你输入一个email地址以推送消息，在证书快到期时，lets encrypt会发邮件提醒你及时更新证书</li><li>询问是否愿意将该邮箱提供给EFF，他们会推送有关lets encrypt 的资讯</li></ul><p>邮箱的添加可以在一开始使用<span class="tips"></span></p><p>证书申请成功后，certbot会返回如下提示信息，其中较为重要的信息包括证书与密钥路径，证书到期时间</p><div class="shell">IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at:   /etc/letsencrypt/live/newyear1234.xyz/fullchain.pem   Your key file has been saved at:   /etc/letsencrypt/live/newyear1234.xyz/privkey.pem   Your certificate will expire on 2022-10-27. To obtain a new or   tweaked version of this certificate in the future, simply run   certbot again. To non-interactively renew *all* of your   certificates, run "certbot renew" - If you like Certbot, please consider supporting our work by:<p>   Donating to ISRG / Let’s Encrypt:   <a href="https://letsencrypt.org/donate">https://letsencrypt.org/donate</a><br>   Donating to EFF:                    <a href="https://eff.org/donate-le">https://eff.org/donate-le</a></div></p><h4 id="插件未安装报错问题"><a href="#插件未安装报错问题" class="headerlink" title="插件未安装报错问题"></a>插件未安装报错问题</h4><p>以nginx为例，执行<span class="tips">sudo certbot -&zwnj;-nginx</span>时，可能会有nginx插件未被正确安装报错</p><div class="shell">The requested nginx plugin does not appear to be installed</div><p>安装nginx插件</p><pre><code>yum install python-certbot-nginx</code></pre><p>问题叠问题，如果源中没有该插件包，又可能会遇到报错提示无有效的包</p><div class="shell">No package python-certbot-nginx available.Error: Nothing to do</div><p>此时需要更换一下repo 源，更换前记得先将自己的源的备份</p><pre><code>yum remove -y epel-release  # 先移除当前的包</code></pre><pre><code>yum clean all -v     # 清除所有下载缓存的包，并显示过程</code></pre><pre><code>yum makecache        # 重新将远程服务器的包下载缓存到本地</code></pre><pre><code>yum install -y epel-release # 重新安装 epel </code></pre><p>安装完epel，再重新尝试安装插件，安装完成就可以开始申请证书了</p><pre><code>yum install python-certbot-nginx</code></pre><h4 id="web服务无法找到报错问题"><a href="#web服务无法找到报错问题" class="headerlink" title="web服务无法找到报错问题"></a>web服务无法找到报错问题</h4><p>执行<span class="tips">sudo certbot -&zwnj;-nginx</span>时，还可能会遇到 certbot 无法找到 web server 或配置文件报错，这是路径问题，可以建一个软链接到 /etc/nginx 目录下</p><pre><code>ln -s /usr/local/nginx/conf/ /etc/nginx</code></pre><p>或者在申请证书时手动指定nginx配置文件路径</p><pre><code>certbot --nginx-server-root /usr/local/nginx/conf</code></pre><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><p>证书申请成功后，相关文件会放置在<span class="tips">/etc/letsencrypt</span>目录下，一般就用得到证书和密钥文件</p><h4 id="密钥与证书"><a href="#密钥与证书" class="headerlink" title="密钥与证书"></a>密钥与证书</h4><p>证书和密钥位于 <span class="tips">/etc/letsencrypt/live/域名.xx/</span> 路径下，该路径下有如下几个文件（配置时一般只需要fullchain.pem和privkey.pem文件）：</p><ul><li><span class="strong">fullchain.pem：</span>完整的证书链文件，包含了cert.pem和chain.pem文件中的内容</li><li><span class="strong">privkey.pem：</span>证书对应的私钥</li><li>cert.pem：证书文件，需要与chain.pem文件结合使用</li><li>chain.pem：链文件，包含了浏览器解析所需的其他全部证书，比如根证书和中间证书</li><li>README：说明文件</li></ul><h4 id="通用配置文件"><a href="#通用配置文件" class="headerlink" title="通用配置文件"></a>通用配置文件</h4><p>在<span class="tips">/etc/letsencrypt</span>路径下会生成Nginx的通用配置文件<span class="tips">options-ssl-nginx.conf</span></p><div class="shell">ssl_session_cache shared:le_nginx_SSL:10m;ssl_session_timeout 1440m;<p>ssl_protocols TLSv1.2;<br>ssl_prefer_server_ciphers off;</p><p>ssl_ciphers “FCDHE-FCLSA….”;</div></p><ul><li>ssl_session_cache：会话缓存</li><li>ssl_session_timeout：用户会话缓存失效时间，如果对安全性有较高要求，可以降低此值</li><li>ssl_protocols：加密协议</li><li>ssl_prefer_server_ciphers：是否开启服务端加密算法优先</li><li>ssl_ciphers：加密算法列表</li></ul><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><p>在<span class="tips">/etc/letsencrypt</span>路径下还有一个用于密钥交换算法的Diffie-Hellman 密钥<span class="tips">ssl-dhparams.pem</span></p><h4 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h4><p><span class="tips">/etc/letsencrypt/archive</span>和<span class="tips">/etc/letsencrypt/keys</span>包含所有以前的密钥和证书，而<span class="tips">/etc/letsencrypt/live</span>目录下保存了最新的证书和密钥</p><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>默认情况下，certbot 的日志文件位于/var/log/letsencrypt 路径下。且默认情况下，一旦日志目录中有 1000 条日志，certbot 就会开始日志轮替。</p><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><div class="show">server {listen 443 ssl;<p>#配置SSL证书和密钥路径<br>ssl_certificate    /etc/letsencrypt/live/域名/fullchain.pem;<br>ssl_certificate_key    /etc/letsencrypt/live/域名/privkey.pem;</p><p>#可以将certbot生成的通用配置文件包含进去，自由选择<br>include    /etc/letsencrypt/options-ssl-nginx.conf;</p><p>#使用生成的Diffie-Hellman 密钥，自由选择<br>ssl_dhparam    /etc/letsencrypt/ssl-dhparams.pem;<br>……<br>}</div></p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>Diffie-Hellman密钥用于密钥交换</div><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="测试自动续订"><a href="#测试自动续订" class="headerlink" title="测试自动续订"></a>测试自动续订</h4><ul><li><span class="strong">sudo certbot renew -&zwnj;-dry-run</span> 测试更新证书</li></ul><p>如果测试成功，certbot会返回成功信息</p><div class="shell">- - - - -Account registered.Simulating renewal of an existing certificate for newyear110.xyz- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Congratulations, all simulated renewals succeeded:   /etc/letsencrypt/live/newyear110.xyz/fullchain.pem (success)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </div><h5 id="插件未安装报错"><a href="#插件未安装报错" class="headerlink" title="插件未安装报错"></a>插件未安装报错</h5><p>在测试续订时，如果遇到插件未安装的报错，则需要安装nginx插件</p><div class="shell">Failed to renew certificate newyear110.xyz with error: The requested nginx plugin does not appear to be installed</div><p>安装<span class="tips">letsencrypt-nginx</span>插件</p><pre><code>pip3 install -U letsencrypt-nginx</code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>更多关于插件未安装的报错，可以查看github上的Issues，上述解决方法也来源于该贴：<a href="https://github.com/certbot/certbot/issues/1736">https://github.com/certbot/certbot/issues/1736</a></div><h4 id="续订证书"><a href="#续订证书" class="headerlink" title="续订证书"></a>续订证书</h4><ul><li><span class="strong">certbot renew</span> 自动更新30天内到期的证书（推荐）</li><li><span class="strong">certbot renew -&zwnj;-force-renewal</span> 强制更新未到期的证书</li></ul><p>在初次申请证书时，certbot会记住所使用的配置和插件，并在续订时使用相同的配置和插件。如果需要更改配置（如：修改文件路径），则需要以下步骤</p><ol><li>在命令行中使用修改以后的配置进行一次测试自动续订</li><li>测试成功，说明新的配置是可以运行的，再执行一次证书更新（时间未到就使用强制更新），这将保存新的配置</li></ol><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>CA机构会限制证书颁发速度并阻止用户在短时间内多次续订同一个域名的证书，所以不要在短时间内多次执行强制更新证书操作</div><h4 id="查看证书列表"><a href="#查看证书列表" class="headerlink" title="查看证书列表"></a>查看证书列表</h4><ul><li><span class="strong">certbot certificates</span> 查看证书</li></ul><p>会返回当前所有域名的证书情况，包括证书名、 证书序列号、密钥类型、到期时间、证书路径、私钥路径信息</p><div class="show">Found the following certs:  Certificate Name: newyear110.xyz    Serial Number: 34829c6e3465f2b1b90db11c36111480280    Key Type: RSA    Domains: newyear110.xyz    Expiry Date: 2022-10-27 11:47:25+00:00 (VALID: 87 days)    Certificate Path: /etc/letsencrypt/live/newyear110.xyz/fullchain.pem    Private Key Path: /etc/letsencrypt/live/newyear110.xyz/privkey.pem</div><h4 id="吊销与删除证书"><a href="#吊销与删除证书" class="headerlink" title="吊销与删除证书"></a>吊销与删除证书</h4><p>删除与吊销证书前，应当从web服务器软件的配置文件中删除对对应证书的引用</p><ul><li><span class="strong">certbot revoke -&zwnj;-cert-name 域名.xxx</span> 吊销证书(根据域名)</li><li><span class="strong">certbot revoke -&zwnj;-cert-path /etc/letsencrypt/live/域名.xxx/cert.pem</span> 吊销证书(根据路径)</li><li><span class="strong">certbot delete -&zwnj;-cert-name 域名.xxx</span> 删除指定证书</li><li><span class="strong">certbot delete</span> 从列表中选择删除证书</li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>官方命令和文档：<a href="https://eff-certbot.readthedocs.io/en/stable/using.html">https://eff-certbot.readthedocs.io/en/stable/using.html</a></div>]]></content>
    
    
    <summary type="html">用于部署https服务，certbot官方文档中的步骤可能需要重新编译Linux内核，可以使用python包管理工具绕开</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>路由与路由守卫</title>
    <link href="https://shiwei11.github.io/blog/2022/07/16/%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/"/>
    <id>https://shiwei11.github.io/blog/2022/07/16/%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</id>
    <published>2022-07-16T04:55:14.000Z</published>
    <updated>2022-07-19T15:06:13.311Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>vue路由官方网站：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></div><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>Vue Router 是Vue的官方路由插件，用于构建单页应用</li><li>页面不刷新，配合ajax实现页面的局部更新，并响应式更新地址栏URL</li><li>在工程中，普通组件一般放在components下，而路由组件放于pages目录下</li><li>切换组件时，未调用的组件是被销毁的，调用时被挂载</li><li>整个应用由一个<span class="tips">router</span>(路由器)统一管理，通过<span class="tips">$router</span>调用</li><li>但每个路由组件都有自己的<span class="tips">$route</span>属性</li></ul><h4 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue router"></a>安装vue router</h4><p>vue2的工程使用vue-router3，vue3的工程使用vue-router4，版本需要对应，这里以安装vue-router3为例</p><p>在脚手架中执行：<br><code><pre>npm i vue-router@3</pre></code></p><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>案例：通过组件嵌套，实现功能</p><ol><li>在app单个页面中通过按钮实现Home和About页面的切换</li><li>About页面中嵌套aboutMe和aboutWeb页面</li></ol><p><span class="strong">1. 新建pages目录，存放Home.vue、About.vue、aboutMe、aboutWeb组件</span></p><p>Home.vue文件:</p><pre><code>&lt;template>  &lt;div class="home">    &lt;h2>Home页面&lt;/h2>  &lt;/div>&lt;/template>&lt;script>export default &#123;    name:'pageHome'  &#125;&lt;/script></code></pre><p>About.vue文件:</p><pre><code>&lt;template>  &lt;div class="about">    &lt;h2>About页面&lt;/h2>    &lt;div class="about-btn">    &lt;!--router-link标签路由切换按钮的两种写法，该标签最后会被解析为a标签-->    &lt;!--1. 根据路径调用组件-->    &lt;router-link to="/about/aboutWeb">关于网页&lt;/router-link>     &lt;router-link to="/about/aboutMe">关于我&lt;/router-link>     &lt;!--2. 根据路由规则中的name属性调用组件-->    &lt;router-link :to="&#123;name: 'aboutme'&#125;">关于网页&lt;/router-link>     &lt;router-link :to="&#123;name: 'aboutweb'&#125;">关于我&lt;/router-link>     &lt;/div>    &lt;div class="about-content">    &lt;!--子组件显示的位置-->    &lt;router-view>&lt;/router-view>     &lt;/div>  &lt;/div>&lt;/template> &lt;script> export default &#123;     name:'pageAbout' &#125;&lt;/script></code></pre><p>aboutWeb.vue文件 (aboutMe.vue类似)</p><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">&#123;&#123;t&#125;&#125;&lt;/li>    &lt;/ul>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:&#123;                前端:'html/css/javaScript',                后端:'java',                系统:'CentOS7',                服务器:'nginx'            &#125;        &#125;    &#125; &#125;&lt;/script></code></pre><p><span class="strong">2. 新建router目录，新建index.js文件用于创建路由器</span><br>index.js文件：</p><pre><code>// 引入vueRouter插件import VueRouter from "vue-router";//引入路由组件import Home from '../pages/pageHome'import About from '../pages/pageAbout'import aboutMe from '../pages/aboutMe'import aboutWeb from '../pages/aboutWeb'// 创建路由器export default new VueRouter(&#123;    // 创建路由规则一个&#123;&#125;内为一条路由    routes:[        &#123;            name: 'home',    //路由规则指定的组件别名            path:'/home',   //路由路径            component:Home //调用的组件        &#125;,        &#123;               name: 'about',            path:'/about',            component:About,            children:[     //组件嵌套                &#123;                       name:'aboutme',                    path:'aboutMe',                    component:aboutMe                &#125;,                &#123;                       name:'aboutweb',                    path:'aboutWeb',                    component:aboutWeb                &#125;            ]        &#125;    ] &#125;)</code></pre><p><span class="strong">3. 在main.js中引入路由器</span></p><pre><code>import Vue from 'vue'import App from './App.vue'// 引入vue-routerimport VueRouter from 'vue-router'// 使用vue-routerVue.use(VueRouter)// 引入创建的路由器import router from './router'new Vue(&#123;  render: h => h(App),  router:router   //配置路由器&#125;).$mount('#app')</code></pre><p><span class="strong">4. 在App中调用路由组件</span></p><pre><code>&lt;template>  &lt;div id="app">    &lt;div class="btn">      &lt;!-- active-class用于指定该链接按钮被选中时生效的样式-->      &lt;router-link class="link" active-class="active" to="/home">Home&lt;/router-link>      &lt;router-link class="link" active-class="active" to="/about">About&lt;/router-link>      &lt;!-- 同样，to可以写为对象形式 -->      &lt;router-link class="link" active-class="active" :to="&#123;name:'home'&#125;">Home&lt;/router-link>      &lt;router-link class="link" active-class="active" :to="&#123;name:'about'&#125;">About&lt;/router-link>    &lt;/div>    &lt;div class="content">      &lt;!-- 指定组件显示的位置 -->      &lt;router-view>&lt;/router-view>    &lt;/div>  &lt;/div>&lt;/template>&lt;script> export default &#123;  name:'App', &#125;&lt;/script></code></pre><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a>query传参</h4><p>父组件可通过向<span class="tips"> to </span>属性添加参数进行传参，类似于带参数的http请求，子路由可通过<span class="tips">$route.query.参数名</span>读取数据</p><p>案例：为aboutWeb组件添加子组件webTech，并由aboutWeb向webTech传参</p><h5 id="方法1：通过字符串传参"><a href="#方法1：通过字符串传参" class="headerlink" title="方法1：通过字符串传参"></a>方法1：通过字符串传参</h5><p>在路由路径后添加查询字符串<span class="tips"> ? </span>，并在之后以键值对的方式传参。</p><p>父组件 aboutWeb.vue</p><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">        &lt;!-- 字符串写法 -->        &lt;!-- 注意：由于to前使用了:解析js语法，因此要添加``将语句解析为字符串 -->        &lt;router-link :to="`/about/aboutWeb/webTech?name=$&#123;t.name&#125;&lang=$&#123;t.language&#125;`">&#123;&#123;t.name&#125;&#125;&lt;/router-link>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'框架',language:'vue'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125; &#125;&lt;/script></code></pre><h5 id="方法2：通过对象传参"><a href="#方法2：通过对象传参" class="headerlink" title="方法2：通过对象传参"></a>方法2：通过对象传参</h5><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">        &lt;!-- 对象写法 -->            &lt;router-link :to="&#123;            path:'/about/aboutWeb/webTech',            query:&#123;                name:t.name,                lang:t.language            &#125;            &#125;">            &#123;&#123;t.name&#125;&#125;            &lt;/router-link>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'框架',language:'vue'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125; &#125;&lt;/script></code></pre><h5 id="子路由读取参数"><a href="#子路由读取参数" class="headerlink" title="子路由读取参数"></a>子路由读取参数</h5><p>webTech.vue文件：</p><pre><code>&lt;template>  &lt;div class="show">  &lt;!-- 读取数据 -->    &lt;span class="tech-name">&#123;&#123;$route.query.name&#125;&#125;：&lt;/span>    &lt;span class="tech-lang">&#123;&#123;$route.query.lang&#125;&#125;&lt;/span>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'webTech' &#125;&lt;/script></code></pre><h4 id="params传参"><a href="#params传参" class="headerlink" title="params传参"></a>params传参</h4><h5 id="方法1：通过字符串传参-1"><a href="#方法1：通过字符串传参-1" class="headerlink" title="方法1：通过字符串传参"></a>方法1：通过字符串传参</h5><p>通过字符串传参时，必须在配置路由规则时在<span class="tips">path</span>路径中指定解析的参数</p><pre><code> &#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    path:'webTech/:name/:lang', //在路径中解析参数    conpontent:webTech  &#125;]      &#125;</code></pre><p>父组件通过附带参数的路径传输参数</p><pre><code>&lt;router-link :to="`/about/aboutWeb/webTech?name=$&#123;t.name&#125;&lang=$&#123;t.language&#125;`">&#123;&#123;t.name&#125;&#125;&lt;/router-link></code></pre><p>子组件通过<span class="tips">$route.params.参数名</span>读取参数</p><pre><code>&lt;span class="tech-name">&#123;&#123;$route.params.name&#125;&#125;&lt;/span>&lt;span class="tech-lang">&#123;&#123;$route.params.lang&#125;&#125;&lt;/span></code></pre><h5 id="方法2：通过对象传参-1"><a href="#方法2：通过对象传参-1" class="headerlink" title="方法2：通过对象传参"></a>方法2：通过对象传参</h5><p>通过对象传参时，<span class="tips">to</span>属性不能再使用<span class="tips">path</span>调用组件，而需要使用<span class="tips">name</span>属性，因此路由规则中一定需要给予组件name属性</p><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech' //必须    path:'webTech/:name/:lang', //必须    conpontent:webTech  &#125;]      &#125;</code></pre><p>传参的父组件</p><pre><code>&lt;router-link :to="&#123;            name:'webtech', //不能使用path            params:&#123;                name:t.name,                lang:t.language            &#125;&#125;">            &#123;&#123;t.name&#125;&#125;&lt;/router-link></code></pre><p>子组件通过<span class="tips">$route.params.参数名</span>读取参数，代码同上</p><h4 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h4><p>当需要大量调用参数时，频繁使用$route.query增加了代码量，可以在路由中配置<span class="tips">props</span>属性简化代码。props属性支持三种配置方法。</p><h5 id="1-对象形式，传输固定参数"><a href="#1-对象形式，传输固定参数" class="headerlink" title="1. 对象形式，传输固定参数"></a>1. 对象形式，传输固定参数</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech',    conpontent:webTech,    //对象形式，传输固定参数    props:&#123; name:'框架',            lang:'Vue'&#125;  &#125;]      &#125;</code></pre><h5 id="2-函数形式，传输指定参数-用query"><a href="#2-函数形式，传输指定参数-用query" class="headerlink" title="2. 函数形式，传输指定参数(用query)"></a>2. 函数形式，传输指定参数(用query)</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech',    conpontent:webTech,    //对象形式，传输固定参数    pros(route)&#123;      return &#123;        name: route.query.name,        lang: route.query.language      &#125;    &#125;  &#125;]      &#125;</code></pre><h5 id="3-布尔值，自动传输所有params参数"><a href="#3-布尔值，自动传输所有params参数" class="headerlink" title="3. 布尔值，自动传输所有params参数"></a>3. 布尔值，自动传输所有params参数</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech/:name/:lang', //自动传输所有参数    conpontent:webTech,    //布尔值形式    pros: true  &#125;]      &#125;</code></pre><h5 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h5><p>子组件需要通过<span class="tips">props</span>属性接收参数</p><pre><code>&lt;span>&#123;&#123;name&#125;&#125;&lt;/span> //直接调用&lt;span>&#123;&#123;lang&#125;&#125;&lt;/span>export default&#123;   name:'webTech',  pros:['name','lang'] //接收参数   &#125;</code></pre><h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h3><p>路由导航分为声明式和编程式</p><ul><li><span class="strong">声明式：</span>通过&lt;router-link&gt;配置to属性实现跳转</li><li><span class="strong">编程式：</span>通过调用push、back等API跳转组件</li></ul><h4 id="路由导航与浏览器历史记录"><a href="#路由导航与浏览器历史记录" class="headerlink" title="路由导航与浏览器历史记录"></a>路由导航与浏览器历史记录</h4><p>浏览器历史记录默认为<span class="tips">push</span>状态，组件的跳转会记录到历史记录中，通过浏览器的前进/后退按钮，或者调用<span class="tips">go</span>、<span class="tips">back</span>等API，能根据历史记录实现页面的前进、回退。当浏览器历史记录切换为<span class="tips">replace</span>状态时，浏览器会使用当前页面的记录替换掉上一条历史记录。</p><pre><code> &lt;--跳转到About页面后，About页面的历史记录会替换掉该页的历史记录，此时无法再使用浏览器的回退按钮返回该页面了-->&lt;router-link replace to="...">跳转到About页面&lt;/router-link></code></pre><h4 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h4><p>不借助&lt;router-link&gt;标签，实现路由跳转<br>API：</p><ul><li><span class="strong">push：</span>跳转到指定路由组件</li><li><span class="strong">replace：</span>跳转到指定路由组件并替换浏览器历史记录</li><li><span class="strong">back：</span>回退</li><li><span class="strong">forward：</span>前进(需要之前回退过)</li><li><span class="strong">go(值)：</span>根据值前进/回退指定次数</li></ul><p>eg：通过按钮实现(或div)实现路由跳转</p><pre><code>&lt;template>  &lt;div>   &lt;button class="link" @click="backTo">回退&lt;/button>    &lt;button class="link" @click="forwardTo">前进&lt;/button>    &lt;button class="link" @click="goTo">跳转&lt;/button>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">            &lt;button @click="pushTo(t)">push&lt;/button>            &lt;button @click="replaceTo(t)">replace&lt;/button>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125;,    methods:&#123;        backTo()&#123;      this.$router.back() //回退一次    &#125;,    forwardTo()&#123;      this.$router.forward() //前进一次    &#125;,    goTo()&#123;      this.$router.go(-2) //，回退2步，正数前进，负数后退    &#125;,        pushTo(m)&#123;    //跳转到指定组件            this.$router.push(&#123;                path:'/about/aboutWeb/webTech',                query:&#123;                name:m.name,                lang:m.language            &#125;            &#125;)        &#125;,        replaceTo(n)&#123;  //跳转到指定组件并替换上一个历史记录            this.$router.replace(&#123;                path:'/about/aboutWeb/webTech',                query:&#123;                name:n.name,                lang:n.language            &#125;            &#125;)        &#125;    &#125; &#125;&lt;/script></code></pre><h3 id="路由组件的缓存"><a href="#路由组件的缓存" class="headerlink" title="路由组件的缓存"></a>路由组件的缓存</h3><p>当组件进行切换时，原组件会被销毁，原组件中未保存的表单内容等数据同时也会被删除，此时，可以使用<span class="tips">&lt;keep-alive&gt;</span>标签阻止组件被销毁，保留数据。</p><pre><code> //缓存多组件使用 :include="['组件1','组件2',...]"&lt;keep-alive include="aboutMe">   &lt;router-view>&lt;/router-view>&lt;/keep-alive></code></pre><h3 id="路由独有生命周期"><a href="#路由独有生命周期" class="headerlink" title="路由独有生命周期"></a>路由独有生命周期</h3><ul><li><span class="strong">activated：</span>当组件被激活时(显示到页面)</li><li><span class="strong">deactivated：</span>当组件失活时<br>当组件被&lt;keep-alive&gt;时，组件不会被销毁，在切换组件时created、destory等钩子函数不会执行，此时可以使用activated、deactivated替代。</li></ul><p>eg：使某组件在激活时启用定时器，失活时关闭</p><pre><code> export default &#123;  name:'webTech',  data()&#123;.....&#125;,  activated()&#123;            let timer=setInterval(....);            &#125;,  deactivated()&#123;            clearInterval(this.timer)            &#125; &#125;</code></pre><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p> 在切换组件时，可借助路由守卫来阻止/放行组件的跳转，常用于判断用户是否有权限访问，无权限时阻止访问,也可用于在组件跳转前后执行某些功能。</p><h4 id="前置、后置路由守卫-全局"><a href="#前置、后置路由守卫-全局" class="headerlink" title="前置、后置路由守卫(全局)"></a>前置、后置路由守卫(全局)</h4><p> 该路由守卫写于路由器配置文件中</p><ul><li><span class="strong">beforeEach((to,from,next)=&gt;{ })：</span>前置路由守卫，在<span class="tips">初始化、路由跳转前</span>执行，接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行</li><li><span class="strong">beforeEach((to,from)=&gt;{ })：</span>后置路由守卫，在<span class="tips">路由跳转后</span>执行，接收to,from两个参数</li></ul><p>eg: 检查用户是否为指定用户，不是则禁止访问aboutWeb和aboutMe组件</p><pre><code> import VueRouter from "vue-router"; import Home from '../pages/pageHome' import About from '../pages/pageAbout' import aboutMe from '../pages/aboutMe' import aboutWeb from '../pages/aboutWeb' import webTech from '../pages/webTech' const router= new VueRouter(&#123;    routes:[        &#123;            name:'home',            path:'/home',               component:Home,             meta:&#123;title:'首页'&#125;//meta为自定义属性，程序员可自定义添加任何参数        &#125;,        &#123;            name:'about',            path:'/about',            component:About,            meta:&#123;title:'关于'&#125;,            children:[                &#123;                    name:'aboutme',                    path:'aboutMe',                    component:aboutMe,                    meta:&#123;isAuth:true,//标识该组件是否需要鉴别权限                          title:'关于我'&#125;//用于组件跳转后修改地址栏标题                &#125;,                &#123;                    name:'aboutweb',                    path:'aboutWeb',                    component:aboutWeb,                    meta:&#123;isAuth:true,                        title:'关于网站'&#125;,                    children:[                        &#123;                            name:'webTech',                            path:'webTech',                            component:webTech,                            meta:&#123;title:'关于本站采用的技术'&#125;                        &#125;                    ]                &#125;            ]        &#125;    ] &#125;)// 全局前置路由守卫 router.beforeEach((to,from,next)=>&#123;        if(to.meta.isAuth)&#123;//确认是否鉴权，避免对所有组件都进行鉴权消耗性能 // 当组件不多时，可以使用下面的代码通过判断路径来识别哪些组件需要权限认证        // if(to.name==='aboutme'||to.path==='/about/aboutWeb')        //只有localStorage中的user为zhoujielun才能访问            if(localStorage.getItem('user')==='zhoujielun')&#123;                next() //放行访问            &#125;            else&#123;                alert('无权限访问')            &#125;        &#125;        else&#123;            next()  //对不需要权限认证的页面直接放行        &#125;  &#125;)// 全局后置路由守卫//用于切换完毕后，修改网页地址栏的标题 router.afterEach((to)=>&#123;    document.title=to.meta.title   &#125;) export default router</code></pre><h4 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h4><p>只为某个路由组件配置的路由守卫， 同样写于路由器配置文件中<br><span class="strong">beforeEnter:(to,from,next)=&gt;{ }</span>只对针对某个组件配置守卫，同样接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行</p><p>eg: 判断用户是否为指定用户，不是则禁止访问aboutMe组件</p><pre><code>&#123;            name:'about',            path:'/about',            component:About,            meta:&#123;title:'关于'&#125;,            children:[                &#123;                    name:'aboutme',                    path:'aboutMe',                    component:aboutMe,                    meta:&#123;isAuth:true,//鉴别权限                          title:'关于我'&#125;,                          //独享路由守卫                          beforeEnter:(to,from,next)=>&#123;                                if(to.meta.isAuth)&#123;                                  //只有localStorage中的user为zhoujielun才能访问                                    if(localStorage.getItem('user')==='zhoujielun')&#123;                                        next()                                    &#125;                                    else&#123;                                        alert('无权限访问')                                    &#125;                                &#125;                                else&#123;                                    next()                                &#125;                           &#125;                &#125;,</code></pre><h4 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h4><p>无法修改路由器配置文件时，可以将路由守卫设于组件.vue的文件中。<span class="tips">组件内的路由守卫只会在通过路由规则进入组件时才会执行</span>，如果将组件标签直接添加到页面中，该组件会被调用，但此时不属于通过路由规则进入组件，不会执行下述路由守卫函数。</p><ul><li><span class="strong">beforeRouteEnter(to,from,next){ }</span>：进入组件前执行</li><li><span class="strong">beforeRouteLeave(to,from,next){ }</span>：离开组件前执行</li><li><span class="strong">beforeRouteUpdate(to,from,next){ }</span>：组件更新时执行</li></ul><pre><code>&lt;template>  &lt;div class="about">    &lt;h2>About页面&lt;/h2>    &lt;div class="about-btn">    &lt;router-link  to="/about/aboutWeb">关于网页&lt;/router-link>    &lt;router-link  to="/about/aboutMe">关于我&lt;/router-link>    &lt;/div>    &lt;div class="about-content">      &lt;keep-alive include="aboutMe">      &lt;router-view>&lt;/router-view>      &lt;/keep-alive>    &lt;/div>  &lt;/div> &lt;/template> &lt;script> export default &#123;    name:'pageAbout',    // 通过路由规则进入组件时调用    beforeRouteEnter(to,from,next)&#123;      //只有localStorage中的user为zhoujielun才能访问            if(localStorage.getItem('user')==='zhoujielun')&#123;                    next()                    &#125;            else&#123;                 alert('无权限访问')             &#125;    &#125;,     // 通过路由规则离开组件时调用    beforeRouteLeave(to,from,next)&#123;      console.log('即将离开组件')        next();//放行    &#125;&#125; &lt;/script></code></pre>]]></content>
    
    
    <summary type="html">vue构建单页应用笔记，包括路由嵌套、传参、导航、生命周期、路由守卫</summary>
    
    
    
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
    <category term="vue" scheme="https://shiwei11.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>yaml语法</title>
    <link href="https://shiwei11.github.io/blog/2022/07/14/yaml%E8%AF%AD%E6%B3%95/"/>
    <id>https://shiwei11.github.io/blog/2022/07/14/yaml%E8%AF%AD%E6%B3%95/</id>
    <published>2022-07-14T07:48:44.000Z</published>
    <updated>2022-07-16T05:55:32.969Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>YAML官方文档：<a href="https://yaml.org/spec/1.2.2/">YAML 1.2.2</a></div><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>YAML是一种数据序列化语言，可用于存储和传输数据，常用于编写配置文件、数据文件、日志文件，以及跨语言进行数据共享等环境，大多数编程语言都可以使用 YAML 进行数据序列化。</p><p>YAML文件后缀为<span class="tips">.yml</span>或<span class="tips">.yaml</span></p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><span class="strong">1. 通常使用键值对形式</span></p><ul><li>键与值通常不需要引号包裹 (这点与json不同)</li><li>值可以为：数组、对象、标量值</li><li>标量值是指：整数、浮点数、字符串、布尔值、Null、时间、日期</li></ul><p><span class="strong">2. 通过缩进或者样式流表示数据结构</span></p><ul><li>数据可以通过空格缩进来表示层级关系，但不能用制表符(Tab)</li><li>子结构相较父结构必须缩进至少一个空格，同一级数据须缩进相同空格数，即左端对齐</li><li>也可以使用花括号{&nbsp;}，中括号[&nbsp;]等样式流表示层级关系<br><span class="strong">3. 大小写敏感</span><br><span class="strong">4. 使用#号注释</span></li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>最为常用的数据类型，又称为字典、哈希、映射，以<span class="tips"> key: &nbsp;value </span>键值对的形式存储数据，<span class="tips">key: 后需要有空格!</span></p><h4 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h4><div class="show">name: JayChoualbum: 十一月的萧邦</div><p>或者使用样式流：</p><div class="show">{    name: JayChou,    album: 十一月的萧邦}</div>等同于json格式下的<div class="show">{  "name": "JayChou",  "album": "十一月的萧邦"}</div><h4 id="缩进与嵌套"><a href="#缩进与嵌套" class="headerlink" title="缩进与嵌套"></a>缩进与嵌套</h4><p>可以通过缩进至少一个空格表示层级关系，从而嵌套其他对象、数组等</p><div class="show">student:   name: aaa   age: 16   hobby:    - basketball    - swimming</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>多级嵌套时，每层嵌套都应当缩进，<span class="tips">且每个子元素左边应该缩进相等的空格数，即左端对齐</span></div>   使用样式流：   <div class="show">student: {        name: aaa,        age: 16,        hobby: [ basketball , swimming ]   }</div><h4 id="复杂对象格式"><a href="#复杂对象格式" class="headerlink" title="复杂对象格式"></a>复杂对象格式</h4><p>使用<span class="tips">?加空格</span>可以指定多个key值，使用<span class="tips">:加空格</span>指定多个value</p><div class="show">?       - key1      - key2:       - value1      - value2</div>    表示key是一个数组，值也是一个数组，样式流：    <div class="show">key1,key2: ["value1","value2"]</div><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用<span class="tips strong">-</span>开头表示数组元素</p><h4 id="数组写法"><a href="#数组写法" class="headerlink" title="数组写法"></a>数组写法</h4><div class="show">- value1- value2- value3</div>样式流：<div class="show">[value1,value2,value3]</div><h4 id="缩进与嵌套-1"><a href="#缩进与嵌套-1" class="headerlink" title="缩进与嵌套"></a>缩进与嵌套</h4><p>可以通过缩进表示层级关系，来嵌套数组、对象等</p><div class="show">- name: 周杰伦,  age: 42,  songs:    - 夜曲   - 米兰的小铁匠- name: 林肯公园,  age: 41,  songs:   - In the End   - Numb</div>样式流<div class="show">[  {    name: 周杰伦,    age: 42,    songs: [ 夜曲 , 米兰的小铁匠 ]  },  {    name: 林肯公园,    age: 41,    songs: [ In the End , Numb ]  }]</div><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>标量指最基本的，不可再分的值，这里指：整数、浮点数、字符串、布尔值、Null、时间、日期</p><p>基本使用方法：</p><div class="show">1. 整数可以为非十进制数num1: 120           #普通十进制数num2: 0b10_1011     #二进制以0b开头num3: 07100         #八进制以0开头num4: 0xf1ab        #十六进制以0x开头2. 浮点数可以使用科学计数法float1: 3.14float2: 3.1415926e+5 #科学计数法314159.26float3: -.inf        #负无穷大flota4: .nan         #不是数字3. 布尔值大小写均可bool: true值为：true、True、TRUE均可，但TRUe将被解析为字符串4. Null可用<span class="tips">~</span>表示data: ~5. 日期必须使用ISO 8601格式，即yyyy-MM-dddate: 2021-07-156. 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区time: 2021-07-15T00:42:31+08:00在JavaScript中解析为Thu Jul 15 2021 00:42:31 GMT+0800 (中国标准时间)7. 使用<span class="tips">!!数据类型 值</span>进行类型转换date: !!str 2021-01-15</div><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>一般情况下，字符串不需要添加引号，但如果字符串中间包含特殊字符，尤其是<span class="tips">冒号加空格</span>组合时，为了避免被yaml解析为键值对，需要添加引号</p><div class="show">str: 'said: meet you like wind'</div><p>给数值等标量添加引号将解析为字符串</p><div class="show">str: '99.99'</div><p>多行字符串，<span class="tips">第二行开始所有行需要缩进至少一个空格</span>，但解析时将被解析为一行字符串，且换行符会被替换为空格</p><div class="show">str: aaaa bbbb cccc 将被解析为 str: "aaaa bbbb cccc"</div><h4 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h4><p> 单引号和双引号均可以用于包裹字符串</p><ul><li><span class="strong">单引号会原样输出，将转义字符作为普通字符串输出</span></li><li><span class="strong">双引号会转义字符串，如将 \n 转义为换行</span></li></ul><div class="show">如：content: '不会\n换行'内容输出为：<span class="tips">不会\n换行</span>content: "进行\n换行"内容输出为： <span class="tips">进行  换行</span></div><h4 id="区块字符串处理"><a href="#区块字符串处理" class="headerlink" title="区块字符串处理"></a>区块字符串处理</h4><ol><li><p>多行字符串可以使用<span class="tips strong">|</span>保留所有换行符，内容从第二行开始需要缩进至少一个空格，且最后一行的换行符也会保留。</p><div class="show">lyrics: |aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd<br/></div></li><li><p>可以使用<span class="tips strong">&gt;</span>去除换行，换行符将被空格代替 (如果某一行是空行，该空行会被额外保留)</p><div class="show">lyrics: >aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbb cccc dddd</div></li><li><p>可以使用<span class="tips strong">+</span>保留文字块末尾的换行</p><div class="show">lyrics: |+aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd<br/></div></li><li><p>可以使用<span class="tips strong">-</span>去除文字块末尾的换行</p><div class="show">lyrics: |-aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd</div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>在yml文件中配置好字符串格式后，读取到html中时往往需要添加如<span class="tips">white-space: pre-line;</span>等css属性来保留换行符和空格，否则读入的数据可能会被css默认样式去除换行符，从而无法展示原生yml指定的数据格式</div></li><li><div class="tips strong">在样式流中，无法使用 | > + -</div><div class="show">如：以上数据写为样式流          {             lyrics: |-             aaaa              bbbb             cccc              dddd            }|- 将无法解析，抛出错误</div></li></ol><h3 id="添加HTML标签"><a href="#添加HTML标签" class="headerlink" title="添加HTML标签"></a>添加HTML标签</h3><p>yaml允许在值中添加HTML标签，并且标签会被正确地解析为DOM</p><div class="show">- tag: web  content: 推荐网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>  或  <div class="show">- tag: web  content: |-   推荐   网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>解析为：<div class="show">推荐网站 <a href="#">SHIWIVI</a></div>   <div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>使用时需要注意，插入的HTML标签是否会被其他语言解析为字符串，但yaml本身是可以输出为DOM元素的</div><h3 id="锚点与引用"><a href="#锚点与引用" class="headerlink" title="锚点与引用"></a>锚点与引用</h3><p>可以使用<span class="tips">&amp;</span>定义一个锚点，然后使用<span class="tips">*</span>引用锚点</p><div class="show">first: &anchor  #定义锚点 - aaa - bbbsecond:  *anchor #调用锚点</div>解析为<div class="show">first: [aaaaa,bbb]second: [aaaaa,bbb] </div><p>如果将多个键值对引用到其他地方，可以使用<span class="tips">&lt;&lt;</span>合并数据</p><div class="show">first: &data  #定义锚点   name: lol   age: 18   hobby:    - sing    - swingsecond:    <<: *data    #将数据插入此处   address: zzz</div> 解析为： <div class="show">{  "first": {      "name": "lol",      "age": 18,      "hobby": "sing  swimming"  },  "second": {      "name": "lol",      "age": 18,      "hobby": "sing  swimming",      "address": "zzz"  }}</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>如果多次定义了同名的锚点(重定义)，则先定义的锚点会被覆盖</div><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>一个完整的yml文档以<span class="tips">-&zwnj;-&zwnj;-</span>标识文档开始，以<span class="tips">…</span>标识文档结束，该标识非必须，无标识的称为<span class="tips">裸文档</span>，文件开头可以添加<span class="tips">%YAML</span>来识别文件的YAML版本</p><div class="show">%YAML 1.2# 开头注释，注明文档作者等信息---ip: 45.77.77.49port: 443...</div><p>一个yml文件中可能有多个文档</p><div class="show">---ip: 45.77.77.10port: 80...---ip: 45.77.77.11port: 443...</div>但如果在一个yml文件中写入多个文档，在某些环境下读入可能报错，需要分割为多个文件<div class="shell">err: YAMLException: expected a single document in the stream, but found more</div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>更多语法和拓展详见官方文档</div>]]></content>
    
    
    <summary type="html">YAML Ain’t Markup Language，小猫咪都会写的yaml文件</summary>
    
    
    
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
    <category term="File" scheme="https://shiwei11.github.io/blog/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Grid栅格布局</title>
    <link href="https://shiwei11.github.io/blog/2022/06/14/Grid%E5%B8%83%E5%B1%80/"/>
    <id>https://shiwei11.github.io/blog/2022/06/14/Grid%E5%B8%83%E5%B1%80/</id>
    <published>2022-06-14T07:03:12.000Z</published>
    <updated>2022-07-02T11:49:59.185Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>Grid在MDN上翻译为网格布局，在《CSS权威指南》中翻译为栅格布局，其实是同一种布局方案，本文语句主要整理自《CSS权威指南》一书</div><h3 id="1-栅格布局"><a href="#1-栅格布局" class="headerlink" title="1. 栅格布局"></a>1. 栅格布局</h3><p>Grid 是一种强大的布局方案，也是最为普适的布局方案，允许在Web上创建二维布局，通过对父元素定义不同参数的行与列垂直线，再将子元素部署于行列网格上，由此实现各类灵活的布局，如：<br><br/></p><div style="display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;"><div style="background-color:#EA2027;grid-area:a;">box1</div><div style="background-color:#fff200;grid-area:b;">box2</div><div style="background-color:#7d5fff;grid-area:c;">box3</div><div style="background-color:#32ff7e;grid-area:d;">box4</div><div style="background-color:#4b4b4b;grid-area:e;">box5</div></div><br/><p>通过标准流、float、flex也可以实现类似的布局，但这些方案往往需要更多的DOM元素，或者需要指定更多的参数，并且很多情况下无法做到自适应，此时，grid布局方案的优势就体现出来了。并且语法兼容性也很好，除了那位大爷…..</p><div class="table"><table><thead><tr><th>Chrome</th><th>Edeg</th><th>Firefox</th><th>IE</th><th>Opera</th><th>Safari</th></tr></thead><tr><td>57</td><td>16</td><td>52</td><td style="color:red;">不支持</td><td>44</td><td>10.1</td></tr></table></div><h3 id="2-栅格容器"><a href="#2-栅格容器" class="headerlink" title="2. 栅格容器"></a>2. 栅格容器</h3><p>创建栅格的第一步就是创建一个栅格容器，并将其中的内容定义为栅格布局</p><h4 id="2-1-栅格属性"><a href="#2-1-栅格属性" class="headerlink" title="2.1 栅格属性"></a>2.1 栅格属性</h4><p><span class="strong">display: grid/inline-grid;</span></p><p>指定容器布局方式为栅格布局，该属性和 block 与 inline-block 值相似</p><h4 id="2-2-定义栅格模板"><a href="#2-2-定义栅格模板" class="headerlink" title="2.2 定义栅格模板"></a>2.2 定义栅格模板</h4><p><span class="strong">grid-template-columns: 值;</span></p><p><span class="strong">grid-template-rows: 值;</span></p><p>将容器划分为行列栅格,栅格线的值可以为<span class="tips">固定值</span>、<span class="tips">百分比</span>、<span class="tips">fr关键字</span>、<span class="tips">repeat()语句</span>、<span class="tips">minmax()语句</span>、<span class="tips">calc()函数</span>等，并且参数可以混用</p><h5 id="2-2-1-固定值行列轨道宽度"><a href="#2-2-1-固定值行列轨道宽度" class="headerlink" title="2.2.1 固定值行列轨道宽度"></a>2.2.1 固定值行列轨道宽度</h5><p>将子元素宽高设为固定值，单位可以为px，也可以为em、rem等相对单位</p><div class="show">如：给父元素指定行列轨道宽度，子元素可以不设置任何参数div{    display:grid;    grid-template-columns:50px 60px 100px;    grid-template-rows:50px 60px 100px;}</div><div style="display:grid;grid-template-columns:50px 60px 100px;grid-template-rows:50px 60px 100px;text-align:center;color:#fff;width:210px;margin:0 auto;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">类似的取值可以为    grid-template-columns:5em 5em 5em;</div><h5 id="2-2-2-百分比配置宽高"><a href="#2-2-2-百分比配置宽高" class="headerlink" title="2.2.2 百分比配置宽高"></a>2.2.2 百分比配置宽高</h5><p>将元素的宽高按百分比配置，可以让网页元素自适应不同屏幕大小</p><div class="show">如：元素宽高分别为20% 20% 50% div{    display:grid;    grid-template-columns:20% 20% 50%;    grid-template-rows:20% 20% 50%;    border:1px solid black;    box-sizing: border-box;}</div><div style="display:grid;grid-template-columns:20% 20% 50%;grid-template-rows:20% 20% 50%;text-align:center;color:#fff;width:280px;height:300px;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>百分比是基于父容器的宽度和高度计算，不管子元素内容大小如何变化也不会变，因此要给与父元素宽高参数，即不能再使用子元素撑开父元素了。若子元素宽高相加不到100%，则剩余部分空置</div><h5 id="2-2-3-fr按比例配置宽高"><a href="#2-2-3-fr按比例配置宽高" class="headerlink" title="2.2.3 fr按比例配置宽高"></a>2.2.3 fr按比例配置宽高</h5><p>grid布局提供了 <span class="tips">fr</span> 关键字(fraction)用于表示比例关系</p><div class="show">如：元素宽高比为1:2:2 div{    display:grid;    grid-template-columns:1fr 2fr 2fr;    grid-template-rows:1fr 2fr 2fr;    border:1px solid black;    box-sizing: border-box;}</div><div style="display:grid;grid-template-columns:1fr 2fr 2fr;grid-template-rows:1fr 2fr 2fr;text-align:center;color:#fff;width:210px;margin:0 auto;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">配合其他值来实现弹性布局     grid-template-columns:150px 1fr 10%;     <span class="tips">第一列宽为150px，最后一列宽为10%,剩下宽度给中间一列</span></div><h5 id="2-2-4-定义栅格线名称"><a href="#2-2-4-定义栅格线名称" class="headerlink" title="2.2.4 定义栅格线名称"></a>2.2.4 定义栅格线名称</h5><p>可以使用<span class="tips">[ ]</span>为边框线起名字，并且同一条线的名称可以有无数多个，如：<span class="tips">[a1 b1]</span>为同一条线取名a1和b1</p><div class="show">如：元素宽高比为1:2:2 div{    display:grid;    grid-template-columns: [c1] 80px [c2] 80px [c3] 80px [c4];    grid-template-rows: [r1] 60px [r2] 60px [r3] 60px [r4];    border:1px solid black;    box-sizing: border-box;}box1、box4、box7左边框线相连为c1，右边框线相连为c2；box1、box2、box3上边框线相连为r1，下边框线相连为r2其他以此类推</div><div style="display:grid;grid-template-columns:[c1] 80px [c2] 80px [c3] 80px [c4];    grid-template-rows:[r1] 60px [r2] 60px [r3] 60px [r4];text-align:center;color:#fff;margin:0 auto;width:240px;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h5 id="2-2-5-repeat-重复填充"><a href="#2-2-5-repeat-重复填充" class="headerlink" title="2.2.5 repeat()重复填充"></a>2.2.5 repeat()重复填充</h5><p>对于多个宽高值相同的元素，可以使用<span class="tips">repeat()</span>语句简写</p><div class="show">如：1. 对于grid-template-columns: 5em 5em 5em;该语句可以简写为    grid-template-columns: repeat(3,5em);2. 类似地可以创建宽度有一定规律的子元素    如：创建宽度依次为20px,40px,60px,20px,40px,60px的6列元素    grid-template-columns: repeat(2, 20px 40px 60px);3. 还可以repeat()前后添加不想重复的宽高值    grid-template-columns: repeat(2,1em 5em) 2em;    这就生成了1em 5em 1em 5em 2em的网格4. 百分号和比例依旧适用    grid-template-columns: repeat(3,33.3%);5. 如果包含了栅格线名，名称也会被复制    grid-template-columns: repeat(3,[top] 5em [bottom]);    则会生成    [top] 5em [bottom top] 5em [bottom top] 5em [bottom]    即：中间的栅格线将会有两个名称，该语句等同于：    grid-template-columns: [top] 5em [bottom top] 5em [bottom top] 5em [bottom];</div><h5 id="2-2-6-minmax-限制尺寸"><a href="#2-2-6-minmax-限制尺寸" class="headerlink" title="2.2.6 minmax()限制尺寸"></a>2.2.6 minmax()限制尺寸</h5><p>当子元素溢出父容器之外时，除了使用<span class="tips">overflow: hidden;</span>外，还可以使用<span class="tips">minmax(最小值，最大值)</span>来限制宽高尺寸</p><div class="show">如：将剩余空间分配给第二列，但又要避免他被挤占得太小     grid-template-columns:5em minmax(10%,1fr) 2em;</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>注意！当minmax()中最大值小于最小值时，最大值将失效。如minmax(100px,2em)中，当2em计算值小于100px时，元素宽高将被解析为100px</div><h5 id="2-2-7-calc-计算尺寸"><a href="#2-2-7-calc-计算尺寸" class="headerlink" title="2.2.7 calc()计算尺寸"></a>2.2.7 calc()计算尺寸</h5><p>grid是支持<span class="tips">calc()</span>语句的，只是有时候不太适用</p><div class="show">如：第二列宽度通过计算得出     grid-template-columns:2em calc(100%-1.5em) 10%;</div><h5 id="2-2-8-根据内容自适应"><a href="#2-2-8-根据内容自适应" class="headerlink" title="2.2.8 根据内容自适应"></a>2.2.8 根据内容自适应</h5><p>子元素宽高还可以根据子元素内容，通过<span class="tips">max-content</span>、<span class="tips">min-content</span>、<span class="tips">fit-content</span>来实现栅格自适应</p><ul><li><span class="strong">max-content:</span>解析为尽可能大的空间，以防换行</li><li><span class="strong">min-content:</span>解析为尽可能小的空间，能够显示内容即可</li><li><span class="strong">fit-content:</span>解析为空间尽可能小，但如果超过指定空间大小就换行</li></ul><div class="show">如：尽可能容纳内容div{    display:grid;    grid-template-columns:max-content max-content max-content;    grid-template-rows:max-content max-content max-content;}可以看到，每一列的宽度由该列有最长内容的列宽决定，行类似。当父元素指定宽度时，这可能会溢出到父容器之外</div><div style="display:grid;grid-template-columns:max-content max-content max-content;grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">1</div><div style="background-color:#fff200;">22</div><div style="background-color:#7d5fff;">33333333</div><div style="background-color:#32ff7e;">44444444444</div><div style="background-color:#4b4b4b;">5</div><div style="background-color:#67e6dc;">6</div><div style="background-color:#ff9f1a;">77</div><div style="background-color:#ffb8b8;">8888</div><div style="background-color:#c56cf0;">9</div></div><div class="show">配合minmax()使用可以不破坏外部布局，但会挤压内部空间div{    display:grid;    grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);    grid-template-rows:max-content max-content max-content;}</div><div style="display:grid;grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">1</div><div style="background-color:#fff200;">22</div><div style="background-color:#7d5fff;">33333333</div><div style="background-color:#32ff7e;">44444444444</div><div style="background-color:#4b4b4b;">5</div><div style="background-color:#67e6dc;">6</div><div style="background-color:#ff9f1a;">77</div><div style="background-color:#ffb8b8;">8888</div><div style="background-color:#c56cf0;">9</div></div><div class="show"><span class="tips">fit-content</span>用于限制最大长度，类似于max-width指定三列宽均为50等宽字符，当未满50ch时按实际字符长度算，超过该值则进行换行，即最大值只能为50chdiv{    display:grid;    grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(5.0ch);}只指定宽度，高度自适应，第一第二列未满50ch时，以各自长度为列宽，第三列超过50ch，则进行换行，以50ch为列宽</div><div style="display:grid;grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(50ch);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#18dcff;">the night</div><div style="background-color:#4b4b4b;">Avicii</div><div style="background-color:#7d5fff;">He said one day you will leave this world behind So live a life you will remember</div></div><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>当父容器较小时，第一、第二列即便未满50ch也可能会进行换行，以保证不会溢出父亲容器</div><h5 id="2-2-9-auto-fill自动填充"><a href="#2-2-9-auto-fill自动填充" class="headerlink" title="2.2.9 auto-fill自动填充"></a>2.2.9 auto-fill自动填充</h5><p>当父容器宽度固定，可以使用<span class="tips">auto-fill</span>让子元素根据大小自动填充</p><div class="show">如：div{    display:grid;    width:50vh;    grid-template-columns:repeat(auto-fill,5em);    grid-template-rows:max-content max-content max-content;    }在父容器中尽量排列宽3em的元素，排列到第一行排完，如果剩下空间不足3em，则剩余子元素将进行换行</div><div style="display:grid;grid-template-columns:repeat(auto-fill,3em);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">1. 一个父容器的宽/高只能有一次自动排列，因此下述语句是不允许的grid-template-columns: repeat(auto-fill,5em) repeat(auto-fill,2em);2. 但可以固定尺寸的repeat与自动填充的repear共存，如：grid-template-columns: repeat(2,5em) repeat(auto-fill,2em);或者grid-template-columns: repeat(auto-fill,5em) repeat(3,2em);但无论语序如何，grid总会为固定尺寸的元素分配空间，因此auto-fill会被最后才被分配空间</div><h4 id="2-3栅格间距"><a href="#2-3栅格间距" class="headerlink" title="2.3栅格间距"></a>2.3栅格间距</h4><p>通过<span class="tips">row-gap</span>、<span class="tips">column-gap</span>来设置栅格见的行、列间隔。或者将两个属性合并为一个 <span class="tips">grid-gap：行间隔 列间隔;</span></p><div class="show">给父容器添加该属性div{    display:grid;    width:50vh;    height:50vh;    grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);    row-gap:10px;    column-gap:10px;    }如图所见，添加间隔可能导致栅格溢出，这两个属性可合并为 grid-gap ，如果该语句之后的值只有一个，则解析为行列间隔都为该值。    grid-gap:10px 10px;等价于    grid-gap:10px;</div><div style="display:grid;grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);row-gap:10px;    column-gap:10px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h3 id="3-栅格区域"><a href="#3-栅格区域" class="headerlink" title="3. 栅格区域"></a>3. 栅格区域</h3><p>此前都是给父容器添加属性，但如果同时给子元素添加相应属性可以做出更好的布局</p><h4 id="3-1-调用栅格线名"><a href="#3-1-调用栅格线名" class="headerlink" title="3.1 调用栅格线名"></a>3.1 调用栅格线名</h4><p>通过<span class="tips">grid-template-columns</span>、<span class="tips">grid-template-rows</span>定义栅格宽高和栅格线名后，可以通过下列语句调用栅格线名</p><ul><li><span class="strong">grid-column-start：</span>列开始的栅格线名</li><li><span class="strong">grid-column-end：</span>列结束的栅格线名</li><li><span class="strong">grid-row-start：</span>行开始的栅格线名</li><li><span class="strong">grid-row-end：</span>行结束的栅格线名</li></ul><div class="show">通过四条边来定义子元素的具体位置，当未定义栅格线名时，可以使用1，2，3...作为栅格线名.box1 {    grid-column-start:1;    grid-column-end:2;    grid-row-start:2;    grid-row-end:4;    background-color: #ff3426;//红色}.box2 {    grid-column-start:3;    grid-column-end:5;    grid-row-start:1;    grid-row-end:3;    background-color: #39f64f;//绿色}<p>.parbox {<br>    display:grid;<br>    grid-template-columns: repeat(4,50px);<br>    grid-template-rows: repeat(4,50px);<br>}<br>栅格线名可以为负数，表示从该栅格线往其反方向数</p></div><div style="display:grid;display:grid;grid-template-columns: repeat(4,50px);grid-template-rows: repeat(4,50px);text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;box-sizing: border-box;"><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #ff3426;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #ff3426;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div></div><div class="show">1. 栅格线的编号可以为<span class="tips">负值</span>，表示从倒数第n条线开始从后往前数如：不知道栅格有几列，但想从最右边的栅格线开始部署，可以使用        grid-column-start:-1;        grid-row-start:-1;(行同理)2. 如果为栅格线定义过名称，则可以使用该名称作为上述语句的值，如果变量对应的栅格线有多条，则使用<span class="strong">变量名 序号</span>来确定具体的栅格线，序号从1开始排列。如：有多条名为col-A的线，表示列从第4条col-A开始：            grid-column-start:col-A 4;3. 此外可以使用<span class="tips">span</span>语句指定子元素跨越的行列数，如：.box1 {    grid-column-start:1;    grid-column-end: span 1;    grid-row-start:2;    grid-row-end: span 2;}上述代码等同于：.box1 {    grid-column-start:1;    grid-column-end: 2;    grid-row-start:2;    grid-row-end: 4;}表示该子元素从左边框号1开始，跨越1列，从上边框号2开始，跨越2行，其中<span class="strong">span 1</span>可以直接简写为<span class="strong">span</span>(默认为1)，且span后的值不能为<span class="tips">0</span>或<span class="tips">负值</span>4. 当使用 <span class="strong">span 栅格线名 n</span> 时，表示该元素跨越了n条该名称的栅格线如：栅格部署为A、B栅格线交替命名时A 格子 B 格子 A 格子 B 格子 A 格子 B 格子此时    grid-column-start: A 1;    grid-column-end: span 2 A;表示栅格从第1条A线开始，跨越1条名为A的栅格线，在下一个A线处结束</div><h4 id="3-2-调用栅格线名的简写"><a href="#3-2-调用栅格线名的简写" class="headerlink" title="3.2 调用栅格线名的简写"></a>3.2 调用栅格线名的简写</h4><p>上一节中 grid-column-start，grid-column-end和grid-row-start，grid-row-end用于指定栅格起始和结束的位置，该属性可以简写为</p><ul><li><span class="strong">grid-column: 起始栅格线/结束栅格线</span></li><li><span class="strong">grid-row: 起始栅格线/结束栅格线</span></li></ul><div class="show">1. 元素开始和结束的栅格线名用 / 隔开 .box1 {    grid-column-start:1;    grid-column-end: 2;    grid-row-start:2;    grid-row-end: 4;}等价于.box1 {    grid-column: 1 / 2;    grid-row: 2 / 4;}也可以用跨越了多少栅格表示.box1 {    grid-column: 1 / span 1;    grid-row: 2 / span 2;}2. 如果 / 和第二个值省略，则默认起始结束的栅格线名都一致如：列栅格线中有两条名为header的线，则        grid-column: header;等价于        grid-column: header / header;即以第一条header开始，第二条header结束，无论中间跨越多少栅格</div><h4 id="3-3-grid-area"><a href="#3-3-grid-area" class="headerlink" title="3.3 grid-area"></a>3.3 grid-area</h4><p>grid-area可用于调用网格线，也可用于为子元素命名</p><h5 id="3-3-1-grid-area调用网格线"><a href="#3-3-1-grid-area调用网格线" class="headerlink" title="3.3.1 grid-area调用网格线"></a>3.3.1 grid-area调用网格线</h5><p> grid-column-start，grid-column-end和grid-row-start，grid-row-end可以直接用一个语句代替：<br> <span class="strong">grid-area：行开始/列开始/行结束/列结束</span></p><div class="show">如：.box1 {    grid-row-start:2;    grid-row-end: 4;    grid-column-start:1;    grid-column-end: 2;  }等价于.box1 {    grid-area:2/1/4/2;}同样，值可以为跨越了多少个网格.box1 {  grid-area: 2 / 1 / span 2 / span 1;}</div><h5 id="3-3-2-grid-area为子元素命名"><a href="#3-3-2-grid-area为子元素命名" class="headerlink" title="3.3.2 grid-area为子元素命名"></a>3.3.2 grid-area为子元素命名</h5><p>可以通过<span class="tips">grid-area</span>给每个栅格子元素定义名称，然后由父容器通过<span class="tips">grid-template-areas</span>定义它们的排列方法</p><div class="show">如：.box1 {    grid-area: a;}.box2 {    grid-area: b;}.box3 {    grid-area: c;}.box4 {    grid-area: d;}.box5 {    grid-area: e;}.parbox {    display:grid;    grid-template-areas: 'a a a'                        &emsp;&emsp;&emsp;&emsp;'b c d'                        &emsp;&emsp;&emsp;&emsp;'b e e';}排列方法可以写于同一行上，但需要注意'&nbsp;'号grid-template-areas: 'a a a''b c d''b e e';</div><div style="display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;"><div style="background-color:#EA2027;grid-area:a;">box1</div><div style="background-color:#fff200;grid-area:b;">box2</div><div style="background-color:#7d5fff;grid-area:c;">box3</div><div style="background-color:#32ff7e;grid-area:d;">box4</div><div style="background-color:#4b4b4b;grid-area:e;">box5</div></div><div class="show">变量名应该尽量使用有含义的单词(子元素变量名应相应改变，这里只展示父容器属性).parbox {    display:grid;    grid-template-areas: 'header header header''left content right''left footer footer';}也可以省略其中的部分变量，使用...代替.parbox {    display:grid;    grid-template-areas: 'header header header''left ... right''left footer footer';}</div><h3 id="4-栅格的对齐方式"><a href="#4-栅格的对齐方式" class="headerlink" title="4. 栅格的对齐方式"></a>4. 栅格的对齐方式</h3><p>栅格对齐方式类似于flex弹性盒里的属性</p><div class="table"><table><thead><tr><th>属性</th><th>目标</th><th>适用于</th></tr></thead><tbody><tr><td>justify-self</td><td>行(一个栅格元素)</td><td>子元素</td></tr><tr><td>justify-items</td><td>行(所有栅格元素)</td><td>父容器</td></tr><tr><td>justify-content</td><td>行(整个栅格)</td><td>父容器</td></tr><tr><td>align-self</td><td>列(一个栅格元素)</td><td>子元素</td></tr><tr><td>align-items</td><td>列(所有栅格元素)</td><td>父容器</td></tr><tr><td>align-content</td><td>列(整个栅格)</td><td>父容器</td></tr></tbody></table></div><div class="show">以行为例.box1{    justify-self:start;}.box2{    justify-self:center;}.box3{    justify-self:end;}justify-self和justify-items用来调整单个或多个元素在它们自己栅格内的位置当justify-self赋值为start、center、end时，如果子元素没有指定宽度和高度，则会自动缩为仅合适内容的大小，对齐方式同单词含义。赋值为stretch时会被拉伸，完全填充box(同剩下的box)当需要所有元素都有该对齐方式，则可以给父容器添加justify-items和对应的值</div><div style="display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;justify-self:start;">box1</div><div style="background-color:#fff200;justify-self:center;">box2</div><div style="background-color:#7d5fff;justify-self:end;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">同样以行为例.parbox{    width:260px;    height:260px;    display:grid;    grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);    justify-content:center;}justify-content则是用来调整整个grid网格在父容器中的位置</div><div style="display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);justify-content:center;text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h3 id="5-隐式栅格"><a href="#5-隐式栅格" class="headerlink" title="5. 隐式栅格"></a>5. 隐式栅格</h3><p>此前通过<span class="strong">grid-template-rows</span>定义的栅格为<span class="tips">显式栅格</span>，当一部分栅格超出了显式栅格，系统会将超出的那部分定义为<span class="tips">隐式栅格</span>。可以使用<span class="tips strong">grid-auto-rows</span>与<span class="tips strong">grid-auto-columns</span>定义隐式栅格的大小</p><div class="show">如：.grid{    display:grid;    width:200px;    height:200px;        //定义2*2的显式栅格    grid-template-columns:100px 100px;    grid-template-rows:100px 100px;        //定义隐式栅格尺寸(以行为例)    grid-auto-rows: 50px;}box1、box2、box3、box4在显式栅格内，高为100px，box5，box6超出了显式栅格，高将变为隐式栅格的高50px</div><div style="display:grid;width:200px;    height:200px;grid-template-columns:100px 100px;grid-template-rows:100px 100px;grid-auto-rows: 50px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:5px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div></div><br/><br/><br/><h3 id="6-栅格流"><a href="#6-栅格流" class="headerlink" title="6. 栅格流"></a>6. 栅格流</h3><p>栅格流主要分为优先行、优先列、密集流三种模式，由<span class="tips">grid-auto-flow</span>决定</p><div class="show">grid-auto-flow的取值有row、column、dense(密集流) .box{    display: grid;    grid-template: repeat(3,80px) / repeat(3,80px);    width: 240px;    height: 240px;     grid-auto-flow: row;    }优先行与优先列的部署模型如下</div><div style="display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: row;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div></div><br/><div style="display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: column;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div></div><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>密集流的主要作用是让元素尽量靠紧，因此有时会破坏栅格元素的顺序进行密集分布，向任何可以插入的位置安插合适的子元素</div><h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h3><p>当输入错误的代码时，部分情况下grid会帮我们修正属性，但在有些情况下会抛弃部分无法解析的值，甚至不解析整个语句</p><div class="show">1. 当栅格开始线放在结束线后    grid-row-start:5;    grid-row-end:2;grid将修正为    grid-row-start:2;    grid-row-end:5;2. 当栅格开始线和结束线都被声明为了跨度    grid-row-start: span ;    grid-row-end: span 3;结束线的值将被修改为 auto    grid-row-start: span ;    grid-row-end: auto;3. 如果栅格开始线被声明为跨越已命名的线，则该语句将被认为非法    grid-row-start: span header;</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>当栅格元素出现重叠时，可以使用 z-index 或 order 进行排序，并且栅格元素可以使用margin、position等标准流、定位等属性。并且还有其他一些更复杂的属性简写语法，本文不再展开说明，具体可以查阅MDN的文档</div>]]></content>
    
    
    <summary type="html">Grid 是一种强大的布局方案，通过行和列的排列能组合出各种灵活的布局方案，并且能很好满足PC端到移动端的自适应需求</summary>
    
    
    
    
    <category term="css" scheme="https://shiwei11.github.io/blog/tags/css/"/>
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Vux状态管理</title>
    <link href="https://shiwei11.github.io/blog/2022/06/13/Vux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>https://shiwei11.github.io/blog/2022/06/13/Vux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</id>
    <published>2022-06-13T14:04:24.000Z</published>
    <updated>2022-07-20T14:25:41.358Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>Vux官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></div><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><span class="tips">Vuex</span>是专门为Vue应用程序开发的集中式状态(数据)管理插件，可以对Vue中的组件进行统一的数据管理。</p><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p>vue2的工程使用vux3，vue3的工程需要使用vux4，版本需要对应，这里以安装vux3为例</p><p>在脚手架中执行：</p><pre><code>npm i vuex@3</code></pre><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><img data-src="/blog/images/vuex_art.jpg" src="/blog/images/vuex_art.jpg" alt="vuex工作流程"><ul><li><span class="strong">Action</span>主要用于响应Vue Conponents的消息，或者从后端接收数据，并且可以将数据在Action中进行初步处理(主要为异步处理，如：添加定时器)</li><li><span class="strong">Mutation</span>主要用于处理数据，在Mutation处理的数据才能被Devtools调试工具监测</li><li><span class="strong">State</span>主要用于集中存储数据</li></ul><p><span class="strong">工作流程：</span>Vue Conponents发送消息<span class="tips">(dispatch)</span>给Action，或者Action通过Ajax等技术从后端异步获取数据 —&gt; Actions提交<span class="tips">(commit)</span>到Mutation —&gt; 数据在Mutation中进行处理后，修改<span class="tips">(mutate)</span>State中存储的数据 —&gt; 监测到State数据发生变化，Vue重新渲染<span class="tips">(render)</span>页面</p><p>vue组件的中数据不要预处理时，也可以越过Action，直接commit到mutation中进行处理</p><p><span class="strong">关于store：</span>store是Vuex的核心库，可以理解为一个容器，Action、Mutation、state由Store统一管理，在进行消息提交、数据操作时往往需要经过store，通过<span class="tips">this.$store.dispatch</span>、<span class="tips">this.$store.commit</span>等语句来调用api</p><h3 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h3><h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><h5 id="1-配置store"><a href="#1-配置store" class="headerlink" title="1. 配置store"></a>1. 配置store</h5><p>在src目录下新建store目录，新建index.js文件</p><pre><code>import Vue from 'vue'import Vue from 'vue'//引入并应用vuximport Vuex from 'vuex'Vue.use(Vuex)//创建action、mutations、stateconst actions=&#123;....&#125;const mutations=&#123;....&#125;const state=&#123;.....&#125;//创建并暴露Storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters&#125;)</code></pre><h5 id="2-引入store配置项"><a href="#2-引入store配置项" class="headerlink" title="2. 引入store配置项"></a>2. 引入store配置项</h5><p>在main.js中引入store配置项</p><pre><code>// 全写为import store from './store/index.js'import store from './store'new Vue(&#123;  render: h => h(App),  store  &#125;).$mount('#app')</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>eg：简单求和差案例，4个按钮分别实现求和、求差、判断偶数后求和、定时器延时1s求和</p><ul><li>直接求和、求差可以直接commit到Mutation中运算</li><li>判断当前值是否为偶数，延时求和需要dispatch到Action中预处理，再commit到Mutation中运算</li><li>需要多次处理的数据可以在Action中多次dispatch，处理完毕再commit</li></ul><h5 id="1-创建组件"><a href="#1-创建组件" class="headerlink" title="1. 创建组件"></a>1. 创建组件</h5><p>在components中创建Count.vue</p><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;$store.getters.addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;$store.state.sum&#125;&#125;&lt;/h3>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="incrace">加&lt;/button>    &lt;button @click="decrace">减&lt;/button>    &lt;button @click="addOpp">偶数才加&lt;/button>    &lt;button @click="addLate">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1, //加数        &#125;    &#125;,    methods:&#123;        // 求和、求差直接commit    incrace()&#123;        this.$store.commit('JIA',this.num)    &#125;,    decrace()&#123;        this.$store.commit('JIAN',this.num)    &#125;,    //延时、判断奇偶dispatch到actions经过处理后再提交    addOpp()&#123;        this.$store.dispatch('addOpp',this.num)    &#125;,    addLate()&#123;        this.$store.dispatch('addLate',this.num)    &#125;    &#125; &#125;&lt;/script></code></pre><h5 id="2-配置store"><a href="#2-配置store" class="headerlink" title="2. 配置store"></a>2. 配置store</h5><p>新建store目录并在该目录下新建index.js</p><pre><code>import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const actions=&#123;    // actions里的方法名一般小写    //接收参数 (context,实参)    // context是一个对象，拥有store的部分属性,变量名可以为其他    addOpp(context,value)&#123;                  if(!(value%2))&#123;             //判断是否为偶数，为偶数则commit到mutations        context.commit('JIA',value)        &#125;else&#123;            console.log('非偶数，数未提交')        &#125;    &#125;,    addLate(context,value)&#123;       //数据想要多道处理时，可以在actions内多次dispatch，无限套娃        setTimeout(()=>&#123;            context.dispatch('addLate2',value);            console.log('第一次延迟处理')        &#125;,500)    &#125;,    addLate2(context,value)&#123;      //数据经过第二道处理后，再提交        setTimeout(()=>&#123;            context.commit('JIA',value);            console.log('第二次延迟处理')        &#125;,500)    &#125;&#125;// mutations里的方法名一般大写，用于和actions里的区别const mutations=&#123;    //接收参数(state,实参)    JIA(state,value)&#123;           //加        state.sum+=value    &#125;,    JIAN(state,value)&#123;          //减        state.sum-=value;    &#125;&#125;const state=&#123; //存储数据    sum:0 &#125;const getters=&#123;                //读取数据前，想要预先进行处理使用getters    addTen(state)&#123;        return state.sum+10    &#125;&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters &#125;)</code></pre><h5 id="3-引入store配置项"><a href="#3-引入store配置项" class="headerlink" title="3. 引入store配置项"></a>3. 引入store配置项</h5><p>在main.js中引入store配置</p><pre><code>import Vue from 'vue'import App from './App.vue'import store from './store'// 全写为import store from './store/index.js'Vue.config.productionTip = false new Vue(&#123;  render: h => h(App),  store &#125;).$mount('#app')</code></pre><h5 id="4-引入Count组件"><a href="#4-引入Count组件" class="headerlink" title="4. 引入Count组件"></a>4. 引入Count组件</h5><p>在App中使用Count组件</p><pre><code>&lt;template>  &lt;div id="app">    &lt;Count/>  &lt;/div>&lt;/template>&lt;script>import Count from'./components/Count.vue'export default &#123;  name:'App',  components:&#123;    Count             &#125;   &#125;&lt;/script></code></pre><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>组件从state读取数据前，如果需要对数据进行预处理，可以在getter中进行。如：读取state中的num前进行处理(完整代码位于上一个案例)</p><h4 id="1-在store中添加getter"><a href="#1-在store中添加getter" class="headerlink" title="1. 在store中添加getter"></a>1. 在store中添加getter</h4><pre><code>const actions=&#123;.....&#125;const mutations=&#123;....&#125;const state=&#123;.....&#125;const getter=&#123;     //读取state中的sum前，将值增大10     addTen(state)&#123;        return state.sum+10;     &#125;&#125;</code></pre><h4 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2. 读取数据"></a>2. 读取数据</h4><p>读取数据使用</p><pre><code>$store.getters.addTen</code></pre><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>当一个组件需要获取多个数据(状态)时，调用数据和api需要大量使用this.$store.state.number等语句，为了减小代码书写量，可以在计算属性中借助<span class="tips">mapState</span>、<span class="tips">mapGetters</span>、<span class="tips">mapMutations</span>、<span class="tips">mapActions</span>辅助函数简化代码</p><h4 id="通过对象"><a href="#通过对象" class="headerlink" title="通过对象"></a>通过对象</h4><p>当组件中的方法名、变量名与State、Mutations…中的变量名不同时，需要通过对象方式接收。并借助模板语法解析变量，以读取State中的数据为例：</p><div class="show">...mapState({组件中的变量名:'state数据',.....})</div><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum1&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name1&#125;&#125;,从state获取song为&#123;&#123;song1&#125;&#125;&lt;/h2>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    //当使用mapState等语法时，需要在写函数时传参(num)    &lt;button @click="incrace(num)">加&lt;/button>    &lt;button @click="decrace(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script>//引入mapState、mapGetters、mapMutations、mapActions import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex' export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    computed:&#123;        //模板语法        ...mapState(&#123;sum1:'sum',name1:'name',song1:'song'&#125;),        ...mapGetters(&#123;addTen:'addTen'&#125;)        // 可以简写为数组形式...mapGetters(['addTen'])，在对象中不能简写，会解析为addTen:addTen，值也解析为变量    &#125;,    methods:&#123;    //原语句    // incrace()&#123;this.$store.commit('JIA',this.num)&#125;,    // decrace()&#123;this.$store.commit('JIAN',this.num)&#125;,    // 借助mapMutations生成对应方法，该方法会自动调用commit，数组写法在另一组件中     ...mapMutations(&#123;incrace:'JIA',decrace:'JIAN'&#125;),    //原语句    // addOpp()&#123;this.$store.dispatch('addOpp',this.num)&#125;,    // addLate()&#123;this.$store.dispatch('addLate',this.num)&#125;     ...mapActions(&#123;addOpp:'addOpp',addLate:'addLate'&#125;)     &#125; &#125;&lt;/script></code></pre><h4 id="通过数组"><a href="#通过数组" class="headerlink" title="通过数组"></a>通过数组</h4><p>当组件中的方法名、变量名与State、Mutations…中的变量名相同时，可以直接使用数组</p><div class="show">...mapState(['变量名1','变量名2',....])</div><pre><code>&lt;template>  &lt;div>    &lt;h2>不同的mapstate等写法&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name&#125;&#125;,从state获取song为&#123;&#123;song&#125;&#125;&lt;/h2>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="JIA(num)">加&lt;/button>    &lt;button @click="JIAN(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script>import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex'export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    computed:&#123;        ...mapState(['sum','name','song']),        ...mapGetters(['addTen'])    &#125;,    methods:&#123;        //数组写法    ...mapMutations(['JIA','JIAN']),     ...mapActions(['addOpp','addLate'])    &#125; &#125;&lt;/script></code></pre><h3 id="模块化与命名空间"><a href="#模块化与命名空间" class="headerlink" title="模块化与命名空间"></a>模块化与命名空间</h3><p>当有多类数据需要vuex管理时，可以将他们的state、actions、mutation封装到多个js文件中，并为它们开启<span class="tips">命名空间</span></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>在store目录中创建多个store配置文件</li><li>将配置文件统一引入该目录的index.js中</li><li>将store配置引入main.js中</li><li>创建组件，需要注意辅助函数的用法，指向命名空间的方法</li><li>在app中引入组件</li></ol><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>eg: 在上个案例基础上加入添加成员的功能。现在有两个功能：求和求差、添加成员，因此store目录下需要两个store配置项。在组件中调用数据时，需要用到命名空间，从不同state中引用数据。</p><h5 id="1-配置store-1"><a href="#1-配置store-1" class="headerlink" title="1. 配置store"></a>1. 配置store</h5><p>在store目录新建 person.js文件</p><pre><code>//添加人员模块import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) const person = &#123;    namespaced:true, //开启命名空间    actions:&#123;        addPersonZhou(context,value)&#123;            if(value.name.indexOf('周')===0)&#123;                context.commit('ADD_PERSON',value)            &#125;            else&#123;                alert('只能添加姓周的名')            &#125;        &#125;,         &#125;,    mutations:&#123;        ADD_PERSON(state,personObj)&#123;            state.personList.unshift(personObj);        &#125;    &#125;,    state:&#123;        personList:[&#123;id:'001',name:'张三'&#125;]    &#125;,    getters:&#123;        getFirstName(state)&#123;            return state.personList[0].name;        &#125;    &#125; &#125; export default person</code></pre><p>在store目录新建 count.js文件</p><pre><code>//求和模块import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default &#123;    namespaced:true, //开启命名空间    actions: &#123;        addOpp(context,value)&#123;          //判断是否为偶数            if(!(value%2))&#123;            context.commit('JIA',value)            &#125;else&#123;                console.log('非偶数，数未提交')            &#125;        &#125;,        addLate(context,value)&#123;        //数据想要多道处理时，可以dispatch为actions内的其他方法，无限套娃            setTimeout(()=>&#123;                context.dispatch('addLate2',value);                console.log('第一次延迟处理')            &#125;,500)        &#125;,        addLate2(context,value)&#123;      //数据经过第二道处理后，再提交            setTimeout(()=>&#123;                context.commit('JIA',value);                console.log('第二次延迟处理')            &#125;,500)        &#125;    &#125;,    mutations:&#123;        JIA(state,value)&#123;           //加            state.sum+=value        &#125;,        JIAN(state,value)&#123;          //减            state.sum-=value;        &#125;,    &#125;,    state:&#123;        sum:0,        name:'周杰伦',        song:'夜曲',    &#125;,    getters:&#123;        addTen(state)&#123;            return state.sum+10        &#125;    &#125;&#125;</code></pre><h5 id="2-在index-js中引入"><a href="#2-在index-js中引入" class="headerlink" title="2. 在index.js中引入"></a>2. 在index.js中引入</h5><p> 在store目录下index.js中引入</p><pre><code> import Vue from 'vue' import Vuex from 'vuex'Vue.use(Vuex)//引入两个配置项import count from './count'import person from './person'// 创建并暴露storeexport default new Vuex.Store(&#123;    //引入模块    modules:&#123;        //全写count: count,        count,        person    &#125; &#125;)</code></pre><h4 id="3-在main-js中引入store"><a href="#3-在main-js中引入store" class="headerlink" title="3. 在main.js中引入store"></a>3. 在main.js中引入store</h4> <pre><code>import Vue from 'vue'import App from './App.vue'import store from './store'new Vue(&#123;  render: h => h(App),  store&#125;).$mount('#app')</code></pre><h5 id="4-书写组件"><a href="#4-书写组件" class="headerlink" title="4. 书写组件"></a>4. 书写组件</h5><p>创建count.vue组件</p><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name&#125;&#125;,从state获取song为&#123;&#123;song&#125;&#125;&lt;/h2>        &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="incrace(num)">加&lt;/button>    &lt;button @click="decrace(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>    &lt;h1>组件2共享过来的人员名单&lt;/h1>   &lt;ol class="person-list">    &lt;li v-for="person in personList" :key="person.id">&#123;&#123;person.name&#125;&#125;&lt;/li>    &lt;/ol>  &lt;/div>&lt;/template>&lt;script> import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex' export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    //使用mapState,mapGetters, mapMutations,mapActions时更简洁    computed:&#123;        // 从count组件获取数据        ...mapState('count',&#123;sum:'sum',name:'name',song:'song'&#125;),         // 从person组件获取数据        ...mapState('person',['personList']),        ...mapGetters('count',&#123;addTen:'addTen'&#125;)    &#125;,    methods:&#123;    ...mapMutations('count',&#123;incrace:'JIA',decrace:'JIAN'&#125;),    ...mapActions('count',&#123;addOpp:'addOpp',addLate:'addLate'&#125;)    &#125; &#125;&lt;/script></code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>辅助函数指向命名空间时，需要在数据和方法名前添加命名空间名，如：...mapState('命名空间',{参数})</div><p>person.vue组件</p><pre><code>&lt;template>  &lt;div>    &lt;h2>组件2：添加成员&lt;/h2>    &lt;input type="text" v-model="personName" placeholder="添加成员">    &lt;button @click="add">添加&lt;/button>    &lt;button @click="addZhou">只添加姓周的人&lt;/button>    &lt;ul>        &lt;li v-for="person in personList" :key="person.id">&#123;&#123;person.name&#125;&#125;&lt;/li>    &lt;/ul>    &lt;h2>名单第一个人为&#123;&#123;firstPersonName&#125;&#125;&lt;/h2>    &lt;h2>组件一共享的值&lt;/h2>    &lt;h3>和为：&#123;&#123;sum&#125;&#125;&lt;/h3>  &lt;/div>&lt;/template>&lt;script>import &#123; nanoid &#125; from 'nanoid'export default &#123;    name:'CountSum',    data()&#123;        return &#123;            personName:''        &#125;    &#125;,    //不使用mapState,mapGetters, mapMutations,mapActions时更新、获取数据的方法    computed:&#123;        personList()&#123;            return this.$store.state.person.personList        &#125;,        sum()&#123;            return this.$store.state.count.sum        &#125;,        //通过getters获取时，想要指定组件名与路径        firstPersonName()&#123;            return this.$store.getters['person/getFirstName']        &#125;    &#125;,    methods:&#123;     add()&#123;        const personObj=&#123;id:nanoid(),name:this.personName&#125;;        //指定为person组件下的ADD_PERSON函数        this.$store.commit('person/ADD_PERSON',personObj);        this.personName='';     &#125;,     addZhou()&#123;         const personObj=&#123;id:nanoid(),name:this.personName&#125;;         this.$store.dispatch('person/addPersonZhou',personObj);         this.personName='';     &#125;    &#125;  &#125;&lt;/script></code></pre><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>不借助mapState等辅助函数，需要使用路径来指定命名空间名称，其中读取state中的数据使用<span class="tips">this.$store.state.配置文件名.数据名</span>来指向命名空间，而<span class="tips">dispatch</span>、<span class="tips">commit</span>、<span class="tips">getter</span>等api需要使用<span class="tips">this.$store.api名['命名空间/方法名',变量名]</span>语句来指向命名空间</div><h5 id="5-App-vue引入两个组件即可"><a href="#5-App-vue引入两个组件即可" class="headerlink" title="5. App.vue引入两个组件即可"></a>5. App.vue引入两个组件即可</h5><pre><code>&lt;template>  &lt;div id="app">    &lt;Count/>    &lt;Person/>  &lt;/div>&lt;/template> &lt;script> import Count from'./components/Count.vue' import Person from'./components/Person.vue' export default &#123;  name:'App',  components:&#123;    Count,    Person  &#125; &#125;&lt;/script></code></pre>]]></content>
    
    
    <summary type="html">Vue中用于集中式状态(数据)管理插件</summary>
    
    
    
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
    <category term="vue" scheme="https://shiwei11.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一位资深数据工程师酒后的肺腑之言(转载)</title>
    <link href="https://shiwei11.github.io/blog/2022/03/15/%E4%B8%80%E4%BD%8D%E5%8D%81%E5%B9%B4IT%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/"/>
    <id>https://shiwei11.github.io/blog/2022/03/15/%E4%B8%80%E4%BD%8D%E5%8D%81%E5%B9%B4IT%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/</id>
    <published>2022-03-15T02:32:23.000Z</published>
    <updated>2022-07-16T18:05:37.105Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>原帖来源于Reddit论坛：<a href="https://www.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/">Drunk Post: Things I've learned as a Sr Engineer</a></div><p>最早我是在知乎上看到的，后来又陆陆续续在公众号、贴吧多次看到，最后追到了Reddit上，原帖作者是flipstables，这篇帖子目前已经获得了12k的点赞，写的很有意思。</p><h3 id="节选"><a href="#节选" class="headerlink" title="节选"></a>节选</h3><p><span class="strong">我喝醉了，这是我作为一名工程师在过去十年学到的一些东西，我可能会后悔说了这些话，但是…..醉都醉了，管他呢。</span></p><p>(1)    提升职业生涯的最好方法是换公司。</p><p>(2)    技术栈不重要。每个技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。</p><p>(3)    人们爱跳槽是有原因的。 如果对当前工作不满意，也许是时候离开了</p><p>(4)    工作和人际关系是两回事。在一些公司，我交到了好朋友，但是工作得并不开心；在另一些公司里，我没有与任何同事建立友谊，但是工作得很开心。</p><p>(5)    我学会了对经理诚实，总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。</p><p>(6)    如果我每个季度不止一次在凌晨2点被人叫醒，并且他们认为我是可以随叫随到的，那么肯定是出了很严重的问题(系统或人)，要么我得修正他们的看法(或者修复系统)，要么提桶跑路。</p><p>(7)<span class="strong">再倒一杯</span></p><p>(8)    优秀的经理和优秀的工程师有很多相似之处。</p><p>(9)    刚开始的时候，我也曾痴迷技术、编程、计算机，但现在已经翻篇了。</p><p>(10)    好的代码是能被初级工程师理解的代码。伟大的代码是可以被CS 专业的大一新生理解的代码。</p><p>(11)    作为一名工程师，最被忽视的能力是写文档。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。</p><p>(12)    网上的口水战(vim vs emacs ,mac vs linux)，几乎都无关紧要，别去参与，除了下一条。</p><p>(13)    年纪越大，我就越觉得动态语言更好，妈的，我就这么说了，有谁反对？</p><p>(14)    如果发现自己是公司里面最厉害的工程师，那就该离开了。</p><p>(15)    我不知道为什么全栈工程师的工资这么低。 不，真的，他们应该每年得到50万的年薪，只是基本工资。 妈的，他们必须了解前端和后端以及不同的浏览器如何工作，还得了解网络、数据库、缓存以及PC端和移动端之间的差异，天哪，还有公司使用的其他框架？ 说真的，为什么全栈工程师工资这么少</p><p>(16)    我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了，我喜欢实习生。</p><p>(17) <span class="strong">抿~</span></p><p>(18)    不要过于迷恋大牛，我花了 5000 美元参加了我所崇拜大牛的公开课。 他是一个才华横溢的人，但后来我意识到，他和我们其他人一样，在瞎编。</p><p>(19)    技术栈很重要。好吧，我刚刚说过不重要之类的话，但听我说完，如果你使用 Python 或 C++ 语言，就会忍不住想用这些语言做一些非同寻常的事情，因为这些语言确实适合干这些工作。</p><p>(20)    如果你不确定自己想做什么东西，请使用 Java。这是一门很糟糕的编程语言，但它几乎无所不能。</p><p>(21)    对于初学者来说，最赚钱的编程语言是 SQL，能干翻所有其他语言。就算你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。</p><p>(22)    测试很重要，但 TDD （测试驱动的开发）是个该死的邪教。</p><p>(23)    政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你得出卖你的灵魂去深究这些专有技术，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄多数在 50 岁以上是有原因的。</p><p>(24)    如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。</p><p>(25)    我从来没有在FAANG (Facebook、亚马逊、苹果、奈飞、谷歌)工作过，所以我不知道我错过了什么。但是我招过FAANG的工程师，他们也不知道自己在做什么。</p><p>(26)    自我价值不是和薪酬挂钩的函数，跟那东西没什么关系，用资本来确定自我价值很糟糕。</p><p>(27)    头衔大多无关紧要，随便什么公司都可以有首席工程师。</p><p>(28)    说到头衔，在职业生涯早期，头衔升级很好，因为这可以让你历练技能，学会担当责任。但到后期，头衔降级很好，这会让你增加薪水。</p><p>(29)    善待每一个人，不是因为这会有助于你的事业，而是因为向善本身就有回报。</p><p>(30)    如果上个月我没有从初级工程师或实习生那里学到点什么，那说明我没有上心。</p><p>(31)    <span class="strong">该死，没酒了</span></p><p>(32)    在课程、书籍、会议方面花点钱是值得的。</p><p>(33)    手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。</p><p>(34)    当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。</p><p>(35)    就算我心里讨厌某种技术，但如果我觉得他好的话，我还是会把它推荐给客户，比如我恨 Jenkins，但会把它推荐给客户，我不觉得做错了。</p><p>(36)    Git很糟糕，但我没有选择只能使用它，它的GUI可以见鬼去了，给我命令就行，大概只需要记住7个，其他的可以Google。</p><p>(37)    我喜欢团队里的半技术分析师， 因为懂编程但不懂软件工程，他们对我成长的帮助比最杰出的工程师要大得多。</p><p>(38) <span class="strong">糟糕，又没酒了</span></p><p>(39)    成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。</p><p>(40)    发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。</p><p>(41)    我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。</p><p>(42)    算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。</p><p>(43)    做自己喜欢的事情并不重要，不要让做讨厌的事情更重要。</p><p>(44)    越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。</p><p>(45)    即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。</p><p>(46)    不是所有好工作都在硅谷，但那里有很多。</p><p>(47) <span class="strong">哦，该死，我又找到啤酒了</span></p><p>(48)    结对编程很棒，只是需要花很多时间，而公司往往不想花那么多时间。</p><p>(49)    和聪明的工程师一起工作让我变成更好的码农，和聪明的非技术同事一起工作让我成为更好的工程师。</p><p>(50)    朝九晚五以外的时间就别花在工作上了，除非那个项目真的很棒，你状态很好。</p><p>(51)    人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那将是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。</p><p>(52)    好人写的代码也有烂的，聪明人写的代码也是，好的工程师也会写出糟糕的代码。不要让代码质量成为你衡量自我价值的因变量。</p><p>(53)    我进入这个行业是因为我喜欢技术，但现在工作已经毁了我的爱好。</p><p>(54)    我挣的钱还不错，对此我心存感激，不过还是得省着点用。</p>]]></content>
    
    
    <summary type="html">国外一位十年经验数据工程师的酒后吐槽，讲述了自己十年来对工作和技术的一些感悟，写的很有意思，在Reddit论坛上获得了上万的点赞</summary>
    
    
    
    
    <category term="life" scheme="https://shiwei11.github.io/blog/tags/life/"/>
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>VLess+TLS+WS代理服务器搭建</title>
    <link href="https://shiwei11.github.io/blog/2022/03/10/VLess-TLS%E9%AB%98%E9%98%B6%E6%90%AD%E5%BB%BA/"/>
    <id>https://shiwei11.github.io/blog/2022/03/10/VLess-TLS%E9%AB%98%E9%98%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2022-03-10T05:51:09.000Z</published>
    <updated>2022-08-27T18:04:23.522Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>本文采用 WTFPL 许可证书，转载请不要标注任何本站信息<div><a href="https://wtfpl2.com/">WTFPL © Do What the Fuck You Want to Public License</a></div></div><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>VLESS 是一种无状态的轻量级数据传输协议，使用 UUID 进行身份验，其协议不再依赖系统时间，配置灵活。但其本身协议不带加密，因此需要配合 TLS 等加密手段。</p><h3 id="前置需要"><a href="#前置需要" class="headerlink" title="前置需要"></a>前置需要</h3><h4 id="一台可用的VPS"><a href="#一台可用的VPS" class="headerlink" title="一台可用的VPS"></a>一台可用的VPS</h4><p>国内的可以使用香港、台湾地区的服务器，如GCP在台湾的节点、softshellweb，国外的推荐vultr、搬瓦工等主流厂商，支持支付宝付款并且不容易跑路。</p><p>操作系统请选择自己熟悉的发行版，并能解决防火墙策略、开放端口等问题，这里以CentOS7为例。</p><p>安装完毕后需要测试是否能Ping通，可以直接使用ping命令尝试，或者去相关网站，国内可以通过<a href="https://ping.chinaz.com/">站长Ping工具</a>检测，国外通过<a href="https://www.yougetsignal.com/">yougetsignal</a>检测。如果国内能ping通，说明该服务器可用，可以开始搭建了。如果国外能ping通，国内无法ping通，则说明被拦截了，需要换一台服务器。如果国内国外都无法ping通，则说明服务器还未部署好，需等待几分钟后再重试。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名推荐去 godaddy 购买，顶级域名为<span class="tips">.com</span>的域名一般第一年只需要59元，<span class="tips">.cn</span>域名一般35元，最便宜的诸如<span class="tips">.live</span>结尾的域名第一年不到14元</p><p>拿到域名后将其解析到所购买的VPS IP地址，域名一般需要24h才会生效(实际不用)。</p><h4 id="SSL-TLS证书"><a href="#SSL-TLS证书" class="headerlink" title="SSL/TLS证书"></a>SSL/TLS证书</h4><p>SSL/TLS证书可以从以下平台免费获取，证书有效期一般为90天，90天后需要更换</p><ul><li>zerossl：<a href="https://zerossl.com/">https://zerossl.com/</a></li><li>letsencrypt：<a href="https://letsencrypt.org/">https://letsencrypt.org/</a></li><li>FreeSSL：<a href="https://freessl.org/">https://freessl.org/</a></li><li>SSL For Free：<a href="https://www.sslforfree.com/">https://www.sslforfree.com/</a></li></ul><p>将获取的证书、密钥文件上传到服务器上，在配置文件时使用。如果不想手动更新SSL证书，可以使用脚本自动更新<br>脚本地址：<a href="https://github.com/acmesh-official/acme.sh">https://github.com/acmesh-official/acme.sh</a></p><h3 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h3><h4 id="安装V2fly"><a href="#安装V2fly" class="headerlink" title="安装V2fly"></a>安装V2fly</h4><p>Github开源地址：<a href="https://github.com/v2fly/fhs-install-v2ray">https://github.com/v2fly/fhs-install-v2ray</a></p><p>安装/更新 v2fly命令：</p><pre><code>bash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)</pre></code><p>安装完成后，配置文件放在<span class="tips">/usr/local/etc/v2ray/config.json</span>路径下</p><h4 id="Google-BBR加速算法"><a href="#Google-BBR加速算法" class="headerlink" title="Google BBR加速算法"></a>Google BBR加速算法</h4><p>TCP BBR(Bottleneck Bandwidth and Round-trip propagation time)是由Google于2016年发布的一种拥塞控制算法，可以显著地提高Linux服务器吞吐量并减少TCP连接的延迟</p><p>安装bbrplus：</p><pre><code>wget "https://github.com/cx9208/bbrplus/raw/master/ok_bbrplus_centos.sh" && chmod +x ok_bbrplus_centos.sh && ./ok_bbrplus_centos.sh</code></pre><p>安装完毕需要重启系统，重启完毕可通过<span class="tips">uname -r</span>命令查询内核，返回bbr相关值说明升级完成，通过命令<span class="tips">lsmod | grep bbr</span>查看是否载入bbr系统模块，返回bbr相关值说明已经加载。</p><p>CentOS8+系统内核自带BBR，开启方法可自行百度。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><p>使用vim在<span class="tips">/usr/local/etc/v2ray/config.json</span>配置文件中添加配置设置。</p><pre><code>&#123;  &#123;    "log": &#123;    "loglevel": "warning",    "access": "/var/log/v2ray/access.log",       "error": "/var/log/v2ray/error.log"  //日志输出路径    &#125;,    "inbounds": [&#123;    "port": 8180 ,  //监听端口    "protocol": "vless",//主传入协议    "settings": &#123;    "decryption": "none",    "clients": [    &#123;    "id": "41803377-5789-4bf5-8cb4-dd6ad659554c",//UUID    "level": 0        &#125;      ]    &#125;,    "streamSettings": &#123;    "network":"ws",  //传输协议    "security": "tls", //传输层安全    "wsSettings":&#123;    "path":"/",     //路径    "headers":&#123;&#125;    &#125;,    "tlsSettings": &#123;    "serverName": "newyear101.xyz", //域名    "certificates": [&#123;    "certificateFile": "/etc/ssl/certificate.crt",//SSL证书路径    "keyFile": "/etc/ssl/private.key" //密钥路径            &#125;]         &#125;      &#125;    &#125;],    "outbounds": [&#123;    "protocol": "freedom",//主传出协议    "settings": &#123;&#125;    &#125;,&#123;    "protocol": "blackhole",    "settings": &#123;&#125;,    "tag": "blocked"    &#125;],    "routing": &#123;    "rules": [    &#123;    "type": "field",    "ip": ["geoip:private"],    "outboundTag": "blocked"        &#125;      ]   &#125; &#125;</code></pre><ul><li>UUID作为唯一身份识别码，可通过客户端生成，或通过UUID生成网站获得，不能自行编写<h5 id="检测配置文件是否正确"><a href="#检测配置文件是否正确" class="headerlink" title="检测配置文件是否正确"></a>检测配置文件是否正确</h5>v2ray官方检测命令：<pre><code>/usr/local/bin/v2ray -test -config  /usr/local/etc/v2ray/config.json</pre></code>文件正确会返回值：<div class="shell">V2Ray 4.44.0 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.17.3 linux/amd64)A unified platform for anti-censorship.2021/02/03 21:46:12 [Info] main/jsonem: Reading config: /usr/local/etc/v2ray/config.jsonConfiguration OK.</div></li></ul><h4 id="更新防火墙规则"><a href="#更新防火墙规则" class="headerlink" title="更新防火墙规则"></a>更新防火墙规则</h4><h5 id="Centos-7-8-firewalld-放行端口"><a href="#Centos-7-8-firewalld-放行端口" class="headerlink" title="Centos 7/8 firewalld 放行端口"></a>Centos 7/8 firewalld 放行端口</h5><div class="show">// 8180改成自己的端口号firewall-cmd --permanent --add-port=8180/tcp //重启使之生效firewall-cmd --reload</div><h5 id="ubuntu系统-ufw放行端口"><a href="#ubuntu系统-ufw放行端口" class="headerlink" title="ubuntu系统 ufw放行端口"></a>ubuntu系统 ufw放行端口</h5><div class="show">//8180改成自己的端口号sudo ufw allow 8180/tcp//重启sudo ufw reload</div><h5 id="Centos-6-7-iptable放行端口"><a href="#Centos-6-7-iptable放行端口" class="headerlink" title="Centos 6/7 iptable放行端口"></a>Centos 6/7 iptable放行端口</h5><div class="show">//8180改成自己的端口号iptables -I INPUT -p tcp --dport 8180 -j ACCEPT//保存添加的规则链service iptables save</div><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端需要使用4.23.2以上内核</p><h4 id="客户端下载地址："><a href="#客户端下载地址：" class="headerlink" title="客户端下载地址："></a>客户端下载地址：</h4><ul><li><strong>Android</strong>: <a href="https://github.com/2dust/v2rayNG/releases">v2rayNG</a></li><li><strong>windows</strong>:<a href="https://github.com/2dust/v2rayN/releases">v2rayN</a></li><li><strong>MacOS</strong>:<a href="https://github.com/yanue/V2rayU/releases">V2rayU</a></li></ul><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><div class="table"><table><thead><tr><th>配置项</th><th>值</th></tr></thead><tbody><tr><td>别名</td><td>任意</td></tr><tr><td>地址</td><td>VPS的IP地址</td></tr><tr><td>端口</td><td>配置文件中的端口号</td></tr><tr><td>用户ID</td><td>UUID,需要和配置文件一致</td></tr><tr><td>传输协议</td><td>ws</td></tr><tr><td>伪装域名</td><td>解析的域名</td></tr><tr><td>路径</td><td>配置文件中的路径</td></tr><tr><td>传输层安全</td><td>tls</td></tr></tbody></table></div><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h4><p>如果已经启动v2ray服务，修改的配置文件需要重启生效</p><ul><li><strong>systemctl start v2ray</strong> 运行</li><li><strong>systemctl stop v2ray</strong> 停止</li><li><strong>systemctl restart v2ray</strong> 重启</li></ul><h4 id="常用服务命令"><a href="#常用服务命令" class="headerlink" title="常用服务命令"></a>常用服务命令</h4><h5 id="生成uuid"><a href="#生成uuid" class="headerlink" title="生成uuid"></a>生成uuid</h5><p> <span class="strong">v2ctl uuid</span> 生成一个新的uuid</p><h5 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h5><p> <span class="strong">v2ray [参数]</span></p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-version</td><td>查看当前版本</td></tr><tr><td>-test</td><td>测试配置文件有效性</td></tr><tr><td>-config</td><td>手动指定配置文件，值可以是绝对路径、相对路径、url链接、”stdin:”(从标准输入读取内容)</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">大二的时候整理的一篇笔记，在原笔记的基础上改用了后面新出的协议，并系统整理了一下可能用到的命令。</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="VPS" scheme="https://shiwei11.github.io/blog/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Nginx笔记(上)</title>
    <link href="https://shiwei11.github.io/blog/2022/03/04/nginx%E7%AC%94%E8%AE%B0/"/>
    <id>https://shiwei11.github.io/blog/2022/03/04/nginx%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T02:53:39.000Z</published>
    <updated>2022-08-01T18:09:32.767Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>nginx官方文档：<a target="_blank" href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></div><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><h4 id="1-1-Nginx简介"><a href="#1-1-Nginx简介" class="headerlink" title="1.1 Nginx简介"></a>1.1 Nginx简介</h4><p>Nginx是一款高性能的Web服务器软件，能在高并发环境下快速响应http/https请求，同时也提供IMAP/POP3/SMTP服务,可用于反向代理服务器、虚拟主机、域名解析、负载均衡、防盗链、URL重定向、http/https、邮件代理服务器等各类场景。</p><p>根据<a href="https://news.netcraft.com/">Netcraft</a> 发布的web服务器调查报告，截至2022年1月，nginx是全球最常用的web服务器软件，占有全球32.3%的站点，另一服务器软件Apache占有23.9%的站点，很大一部分web服务器使用Nginx作为负载均衡服务器。</p><h4 id="1-2-依赖与环境"><a href="#1-2-依赖与环境" class="headerlink" title="1.2 依赖与环境"></a>1.2 依赖与环境</h4><p><strong>操作系统要求：</strong>Nginx底层使用了多进程和I/O多路复用(epoll)来提高并发能力，因此需要使用Linux2.6以上的内核以支持epoll</p><p><strong>源码包依赖：</strong></p><ul><li>GCC编译器：编译C语言</li><li>PCRE库(兼容正则表达式库)：用于支持正则表达式</li><li>zlib库：为Nginx的gzip压缩提供压缩算法</li><li>OpenSSL：提供安全通信</li></ul><h4 id="1-3进程模型"><a href="#1-3进程模型" class="headerlink" title="1.3进程模型"></a>1.3进程模型</h4><p>master进程：主进程，以root权限运行，负责读取检测配置文件，启动和管理worker进程</p><p>worker进程：工作进程，权限由配置文件中的user决定，负责处理网络请求，进程数量由配置文件中的worker_processes决定</p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h3><h4 id="2-1Nginx服务命令"><a href="#2-1Nginx服务命令" class="headerlink" title="2.1Nginx服务命令"></a>2.1Nginx服务命令</h4><p>未配置全局环境变量的情况下，nginx命令执行路径为<span class="tips">/usr/local/nginx/sbin</span>，可以通过./nginx -h查看所有命令</p><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>./nginx</td><td>启动nginx</td></tr><tr><td>./nginx -h</td><td>-h可替换为-?,查看nginx的所有命令</td></tr><tr><td>./nginx -v</td><td>查看nginx的版本</td></tr><tr><td>./nginx -s 信号量</td><td>发送一个信号量操作nginx</td></tr><tr><td>./nginx -s stop</td><td>强制关闭nginx</td></tr><tr><td>./nginx -s quit</td><td>停止接受新请求，等待nginx处理完当前任务后关闭nginx</td></tr><tr><td>./nginx -s reload</td><td>重新加载配置文件</td></tr><tr><td>./nginx -s reopen</td><td>重新打开日志文件(可用于日志分割)</td></tr><tr><td>./nginx -t [文件路径]</td><td>检测nginx的配置文件是否书写正确</td></tr><tr><td>./nginx -T</td><td>检测nginx的配置文件是否书写正确，若正确则将内容输出到屏幕</td></tr><tr><td>./nginx -c 文件路径</td><td>手动指定nginx的配置文件后启动</td></tr></tbody></table></div><h4 id="2-2Linux系统命令"><a href="#2-2Linux系统命令" class="headerlink" title="2.2Linux系统命令"></a>2.2Linux系统命令</h4><p><span class="strong">kill -信号 master进程PID</span></p><div class="table"><table><thead><tr><th>信号</th><th>说明</th></tr></thead><tbody><tr><td>TERM/INT</td><td>强制关闭nginx</td></tr><tr><td>QUIT</td><td>停止接受新请求，处理完当前任务后关闭nginx</td></tr><tr><td>HUP</td><td>重新加载配置文件</td></tr><tr><td>USR1</td><td>重新打开日志文件(可用于日志分割)</td></tr><tr><td>USR2</td><td>不停止服务，平滑升级到最新版nginx</td></tr><tr><td>WINCH</td><td>停止接受新请求，处理完当前任务后关闭所有worker进程</td></tr></tbody></table></div><h5 id="关于平滑升级"><a href="#关于平滑升级" class="headerlink" title="关于平滑升级"></a>关于平滑升级</h5><p>执行 <span class="tips">kill -USR2 17482</span>(假设17482为master进程PID)命令进行平滑升级时，更新完ngixn后会开启一个新版本nginx对应的master进程和work进程，此时系统中将会有两个master进程，并且新版本的master进程PID会被记录在<span class="tips">/usr/loca1/nginx/logs/nginx.pid</span>文件中，而旧版本master进程PID会被记录在<span class="tips">/usr/loca1/nginx/logs/nginx.pid.oldbin</span>文件中，之后会发送QUIT信号给旧的master进程，让其处理完请求后关闭，完成升级。</p><h3 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h3><p>配置文件位于<span class="tips">/usr/local/nginx/conf/nginx.conf</span>路径下</p><h4 id="3-1全局配置"><a href="#3-1全局配置" class="headerlink" title="3.1全局配置"></a>3.1全局配置</h4><div class="show">#user  nobody;          //指定nginx工作进程的用户身份，默认为nobodyworker_processes  1;   //允许生成的worker process数<p>#error_log  logs/error.log;     //日志级别与存放路径<br>#error_log  logs/error.log  notice;<br>#error_log  logs/error.log  info;</p><p>#pid        logs/nginx.pid; //master进程pid存放路径<br>……</div></p><h5 id="3-1-1-user配置进程权限"><a href="#3-1-1-user配置进程权限" class="headerlink" title="3.1.1 user配置进程权限"></a>3.1.1 user配置进程权限</h5><p><span class="strong">user 用户名 [用户组];</span></p><p>默认为nobody，配置决定了worker进程的调用用户，以及nginx对文件(一般指资源文件和目录)的读写权限，而日志文件、pid文件、配置文件等由master进程调用的文件则不受此配置影响，所有者一般为root。当配置的用户对指定文件无访问权限时，Nginx将返回403错误，此时需要授予该用户相关权限，或者更改为权限更高的用户。</p><h5 id="3-1-2-worker-processes配置进程数量"><a href="#3-1-2-worker-processes配置进程数量" class="headerlink" title="3.1.2 worker_processes配置进程数量"></a>3.1.2 worker_processes配置进程数量</h5><ul><li><span class="strong">master_process on/off;</span>用于指定是否生成worker进程，默认为on</li><li><span class="strong">worker_processes 值/auto;</span>指定worker进程生成数量，默认为1</li></ul><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>worker_processes值越大，处理并发能力越强。但需要考虑服务器的CPU核心数、内存余量等硬件资源大小</div><h5 id="3-1-3-daemon配置nginx为守护进程"><a href="#3-1-3-daemon配置nginx为守护进程" class="headerlink" title="3.1.3 daemon配置nginx为守护进程"></a>3.1.3 daemon配置nginx为守护进程</h5><p><span class="strong">daemon on/off;</span></p><p>配置nginx是否以守护进程方式启动，并在后台运行，默认为on</p><h5 id="3-1-4-error-log配置日志"><a href="#3-1-4-error-log配置日志" class="headerlink" title="3.1.4 error_log配置日志"></a>3.1.4 error_log配置日志</h5><p><span class="strong">error_log 路径 [日志级别];</span></p><p>配置日志路径和记录级别，这里指Nginx本身运行错误产生的日志，用户连接产生的日志需要在http/https块里配置，默认将notice以上级别的日志写入error.log日志文件中，日志级别有 debug、info、notice、warn、error、crit</p><h5 id="3-1-5-pid配置pid文件路径"><a href="#3-1-5-pid配置pid文件路径" class="headerlink" title="3.1.5 pid配置pid文件路径"></a>3.1.5 pid配置pid文件路径</h5><p><span class="strong">pid 路径;</span></p><p>自定义pid文件路径，默认在/usr/local/nginx/logs/nginx.pid路径下。pid文件用于存放master进程的pid，会在master进程产生时生成，进程关闭时删除。当使用nginx -s reload/reopen重新加载配置文件或日志时，nginx会到该文件中读取进程pid，如果该文件无法找到或者已经被删除，nginx将报错，常用的解决方法是使用<span class="tips">nginx -c 配置文件名</span>命令重新指定配置文件后启动nginx</p><h4 id="3-2-events块"><a href="#3-2-events块" class="headerlink" title="3.2 events块"></a>3.2 events块</h4><div class="show">...events {    worker_connections  1024;//每个worker允许的最大连接数}</div><h5 id="3-2-1-accept-mutex配置网络连接序列号"><a href="#3-2-1-accept-mutex配置网络连接序列号" class="headerlink" title="3.2.1 accept_mutex配置网络连接序列号"></a>3.2.1 accept_mutex配置网络连接序列号</h5><p><span class="strong">accept_mutex on/off;</span></p><p>默认为on，用于解决“惊群”问题，即将连接到nginx的网络连接进行序列化，并依次分配给worker进程，防止多个worker争抢连接。</p><h5 id="3-2-2-accept-mutex配置网络连接序列号"><a href="#3-2-2-accept-mutex配置网络连接序列号" class="headerlink" title="3.2.2 accept_mutex配置网络连接序列号"></a>3.2.2 accept_mutex配置网络连接序列号</h5><p><span class="strong">multi_accept on/off;</span></p><p>默认为off，在off状态下，一个worker进程只能接收一个新的连接请求，否则，一个worker进程将同时接收所有新连接。</p><h5 id="3-2-3-worker-connections配置单进程最大连接数"><a href="#3-2-3-worker-connections配置单进程最大连接数" class="headerlink" title="3.2.3 worker_connections配置单进程最大连接数"></a>3.2.3 worker_connections配置单进程最大连接数</h5><p><span class="strong">worker_connections 值;</span></p><p>默认为1024，用于配置每个worker允许的最大连接数，值不能超过操作系统最大文件句柄数量。</p><h5 id="3-2-4-use配置事件处理模型"><a href="#3-2-4-use配置事件处理模型" class="headerlink" title="3.2.4 use配置事件处理模型"></a>3.2.4 use配置事件处理模型</h5><p><span class="strong">use 参数;</span></p><p>可选参数有poll/select/epoll/kqueue等，Linux2.6以上内核默认使用epoll函数以优化并发连接能力。</p><h4 id="3-3-http块"><a href="#3-3-http块" class="headerlink" title="3.3 http块"></a>3.3 http块</h4><div class="shell">http {    include       mime.types;   //引入外部文件mime.types    default_type  application/octet-stream;    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main; //定义access连接日志的路径与内容//快速传输文件    sendfile        on;    #tcp_nopush     on;//服务器保持连接最大时间，单位为s    #keepalive_timeout  0;    keepalive_timeout  65;//传输文件前是否压缩    #gzip  on;    ....</div><h5 id="3-3-1-include"><a href="#3-3-1-include" class="headerlink" title="3.3.1  include"></a>3.3.1  include</h5><p><span class="strong">include 文件名;</span></p><ul><li>用于引入外部文件，管理员可以定义一个外部文件书写配置，然后通过include将该文件内容引入到相应位置。</li><li>这里引入的mime.types用于标识文档、媒体文件格式和类型，该文件标识了常用的html、css、js、jpg等文件类型，用于帮助nginx识别请求的文件类型</li></ul><h5 id="3-3-2-default-type"><a href="#3-3-2-default-type" class="headerlink" title="3.3.2  default_type"></a>3.3.2  default_type</h5><p><span class="strong">default_type MIME类型;</span></p><p>默认值application/octet-stream指没有特定类型的二进制文件，MIME类型可参考MDN文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" style="word-wrap: break-word;">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></p><h5 id="3-3-3-access-log"><a href="#3-3-3-access-log" class="headerlink" title="3.3.3 access_log"></a>3.3.3 access_log</h5><ul><li><span class="strong">log_format 变量名 日志格式;</span></li><li><span class="strong">access_log 路径 变量名;</span></li></ul><p>二者搭配使用，第一个语句用于定义一个变量名，并将配置的日志格式赋值给该变量，变量名取值需使用<span class="tips">$</span>符。第二个语句用于根据变量名对应的日志格式，将用户访问日志书写到对应路径下。日志格式中对应的变量含义：</p><div class="table"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>remote_addr</td><td>客户端地址</td></tr><tr><td>remote_user</td><td>客户端用户名</td></tr><tr><td>time_local</td><td>访问时间和时区</td></tr><tr><td>request</td><td>请求的URL和HTTP协议</td></tr><tr><td>http_host</td><td>请求地址，即浏览器中输入的地址</td></tr><tr><td>status</td><td>http请求返回的状态码，如：301、404等</td></tr><tr><td>upstream_status</td><td>upstream状态</td></tr><tr><td>body_bytes_sent</td><td>发送给客户端的文件大小(字节)</td></tr><tr><td>http_referer</td><td>该请求是从哪个链接跳转过来</td></tr><tr><td>http_user_agent</td><td>客户端信息，如：浏览器标识等</td></tr><tr><td>ssl_protocol</td><td>SSL协议版本</td></tr><tr><td>ssl_cipher</td><td>交换数据中的算法</td></tr><tr><td>request_time</td><td>整个请求的总时间</td></tr><tr><td>upstream_addr</td><td>upstream的地址，即真正提供服务的主机地址</td></tr><tr><td>http_x_forwarded_for</td><td>记录有代理服务器时客户端地址的配置</td></tr><tr><td>upstream_response_time</td><td>请求过程中，upstream响应时间</td></tr></tbody></table></div><h5 id="3-3-4-sendfile"><a href="#3-3-4-sendfile" class="headerlink" title="3.3.4  sendfile"></a>3.3.4  sendfile</h5><ul><li><span class="strong">sendfile on/off;</span></li><li><span class="strong">tcp_nopush on/off;</span></li></ul><p>sendfile用于高效传输文件，在sendfile为on的状态下，开启tcp_nopush会将文件积累到一定大小后再统一发送，用于提高包传输效率</p><h5 id="3-3-5-keepalive-timeout"><a href="#3-3-5-keepalive-timeout" class="headerlink" title="3.3.5  keepalive_timeout"></a>3.3.5  keepalive_timeout</h5><ul><li><span class="strong">keepalive_timeout 值;</span></li><li><span class="strong">tcp_nodelay on/off;</span></li></ul><p>keepalive_timeout用于设置保持与客户端连接的最大时间，单位默认为s，超时时nginx会关闭连接并释放服务器资源，若设置为0则禁用该设置。设置的时间过大会导致大量的无效连接未断开，从而占用服务器资源，太小会导致服务未处理完，就被强制关闭连接。</p><p>在keepalive_timeout启用状态下，配置tcp_nodelay on;可以将数据即使发送。</p><h5 id="3-3-6-gzip"><a href="#3-3-6-gzip" class="headerlink" title="3.3.6  gzip"></a>3.3.6  gzip</h5><p><span class="strong">gzip on/off;</span></p><p>gzip 用于配置传输文件前是否进行压缩以提高传输速率，压缩会占用一定系统资源</p><h4 id="3-4-server块"><a href="#3-4-server块" class="headerlink" title="3.4 server块"></a>3.4 server块</h4><div class="show">server {        listen      80;   //监听端口        server_name  localhost;//监听的域名或ip地址        #charset koi8-r;        #access_log  logs/host.access.log  main;//日志输出路径        location /web/ {  //路由路径            root   /test;            index  index.html index.htm;        }        location /images {            root /test;            autoindex on;//自动生成文件归档页面        }        location /.well-known/pki-validation/{        root /;        }        location /new/{        root    /;        add_header Content-Disposition "attachment;";        }//定义404页面        #error_page  404              /404.html;//定义50x页面        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }</div><h5 id="3-4-1-listen"><a href="#3-4-1-listen" class="headerlink" title="3.4.1  listen"></a>3.4.1  listen</h5><p><span class="strong">listen 地址/端口 [default_server];</span></p><p>配置监听地址和端口，default_server参数用于将该server设置为默认主机，无该参数则第一个server为默认主机，当没有匹配到客户端指定的端口/IP时，将连接到默认主机。地址和端口格式可以为：</p><ul><li>listen 127.0.0.1 监听该地址所有端口</li><li>listen 127.0.0.1:8080 监听该地址的8080端口</li><li>listen *:8080 监听所有地址的8080端口</li></ul><h5 id="3-4-2-server-name"><a href="#3-4-2-server-name" class="headerlink" title="3.4.2  server_name"></a>3.4.2  server_name</h5><p><span class="strong">server_name 域名/IP地址;</span></p><p>用于配置虚拟主机的标识名称，域名或IP地址可以写多个，使用空格隔开。当listen中配置了域名或IP地址，则server_name配置的域名和IP地址将失效，配置方法可以使用以下三种，当域名被多个server匹配到，将按精确匹配&gt;通配符在开头&gt;通配符在结尾&gt;正则匹配&gt;默认主机的优先级进行分配。</p><h6 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h6><div class="show">server {    listen 80;    server_name aaaa.com bbbbb.cn;//配置多个域名    .....}</div><h6 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h6><p>通配符只能在段首和段尾使用，不能再域名中间使用！</p><div class="show">server {    listen 80;    server_name *.aaaa.com www.aaaa.*;    .....}</div><h6 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h6><div class="show">server {    listen 80;    server_name ~正则表达式;    .....}</div><h5 id="3-4-3-charset"><a href="#3-4-3-charset" class="headerlink" title="3.4.3 charset"></a>3.4.3 charset</h5><p><span class="strong">charset 编码格式;</span><br>charset 用于指定字符编码格式，默认的koi8-r为俄语编码格式(nginx作者是俄罗斯人)，与utf-8类似</p><h5 id="3-4-4-access-log"><a href="#3-4-4-access-log" class="headerlink" title="3.4.4 access_log"></a>3.4.4 access_log</h5><p><span class="strong">access_log 路径 日志格式;</span></p><p>用于指定该server的连接日志，日志格式默认使用http模块中的main变量定义的格式，可用<span class="tips">log_format</span>命令自行定义。</p><h5 id="3-4-5-location"><a href="#3-4-5-location" class="headerlink" title="3.4.5 location"></a>3.4.5 location</h5><p><span class="strong">location 请求路径;</span></p><p>配置请求路径，可配置多个location块用于响应不同请求</p><div class="show">location  /路径{   //在test目录下匹配该路径(默认)    root /test}location = /路径{   //在test目录下精准匹配该路径    root /test}location ~* \正则表达式  {   //在test目录下正则匹配(添加*号不区分大小写)    root  /test            }~用于标识正则表达式，*表示不区分大小写，^~则表示不包含正则表达式，功能和不加~一致</div><h5 id="3-4-6-root-alias"><a href="#3-4-6-root-alias" class="headerlink" title="3.4.6 root/alias"></a>3.4.6 root/alias</h5><p><span class="strong">root/alias 路径;</span></p><p>用于指定资源查找路径，使用root语句时，客户端请求location路径，Nginx查找资源会直接前往<span class="tips">root路径+location路径</span>。alias一般在需要隐藏服务器真实路径时使用，查找资源会直接前往alias路径，location路径仅作为客户端请求的虚拟路径</p><h5 id="3-4-7-index"><a href="#3-4-7-index" class="headerlink" title="3.4.7 index"></a>3.4.7 index</h5><p><span class="strong">index 文件名;</span></p><p>用于设置主页，文件名可以写多个，如: index index1.html index2.html;当找不到第一个文件时，会依次往后查找。</p><h5 id="3-4-8-error-page"><a href="#3-4-8-error-page" class="headerlink" title="3.4.8 error_page"></a>3.4.8 error_page</h5><p><span class="strong">error_page 状态码 [=状态码] 路径;</span></p><p>用于设置错误处理方法，根据不同的状态码，进行相应处理，常用于配置404，50x页面，可以通过添加[=状态码]修改返回给客户端的状态码，如：error_page 404 [=200] /404.html，浏览器收到的状态码将从404修改为200。路径可以为：</p><ul><li>地址：error_page 404 http://<span></span>wrong.com</li><li>重定向:<div class="show">error_page   500 502 503 504  /50x.html;<br>location = /50x.html {<br>root   html;<br>}</div></li><li>返回信息:<div class="show">error_page 404 @goto<br>loaction @goto{<br>  default_type text/plain;<br>  return 404 ‘not found….’<br>}</div></li></ul><h3 id="Web服务器配置实例"><a href="#Web服务器配置实例" class="headerlink" title="Web服务器配置实例"></a>Web服务器配置实例</h3><p><strong>需求：</strong>在服务器8081和8082端口分别配置server1、server2两个服务，每个服务下有两个页面，根据客户端请求返回不同页面，为每个服务配置单独的访问日志。</p><h4 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h4><p>webservers目录位于服务器根目录下，conf.d目录用于存放每个服务的配置文件，web目录用于存放页面和访问日志。每个服务下的logs目录用于存放access_log日志文件，webpages目录用于存放页面。</p><div class="shell">webservers     |____conf.d     |          |_____server1.conf     |          |_____server2.conf     |____web           |____404.html           |____server1           |          |____logs——access_log           |          |____webpages           |                |____web1.html           |                |____web2.html           |____server2                      |_____logs——access_log                      |_____webpages                                 |_____web3.html                                 |_____web4.html</div><h4 id="http块配置"><a href="#http块配置" class="headerlink" title="http块配置"></a>http块配置</h4><p>定义两个变量server1和server2，用于配置日志格式，两个服务的配置文件独立存放于/webservers/conf.d路径下，使用include引入nginx.conf配置文件中。</p><div class="show">http{    ......    log_format server1 'new access =>$time_local';    log_format server2 'new access =>$time_local';    include /webservers/conf.d/*.conf;//引入两个服务的配置文件}</div><h4 id="server1配置"><a href="#server1配置" class="headerlink" title="server1配置"></a>server1配置</h4><p>访问<span class="tips"><code>http://45.77.77.10:8081</code></span>访问web1页面</p><p>访问<span class="tips"><code>http://45.77.77.10:8081/pages</code></span>访问web2页面</p><pre><code>server&#123;    listen 8081;    server_name 45.77.77.10;    access_log /webservers/web/server1/logs/access.log server1;    error_page 404 /404.html;    location /&#123;    alias /webservers/web/server1/webpages/;    index web1.html;    &#125;    location /pages&#123;    alias /webservers/web/server1/webpages/;    index web2.html;    &#125;    location =/404.html&#123;    root /webservers/web;    index 404.html;    &#125;      &#125;</code></pre><h5 id="server2配置"><a href="#server2配置" class="headerlink" title="server2配置"></a>server2配置</h5><p>访问<span class="tips"><code>http://45.77.77.10:8082/web3.html</code></span>访问web3页面</p><p>访问<span class="tips"><code>http://45.77.77.10:8082/webpages</code></span>访问web4页面</p><pre><code>server&#123;    listen 8082;    server_name 45.77.77.10;    access_log /webservers/web/server2/logs/access.log server2;    error_page 404 /404.html;    location /web3.html&#123;    root /webservers/web/server2/webpages;    index web3.html;    &#125;        location /webpages&#123;    root /webservers/web/server2;    index web4.html;    &#125;    location =/404.html&#123;    root /webservers/web;    index 404.html;    &#125;      &#125;</code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>配置https服务时，使用<span class="tips">ssl_certificatessl 路径</span>语句配置证书，使用<span class="tips">ssl_certificate_key 路径</span>配置密钥</div><h3 id="静态资源提供服务"><a href="#静态资源提供服务" class="headerlink" title="静态资源提供服务"></a>静态资源提供服务</h3><pre><code>http &#123;    .......gzip on;gzip_min_length 1;  //设置最小压缩大小，小于1字节的文件不进行压缩gzip_comp_level 3; //压缩级别(压缩比)，取值范围为1-9，值越大，压缩越多，cpu占用率越高gzip_types text/css text/javascript; //配置压缩的文件类型    server &#123;        listen      80;        server_name  45.77.78.10;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /images/ &#123;  //匹配路径        root /test;         //资源所在路径        autoindex on;  //自动生成资源归档页面         &#125;        location /images &#123;  //匹配路径        root /test;         //资源所在路径         &#125;         location /other/ &#123;  //匹配路径        alias /test/images;         //资源所在路径         &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;        .....    &#125;    ........&#125;</code></pre><p>test目录服务器根目录下，并且在/test/images路径下存放了photo.jpg照片</p><ul><li>使用第一个location配置时，当访问 http:<span></span>//45.77.78.10/images/ 时，ngxin会在自动生成的归档页面上输出/test/images/目录下的所有文件。请求只能为location后面配置的参数，若请求为 http:<span></span>//45.77.78.10/test/images/则会返回404</li><li>使用第二个location配置时，由于未使用 <span class="tips">autoindex on</span> 配置，nginx不会生成归档页面，当访问 http:<span></span>//45.77.78.10/images/ 时nginx将返回403，访问文件需指定具体文件路径，如：http:<span></span>//45.77.78.10/test/images/photo.jpg</li><li>当需要对访问者隐藏服务器实际文件路径时，可以使用<span class="tips">alias</span>进行配置，使用第三个location配置，url应当为http:<span></span>//45.77.78.10/other/photo.jpg，此时实际访问的依旧alias指定的/test/images路径下的文件</li></ul>]]></content>
    
    
    <summary type="html">Nginx是一款高性能的Web服务器软件，也可用于配置反向代理、虚拟主机、域名解析、负载均衡、邮件代理等各类服务器</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Redhat防火墙</title>
    <link href="https://shiwei11.github.io/blog/2022/02/23/Centos%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://shiwei11.github.io/blog/2022/02/23/Centos%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2022-02-23T08:18:13.000Z</published>
    <updated>2022-04-04T20:19:57.613Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>本文不涉及Debian系列操作系统使用的ufw(Uncomplicated FireWall)防火墙</div><h3 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h3><p>Firewalld支持动态更新防火墙规则，并加入了区域（zone）的概念，zone是Firewalld预先准备的几套防火墙策略模板，用户可以根据不同生产场景选择合适的策略集合，从而实现防火墙策略之间的快速切换。</p><h4 id="常用的区域"><a href="#常用的区域" class="headerlink" title="常用的区域"></a>常用的区域</h4><div class="table"><table><thead><tr><th>区域</th><th>默认策略</th></tr></thead><tbody><tr><td>trusted(信任)</td><td>允许所有数据包</td></tr><tr><td>block(阻塞)</td><td>拒绝所有数据包</td></tr><tr><td>drop(丢弃)</td><td>丢弃所有数据包，并且不回复信息</td></tr><tr><td>home(家庭)</td><td>仅接受与流出数据有关，或者与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关的数据包</td></tr><tr><td>public(公共)</td><td>仅接受与流出数据有关，或与ssh、dhcpv6-client服务相关的数据包</td></tr><tr><td>internal(内部)</td><td>仅接受与流出数据有关，或与ssh、mdns、ipp-client、dhcpv6-client服务相关的数据包</td></tr><tr><td>work(工作)</td><td>仅接受与流出的流量，或与ssh、ipp-client与dhcpv6-client服务相关的数据包</td></tr><tr><td>external(外部)</td><td>仅接受与流出流量和ssh服务相关的数据包</td></tr><tr><td>DMZ(隔离)</td><td>又称为非军事区域，内外网络之间增加的一层网络，起到缓冲作用，仅接受与流出的流量相关和ssh服务相关的数据包</td></tr></tbody></table></div><p>firewalld默认提供了9个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、 home.xml、internal.xml、public.xml、trusted.xml、work.xml，文件位于<span class="tips">/usr/lib /firewalld/zones/</span>目录下。用户对区域进行修改后，会在<span class="tips">/etc/firewalld/zones</span>目录下生成对应的(用户自定义)配置文件。</p><h4 id="防火墙开启与关闭"><a href="#防火墙开启与关闭" class="headerlink" title="防火墙开启与关闭"></a>防火墙开启与关闭</h4><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>systemctl start firewalld</td><td>开启防火墙</td></tr><tr><td>systemctl stop firewalld</td><td>关闭防火墙</td></tr><tr><td>systemctl enable firewalld</td><td>开机自启动防火墙</td></tr><tr><td>systemctl disable firewalld</td><td>禁止开机自启动</td></tr><tr><td>systemctl status firewalld</td><td>查看防火墙状态</td></tr></tbody></table></div><h4 id="命令与参数"><a href="#命令与参数" class="headerlink" title="命令与参数"></a>命令与参数</h4><p><span class="strong">firewall-cmd [参数]</span></p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-&zwnj;-state</td><td>查看防火墙是否在运行</td></tr><tr><td>-&zwnj;-get-default-zone</td><td>查看当前生效的防火墙区域</td></tr><tr><td>-&zwnj;-set-default-zone=区域名</td><td>设置生效的防火墙区域</td></tr><tr><td>-&zwnj;-get-zones</td><td>显示所有可用的区域</td></tr><tr><td>-&zwnj;-get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>-&zwnj;-zone=区域名 -&zwnj;-list-all</td><td>列出指定区域的所有配置参数</td></tr><tr><td>-&zwnj;-list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>-&zwnj;-get-services</td><td>查看当前域所有支持的服务(需要放行的服务需要自行添加)</td></tr><tr><td>-&zwnj;-list-services</td><td>查看当前区域允许放行的服务列表</td></tr><tr><td>-&zwnj;-add-service=服务名</td><td>设置当前区域允许该服务的流量通过</td></tr><tr><td>-&zwnj;-add-port=端口号/协议</td><td>设置当前区域允许该端口的流量通过</td></tr><tr><td>-&zwnj;-remove-service=服务名</td><td>设置默认区域禁止该服务的流量通过</td></tr><tr><td>-&zwnj;-remove-port=端口号/协议</td><td>设置当前区域禁止该端口的流量通过</td></tr><tr><td>-&zwnj;-add-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>-&zwnj;-remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>-&zwnj;-add-interface=网卡名</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>-&zwnj;-change-interface=网卡名</td><td>将某个网卡与区域进行关联</td></tr><tr><td>-&zwnj;-list-all</td><td>显示当前区域的网卡、资源配置，以及开放了哪些端口、服务</td></tr><tr><td>-&zwnj;-reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>-&zwnj;-panic-on</td><td>开启应急状况模式(关闭所有网络连接，包括远程ssh连接)</td></tr><tr><td>-&zwnj;-panic-off</td><td>关闭应急状况模式</td></tr></tbody></table></div><h4 id="生效模式，更新防火墙规则"><a href="#生效模式，更新防火墙规则" class="headerlink" title="生效模式，更新防火墙规则"></a>生效模式，更新防火墙规则</h4><p>默认情况下，firewalld配置的防火墙策略为当前生效模式(Runtime)，系统重启时会失效。想让配置策略永久生效，需要添加<span class="tips">-&zwnj;-permanent</span>参数使用永久模式(Permanent)，如：永久开放10800端口：firewall-cmd -&zwnj;-add-port=10800/tcp -&zwnj;-permanent ，但该模式配置的策略需要执行firewall-cmd -&zwnj;-reload命令重新加载后才会生效。</p><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>firewall-cmd -&zwnj;-reload</td><td>重新加载防火墙配置</td></tr><tr><td>firewall-cmd -&zwnj;-complete-reload</td><td>重新加载防火墙，不中断用户的连接,如远程连接（防火墙出严重故障时使用）</td></tr></tbody></table></div><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>1. 查看区域信息</strong></p><div class="shell">查看public区域的所有信息# firewall-cmd --zone=public --list-all返回值的含义：Target：default                  //目标icmp-block-inversion：yes/no    //是否允许ICMP协议类型的数据包通过防火墙Interfaces：                   //关联的网卡sources：                     //来源，可以是IP地址或mac地址services：                   //允许的服务ports：                     //允许的端口，即本地开放的端口protocols：                //允许通过的协议masquerade: yes/no        //是否允许伪装，可改写来源IP地址及mac地址 forward-ports：          //允许转发的端口 source-ports：          //允许的来源端口 icmp-blocks：         //可添加的ICMP类型，当icmp-block-inversion为no时，这些ICMP类型被拒绝；当icmp-block-inversion为yes时，这些ICMP类型被允许 rich rules： //富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。</div><p><strong>2. 放行端口</strong></p><div class="shell">永久放行10800-10805端口的tcp数据# firewall-cmd --permanent --add-port=10800-10805/tcp重新加载防火墙配置# firewall-cmd --reload</div><p><strong>3. 为网卡绑定区域</strong></p><p>一般情况下，一台主机会有多个网卡，比如一块对公网，一块对内网，因此网卡使用的防火墙策略也不一样，可以单独为某个网卡绑定某个区域。通过firewall-cmd –set-default-zone命令设置的区域会对所有网卡生效，但如果该网卡绑定了单独的区域，则单独绑定区域的优先级更高。</p><div class="shell">将网卡eth0默认区域修改为external# firewall-cmd --permanent --zone=external --change-interface=eth0</div><p><strong>4. 查询服务是否放行</strong></p><p>如：查询SSH和HTTPS协议的流量是否允许放行</p><div class="shell">查询public区域中SSH协议的流量是否被放行# firewall-cmd --zone=public --query-service=ssh查询public区域中https协议的流量是否被放行# firewall-cmd --zone=public --query-service=https</div><p><strong>5. 放行协议流量</strong></p><p>把HTTPS协议的流量设置为永久允许放行</p><div class="shell">在public区域中放行https协议的流量# firewall-cmd --permanent --zone=public --add-service=https重新加载防火墙配置# firewall-cmd --reload</div><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>端口转发命令格式如下，目标IP地址为所要访问服务器的IP地址：<br><span class="strong">firewall-cmd –permanent –zone=区域 –add-forward-port=port=源端口号:proto=协议:toport=目标端口号:toaddr=目标IP地址</span></p><div class="shell">将9000端口转发到22端口，使得用户能通过9000端口使用ssh远程连接服务# firewall-cmd --permanent --zone=public --add-forward-port=port=9000:proto=tcp:toport=22:toaddr=192.168.0.1重新加载防火墙配置# firewall-cmd --reload</div><h4 id="富规则"><a href="#富规则" class="headerlink" title="富规则"></a>富规则</h4><p>富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置，它的优先级在所有的防火墙策略中也是最高的。</p><div class="shell">拒绝192.168.0.1/24网段的所有用户访问本机的ssh服务# # firewall-cmd --permanent --zone=public --add-rich-rule="rule family="ipv4" source address="192.168.0.1/24" service name="ssh" reject"重新加载防火墙配置# firewall-cmd --reload</div><h3 id="IPTables"><a href="#IPTables" class="headerlink" title="IPTables"></a>IPTables</h3><p>早期的RHEL系列的操作系统，默认使用IPTables来配置防火墙。RHEL7之后的系统使用firewalld取代了IPTables防火墙，IPTables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。</p><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>Centos官方IPTables文档：<a target="_blank" href="https://wiki.centos.org/HowTos/Network/IPTables">https://wiki.centos.org/HowTos/Network/IPTables</a></div><h4 id="策略与规则链"><a href="#策略与规则链" class="headerlink" title="策略与规则链"></a>策略与规则链</h4><p>IPTables会根据管理员书写的策略来决定防火墙是否放行数据包通过，基本的策略规则有四种：ACCEPT、REJECT、LOG、DROP。IPTables会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后立即执行规则定义的行为(如：放行或阻止流量)，若在读取完所有的策略规则之后没有匹配项，则会执行默认的策略。</p><p>IPTables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链。<span class="tips">由于防火墙策略规则是按照从上到下的顺序匹配执行的，因此一定要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝，因此规则链最后一条往往为拒绝规则。</span></p><p>当防火墙的默认策略为拒绝时，需要添加相应的规则链来放行允许进入服务器的数据，否则服务器将拒绝所有数据包；而当防火墙的默认策略为允许时，则需要添加相应的拒绝规则链，否则防火墙就失去了它的作用。一般情况下，INPUT流量的默认策略为拒绝，OUTPUT流量默认策略为允许。</p><h4 id="数据包分类与处理方式"><a href="#数据包分类与处理方式" class="headerlink" title="数据包分类与处理方式"></a>数据包分类与处理方式</h4><p>根据数据包的不同处理位置，数据包分为</p><ul><li><span class="strong">在进行路由选择前处理数据包(PREROUTING)</strong></li><li><span class="strong">处理流入的数据包(INPUT)</strong></li><li><span class="strong">处理流出的数据包(OUTPUT)</strong></li><li><span class="strong">处理转发的数据包(FORWARD)</strong></li><li><span class="strong">在进行路由选择后处理数据包(POSTROUTING)</strong></li></ul><h5 id="数据包处理方式"><a href="#数据包处理方式" class="headerlink" title="数据包处理方式"></a>数据包处理方式</h5><div class="table"><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td>ACCEPT</td><td>允许流量通过</td></tr><tr><td>REJECT</td><td>拒绝流量通过并返回流量被丢弃的提示信息</td></tr><tr><td>LOG</td><td>记录日志信息</td></tr><tr><td>DROP</td><td>拒绝流量通过且不返回任何信息</td></tr></tbody></table></div><p>REJECT会在拒绝流量后，告知流量发送方流量已收到，但服务器拒绝响应的信息</p><p>DROP会直接丢弃流量，使流量发送方不清楚流量是被拒绝还是主机不在线，一般能更好保护主机安全。</p><h4 id="命令与参数-1"><a href="#命令与参数-1" class="headerlink" title="命令与参数"></a>命令与参数</h4><p><span class="strong">iptables [参数] [对象]</span></p><div class="table"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-L</td><td>查看当前的规则链，可以使用iptables -L –line-numbers命令显示规则链的序号</td></tr><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-A</td><td>在规则链末尾加入新规则</td></tr><tr><td>-I [序号]</td><td>在指定序号规则前加入新规则，无序号默认在规则链首加入</td></tr><tr><td>-R 序号</td><td>替换指定规则，无序号默认替换第一条规则</td></tr><tr><td>-D 序号</td><td>删除指定规则</td></tr><tr><td>-s IP/主机名</td><td>匹配来源的IP和主机，加!号表示除该IP外，子网掩码可以使用/MASK的方式表示</td></tr><tr><td>-d</td><td>匹配目标地址，类似于参数-s</td></tr><tr><td>-J</td><td>跳转到下一个处理规则，可能的值有：ACCEPT(允许数据通过), DROP(丢弃), QUEUE(进入队列), RETURN(返回上一个跳转规则)。也可以添加规则名跳转到指定规则</td></tr><tr><td>-i 网卡名</td><td>匹配从该网卡流入的数据</td></tr><tr><td>-o 网卡名</td><td>匹配从该网卡流出的数据</td></tr><tr><td>-p 协议</td><td>匹配协议，如:TCP、UDP等,all代表所有协议(一般不使用)</td></tr><tr><td>-&zwnj;-dport 端口号</td><td>匹配目标端口号</td></tr><tr><td>-&zwnj;-sport 端口号</td><td>匹配来源端口号</td></tr></tbody></table></div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>防火墙命令均需要root权限</div><div class="shell">如：查看当前规则链iptables -L返回结果：Chain INPUT (policy ACCEPT)     //INPUT数据包，默认策略为ACCEPTnum  target     prot opt source               destination         1    ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED2    ACCEPT     all  --  anywhere             anywhere            3    INPUT_direct  all  --  anywhere             anywhere            4    INPUT_ZONES_SOURCE  all  --  anywhere             anywhere            5    INPUT_ZONES  all  --  anywhere             anywhere            6    DROP       all  --  anywhere             anywhere             ctstate INVALID7    REJECT     all  --  anywhere             anywhere             reject-with icmp-host-prohibited</div><div class="show">示例：<strong>1. 修改INPUT规则链默认配置为拒绝，并允许允许ICMP流量进入(允许服务器被ping后返回信息)</strong># iptables -P INPUT DROP# iptables -I INPUT -p icmp -j ACCEPT<strong>2. 拒绝所有人访问本机10800端口</strong># iptables -I INPUT -p tcp --dport 10800 -j REJECT# iptables -I INPUT -p udp --dport 10800 -j REJECT<strong>3. 拒绝192.168.10.5主机访问本机80端口</strong>iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT<strong>4.拒绝所有主机访问本机1000～1024端口</strong># iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT<strong>5.只允许192.168.10.0主机访问本机的22端口，拒绝来自其他所有主机的流量。</strong># iptables -I INPUT -s 192.168.10.0 -p tcp --dport 22 -j ACCEPT# iptables -A INPUT -p tcp --dport 22 -j REJECT</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>如同第5条命令，由于防火墙策略规则是按照从上到下的顺序匹配的，因此需要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝</div><div class="show">网口转发,如将公网的数据包转发到内网,假设eth0连接内网，eth1连接公网iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</div><h4 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h4><p>通过命令添加的规则链，会在系统重启后失效，因此需要写入配置文件使其永久生效，可以使用命令<span class="tips">service iptables save</span>保存</p><p>ipv4默认保存位置为<span class="tips">/etc/sysconfig/iptables-config</span></p><p>ipv6默认保存位置为<span class="tips">/etc/sysconfig/ip6tables-config</span></p>]]></content>
    
    
    <summary type="html">Redhat系列系统防火墙的配置方法，包括防火墙策略配置语法，IPTable和firewalld服务的常用命令，适用于CentOS、Fedora、RHEL发行版</summary>
    
    
    
    
    <category term="CentOS" scheme="https://shiwei11.github.io/blog/tags/CentOS/"/>
    
    <category term="firewall" scheme="https://shiwei11.github.io/blog/tags/firewall/"/>
    
  </entry>
  
  <entry>
    <title>Bash与shell脚本</title>
    <link href="https://shiwei11.github.io/blog/2022/02/10/Bash%E4%B8%8Eshell/"/>
    <id>https://shiwei11.github.io/blog/2022/02/10/Bash%E4%B8%8Eshell/</id>
    <published>2022-02-10T10:38:49.000Z</published>
    <updated>2022-04-03T16:05:29.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bash命令"><a href="#Bash命令" class="headerlink" title="Bash命令"></a>Bash命令</h3><h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><p><span class="strong">history [选项] [历史命令保存文件]</span></p><ul><li>-c&emsp;清空历史命令</li><li>-w&emsp;把缓存的历史命令写入历史命令保存文件~/.bash_history中</li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>每个用户都有独立的历史命令保存文件，一般在用户家目录下，该文件默认隐藏，用户执行过的命令会先缓存在内存中，等登出账户后再写入bash_history文件中，历史命令默认保存1000条，用户可在环境变量配置文件/etc/profile中的HISTSIZE选项自行修改</div><h4 id="调用历史命令"><a href="#调用历史命令" class="headerlink" title="调用历史命令"></a>调用历史命令</h4><ul><li><span class="strong">可通过上下箭头调用之前执行的命令</span></li><li><span class="strong">!!</span>再次执行上一次执行的命令</li><li><span class="strong">!n</span>再次执行第n条历史命令(序号以history列出的序号为准)</li><li><span class="strong">!字符串</span>再次执行最后一次以该字符串开头的命令</li></ul><h4 id="自定义命令名"><a href="#自定义命令名" class="headerlink" title="自定义命令名"></a>自定义命令名</h4><p><span class="strong">alias</span>查看所有自定义的命令</p><p><span class="strong">alias 别名=’原命令’</span>自定义命令名，原命令依旧可用</p><p>使用命令定义的命令名只能临时生效，系统重启后将丢失，要永久生效需将自定义的命令添加到文件<span class="tips">/用户名/.bashrc</span>中</p><p>删除自定义的命令:</p><p><span class="strong">unalias 别名</span></p><h4 id="命令的执行优先级"><a href="#命令的执行优先级" class="headerlink" title="命令的执行优先级"></a>命令的执行优先级</h4><ul><li>第一顺位执行通过绝对路径或相对路径执行的命令</li><li>第二顺位执行自定义的命令别名</li><li>第三顺位执行bash内部命令</li><li>第四顺位执行$PATH环境变量定义的第一个命令</li></ul><h4 id="bash常用快捷键"><a href="#bash常用快捷键" class="headerlink" title="bash常用快捷键"></a>bash常用快捷键</h4><div class="table"><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>ctrl+c</td><td>强制终止当前目录</td></tr><tr><td>ctrl+l</td><td>清屏，同clear命令</td></tr><tr><td>ctrl+u</td><td>剪切光标之前的命令</td></tr><tr><td>ctrl+k</td><td>剪切光标之后的内容</td></tr><tr><td>ctrl+y</td><td>粘贴剪切的内容</td></tr><tr><td>ctrl+r</td><td>搜索执行过的历史命令</td></tr><tr><td>ctrl+d</td><td>退出当前终端</td></tr><tr><td>ctrl+z</td><td>暂停工作并放入后台</td></tr><tr><td>ctrl+a</td><td>将光标移动到命令行开头</td></tr></tbody></table></div><p>相关命令</p><ul><li><span class="strong">stty -a</span>&emsp;查看所有快捷键</li><li><span class="strong">stty 关键字 快捷键</span>&emsp;更改快捷键</li></ul><h3 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h3><h4 id="shell的不同家族"><a href="#shell的不同家族" class="headerlink" title="shell的不同家族"></a>shell的不同家族</h4><p>Bourne Shell：包括sh、ksh、Bash、psh、zsh，Linux默认使用Bash</p><p>C Shell：包括csh、tcsh，语法与C语言类似，主要用于BSD版Unix系统</p><h4 id="Linux支持的shell"><a href="#Linux支持的shell" class="headerlink" title="Linux支持的shell"></a>Linux支持的shell</h4><p>查看<span class="tips">/etc/shells</span>文件可获取当前Linux支持的shell列表，Linux默认使用Bash作为命令解释器，直接输入其他shell名可进行切换，通过<span class="tips"><strong>exit</strong></span>命令返回默认的Bash终端</p><h4 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h4><h5 id="通过路径直接运行脚本"><a href="#通过路径直接运行脚本" class="headerlink" title="通过路径直接运行脚本"></a>通过路径直接运行脚本</h5><p>赋予脚本执行权限，然后运行,如对于名为HelloWorld.sh脚本，执行方式为:<br><span class="strong">chmod 755 HelloWorld.sh</span></p><p> <span class="strong">./HelloWorld.sh</span></p><h5 id="通过bash调用"><a href="#通过bash调用" class="headerlink" title="通过bash调用"></a>通过bash调用</h5><p>bash HelloWorld.sh</p><h4 id="脚本格式转换"><a href="#脚本格式转换" class="headerlink" title="脚本格式转换"></a>脚本格式转换</h4><p>在Linux中，回车符识别为<span class="tips"><strong><code>$</code></strong></span>，而在windows中回车符为^M$，因此在windows中编写的sh脚本需要经过转换，才能在Linux中运行，转换命令为：<br><span class="strong">dos2unix 文件名</span><br>相反，将文件从Linux格式转为Windows格式为<br><span class="strong">unix2dos 文件名</span></p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>该功能需要自行安装，yum -y install dos2unix</div><h3 id="shell基础语法"><a href="#shell基础语法" class="headerlink" title="shell基础语法"></a>shell基础语法</h3><h4 id="脚本声明"><a href="#脚本声明" class="headerlink" title="脚本声明"></a>脚本声明</h4><div class="show">#!bin/bash  //申明shell脚本</div><h4 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h4><p><span class="strong">echo [选项] [输出内容]</span></p><ul><li>-e&emsp;支持使用\进行字符转换</li></ul><h4 id="修改字体颜色"><a href="#修改字体颜色" class="headerlink" title="修改字体颜色"></a>修改字体颜色</h4><p>通过转义序列，可以修改终端的字体、背景的颜色和显示效果。转义序列语法为：</p><p><span class="strong">[代码m</span></p><p>转义序列语法前需要使用<span class="tips">\e或\033 或\x1B</span>来引导非常规字符序列</p><div class="show">如：输出红色字符串 "RedColor"# echo -e "\e[31mRedColor \e[0m"末尾的\e[0m用于删除所有设置的属性(包括颜色、加粗、闪烁等效果)使后续输出内容恢复默认属性</div><h5 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h5><div class="table"><table><thead><tr><th>设置效果代码</th><th>效果</th><th>取消效果代码</th></tr></thead><tbody><tr><td>1</td><td>加粗高亮</td><td>21</td></tr><tr><td>2</td><td>变暗</td><td>22</td></tr><tr><td>4</td><td>下划线</td><td>24</td></tr><tr><td>5</td><td>闪烁</td><td>25</td></tr><tr><td>7</td><td>反转背景色和前景色</td><td>27</td></tr><tr><td>8</td><td>隐藏(常用于密码)</td><td>28</td></tr></tbody></table></div><h5 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h5><div class="table"><table><thead><tr><th>代码</th><th>颜色</th><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>39</td><td>默认颜色</td><td></td><td></td></tr><tr><td>30</td><td>黑色</td><td>90</td><td>深灰</td></tr><tr><td>31</td><td>红色</td><td>91</td><td>红色</td></tr><tr><td>32</td><td>绿色</td><td>92</td><td>浅绿色</td></tr><tr><td>33</td><td>黄色</td><td>93</td><td>淡黄色</td></tr><tr><td>34</td><td>蓝色</td><td>94</td><td>浅蓝</td></tr><tr><td>35</td><td>品红</td><td>95</td><td>浅洋红色</td></tr><tr><td>36</td><td>青色</td><td>96</td><td>浅青色</td></tr><tr><td>37</td><td>浅灰</td><td>97</td><td>白色</td></tr></tbody></table></div><h5 id="字体背景色"><a href="#字体背景色" class="headerlink" title="字体背景色"></a>字体背景色</h5><div class="table"><table><thead><tr><th>代码</th><th>颜色</th><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>49</td><td>默认颜色</td><td></td><td></td></tr><tr><td>40</td><td>黑色</td><td>100</td><td>深灰</td></tr><tr><td>41</td><td>红色</td><td>101</td><td>红色</td></tr><tr><td>42</td><td>绿色</td><td>102</td><td>浅绿色</td></tr><tr><td>43</td><td>黄色</td><td>103</td><td>淡黄色</td></tr><tr><td>44</td><td>蓝色</td><td>104</td><td>浅蓝</td></tr><tr><td>45</td><td>品红</td><td>105</td><td>浅洋红色</td></tr><tr><td>46</td><td>青色</td><td>106</td><td>浅青色</td></tr><tr><td>47</td><td>浅灰</td><td>107</td><td>白色</td></tr></tbody></table></div><h5 id="修改文件目录颜色"><a href="#修改文件目录颜色" class="headerlink" title="修改文件目录颜色"></a>修改文件目录颜色</h5><p>想在使用ls命令后使各种不同类型文件显示不同颜色，可以修改<span class="tips">/etc/DIR_COLORS</span>文件中的颜色配置，修改完成后使用<span class="tips">eval `dircolors /etc/DIR_COLORS`</span>命令使之生效</p><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><h5 id="1-标准输入输出设备"><a href="#1-标准输入输出设备" class="headerlink" title="1. 标准输入输出设备"></a>1. 标准输入输出设备</h5><div class="table"><table><thead><tr><th>设备</th><th>Linux文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>/dev/stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>/dev/stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>/dev/stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table></div><h5 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2. 输出重定向"></a>2. 输出重定向</h5><div class="table"><table><thead><tr><th>类型</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td rowspan="2">标准输出重定向</td><td>&gt;</td><td>以覆盖方式将正确命令返回内容输出到指定文件或设备中</td></tr><tr><td>&gt;&gt;</td><td>以追加方式将正确命令返回内容输出到指定文件或设备中</td></tr><tr><td rowspan="2">标准错误输出重定向</td><td>2&gt;</td><td>以覆盖方式将错误命令返回内容输出到指定文件或设</td></tr><tr><td>2&gt;&gt;</td><td>以追加方式将错误命令返回内容输出到指定文件或设备中</td></tr>      <tr>      <td rowspan="5">同时输出正确和错误命令返回信息</td>      <td>命令&&gt;文件</td>      <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&&gt;&gt;文件</td>         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&&gt;文件 2&gt;&1</td>         <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&&gt;&gt;文件 2&gt;&1</td>         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&gt;&gt;文件1 2&gt;&gt;文件2</td>         <td>把正确命令返回信息追加到文件1中，错误命令返回信息追加到文件2中</td>      </tr>   </tbody></table></div><h5 id="3-输入重定向-不常用"><a href="#3-输入重定向-不常用" class="headerlink" title="3. 输入重定向(不常用)"></a>3. 输入重定向(不常用)</h5><p><span class="strong">wc [选项] [文件名]</span></p><ul><li>-c &emsp;统计字节数</li><li>-w &emsp;统计单词数</li><li>-l &emsp;统计行数</li></ul><div class="show"># wc < test计算test文件字符数等</div><h5 id="4-多命令执行"><a href="#4-多命令执行" class="headerlink" title="4. 多命令执行"></a>4. 多命令执行</h5><div class="table"><table><thead><tr><th>多命令执行</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td>;</td><td>命令1;命令2</td><td>顺序执行，若前一命令执行错误，则跳过继续执行</td></tr><tr><td>&amp;&amp;</td><td>命令1&amp;&amp;命令2</td><td>当命令1正确执行，才继续执行命令2</td></tr><tr><td>||</td><td>命令1||命令2</td><td>当命令1正确执行，停止执行命令2，命令1错误才继续执行命令2</td></tr></tbody></table></div><div class="show"># 命令 && echo true || echo false   类似于三目运算符，执行命令，执行正确输出true，执行错误输出false</div><h5 id="5-管道符"><a href="#5-管道符" class="headerlink" title="5. 管道符"></a>5. 管道符</h5><p><span class="strong">命令1 | 命令2</span>将命令1的输出作为命令2的输入</p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><div class="table"><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>‘’</td><td>单引号中的所有特殊字符仅作为普通字符，无特殊含义，</td></tr><tr><td>“”</td><td>双引号中的所有特殊字符，除了$、`、\外，其他仅作为普通字符。命令行中的字符串之间有空格时，需要通过引号包裹</td></tr><tr><td>``</td><td>反引号，引入系统命令</td></tr><tr><td>$()</td><td>同``，引入系统命令</td></tr><tr><td>#</td><td>注释</td></tr><tr><td>$</td><td>调用变量值</td></tr><tr><td>\</td><td>转义符，输出$等字符可使用$使其无特殊含义</td></tr></tbody></table></div><h5 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h5><div class="table"><table><thead><tr><th>字符转换</th><th>作用</th></tr></thead><tbody><tr><td>\\</td><td>输出\</td></tr><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>退格，删除一个字符</td></tr><tr><td>\c</td><td>取消行末的换行符,同-n选项</td></tr><tr><td>\e</td><td>ESC键</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车键</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\0nnn</td><td>按照八进制ASCII码表输出字符，如:\x106</td></tr><tr><td>\xhh</td><td>按照十六进制ASCII码表输出字符，如:\xff</td></tr></tbody></table></div><h4 id="根据关键字搜索grep"><a href="#根据关键字搜索grep" class="headerlink" title="根据关键字搜索grep"></a>根据关键字搜索grep</h4><p><span class="strong">grep [选项] 搜索内容</span></p><ul><li>-i&emsp;忽略大小写</li><li>-n&emsp;输出行号</li><li>-v&emsp;反向查找</li><li>-&zwnj;-color=auto;&emsp;搜索到的关键字用颜色高亮显示(默认)</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li>自定义变量</li><li>环境变量：保存和操作系统环境相关的数据</li><li>位置参数变量：用于向脚本中传递参数和数据，变量名不能自定义</li><li>预定义变量：bash预定义的变量</li></ul><h5 id="查看所有变量"><a href="#查看所有变量" class="headerlink" title="查看所有变量"></a>查看所有变量</h5><p><span class="strong">set</span>&emsp;查看所有变量(包括系统自定义的变量)</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul><li>变量名规则同C语言，允许由字母、数字、下划线组成，但不能以数字开头</li><li>bash中变量默认类型都为字符串类型</li><li>变量赋值时，若值包含空格，则需要使用单引号或双引号包裹</li><li>变量值中可以使用\进行转义</li><li>环境变量名一般使用大写</li></ul><p><span class="tips">自定义变量不需要int、var等关键字，直接写<strong> 变量名=值</strong> 即可</span>，如：name=”South West”</p><h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><ul><li><span class="strong">unset 变量名</span>&emsp;删除变量</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul><li><span class="strong">export 变量名=值</span>&emsp;定义环境变量</li><li><span class="strong">env</span>&emsp;查询环境变量</li><li><span class="strong">unset 变量名</span>&emsp;删除变量</li></ul><p>用户自定义的变量只在当前shell终端中有效，如果需要该变量在所有shell中生效，则需要把该变量写入环境变量的配置文件中</p><h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><div class="table">   <table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>$n</td><td>n为数字，$0代表命令本身，$1-$9代表命令第1-9个参数，10以上用{}包裹，如:${10}</td></tr><tr><td>$*</td><td>代表命令行所有参数，$*将命令行所有参数作为一个整体进行处理，在遍历时循环只执行一次</td></tr><tr><td>$@</td><td>代表命令行所有参数，$@将区分每一个参数</td></tr><tr><td>$#</td><td>代表命令行所有参数个数</td></tr></tbody></table></div><div class="show">定义一个test.sh脚本#! /bin/bashnum1=$1num2=$2sum=$(($num1+$num2))echo "sum is: $sum"执行该脚本并传参chmod 755 test.sh./test.sh 10 20输出参数和 30</div><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><div class="table">   <table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>$?</td><td>返回上一个命令的执行状态，如果返回0则说明执行正确，返回值非0则说明上一个命令执行不正确</td></tr><tr><td>$$</td><td>当前进程的进程号(PID)</td></tr><tr><td>$!</td><td>后台运行最后一个进程的进程号(PID)</td></tr></tbody></table></div><h4 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h4><p><span class="strong">read [选项] [变量名]</span></p><ul><li>-p “提示信息” &emsp;输出提示信息</li><li>-t 秒数 &emsp;read命令只等待指定时间</li><li>-n 字符数&emsp;read命令只接收指定数量字符</li><li>-s &emsp;隐藏输入的内容</li></ul><div class="shell">示例：#!/bin/bashread -t 30 -p "input name:" name    //30s内输入姓名并赋值给nameread -s -t 30 -p "input password:" passwd  //30s内隐藏输入密码并赋值给passwdecho "Name is $name"                //输出姓名echo -e "\n"                        //输出换行符</div><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><h4 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h4><p><span class="strong">declare [+或-] [选项] 变量名</span></p><ul><li>-&emsp;给变量设置类型属性</li><li>+&emsp;取消变量的类型属性</li><li>-i&emsp;将变量声明为整形(integer)</li><li>-x&emsp;将变量声明为环境变量</li><li>-p&emsp;查看变量的类型</li></ul><h4 id="数值运算-1"><a href="#数值运算-1" class="headerlink" title="数值运算"></a>数值运算</h4><h5 id="1-通过”-”或”-”运算式"><a href="#1-通过”-”或”-”运算式" class="headerlink" title="1.通过”$(())”或”$[]”运算式"></a>1.通过”$(())”或”$[]”运算式</h5><ul><li><span class="strong">变量名=$((运算式))</span></li><li><span class="strong">变量名=$[运算式]</span></li></ul><div class="shell">示例：[root@localhost ~]# num1=$((11+22))[root@localhost ~]# num2=$[11+22]</div><h5 id="2-通过declare-i声明"><a href="#2-通过declare-i声明" class="headerlink" title="2.通过declare -i声明"></a>2.通过declare -i声明</h5><p><span class="strong">declare -i 变量名</span></p><div class="shell">示例：[root@localhost ~]# declare -i num1=11+22</div><h5 id="3-通过expr或let转换为数值"><a href="#3-通过expr或let转换为数值" class="headerlink" title="3.通过expr或let转换为数值"></a>3.通过expr或let转换为数值</h5><p><span class="strong">变量名=$(expr $变量1 + $变量2)</span></p><div class="shell">示例:[root@localhost ~]# a=11[root@localhost ~]# b=22[root@localhost ~]# num1=$a+$b[root@localhost ~]# echo $num1  //输出11+22[root@localhost ~]# num2=$(expr $a + $b)  //严格遵守expr后空格，+号两边空格[root@localhost ~]# echo $num2  //输出33</div><h4 id="变量测试与内容替换"><a href="#变量测试与内容替换" class="headerlink" title="变量测试与内容替换"></a>变量测试与内容替换</h4><div class="table"><table><thead><tr><th>语句</th><th>未定义变量y</th><th>变量y为空</th><th>变量y有值</th></tr></thead><tbody><tr><td>x=${y-新值}</td><td>x=新值</td><td>x为空</td><td>x=$y</td></tr><tr><td>x=${y:-新值}</td><td>x=新值</td><td>x=新值</td><td>x=$y</td></tr><tr><td>x=${y+新值}</td><td>x为空</td><td>x=新值</td><td>x=新值</td></tr><tr><td>x=${y:+新值}</td><td>x为空</td><td>x为空</td><td>x=新值</td></tr><tr><td>x=${y=新值}</td><td>x=y=新值</td><td>x为空，y值不变</td><td>x=$y,y值不变</td></tr><tr><td>x=${y:=新值}</td><td>x=y=新值</td><td>x=y=新值</td><td>x=$y,y值不变</td></tr><tr><td>x=${y?新值}</td><td>新值输出到标准错误输出</td><td>x为空</td><td>x=$y</td></tr><tr><td>x=${y:?新值}</td><td>新值输出到标准错误输出</td><td>新值输出到标准错误输出</td><td>x=$y</td></tr></tbody></table></div><div class="shell">示例：[root@localhost ~]# x=${y-new}    //new值可任意[root@localhost ~]# echo $x      //未定义y，x值也为new[root@localhost ~]# y=""         //定义y，赋为空[root@localhost ~]# x=${y-new}   //此时x为空</div><h3 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h4><h5 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h5><p>对所有用户生效</p><ul><li><strong>/etc/profile</strong>&emsp;主要的配置文件，也是用户登录时最先读取的文件</li><li><strong>/etc/profile.d/.sh后缀文件</strong>&emsp;由profile调用</li><li><strong>/etc/bashrc</strong>&emsp;定义PS1等bash终端的环境</li></ul><h5 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h5><p>只对单一用户生效，每个用户都有自己的配置文件，root用户位于/root下，普通用户位于/home/用户名下，默认隐藏，需要使用ls -a命令才能看见文件</p><ul><li>~/.bash_profile &emsp; 用户个人的/etc/profile文件 </li><li>~/.bashrc &emsp;写有用户自定义的命令别名等</li><li>~/.bash_logout &emsp;用户注销时执行的环境变量配置文件，可以写一些我们希望系统关机时执行的操作，如备份日志等</li><li>~/.bash_history &emsp;记录用户执行过的命令</li></ul><h5 id="不重启就使配置文件生效"><a href="#不重启就使配置文件生效" class="headerlink" title="不重启就使配置文件生效"></a>不重启就使配置文件生效</h5><p>直接执行任一命令</p><ul><li><span class="strong">source 文件名</span></li><li><span class="strong">.配置文件名</span></li></ul><h4 id="etc-profile配置文件"><a href="#etc-profile配置文件" class="headerlink" title="/etc/profile配置文件"></a>/etc/profile配置文件</h4><p>配置文件中变量的主要作用</p><div class="table"><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>USER</td><td>当前用户</td></tr><tr><td>LOGNAME</td><td>当前用户名，配置文件中LOGNAME=$USER，因此同USER</td></tr><tr><td>MAIL</td><td>用户邮箱</td></tr><tr><td>HOSTNAME</td><td>主机名</td></tr><tr><td>HISTSIZE</td><td>历史命令保存条数</td></tr><tr><td>umask</td><td>设置文件默认权限</td></tr></tbody></table></div><h4 id="全局执行脚本方式"><a href="#全局执行脚本方式" class="headerlink" title="全局执行脚本方式"></a>全局执行脚本方式</h4><p>执行脚本一般需要在赋予脚本执行权限后，使用绝对路径调用，或者进入脚本所在目录，使用相对路径调用。全局使用的脚本和命令，Linux是根据PATH寻找相应路径自动执行实现的，可通过<span class="strong">echo $PATH</span>查看当前配置的全局路径，手动安装的服务想实现全局执行脚本，有两种实现方法：</p><ul><li><span class="strong">将脚本cp复制到PATH中的某个路径下，如:/usr/bin下</span></li><li><span class="strong">通过变量叠加的方式，将脚本路径添加到PATH变量中，格式为PATH=”$PATH”:路径</span></li></ul><p>通过变量叠加的方式添加的全局变量，在系统重启后将失效，永久生效方法是将路径添加到<span class="tips">/etc/profile</span>文件的PATH变量后</p><div class="show">如Nginx的启动脚本在/usr/local/nginx/sbin路径下，非全局启动方法为：1.相对路径： 在 /usr/local/nginx/sbin 路径下执行./nginx 2. 绝对路径：执行 /usr/local/nginx/sbin/nginx添加到全局的方法为：执行PATH="$PATH":/usr/local/nginx/sbin使调用命令永久生效的方法：在 /etc/profile 中最后一行添加PATH=$PATH:/usr/local/nginx/sbin</div><h4 id="修改命令提示符"><a href="#修改命令提示符" class="headerlink" title="修改命令提示符"></a>修改命令提示符</h4><p>默认情况下的命令提示符为<span class="tips">[用户名@主机名 当前目录]提示符</span>，如：[root@localhost ~]#，该默认值由系统定义的变量<span class="tips">PS1</span>决定，可通过<span class="strong">echo $PS1</span>&emsp;查看当前配置，也可以通过修改PS1变量自定义命令提示符，如：</p><div class="show">PS1='[\u@\t \w]#'命令提示符将修改为：[root@15:21:13 /home/user1]#</div>但通过修改变量自定义的命令提示符，只在本次登录有效，系统重启后将失效，需要永久修改命令提示符，可以将上述语句写入配置文件<span class="tips">/etc/bashrc</span>中，自定义命令提示符常用的转义符有：<div class="table"><table><thead><tr><th>转义符</th><th>作用</th></tr></thead><tbody><tr><td>\d</td><td>显示当前系统日期，格式为”星期 月 日”</td></tr><tr><td>\h</td><td>显示简写主机名</td></tr><tr><td>\t</td><td>显示24小时制时间，格式为”HH:MM:SS”</td></tr><tr><td>\T</td><td>显示12小时制时间，格式为”HH:MM:SS”</td></tr><tr><td>\A</td><td>显示24小时制时间，格式为”HH:MM”</td></tr><tr><td>\u</td><td>显示当前用户名</td></tr><tr><td>\w</td><td>显示当前所在目录完整名称</td></tr><tr><td>\W</td><td>显示所在目录最后一个目录</td></tr><tr><td>\#</td><td>显示执行的第几个命令</td></tr><tr><td>$</td><td>提示符，root用户提示符为”#”，普通用户为”$”</td></tr></tbody></table></div><h5 id="修改bash终端颜色"><a href="#修改bash终端颜色" class="headerlink" title="修改bash终端颜色"></a>修改bash终端颜色</h5><p>永久修改Bash终端的默认配色，可以修改<span class="tips">/etc/bashrc</span>配置文件中的PS1变量，若只想修改某个用户的终端，可以修改该用户家目录下的<span class="tips">.bashrc</span>配置文件中的PS1变量。</p><p>配置文件中修改颜色的语句需要用”[]”包裹，并且”[]”前需要使用转义符，并使用\e获取颜色设置字符，即语法为：</p><p><span class="strong">\[\e[颜色码m\]</span></p><p>修改完使用<span class="tips">source 文件名</span>使之生效</p><div class="shell">如在/etc/bashrc文件最后一行添加语句：PS1='\[\e[0m\][\[\e[36m\]\u\[\e[34m\]@\h \[\e[36m\]\W\[\e[0m\]]\[\e[95m\]#\[\e[0m\]'终端提示符将变为：[<span style="color:#0cf8fc;">root</span><span style="color:#0c8afc;">@myLinux</span> <span style="color:#0cf8fc;">etc</span>]<span style="color:#fc0ce6;">#</span></div><h4 id="本地终端登录欢迎信息"><a href="#本地终端登录欢迎信息" class="headerlink" title="本地终端登录欢迎信息"></a>本地终端登录欢迎信息</h4><p>需要修改本地终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue</span>，配置文件中可使用的转义字符：</p><div class="table"><table><thead><tr><th>转义符</th><th>作用</th></tr></thead><tbody><tr><td>\d</td><td>显示当前系统日期</td></tr><tr><td>\t</td><td>显示当前系统时间</td></tr><tr><td>\s</td><td>显示操作系统名称</td></tr><tr><td>\l</td><td>显示登录的终端号</td></tr><tr><td>\m</td><td>显示硬件架构信息，如i386等</td></tr><tr><td>\n</td><td>显示主机名</td></tr><tr><td>\o</td><td>显示域名</td></tr><tr><td>\r</td><td>显示内核版本</td></tr><tr><td>\u</td><td>显示当前用户登录的序列号</td></tr></tbody></table></div><div class="show">最小化安装的Centos7默认配置为：\SKernel \r on an \m</div><h4 id="远程终端登录欢迎信息"><a href="#远程终端登录欢迎信息" class="headerlink" title="远程终端登录欢迎信息"></a>远程终端登录欢迎信息</h4><p>修改远程终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue.net</span>，该文件不支持上述本地终端登录可用的转义字符，需要显示此欢迎信息，需要在配置文件<span class="tips">/etc/ssh/sshd_config</span>中加入<span class="tips">Banner /etc/issue.net</span>配置内容(需要重启生效)</p><div class="shell">/etc/ssh/sshd_config文件添加配置位置:#UseLogin no#UsePrivilegeSeparation sandbox#PermitUserEnvironment no#Compression delayed#ClientAliveInterval 0#ClientAliveCountMax 3#ShowPatchLevel no#UseDNS yes#PidFile /var/run/sshd.pid#MaxStartups 10:30:100#PermitTunnel no#ChrootDirectory none#VersionAddendum none<p># no default banner path<br>#Banner none<br><span style="color:rgb(232, 250, 0)">Banner</span><span style="color:rgb(250, 0, 136);"> /etc/issue.net</span></p><p># Accept locale-related environment variables</div></p><h4 id="配置终端登录成功后的提示信息"><a href="#配置终端登录成功后的提示信息" class="headerlink" title="配置终端登录成功后的提示信息"></a>配置终端登录成功后的提示信息</h4><p>配置文件位于<span class="tips">/etc/motd</span>，用于在远程和本地终端登录成功后显示提示信息，文件默认为空</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="cut字段提取"><a href="#cut字段提取" class="headerlink" title="cut字段提取"></a>cut字段提取</h4><p><span class="strong">cut [选项] 文件名</span></p><ul><li>-f 列号 &emsp;提取第几列</li><li>-d 分隔符&emsp;按照分隔符识别目标内容中的列(可以识别制表符和其他特殊符号，但不能识别空格)</li></ul><p>从文本或命令输出中提取列内容，grep为提取行内容，因此二者搭配可根据行列精确提取对应内容。cut无法识别以空格为分隔符的内容。</p><div class="shell">如 /etc/passwd 文件中保存了Linux用户信息user1:x:1001:1001::/home/user1:/bin/bashuser2:x:1002:1002::/home/user2:/bin/bashuser3:x:1003:1003::/home/user3:/bin/bash从中提取普通用户的用户名与UIDcat /etc/passwd | grep /bin/bash | grep -v root | cut -d ":" -f 1,31. 普通用户默认使用/bin/bash，通过grep /bin/bash识别2. 通过grep -v root去除root用户,3. 文件使用:为分隔符，使用-d 识别分隔符4. 截取1，3列即用户名和UID</div><h4 id="printf格式化输出"><a href="#printf格式化输出" class="headerlink" title="printf格式化输出"></a>printf格式化输出</h4><p><span class="strong">printf ‘输出类型输出格式’ 输出内容</span></p><p>输出类型</p><ul><li>%ns:&emsp;输出字符串，n指定输出个数</li><li>%ni:&emsp;输出整数，n指定输出个数</li><li>%m.nf:&emsp;输出浮点数，m为总位数，n为小数位数</li></ul><p>输出格式</p><div class="table"><table><thead><tr><th>字符</th><th>作用</th></tr></thead><tbody><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>输出退格键</td></tr><tr><td>\f</td><td>清除屏幕</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平输出制表符</td></tr><tr><td>\v</td><td>垂直输出制表符</td></tr></tbody></table></div><div class="show">示例：# printf '%s\t %s\t %s\t' 6 6 6  //格式输出6 6 6# printf '%s' $(cat test.txt)   //无任何格式输出test.txt文件内容</div><h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p><span class="strong">awk ‘条件1{操作1}&emsp;条件2{操作2} …..’ [文件名]</span></p><p>提取列内容，满足条件1，执行操作1，以此类推。C语言中的大部分数学表达式都可作为条件<br>awk支持printf和print命令，其中print命令会在每行自动添加换行符后再输出，printf需要手动输入\n。</p><div class="show">示例：df -h 命令可以查看当前磁盘使用情况Filesystem      Size  Used Avail Use% Mounted ondevtmpfs        229M     0  229M   0% /devtmpfs           241M     0  241M   0% /dev/shmtmpfs           241M   29M  212M  12% /runtmpfs           241M     0  241M   0% /sys/fs/cgroup/dev/vda1       9.4G  2.6G  6.3G  30% /需求：检测根目录 / 文件占用百分比df -h | grep /dev/vda1 | awk '{print $5}'    //$5代表第5列内容</div><div class="show">示例：文件test.txt中有内容name ID     Gradestu1 1001    65stu2 1002    60stu3 1003    55找出Grade小于60并列出姓名cat test.txt | grep -v name |awk '$3<60 {print $1 "\n"}'1. grep -v name去除第一行内容2. awk '$3<60 {print $1 "\n"}'找出列3小于60的值并返回列1</div><h5 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h5><p>BEGIN作为awk的一种条件，用于在最开始执行操作，如在读取数据之前执行某操作</p><div class="show">示例：awk 'BEGIN{print "first printf"} {print $4 "\t" $5}' test.txt在读取test.txt文件前先输出 first printf ，再输出该文件第4和第5列</div><h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>类似于BEGIN，在最后执行操作</p><div class="show">示例：awk 'BEGIN{print "first printf"}END{print "END!"} {print $4 "\t" $5}' test.txt在读取test.txt文件前先输出 first printf ，再输出该文件第4和第5列,最后输出END!</div><h5 id="常用的内置变量"><a href="#常用的内置变量" class="headerlink" title="常用的内置变量"></a>常用的内置变量</h5><p>awk有自己内置的特殊变量集合，常用变量有：</p><div class="table"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>当前输入文件名</td></tr><tr><td>$数值</td><td>$0为当前整行，$1表示第1个字段，$2表示第2个字段，以此类推</td></tr><tr><td>NR</td><td>当前输入行号，多文件记录递增</td></tr><tr><td>FNR</td><td>与NR类似，多文件记录不递增，每个文件都从1开始</td></tr><tr><td>NF</td><td>当前输入行的字段编号</td></tr><tr><td>FS</td><td>输入字段分隔符</td></tr><tr><td>OFS</td><td>输出字段分隔符，默认为空格</td></tr><tr><td>RS</td><td>输入记录分隔符</td></tr><tr><td>ORS</td><td>输出记录分隔符，默认为换行符</td></tr></tbody></table></div><div class="shell">例：同cut语句的例子，提取所有非root用户用户名和UID可用#cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}' 使用内置变量FS指定输入字段的分隔符，使用BEGIN在读取文件前进行分隔符设置</div><div class="shell">例：如一个通信记录文件liudehua:13212345678:ldh@mail.comwuyanzu:13112345678:wyz@mail.com可以将每一行看作是一个记录，一个记录包含三个字段，由此awk 'BEGIN{FS=":";RS="\n";OFS="\t";ORS="**\n"}{print $1,$2,$3}' awktest.txt 将换行符识别为记录分隔符，并用**\n代替；将：识别为字段分隔符，并用制表符代替。字段必须写为$1,$2,$3格式，否则OFS将不生效ldh   13212345678   ldh@mail.com**wyz    13112345678   wyz@mail.com**    </div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>自定义分隔符必须要写条件BEGIN，使之在读取数据前生效</div><h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p><span class="strong">sed [选项] ‘[操作]’ [文件名]</span><br>进行数据的选取、替换、删除、新增</p><p><strong>常用选项</strong></p><ul><li>-n&emsp;只显示sed处理的行到屏幕上，默认情况下sed会显示所有数据</li><li>-e&emsp;允许使用多条Sed命令处理输入数据</li><li>-i&emsp;sed处理结果应用到文件，不再输出到屏幕</li></ul><p><strong>常用操作</strong></p><ul><li>a&emsp;追加，在当前行之后添加一行或多行，添加多行内容时，在输入一行内容后添加\，并在下一行添加第2行内容，以此类推</li><li>c&emsp;替换，使用c之后的内容替换原数据行，替换多行同上</li><li>i&emsp;插入，在当前行之前插入一行或多行，插入多行同上</li><li>d&emsp;删除指定行</li><li>p&emsp;输出指定行到屏幕</li><li>s&emsp;字符串替换，格式为”行号s/旧字符/新字符/g”</li></ul><div class="show">示例：文件test.txt中有内容name ID     Gradestu1 1001    65stu2 1002    60stu3 1003    55命令sed -n '2p' test.txt显示第2行内容到屏幕，-n只显示sed处理的行，'2'指定行号，'p'输出指定行到屏幕sed '3i stu5 1005 58 \> stu6 1006 66' test.txt在第3行之前插入两行内容，新的test.txt内容为name ID     Gradestu1 1001    65stu5 1005    58stu6 1006    66stu2 1002    60stu3 1003    55以上命令只修改输出到屏幕的内容，修改文件内容需添加-i参数，如：sed -i '3s/58/66/g' test.txt替换第3行内容中的58为66，并将修改应用到文件不添加行号会修改文件中所有匹配到的内容，修改内容可为空，如：sed -i 's/58//g' test.txt</div><h4 id="sort排序处理"><a href="#sort排序处理" class="headerlink" title="sort排序处理"></a>sort排序处理</h4><p><span class="strong">sort [选项] [文件名]</span></p><p>将文件或命令结果进行排序，默认以每行第一个字母为依据，按字母顺序排序</p><ul><li>-f&emsp;忽略大小写</li><li>-n&emsp;按数值大小进行排序</li><li>-r&emsp;反向排序</li><li>-t&emsp;指定分隔符为分段依据</li><li>-k n[,m]&emsp;指定字段为排序依据，不指定m则判断依据为以n字段开始到本行末</li></ul><div class="show">示例：sort /etc/passwd按passwd文件每行首字母进行排序显示sort -n -t ":" -k 3,3 etc/passwd指定字段以:分隔，按第3字段(UID)值大小进行排序显示</div><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="检测文件类型"><a href="#检测文件类型" class="headerlink" title="检测文件类型"></a>检测文件类型</h4><ul><li><span class="strong">test 选项 文件名</span></li><li><span class="strong">[选项 文件名 ]</span><br>返回值在终端上需要用$?查看</li></ul><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-e</td><td>判断文件是否存在</td></tr><tr><td>-d</td><td>判断文件是否存在，且是否为目录文件</td></tr><tr><td>-f</td><td>判断文件是否存在，且是否为为普通文件</td></tr><tr><td>-b</td><td>判断文件是否存在，且是否为块设备文件(如：硬盘设备文件)</td></tr><tr><td>-c</td><td>判断文件是否存在，且是否为字符设备文件(如：鼠标、键盘设备文件)</td></tr><tr><td>-L</td><td>判断文件是否存在，且是否为链接文件</td></tr><tr><td>-p</td><td>判断文件是否存在，且是否为管道文件</td></tr><tr><td>-s</td><td>判断文件是否存在，且是否非空，非空为true</td></tr><tr><td>-S</td><td>判断是否为套接字文件</td></tr></tbody></table></div><h4 id="检测文件权限"><a href="#检测文件权限" class="headerlink" title="检测文件权限"></a>检测文件权限</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-r</td><td>判断文件是否存在，且是否拥有读权限</td></tr><tr><td>-w</td><td>判断文件是否存在，且是否拥有写权限</td></tr><tr><td>-x</td><td>判断文件是否存在，且是否拥有执行权限</td></tr><tr><td>-u</td><td>判断文件是否存在，且是否拥有SUID权限</td></tr><tr><td>-g</td><td>判断文件是否存在，且是否拥有SGID权限</td></tr><tr><td>-k</td><td>判断文件是否存在，且是否拥有SBit权限</td></tr></tbody></table></div><p>检测读(写/执行)权限时，文件所有者、所属组、其他任意拥有读(写/执行)权限都将返回true</p><h4 id="两个文件间的比较"><a href="#两个文件间的比较" class="headerlink" title="两个文件间的比较"></a>两个文件间的比较</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>文件1 -nt 文件2</td><td>判断文件1的修改时间是否比文件2新</td></tr><tr><td>文件1 -ot 文件2</td><td>判断文件1的修改时间是否比文件2旧</td></tr><tr><td>文件1 -et 文件2</td><td>判断文件1和文件2的i节点(Inode)是否一致，即判断是否为同一文件，常用于判断是否为硬链接</td></tr></tbody></table></div><h4 id="两个整数的比较"><a href="#两个整数的比较" class="headerlink" title="两个整数的比较"></a>两个整数的比较</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>整数1 -eq 整数2</td><td>判断整数1与整数2是否相等</td></tr><tr><td>整数1 -ne 整数2</td><td>判断整数1与整数2是否不相等</td></tr><tr><td>整数1 -gt 整数2</td><td>判断整数1是否大于整数2</td></tr><tr><td>整数1 -lt 整数2</td><td>判断整数1是否小于整数2</td></tr><tr><td>整数1 -ge 整数2</td><td>判断整数1是否大于等于整数2</td></tr><tr><td>整数1 -le 整数2</td><td>判断整数1是否小于等于整数2</td></tr></tbody></table></div><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-z 字符串</td><td>判断字符串是否为空</td></tr><tr><td>-z 字符串</td><td>判断字符串是否为非空</td></tr><tr><td>字符串1==字符串2</td><td>判断字符串1和字符串2是否相等</td></tr><tr><td>字符串1!=字符串2</td><td>判断字符串1和字符串2是否不相等</td></tr></tbody></table></div><p>字符串可以使用 $变量名 取值</p><h4 id="多重判断"><a href="#多重判断" class="headerlink" title="多重判断"></a>多重判断</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>判断1 -a 判断2</td><td>逻辑与，判断1和判断2都成立，结果为真</td></tr><tr><td>判断1 -o 判断2</td><td>逻辑或，判断1和判断2任意一个成立，结果为真</td></tr><tr><td>! 判断</td><td>结果取反</td></tr></tbody></table></div><div class="show">示例：a=10[ -n "$a" -a "$a" -gt 20] && echo "true" || echo "false"判断a是否有值，并且判断a是否大于20，都成立输出 true，否则输出 false</div><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><div class="show"><span class="strong">if语句的格式为:</span>   if [条件判断] ;         //;可省略   then     程序体   fi   <span class="tips">或</span>    if [条件判断]       then            条件成立执行      else            条件不成立时执行   fi   <span class="tips">多分支if语句</span>   if [条件判断]       then            条件成立执行   elif [条件判断]      then            条件成立时执行   (.....)   else         上述所有条件不成立时执行   fi</div><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><div class="show"><strong>case语句格式为：</strong>case $变量 in   "值1")            程序1      ;;   "值2")            程序2      ;;     .....     *)         上述条件都不满足，执行该程序     ;; esac</div><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><div class="show"><strong>for语句格式：</strong> for 变量 in 值1 值2 值3.....   do       程序   done</div><pre><code> #! /bin/bash cd /lamp ls *.tar.gz>ls.log for i in $(cat ls.log)   do      tar -zxf $i &>/dev/null   done rm -rf /lamp/ls.log # 功能：将lamp目录下的所有压缩包文件名写入ls.log文件中，再遍历ls.log文件依次解压所有包 </code></pre><div class="show"><strong>for语句格式2：(类似于c语言，注意双括号)</strong>  for((初始值;条件;变量变化))   do     程序   done</div><h4 id="whlie与until循环"><a href="#whlie与until循环" class="headerlink" title="whlie与until循环"></a>whlie与until循环</h4><div class="show"><strong>whlie语法结构:</strong>   whlie [判断语句]      do         程序      done</div><div class="show"><strong>until语法结构：</strong>  until [条件判断]   do     程序   done</div>]]></content>
    
    
    <summary type="html">本文包括Bash历史命令与自定义命令，终端自定义，环境变量配置，shell基本语法，cut、awk、sed命令使用方法</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="shell" scheme="https://shiwei11.github.io/blog/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件与权限</title>
    <link href="https://shiwei11.github.io/blog/2022/01/22/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90/"/>
    <id>https://shiwei11.github.io/blog/2022/01/22/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90/</id>
    <published>2022-01-22T08:26:39.000Z</published>
    <updated>2022-07-14T08:00:31.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><h4 id="常见的文件类型"><a href="#常见的文件类型" class="headerlink" title="常见的文件类型"></a>常见的文件类型</h4><ol><li><span class="tips"><strong>普通文件：</strong></span>最为常见的文件类型，包括纯文本文件(ASCII)，二进制文件(binary)，数据文件(data)等</li><li><span class="tips"><strong>目录：</strong></span>即文件夹，用于包含更多目录和文件</li><li><span class="tips"><strong>块设备文件：</strong></span>将硬盘、光盘等存储设备以文件形式供用户操作</li><li><span class="tips"><strong>字符设备文件：</strong></span>将串行端口的接口设备，如键盘、鼠标等以文件形式供用户操作</li><li><span class="tips"><strong>套接字文件：</strong></span>又称为数据接口文件，用于网络数据连接</li><li><span class="tips"><strong>管道文件：</strong></span>用于解决多个程序同时存取一个文件所造成的错误</li><li><span class="tips"><strong>链接文件：</strong></span>分为硬链接和软链接，类似于快捷方式</li></ol><h4 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h4><h5 id="1-查看目录-list-信息"><a href="#1-查看目录-list-信息" class="headerlink" title="1. 查看目录(list)信息"></a>1. 查看目录(list)信息</h5><p><span class="strong">ls [可选参数] [文件或目录]</span></p><ul><li>-a &emsp;显示所有文件，包括隐藏文件</li><li>-l &emsp;显示详细信息，默认情况下文件大小只以byte显示，命令可以直接写为 ll</li><li>-d &emsp;查看目录信息而非展示目录所含文件</li><li>-h &emsp;常与l参数一起使用，文件大小会被换算为KB、MB等单位</li><li>-i &emsp;查看文件i节点</li></ul><p>如果不指定文件或目录名，操作对象为当前目录</p><div class="show">示例：# ls列出当前目录所含非隐藏文件或文件夹# ll (同ls -l)列出当前目录所含非隐藏文件或文件夹详细信息# ls -ld列出当前目录的详细信息#ls -ldh tmp列出tmp目录的详细信息，并且文件大小会被换算为KB等方便阅读的单位</div><h5 id="2-文件信息详解"><a href="#2-文件信息详解" class="headerlink" title="2. 文件信息详解"></a>2. 文件信息详解</h5><p>使用<span class="tips">ls -l</span>等命令列出文件详细信息，文件信息格式类似于</p><div style="text-align:center;"><span class="tips">&emsp;drwxr-xr-x.  &nbsp;6&nbsp; root&nbsp; root&nbsp; 4.0K &nbsp;Feb&nbsp;  9&nbsp; 11:53&nbsp; home&emsp;</span></div><h5 id="字段一"><a href="#字段一" class="headerlink" title="字段一"></a>字段一</h5><h6 id="第1位"><a href="#第1位" class="headerlink" title="第1位"></a>第1位</h6><p>第1位表示文件类型</p><ul><li>-为普通文件</li><li>d为目录</li><li>l为链接文件</li><li>c为字符设备文件，如：鼠标、键盘设备文件</li><li>b为块设备文件，如：硬盘设备文件</li><li>s为套接字文件，一般用于数据连接，常见于 /var/run目录</li><li>p为管道文件(FIFO)，用于解决多个程序同时存取一个文件所造成的错误</li></ul><h6 id="第2-10位"><a href="#第2-10位" class="headerlink" title="第2-10位"></a>第2-10位</h6><p>3位为一组，分别为文件所有者、所属组、其他用户的读、写、执行权限</p><ul><li>r为可读</li><li>w为可写</li><li>x为可执行</li><li>-为无权限</li></ul><h6 id="第11位-号"><a href="#第11位-号" class="headerlink" title="第11位 .号"></a>第11位 .号</h6><p>.号为安装有SElinux的系统特有，这个点表示该文件带有“SELinux的安全上下文”</p><h5 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h5><p>之后的字段分别表示</p><ul><li>该文件被硬链接调用过的次数</li><li>文件所属用户</li><li>文件所属组</li><li>文件大小</li><li>文件最后一次修改时间，无修改则为创建时间</li><li>文件名</li></ul><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><h5 id="1-创建目录-make-directory"><a href="#1-创建目录-make-directory" class="headerlink" title="1.创建目录(make directory)"></a>1.创建目录(make directory)</h5><p><span class="strong">mkdir [-p] 目录名</span></p><ul><li>使用-p 可以递归创建目录，在不存在的目录下创建新目录</li><li>目录名可以写多个来同时创建多个目录</li></ul><div class="show">示例：# mkdir tmp/test/newdir如果tmp目录下没有test目录，将提示无test目录，此时可以用-p参数# mkdir -p tmp/test/newdir将在tmp下新建test，再在test下新建newdir目录# mkdir newdir1 newdir2 newdir3在当前路径下新建三个目录</div><h5 id="2-切换目录-change-directory"><a href="#2-切换目录-change-directory" class="headerlink" title="2.切换目录(change directory)"></a>2.切换目录(change directory)</h5><p><span class="strong">cd 目录名</span></p><ul><li>目录名可以用<span class="tips"> Tab键 </span>补全</li><li>Linux中使用<span class="tips"> . </span>表示当前目录，<span class="tips"> .. </span>表示上一级目录，可以使用<span class="tips">cd .. </span>返回上一级目录</li></ul><h5 id="3-查看当前路径-print-working-directory"><a href="#3-查看当前路径-print-working-directory" class="headerlink" title="3.查看当前路径(print working directory)"></a>3.查看当前路径(print working directory)</h5><p><span class="strong"> pwd </span><br>显示工作目录的路径</p><h5 id="4-删除空目录-remove-empty-directory"><a href="#4-删除空目录-remove-empty-directory" class="headerlink" title="4.删除空目录(remove empty directory)"></a>4.删除空目录(remove empty directory)</h5><p><span class="strong"> rmdir 目录名 </span><br>系统不允许使用该命令删除有内容的目录</p><h5 id="5-删除文件与目录-remove"><a href="#5-删除文件与目录-remove" class="headerlink" title="5.删除文件与目录(remove)"></a>5.删除文件与目录(remove)</h5><p><span class="strong"> rm [-rf] 文件或目录名</span></p><ul><li>-r&emsp;删除目录需要使用该参数</li><li>-f&emsp;强制删除，不再询问用户确认</li></ul><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>Linux无回收站功能，文件会被直接删除</div><h5 id="5-复制文件或目录-copy"><a href="#5-复制文件或目录-copy" class="headerlink" title="5.复制文件或目录(copy)"></a>5.复制文件或目录(copy)</h5><p><span class="strong"> cp [可选参数] [源文件或目录] [目标目录]</span></p><ul><li>-r &emsp;复制目录</li><li>-p &emsp;保留文件属性，如文件修改时间</li><li>复制文件不需要任何参数，复制目录使用-r</li><li>源文件或目录可以有多个来同时复制多个文件</li><li>复制文件的同时可以将新文件改名<div class="show">示例：# cp /file/test1 /file/test2 /newdir复制文件test1和test2到newdir目录中# cp -p install.log /tem复制install.log文件到tem目录中并保留install.log文件信息(不使用-p参数则文件最后修改时间为执行复制操作的当前时间)# cp -r /usr/dir /tem/newdir复制目录dir到tem目录下并命名为newdir</div></li></ul><h5 id="6-移动文件和修改文件名-move"><a href="#6-移动文件和修改文件名-move" class="headerlink" title="6.移动文件和修改文件名(move)"></a>6.移动文件和修改文件名(move)</h5><p><span class="strong"> mv [源文件或目录] [目标目录]</span></p><ul><li>如果目标目录没有对应名字，则为修改文件名操作</li><li>源文件或目录可以有多个来同时移动多个文件</li></ul><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="1-创建空文件"><a href="#1-创建空文件" class="headerlink" title="1. 创建空文件"></a>1. 创建空文件</h5><p><span class="strong"> touch [文件名]</span></p><ul><li>可以同时创建多个文件，文件名之间用空格隔开</li><li>如果文件名中有空格符，需要使用””<div class="show">示例：# touch file1 file2创建两个文件file1、file2# touch "fi le"创建一个名为fi le的文件</div></li></ul><h5 id="2-查看文件内容"><a href="#2-查看文件内容" class="headerlink" title="2. 查看文件内容"></a>2. 查看文件内容</h5><h6 id="2-1-查看短文件"><a href="#2-1-查看短文件" class="headerlink" title="2.1 查看短文件"></a>2.1 查看短文件</h6><p><span class="strong"> cat [-n] [文件名]</span></p><ul><li>-n &emsp;显示行号<br>从头到尾正常显示文件</li></ul><p><span class="strong"> tac [-n] [文件名]</span><br>cat反写，从尾到头显示文件(文件末行为第一行)</p><h6 id="2-2-查看长文件"><a href="#2-2-查看长文件" class="headerlink" title="2.2 查看长文件"></a>2.2 查看长文件</h6><p><span class="strong"> more [文件名]</span><br>分页显示文件，一般用于查看长文件</p><ul><li>空格或f &emsp;向下翻页</li><li>b     &emsp;&emsp; &emsp;&nbsp;向上翻页</li><li>Enter  &emsp;&emsp;换行</li><li>q或Q &emsp;&emsp;退出</li></ul><p><span class="strong"> less [文件名]</span><br>分页显示文件，一般用于查看长文件，支持关键字搜索</p><ul><li> 空格或f或PageDown&emsp;向下翻页</li><li>b或PageUp&emsp;&emsp;&emsp;&emsp;&emsp;向上翻页</li><li>上下方向键&emsp;&emsp;&emsp;&emsp;&emsp;逐行翻动</li><li>可以使用<span class="tips"> /关键字 </span>进行关键字搜索，使用<span class="tips"> n </span>跳转到下一个高亮显示的关键字</li><li>q或Q &emsp;&emsp;退出</li></ul><h6 id="2-3-仅查看前几行或后几行"><a href="#2-3-仅查看前几行或后几行" class="headerlink" title="2.3 仅查看前几行或后几行"></a>2.3 仅查看前几行或后几行</h6><p><span class="strong"> head [-n 行号] 文件名</span><br>仅仅查看文件前几行，不使用 -n 指定行号，默认显示前10行</p><p><span class="strong"> tail [可选参数] 文件名</span></p><ul><li>-n 行号 &emsp; 仅仅查看文件末几行，不使用 -n 指定行号，默认显示后10行</li><li>-f &emsp;&emsp;&emsp;动态显示文件末尾，常用于查看日志文件实时变更</li></ul><h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><p>软链接：类似于Windows的快捷方式，读取、执行等操作依旧基于源文件，当源文件删除，软链接文件也将失效</p><p>硬链接：相当于复制了一份文件，并且当源文件发生改动，硬链接文件会同步更新，源文件删除，硬链接文件依旧有效</p><p><span class="strong">ln [-s] 源文件 目标文件</span><br> -s 为生成生成软链接，无该参数为生成硬链接</p><div class="show">示例:# ln /etc/issue /tmp/issue.hard为/etc/issue创建硬链接# ln -s /etc/issue /tmp/issue.soft为/etc/issue创建软链接</div><p>二者区别:</p><ul><li>生成的软链接权限都为 rwxrwxrwx，实际权限取决于源文件权限</li><li>硬链接文件 i 节点与源文件相同，软链接不同</li><li>硬链接指向不能跨分区，软链接可以</li><li>不能给目录生成硬链接，软链接可以</li></ul><h3 id="文件与目录权限管理"><a href="#文件与目录权限管理" class="headerlink" title="文件与目录权限管理"></a>文件与目录权限管理</h3><h4 id="权限管理中的参数"><a href="#权限管理中的参数" class="headerlink" title="权限管理中的参数"></a>权限管理中的参数</h4><div class="table"><table><thead><tr><th>符号</th><th>含义</th><th>对文件</th><th>对目录</th></tr></thead><tbody><tr><td>r</td><td>读权限</td><td>可以查看文件内容</td><td>可以列出目录中的内容</td></tr><tr><td>w</td><td>写权限</td><td>可以修改文件内容</td><td>可以在目录中创建、删除文件</td></tr><tr><td>x</td><td>执行权限</td><td>可以执行文件</td><td>可以进入目录</td></tr><tr><td>-</td><td>无权限</td><td>无权限</td><td>无权限</td></tr></tbody></table></div><p><span class="tips">删除某个文件需要对包含该文件的母目录拥有w权限，对文件拥有w权限只能修改文件内容而不能进行删除</span></p><h4 id="更改权限-change-the-permissions-mode-of-a-file"><a href="#更改权限-change-the-permissions-mode-of-a-file" class="headerlink" title="更改权限(change the permissions mode of a file)"></a>更改权限(change the permissions mode of a file)</h4><p><span class="strong">chmod [-R] [{ugoa}{+-=}{rwx}] [文件名或目录名]</span><br>只有root用户与文件所有者才能修改文件的权限</p><ul><li><p>-R&emsp;递归修改，修改目录及其所有子文件的权限</p></li><li><p>u为文件所有者，g为文件所属组，o为其他用户，a为所有用户</p></li><li><p>+为添加权限，-为取消权限，=为修改权限为等号所指</p></li><li><p>同时修改ugoa中的多个可以使用 , 号分隔</p><div class="show">示例：# chmod g+w,o-r file添加文件所属组写权限，取消文件其他用户的读权限# chmod a=rwx file将所有人权限都修改为 rwx</div>可以将rwx写为mode值之和<p><span class="strong">chmod [mode] [文件名或目录名]</span></p></li><li><p>r 值为4</p></li><li><p>w 值为2</p></li><li><p>x 值为1</p></li><li><p>rwx值为7，rw-值为6，r-x值为5依此类推</p><div class="show">示例：# chmod 640 index.html修改权限为rw-r-----</div></li></ul><h4 id="更改文件所有者-change-file-ownership"><a href="#更改文件所有者-change-file-ownership" class="headerlink" title="更改文件所有者(change file ownership)"></a>更改文件所有者(change file ownership)</h4><p><span class="strong">chown [用户] [文件名或目录名]</span></p><p><span class="tips">只有root用户才能更改文件所有者</span></p><h4 id="更改文件所属组-change-file-group-ownership"><a href="#更改文件所属组-change-file-group-ownership" class="headerlink" title="更改文件所属组(change file group ownership)"></a>更改文件所属组(change file group ownership)</h4><p><span class="strong">chgrp [用户组] [文件名或目录名]</span></p><p><span class="tips">只有root用户才能更改文件所属组</span></p><h4 id="更改新建文件时的默认权限设置-the-user-file-creation-mask"><a href="#更改新建文件时的默认权限设置-the-user-file-creation-mask" class="headerlink" title="更改新建文件时的默认权限设置(the user file-creation mask)"></a>更改新建文件时的默认权限设置(the user file-creation mask)</h4><ul><li><span class="strong">umask -S</span>&emsp;显示新建目录时权限的默认设置</li><li><span class="strong">umask</span>&emsp;显示默认权限值</li><li><span class="strong">umask  权限值</span>&emsp;修改默认权限</li></ul><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>新建的文件相较于新建的目录所有用户会少一个x权限，这是因为Linux会取消新建文件的可执行权限以防止危害系统的可执行程序运行</div><div class="show">root执行umask显示默认权限值一般为0022(普通用户为0002)，第一位0代表特殊权限，022为默认的权限与777权限异或后的权限值    777 rwx rwx rwx    022 --- -w- -w-  ===============    755 rwx r-x r-x(默认权限)因此需要修改默认权限时，需要先异或操作计算出权限值，如想把默认权限改为rwx --- ---，则先计算权限值    777 rwx rwx rwx    700 rwx --- ---  =================    077 --- rwx rwx然后执行umask 077即可，同样，如果创建的是一个文件，Linux会在默认权限基础上取消所有用户的x权限</div><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><h4 id="文件查找-1"><a href="#文件查找-1" class="headerlink" title="文件查找"></a>文件查找</h4><p>文件查找会占用大量的系统资源，尽量避免在系统使用高峰期使用文件查找命令，文件查找范围应该尽可能小。</p><h5 id="1-根据文件名查找"><a href="#1-根据文件名查找" class="headerlink" title="1. 根据文件名查找"></a>1. 根据文件名查找</h5><p><span class="strong">find [查找路径] [参数] [文件名]</span></p><ul><li>-name&emsp;根据文件名查找</li><li>-iname&emsp;根据文件名查找(文件名不区分大小写)</li><li>搜索范围应尽可能小，尽量避免在根目录下搜索</li><li>只使用文件名为精确搜索，可以使用通配符(*匹配任意数量字符，一个?匹配一个字符)来模糊查找<div class="show">示例:# find /etc -name init在/etc目录下查找init文件# find /etc -name *init*在/etc目录下查找所有文件名带init的文件# find /etc -name init???在/etc目录下查找所有文件名init开头，后面跟3个字符的文件</div></li></ul><h5 id="2-根据文件大小查找"><a href="#2-根据文件大小查找" class="headerlink" title="2. 根据文件大小查找"></a>2. 根据文件大小查找</h5><p><span class="strong">find [查找路径] [参数] [文件大小]</span></p><ul><li>-size &emsp;根据文件大小查找</li><li>文件大小中，可以使用+表示大于，-表示小于，直接写数值表示等于<div class="show">示例:# find / -size +100M查找服务器中大于100MB的文件</div></li></ul><h5 id="3-根据文件所有者、所属组查找"><a href="#3-根据文件所有者、所属组查找" class="headerlink" title="3. 根据文件所有者、所属组查找"></a>3. 根据文件所有者、所属组查找</h5><p><span class="strong">find [查找路径] [参数] [用户名或组名]</span></p><ul><li>-user &emsp;根据根据文件所属用户查找</li><li>-group&emsp;根据文件所属组查找<div class="show">示例:# find /home -user shw查找/home目录下属于shw用户的文件</div></li></ul><h5 id="4-根据时间属性查找"><a href="#4-根据时间属性查找" class="headerlink" title="4. 根据时间属性查找"></a>4. 根据时间属性查找</h5><p><span class="strong">find [查找路径] [参数] [时间]</span></p><ul><li>-amin &emsp;根据根据文件访问时间</li><li>-cmin &emsp;根据文件属性被修改时间</li><li>-mmin &emsp;根据文件内容被修改时间</li><li>时间参数中，使用+表示超过该时间范围，-表示小于该时间内，直接写数值表示等于<div class="show">示例:# find /etc -amin -5查找/etc目录下5分钟内被访问过的所有文件</div></li></ul><h5 id="5-根据文件类型查找"><a href="#5-根据文件类型查找" class="headerlink" title="5. 根据文件类型查找"></a>5. 根据文件类型查找</h5><p><span class="strong">find -type [文件类型]</span></p><ul><li>f &emsp;文件</li><li>d &emsp;目录</li><li>l &emsp;链接文件<div class="show">示例:# find /etc -type f查找/etc目录下的所有普通文件</div></li></ul><h5 id="6-多个条件同时查找"><a href="#6-多个条件同时查找" class="headerlink" title="6. 多个条件同时查找"></a>6. 多个条件同时查找</h5><p>如果需要查找同时满足多个条件的文件，可以添加下面的参数</p><ul><li>-a &emsp;两个条件同时满足</li><li>-o &emsp;两个条件任意满足一个<div class="show">示例:# find /etc -size +100MB -a -size -200MB查找大于100MB而小于200MB的文件</div></li></ul><h5 id="7-对找到文件的执行其他命令"><a href="#7-对找到文件的执行其他命令" class="headerlink" title="7. 对找到文件的执行其他命令"></a>7. 对找到文件的执行其他命令</h5><p>如果在找到文件后需要对其进行相应操作，可以添加下述命令</p><ul><li>-exec 命令 {}; &emsp;找到文件后直接执行命令</li><li>-ok 命令 {}; &emsp;找到文件后会每个文件逐一询问是否执行命令<div class="show">示例:# find /etc -name init* -a -type f -exec ls -l {} \;找到/etc目录下所有init开头的文件并列出具体文件信息# find /home -size +100MB -a -user shw -ok rm {} \;找到/home目录下属于shw用户且大于100MB的文件，然后依次询问是否删除找到的文件</div></li></ul><h5 id="根据i节点查找"><a href="#根据i节点查找" class="headerlink" title="根据i节点查找"></a>根据i节点查找</h5><p><span class="strong">find [查找路径] -inum i节点值</span><br>在知道某文件i节点值的情况下根据i节点查找，如：用于查找某个文件的硬链接(文件i节点值与文件硬链接i节点值相同)</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>locate为一个文件查找工具，可以从yum源安装<br>find命令为在指定目录下遍历查找，会占用大量系统资源，而且查找速度较慢，locate会建立文件资料库，然后在资料库中查找，反应速度快。<br><span class="strong">locate [-i] 文件名</span></p><ul><li>-i&emsp;不区分大小写</li><li>locate会定期更新资料库，但实时新建的文件可能会找不到，可以在root下使用 updatedb 命令手动更新资料库</li><li>locate 不会将/tmp等临时缓存文件收录到资料库中，因此临时文件使用locate找不到</li></ul><h3 id="查找命令所在路径"><a href="#查找命令所在路径" class="headerlink" title="查找命令所在路径"></a>查找命令所在路径</h3><ul><li><span class="strong">which 命令</span>&emsp;查找命令所在路径，同时可以查看命令的别名</li><li><span class="strong">whereis 命令</span>&emsp;查找命令所在路径，同时可以查看命令帮助文档所在路径<div class="show">示例:# which rmLinux返回:alias rm='rm -i'   /usr/bin/rm查看rm命令所在路径，rm -i为rm命令全写#whereis rmLinux返回:rm: /usr/bin/rm /usr/share/man/man1/rm.1.gz返回信息为rm命令所在路径和rm命令帮助文档所在路径</div></li></ul><h3 id="查找文件中的某个内容"><a href="#查找文件中的某个内容" class="headerlink" title="查找文件中的某个内容"></a>查找文件中的某个内容</h3><p><span class="strong">grep [参数] [搜索的字符串] [文件]</span></p><ul><li>-i &emsp;不区分大小写</li><li>-v &emsp;排除指定字符串<br>找到或排除字符串所在行，然后输出内容<div class="show">示例:# grep man /etc/file找到/etc/file文件中含有man的行并输出# grep -v ^# /etc/inittab显示/etc/inittab中除了#开头的所有行内容(#开头的内容为被注释了的内容，不想看注释)</div></li></ul><h3 id="查看帮助-manual"><a href="#查看帮助-manual" class="headerlink" title="查看帮助 (manual)"></a>查看帮助 (manual)</h3><h4 id="1-查看完整帮助man"><a href="#1-查看完整帮助man" class="headerlink" title="1. 查看完整帮助man"></a>1. 查看完整帮助man</h4><p><span class="strong">man [命令或配置文件]</span></p><ul><li>查看配置文件的帮助时，直接写文件名，不能加上文件路径，使用文件路径会直接显示文件内容而不是该配置文件的使用说明</li><li>对于命令，man 有帮助级别(通常为0-9)，可以使用 <span class="tips">whereis 命令</span>查看该命令在man目录下有几个级别，如果有级别，可以使用<span class="tips">man [级别] [命令]</span>来查看对应帮助。如：1为通常为命令的帮助，5通常为命令对应说明文档的帮助。即：使用<span class="tips">man 命令</span>和<span class="tips">man 1 命令</span>为查看命令的帮助，<span class="tips">man 5 命令</span>为查看目录说明文档的帮助(具体级别视命令而定)</li></ul><h4 id="2-查看简短帮助"><a href="#2-查看简短帮助" class="headerlink" title="2. 查看简短帮助"></a>2. 查看简短帮助</h4><ul><li><span class="strong">what 命令</span>&emsp;只显示命令帮助文档中NAME部分的内容</li><li><span class="strong">apropos 配置文件</span>&emsp;简短查看配置文件作用</li></ul><h4 id="3-查看命令的可选参数选项"><a href="#3-查看命令的可选参数选项" class="headerlink" title="3. 查看命令的可选参数选项"></a>3. 查看命令的可选参数选项</h4><p>只查看命令的可选参数选项，不需要查看命令完整帮助信息</p><p><span class="strong">命令 --help</span></p><h4 id="4-查看shell内置命令"><a href="#4-查看shell内置命令" class="headerlink" title="4. 查看shell内置命令"></a>4. 查看shell内置命令</h4><p>有些命令是bash(shell)内置命令而不是Linux的命令，使用上述命令查看不到帮助，可以使用</p><p><span class="strong">help 命令</span></p><h3 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h3><h4 id="文件的压缩与解压-gz格式"><a href="#文件的压缩与解压-gz格式" class="headerlink" title="文件的压缩与解压(.gz格式)"></a>文件的压缩与解压(.gz格式)</h4><p>压缩格式为<span class="tips">.gz</span>，与windows不同，下述命令只能压缩与解压缩文件，不能处理文件夹，并且压缩完只保留压缩文件，不保留原文件</p><ul><li><span class="strong">gzip 文件名</span>&emsp;压缩(GUN zip)</li><li><span class="strong">gunzip 文件名</span>&emsp;解压缩(GUN unzip)</li></ul><h4 id="文件夹的打包、压缩与解压-tar-gz格式"><a href="#文件夹的打包、压缩与解压-tar-gz格式" class="headerlink" title="文件夹的打包、压缩与解压(.tar.gz格式)"></a>文件夹的打包、压缩与解压(.tar.gz格式)</h4><h5 id="打包与压缩"><a href="#打包与压缩" class="headerlink" title="打包与压缩"></a>打包与压缩</h5><p><span class="strong">tar [参数] [压缩后文件名] [压缩目录]</span></p><p>打包是将多个文件打包为一个文件，文件总大小不变，打包后的文件格式为<span class="tips">.tar</span>，对包可以用<span class="strong">gzip</span>命令压缩，生成<span class="tips">.tar.gz</span>格式的压缩包文件，而<span class="strong">tar</span>命令可以将打包压缩同时处理，打包压缩后的文件名可以不写.tar.gz等后缀，但不方便用户识别。</p><ul><li>-c &emsp;打包</li><li>-v &emsp;显示详细信息</li><li>-f &emsp;指定文件名(该参数必须)</li><li>-z &emsp;打包后压缩(需要和c参数一起使用)<div class="show">示例:# tar -cvf test1.tar test1打包test1文件夹中文件为test1.tar文件，并显示详细信息# tar -zcf test.tar.gz test1打包并压缩test1文件夹为test.tar.gz</div></li></ul><h5 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h5><p><span class="strong">tar [参数] [解压缩的文件]</span></p><ul><li>-x &emsp;解包</li><li>-v &emsp;显示详细信息</li><li>-f &emsp;指定解压缩的文件(该参数必须)</li><li>-z &emsp;解包后解压缩(需要和x参数一起使用)<p>最常用的是解压一个.tar.gz文件，因此大多数情况下-zxf为必用参数</p><div class="show">示例:# tar -zxvf test.tar.gz 解压缩test.tar.gz文件，并显示详细信息</div></li></ul><h4 id="zip格式的压缩与解压"><a href="#zip格式的压缩与解压" class="headerlink" title=".zip格式的压缩与解压"></a>.zip格式的压缩与解压</h4><p><span class="strong">zip [选项] [-r] [压缩后文件名] [压缩文件或目录]</span></p><ul><li>-r&emsp;压缩目录<p>.zip格式为Linux和windows通用格式，zip命令会保留原文件，并且一个命令就可以处理文件与文件夹</p></li></ul><p><span class="strong">unzip [解压的文件名]</span></p><p>解压文件</p><h4 id="bz2、-tar-bz2格式的压缩与解压"><a href="#bz2、-tar-bz2格式的压缩与解压" class="headerlink" title=".bz2、.tar.bz2格式的压缩与解压"></a>.bz2、.tar.bz2格式的压缩与解压</h4><h5 id="1-压缩"><a href="#1-压缩" class="headerlink" title="1. 压缩"></a>1. 压缩</h5><h6 id="对文件-格式为-bz2"><a href="#对文件-格式为-bz2" class="headerlink" title="对文件(格式为.bz2)"></a>对文件(格式为.bz2)</h6><p><span class="strong">bzip2 [参数] [-k][文件]</span></p><ul><li>-k &emsp;压缩后保留原文件</li></ul><h6 id="对文件夹-格式为-tar-bz2"><a href="#对文件夹-格式为-tar-bz2" class="headerlink" title="对文件夹(格式为.tar.bz2)"></a>对文件夹(格式为.tar.bz2)</h6><p><span class="strong">tar -jcf [压缩后文件名] [压缩目录]</span></p><p>即将tar中的z参数改为j参数就是压缩为.tar.bz2格式</p><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h5><h6 id="对文件-格式为-bz2-1"><a href="#对文件-格式为-bz2-1" class="headerlink" title="对文件(格式为.bz2)"></a>对文件(格式为.bz2)</h6><p><span class="strong">bunzip2 [-k] [解压文件]</span></p><ul><li>-k &emsp;解压缩后保留原文件</li></ul><h6 id="对文件夹-格式为-tar-bz2-1"><a href="#对文件夹-格式为-tar-bz2-1" class="headerlink" title="对文件夹(格式为.tar.bz2)"></a>对文件夹(格式为.tar.bz2)</h6><p><span class="strong">tar -jxf [解压文件]</span></p><p>同样将tar中的z参数改为j参数就是解压.tar.bz2格式</p><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><p>ACL权限用于给文件所有者(u)、所属组(g)、其他用户(o)以外的用户提供权限</p><h4 id="查看ACL权限"><a href="#查看ACL权限" class="headerlink" title="查看ACL权限"></a>查看ACL权限</h4><p><span class="strong">getfacl 文件名</span></p><div class="show">设置了ACL权限的文件，使用 ls -l 命令查看文件时权限标识后带有+号，如：-rw-r-xr--+ 1 root root  174 Jan 23 18:55 index.html使用 getfacl 命令查看具体ACL权限，会多一组拥有ACL权限的 user或group 并标明用户名或组名，如：# file: index.html# owner: root# group: rootuser::rw-user:sw:r-x     //sw用户拥有ACL权限r-xgroup::r--mask::r-xother::r--</div><h4 id="设置mask权限"><a href="#设置mask权限" class="headerlink" title="设置mask权限"></a>设置mask权限</h4><p>mask权限用于指定最大的权限，防止给与用户ACL权限时权限过大。用户最终得到的权限是ACL权限于mask权限相与以后得到的权限。<br><span class="strong">setfacl -m m:组名:权限 文件名</span></p><h4 id="设置ACL权限"><a href="#设置ACL权限" class="headerlink" title="设置ACL权限"></a>设置ACL权限</h4><p><span class="strong">setfacl 参数 文件名</span></p><ul><li>-m &emsp;设定ACL权限</li><li>-x &emsp;删除指定ACL权限</li><li>-b &emsp;删除文件所有ACL权限</li><li>-d &emsp;设定默认ACL权限</li><li>-k &emsp;删除默认ACL权限</li><li>-R &emsp;递归设置ACL权限</li></ul><h5 id="1-设置ACL权限"><a href="#1-设置ACL权限" class="headerlink" title="1. 设置ACL权限"></a>1. 设置ACL权限</h5><ul><li><span class="strong">setfacl -m u:用户名:权限 文件名</span>给用户设置ACL权限</li><li><span class="strong">setfacl -m u:用户名:权限 -R 文件名</span>递归设置，给用户设置目录下所有子文件的ACL权限</li><li><span class="strong">setfacl -m g:组名:权限 文件名</span>给组设置ACL权限</li><li><span class="strong">setfacl -m g:组名:权限 -R 文件名</span>递归设置，给组设置目录下所有子文件的ACL权限<div class="show">示例：setfacl -m u:lm:r-x index.html给与用户lm对index.html的读和执行权限</div></li></ul><h5 id="2-删除ACL权限"><a href="#2-删除ACL权限" class="headerlink" title="2. 删除ACL权限"></a>2. 删除ACL权限</h5><p><span class="strong">setfacl -x [u或g]:[用户名或组名] 文件名</span></p><p>删除对应用户或组的ACL权限</p><p><span class="strong">setfacl -b 文件名</span></p><p>删除对应文件所有ACL权限</p><h5 id="3-设置默认ACL权限"><a href="#3-设置默认ACL权限" class="headerlink" title="3. 设置默认ACL权限"></a>3. 设置默认ACL权限</h5><p>设置默认ACL权限的作用是给父目录设置ACL权限后，父目录中创建的所有子文件都会继承父目录的ACL权限，但执行命令前的文件不会拥有权限。与递归设置的区别是，递归设置的ACL权限只会给当前已经存在的子目录给与ACL权限，新建的后来文件不会拥有权限。</p><ul><li><span class="strong">setfacl -m d:u:用户名:权限 文件名</span>设置默认ACL权限</li><li><span class="strong">setfacl -m k:u:用户名:权限 文件名</span> 删除默认ACL权限设置</li></ul><p>可以添加-R参数递归给子目录的子文件也设置默认ACL权限，但执行命令前创建的文件依旧不会有ACL权限。</p><p><span class="strong">setfacl -m d:u:用户名:权限 -R 文件名</span></p><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><h4 id="1-SetUID权限"><a href="#1-SetUID权限" class="headerlink" title="1. SetUID权限"></a>1. SetUID权限</h4><p>用于执行某个程序时赋予该用户文件所有者身份，程序运行完毕收回所有者身份。如：普通用户对 /etc/shadow 文件的权限为 0 ，即无法查看无法修改，但通过执行passwd命令，普通用户会获得临时的所有者即root权限，可以修改密码，</p><ul><li><span class="tips">只有可执行的二进制程序才能设置SUID权限</span></li><li><span class="tips">要求命令执行者要对该程序拥有x(执行)权限</span></li><li>命令执行者在运行该程序时会临时获得文件所有者身份</li><li>SUID权限只在该程序执行时有效，程序执行完毕权限失效</li></ul><h5 id="设置SUID权限"><a href="#设置SUID权限" class="headerlink" title="设置SUID权限"></a>设置SUID权限</h5><p>4代表SUID</p><ul><li><span class="strong">chmod 4755 文件名</span>&emsp;755为权限值可任意，但要保证用户有x权限</li><li><span class="strong">chmod u+s 文件名</span></li></ul><h5 id="取消SUID权限"><a href="#取消SUID权限" class="headerlink" title="取消SUID权限"></a>取消SUID权限</h5><p><span class="strong">chmod 755 文件名</span></p><p><span class="strong">chmod u-s 文件名</span></p><div class="show">说明：当设置SUID权限后，该文件权限标识中所有者的可执行权限x会被修改为s-rwsr--r--  1 root root 174 Jan 23 18:56 file如果该标识为大写S，则说明文件设置了SUID权限，但用户没有x权限，SUID权限无法生效，权限报错</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>该命令容易造成权限滥用，Linux中默认只有/usr/bin/passwd 等少数文件有SUID权限，禁止为 vi 等命令设置该权限，否则所有用户在使用 vi 命令时都将获得 root 权限。应定时检查系统中是否有除默认以外的文件设置了SUID权限</div><h4 id="2-SetGID权限"><a href="#2-SetGID权限" class="headerlink" title="2. SetGID权限"></a>2. SetGID权限</h4><p>对文件</p><ul><li>只有可执行的二进制程序才能设置SGID权限</li><li>要求命令执行者要对该程序拥有x(执行)权限</li><li>命令执行者在运行该程序时，组身份会临时升为文件所属组身份</li><li>SGID权限只在该程序执行时有效，程序执行完毕权限失效</li></ul><div class="show">说明：当设置SGID权限后，该文件权限标识中所属组的可执行权限x会被修改为s，如 locate 命令的权限为-rwx--s--x  1 root root 174 Jan 23 18:56 usr/bin/locate</div><p>对目录</p><ul><li>要求用户必须拥有此目录的 r 和 x 权限</li><li>普通用户进入该目录时，用户的组会升为此目录的所属组</li><li>如果用户对目录有w权限，新建文件的默认组 将变为目录的所属组，而非创建者的所属组</li></ul><h5 id="设置SGID权限"><a href="#设置SGID权限" class="headerlink" title="设置SGID权限"></a>设置SGID权限</h5><p>2代表SGID</p><ul><li><span class="strong">chmod 2755 文件名</span>&emsp;755为权限值可任意，若为文件要保证拥有x权限，为目录则拥有r和x权限</li><li><span class="strong">chmod g+s 文件名</span></li></ul><h5 id="取消SGID权限"><a href="#取消SGID权限" class="headerlink" title="取消SGID权限"></a>取消SGID权限</h5><p><span class="strong">chmod 755 文件名</span></p><p><span class="strong">chmod g-s 文件名</span></p><h4 id="3-Sticky-BIT-粘着位权限"><a href="#3-Sticky-BIT-粘着位权限" class="headerlink" title="3. Sticky BIT(粘着位权限)"></a>3. Sticky BIT(粘着位权限)</h4><ul><li>只对目录有效</li><li><span class="tips">要求用户对目录拥有w和x权限</span></li><li>没有设置粘着位权限时，用户拥有w权限后可以删除目录下的所有文件，包括其他用户创建的文件。设置粘着位后，用户只能删除自己创建的文件，root用户不受此规则影响</li></ul><div class="show">说明：当设置SBIT权限后，文件权限标识中其他用户的可执行权限x会被修改为t，如drwxrwxrwt  1 root root 174 Jan 23 18:56 /dir/</div><h5 id="设置SBIT权限"><a href="#设置SBIT权限" class="headerlink" title="设置SBIT权限"></a>设置SBIT权限</h5><p>1代表SBID</p><ul><li><span class="strong">chmod 1755 目录名</span>&emsp;755为权限值可任意，要保证用户拥有w和x权限</li><li><span class="strong">chmod o+t 目录名</span></li></ul><h5 id="取消SBIT权限"><a href="#取消SBIT权限" class="headerlink" title="取消SBIT权限"></a>取消SBIT权限</h5><p><span class="strong">chmod 755 目录名</span></p><p><span class="strong">chmod o-t 目录名</span></p><h3 id="文件系统属性权限chattr权限"><a href="#文件系统属性权限chattr权限" class="headerlink" title="文件系统属性权限chattr权限"></a>文件系统属性权限chattr权限</h3><p><span class="strong">chattr&emsp;[+-=][i或a]&emsp;文件或目录名</span></p><ul><li><p>+为增加权限，-为删除权限，=为设置为指定权限</p></li><li><p>i &emsp;对文件：不允许删除、改名、添加内容或修改文件内容操作<br>&emsp;对目录：只能修改目录下文件的内容，不允许新建和删除文件<br><span class="tips">对root用户生效！</span></p></li><li><p>a &emsp;对文件：只能添加新内容，不能删除、修改已有内容(并且只允许使用echo添加，不能使用vi等编辑器添加)<br>&emsp;对目录：只能新建和修改文件，不能删除文件<br><span class="tips">对root用户生效！</span></p></li></ul><div class="show">示例：chattr +i test给文件test添加i属性，锁定文件，防止误操作</div><h5 id="查看chattr权限方法"><a href="#查看chattr权限方法" class="headerlink" title="查看chattr权限方法"></a>查看chattr权限方法</h5><p>该权限无法使用 ls 命令查看，而需要使用：</p><p><span class="strong">lsattr [参数] 文件名</span></p><ul><li>-a 显示所有文件和目录</li><li>-d 若为目录，则显示目录属性，而非子文件属性</li></ul><h3 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h3><p>由root用户赋予普通用户权限，使普通用户可以使用原本只有root用户才能执行的系统命令。能赋予的只能是系统命令！</p><h5 id="1-添加赋予的命令"><a href="#1-添加赋予的命令" class="headerlink" title="1. 添加赋予的命令"></a>1. 添加赋予的命令</h5><p>执行 <span class="strong">visudo</span> 命令，执行该命令实际是修改<span class="tips"> /etc/sudoers </span>文件，在文件中添加格式为<span class="tips">用户名 被管理主机地址=(赋予的身份) 授权命令的绝对路径</span> 的内容，赋予组相关权限的格式类似</p><div class="show">举例：  root    ALL=(ALL)       ALL   //文件自带，给root授予的权限  wj      ALL=/sbin/shutdown -r now//用户名  被授权的主机=被授予可以使用的命令，被授权主机指被授予的命令可以在哪些主机上使用  %wheel  ALL=(ALL)       ALL   //文件自带  //若要为组添加，组名前使用%号</div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>授予命令越简单，权限越大，因此命令应该尽量详细</div><h5 id="2-查看当前用户可以使用sudo权限执行的命令"><a href="#2-查看当前用户可以使用sudo权限执行的命令" class="headerlink" title="2. 查看当前用户可以使用sudo权限执行的命令"></a>2. 查看当前用户可以使用sudo权限执行的命令</h5><p><span class="strong">sudo -l</span></p><p>执行命令后Linux系统会要求输入当前账户密码</p><h5 id="3-使用sudo权限执行命令"><a href="#3-使用sudo权限执行命令" class="headerlink" title="3. 使用sudo权限执行命令"></a>3. 使用sudo权限执行命令</h5><p><span class="strong">sudo 被授予的命令</span></p><div class="show">wj用户被授予使用shutdown -r now命令后，可以使用sudo shutdown -r now 重启系统了</div><h3 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h3><h4 id="文件系统空间"><a href="#文件系统空间" class="headerlink" title="文件系统空间"></a>文件系统空间</h4><h5 id="1-显示磁盘分区大小"><a href="#1-显示磁盘分区大小" class="headerlink" title="1.显示磁盘分区大小"></a>1.显示磁盘分区大小</h5><p><span class="strong">df [参数] [挂载点]</span></p><ul><li>-a &emsp;显示所有文件系统信息，包括特殊文件系统</li><li>-h &emsp;将磁盘大小单位换算为KB、MB等单位</li><li>-T &emsp;显示文件系统类型</li><li>-m &emsp;以MB为单位显示容量</li><li>-k &emsp;以KB为单位显示容量，默认值</li></ul><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>df命令会统计包括一些磁盘碎片在内的空间，而该类空间是被程序占用后释放的碎片空间，需要Linux整理后才能使用，因此df命令统计结果也往往比du命令统计结果大，但更能正确反映系统可用的空间大小</div><h5 id="2-显示目录或文件大小"><a href="#2-显示目录或文件大小" class="headerlink" title="2. 显示目录或文件大小"></a>2. 显示目录或文件大小</h5><p><span class="strong">du [参数] [目录或文件名]</span></p><ul><li>-a &emsp;显示每个子目文件的大小</li><li>-h &emsp;将文件大小单位换算为KB、MB等单位</li><li>-s &emsp;只统计总大小，不列出子目录和文件</li></ul><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>ls命令只统计目录下一级子文件和子目录文件信息大小，而不统计子目录下属文件大小，du命令更能准确统计出子文件、子目录和子目录所含文件的数据大小</div><h4 id="文件系统修复"><a href="#文件系统修复" class="headerlink" title="文件系统修复"></a>文件系统修复</h4><p><span class="strong">fsck [参数] 分区设备名</span></p><ul><li>-a &emsp;不显示用户提示，自动修复文件系统</li><li>-y &emsp;功能同-a，部分文件系统仅支持-y</li></ul><h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><p><span class="strong">mount [-l]</span>查询已经挂载的设备，-l显示卷标</p><p><span class="strong">mount -a</span>根据配置文件 /etc/fstab 自动挂载</p><h5 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h5><p><span class="strong">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span></p><ul><li>-t 文件系统：挂载指定文件系统，如 ext4、iso9660</li><li>-L 卷标名：自定义卷标的名字</li><li>-o 特殊选项：指定挂载的额外选项，几个常用的选项：<div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>atime/noatime</td><td>访问分区文件时是否更新文件访问时间</td></tr><tr><td>exec/noexec</td><td>是否允许文件系统中的可执行程序可以运行，默认为exec允许</td></tr><tr><td>user/nouser</td><td>是否允许普通用户挂载文件系统，默认为不允许</td></tr><tr><td>remount</td><td>重挂载已经挂载的文件系统，一般用于修改特殊权限后重挂载</td></tr></tbody></table></div></li></ul><div class="show">示例：# mount -o remount,noexec /home/禁止 /home/分区中的所有可执行程序执行，包括root用户</div><h5 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h5><div class="table"><table><thead><tr><th>硬件</th><th>设备文件名</th></tr></thead><tbody><tr><td>IDE硬盘</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/USB硬盘</td><td>/dev/sd[a-p]</td></tr><tr><td>光驱</td><td>/dev/cdrom 或 /dev/sr0</td></tr><tr><td>软盘</td><td>/dev/fd[0-1]</td></tr><tr><td>打印机(25针)</td><td>/dev/lp[0-2]</td></tr><tr><td>打印机(USB)</td><td>/dev/usb/lp[0-15]</td></tr><tr><td>鼠标</td><td>/dev/mouse</td></tr></tbody></table></div><h5 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h5><p>为方便文件查找，一般将光盘挂载于根目录下的 /media  ，U盘挂载于/mnt目录下，iso9660为光盘默认文件系统，因此-t iso9660 可以省略</p><p><span class="strong">mount -t iso9660 /dev/cdrom /media</span></p><h5 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h5><ol><li><p><span class="strong">fdisk -l</span>查看U盘设备文件名</p></li><li><p><span class="strong">mount -t &emsp;文件系统 &emsp;/dev/U盘设备文件名 &emsp;/mnt</span></p></li></ol><p>linux默认不支持NTFS文件系统(大部分移动硬盘设备使用NTFS文件系统)，但可以通过插件提供支持</p><h5 id="卸载设备"><a href="#卸载设备" class="headerlink" title="卸载设备"></a>卸载设备</h5><p><span class="strong">umount 设备文件名或挂载点目录名</span></p>]]></content>
    
    
    <summary type="html">Linux文件与目录的相关操作，包括文件系统挂载，文件查找，命令查找，文件压缩与解压，文件rwx权限、ACL权限、SetUID权限、Sticky BIT权限、charttr权限、sudo权限的修改</summary>
    
    
    
    
    <category term="File" scheme="https://shiwei11.github.io/blog/tags/File/"/>
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务与系统资源管理</title>
    <link href="https://shiwei11.github.io/blog/2022/01/20/Linux%E6%9C%8D%E5%8A%A1%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://shiwei11.github.io/blog/2022/01/20/Linux%E6%9C%8D%E5%8A%A1%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</id>
    <published>2022-01-20T04:00:00.000Z</published>
    <updated>2022-08-03T17:34:56.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h4 id="ping-测试网络"><a href="#ping-测试网络" class="headerlink" title="ping 测试网络"></a>ping 测试网络</h4><p><span class="strong">ping [-c 次数] IP地址</span></p><ul><li>-c &emsp;指定发送次数</li></ul><p>测试网络是否联通，如果不添加-c参数，则会无终止进行ping操作，直至 ctrl+c 停止</p><h4 id="ifconfig-网卡设置"><a href="#ifconfig-网卡设置" class="headerlink" title="ifconfig 网卡设置"></a>ifconfig 网卡设置</h4><p><span class="strong">ifconfig [网卡名称] [IP地址]</span></p><p>查看和设置网卡</p>  <div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>直接使用 ifconfig 为查看网卡，不同发行版的Linux网卡标识不同，Centos7中网卡名以eth+数字标识，其中lo为回环网卡，用于本地通信与测试</div><h4 id="traceroute-查看与目标主机间的网路节点"><a href="#traceroute-查看与目标主机间的网路节点" class="headerlink" title="traceroute 查看与目标主机间的网路节点"></a>traceroute 查看与目标主机间的网路节点</h4><p><span class="strong">traceroute 网址或IP地址</span></p><p>显示当前主机与目标主机之间的所有网络节点的IP地址、延迟等信息，节点为***表示该节点信息被加密</p><h4 id="查看网络状态"><a href="#查看网络状态" class="headerlink" title="查看网络状态"></a>查看网络状态</h4><p><span class="strong">netstat [参数]</span><br>查看当前主机的网络连接状态，包括端口号、IP地址等</p><ul><li>-t &emsp;TCP协议</li><li>-u &emsp;UDP协议</li><li>-l &emsp;监听</li><li>-r &emsp;路由</li><li>-n &emsp;显示IP地址和端口号</li><li>-a &emsp;所有</li></ul><p>常用</p><ul><li><span class="strong">netstat -tuln &emsp;查看本机监听的TCP和UDP端口</span></li><li><span class="strong">netstat -an &emsp;查看本机的所有网络连接</span></li><li><span class="strong">netstat -rn &emsp;查看本机所有路由表</span></li></ul><h4 id="setup-配置网络-redhat系列操作系统专有"><a href="#setup-配置网络-redhat系列操作系统专有" class="headerlink" title="setup 配置网络(redhat系列操作系统专有)"></a>setup 配置网络(redhat系列操作系统专有)</h4><p><span class="strong">setup</span><br>调出GUI界面设置IP地址、子网掩码等信息，setup是redhat开发的用于配置网络IP地址、子网掩码等网络信息的GUI工具，只有部分redhat发行的操作系统中有该工具。</p><h4 id="mount-挂载设备"><a href="#mount-挂载设备" class="headerlink" title="mount 挂载设备"></a>mount 挂载设备</h4><h5 id="1-挂载设备"><a href="#1-挂载设备" class="headerlink" title="1.挂载设备"></a>1.挂载设备</h5><p><span class="strong">mount [-t 文件系统] 设备文件名 挂载路径</span></p><p>挂载u盘、光盘等设备到Linux中，设备文件名与挂载路径一般有约定俗成的设置</p><h5 id="2-卸载设备"><a href="#2-卸载设备" class="headerlink" title="2.卸载设备"></a>2.卸载设备</h5><p><span class="strong">umount 设备文件名或挂载路径</span></p><p>卸载已经挂载的设备，类似于Windows的U盘弹出，参数使用设备文件名或挂载路径其一，不能同时使用两个参数，卸载时需要回到挂载路径的母目录中。</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><h5 id="1-write-给某个在线用户发送信息"><a href="#1-write-给某个在线用户发送信息" class="headerlink" title="1. write 给某个在线用户发送信息"></a>1. write 给某个在线用户发送信息</h5><p><span class="strong">write 用户名 信息</span></p><p>给已经登录Linux的用户发送消息，<span class="tips">Ctrl+D</span>结束输入并发送，需要用户在线，可以使用<span class="tips">w</span>查询在线的账户。</p><h5 id="2-wall-给所有在线用户发送信息-write-all"><a href="#2-wall-给所有在线用户发送信息-write-all" class="headerlink" title="2. wall 给所有在线用户发送信息(write all)"></a>2. wall 给所有在线用户发送信息(write all)</h5><p><span class="strong">wall 信息</span></p>给所有在线用户发送广播信息<h4 id="mail-发送邮件"><a href="#mail-发送邮件" class="headerlink" title="mail 发送邮件"></a>mail 发送邮件</h4><p><span class="strong">mail 用户名</span></p><p>当用户未登录无法使用上述命令发送消息时，可以发送邮件给Linux用户。</p><div class="show">邮件发送:# mail 用户名 Subject : 邮件标题  //输入邮件邮件内容           //输入邮件内容，输入完毕<span class="tips">Ctrl+D</span>发送<p>邮件接收：<br>~ mail          //查看邮件箱<br>收到的邮件将以New标识(是否已读)、序号、发送用户、发送时间、邮件标题的格式列出<br>-&gt; N 1 root                  Sun Feb 20 12:38  18/532   “test”<br>~ 1             //直接输入序号查看对应邮件<br>~ h             //列出所有邮件<br>~ d1            //d+序号删除对应邮件<br>~ q             //退出邮件查看系统</div></p><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>Linux会通过mail给root用户发送一些邮件反映服务器错误信息等</div><h4 id="last-查看用户登录系统时间与系统重启时间"><a href="#last-查看用户登录系统时间与系统重启时间" class="headerlink" title="last 查看用户登录系统时间与系统重启时间"></a>last 查看用户登录系统时间与系统重启时间</h4><p><span class="strong">last </span><br>列出目前与过去所有登入过系统的用户信息，并列出了系统何时重启过</p><p><span class="strong">lastlog </span></p>列出用户上次登录系统的时间(包括系统用户)<p><span class="strong">lastlog -u UID</span></p>仅列出指定用户上次登录系统的时间<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>Linux中的软件安装包一般分为两种：源码包和二进制包</p><p>源码包：一般是使用C语言编写但未经过编译的包，安装时需要编译，所以时间长且安装步骤多，容易报错，但方便程序员阅读和修改源码</p><p>二进制包：源码包经过编译后形成二进制包，安装简单，安装速度快，但依赖性强，需要安装其他环境。二进制包通常有两大主流的管理系统：<ul><li>RPM 包管理系统：即Red-Hat Package Manager(红帽软件包管理器)，大多数 Linux 发行版默认的包管理方式，如 Fedora、CentOS、SuSE 操作系统。</li><li>DPKG 包管理系统：为 “Debian” 专门开发的套件管理系统，主要应用在 Debian 和 Ubuntu 上</p></li></ul><p>RPM包安装的默认路径为：</p><div class="table"><table><thead><tr><th>路径</th><th>文件</th><tr></thead><tbody><tr><td>/etc/</td><td>配置文件</td></tr><tr><td>/usr/bin/</td><td>可执行命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man</td><td>帮助文件保存位置</td></tr></tbody></table></div>因此通过RPM包安装的软件，服务启动时会自动去默认路径下寻找可执行命令，红帽系列的操作系统可通过系统服务管理命令<span class="tips">service、systemctl</span>命令管理<p>源码包安装路径自定义，一般安装在<span class="tips"> /usr/local/软件名/</span>路径下</p><h4 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h4><p>由于未经过编译，源码包安装一般需要先安装gcc编译器。源码包的安装一般要经过</p><ol><li>通过tar命令解压</li><li>进入解压缩的目录下</li><li>阅读INSTALL文件，INSTALL一般为安装说明</li><li>执行<span class="strong"> ./configure</span>设置安装在默认路径下，也可以使用<span class="strong"> ./configure –prefix=/usr/local/路径</span>自定义安装路径，执行完会根据配置项生成 Makefile 文件</li><li>执行<span class="strong">make</span> 命令进行编译。如果报错，除错后执行<span class="strong">make clean</span>删除编译产生的临时文件即可。</li><li>执行<span class="strong">make install</span> 命令进行安装</li><li>源码包的卸载只需删除安装目录即可，不会遗留任何垃圾文件。</li></ol><h4 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h4><p>RPM包安装需要提前安装好软件的依赖环境</p><h5 id="RPM包"><a href="#RPM包" class="headerlink" title="RPM包"></a>RPM包</h5><p>RPM包全名类似于 httpd-2.2.3-29.el5.i386.rpm ，其命名规则为</p><ol><li>包名</li><li>版本号，格式通常为“主版本号.次版本号.修正号”</li><li>发布次数，表示RPM包是第几次编译后发布的</li><li>适合的Liunx平台，如el5表示支持RHEL 5.x/CentOS 5.x下安装</li><li>适合的硬件平台，目前RPM支持的平台有：i386、i586、i686、sparc和alpha，noarch为支持所有硬件平台。</li><li>后缀名，.rpm是编译好的二进制包，可用rpm命令直接安装；.src.rpm表示是源码包，需要编译以后才能安装<div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>在安装软件时，有些命令后使用的是包的全名，有些命令使用的是包名，二者混用会导致软件无法安装</div>rpm模块依赖查询网站：<span class="tips"> www.rpmfind.net </span></li></ol><h5 id="安装升级与卸载"><a href="#安装升级与卸载" class="headerlink" title="安装升级与卸载"></a>安装升级与卸载</h5><ol><li><span class="strong">rpm -[i或U]vh 包全名</span>&emsp;安装或升级软件</li></ol><ul><li>-i &emsp;安装(install)</li><li>-U &emsp;升级(upgrade)</li><li>-v &emsp;显示详细信息(verbose)</li><li>-h &emsp;显示进度(hash)</li><li>-&nbsp;-nodeps &emsp;不检测依赖性(通常仅用于实验测试)</li></ul><ol start="2"><li><span class="strong">rpm -e 包名</span>&emsp;卸载软件</li></ol><ul><li>-&nbsp;-nodeps &emsp;不检测依赖性</li></ul><h5 id="查询包信息"><a href="#查询包信息" class="headerlink" title="查询包信息"></a>查询包信息</h5><h6 id="1-查询是否安装了某个包"><a href="#1-查询是否安装了某个包" class="headerlink" title="1. 查询是否安装了某个包"></a>1. 查询是否安装了某个包</h6><p><span class="strong">rpm -q 包名</span></p><ul><li>-q &emsp;查询(query)</li></ul><h6 id="2-列出所有已经安装的rpm包"><a href="#2-列出所有已经安装的rpm包" class="headerlink" title="2. 列出所有已经安装的rpm包"></a>2. 列出所有已经安装的rpm包</h6><p><span class="strong">rpm -qa&emsp;</span></p><ul><li>-a &emsp;所有(all)</li></ul><h6 id="3-查询rpm包详细信息"><a href="#3-查询rpm包详细信息" class="headerlink" title="3. 查询rpm包详细信息"></a>3. 查询rpm包详细信息</h6><p><span class="strong">rpm -qi 包名</span></p><ul><li>-i &emsp;查询信息(information)</li><li>-p &emsp;添加-p查询未安装包的信息(package)，对于未安装的包，包名应为完整包名</li></ul><h6 id="4-查询包文件安装位置"><a href="#4-查询包文件安装位置" class="headerlink" title="4. 查询包文件安装位置"></a>4. 查询包文件安装位置</h6><p><span class="strong">rpm -ql 包名</span></p><ul><li>-l &emsp;列表(list)</li><li>-p &emsp;未安装包的信息(package)，包名应为完整包名</li></ul><h6 id="5-查询某个系统文件属于哪个rpm包"><a href="#5-查询某个系统文件属于哪个rpm包" class="headerlink" title="5. 查询某个系统文件属于哪个rpm包"></a>5. 查询某个系统文件属于哪个rpm包</h6><p><span class="strong">rpm -qf 文件名</span></p><ul><li>-f &emsp;系统文件(file)</li></ul><h6 id="6-查询rpm包的依赖环境"><a href="#6-查询rpm包的依赖环境" class="headerlink" title="6. 查询rpm包的依赖环境"></a>6. 查询rpm包的依赖环境</h6><p><span class="strong">rpm -qR 包名</span></p><ul><li>-R &emsp;查询包的依赖(requires)</li><li>-p &emsp;未安装包的依赖(package)，包名应为完整包名</li></ul><h5 id="包校验"><a href="#包校验" class="headerlink" title="包校验"></a>包校验</h5><p><span class="strong">rpm -V 已经安装的包名</span></p><p>校验包中的文件是否正确，会返回包的验证信息</p><h5 id="包文件提取"><a href="#包文件提取" class="headerlink" title="包文件提取"></a>包文件提取</h5><p><span class="strong">rpm2cpio 包全名 | cpio -idv 文件绝对路径</span></p><p>cpio：标准工具，用于创建档案文件和从档案文件中提取文件</p><p>rpm2cpio命令用于将rpm包转换为cpio格式</p><div class="show">示例：rpm2cpio coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls该命令可用于 /bin 目录下的 ls 目录被误删除，因而无法使用 ls 命令时，从 coreutils-8.4-19.el6.i686.rpm 包中提取 ls 目录到 bin 目录下，修复 ls 命令</div><h3 id="yum操作"><a href="#yum操作" class="headerlink" title="yum操作"></a>yum操作</h3><p>yum是一个由RedHat社区开发，基于RPM包管理的Shell前端软件包管理器，被广泛用于Fedora、RedHat以及CentOS中。yum能自动从指定的服务器下载RPM包并且安装，并自动处理依赖性关系</p><h4 id="配置网络yum源"><a href="#配置网络yum源" class="headerlink" title="配置网络yum源"></a>配置网络yum源</h4><p>网络yum源的配置文件路径为<span class="tips"> /etc/yum.repos.d/CentOS-Base.repo </span>，配置信息类似于：</p><div class="shell">[base]name=CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</div><p>配置信息中各项配置解析：</p><ul><li>[base] &emsp;容器名称，放在[]中</li><li>name &emsp;容器说明，自由写</li><li>mirrorlist &emsp;镜像站点</li><li>baseurl &emsp;yum源服务器地址，默认为CentOS官方地址，国内可使用阿里云镜像地址</li><li>enabled &emsp;该容器是否失效，enable=0为不生效，enable=1为生效但会略写。</li><li>gpgcheck &emsp;为1则RPM的数字证书失效，0为不生效</li><li>gpgkey &emsp;数字证书公钥文件保存位置</li></ul><h4 id="yum安装软件"><a href="#yum安装软件" class="headerlink" title="yum安装软件"></a>yum安装软件</h4><p>yum命令中的包名不需要包的全名</p><h5 id="查询包"><a href="#查询包" class="headerlink" title="查询包"></a>查询包</h5><p><span class="strong">yum list &emsp;列出所有可用的软件包</span></p><p><span class="strong">yum search 关键字&emsp;搜索服务器上所有和关键字相关的包</span></p><h5 id="安装与升级"><a href="#安装与升级" class="headerlink" title="安装与升级"></a>安装与升级</h5><p><span class="strong">yum -y install 包名</span></p><ul><li>-y &emsp;对询问自动回答yes</li></ul><h5 id="升级、卸载"><a href="#升级、卸载" class="headerlink" title="升级、卸载"></a>升级、卸载</h5><ul><li>yum -y update 包名</li><li>yum -y remove 包名</li></ul><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>升级时必须写包名，否则会升级所有包，包括Linux内核，会直接导致服务器崩溃。而卸载时会卸载包和包的所有依赖，但依赖可能还是其他包的依赖，因此可能导致其他软件功能失效，因此这两条命令慎用</div><h4 id="yum安装软件包组"><a href="#yum安装软件包组" class="headerlink" title="yum安装软件包组"></a>yum安装软件包组</h4><ul><li><span class="strong">yum grouplist &emsp;列出所有可用软件组</span></li><li><span class="strong">yum groupinstall 软件组名&emsp;安装软件组</span></li><li><span class="strong">yum groupremove 软件组名&emsp;卸载软件组</span></li></ul><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>通过源码包安装的程序，所有文件会统一放置于如 /usr/local/ 目录下，而通过RPM包安装的程序，不同文件会放在不同目录下，如：可执行命令文件放在 /usr/bin 目录下，配置文件放在 /etc目录下。通过RPM包安装的软件服务，可以通过脚本文件启动，也可以通过service或systemctl命令直接启动，当执行该命令时，Linux会默认前往/usr/bin 目录下寻找相关文件。而通过源码包安装的服务由于安装路径不同，就无法通过该命令直接启动，但也可以将启动命令文件生成链接放置在/usr/bin目录下，这样源码包安装的服务也可以通过该命令启动了。</p><p>卸载软件时，通过源码包安装的程序直接删除对应文件即可，而通过RPM包安装的软件，由于文件散列分布，因此需要rpm -e 命令来卸载。</p><h4 id="服务查询"><a href="#服务查询" class="headerlink" title="服务查询"></a>服务查询</h4><p>查询服务开机自启动状态</p><h5 id="1-RPM包安装的应用服务"><a href="#1-RPM包安装的应用服务" class="headerlink" title="1. RPM包安装的应用服务"></a>1. RPM包安装的应用服务</h5><p><span class="strong">chkconfig -&zwnj;-list</span></p><p>查询所有RPM包安装的应用服务启动状态，会标出int0-6哪个级别系统启动状态下，服务会自启动。通过管道符可以查询指定服务的启动状态，如: chkconfig | grep nginx查看nginx服务的启动状态，在Centos7以后，该命令只能查看应用服务自启动情况，不包括系统本地服务，查看本地服务可以使用<span class="strong">systemctl list-unit-files</span>命令，使用管道符可以只查看指定服务的启动状况。</p><h5 id="2-源码包安装的服务"><a href="#2-源码包安装的服务" class="headerlink" title="2. 源码包安装的服务"></a>2. 源码包安装的服务</h5><p>查看安装位置下对应服务的配置文件，一般位于<span class="tips"> /usr/local/</span>路径下。</p><h4 id="RPM服务管理"><a href="#RPM服务管理" class="headerlink" title="RPM服务管理"></a>RPM服务管理</h4><h5 id="独立服务管理"><a href="#独立服务管理" class="headerlink" title="独立服务管理"></a>独立服务管理</h5><p>常用文件路径</p><div class="table"><table><thead><tr><th align="center">路径</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/etc/init.d</td><td align="center">启动脚本位置</td></tr><tr><td align="center">/etc/xinetd.d</td><td align="center">基于xinetd 服务的启动脚本</td></tr><tr><td align="center">/etc/sysconfig</td><td align="center">初始化环境配置文件</td></tr><tr><td align="center">/etc</td><td align="center">配置文件位置</td></tr><tr><td align="center">/etc/xinetd.conf</td><td align="center">xinetd 配置文件</td></tr><tr><td align="center">/var/lib</td><td align="center">放置服务产生的数据</td></tr><tr><td align="center">/var/log</td><td align="center">日志</td></tr></tbody></table></div><h5 id="独立服务命令"><a href="#独立服务命令" class="headerlink" title="独立服务命令"></a>独立服务命令</h5><ul><li><p><span class="strong">/etc/init.d/服务名&emsp;start/stop/status/restart </span></p></li><li><p><span class="strong">service/systemctl&emsp;服务名&emsp;start/stop/status/restart </span>&emsp;红帽系列系统专属</p></li></ul><h5 id="独立服务自启动"><a href="#独立服务自启动" class="headerlink" title="独立服务自启动"></a>独立服务自启动</h5><ul><li>将启动程序的命令写入<span class="tips"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令</li><li>chkconfig 服务名 on/off &emsp;开启、关闭自启动，默认在2345运行级别下自启动</li></ul><h5 id="基于xinetd-超级守护进程-服务"><a href="#基于xinetd-超级守护进程-服务" class="headerlink" title="基于xinetd(超级守护进程)服务"></a>基于xinetd(超级守护进程)服务</h5><p>xinetd负责管理系统中不频繁使用的服务，这些服务程序在有请求时才由xinetd服务负责启动运行，一旦完成服务请求服务程序结束运行，以减少对系统资源的占用。</p><p>基于 xinetd 的服务没有自己独立的启动脚本程序，需要依赖 xinetd 的启动脚本来启动。xinetd 本身是独立的服务，启动xinetd 服务的方法和启动独立服务的方法一致。</p><p>基于 xinetd 的服务只需修改 <span class="tips"> /etc/xinetd.d/服务名 </span> 文件下的 <span class="tips"> /disable</span>为 <span class="tips"> no</span>，然后重启xinetd 服务即可</p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>xinetd常用于红帽系列的操作系统，需要用户自行安装</div><h4 id="源码包安装的服务管理"><a href="#源码包安装的服务管理" class="headerlink" title="源码包安装的服务管理"></a>源码包安装的服务管理</h4><h5 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h5><p>源码包安装的服务一般通过绝对路径下的脚本启动，具体路径需查看安装说明INSTALL文件。</p><h5 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h5><p>将启动程序的命令写入<span class="tips"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令</p><h4 id="查看开机时服务启动顺序"><a href="#查看开机时服务启动顺序" class="headerlink" title="查看开机时服务启动顺序"></a>查看开机时服务启动顺序</h4><p>Linux开机或关机时的服务启动/关闭顺序写于文件<span class="tips"> /etc/rc.d/</span>路径下的对应文件中， <span class="tips"> rc0-rc6 </span>文件中分别书写有系统不同启动级别下服务启动顺序。如 rc3 中，S85nginx表示系统启动时，nginx将是第85个启动的服务，K15nginx表示系统关机时，nginx将是第15个关闭的服务。</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><ol><li><span class="strong">ps aux</span>&emsp;使用BSD(unix)标准格式显示进程</li></ol><ul><li>a &emsp;显示所有前台进程</li><li>x &emsp;显示所有后台进程</li><li>u &emsp;显示进程由哪个用户产生</li></ul><div class="show">BSD格式的进程信息：USER：该进程由哪个用户产生PID：进程的ID号%CPU：进程占用的CPU百分比%MEM：进程占用的物理内存百分比VSZ：进程占用的虚拟内存，单位为KBRSS：进程占用的物理内存大小，单位为KBTTY：进程在哪个终端运行，？为由Linux系统运行，tty1-tty6为本地字符界面终端，tty7为图形终端，pts/0-255为远程登录虚拟终端STAT：进程状态，常见的状态字符有：R运行(runnable)，S睡眠(sleeping)，s包含子进程，+位于后台的进程组，T停止，&lt;优先级高的进程，N优先级低的进程，l多线程，Z僵尸进程，D无法中断的休眠进程(通常为IO进程)START：进程启动时间TIME：进程占用CPU时间COMMAND：产生进程的命令名</div>2. <span class="strong">ps -le</span>&emsp;使用Linux标准格式显示进程<ul><li>-l &emsp;显示详细信息</li><li>-e &emsp;显示所有进程</li><li>-C命令&emsp;显示指定命令的状态</li></ul><div class="show">Linux格式的进程信息：UID：产生进程的用户IDPID：进程的ID号PPID：父进程IDC：进程占用CPU百分比STIME：进程启动时间TTY：进程在哪个终端运行，参数同上CMD：产生进程的命令名</div><h4 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h4><p><span class="strong">pstree [选项]</span></p><ul><li>-p &emsp;显示进程PID</li><li>-u &emsp;显示进程所属用户</li></ul><h4 id="查看进程调用的文件"><a href="#查看进程调用的文件" class="headerlink" title="查看进程调用的文件"></a>查看进程调用的文件</h4><p><span class="strong">lsof [参数]</span></p><ul><li>-c 字符串 &emsp;只列出以字符串开头的进程打开的文件</li><li>-u 用户名 &emsp;只列出某个用户所启动进程打开的文件</li><li>-p pid   &emsp;只列出某个PID进程打开的文件</li></ul><h4 id="监控系统资源占用状态"><a href="#监控系统资源占用状态" class="headerlink" title="监控系统资源占用状态"></a>监控系统资源占用状态</h4><p><span class="strong">top [参数]</span></p><ul><li>-d 秒数 &emsp;指定每几秒更新系统状态，默认是3秒</li></ul><p>显示当前系统的内存、CPU占用情况，显示状态下通过下列按键进行交互</p><ul><li>?或h &emsp;显示交互帮助</li><li>P &emsp; 根据CPU占用率显示进程顺序，默认</li><li>M &emsp; 根据内存占用率显示进程顺序</li><li>N &emsp; 根据PID显示进程顺序</li><li>q &emsp; 退出top监控</li></ul><div class="shell">系统资源显示信息：top - 15:40:11 up 41 days, 15:45,  2 users,  load average: 0.04, 0.05, 0.01Tasks:  78 total,   1 running,  45 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :   492280 total,    15964 free,    74408 used,   401908 buff/cacheKiB Swap:        0 total,        0 free,        0 used.   375944 avail Mem<p>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND<br>  1 root      20   0   51704   4948   3660 S  0.0  1.0  10:45.34 systemd</p></div><div class="table" style="text-align:left;"><table><thead><tr><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">15:40:11</td><td align="left">系统当前时间</td></tr><tr><td align="left">up 41 days,15:45</td><td align="left">系统运行时间，已运行41天15小时45分</td></tr><tr><td align="left">2 users</td><td align="left">当前登录用户数量</td></tr><tr><td align="left">load average: 0.04, 0.05, 0.01</td><td align="left">系统在1分钟、5分钟、15分钟前的平均负载，根据主机内核数量判断负荷情况，如 8核，超过8表明已超负荷运行</td></tr><tr><td align="left">Tasks</td><td align="left">Tasks后分别为 系统中的总进程数、正在运行的进程、睡眠进程、停止的进程、僵尸进程</td></tr><tr><td align="left">%Cpu(s)</td><td align="left">us为CPU被用户占用的比率，sy为系统占用比例，ni为修改过优先级的用户进程CPU占用比率，id为CPU空闲的比率，wa为等待输入、输出的进程占用CPU的比率，hi为硬中断请求服务占用CPU比率，si为软中断请求服务占用CPU比率，st为有虚拟机时，虚拟CPU等待实际CPU的时间百分比</td></tr><tr><td align="left">Mem</td><td align="left">物理内存总大小、空闲内存大小、使用内存大小、正在缓冲的内存大小</td></tr><tr><td align="left">Swap</td><td align="left">交换分区总大小、空闲部分、使用部分、有效大小</td></tr></tbody></table></div><h4 id="按指定次数监控系统资源"><a href="#按指定次数监控系统资源" class="headerlink" title="按指定次数监控系统资源"></a>按指定次数监控系统资源</h4><p><span class="strong">vmstat 刷新延迟 监听次数</span></p><p>输出进程数、内存状态、交换分区状况、硬盘输入输出状况、CPU状态</p><div class="show"># vmstat 3 4每3秒监听一次系统资源，输出4次</div><h4 id="查看开机时检测的系统内核信息"><a href="#查看开机时检测的系统内核信息" class="headerlink" title="查看开机时检测的系统内核信息"></a>查看开机时检测的系统内核信息</h4><p><span class="strong">dmesg</span></p><p>会输出非常详细的CPU(如型号、主频、核心数….)、网卡、硬盘等主机开机检测的信息，一般通过管道符只查看某部分具体信息，如: dmesg | grep CPU 查看CPU详细信息</p><h5 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h5><p>开机检测后，检测到的信息会按格式写于<span class="tips">/proc/cpuinfo</span>文件中，通过该文件查看CPU信息更为清晰</p><h4 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h4><p><span class="strong">free [参数]</span></p><ul><li>-b &emsp;以字节单位显示内存大小</li><li>-k &emsp;以KB单位显示内存大小(默认)</li><li>-m &emsp;以MB单位显示内存大小</li><li>-g &emsp;以GB单位显示内存大小</li></ul><h4 id="查看操作系统内核"><a href="#查看操作系统内核" class="headerlink" title="查看操作系统内核"></a>查看操作系统内核</h4><p><span class="strong">uname [选项]</span></p><ul><li>-a &emsp;查看系统所有信息</li><li>-r &emsp;查看内核版本</li><li>-s &emsp;查看内核名称</li><li>-m &emsp;查看内核架构、操作系统位数</li></ul><p>通过查看文件系统的位数，也可以查看操作系统位数，如执行 <span class="tips">file /bin/ls</span>，其中/bin/ls可以为任意外部命令</p><h4 id="查看当前Linux操作系统的发行版本"><a href="#查看当前Linux操作系统的发行版本" class="headerlink" title="查看当前Linux操作系统的发行版本"></a>查看当前Linux操作系统的发行版本</h4><p>使用cat命令查看 <span class="tips">/etc/system-release</span>或 <span class="tips">/etc/redhat-release(红帽专属)</span>文件即可</p><h4 id="中止进程"><a href="#中止进程" class="headerlink" title="中止进程"></a>中止进程</h4><h5 id="系统的中止信号"><a href="#系统的中止信号" class="headerlink" title="系统的中止信号"></a>系统的中止信号</h5><p><span class="strong">kill -l</span>查询可用的进程信号<br>常用的进程信号</p><div class="table"><table><thead><tr><th>代号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>该信号用于让进程重新读取配置文件后重启</td></tr><tr><td>2</td><td>SIGINT</td><td>中止前台进程，相当于ctrl+C</td></tr><tr><td>9</td><td>SIGKILL</td><td>该信号用于强制中止进程</td></tr><tr><td>15</td><td>SIGTERM</td><td>正常中止进程，kill命令的默认信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>让一个暂停的进程继续执行</td></tr><tr><td>19</td><td>SIGSTOP</td><td>暂停进程的执行</td></tr></tbody></table></div><h5 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h5><p><span class="strong">kill [信号代号] [进程PID]</span></p><p>根据进程PID中止进程</p><ul><li>kill -15 PID &emsp;中止进程(默认，-15可省略)</li><li>kill -1 PID &emsp;重新载入配置文件后重启</li><li>kill -9 PID &emsp;强制中止进程</li></ul><h5 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h5><p><span class="strong">kill [参数][信号代号] [进程名]</span></p><p>根据进程名中止进程</p><ul><li>-i &emsp;询问是否杀死某进程</li><li>-I &emsp;忽略进程名大小写</li></ul><h5 id="pkill命令"><a href="#pkill命令" class="headerlink" title="pkill命令"></a>pkill命令</h5><p><span class="strong">pkill [参数][信号代号] [进程名]</span></p><ul><li>-t 终端号 &emsp;按终端号关闭用户的连接(踢出用户)</li></ul><div class="show"># pkill -9 -t tty1关闭终端号为 tty1 用户的连接</div><h3 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h3><h4 id="将程序转入后台运行-暂停"><a href="#将程序转入后台运行-暂停" class="headerlink" title="将程序转入后台运行/暂停"></a>将程序转入后台运行/暂停</h4><p><span class="strong">在命令后添加 <span class="tips"> &amp; </span>，可使该命令在后台执行</span></p><div class="show">如：# tar -zxf test.tar.gz &在后台解压缩 test.tar.gz文件，执行完会提示Done</div><p><span class="strong">在命令运行时执行<span class="tips"> Ctrl + Z </span> 是将当前工作暂停后转入后台</span></p><div class="show">如：# top执行Ctrl + Z会将监视系统资源的top程序设为stopped(暂停)状态后转入后台</div><h4 id="查看后台的工作"><a href="#查看后台的工作" class="headerlink" title="查看后台的工作"></a>查看后台的工作</h4><p><span class="strong"> jobs [-l]</span></p><ul><li>-l &emsp;显示工作的PID</li></ul><div class="shell">[1]   Stopped                 top[2]-  Stopped                 top[3]+  Stopped                 top</div><p>[3]代表工作序号，“+”号代表最后一个放入后台的工作，“-”号代表倒数第二个放入后台的工作，恢复时默认使用出栈方式从最后一个放入后台的工作开始恢复</p><h4 id="将后台暂停的工作恢复到前台执行"><a href="#将后台暂停的工作恢复到前台执行" class="headerlink" title="将后台暂停的工作恢复到前台执行"></a>将后台暂停的工作恢复到前台执行</h4><p><span class="strong"> fg [%工作序号]</span></p><ul><li>%可省略，如果不添加工作序号，则默认从后放入的工作开始恢复</li></ul><h4 id="将后台暂停的工作恢复到后台执行"><a href="#将后台暂停的工作恢复到后台执行" class="headerlink" title="将后台暂停的工作恢复到后台执行"></a>将后台暂停的工作恢复到后台执行</h4><p><span class="strong"> bg [%工作序号]</span></p><ul><li>%可省略，如果不添加工作序号，则默认从后放入的工作开始恢复</li></ul><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>top，vi等服务于前台的命令，不能恢复到后台执行。</div><h3 id="alternatives工具"><a href="#alternatives工具" class="headerlink" title="alternatives工具"></a>alternatives工具</h3><h4 id="alternatives简介"><a href="#alternatives简介" class="headerlink" title="alternatives简介"></a>alternatives简介</h4><p>alternatives工具常用于指定默认软件、默认配置，或者某一软件的默认版本。</p><p>如：在Linux中，yum等工具一般使用python2作为命令解释器，而一些较新的软件依赖较新版的python3。因此有时我们不得不同时安装python2和python3。如果使用 python3 作为默认的python版本，使用yum会抛出错误，这是因为使用了python3解析yum中python2的语法，同理，一些较新的软件也无法使用python2解析。此时，我们就需要使用alternatives来控制软件的默认版本。</p><p>alternatives的使用方法是：给定两个软件或多个软件的路径，然后将它们注册为一个组，为这个组建立一个软链接，之后调用软件将直接从这一软链接调用</p><h4 id="alternatives命令"><a href="#alternatives命令" class="headerlink" title="alternatives命令"></a>alternatives命令</h4><h5 id="注册组"><a href="#注册组" class="headerlink" title="注册组"></a>注册组</h5><p><span class="strong">alternatives -&zwnj;-install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</span></p><ul><li>-&zwnj;-install 注册(新增)需要管理的命令/软件</li><li>link：注册路径，会在该路径下生成一个软链，此后由该软链启动命令</li><li>name：组名</li><li>path：软件/命令的路径，将该路径下的命令加入alternatives管理组</li><li>priority：权值，在自动模式下，权值越高，软件优先级越高</li></ul><h5 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h5><ul><li><span class="strong">alternatives -&zwnj;-config &lt;name&gt;</span> 修改默认配置(将进入交互模式，并切换为手动模式)</li><li><span class="strong">alternatives -&zwnj;-set &lt;name&gt; &lt;path&gt;</span> 修改默认配置(将切换为手动模式)</li><li><span class="strong">alternatives -&zwnj;-auto &lt;name&gt;</span> 切换为自动模式</li><li><span class="strong">alternatives -&zwnj;-display &lt;name&gt;</span> 显示对应组的配置信息(包括自动/手动模式，路径，权值)</li><li><span class="strong">alternatives -&zwnj;-remove &lt;name&gt; &lt;path&gt;</span> 删除组中对应路径的软件</li><li><span class="strong">alternatives -&zwnj;-list</span> 列出所有组的信息(组名、自动/手动模式、当前默认软件路径)</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="1-注册组"><a href="#1-注册组" class="headerlink" title="1. 注册组"></a>1. 注册组</h5><p>在<span class="tips">/usr/bin</span>目录下有python2.7与python3.7的启动命令，我们可以新建python组，将python2和python3的启动路径加入到该组中，并指定python3为默认版本，此后直接执行<span class="tips">python</span>命令将唤醒python3，而不用再指定明确的版本号，且将默认唤醒python3，该默认值是可以随时更改的</p><div class="shell"><code># alternatives --install /usr/bin/python python /usr/bin/python2.7 10# alternatives --install /usr/bin/python python /usr/bin/python3.6 20</code></div><p>上述命令</p><ul><li>将在 <span class="tips">/usr/bin</span> 目录下新建名为 <span class="tips">python</span> 的软链接，该软链接指向<span class="tips">/etc/alternatives/python</span>，该链接又指向<span class="tips">/usr/bin/python3.6</span></li></ul><div class="show">即 /usr/bin/python --> /etc/alternatives/python --> /usr/bin/python3.6</div><ul><li>修改默认值，修改的是/etc/alternatives/python的指向，即默认值为python2.7时，/etc/alternatives/python链接指向将修改为/usr/bin/python2.7</li><li>python3.6的权值为20，python2.7的权值为10，自动模式下，alternatives将优先调用python3.6</li><li>生成链接名可以任意自定义，并且调用命令也将相应修改，如：<div class="shell"><code>alternatives --install /usr/bin/py ppyy /usr/bin/python3 10</code></div>调用命令将变为py:<div class="shell">py --version #同python3 --version命令</div></li></ul><h6 id="2-修改默认值"><a href="#2-修改默认值" class="headerlink" title="2. 修改默认值"></a>2. 修改默认值</h6><div class="shell"><code>alternatives --config python</code></div>将进入交互模式，让你输入序号选择版本<div class="shell">There are 2 programs which provide 'python'.  Selection    Command-----------------------------------------------   1           /usr/bin/python2.7*+ 2           /usr/bin/python3.6<p>Enter to keep the current selection[+], or type selection number: </p></div><p>+号为当前生效的版本，*为新增版本</p><h6 id="3-查看python组信息"><a href="#3-查看python组信息" class="headerlink" title="3. 查看python组信息"></a>3. 查看python组信息</h6><div class="shell"><code>alternatives --display python</code></div><div class="shell">python - status is manual. #python处于手动模式 link currently points to /usr/bin/python3.6 #当前默认使用python3.6版本/usr/bin/python2.7 - priority 10  #可选版本信息/usr/bin/python3.6 - priority 20Current `best' version is /usr/bin/python3.6.</div><h6 id="4-从组中删除python3-6版本"><a href="#4-从组中删除python3-6版本" class="headerlink" title="4. 从组中删除python3.6版本"></a>4. 从组中删除python3.6版本</h6><div class="shell"><code>alternatives --remove python /usr/bin/python3.6</code></div>从python组中移除3.6版本，将只剩2.7版本可选<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h4><p>cron即计划任务，而crond则是一个常驻服务，在Linux中用于周期性执行某个任务，该服务的配置文件位于<span class="tips">/etc/crontab</span></p><h5 id="查看crond服务运行情况"><a href="#查看crond服务运行情况" class="headerlink" title="查看crond服务运行情况"></a>查看crond服务运行情况</h5><p><span class="strong">ps aux | grep crond</span>查看crond进程是否在运行，红帽系列的操作系统可使用<span class="strong">service status crond</span>或<span class="strong">systemctl status crond</span>(centos7+)</p><h5 id="查看crond服务是否开机自启动"><a href="#查看crond服务是否开机自启动" class="headerlink" title="查看crond服务是否开机自启动"></a>查看crond服务是否开机自启动</h5><p><span class="strong">chkconfig -&zwnj;-list | grep crond</span>或<span class="strong">systemctl list-unit-files | grep crond</span>(centos7+)</p><h4 id="设置crond定时任务"><a href="#设置crond定时任务" class="headerlink" title="设置crond定时任务"></a>设置crond定时任务</h4><p>可通过修改<span class="tips">/etc/crontab</span>文件来设置定时任务，同路径下还有 cron.daily，cron.weekly等对应时间记录crond任务的文件。也可以通过命令来修改crontab文件，语法为:</p><p><span class="strong">crontab [参数]</span></p><ul><li>-e &emsp;编辑crontab定时任务</li><li>-l &emsp;查询crontab定时任务</li><li>-r &emsp;删除当前用户所有crontab任务</li></ul><h5 id="cron语法"><a href="#cron语法" class="headerlink" title="cron语法"></a>cron语法</h5><p>编辑定时任务时会打开vi编辑器，编辑语法格式需遵循cron语法，基本格式为：<span class="tips"><strong>***** 命令</strong></span></p><ul><li><span class="strong">第一个*表示一小时当中的第几分钟，范围为0-59</span></li><li><span class="strong">第二个*表示一天当中的第几个小时，范围为0-23</span></li><li><span class="strong">第三个*表示一个月当中的第几天，范围为1-31</span></li><li><span class="strong">第四个*表示一年当中的第几个月，范围为1-12</span></li><li><span class="strong">第五个*表示一周当中的星期几，范围为0-7(0和7都代表星期日)</span></li></ul><div class="table"><table><thead><tr><th align="left">特殊符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">代表任何时间</td></tr><tr><td align="left">,</td><td align="left">代表不连续的时间</td></tr><tr><td align="left">-</td><td align="left">代表连续的时间范围</td></tr><tr><td align="left">*/n</td><td align="left">代表隔多久执行一次</td></tr></tbody></table></div><div class="show">示例：30 23 * * * 命令      //每天的23：30执行对应命令0 1 1,15 * * 命令    //每个月1号和15号凌晨1:00执行命令30 2 * * 1-3 命令   // 每周一到周三凌晨2点30执行命令*/10 4 * * * 命令   //每天凌晨4点，每隔10分钟执行一次命令，执行6次(即小时数超过4时就停止)0 0 1,15 * 1 命令   //每个月1号，15号和每周一凌晨00:00执行一次命令0 2 1 * * /sbin/shutdown -r now 每个月1号凌晨2：00重启Linux</div><h3 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h3><h4 id="rsyslog服务"><a href="#rsyslog服务" class="headerlink" title="rsyslog服务"></a>rsyslog服务</h4><p>Syslog(系统日志协议)是在一个IP网络中转发系统日志信息的标准，syslogd服务被广泛用于老版Unix/Linux系统中负责记录系统日志，RSyslog是syslog的多线程增强版，CentOS6以后系统默认使用Rsyslogd服务记录系统日志。</p><h5 id="查询rsyslog服务是否在运行"><a href="#查询rsyslog服务是否在运行" class="headerlink" title="查询rsyslog服务是否在运行"></a>查询rsyslog服务是否在运行</h5><p>可使用命令<span class="strong">ps aux | grep rsyslogd</span>查看rsyslog进程是否在运行，红帽系列可使用命令<span class="strong">systemctl status rsyslog</span>查看</p><h5 id="查看rsyslog服务是否开机自启动"><a href="#查看rsyslog服务是否开机自启动" class="headerlink" title="查看rsyslog服务是否开机自启动"></a>查看rsyslog服务是否开机自启动</h5><ul><li><span class="strong">chkconfig –list |grep rsyslog</span></li><li><span class="strong">systemctl list-unit-files | grep rsyslog</span>(centos7)</li></ul><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>系统日志默认保存在 <span class="tips">/var/log</span> 路径下，对应文件的作用:</p><div class="table"><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/var/log/cron</td><td>定时任务相关日志</td></tr><tr><td>/var/log/cups</td><td>打印系统的日志</td></tr><tr><td>/var/log/dmesg</td><td>开机内核自检的信息，使用dmesg命令就是读取了该文件</td></tr><tr><td>/var/log/btmp</td><td>错误登录日志，二进制文件，需通过<span class="tips">lastb</span>命令查看</td></tr><tr><td>/var/log/lastlog</td><td>记录所有用户最后一次登录系统的日志，二进制文件，需通过<span class="tips">lastlog</span>命令查看</td></tr><tr><td>/var/log/mailog</td><td>邮件日志</td></tr><tr><td>/var/log/message</td><td>记录系统所有重要事件信息</td></tr><tr><td>/var/log/secure</td><td>记录所有涉及用户账户和密码的信息，如：用户登录，添加用户，切换用户，sudo授权，修改密码等</td></tr><tr><td>/var/log/wtmp</td><td>永久记录所有用户的登录、注销、系统启动、重启等信息，二进制文件，需使用<span class="tips">last</span>命令查看</td></tr><tr><td>/var/log/utmp</td><td>记录当前登录的用户信息，并且随着用户注销、切换不断变化，使用w,who,users等命令查看</td></tr></tbody></table></div><p>使用RPM包安装的服务也会默认把日志文件放在<span class="tips">/vat/log/服务名</span> 路径下，但其日志由自身服务管理，而不归rsyslogd服务管理</p><p>使用源码包安装服务的日志文件位于用户指定的安装路径下，一般位于 /usr/local路径下</p><h4 id="rsyslog日志格式"><a href="#rsyslog日志格式" class="headerlink" title="rsyslog日志格式"></a>rsyslog日志格式</h4><p>日志文件通常由以下内容按顺序书写：</p><ul><li>事件产生时间</li><li>服务器主机名</li><li>产生事件的服务名</li><li>事件的具体信息</li></ul><h4 id="rsyslog日志配置文件"><a href="#rsyslog日志配置文件" class="headerlink" title="rsyslog日志配置文件"></a>rsyslog日志配置文件</h4><p>该配置文件位于<span class="tips">/etc/rsyslog.conf</span>，配置文件决定了日志系统记录哪些级别的日志信息，文件的格式为 <span class="tips"><strong>服务名[连接符]日志等级&emsp;&emsp;日志记录位置</strong></span></p><h5 id="服务名"><a href="#服务名" class="headerlink" title="服务名"></a>服务名</h5><div class="table"><table><thead><tr><th>服务名称</th><th>说明</th></tr></thead><tbody><tr><td>auth</td><td>安全和认证相关信息</td></tr><tr><td>authpriv</td><td>安全和认证相关信息(私有信息)</td></tr><tr><td>cron</td><td>系统定时任务cront和At产生的日志</td></tr><tr><td>daemon</td><td>守护进程相关的日志</td></tr><tr><td>ftp</td><td>ftp守护进程相关日志</td></tr><tr><td>kern</td><td>内核产生的日志</td></tr><tr><td>local0-local7</td><td>为本地预留的服务项</td></tr><tr><td>lpr</td><td>打印系统产生的日志</td></tr><tr><td>mail</td><td>邮件日志</td></tr><tr><td>news</td><td>新闻服务器相关日志</td></tr><tr><td>syslog</td><td>rsyslog服务产生的日志</td></tr><tr><td>user</td><td>用户等级类别产生的日志</td></tr><tr><td>uucp</td><td>uucp(数据传输协议)子系统的日志</td></tr></tbody></table></div><h5 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h5><div class="table"><table><thead><tr><th>连接符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>表示比后面所写等级高(包含该等级)的日志都记录下来</td></tr><tr><td>.=</td><td>只记录指定等级的日志</td></tr><tr><td>.!</td><td>除了该等级，其余等级都记录</td></tr></tbody></table></div><h5 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h5><div class="table"><table><thead><tr><th>等级</th><th>说明</th></tr></thead><tbody><tr><td><strong>*</strong></td><td>所有等级</td></tr><tr><td>none</td><td>与*相反，不记录任何等级日志</td></tr><tr><td>debug</td><td>调试信息</td></tr><tr><td>info</td><td>通知信息，反馈系统状态</td></tr><tr><td>notice</td><td>公告(提醒)信息，不影响功能但有一定重要性</td></tr><tr><td>warning</td><td>警告信息，服务不影响使用但可能存在问题</td></tr><tr><td>err</td><td>错误信息，服务出错停止运行，需要修复</td></tr><tr><td>crit</td><td>临界状态信息，服务宕机，且可能无法修复</td></tr><tr><td>alert</td><td>警报信息，服务宕机，影响系统运行</td></tr><tr><td>emerg</td><td>紧急信息，系统疼痛等级，系统濒临崩溃甚至已经崩溃</td></tr></tbody></table></div><h5 id="日志记录位置"><a href="#日志记录位置" class="headerlink" title="日志记录位置"></a>日志记录位置</h5><p>日志记录位置可以是以下值:</p><ul><li>路径，写于本机指定位置，如:/var/log/lastlog</li><li>系统设备，写于U盘或者通过打印机打印日志，如:/dev/lp0</li><li>转发到远程主机或日志服务器，如:@192.168.0.100:514</li><li>用户名，发送给指定用户，如:root</li><li>忽略或丢弃日志，如：~ ，直接丢弃</li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>以下示例来源于centos7系统默认配置</p><div class="shell">cron.*                                                  /var/log/cron所有等级的cron日志写于/var/log/cron文件中*.emerg                                                 :omusrmsg:*出现疼痛等级的日志时，发送给所有用户*.info;mail.none;authpriv.none;cron.none                /var/log/messages不记录任何私人身份验证消息uucp,news.crit                                          /var/log/spooler将uucp,news服务crit和更高级别的日志信息保存在指定文件中</div><h4 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h4><p>日志轮替用于用新日志覆盖旧日志，其配置文件位于<span class="tips">/etc/logrotate.conf</span>，需要相关功能只需在配置文件中添加对应参数就即可。</p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daily/weekly/monthly</td><td>日志轮替周期</td></tr><tr><td>rotate 数字</td><td>保留日志文件的个数，0为不备份</td></tr><tr><td>compress</td><td>日志轮替时，对旧日志进行压缩</td></tr><tr><td>create 权限值 所有者 所属组</td><td>建立新日志，并指定日志文件的权限、所有者、所属组</td></tr><tr><td>mail address</td><td>日志轮替时，日志内容发送到指定邮箱，如:mail <a href="mailto:&#x31;&#x31;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#x31;&#x31;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></td></tr><tr><td>missingok</td><td>日志不存在时，忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志文件为空，则不进行轮替</td></tr><tr><td>maxsize 大小</td><td>当日志文件到达指定大小，无论是否到轮替时间，都进行一次轮替，未到达指定大小但到达轮替周期，也进行轮替</td></tr><tr><td>minsize 大小</td><td>到达轮替时间时，如果日志文件达到该最小值时就进行轮替，否则不进行轮替</td></tr><tr><td>size 大小</td><td>时间周期设置无效，只有当日志文件大于指定大小才进行轮替</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件名</td></tr></tbody></table></div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div><span class="tips">dateext</span>参数用于指定当前日期作为日志文件后缀名，如:secure-20210211。如果配置文件中没有该参数，则日志文件将以.1，.2作为文件名名后缀。如：当前日志文件为secure，进行轮替后该文件改名为secure.1，secure.1改为secure.2，而将新的日志文件命名为secure。</div><h5 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h5><p>通过RPM包安装的服务其日志会被自动识别配置轮替，通过源码包安装的服务需要自行添加配置，配置格式同本地配置的基本格式。</p><div class="shell"># see "man logrotate" for details# rotate log files weeklyweekly<p># keep 4 weeks worth of backlogs<br>rotate 4</p><p># create new (empty) log files after rotating old ones<br>create</p><p># use date as a suffix of the rotated file<br>dateext</p><p># uncomment this if you want your log files compressed<br>#compress</p><p># RPM packages drop log rotation information into this directory<br>include /etc/logrotate.d</p><p># no packages own wtmp and btmp – we’ll rotate them here<br>/var/log/wtmp {<br>    monthly<br>    create 0664 root utmp<br>    minsize 1M<br>    rotate 1<br>}<br>/var/log/btmp {<br>    missingok<br>    monthly<br>    create 0600 root utmp<br>    rotate 1<br>}<br>本地配置格式(若某参数同时设置了本地配置和全局配置，则本地配置生效)<br>日志路径 {<br>  配置参数<br>}<br>如：<br>/usr/local/apache/logs/access_log {<br>  daily      //每天进行日志轮替<br>  create    //日志轮替时新建日志，文件权限、所有者等信息默认<br>  rotate 30 //保留30份日志文件(即保留30天)<br>}</p></div><h5 id="手动进行日志轮替"><a href="#手动进行日志轮替" class="headerlink" title="手动进行日志轮替"></a>手动进行日志轮替</h5><p><span class="strong">logrotate [参数] 配置文件名</span></p><p>不添加任何参数时，将按配置文件进行轮替</p><ul><li>-v 显示日志轮替的过程</li><li>-f 无论是否达到轮替配置要求，强制进行日志轮替</li></ul><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p><strong>完全备份：</strong>即把所有需要备份的数据全部备份， 在Linux 中，完全备份指将根目录下的所有文件进行备份。</p><p><strong>增量备份：</strong>指第一次进行完全备份，服务器运行一段时间后，比较当前数据和第一次备份数据之间的差异，只备份有差异的数据，之后的每次备份都只备份与上一次备份有差异的数据。</p><h5 id="一般需备份的数据"><a href="#一般需备份的数据" class="headerlink" title="一般需备份的数据"></a>一般需备份的数据</h5><ul><li><strong>/root/</strong>&emsp;管理员账户根目录</li><li><strong>/home/</strong>&emsp;普通用户家目录</li><li><strong>/var/spool/mail</strong>&emsp;邮件</li><li><strong>/etc/</strong>&emsp;重要服务的配置文件</li><li><strong>/var/log</strong>&emsp;常用服务的日志</li><li><strong>数据库数据、账户资料….</strong></li></ul><h4 id="dump文件备份系统"><a href="#dump文件备份系统" class="headerlink" title="dump文件备份系统"></a>dump文件备份系统</h4><h5 id="1-安装dump"><a href="#1-安装dump" class="headerlink" title="1. 安装dump"></a>1. 安装dump</h5><ul><li><strong>yum -y install dump</strong> (redhalt系列)</li><li><strong>apt-get install dump</strong> (debian系列)</li></ul><h5 id="2-dump命令"><a href="#2-dump命令" class="headerlink" title="2. dump命令"></a>2. dump命令</h5><p><span class="strong">dump [参数] 备份后文件名 原文件或目录</span></p><ul><li>-[0-9级别]&emsp;可选0-9备份级别</li><li>-f 文件名&emsp;指定备份后的文件名</li><li>-u&emsp;备份成功后，把备份时间、备份级别等信息记录在 /etc/dumpdates 文件中</li><li>-v&emsp;显示备份过程中更多的输出信息</li><li>-j&emsp;调用 bzlib 库压缩备份文件，其实就是把备份文件压缩为 .bz2 格式，默认压缩等级为2</li><li>-W&emsp;显示允许被 dump 的分区的备份等级及备份时间</li></ul><h5 id="3-备份操作"><a href="#3-备份操作" class="headerlink" title="3.备份操作"></a>3.备份操作</h5><p>对于某个文件或不是分区的目录，dump只能使用 0 级别进行完全备份。而备份分区或整块硬盘时，dump 通过“备份级别”实现增量备份，其中，0 级别是完全备份，1-9为增量备份。</p><p>当我们备份数据时，第一次备份应该使用 0 级别，dump会把所有数据完全备份一次；第二次备份就可以使用 1 级别了，它会和 0 级别进行比较，把 0 级别备份之后变化的数据进行备份；第三次备份使用  2 级别，2 级别会和 1 级别进行比较，把 1 级别备份之后变化的数据进行备份，以此类推。</p><h6 id="备份目录"><a href="#备份目录" class="headerlink" title="备份目录"></a>备份目录</h6><div class="show"># dump -0uj -f /new/home.bak.bz2 /home/完全备份home目录到/new/home.bak.bz2路径下</div><h6 id="备份分区"><a href="#备份分区" class="headerlink" title="备份分区"></a>备份分区</h6><div class="show">#df -h 查看分区信息# dump -0uj -f /root/boot.bak.bz2 /boot/第一次备份进行完全备份，记录备份信息# dump -1uj -f /root/boot.bak1.bz2 /boot/第二次开始使用增量备份# dump -W查询分区的备份时间及备份级别(需要备份的时候添加u参数)</div><h4 id="restore还原dump备份的文件"><a href="#restore还原dump备份的文件" class="headerlink" title="restore还原dump备份的文件"></a>restore还原dump备份的文件</h4><p><span class="strong">restore [模式选项] [-f 文件名]</span></p><p>-f用于指定备份文件文件名，模式选项有四个，只能选一个模式</p><ul><li>-C&emsp;比较模式，比较备份数据和现有数据的不同并返回(只能检测出数据修改或减少的部分，如果新增了数据不会被检测到)</li><li>-i&emsp;交互模式，手动选择需要恢复的文件</li><li>-t&emsp;查看模式，用于查看备份文件中拥有哪些文件和目录</li><li>-r&emsp;还原模式，用于数据还原(如果是增量备份，则需先还原首次完全备份的数据)</li></ul><div class="show"># restore -r -f /root/boot.bak.bz2先还原增量备份中首次备份的数据# restore -r -f /root/boot.bak.bz2再还原第二次开始增量备份的数据</div><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>一般使用<span class="tips">bak</span>作为系统备份文件名后缀</div>]]></content>
    
    
    <summary type="html">Linux网络操作，包括网络与网卡设置，源码包与二进制包的安装，yum工具使用，安装服务管理，系统资源的监控，日志服务，定时任务，文件备份</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="command" scheme="https://shiwei11.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>Linux 运行级别与用户管理</title>
    <link href="https://shiwei11.github.io/blog/2021/12/29/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84/"/>
    <id>https://shiwei11.github.io/blog/2021/12/29/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84/</id>
    <published>2021-12-29T01:57:08.000Z</published>
    <updated>2022-09-09T23:40:39.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h3><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><ul><li><strong>/bin</strong> &emsp; Binaries的缩写，存放普通用户可使用的系统命令,如:ls</li><li><strong>/sbin</strong>&emsp;Super user Binary的缩写，存放只有系统管理员才能使用的系统命令，如:shutdown、reboot</li><li><strong>/usr/bin</strong>&emsp;存放安装软件后，普通用户可以使用的软件命令，如:c++、make、wget等</li><li><strong>/usr/sbin</strong>&emsp;存放系统管理员用户安装使用的高级管理程序和系统服务程序，如:httpd、netconfig、tcpd等</li></ul><h4 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h4><ul><li><strong>/etc</strong>&emsp;Etcetera(其他)的缩写，这个目录用来存放所有系统管理所需要的<strong>配置文件</strong>和子目录</li><li><strong>/var</strong>存放一些经常被修改、扩充的文件，如各种日志文件</li><li>/boot&emsp;存放引导启动Linux时使用的核心文件,如镜像文件等</li><li>/sys&emsp; Linux2.6内核新增的文件系统sysfs，sysfs文件系统集成了3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统</li><li>/lib&emsp;存放系统所需要的动态链接库(如C++库)，相当于windows的dll文件</li><li>/dev&emsp;Device的缩写, 将Linux主机的硬件以文件形式存储并提供访问，相当于Windows的设备管理器</li><li>/usr/src&emsp;内核源代码、说明文档等默认放置目录</li><li>/opt&emsp;默认为空，常用于安装额外软件</li><li>/proc&emsp;Processes(进程)的缩写，虚拟的目录，用于管理内存空间，是系统内存的映射，我们可以直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里</li><li>/selinux&emsp;全称为security-enhanced linux，该目录是 Redhat/CentOS 所特有的目录，是Redhat/CentOS的安全子系统</li><li>/srv&emsp;service缩写，存放一些服务启动后需要提取的数据</li></ul><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><ul><li><strong>/root</strong>&emsp;系统管理员的账号主目录</li><li><strong>/home</strong>&emsp;存放普通用户的相关文件，Linux会在home目录下为每一个用户生成一个以用户账号命名的目录</li><li><strong>/usr</strong>&emsp;Unix Software Resource(共享资源)的缩写,放置用户的应用程序和文件，类似于windows下的program files目录</li><li><strong>/usr/local</strong>&emsp;软件安装目录，一般通过源码编译安装方式安装的软件都会存放于该目录下</li><li>/usr/include&emsp;放置如c/c++等程序语言的头文件(header)与包含档(include)</li><li>/usr/lib&emsp;放置各应用软件的函式库、目标文件等，如果使用的是X86_64的Linux系统，则可能会生成/usr/lib64文件夹</li></ul><h4 id="外部文件"><a href="#外部文件" class="headerlink" title="外部文件"></a>外部文件</h4><ul><li><strong>/media</strong>&emsp;挂载U盘、光驱等设备的目录，类似于windows的其他设备</li><li>/mnt&emsp;让用户挂载其他的文件系统，如将Windows上的某个目录挂载在/mnt下，可用于共享文件等</li></ul><h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><ul><li>/lost+found&emsp;一般情况下为空目录，用于存放系统非法关机或者发生意外错误后，fsck(磁盘修复)过程修复的部分文件</li><li>/tmp&emsp;用于存放临时文件</li><li>/run&emsp;一个临时文件系统，存放存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul><h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p>Linux系统的开机过程流程为：加载BIOS，进入Boot Loader，加载系统内核，进行内核初始化，启动初始化进程init。</p><p>可以使用<span class="tips">init 运行级别</span>在系统运行级别之间切换，使用<span class="tips">runlevel</span>查询当前运行级别。</p><div class="table"><table><thead><tr><th>运行级别(runlevel)</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>系统关机，禁止设置为系统默认运行级别</td></tr><tr><td>1</td><td>单用户状态，只启动系统核心，用于系统修复和维护</td></tr><tr><td>2</td><td>多用户状态，禁用NFS(网络文件系统)和网络服务，可用于停机维护</td></tr><tr><td>3</td><td>完全多用户状态，具有完整的功能</td></tr><tr><td>4</td><td>系统未使用，保留</td></tr><tr><td>5</td><td>GUI模式，桌面版Linux专属</td></tr><tr><td>6</td><td>系统重启，禁止设置为系统默认运行级别</td></tr><tr><td>emergency</td><td>用于系统救援</td></tr></tbody></table></div><p>在路径<span class="tips">/etc/rc.d</span>下存放有7个对应系统运行级别的目录<span class="tips">/rc0.d——rc6.d</span>，目录中列出了该运行级别下会启动/关闭的服务，init.d目录下存放有用户可以开机启动的脚本，对于以K(Kill)开头的文件，系统会关闭对应的服务，以S(Start)开头的文件，系统将启动对应的服务，并且启动/关闭次序为S/K之后的值。<span class="tips">rc.local</span>文件用于配置用户开机执行的命令，系统在启动后将自动执行该文件中的所有命令。</p><p>在一些旧版本的Linux中，/etc/rc.d路径下还含有<span class="tips">/etc/inittab</span>文件，文件中可以设置系统默认运行级别。centos7之后的系统将不再支持该方式修改默认级别，而使用target替代了sysvinit的运行级。</p><div class="table"><table><thead><tr><th>Sys v init runlevel</th><th>systemd target</th></tr></thead><tbody><tr><td>0</td><td>poweroff.target</td></tr><tr><td>1</td><td>rescue.target</td></tr><tr><td>2</td><td>multi-user.target</td></tr><tr><td>3</td><td>multi-user.target</td></tr><tr><td>4</td><td>multi-user.target</td></tr><tr><td>5</td><td>graphical.target</td></tr><tr><td>6</td><td>reboot.target</td></tr><tr><td>emergency</td><td>emergency.target</td></tr></tbody></table></div><div class="show">系统默认以启动runlevel3启动# systemctl set-default multi-user.target系统默认以启动runlevel5启动# systemctl set-default graphical.target查看当前运行级别# systemctl get-default</div><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>许多主流Linux系统默认使用的Shell(终端程序)是Bash(GNU Bourne-Again Shell)解释器，可以通过<span class="tips">上下方向键</span>来调取之前执行过的Linux命令，可以使用<span class="tips">Tab键</span>来补全命令、参数或文件名。</p><p>常见的执行Linux命令的格式为</p><p><span class="strong">命令  [参数] [对象]</span></p><ul><li>有多个可选参数时，可以写在一起</li><li>参数可以用长格式(完整的参数名称)并使用”-&zwnj;-“作为前缀，也可以用短格式（单个字母的缩写）使用”-“作为前缀。如：<span class="tips">-&zwnj;-help</span>和<span class="tips"> -h</span>，但有时短格式与长格式表示的不是同一个参数，如：shutdown -&zwnj;-help会显示shutdown命令的帮助信息,shutdown -h则为系统关机命令<div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>命令、参数与命令对象字母严格区分大小写</div></li></ul><h4 id="Linux的关闭与重启"><a href="#Linux的关闭与重启" class="headerlink" title="Linux的关闭与重启"></a>Linux的关闭与重启</h4><h5 id="1-sync-保存数据"><a href="#1-sync-保存数据" class="headerlink" title="1. sync 保存数据"></a>1. sync 保存数据</h5><p><span class="strong">sync</span>&emsp;将内存数据存储到磁盘，<span class="tips">关机或重启Linux前应当执行该命令防止数据丢失</span></p><h5 id="2-shutdown-命令-推荐使用"><a href="#2-shutdown-命令-推荐使用" class="headerlink" title="2.shutdown 命令(推荐使用)"></a>2.shutdown 命令(推荐使用)</h5><p>shutdown命令用于关闭/重启Linux，命令格式为</p><p> <span class="strong">   shutdown [选项] [时间] [警告消息]</span></p>常用选项<ul><li><span class="strong">-t 值</span>&emsp;设置在几秒后关机</li><li><span class="strong">-h</span>&emsp;关机</li><li><span class="strong">-r</span>&emsp;重启</li><li><span class="strong">-c</span>&emsp;取消已经设置的关机/重启命令</li><li>- m&emsp;强制杀死所有执行中的程序,然后关机(不调用init进程)</li><li>-k &emsp;不关机，仅把警告讯息传送给所有登录的用户</li><li>-f &emsp;强制略过fsck磁盘检测(unbuntu独有参数)</li><li>-F &emsp;强制进行fsck磁盘检测(unbuntu独有参数)</li><li>-w &emsp;测试使用，系统不会重启，但会把重新开机的数据写入/var/log目录下的wtmp记录文件</li><li>-H 或 --halt&emsp;&emsp;&emsp;相当于halt</li><li>-P 或 --poweroff&emsp;相当于poweroff</li><li>--no-wall &emsp;&emsp;&emsp;&emsp;系统在重启、关闭时不发送信息给登录的用户</li></ul><div class="show">示例：# shutdown -t 30        30s后关机# shutdown -h now       马上关机# shutdown -h 12:30     12:30关机，会占用终端# shutdown -h 12:30 &   12:30关机，关机命令会在后台处理不占用终端# shutdown -h 10 "System will shutdown after 10 minutes"    10分钟后关机并发送消息给用户# shutdown -r +10       10分钟后重启# shutdown -fr now      马上重启并强制略过fsck磁盘检测# shutdown -c           取消已设置的关机/重启命令</div><h5 id="3-halt-关机"><a href="#3-halt-关机" class="headerlink" title="3.halt 关机"></a>3.halt 关机</h5><p><span class="strong">halt [选项]</span></p><p>可选选项</p><ul><li>-d &emsp;不把关机记录写到 /var/log/wtmp 文件里</li><li>-n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)</li><li>-w &emsp;不会真的关机,只是把关机记录写到 /var/log/wtmp 文件里</li><li>-f &emsp;强制关机，不调用shutdown命令</li><li>-i &emsp;关机前关闭所有网络接口</li><li>-p &emsp;关机后关闭电源(poweroff)</li></ul><h5 id="4-reboot-重启"><a href="#4-reboot-重启" class="headerlink" title="4.reboot 重启"></a>4.reboot 重启</h5><p><span class="strong">reboot [选项]</span></p><p>可选选项</p><ul><li>-d &emsp;不把重启记录写到 /var/log/wtmp 文件里</li><li>-n &emsp;重启前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)</li><li>-w &emsp;不会真的重启,只是把重启记录写到 /var/log/wtmp 文件里</li><li>-f &emsp;强制重启，不调用shutdown命令</li><li>-i &emsp;重启前关闭所有网络接口</li></ul><h5 id="5-poweroff-关机并切断电源"><a href="#5-poweroff-关机并切断电源" class="headerlink" title="5.poweroff 关机并切断电源"></a>5.poweroff 关机并切断电源</h5><p><span class="strong">poweroff [选项]</span></p><p>可选选项</p><ul><li>-d &emsp;不把关机记录写到 /var/log/wtmp 文件里</li><li>-n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)</li><li>-w &emsp;不会真的关机,只是把关闭记录写到 /var/log/wtmp 文件里</li><li>-f &emsp;强制关闭</li><li>-i &emsp;关机前关闭所有网络接口</li><li>-h &emsp;关机前将系统中所有的硬件设置为备用模式<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>除了上述命令，还可以通过设置系统运行级别进行关机、重启。使用 <span class="tips">init 0 </span>关机，使用<span class="tips">init 6 </span>重启。</div></li></ul><h3 id="用户与组管理"><a href="#用户与组管理" class="headerlink" title="用户与组管理"></a>用户与组管理</h3><p>Linux系统是一个多用户多任务的分时操作系统，用户可以属于一个或多个组方便系统管理员控制用户权限，默认有一个root管理员组并且root账户属于该组。可以使用<span class="tips">logout</span>登出当前用户账户。</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><h5 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1. 添加用户"></a>1. 添加用户</h5><p><span class="strong">useradd [可选参数] 用户名</span></p><p>默认会在/home 目录下生成一个以用户名命名的文件夹作为用户的主文件夹，并且会生成一个与用户名同名的用户组。</p>可选参数：<ul><li>-c 注释 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;为用户添加一段注释性描述</li><li>-d /路径/目录名&emsp;&emsp;&emsp;自定义用户的主目录，即不使用与用户名同名的默认目录,如果该目录不存在，则可以同时使用-m参数来新建文件夹指定为主目录</li><li>-g 用户组 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户所属的初始用户组</li><li>-G 用户组，用户组 &emsp;指定用户所属的附加用户组</li><li>-s Shell文件 &emsp;&emsp;&emsp;&emsp;指定用户的登录Shell</li><li>-u 用户号 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户的用户号，可以添加-o选项来重复使用与其他用户相同的标识号<div class="show">示例：# useradd yg新增用户yg，同时会新建一个组yg# useradd -g gumu lmc新增用户lmc，并且将lmc添加到gumu组# useradd -d /somedir/user2dir -m user2新建用户user2，在 /somedir 文件夹下新建user2dir并将其主目录指定为user2dir (somedir文件夹必须存在，无法用上述命令直接新建)</div></li></ul><h5 id="2-给用户添加-修改密码"><a href="#2-给用户添加-修改密码" class="headerlink" title="2. 给用户添加/修改密码"></a>2. 给用户添加/修改密码</h5><p><span class="strong">passwd [可选参数] [用户名]</span><br>不写用户名则会修改当前账户密码，输入密码时不会显示在终端上,可选参数：</p><ul><li>-l &emsp;锁定口令，禁止用户自行修改(参数为小写L)</li><li>-u &emsp;解锁口令，允许用户自行修改</li><li>-S &emsp;显示密码信息</li><li>-d &emsp;删除账户口令</li><li>-f &emsp;强迫用户下次登录时必须修改口令</li><li>-x &emsp;指定口令最长存活期</li><li>-k &emsp;    保留即将过期的用户在期满后能仍能使用</li></ul><h5 id="3-删除用户"><a href="#3-删除用户" class="headerlink" title="3. 删除用户"></a>3. 删除用户</h5><p>只能在root账户下删除用户</p><ul><li><span class="strong">userdel 用户名</span>&emsp;删除用户但保留用户的主目录</li><li> <span class="strong">userdel -r 用户名</span>&emsp;删除用户且不保留用户主目录</li></ul><h5 id="4-查询用户信息"><a href="#4-查询用户信息" class="headerlink" title="4. 查询用户信息"></a>4. 查询用户信息</h5><p><span class="strong">id 用户名</span><br>查询是否有该用户，有则返回用户号(uid)、组号(gid)、所属组名</p><h5 id="5-切换用户"><a href="#5-切换用户" class="headerlink" title="5. 切换用户"></a>5. 切换用户</h5><p><span class="strong">su [可选参数] 用户名</span><br>从权限高的账户切换到权限低的用户不需要输入密码，反之需要。切换完用户后，可通过 <span class="tips">exit</span> 命令返回原来的用户</p><ul><li>-&emsp; 使用”-“在切换用户时会连带切换用户环境，如:家目录，用户邮箱等</li><li>-c 命令 &emsp;仅切换到该用户执行一次-c后的命令<div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>仅使用 <span class="tips">su 用户名</span> 不会切换用户环境，在很多使用场景中会报错，推荐使用<span class="tips">su - 用户名</span>命令</div></li></ul><h5 id="6-修改用户信息"><a href="#6-修改用户信息" class="headerlink" title="6. 修改用户信息"></a>6. 修改用户信息</h5><p><span class="strong">usermod [可选参数] 用户名</span></p><ul><li>-u UID &emsp;修改用户UID</li><li>-c 用户说明 &emsp;修改用户说明信息</li><li>-G 组名 &emsp; 修改用户附加组</li><li>-L &emsp;&emsp;临时锁定用户</li><li>-U &emsp;&emsp;解锁用户</li></ul><h5 id="7-修改用户密码状态"><a href="#7-修改用户密码状态" class="headerlink" title="7. 修改用户密码状态"></a>7. 修改用户密码状态</h5><p><span class="strong">chage [可选参数] 用户名</span></p><ul><li>-l  &emsp;&emsp;列出用户详细密码状态</li><li>-d 日期 &emsp;修改密码最后一次修改日期(修改shadow文件字段3)</li><li>-m 天数 &emsp; 两次密码修改间隔(字段4)</li><li>-M 天数 &emsp;&emsp;密码有效期(字段5)</li><li>-W 天数 &emsp;&emsp;密码过期前警告天数(字段6)</li><li>-I 天数 &emsp;&emsp;密码过期后宽限天数(字段7)</li><li>-E 日期 &emsp;&emsp;账号失效时间(字段8)<div class="show">使用：# chage -d 0 user1强制用户user1下次登录修改密码</div></li></ul><h5 id="8-查看当前所有登录用户"><a href="#8-查看当前所有登录用户" class="headerlink" title="8. 查看当前所有登录用户"></a>8. 查看当前所有登录用户</h5><h6 id="8-1-查看当前使用的账户"><a href="#8-1-查看当前使用的账户" class="headerlink" title="8.1 查看当前使用的账户"></a>8.1 查看当前使用的账户</h6><p><span class="strong">whoami 或 who am i</span></p><h6 id="8-2-查看当前登录的用户"><a href="#8-2-查看当前登录的用户" class="headerlink" title="8.2 查看当前登录的用户"></a>8.2 查看当前登录的用户</h6><p><span class="strong">who</span></p><p>会返回登录用户名、登录终端、登陆时间(远程登录还有IP地址)，登录终端中tty表示本地登录终端，pts一般为远程登录。</p><p> <span class="strong">w</span></p><p>会返回更详细的登录信息。</p><div class="show">w命令返回值解析：15:20:10 up 25 days, 15:25,  1 user,  load average: 0.00, 0.00, 0.00USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATroot     pts/0    180.129.129.129  10:09    0.00s  0.04s  0.04s -bash第一行为登录时间，up后为linux运行时间，用户数量，服务器负载情况第二行IDLE为用户已经空闲时间，JCPU为用户累计CPU占用时间，PCPU为用户当前命令操作占用CPU时间，WHAT为用户操作</div><h4 id="用户的相关文件"><a href="#用户的相关文件" class="headerlink" title="用户的相关文件"></a>用户的相关文件</h4><p>Linux通过用户配置文件来查看和修改用户信息</p><h5 id="1-用户的信息文件"><a href="#1-用户的信息文件" class="headerlink" title="1. 用户的信息文件"></a>1. 用户的信息文件</h5><p>文件位于<span class="tips">/etc/passwd</span>，每一行代表一个用户，并且以</p><div class="show"><span class="tips">用户名:密码标识:用户UID:用户初始组GID:用户说明:家目录:登录的Shell</span></div>格式书写用户信息<ul><li><p>密码标识中，有 X 表示用户有密码，用户登录时linux会前往/etc/shadow查找密码</p></li><li><p>用户UID：0 为超级管理员用户，1-1000为系统用户，系统用户为ftp等由linux调用的用户，无法登录，修改可能会导致系统无法启动，1000以上为普通用户(旧版本的linux可能1-500为系统用户)</p></li><li><p>用户说明可以为空</p></li><li><p>用户登录shell一般默认为/bin/bash，系统用户为/sbin/nologin,可以将普通用户的shell更改为/sbin/nologin来禁止用户登录</p><h4 id="2-用户的密码文件"><a href="#2-用户的密码文件" class="headerlink" title="2. 用户的密码文件"></a>2. 用户的密码文件</h4><p>文件位于<span class="tips">/etc/shadow</span>，保存了加密后的用户密码等信息，每一行代表一个用户，如：</p><div class="show">swv:$6$hPQczrTV$urGtx/wXaOtfIKdyuD/aUO.tHogxBM7uie4ioSbyVgcpNS3Po.:19032:0:99999:7:::</div></li><li><p>字段一：用户名</p></li><li><p>字段二：加密后的密码，如果为”!!”或”*”表示没有密码，无法登录</p></li><li><p>字段三：密码最后一次修改日期，以1970年1月1日作为标准时间，每天+1</p></li><li><p>字段四：允许的两次密码修改间隔，如：10为只允许每10天修改一次密码</p></li><li><p>字段五：密码有效期</p></li><li><p>字段六：密码到期提前警告时间</p></li><li><p>字段七：密码到期后仍然可使用时间，如：3为还可以使用3天，其中0代表到期立马失效，-1代表到期后仍然能永久使用</p></li><li><p>字段八：账号失效时间，使用时间戳(到期时间与1970-1-1的间隔天数)表示</p></li><li><p>字段九：保留字段(未使用)</p></li></ul><h4 id="3-用户的邮箱文件"><a href="#3-用户的邮箱文件" class="headerlink" title="3. 用户的邮箱文件"></a>3. 用户的邮箱文件</h4><p>文件位于<span class="tips">/var/spool/mail/用户名/</span>，Linux用户可以相互发送内部邮件</p><h4 id="4-用户模板目录"><a href="#4-用户模板目录" class="headerlink" title="4. 用户模板目录"></a>4. 用户模板目录</h4><p>文件位于<span class="tips">/etc/skel/</span>，用于制作一个模板文件，在新注册用户时会在用户家目录下自动生成该文件。如：给每个账户生成一个用户操作手册。</p><h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><p>用户组方便系统对同一类型的用户进行管理，对用户组的修改实际上就是对/etc/group文件的更新。</p><h5 id="1-增加组"><a href="#1-增加组" class="headerlink" title="1. 增加组"></a>1. 增加组</h5><p><span class="strong">groupadd [可选参数] 组名</span><br>可选参数：</p><ul><li>-g GID &emsp;指定新用户组的组标识号（GID）</li><li>-o &emsp;&emsp;&emsp;一般与-g参数同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><h5 id="2-修改用户组"><a href="#2-修改用户组" class="headerlink" title="2.修改用户组"></a>2.修改用户组</h5><p><span class="strong">groupmod [可选参数] 组名</sapn></p><ul><li>-g GID &emsp;修改组ID</li><li>-n 新组名&emsp;修改组名</li></ul><h5 id="3-删除用户组"><a href="#3-删除用户组" class="headerlink" title="3. 删除用户组"></a>3. 删除用户组</h5><p><span class="strong">groupdel 组名</span><br>如果组中有初始用户，该组无法删除(以避免用户不属于任何一个组，想删除该组可以先删除该初始用户的账户)，若组中都为附加用户则可以删除。</p><h5 id="4-把用户添加入组或从组中删除"><a href="#4-把用户添加入组或从组中删除" class="headerlink" title="4. 把用户添加入组或从组中删除"></a>4. 把用户添加入组或从组中删除</h5><p><span class="strong">gpasswd 必选参数 组名</sapn></p><ul><li>-a 用户名&emsp;把用户加入组中</li><li>-d 用户名&emsp;把用户从组中删除</li></ul><h4 id="用户组的配置文件"><a href="#用户组的配置文件" class="headerlink" title="用户组的配置文件"></a>用户组的配置文件</h4><h5 id="1-用户组的信息文件"><a href="#1-用户组的信息文件" class="headerlink" title="1. 用户组的信息文件"></a>1. 用户组的信息文件</h5><p>组信息文件位于<span class="tips">/etc/group</span>，信息格式为：</p><div class="show"><span class="tips">组名:组密码标识:组GID:组中的附加用户</span></div>字段说明同用户配置文件类似<h5 id="2-组密码文件"><a href="#2-组密码文件" class="headerlink" title="2. 组密码文件"></a>2. 组密码文件</h5><p>文件位于<span class="tips">/etc/gshadow</span>，密码文件书写格式为：</p><div class="show"><span class="tips">组名:组密码:组管理员用户名:组中的附加用户</span></div>配置如上,该文件不常用]]></content>
    
    
    <summary type="html">包括Linux系统文件介绍，系统运行级别介绍，用户与用户组管理，用户身份切换</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="command" scheme="https://shiwei11.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>vim笔记</title>
    <link href="https://shiwei11.github.io/blog/2021/06/15/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://shiwei11.github.io/blog/2021/06/15/vim%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2021-06-14T18:22:18.000Z</published>
    <updated>2022-07-14T17:48:29.447Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>第一次接触到vim时连字都不会打...后来在某管乱逛的时候看到两个Google的<del> 秃头 </del>工程师用vim花式结对编程时，vim就深深折服了我，那效率真是芜湖~，谁不想有个这样的<del> jiyou </del>普通朋友来次愉快的多线程交流呢<span  style="white-space: nowrap;">๑乛◡乛๑</span></div><h3 id="vi-与-vim-简介"><a href="#vi-与-vim-简介" class="headerlink" title="vi 与 vim 简介"></a>vi 与 vim 简介</h3><p><span class="strong">vi:</span>为 visual interface 的简称，是<span class="tips">Linux</span>操作系统中最经典的文本编辑器。</p><p><span class="strong">vim:</span>全称为vi improved，从vi 发展而来的文本编辑器，支持代码补全、编译、错误跳转等功能。在很多Linux发行版中，直接预装有vim编辑器，vim本身也发布了支持Windows、Unix、MacOS等不同操作系统的编辑器版本，并且很多优秀的IDE都有支持vim的插件，因此使用vim命令可以在各种操作系统环境下高效编辑代码/文本。</p><p><span class="tips">vim官方网站：<a href="https://www.vim.org/" target="_blank">https://www.vim.org/</a></span></p><ul>vim的特点:<li>熟练掌握vim以后可以极大地提高编辑速率</li><li>所有操作可以靠键盘完成，免去了键盘鼠标来回切换的时间</li><li>甚至于在部分终端中不支持鼠标操作，无UI界面，所有操作靠命令</li><li>无花里胡哨的排版功能，但有很多花里胡哨的的插件可以玩</li><li>命令操作一切</li><li>大多数服务器默认安装</li></ul><h3 id="vim-的三种工作模式"><a href="#vim-的三种工作模式" class="headerlink" title="vim 的三种工作模式"></a>vim 的三种工作模式</h3><p>不同文档对命令、工作模式的翻译可能不同，不过在vim中操作是一样的</p><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><p>打开文件会首先进入命令模式，是 vim 使用的入口。该模式下可对文件内容进行基本的快捷操作，如：定位、翻页、复制、粘贴、删除等</p><p>在命令模式下输入<span class="tips">i</span>进入编辑模式，进入编辑模式后按下<span class="tips">esc</span>返回命令模式</p><p>在命令模式下输入<span class="tips">:</span>进入末行模式，进入末行模式后按下<span class="tips">esc</span>返回命令模式</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>使用I、o、a等命令也可进入编辑模式，具体用法详见插入命令。</div><h5 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h5><p>在vim最底部输入命令的模式，也是vim 的出口，当要退出 vim 返回控制台时，需要在末行模式下输入命令。该模式下可对文件整体进行基本的操作，如：保存、退出、另存、搜索与替换等操作。</p><p>末行模式下输入<span class="tips">wq</span>可快速保存并关闭文件</p><h5 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h5><p>用于编辑文件具体内容的模式</p><h5 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h5><p>还有<span class="tips">可视模式</span>、<span class="tips">替换模式</span>两个用于选取字符、替换内容等具体操作的模式</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="打开与新建文件"><a href="#打开与新建文件" class="headerlink" title="打开与新建文件"></a>打开与新建文件</h4><ul><li><span class="strong">vim 文件名</span> 打开/新建文件</li><li><span class="strong">vim 文件名 +行号</span> 打开文件并跳转到对应行号</li><li><span class="strong">vim 文件名 +</span>打开文件并跳转到文件末尾</li><li><span class="strong">vim 文件名1 文件名2 ... </span>同时打开多个文件</li></ul><p>使用命令时，若文件名对应的文件存在，则会用vim编辑器打开该文件，若文件不存在，则会新建一个文件。打开多个文件时，默认显示第一个文件，可以通过命令<span class="tips">:ls</span>让vim列出所有打开的文件，使用<span class="tips">:b数字</span>来使对应序号的文件显示在屏幕上。</p><h4 id="保存与退出-末行模式下"><a href="#保存与退出-末行模式下" class="headerlink" title="保存与退出(末行模式下)"></a>保存与退出(末行模式下)</h4><p>需要先切换到末行模式下，因此下述命令前的<span class="tips"> : </span>号用于换到末行模式</p><ul><li><span class="strong">:w </span>保存</li><li><span class="strong">:w! </span>强制保存</li><li><span class="strong">:q </span>退出，如果没有保存则不允许退出</li><li><span class="strong">:q! </span>不保存，强制退出</li><li><span class="strong">:wq </span>保存并退出</li><li><span class="strong">:x </span>保存并退出</li></ul><p>更多末行模式下的命令在末行模式下的命令小节</p><h4 id="异常退出"><a href="#异常退出" class="headerlink" title="异常退出"></a>异常退出</h4><p>如果 vim 异常退出，会为当前编辑但尚未保存的文件创建一个后缀名为<span class="tips">.swp</span>的<span class="tips">交换文件</span>,该文件默认隐藏，下次打开未保存的文件会询问如何进行操作，可以根据vim提示选择恢复、直接编辑等操作。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="移动光标与选取文本"><a href="#移动光标与选取文本" class="headerlink" title="移动光标与选取文本"></a>移动光标与选取文本</h4><h5 id="上上下下左左右右-BABA"><a href="#上上下下左左右右-BABA" class="headerlink" title="上上下下左左右右 BABA"></a>上上下下左左右右 BABA</h5><ul><li><span class="strong">h&emsp;&emsp;向左</span></li><li><span class="strong">j &emsp;&emsp;向下</span></li><li><span class="strong">k&emsp;&emsp;向上</span></li><li><span class="strong">l &emsp;&emsp;向右</span></li></ul><h5 id="行内移动"><a href="#行内移动" class="headerlink" title="行内移动"></a>行内移动</h5><ul><li><span class="strong">w&emsp;&emsp;移动到下一个单词开头</span>(word)</li><li><span class="strong">b &emsp;&emsp;向前移动一个单词</span>(back)</li><li><span class="strong">0 &emsp;&emsp;行首</span></li><li><span class="strong">^ &emsp;&emsp;行首，第一个不是空白的字符位置</span></li><li><span class="strong">$ &emsp;&emsp;行尾</span></li><li><span class="strong">g_ &emsp;&emsp;行尾,最后一个不是空白的字符位置</span></li><li>&nbsp; e &emsp;&emsp;下一个单词结尾</li><li>&nbsp; f字符&emsp;&emsp;下一个对应字符位置</li><li>&nbsp; nf字符&emsp;&emsp;下n个对应字符位置</li><li>&nbsp; F字符&emsp;&emsp;上一个对应字符位置</li><li>&nbsp; nF字符&emsp;&emsp;上n个对应字符位置</li><li>&nbsp; t字符&emsp;&emsp;下一个该字符的前一个字符位置</li><li>&nbsp; nt字符&emsp;&emsp;下n个该字符的前一个字符位置</li><li>&nbsp; T字符&emsp;&emsp;上一个该字符的后一个字符位置</li><li>&nbsp; nT字符&emsp;&emsp;上n个字符的后一个字符位置</li></ul><p>当使用f、F、t、T关键字跳转时，使用 ; 可以快速跳转到下一个指定字符，使用 , 可以跳转到上一个指定字符。</p><h5 id="行间移动"><a href="#行间移动" class="headerlink" title="行间移动"></a>行间移动</h5><ul><li><span class="strong">gg&emsp;&emsp;&emsp;&emsp;跳转到文件第一行行首</span></li><li><span class="strong">G &emsp;&emsp;&emsp;&emsp;&nbsp;跳转到文件最后一行行首</span></li><li><span class="strong">数字gg&emsp;&emsp;跳转到数字对应行数</span></li><li><span class="strong">数字G &emsp;&emsp;&nbsp;跳转到数字对应行的行首</span></li><li><span class="strong">: 数字 &emsp;&emsp;&emsp;跳转到数字对应行数</span></li></ul><h5 id="屏幕内移动"><a href="#屏幕内移动" class="headerlink" title="屏幕内移动"></a>屏幕内移动</h5><ul><li><span class="strong">Ctrl+b&emsp;&emsp;&emsp;向上翻页</span>(back)</li><li><span class="strong">Ctrl+f &emsp;&emsp;&emsp;向下翻页</span>(forward)</li><li><span class="strong">H &emsp; &emsp;&emsp;&emsp;&emsp;当前屏幕第一行行首</span>(Head)</li><li><span class="strong">M&emsp; &emsp;&emsp;&emsp;&emsp;屏幕中间</span>(Middle)</li><li><span class="strong">L &emsp; &emsp; &emsp;&emsp;&emsp;屏幕底部</span>(Low)</li><li><span class="strong">zt &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕顶部</span></li><li><span class="strong">zz &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕中央</span></li><li><span class="strong">zb &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕尾部</span></li></ul><h5 id="段落切换"><a href="#段落切换" class="headerlink" title="段落切换"></a>段落切换</h5><p>vim 中以<span class="tips">空白行</span>来区分段落，开发程序时将同一个功能相关的代码写在一起，不留空行。而在不同功能间留下空白行方便切换。</p><ul><li><span class="strong">{&emsp;&emsp;上一个段落</span></li><li><span class="strong">}&emsp;&emsp;下一个段落</span></li></ul><h5 id="括号间切换"><a href="#括号间切换" class="headerlink" title="括号间切换"></a>括号间切换</h5><p>用于在程序中出现频率很高的<span class="tips">( )</span>、<span class="tips">[ ]</span>、<span class="tips">{ }</span>间切换，需要先把光标移动到其中一个括号上，然后使用%可切换到与其匹配的另外一边括号</p><ul><li><span class="strong">%&emsp;&emsp;括号匹配及切换</span></li></ul><h5 id="添加标记与跳转"><a href="#添加标记与跳转" class="headerlink" title="添加标记与跳转"></a>添加标记与跳转</h5><p>在开发时，某段代码可能需要稍后处理，此时可用标记功能并在稍后快速跳转。</p><ul><li><span class="strong">m字母&emsp;&emsp; &emsp; &emsp;添加标记，字母可用a-z或A-Z间的任意字母</span>(mark)</li><li><span class="strong">' 标记的字母&emsp;&emsp;跳转到该字母标记的行首</span>(英文单引号)</li><li><span class="strong">`标记的字母&emsp;&emsp;跳转到该字母标记处</span>(esc下的撇号)</li><li><span class="strong">:marks&emsp;&emsp;列出所有标记</span></li><li><span class="strong">:delmarks 标记名 标记名....&emsp;&emsp;删除对应标记名</span>(可单个删除可多个删除)</li><li><span class="strong">:delmarks!&emsp;&emsp;删除所有小写字母标记</span></li></ul><p><span class="tips">大写字母标记符可以实现文件间的跳转,因此大写字母通常用于文件间的标记</span></p><p><span class="tips">如果添加标记的行被删除，标记也将被删除。</span></p><p><span class="tips">如果其他行添加了同名标记，之前添加的标记将被替换掉。</span></p><h5 id="选中文本-可视模式"><a href="#选中文本-可视模式" class="headerlink" title="选中文本(可视模式)"></a>选中文本(可视模式)</h5><p>在命令模式下使用下列命令可切换到<span class="tips">可视模式</span>，vim 有三种可视模式。</p><p>可视模式通过与光标移动命令搭配使用来选取文本，如：<span class="tips">ggVG</span>可用于选中所有文本，选取的文本可通过<span class="tips">esc</span>放弃选中并返回命令模式。</p><ul><li><span class="strong">v(常规可视模式)&emsp;&emsp; &emsp;选中光标经过的所有文本</span></li><li><span class="strong">V(可视行模式)&emsp;&emsp;&emsp;&emsp;整行选中光标经过的所有文本</span></li><li><span class="strong">Ctrl+v(可视块模式)&emsp;&emsp;垂直方向选中文本</span>(类似于vscode的shift+Alt+鼠标点击，用于多行输入/删除)</li></ul><h4 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h4><h5 id="撤销与恢复撤销"><a href="#撤销与恢复撤销" class="headerlink" title="撤销与恢复撤销"></a>撤销与恢复撤销</h5><p>用于撤销错误的编辑操作，或者恢复撤销的命令,<span class="tips">可用多次使用!</span></p><ul><li><span class="strong">u&emsp;&emsp; &emsp; &emsp;撤销上一个命令</span>(undo)</li><li><span class="strong">Ctrl+r&emsp;&emsp;恢复撤销的命令</span>(redo)</li></ul><h5 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h5><ul><li><span class="strong">x&emsp; &emsp; &emsp; &emsp; &emsp;删除光标所在字符或选中的文本</span>(cut)</li><li><span class="strong">d移动命令&emsp;&emsp;删除移动命令对应的内容</span>(delete)</li><li><span class="strong">dd&emsp;&emsp;&emsp;&emsp; &emsp;删除光标所在行</span></li><li><span class="strong">D&emsp; &emsp; &emsp;&emsp; &emsp;删除光标至行尾间的内容</span></li><li><span class="strong">:n1,n2d&emsp;&emsp;&emsp;多行删除,n1为起始行号，n2为结束行号</span>(末行模式下)</li></ul><p>删除命令与移动命令的常用组合</p><ul><li>dw &emsp; &emsp;&emsp; 从光标位置删除到单词末尾</li><li>dnw &emsp; &emsp;&emsp; 删除n个单词</li><li>df字符 &emsp; &emsp;从光标处删除到下一个该字符处</li><li>d$ &emsp; &emsp;&emsp; 删除光标到本行末尾</li><li>d0 &emsp; &emsp; &emsp;从光标位置删除到该行起始位置(光标前该行的所有内容)</li><li>d} &emsp; &emsp; &emsp; 从光标位置删除到段落结尾</li><li>ndd &emsp; &emsp;&emsp;从光标位置向下连续删除 n 行</li><li>d行号G &emsp;&emsp;删除光标所在行到指定代码行之间的所有内容</li><li>d'标记符&emsp;&emsp;从光标所在行删除到标记符之间的所有代码</li><li>dH &emsp; &emsp;&emsp; 删除屏幕第一行到光标所在行</li><li>dG &emsp; &emsp;&emsp; 删除光标所在行到文件结束</li></ul><h5 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h5><p>vim提供一个用于保存被复制、删除文本的缓冲区</p><p> <span class="tips">复制</span>命令会将选中的文字保存在该缓冲区<p><p> <span class="tips">删除</span>命令会将删除内容保存在该缓冲区<p><p> <span class="tips">粘贴</span>命令会将缓冲区内容插入光标所在位置<p><ul><li><span class="strong">y移动命令&emsp;&emsp;复制</span>(copy)</li><li><span class="strong">yy &emsp;&emsp;&emsp;&emsp;&emsp;复制一行,nyy会复制n行</span>(copy)</li><li><span class="strong">y$ &emsp;&emsp;&emsp;&emsp;&emsp;复制光标到本行结尾</span></li><li><span class="strong">yH &emsp;&emsp;&emsp;&emsp;&emsp;复制屏幕第一行到光标所在行</span></li><li><span class="strong">yG &emsp;&emsp;&emsp;&emsp;&emsp;复制光标所在行到文件结束</span></li><li><span class="strong">p &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之后</span>(paste)</li><li><span class="strong">P &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之前</span>(paste)</li></ul><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>vim中的文本缓冲区只有一个，后续做过复制、删除命令操作后，之前缓冲区中的内容会被替换</div><h5 id="输入替换-替换模式"><a href="#输入替换-替换模式" class="headerlink" title="输入替换(替换模式)"></a>输入替换(替换模式)</h5><p><span class="tips">r</span>命令用于轻量级修改,不需要进入替换模式</p><p><span class="tips">R</span>可进入替换模式，修改完成后通过<span class="tips">esc</span>返回命令模式</p><ul><li><span class="strong">r &emsp;&emsp;替换当前字符</span>(replace)命令模式</li><li><span class="strong">R&emsp;&emsp;替换当前行光标后的所有字符</span>(replace)替换模式</li></ul><h5 id="缩排和重复执行"><a href="#缩排和重复执行" class="headerlink" title="缩排和重复执行"></a>缩排和重复执行</h5><p>用于编排代码格式</p><ul><li><span class="strong">&gt;&gt; &emsp;&emsp;向右增加缩进</span>(增加4个空格)</li><li><span class="strong">&lt;&lt; &emsp;&emsp;向左减少缩进</span>(减少4个空格)</li><li><span class="strong"> . &emsp;&emsp;&emsp;重复上次命令</span></li></ul><p>在<span class="tips">可视模式</span>下，缩排命令只需一个<span class="tips">&gt;</span>、<span class="tips">&lt;</span>即可。缩排一次后，用<span class="tips"> . </span>命令执行多次缩排快速进行排版</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><h6 id="1-指定字符查找"><a href="#1-指定字符查找" class="headerlink" title="1.指定字符查找"></a>1.指定字符查找</h6><ul><li><span class="strong">/字符 &emsp;&emsp;查找指定的字符</span></li></ul><p>输入查找内容后回车，vim会高亮找到的内容，此时可使用<span class="tips">n/N</span>命令跳转</p><ul><li><span class="strong">n &emsp;&emsp;查找上一个</span>(next)</li><li><span class="strong">N &emsp;&emsp;查找下一个</span>(next)</li></ul><h6 id="2-快速匹配单词"><a href="#2-快速匹配单词" class="headerlink" title="2.快速匹配单词"></a>2.快速匹配单词</h6><ul><li><span class="strong">* &emsp;&emsp;向后查找光标所在单词</span></li><li><span class="strong">N &emsp;&emsp;向前查找光标所在单词</span></li></ul><P></P>直接按上述键，vim会识别当前光标所在的单词，然后查找相同的单词<div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>vim会高亮显示查找到的内容，若想取消高亮显示，使用<span class="tips">/字符</span>命令查找一个不存在的字符串将取消高亮显示。<span class="tips">搜索支持正则表达式 !</span></div><h5 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h5><p>替换指定的内容，vim中查找并替换命令需要在<span class="tips">末行模式</span>下执行，语法组成为<span class="tips">:作用范围s/替换内容/新内容/标识符</span>,标识符可由下列3类自由组成。</p><p><span class="tips">i</span>表示大小写不敏感查找</p><p><span class="tips">I</span>表示大小写敏感查找</p><p><span class="tips">g</span>指定区域中找到的所有目标</p><p><span class="tips">c</span>替换前需确认</p><h6 id="1-仅替换第一个目标"><a href="#1-仅替换第一个目标" class="headerlink" title="1.仅替换第一个目标"></a>1.仅替换第一个目标</h6><ul><li><span class="strong">:s/替换内容/新内容&emsp;&emsp;仅替换当前行中的第一个目标内容</span></li><li><span class="strong">:%s/替换内容/新内容&emsp;&emsp;替换文件中所有行的第一个目标内容</span></li></ul><h6 id="2-文件全局替换"><a href="#2-文件全局替换" class="headerlink" title="2.文件全局替换"></a>2.文件全局替换</h6><ul><li><span class="strong">:%s/替换内容/新内容/g&emsp;&emsp;全局替换</span></li></ul>一次性替换整个文件中的所有指定内容<h6 id="3-局部替换"><a href="#3-局部替换" class="headerlink" title="3.局部替换"></a>3.局部替换</h6><ul><li><span class="strong">:s/替换内容/新内容/g&emsp;&emsp;替换当前行中的所有目标内容</span></li><li><span class="strong">:行号1,行号2s/替换内容/新内容/g&emsp;&emsp;替换行号1到行号2之间的所有目标内容</span></li></ul><h6 id="4-在选取内容中替换-可视模式下"><a href="#4-在选取内容中替换-可视模式下" class="headerlink" title="4.在选取内容中替换(可视模式下)"></a>4.在选取内容中替换(可视模式下)</h6><p>只替换选中区域中的指定内容，需要在可视模式下先选中需要替换的区域，选取区域后输入<span class="tips">:</span>,vim会自动补全为<span class="tips">:’&lt;,&gt;’</span>，完整语法为:</p><ul><li><span class="strong">:'<,>'s/替换内容/新内容/g&emsp;&emsp;替换选择区域中的所有目标</span></li></ul><h6 id="5-确认替换-使用标识符c时"><a href="#5-确认替换-使用标识符c时" class="headerlink" title="5.确认替换(使用标识符c时)"></a>5.确认替换(使用标识符c时)</h6><p>进行替换操作时会依次询问每一个内容是否要替换，可依次选择每个目标是否替换然后退出，或执行全部替换。</p><ul><li><span class="strong">:s/替换内容/新内容/gc&emsp;&emsp;确认替换</span>(comfirm)</li></ul><p>确认/取消替换命令:</p><ol><li><span class="strong">y&emsp;&emsp;替换</span>(yes)</li><li><span class="strong">n&emsp;&emsp;不替换</span>(no)</li><li><span class="strong">a&emsp;&emsp;替换所有</span>(all)</li><li><span class="strong">q&emsp;&emsp;退出替换</span>(quit)</li><li> l &emsp;&emsp;最后一个，并把光标移动到行首(last)</li><li>^E&emsp;&emsp;向下滚屏</li><li>^Y&emsp;&emsp;向上滚屏</li></ol><h5 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h5><p>用于进入编辑模式</p><ul><li><span class="strong">i&emsp;&emsp;在当前字符前插入文本</span>(insert)</li><li><span class="strong">I&emsp;&emsp;在行首插入文本</span>(insert)</li><li><span class="strong">a&emsp;&emsp;在当前字符后插入文本</span>(append)</li><li><span class="strong">A&emsp;&emsp;在行末插入文本</span>(append)</li><li><span class="strong">o&emsp;&emsp;在当前行后插入一个空行</span></li><li><span class="strong">O&emsp;&emsp;在当前行前插入一个空行</span></li><li><span class="strong">s&emsp;&emsp;删除光标所在字符然后插入文本</span></li><li><span class="strong">S&emsp;&emsp;删除光标所行然后插入文本</span></li><li><span class="strong">cw&emsp;&emsp;删除光标所在单词然后插入文本</span></li></ul><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><ul><li><span class="strong">~&emsp;&emsp;改变光标所在字母大小写</span></li><li><span class="strong">n~&emsp;&emsp;改变光标开始的n个字母大小写</span></li><li><span class="strong">g~~&emsp;&emsp;改变当前行字母大小写</span></li><li><span class="strong">gUU&emsp;&emsp;将当前行字母改成大写</span></li><li><span class="strong">guu&emsp;&emsp;将当前行字母改成小写</span></li><li><span class="strong">ngUU&emsp;&emsp;将光标所在行开始的后n行改成大写</span></li><li><span class="strong">gUw&emsp;&emsp;将光标所处单词改成大写</span></li><li><span class="strong">guw&emsp;&emsp;将光标所处单词改成小写</span></li></ul><h3 id="重复执行命令"><a href="#重复执行命令" class="headerlink" title="重复执行命令"></a>重复执行命令</h3><h5 id="数字-命令的组合会让部分命令执行指定次数"><a href="#数字-命令的组合会让部分命令执行指定次数" class="headerlink" title="数字+命令的组合会让部分命令执行指定次数"></a><span class="tips">数字+命令的组合会让部分命令执行指定次数</span></h5><div class="code">如：10x  删除光标后的10个字符10>>  让光标后的10行文本进行缩进10yy  复制10行内容</div><div class="show">如：输入10个相同的字符串执行步骤1. 在命令模式下输入102. 输入i进入编辑模式3. 输入需要重复的字符串4. 输入完毕后esc返回命令模式，vim会把输入字符这个命令执行10次</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>以上原因，在进入编辑模式前，尽量不要触碰数字，否则可能导致命令的重复执行</div><h5 id="执行某个命令后使用-号可重复执行该命令"><a href="#执行某个命令后使用-号可重复执行该命令" class="headerlink" title="执行某个命令后使用 . 号可重复执行该命令"></a><span class="tips">执行某个命令后使用 . 号可重复执行该命令</span></h5><div class="code">如：dd 删除光标当前所在行后之后每使用一次 . 会删除一行</div><h5 id="运用举例"><a href="#运用举例" class="headerlink" title="运用举例"></a>运用举例</h5><div class="show">利用可视块将多行文本改为注释(注释符号为:#)执行步骤1. 移动光标到要添加注释的第一行代码，使用^定位到行首2. 使用Ctrl+v进入可视块模式3. 使用I进入编辑模式,并输入#。注：可视块模式下使用i插入无效4. 输入完毕后esc返回命令模式，vim会把选中的每一行文本前都插入#</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao">注意</div>重复执行只对部分命令有效，而对如 u(撤销)命令无效，vim依旧会重复执行u 命令前执行的命令。</div><h3 id="末行模式下的命令"><a href="#末行模式下的命令" class="headerlink" title="末行模式下的命令"></a>末行模式下的命令</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>末行命令主要用于文件的保存、退出、搜索与替换，以及浏览、新建、另存文件等操作</p><ul><li><span class="strong">:e.&emsp;&emsp;打开内置文件浏览器，浏览当前目录下的文件</span></li><li><span class="strong">:e 文件名&emsp;&emsp;打开另外一个文件并切换到其中</span>(edit)</li><li><span class="strong">:e!&emsp;&emsp;放弃对所有文件的修改，恢复文件到上次保存的位置</span></li><li><span class="strong">:n 文件名&emsp;&emsp;新建文件</span>(new)</li><li><span class="strong">:w 文件名&emsp;&emsp;保存当前文件修改到对应文件中(没有时会新建)</span>(write)</li><li><span class="strong">:saveas 文件名 &emsp;另存为新文件</span></li><li><span class="strong">:bn&emsp;切换到上一个文件</span>(打开多个文件时)</li><li><span class="strong">:bp&emsp;切换到下一个文件</span>(打开多个文件时)</li></ul><p>切换文件时若当前文件未保存时不能切换，但可用!强制执行。文件另存为操作不会将编辑界面跳转到新另存的文件里，依旧会在当前文件编辑界面中。</p><p>输入文件名时，输入部分文件名后按下<span class="tips">Tab</span>键，vim会提示文件名</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ul><li><span class="strong">:set nu&emsp;&emsp;显示行号</span></li><li><span class="strong">:set nonu&emsp;&emsp;取消行号显示</span></li><li><span class="strong">:数字&emsp;&emsp;定位到对应的行</span></li><li><span class="strong">:set ic&emsp;&emsp;不区分大小写</span></li><li><span class="strong">:set noic&emsp;&emsp;区分大小写</span></li></ul><h3 id="分屏命令"><a href="#分屏命令" class="headerlink" title="分屏命令"></a>分屏命令</h3><h4 id="分屏打开多个文件"><a href="#分屏打开多个文件" class="headerlink" title="分屏打开多个文件"></a>分屏打开多个文件</h4><ul><li><span class="strong">vim -On 文件名1 文件名2 ...&emsp;&emsp;横向分屏打开文件，从左到右依次显示</span></li><li><span class="strong">vim -on 文件名1 文件名2 ...&emsp;&emsp;竖向分屏打开文件，从上到下依次显示</span></li></ul><h4 id="拆分当前屏幕"><a href="#拆分当前屏幕" class="headerlink" title="拆分当前屏幕"></a>拆分当前屏幕</h4><p>方便同时编辑、浏览多个文件</p><ul><li><span class="strong">:sp [文件名]&emsp;&emsp;增加横向分屏</span>(split)</li><li><span class="strong">:vsp [文件名]&emsp;&emsp;增加竖向分屏</span>(vertical split)</li></ul><p>可以不跟文件名，当无文件名时分屏命令会将当前文件也显示在分屏上。输入文件名忘记全称时，使用<span class="tips">Tab</span>键，vim会提示文件名</p><p>上述命令不添加文件名时，功能同如下两个命令，但下面两个命令使用前需先执行<span class="tips">Ctrl+w</span>命令</p><ul><li>s&emsp;&emsp;上下屏幕同时显示当前文件</li><li>v&emsp;&emsp;左右屏幕同时显示当前文件</li></ul><h4 id="切换分屏窗口"><a href="#切换分屏窗口" class="headerlink" title="切换分屏窗口"></a>切换分屏窗口</h4><p>切换分屏窗口都是基于<span class="tips">Ctrl+w</span>命令，使用下述命令前都要先执行该命令。</p><h5 id="光标在分屏窗口中切换"><a href="#光标在分屏窗口中切换" class="headerlink" title="光标在分屏窗口中切换"></a>光标在分屏窗口中切换</h5><ul><li><span class="strong">w&emsp;&emsp;按顺序切换到下一个窗口</span>(window)(从上到下从左到右)</li><li><span class="strong">W&emsp;&emsp;逆顺序切换到下一个窗口</span>(window)(从下到上从右到左)</li><li><span class="strong">h&emsp;&emsp;切换到左边的窗口</span></li><li><span class="strong">l&emsp;&emsp;切换到右边的窗口</span></li><li><span class="strong">j&emsp;&emsp;切换到下面的窗口</span></li><li><span class="strong">k&emsp;&emsp;切换到上面的窗口</span></li></ul><h5 id="移动分屏窗口"><a href="#移动分屏窗口" class="headerlink" title="移动分屏窗口"></a>移动分屏窗口</h5><ul><li><span class="strong">r&emsp;&emsp;按顺序互换窗口</span>(reverse)</li><li><span class="strong">R&emsp;&emsp;逆顺序互换窗口</span>(reverse)</li><li><span class="strong">H&emsp;&emsp;将当前分屏移动到左边</span></li><li><span class="strong">L&emsp;&emsp;将当前分屏移动到右边</span></li><li><span class="strong">J&emsp;&emsp;关将当前分屏移动到下面</span></li><li><span class="strong">K&emsp;&emsp;将当前分屏移动到上面</span></li></ul><p>以从上到下的窗口分布为例，将7个窗口比作7个楼层，按顺序互换窗口指顶楼7楼变6楼，6楼变5楼，依次往下，而1楼移动到7楼变成顶楼。而当4楼还分割了左右多个窗口时，无法将窗口上下移动，使用命令vim报错。但仍可以将光标切换到4楼以后，在4楼内部移动4楼分割的左右窗口。</p><p>窗口左右分布时类似，窗口可以在左右间移动，而某个窗口内部还分割了上下窗口时，使用命令报错。逆顺序类似，移动方向相反。</p><h5 id="关闭分屏"><a href="#关闭分屏" class="headerlink" title="关闭分屏"></a>关闭分屏</h5><ul><li><span class="strong">c&emsp;&emsp;关闭当前窗口，只剩一个时无法使用</span>(close)</li><li><span class="strong">q&emsp;&emsp;关闭当前窗口，只剩一个时退出vim</span>(quit)</li><li><span class="strong">o&emsp;&emsp;关闭其他窗口</span>(other)</li></ul><h3 id="标签-tab"><a href="#标签-tab" class="headerlink" title="标签(tab)"></a>标签(tab)</h3><p>标签类似于在浏览器中打开多个网页,会在窗口顶部列出各个标签,标签相当于一个vim</p><ul><li><span class="strong">:tabnew [标签名]&emsp;&emsp;创建一个对应名字的新标签</span>(标签名省略时创建一个无名标签)</li><li><span class="strong">:tabc&emsp;&emsp;关闭当前标签</span></li><li><span class="strong">:tabn&emsp;&emsp;切换到下一个标签</span></li><li><span class="strong">:tabp&emsp;&emsp;切换到上一个标签</span></li><li><span class="strong">:tabs&emsp;&emsp;查看一共有几个标签</span></li><li><span class="strong">gt&emsp;&emsp;依次在标签间切换</span>(在命令模式下)</li><li><span class="strong">数字gt&emsp;&emsp;切换到对应顺序的标签中</span></li></ul><h3 id="执行Linux命令"><a href="#执行Linux命令" class="headerlink" title="执行Linux命令"></a>执行Linux命令</h3><ul><li><span class="strong">:!Linux命令&emsp;&emsp;让vim执行Linux命令</span>(执行完Enter会返回文件)</li><li><span class="strong">:r&nbsp;!Linux命令&emsp;&emsp;让vim执行Linux命令并添加执行结果到光标处</span></li></ul><h3 id="定义字符串快捷输入-ab"><a href="#定义字符串快捷输入-ab" class="headerlink" title="定义字符串快捷输入(ab)"></a>定义字符串快捷输入(ab)</h3><p>用于需要频繁输入某个长字符串时，使用一个较短的字符串快速打出该长字符串</p><ul><li><span class="strong">:ab 短字符 长字符串&emsp;&emsp;定义一个长字符串快捷输入</span></li></ul><div class="show" style="word-break: break-all;"><code>如：当需要频繁输入邮箱时，可以用一个短字符串定义邮箱地址:ab gmail sheiyoubingbayouxiangxiezhemechang@Gmail.com之后只需输入gmail空格或者回车，vim会自动补全该长字符串</code></div><h3 id="使用寄存器"><a href="#使用寄存器" class="headerlink" title="使用寄存器"></a>使用寄存器</h3><p>使用复制粘贴时，vim是将内容缓存在寄存器中。用户可以自定义寄存器，vim中使用<span class="tips">“字母</span>来定义一个该字母(大小写均可)命名的寄存器，寄存器后往往加上具体命令，空定义寄存器无效。</p><ul><li><span class="strong">"字母yy&emsp;&emsp;复制当前行到该寄存器中</span></li><li><span class="strong">"字母p&emsp;&emsp;从该寄存器中取出内容并粘贴</span></li><li><span class="strong">:reg&emsp;&emsp;列出所有寄存器</span></li><li><span class="strong">:reg 字母&emsp;&emsp;查看对应寄存器中内容</span></li><li><span class="strong">“”&emsp;&emsp;定义一个无名寄存器</span>(使用复制粘贴时vim启用的是该寄存器)</li></ul><h3 id="定义快捷键"><a href="#定义快捷键" class="headerlink" title="定义快捷键"></a>定义快捷键</h3><p>自定义一个用于某个操作的快捷键</p><ul><li><span class="strong">:map key value&emsp;&emsp;使用快捷键key快速执行value的步骤</span></li></ul>快捷键通常使用<span class="tips">Ctrl+某个不冲突的按键</span>，而定义时该组合按键时需要通过<span class="tips">Ctrl+v+该按键</span>来输入<div class="show" style="word-break: break-all;"><code>如：将某行代码注释掉输入的命令为 :map Ctrl+v+/ I#&lt;esc&gt;命令就会定义Ctrl+/为快捷键,执行的操作为:在行首插入(I的功能)#号,然后esc退出编辑模式,即以后只需要按下Ctrl+/就可以在当前行首插入#号把当前行注释掉(同vscode里的注释快捷键)</code></div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>:map 命令的应用很广</div><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>vim还有其他诸如宏定义、运用插件等能显著提升效率和编程体验的功能，再展开文章就显得有点冗长了，边写边设计样式人麻了，文中可能存在错误。</p>]]></content>
    
    
    <summary type="html">vim是一款功能强大的文本编辑器，被广泛内置于类unix操作系统中，并且很多IDE都支持vim插件。vim可以让我们可以很方便地在Linux各种发行版中编写文件，修改系统配置</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="vim" scheme="https://shiwei11.github.io/blog/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>听歌软件推荐-Spotify</title>
    <link href="https://shiwei11.github.io/blog/2021/06/01/spotify%E6%8E%A8%E8%8D%90/"/>
    <id>https://shiwei11.github.io/blog/2021/06/01/spotify%E6%8E%A8%E8%8D%90/</id>
    <published>2021-05-31T16:00:00.000Z</published>
    <updated>2022-04-30T19:04:13.664Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>Spotify官方信息可能随时会变化，本文部分信息可能过时，请以官方信息为准，但是注册、使用步骤都是大同小异的</div><h3>关于Spotify</h3><p>Spotify创立于瑞典，是目前全球最大的在线音乐流服务商,得到了华纳音乐集团、环球音乐集团、索尼音乐娱乐、Kakao M和腾讯音乐娱乐集团等唱片公司的合作授权，所以曲库非常齐全。Spotify暂未进入中国大陆市场，不过不妨碍软件的正常使用。</p><h3>与国内音乐软件比对</h3><p>先来说说Spotify的优点吧</p><h5>1. 齐全的曲库</h5><p>国内的歌很容易出现版权被某家平台买断的情况，想听喜欢的歌可能得好几个平台才能找齐，听歌时还得好几个APP切来切去，甚至要在好几个平台开VIP。平台自己的恶性竞争还要消费者来买单，这能惯着他们？另外一方面，国内的音乐也很容易出现被人恶意举报而惨遭下架的情况。比如说嘻哈音乐，在diss某些流量idol后，会出现被其粉丝恶意举报后惨遭下架的情况。<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>“DISS不过是种切磋但那些明星雇佣的水军总想方设法要把对方逼死”</div><p>对于Spotify就不存在这个问题了，很多国内下架的专辑你仍然可以在Spotify上找到，拥有极为齐全的版权和曲库。如果你是嘻哈音乐，欧美音乐爱好者，Spotify绝对不会让你失望。当然，Spotify本身没有进入大陆市场，很多小众的华语音乐还是只能在国内APP上找到。</p><h5>2. 开通Premium后就不用再买专辑</h5><p>Premium相当于开通Spotify的VIP，国内在开通VIP后，很多专辑还需要单独付费购买才能听，在Spotify中无需再购买专辑，专辑费用不用额外出了。</p><h5>3. 优秀的音乐推荐算法</h5><p>Spotify的音乐推荐算法也是网上经常被人称赞的闪光点，它会定期制作made for you歌单推荐音乐，国内的音乐软件也有类似的功能，但国内的推荐老会有奇奇怪怪的歌混在里面，感觉Spotify的推荐算法更精准点。</p><h5>4. 支持手机端和PC端相互操控</h5><p>当使用电脑听歌时，打开手机端的Spotify会同步电脑端的状态，反过来也如此。你可以使用手机来控制电脑端进行切歌，调节音量等操作，有些鸡肋，可能我没学会正确的打开方式......在家搞家务使用电脑的音箱外放时，就不用跑到电脑面前切歌了。</p><h5>5. 没有乱七八糟的直播、短视频推送</h5><p>作为音乐软件，Spotify拥有的就是安安静静听歌，没有什么直播、小视频、商店等乱七八糟的功能，也不会有那些乱七八糟的主播推荐。不过不开VIP的话每隔15分钟会推送一次广告，这个后面详细说付费和免费的区别。</p><h5>6. 舒适的UI界面</h5><p>不得不说，歪果仁对于UI设计、无障碍设计还是很有心得的，Spotify的界面用的是真的很舒服。</p><h6>其他优点自己去体验一下吧，接下来再说说用惯了国内的软件可能会觉得不习惯的点</h6><h5>1. 部分地区不支持显示歌词</h5><p>日区、港区可以显示歌词，但是美区账号没有歌词显示功能，只能借助Musixmatch、LyricsX等软件，Musixmatch会自动识别Spotify当前播放的音乐自动匹配歌词。Musixmatch本身是免费的，付费版支持更多花里胡哨的歌词显示方式，1美元可以永久解锁付费版。</p><h5>2. 不支持评论</h5><p>不能到点上号开哭了。</p><h5>3. 注册、登录账号时需要魔法工具加持</h5><p>Spotify没有进入大陆市场，而且注册账号时官方使用的是谷歌的人机验证，而国内的网络无法加载谷歌的服务，所以注册账号的时候会有点麻烦，但注册完以后听歌是全程可以用国内的网络环境的。</p><h5>4. 官方开通Premium贵</h5><p>印度、菲律宾等东南亚区的账号开通Premium比较便宜，美区账号每个月的费用是$9.99美刀，折合人民币大约64.4元每个月，情侣套餐包含两个账号12.99美元一个月，折合人民币83.7元一个月，一个账号就是42块左右，家庭组包含6个账号15.99美元每个月，折合人民币103元每个月，一个账号均摊下来17块左右，另外有学生套餐，但是天朝的学生不能用。这价格相较于国内的平台来说就有点贵了。</p><p>所以很多人一般都是开通的东南亚国家的Premium，开通美区账号一般都是组队开家庭组。</p><h3>注册与使用</h3><h5>1. 注册账号</h5><p>因为Spotify没有进入大陆的市场，所以注册时需要魔法工具，如果不使用魔法工具当他检测到你的IP地址是来源于中国大陆，就会提示<span class="tips"> "Spotify is currently not available in your country"</span>，所以需要魔法将我们的IP地址伪装成其他地区，国内香港、澳门、台湾都行，国外随便一个国家都行。</p><p>传送过去后，登录Spotify的官网 <a href="https://www.spotify.com" target="_blank">https://www.spotify.com</a>，然后点右上角的Log in，然后点击注册一个账号，填写邮箱、密码、用户名、生日等信息(生日可以乱填但记得填18岁以上，不然有些带脏标的歌会听不了)，填完有个google的reCAPTCHA人机验证，这个服务的域名在国内是被墙的，同样需要魔法工具才能打开。网上好像也有不需要魔法工具就能打开reCAPTCHA的教程，我没自己试过，不知道在Spotify里有没有效，没有魔法工具的找身边有的人帮忙注册一下。去Spotify的贴吧、豆瓣小组好像有好心人帮人免费注册，但注意防骗，要钱的就不要理了。最省事的方法就是某宝某多买个号(基本上去他们那里买Premium就会送号)，然后改邮箱就行，注意防骗！！！！！</p><p>注册后官方会发一封邮件验证邮箱,点一下<span class="tips"> CONFIRM YOUR ACCOUNT </span>完成认证即可，注册完的账号有7天体验期可以任意听歌、切歌。</p><p>在使用魔法工具时，有些魔法工具会被提示Spotify检测到正在使用代理工具，要求关闭代理再进行操作。这估计是以前有哪个憨皮拿这个IP批量注册过Spotify账号，IP被官方记录了，把工具切换到全局模式再试试，或者把广播IP地址换成原生IP，如果还是不行那只能换个IP了。</p><h5>2. 分区</h5><p>Spotify为全球很多国家和地区提供服务，所以他的账号是分区的，国内常用的区域有美区、日区、港区、菲律宾区、俄区、马来西亚、印度的一些东南亚的区,账户区域不同，曲库内容、歌单、界面UI、付费价格也不同。</p><p>注册账号时，如果挂的美国的代理，就会进美区的官网，其他同理。具体进了什么区看页面语言，或者地址栏URL路径就可以了，如美区URL为：<div class="code">https://www.spotify.com/us/</div><p>但这个后期可以改的，所以注册时哪个区都无所谓，但是买Premium时，买完就不能改了，所以想好买哪个区的Premium，给个常用的几个区对比：</p></p><ul><li><h6>曲库</h6>美区的曲库相对较全，但如果喜欢ACG音乐、日语歌那肯定去日区，其他同理。但Spotify的曲库判定有点迷，有些日语歌或者韩语歌你无法在日区找到，但是美区或其他区却有，不过这毕竟还是少数。</li><li><h6>歌词</h6>美区是没有歌词的，得借助其他软件，日区、港区、俄区还有一些东南亚区有歌词。</li><li><h6>订阅价格</h6>下面是部分区折算成人民币后的价格，一般东南亚区的比较便宜 <div class="table">    <table>        <thead>            <tr>                <th>区</th>                <th>个人</th>                <th>家庭组(6个账号)</th>            </tr>        </thead>        <tbody>          <tr>              <td>香港</td>              <td>51元</td>              <td>77.5元</td>          </tr>            <tr>            <td>美区</td>            <td>65元</td>            <td>102.5元</td>        </tr>        <tr>            <td>日区</td>            <td>63元</td>            <td>95元</td>        </tr>        <tr>            <td>菲律宾</td>            <td>17元</td>            <td>26元</td>        </tr>        </tbody>    </table></div>   <div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>仅作参考，实际价格以Spotify官网发布的价格为准</div></li></ul><h5>2. 关于Premium</h5><p>即付费版，新注册的账号有7天的付费版体验期。如果第一次开Premium则会送一个月的体验期，免费版和付费版的区别在于<ul><li>手机端免费版只能随机播放，而且只能切6次歌，即你不能想听啥就点啥听，只能听它随机播放的，听一半不想听了想点下一曲只有6次机会，6次以后就只能等它放完(不知道那个天才想出来的设定，真想给他寄点土特产)，网页版和PC端的好一点，能切歌但只能随机播放(老式收音机)，付费版可以任意播放、切换歌</li><li>免费版在听歌过程中会有广告，付费版没有</li><li>音质有区别，免费版比特率在160kbit/s，付费版的比特率在320kbit/s</li></ul></p><h5>3. 开通Premium的小tips</h5><p>直接开个人账号太贵了，常见的方法就是去贴吧、豆瓣小组找人一起开家庭组，这里常年会有车队等着拉人，注意防骗！！！因为一个家庭组里有一个管理员账号，他可以随时把家庭成员踢出去，交了钱隔天就被踢很常见。要是周围用的人多，熟人约好几个人一起开稳妥一点。</p><p>还有一个方法就是去某宝续费，注册有问题的也可以直接在他们手上买号，然后把邮箱换成自己的，同样要注意防骗问题。费用大概是15、20块三个月这样，每家店都不一样。</p><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>一定要去开店年份较高，回头客多的店铺买，开店时间短、评论没几个那种很有可能是以前跑路了，开家新店铺再来割一波韭菜，指不定哪天就找不到店家了</div><h5>4. 踩过的坑</h5><p>某宝的方法也是拉家庭组，然后利用绑信用卡免费1个月等官方优惠赚取差价。但是经常会遇到你买完以后没几个星期就把你踢出家庭组，然后商家跑路，连店铺都找不到那种.....所以在某宝续费，要选那些开店年份长的的店铺，至少说明人家不跑路。</p><p>跑路的最坏结果就是，如果你多次买了家庭组，然后被踢，又买再被踢，官方检测到你的账号短期内加入了众多不同的家庭组，可能会被封禁。并且有些店家的家庭组，是盗取了国外的账号然后拉你进家庭组，一旦国外的号主发现了，向官方反馈后可能直接会被封禁。我的上一个账号就是在某宝续费之后，某天登录时提示无效的账户，去某宝看店家已经跑路了，汤都没留一口.......找Spotify客服客服表示需要提供付费账单才能提供帮助......可是我的付费都付给了某个天萨的卖家，哪有什么账单.......无奈只能放弃那个账号了，可惜了收藏多年的广场舞神曲。。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注册：<br>1.自己有魔法工具自己注册；<br>2.没有魔法工具就去贴吧、豆瓣看看能不能找人帮忙注册；<br>3.或直接去某宝、某多直接买Premium让店家帮忙注册；<br>4.都不行可以写邮件给我，让我看看是谁这么笨；<br>可以先注册用一个星期体验一下，spotify有一个星期的新号体验期，觉得好用再去某宝开Premium或去贴吧、豆瓣找人合作开家庭组。</p><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>注册或者使用中有啥问题，可以去Spotify贴吧，或者去豆瓣小组找找攻略，需要帮忙可以给我写邮件</div>]]></content>
    
    
    <summary type="html">国内的版权买断太严重了，听个歌还得好几个音乐APP来回切换，还得开多份VIP，推荐一款好用的听歌软件Spotify</summary>
    
    
    
    
    <category term="life" scheme="https://shiwei11.github.io/blog/tags/life/"/>
    
    <category term="Music" scheme="https://shiwei11.github.io/blog/tags/Music/"/>
    
  </entry>
  
  <entry>
    <title>一款毫米波不等分功分器</title>
    <link href="https://shiwei11.github.io/blog/2021/05/29/5G%E5%8A%9F%E5%88%86%E5%99%A8/"/>
    <id>https://shiwei11.github.io/blog/2021/05/29/5G%E5%8A%9F%E5%88%86%E5%99%A8/</id>
    <published>2021-05-28T19:08:25.000Z</published>
    <updated>2022-04-04T20:20:11.520Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>和普通的微波器件相比，5G通讯系统中微波器件的结构参数都是毫米级的，改一点点模型参数结果就完全不一样了，带宽又难做大，每一个参数需要重复优化很久才能满足5G通信的需求。</div><h3 id="5G通讯系统"><a href="#5G通讯系统" class="headerlink" title="5G通讯系统"></a>5G通讯系统</h3><p>现在有越来越多的数字终端接入到移动网络中，比如手机、平板、车载AI、远程监控设备等等，全球对移动通信的需求和要求也越来越高了。为了满足未来的更多需求，5G通讯系统中，毫米波成为了传输高质量数据流的主要载体，毫米波频段在30GHz到300GHz之间，世界无线电通信大会提议使用24GHz—86GHz之间的频段作为5G通信频率。</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>数据来源：Hidayat Ullah. Further Notice of Proposed Rulemaking in the Matter of Use of Spectrum Bands Above 24 GHz for Mobile Radio Services [C]. Int. Telecommun. Union-Radiocom Sector. 2016.</div><p>但是，毫米波能实现高速率传输带来的代价就是，由于其频率高、波长短等特性，其对应的微波器件尺寸很小，微小的尺寸差异都会为通信系统带来巨大影响，因此用在毫米波通讯系统中的器件对设计要求和加工工艺要求都很高。并且，毫米波在传播过程中损耗很大，信号衰减较快，并且易受阻挡，地形、建筑物、丛林甚至于雨水都会使毫米波的传输产生很大的衰减，因此5G天线的设计既要有大带宽保证通讯速率，还要有高增益保证毫米波的有效传输，并满足其他电参数性能。如此苛刻的要求，单独的天线单元往往是做不到的，现实生活中通讯系统中的天线往往由天线阵列组成。一款5G手机中的天线数量往往多达十多根，用于负责蓝牙、WLAN、NFC、2-5G等不同频段的通讯，而负责5G通讯的天线也往往是一组天线阵列，将手机信号传输到天线阵列就需要用到功分器的设计了。</p><h3 id="功分器"><a href="#功分器" class="headerlink" title="功分器"></a>功分器</h3><p>功分器是一种主要用于无线电技术领域的无源设备，在微波、射频电路中，有时需要将功率按一定的比例分成两路或多路输出，此时就需要用功率分配器来实现。功率分配器的技术指标主要包括工作频率范围、分配损耗、插入损耗、隔离度等，这几个常用参数的大致定义如下：</p><p><span class="strong">分配损耗：</span>定义P<sub>in</sub>为功分器的输入功率，P<sub>out</sub>为功分器某一输出端口的输出功率，则该端口的分配损耗为:</p><div class="formula">A<sub>d</sub>=10 lg(P<sub>in</sub>/P<sub>out</sub>)</div><p><span class="strong">插入损耗：</span>由输入端驻波比带来的损耗，一般是由于微带线导体介质不理想等因素造成的，设实际测量值为A，则插入损耗A<sub>i</sub>为:</p><div class="formula">A<sub>i</sub>=A-A<sub>d</sub></div><p><span class="strong">隔离度：</span>一般情况下，若信号从支路端口的输入，应当从主路端口输出，若大部分能量能从主路端口输出出来，说明功分器的隔离度较好。i端口与j端口的隔离度定义为：</p><div class="formula">A<sub>ij</sub>=10 lg(P<sub>ini</sub>/P<sub>outj</sub>)</div><p><span class="strong">驻波比：</span>电压驻波比指驻波波腹电压与波节电压幅度之比，又称为驻波系数。当驻波比等于1时，表明端口输入输出阻抗匹配，此时高频能量完全输入到了电路中，没有能量的反射损耗，一般为理想情况，实际的驻波比应尽量接近1。</p><h3 id="威尔金森功分器"><a href="#威尔金森功分器" class="headerlink" title="威尔金森功分器"></a>威尔金森功分器</h3><p>在微波电路中，阻抗不匹配会导致信号反射，反射的信号会干扰其他正常信号的传输，比如1端口的信号会反射到2端口来，影响2端口的信号传输，衡量这一现象的参数是上面提到的隔离度，1-2端口隔离度越好，说明这个两个端口越不容易相互干扰。一般的功分器结构隔离度有可能不太理想，而威尔金森功分器就是为了解决这一问题而设计出来的，功率分配器可由不同的元件组合成不同的形式，威尔金森功分器的原始模型是同轴线形式，因具有良好的隔离度在微带和带状线结构上得到了广泛应用，如下为两路威尔金森功分器示意图：<br><img data-src="/blog/images/wilkinson.jpg" src="/blog/images/loading.gif" tlt="威尔金森功分器" title="威尔金森功分器"></p><p>威尔金森功分器的设计需要借助微带线尺寸计算工具，根据功分器各部分阻抗值计算各部分的结构尺寸。多路功率分配器的设计，可以直接设计为多路输出，也可以采用两路功率分配器的级联形式，即一分二，二分四……上下两级的功分器之间一般需要加上阻抗匹配元件。</p><h3 id="C语言计算威尔金森功分器尺寸"><a href="#C语言计算威尔金森功分器尺寸" class="headerlink" title="C语言计算威尔金森功分器尺寸"></a>C语言计算威尔金森功分器尺寸</h3><p>对于规模较大的天线阵列，往往需要使用多路威尔金森功分器。为了保证通讯系统的稳定性，阵列的带宽、增益、主瓣宽度、副瓣电平等电性能参数都要满足一定的指标，因此阵列往往需要切比雪夫等算法加持，由此设计出来的激励分布往往也是不等分的，因此相应的功分器分配比也要是不等分的，再使用两路功率分配器的级联形式，组合成功分器网络。</p><p>根据功率分配比计算阻抗的过程需要重复用到威尔金森(Wiljinson)功率分配器的设计步骤和计算过程，计算过程繁杂且容易出错，借助C语言来简化这个过程。</p><pre><code class="hljs language-c">#include&lt;stdio.h&gt;#include&lt;float.h&gt;#include&lt;math.h&gt;#define Z0 50//输入阻抗typedef struct design &#123;    float ants[8];//阵列    struct data &#123;//介质板参数        float Er;        float Mur;        float H;        float Hu;        float T;        float TanD;    &#125;; &#125;antenna; int main(void) &#123;    antenna Yagi;    Yagi.Er = 2.2;    Yagi.Mur = 1;    Yagi.H = 0.254;    float num1, num2,k2,k3,result1,z02,z03,R; loop:printf("输入功率分配比:\n");    printf("p1值：");    scanf_s("%f", &num1);    printf("p2值：");    scanf_s("%f", &num2);    printf("验算过程：\n");    printf("--------------\n");    printf("功率分配比：  %.2f:%.2f\n", num1, num2);    k2 = num2 / num1;    printf("k方值为:%f\n", k2);    result1 = 1 + k2;    printf("非归一化比值为:%f\n", result1);    k3 = (float)pow(k2, 1.5);    printf("非归一化比值验算分母:%f\n", k3);    printf("开根:%f\n", result1/k3);    z03= (float)(pow(result1 / k3,0.5)) * Z0;    z02= (float)(pow(pow(k2, 0.5) * result1, 0.5)) * Z0;    R = result1 / pow(k2, 0.5) * Z0;    printf("--------------\n");    printf("计算得的阻抗值为\n");    printf("Z03=%.2fΩ  Z02=%.2fΩ\n", z03, z02);    printf("隔离电阻:");    printf("R=%.2fΩ\n", R);    printf("**************************************\n");    goto loop;    return 0; &#125;    </code></pre><p>由代码可分别计算出每一级功分器支节的阻抗值与输出端口的输出阻抗，而由阻抗值借助微波仿真软件的微带线尺寸计算工具，可以计算出各级功分器的结构参数，但该结构参数仅作为初始数据，根据初始参数所建模型的仿真测试结果往往和预期目标相差巨大，需要利用仿真软件进行多次迭代优化。为了和阵列结构相匹配，功分器网络的结构需要进行拐角、切角等处理，整体设计完的功分器网络可能长这样</p><img data-src="/blog/images/wilkin.jpg" src="/blog/images/loading.gif" alt="不等分功分器馈电网络"><p>经过上百次的迭代优化后，利用微波仿真软件查看功分器馈电网络各输出端口的相位，低频时输出端口的相位基本保持一致，高频时会产生部分频偏，但相位偏移不大，并且该部分已经超出天线的有效带宽范围，因此基本能保证功分器输出端口的同相输出。</p><img data-src="/blog/images/phase.jpg" alt="相位差" src="/blog/images/loading.gif"><p>由于威尔金森功分器加装了隔离电阻，能很好保证各端口间的隔离度基本保持在-15dB以下，所以能确保器件工作时各端口间微波信号的反射干扰不会影响天线阵列的正常工作。</p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>当初做这个设计的时候，我的一个博士生学长和指导老师都给了我很多帮助，查了很多资料，最后也获得了很不错的成果。</div>]]></content>
    
    
    <summary type="html">设计了一个工作在30GHz左右的不等分功分器馈电网络，当初是用来给一个5G天线阵列提供馈电的，花了很多时间和精力，总结一下设计过程和成果</summary>
    
    
    
    
    <category term="硬件" scheme="https://shiwei11.github.io/blog/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="RF" scheme="https://shiwei11.github.io/blog/tags/RF/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://shiwei11.github.io/blog/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://shiwei11.github.io/blog/2021/04/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-04-12T17:53:14.000Z</published>
    <updated>2022-04-01T09:45:23.924Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>文中所声明对象和语法基于javaScript</div><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>用于描述字符串的某种特殊规则，可以用来检测某个字符串是否满足该规则，或对符合该规则的字符串进行提取、删除、替换等操作。</p><h5 id="常见的运用"><a href="#常见的运用" class="headerlink" title="常见的运用"></a>常见的运用</h5><ul><li>LOL：我星号你个星号星号的瞎子&emsp;(聊天系统将脏话等敏感字眼替换成 * 号)</li><li>设置密码时<br/>系统："请至少设置8位以上且同时包含数字、大小写字母和特殊字符"<br/>"我他喵记不住啊!"&emsp;(限制用户所输入字符串的复杂度以提高密码强度)</li><li>每天手机号收到乱七八糟的广告短信&emsp;(从爬虫中提取有效手机号、邮箱号、身份证号等信息)</li><li>.........</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="创建正则表达式对象"><a href="#创建正则表达式对象" class="headerlink" title="创建正则表达式对象"></a>创建正则表达式对象</h4><h6 id="1-利用构造函数"><a href="#1-利用构造函数" class="headerlink" title="1.利用构造函数"></a>1.利用构造函数</h6><p> 由引号<span class="tips">“ </span>包围，语法：<span class="strong">let 变量=new RegExp(“正则表达式”,”匹配模式”)</span><br> 匹配模式可直接省略，默认情况下匹配到一个结果就返回<br> <pre><code>let reg=new RegExp("ab","i")</code></pre></p><h6 id="2-字面量"><a href="#2-字面量" class="headerlink" title="2.字面量"></a>2.字面量</h6><p> 由斜杠<span class="tips">/</span>包围，语法：<span class="strong">let 变量=/正则表达式/匹配模式</span><br> <div class="code">let reg=/ab/i</div></p><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><p> 匹配模式可以忽略，默认情况下正则匹配会区分大小写，并且将在匹配到第一个结果后停止匹配并返回结果。正则表达式有六个参数用于指定匹配模式，这些参数既可以单独使用也可以任意顺序一起使用。</p> <ul> <li><span class="strong">g &emsp;&emsp;全局搜索</span></li> <li><span class="strong">i &emsp;&emsp;忽略大小写</span></li> <li><span class="strong">m&emsp;&emsp;多行搜索</span></li> <li><span class="strong">s &emsp;&emsp;允许<span class="tips">.</span>号匹配换行符</span></li> <li><span class="strong">u &emsp;&emsp;使用unicode码的模式进行匹配。</span></li> <li><span class="strong">y &emsp;&emsp;执行“粘性”搜索,匹配从目标字符串的当前位置开始。</span></li> </ul><h4 id="RegExp对象的常用方法"><a href="#RegExp对象的常用方法" class="headerlink" title="RegExp对象的常用方法"></a>RegExp对象的常用方法</h4><h5 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h5><p>在字符串中查找是否有满足正则表达式的值，有则返回<span class="tips">true</span>,无则返回<span class="tips">false</span>。</p><div class="code"><code>let reg=/hello/;console.log(reg.test("xxhelloxx")); //true</code></div><h5 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h5><p>搜索出字符串中与正则表达式匹配的值，如果找到了，返回一个存放了匹配结果、匹配结果的第一个字符位置等信息的数组，如果未找到返回 null 。该方法不常用，搜索字符串常用String对象的match()方法。</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>更多RegExp对象的属性和方法详见W3C标准或MDN的官方文档</div><h4 id="支持正则表达式的String对象的方法"><a href="#支持正则表达式的String对象的方法" class="headerlink" title="支持正则表达式的String对象的方法"></a>支持正则表达式的String对象的方法</h4><h5 id="split-字符串拆分为数组"><a href="#split-字符串拆分为数组" class="headerlink" title="split() 字符串拆分为数组"></a>split() 字符串拆分为数组</h5><p>按所写正则表达式表达式规则将一个字符串拆分成数组，拆分处字符将丢弃,该方法即使不指定全局匹配，也会自动进行全局匹配，返回数据类型为<span class="tips">Object数组<span>。</p><div class="code"><code>var str="1a2b3c4d";console.log(str.split(/[A-z]/));//返回['1','2','3','4']</code></div><h5 id="search-搜索匹配值"><a href="#search-搜索匹配值" class="headerlink" title="search() 搜索匹配值"></a>search() 搜索匹配值</h5><p>搜索字符串是否含有指定内容，有则返回第一次出现的索引值(即使为全局匹配也只返回第一次出现的索引值)，没有则返回-1。返回数据类型为<span class="tips">Number<span></p><div class="code"><code>var str="never forget ever";console.log(str.search(/ever/));//返回1console.log(str.search(/f/));//返回6</code></div><h5 id="match-找到一个或多个正则表达式匹配"><a href="#match-找到一个或多个正则表达式匹配" class="headerlink" title="match() 找到一个或多个正则表达式匹配"></a>match() 找到一个或多个正则表达式匹配</h5><p>将符合正则表达式的内容提取出来,默认情况下找到第一个符合的字符就会返回，因此经常配合全局匹配模式。返回数据类型为<span class="tips">Object数组<span></p><div class="code"><code>var str="1a2b3c4d";console.log(str.match(/[a-z]/ig));//返回['a','b','c','d']console.log(str.search(/[0-9]/g));//返回['1','2','3','4']</code></div><h5 id="replace-将符合表达式的字符串替换成指定字符串"><a href="#replace-将符合表达式的字符串替换成指定字符串" class="headerlink" title="replace() 将符合表达式的字符串替换成指定字符串"></a>replace() 将符合表达式的字符串替换成指定字符串</h5><p>用于屏蔽、替换内容，接收两个参数：被替换的内容、新内容，语法为<span class="strong">replace(字符或正则表达式,”新内容”)</span>。默认只替换第一个符合表达式的内容。返回数据类型为<span class="tips">String<span></p><div class="code"><code>var str="1a2b3c4d";console.log(str.replace(/[a-z]/ig,"*"));//返回1*2*3*4*console.log(str.replace(/[0-9]/g,""));//返回abcd</code></div><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><h5 id="或"><a href="#或" class="headerlink" title="或 |"></a>或 |</h5><p>使用 | 匹配多项字符串 eg: let reg=/a|b/;</p><h5 id="方括号"><a href="#方括号" class="headerlink" title="方括号 [ ]"></a>方括号 [ ]</h5><p>方括号用于查找某个范围内的字符，括号内内容也是<span class="tips">或</span>的关系</p><div class="code"><code>/[a-z]/   是否含有任意的小写字母/[A-Z]/   是否含有任意的大写字母/[A-z]/   是否含有任意字母/[0-9]     任意数字/a[bde]c/   检查是否含有abc或adc或aec</code></div>在方括号中增加<span class="tips">^</span>符号表示<span class="tips">非</span>的关系<div class="code"><code>let reg=/[^0-9]/;console.log(reg.test("12a34"));  //ture，字符串"12a34"中含有除数字以外的字符</code></div><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><h5 id="x-匹配出现x次的字符串"><a href="#x-匹配出现x次的字符串" class="headerlink" title="{x} 匹配出现x次的字符串"></a>{x} 匹配出现x次的字符串</h5><p>指定一个内容出现的次数,注意：它只对它之前的一个内容起作用，多个内容重复应该使用<span class="tips">( )</span>包裹</p><div class="code"><code>let reg=/a&#123;3&#125;/;    //匹配aaalet reg2=/ab&#123;3&#125;/;  //匹配abbblet reg3=/(ab)&#123;3&#125;/; //匹配ababab</code></div><h5 id="x-y-匹配出现x至y次的字符串"><a href="#x-y-匹配出现x至y次的字符串" class="headerlink" title="{x,y} 匹配出现x至y次的字符串"></a>{x,y} 匹配出现x至y次的字符串</h5><div class="code"><code>let reg=/ab&#123;1,3&#125;c/;    //匹配abc、abbc、abbbc</code></div><h5 id="x-匹配出现的字符串大于等于x次的字符串"><a href="#x-匹配出现的字符串大于等于x次的字符串" class="headerlink" title="{x,} 匹配出现的字符串大于等于x次的字符串"></a>{x,} 匹配出现的字符串大于等于x次的字符串</h5><div class="code"><code>let reg=/ab&#123;3,&#125;c/;    //匹配abbbc等b出现3次及3次以上的字符串</code></div><h5 id="n-匹配包含至少有一个字符n的字符串"><a href="#n-匹配包含至少有一个字符n的字符串" class="headerlink" title="n+ 匹配包含至少有一个字符n的字符串"></a>n+ 匹配包含至少有一个字符n的字符串</h5><p>相当于/{1,}n/</p><div class="code"><code>let reg=/ab+c/;    //匹配abc等b出现1次及1次以上的字符串</code></div><h5 id="n-匹配包含0个或多个n的字符串"><a href="#n-匹配包含0个或多个n的字符串" class="headerlink" title="n* 匹配包含0个或多个n的字符串"></a>n* 匹配包含0个或多个n的字符串</h5><p>即有无n都可，相当于/{0,}n/</p><div class="code"><code>let reg=/ab*c/;    //匹配ac、abc等b可有可无，无限数量的字符串</code></div><h5 id="n-匹配只能包含0个或1个n的字符串"><a href="#n-匹配只能包含0个或1个n的字符串" class="headerlink" title="n? 匹配只能包含0个或1个n的字符串"></a>n? 匹配只能包含0个或1个n的字符串</h5><p>字符串中要么没有n,要么只能有一个n</p><div class="code"><code>let reg=/ab?c/;    //只能匹配ac、abc</code></div><h4 id="检查字符串位置"><a href="#检查字符串位置" class="headerlink" title="检查字符串位置"></a>检查字符串位置</h4><ul><li><span class="strong">^n &emsp;&emsp;匹配以 n 开头的字符串</span></li><li><span class="strong">n$ &emsp;&emsp;匹配以 n 结尾的字符串</span></li><li><span class="strong">^n|n$ &emsp;匹配以n开头或以n结尾的字符串</span></li><li><span class="strong">^n$ &emsp;&emsp;以n开头马上以n结尾,因此只能匹配到"n"</span></li><li><span class="strong">?=n &emsp;&emsp;匹配任何其后紧接指定字符串 n 的字符串。</span></li><li><span class="strong">?!n &emsp;&emsp;匹配任何其后没有紧接指定字符串 n 的字符串</span></li></ul><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>^n和n$可理解为开头后紧接字符n,结束前紧接字符n,因此^n$表示开头后紧接这字符n，马上紧接这结束符号，因此只能匹配字符n自己</div><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符即正则表达式中一些用于特殊用途的字符</p><div class="table"><table>    <thead>        <tr>            <th>元字符</th>            <th>描述</th>        </tr>    </thead>    <tbody>        <tr>            <td><span class="strong">.</span></td>            <td><span class="strong">查找单个任意字符，除了换行和行结束符</span></td>        </tr>         <tr>            <td><span class="strong">\w</span></td>            <td><span class="strong">查找单词字符</span>(任意字母、数字、下划线_)</td>        </tr>        <tr>            <td><span class="strong">\W</span></td>            <td><span class="strong">查找非单词字符</span>(除字母、数字、下划线_以外的字符)</td>        </tr>        <tr>            <td><span class="strong">\d</span></td>            <td><span class="strong">查找数字</span></td>        </tr>        <tr>            <td><span class="strong">\D</span></td>            <td><span class="strong">查找非数字字符</span></td>        </tr>        <tr>            <td><span class="strong">\s</span></td>            <td><span class="strong">查找空白字符</span></td>        </tr>        <tr>            <td><span class="strong">\S</span></td>            <td><span class="strong">查找非空白字符</span></td>        </tr>        <tr>            <td><span class="strong">\b</span></td>            <td><span class="strong">匹配单词边界</span></td>        </tr>        <tr>            <td><span class="strong">\B</span></td>            <td><span class="strong">匹配非单词边界</span></td>        </tr>        <tr>            <td><span class="strong">\o</span></td>            <td><span class="strong">查找 NUL 字符(字符串结束字符)</span></td>        </tr>        <tr>            <td><span class="strong">\n</span></td>            <td><span class="strong">查找换行符</span></td>        </tr>        <tr>            <td><span class="strong">\f</span></td>            <td><span class="strong">查找换页符</span></td>        </tr>        <tr>            <td><span class="strong">\r</span></td>            <td><span class="strong">查找回车符</span></td>        </tr>        <tr>            <td><span class="strong">\t</span></td>            <td><span class="strong">查找制表符</span></td>        </tr>        <tr>            <td><span class="strong">\v</span></td>            <td><span class="strong">查找垂直制表符</span></td>        </tr>        <tr>            <td><span class="strong">\xxx</span></td>            <td><span class="strong">查找以八进制数 xxx 规定的字符</span></td>        </tr>        <tr>            <td><span class="strong">\xdd</span></td>            <td><span class="strong">查找以十六进制数 dd 规定的字符</span></td>        </tr>        <tr>            <td><span class="strong">\uxxxx</span></td>            <td><span class="strong">查找以十六进制数 xxxx 规定的 Unicode 字符</span></td>        </tr>    </tbody></table></div><h4 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h4><p>查找某个单独单词时使用单词边界，用于区分这个单词刚好是另外一个字符串一个部分的情况</p><div class="code"><code>let reg=/\bchild\b/;console.log(reg.test("eg children")); //false </code></div><h4 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h4><h5 id="去除字符串中的所有空格"><a href="#去除字符串中的所有空格" class="headerlink" title="去除字符串中的所有空格"></a>去除字符串中的所有空格</h5><p>表达式：<span class="strong">/\s/g</span></p><div class="code"><code>let str=" xxx  xxx ";let str1=str.replace(/\s/g,""); //输出xxxxxx</code></div><h5 id="去除字符串前后的空格，保留字符之间的空格"><a href="#去除字符串前后的空格，保留字符之间的空格" class="headerlink" title="去除字符串前后的空格，保留字符之间的空格"></a>去除字符串前后的空格，保留字符之间的空格</h5><p>表达式：<span class="strong">/^\s+|\s+$/g</span>若只去除前或后的空格，取表达式一半</p><div class="code"><code>let str=" xxx  xxx ";let str1=str.replace(/^\s+|\s+$/g,""); //输出xxx  xxx</code></div><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>由于<span class="tips">.</span>、<span class="tips">/</span>等已作为关键字使用，因此如匹配小数点等功能需要用到转义。正则表达式中使用<span class="tips">&#92;</span>作为转义字符</p><div class="code"><code>let reg=/\./;  //匹配字符串中的.号，如匹配小数</code></div><h4 id="构造函数中的转义"><a href="#构造函数中的转义" class="headerlink" title="构造函数中的转义"></a>构造函数中的转义</h4><p>由于构造函数中接收的参数为字符串，而字符串中<span class="tips">&#92;</span>也为转义字符，因此在构造函数中使用<span class="tips">&#92;</span>符号需要进行二次转义。如</p><div class="code"><code>let reg=new RegExp("\\."); //编译后的正则表达式为/\./,即用于匹配小数点</code></div><h5 id="匹配字符串中是否有-92"><a href="#匹配字符串中是否有-92" class="headerlink" title="匹配字符串中是否有&#92;"></a>匹配字符串中是否有<span class="tips">&#92;</span></h5><div class="code"><code>let reg=new RegExp("\\\\"); //编译后的正则表达式为/\\/</code></div><p>错误的语法</p><div class="code"><code>let reg=new RegExp("\\"); //编译后的正则表达式为/\/，表达式将\作为转义符号,转义后面的/符号，从而导致正则表达式缺少完整//符号而报错</code></div><p>测试字符串中是否有<span class="tips">&#92;</span>完整代码</p><div class="code"><code>let reg=new RegExp("\\\\"); let str="abcd\\"; console.log(reg); //输出/\\/ console.log(str); //输出abcd\ console.log(reg.test(str)); //输出true</code></div><h3 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h3> <div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>网课资料，老师说没一个一个验证过，可能存在错误。不知道作者没有注明来源，侵权请联系我删除</div><h5>校验数字</h5><p style="white-space:pre;text-indent:0;">1. 数字：^[0-9]*$2. n位的数字：^\d{n}$3. 至少n位的数字：^\d{n,}$4. m-n位的数字：^\d{m,n}$5. 零和非零开头的数字：^(0|[1-9][0-9]*)$6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$12. 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</p><h5>校验字符</h5><p style="white-space:pre;text-indent:0;">1. 汉字：^[\u4e00-\u9fa5]{0,}$2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$3. 长度为3-20的所有字符：^.{3,20}$4. 由26个英文字母组成的字符串：^[A-Za-z]+$5. 由26个大写英文字母组成的字符串：^[A-Z]+$6. 由26个小写英文字母组成的字符串：^[a-z]+$7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$11. 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+</p><h5>信息</h5><p style="white-space:pre;text-indent:0;">1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$5. 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}7. 身份证号(15位、18位数字)：^\d{15}|\d{18}$8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$12. 日期格式：^\d{4}-\d{1,2}-\d{1,2}13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15. 金额的输入格式：    1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$    2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$    3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$    4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$    5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$    6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$    7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$    8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$16. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$17. 中文字符的正则表达式：[\u4e00-\u9fa5]18. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))19. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)20. HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)21. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)22. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)23. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)24. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)25. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</p>]]></content>
    
    
    <summary type="html">正则表达式通常被用于匹配符合某个特殊规则的字符串，并且运用十分广泛，可以用于注册账号时限制用户名、从爬虫里筛选出满意的信息等等</summary>
    
    
    
    
    <category term="笔记" scheme="https://shiwei11.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="regex" scheme="https://shiwei11.github.io/blog/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>手写一个迭代器</title>
    <link href="https://shiwei11.github.io/blog/2021/04/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://shiwei11.github.io/blog/2021/04/01/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2021-04-01T10:25:06.000Z</published>
    <updated>2021-10-28T20:18:38.608Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>文中所声明对象和语法基于javaScript</div><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器(iterator)是一种可以为各种不同的数据结构提供统一遍历操作的接口，JAVA、C++、Python、PHP等很多语言都有迭代器的概念，对象只要部署了iterator接口，就可以进行遍历操作(如用for语句进行遍历)。</p><h3 id="迭代器的遍历"><a href="#迭代器的遍历" class="headerlink" title="迭代器的遍历"></a>迭代器的遍历</h3><p>迭代器遍历的原理是这样的：</p><ol><li>创建一个指针对象，指向当前数据结构的起始位置;</li><li>调用指针对象的next方法，指针指向数据结构的第一个成员;</li><li>重复调用next方法，指针后移动，直至指向最后一个成员;</li></ol><p>以最常见的遍历数组为例：我们可以用for…of等语句对其进行遍历，是因为数组中原生内置了iterator接口。</p><pre><code> const songs=['夜曲','手写的从前','反方向的钟','晴天','最长的电影'];    console.log(songs);</code></pre>    <img data-src="/blog/images/iterator01.jpg" src="/blog/images/loading.gif" alt="iterator接口"><p>按照其原理，先定义一个对象来获取该Symbol.iterator属性，找到该对象中包含的next方法。调用这个next()方法，它会返回一个包含done和value属性的对象。</p><pre><code>const songs=['夜曲','手写的从前','最长的电影','晴天','明明就'];        // console.log(songs);        let iterator=songs[Symbol.iterator]();        console.log(iterator);        console.log(iterator.next());</code></pre>        <img data-src="/blog/images/iterator02.jpg" src="/blog/images/loading.gif" alt="iterator中的next方法"><p>重复调用next()方法，该方法会依次遍历数组成员并返回多个包含done和value属性的对象，遍历完数组后，再返回一个done属性值为true,value属性值为undefined的对象，表示数组遍历结束。</p><img data-src="/blog/images/iterator03.jpg" src="/blog/images/loading.gif" alt="遍历结束"><p>在JAVAScript中，原生自带iterator接口的数据结构有：<br/><span class="tips">Array</span>、<span class="tips">Map</span>、<span class="tips">Set</span>、<span class="tips">String</span>、<span class="tips">TypedArray</span>、<span class="tips">函数的 arguments 对象</span>、<span class="tips">NodeList 对象</span></p><h3 id="自定义遍历对象"><a href="#自定义遍历对象" class="headerlink" title="自定义遍历对象"></a>自定义遍历对象</h3><p>对于没有内置iterator接口的数据结构，可以仿照其原理，手写一个iterator接口，并且自定义需要遍历或者允许被遍历的内容。</p><p>按照其原理，添加iterator接口的步骤分为:</p><ol><li>添加Symbol.iterator属性,它是以一个函数的形式包含；</li><li>在其中添加next()方法;</li><li>next()方法会依次返回一个包含done和value属性的对象；</li><li>如果遍历结束，则返回一个done属性值为true,value属性值为undefined的对象;</li></ol>完整代码：<pre><code> //遍历输出对象的songs属性        const Rapper=&#123;            name:'王以太',            shows:['Chengdu','Hangzhou','Shenzhen'],            songs:['三思而后行','阿司匹林','童言无忌','目不转睛','人间天堂'],            [Symbol.iterator]()&#123;                let index=0;//索引号                return&#123;                    next: ()=>&#123;                        if(index< this.songs.length)&#123;                            const result=&#123;                                value:this.songs[index],                                done:false&#125;;                                index++;                                return result;                            &#125;                            else&#123;                                return&#123;                                    value:undefined,                                    done:true                                &#125;                            &#125;                        &#125;                    &#125;                &#125;            &#125;;          //遍历输出        for(let m of Rapper)&#123;        console.log(m);    &#125;</code></pre><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>python、C++写个类似的接口也很简单，不过对复杂点的数据结构比较麻烦</div>]]></content>
    
    
    <summary type="html">迭代器(iterator)是一种可以为各种不同的数据结构提供统一遍历操作的接口，对于没有内置iterator接口的数据结构，我们可以自定义一个iterator接口</summary>
    
    
    
    
    <category term="javaScript" scheme="https://shiwei11.github.io/blog/tags/javaScript/"/>
    
    <category term="数据结构" scheme="https://shiwei11.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Git与Github</title>
    <link href="https://shiwei11.github.io/blog/2021/03/23/git%E4%B8%8Egithub/"/>
    <id>https://shiwei11.github.io/blog/2021/03/23/git%E4%B8%8Egithub/</id>
    <published>2021-03-22T19:08:18.000Z</published>
    <updated>2021-10-28T20:19:01.430Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>记录一下git的常用命令</div> <h3> 1.git与github </h3><p>git是由Linux之父Linus运用c语言开发的一款分布式版本控制工具，支持Linux命令。github是全球最大的社交编程与代码托管网站，托管了数以百万的开源项目。                    <ul>                    <li>保存所有提交过的文件历史状态</li>                    <li>将文件回退到任意历史版本</li>                    <li>多人并行修改同一文件，并推送到服务器端</li>                    <li>创建多条支线同时推进开发任务</li>                    <li>邀请团队外的人员参与开发并进行审核</li>                    <li>对团队成员进行权限限制</li>                    <li>查看团队成员的修改内容、时间、日志</li>                </ul>                    </p><h3>2.本地仓库操作</h3>              <h4>2.1 初始化 git init</h4>              <p>生成.git文件夹(默认隐藏)，文件夹中包含了配置文件等本地库相关的目录和文件，如config文件中包含用户签名等信息</p>               <h4>2.2 设置签名</h4>                <p>用户名和Email地址可随意，仅用于区分开发者身份</p>               <h6>项目级别(仓库级别)：</h6>               <p>仅在当前本地仓库范围内有效</p>               <div class="code">git config user.name xxxgit config user.email xxx@xxx.com</div>               <p> 配置文件保存在该项目下.git文件夹中的config里</p>               <h6>系统用户级别：</h6>               <p>登录当前操作系统的用户范围</p>               <div class="code">git config --global user.name xxxgit config --global user.email xxx@xxx.com</div>               <p>                配置文件位于C:\Users\Administrator\.gitconfig                当二者用户签名都存在时，会优先使用项目级别的签名。               </p>               <h4>2.3 git本地操作</h4>               <h6>2.3.1 将文件加入暂存区\从暂存区去除</h6>              <ul>                  <li>将文件加入暂存区 <span class="strong">git add 文件名</span></li>                  <li>将所有文件加入暂存区<span class="strong">git add *</span></li>                  <li>将文件从暂存区去除<span class="strong">git rm --cached 文件名</span></li>                  <li>查看当前状态<span class="strong">git status</span></li>              </ul>            <h6>2.3.2 将文件提交到本地库</h6>            <ul>                <li>将文件快速提交到本地库 <span class="strong">git commit -m "提交标识语句" 文件名</span></li>                <li>将文件提交到本地库 <span class="strong">git commit 文件名</span> </li>                不使用快速提交会打开vim编辑器，要求添加提交标识语句            </ul>            <h6>2.3.3 查看提交的日志</h6>            <ul>                <li>完整查看历史记录 <span class="strong">git log</span></li>                <li>简洁版 <span class="strong">git log --pretty=oneline</span> </li>                <li>简洁版并缩短了哈希值 <span class="strong"> git log --oneline</span></li>                <li>在oneline基础上添加了回退版本指针需要移动的次数 <span class="strong">git reflog</span></li>            </ul>            <h6>2.3.4 版本回退</h6>            <ul>                <li>基于索引值 <span class="strong">git reset --hard 哈希值</span> </li>                <li>基于^符号：只能后退 <span class="strong">git reset --hard HEAD^</span>                     一个^表示回退一个版本，n个^即回退n个版本</li>                <li>基于~符号：只能后退 <span class="strong">git reset --hard HEAD~回退数</span> </li>            </ul>            <h6>2.3.5 reset的参数</h6>            <ul>                <li><span class="strong">--soft  </span> 仅在本地库移动 HEAD 指针,不修改工作区和暂存区内容,工作区和暂存区内容仍为版本回退前的内容,因为本地库和暂存区内容不同了,此时git status会提示有新内容可提交(不常用)</li>                <li><span class="strong">--mixed  </span>在本地库移动 HEAD 指针,同时暂存区也会回退到历史版本(不常用)</li>                <li><span class="strong">--hard </span>在本地库移动 HEAD 指针，暂存区、工作区也会一同被重置回历史版本</li>            </ul>            <h6>2.3.6 文件删除与找回</h6>            <p>文件删除同样需要git add添加和git commit提交，将删除记录提交到本地库，以备版本回退。</p><span class="strong">找回文件将版本回退到删除前的版本即可</span><p>若删除文件后只添加到了缓存区，没有提交到本地库，此时本地库中是没有提交记录，但可以用<span class="strong"> git reset --hard HEAD </span>命令将暂存区、工作区一起回退到没有删除文件和添加缓存的那个版本。</p><p>即：</p><ul>    <li>删除操作已经提交到本地库  <span class="strong"> git reset --hard 哈希值</span></li>    <li>删除操作未提交到本地库<span class="strong">  &emsp;git reset --hard HEAD</span></li></ul><h6>2.3.7  文件比较</h6><ul>    <li>将工作区和暂存区的文件进行比较 <span class="strong"> git diff 文件名</span></li>     若无文件名则将比较所有文件删除内容将以红色表示，新增文件绿色标识    <li>将工作区文件和历史版本进行比较  <span class="strong"> git diff 历史版本 文件名</span></li>eg：git diff HEAD new1.txt 和当前版本进行比较<br/>eg：git diff HEAD^^ new1.txt 和上上个版本比较<br/>eg：git diff 哈希值 new1.txt 和该哈希值对应的版本进行比较</ul><h4>2.4 分支</h4><h6>2.4.1 创建与切换分支</h6><ul>    <li>创建分支 <span class="strong"> git branch 分支名</span></li>    <li>切换分支 <span class="strong"> git checkout 分支名</span></li>    <li>这两个代码可以合并，创建并切换到新建的分支 <span class="strong"> git checkout -b 分支名</span></li>    <li>不能创建两个同名的分支，使用 <span class="strong"> git checkout -B 分支名 </span>强制创建会重置原有的分支</li>    <li>查看所有分支 <span class="strong"> git branch -v</span></li></ul><h6>2.4.2 合并分支</h6><p>1.先切换到需要待修改的分支上  <span class="strong"> git checkout 分支名</span></p><p>2.执行合并 <span class="strong">  git merge 有新内容的分支名</span></p><h6>2.4.3 解决冲突</h6><p>当两个分支同一文件同一内容进行了不同修改，git将提示自动合并失败，打开文件会标识出冲突位置和内容</p><div class="code">&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD当前分支修改内容=========被合并分支修改内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;分支名</div>并且状态显示为正在合并，直接打开文件修改冲突内容后保存然后使用<p> <span class="strong"> git add 文件名</span></p><p> <span class="strong">git commit -m “提交说明”</span></p>完成合并<br/>注意！！git commit 命令后不跟文件名，否则会提示合并状态下无法进行提交<h4>2.5 创建标签</h4><p>可以为github的项目添加标签，方便查找不同的版本。较为规范的版本格式应该为<span class="tips">主版本号.次版本号.修订号</span>各版本号应该依次递增，版本号递增应该遵循：</p><ul>    <li><span class="strong">主版本号</span>重大调整、大型不兼容的API修改</li>    <li><span class="strong">次版本号</span>新增功能、小型功能性修改</li>    <li><span class="strong">修订号</span>修复bug</li>    <li>每当次版本号递增时，修订号必须归零。每当主版本号递增时，次版本号和修订号必须归零</li>    <li>先行版本号可以标注在修订号之后，使用连接号再加上一连串以句点分隔的标识符来修饰，如：1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92</li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>关于版本控制规范，github上有更详细的说明 <a href="https://semver.org/lang/zh-CN/" target="_blank"> https://semver.org/lang/zh-CN/</a></div><h5>2.5.1 查看tag</h5><p>查看已创建的标签</p><ul>    <li>查看所有标签<span class="strong"> git tag </span></li>    <li>查看指定版本的标签 <span class="strong"> git tag -l v1.1.*</span></li>     <li>显示tag信息 <span class="strong"> git show v1.1.1</span></li></ul><h5>2.5.2 创建tag</h5><ul>    <li>轻量级tag，无任何附带信息<span class="strong"> git tag 标签名</span></li>    <li>附带说明的tag<span class="strong"> git tag -a 标签名 -m "说明"</span></li>   <li>带有签名的tag，需要GPG私钥<span class="strong"> git tag -s 标签名 -m "说明"</span></li></ul><h5>2.5.3 删除tag</h5><ul>    <li>删除本地tag<span class="strong"> git tag -d 标签名</span></li>    <li>删除远程tag<span class="strong"> git push origin --delete 标签名</span></li>   <li>删除远程tag<span class="strong"> git push origin :refs/tags/标签名</span></li></ul><h5>2.5.4 验证tag</h5>拥有GPG私钥时可以验证tag<ul>    <li>验证tag<span class="strong"> git tag -v 标签名</span></li></ul><h5>2.5.5 推送本地tag到远程仓库</h5><ul>    <li>推送指定tag<span class="strong"> git push 远程仓库别名 标签名</span></li>    <li>推送所有tag<span class="strong"> git push 远程仓库别名 --tags</span></li></ul><h3>3.远程仓库</h3><h4>3.1 push与clone</h4>在github创建仓库，并复制仓库地址git init 在本地初始化文件夹，建立本地仓库<ul>    <li>创建远程仓库别名<span class="strong"> git remote add 别名 远程仓库地址</span>(别名常用origin)</li>    <li>查看当前所有仓库别名<span class="strong"> git remote -v</span></li>    <li>推到远程仓库<span class="strong"> git push 别名 分支名</span></li>    <li>克隆到本地<span class="strong"> git clone 远程仓库地址</span></li></ul><h4>3.2 拉取</h4><ul>    <li>拉取并直接合并<span class="strong">git pull 别名 远程分支名</span></li>    <li>仅拉取远程库<span class="strong">git fetch 别名 远程分支名</span></li>    <li>合并<span class="strong">git merge 远程库地址别名 / 远程分支名</span></li>    <li>即 pull=fetch+merge</li></ul><h4>3.3 冲突解决</h4><p>  当团队不同成员对同一文件进行了修改，后push 的人会被要求将本地库更新到最新版本，需先 pull 到本地，而当拉取的远程库内容和本地库有冲突时，会直接进入待合并状态，需解决冲突位置。 即如果不是基于Github 远程库最新版本进行的修改，会无法进行push操作</p><h3>4. 跨团队开发与fork操作</h3><p>团队外的成员,可用 Github 中的 fork 将心仪的仓库复制一份到自己的仓库中，fork的仓库会保留来源。 在自己的仓库中编辑完后，可用 Github 中的 Pull requests 将修改提交给原作者。 原作者可通过 Merge pull request 合并代码，书写合并操作日志后 Confirm merge完成合并。</p><h3>5. ssh免密登录设置</h3><h4>5.1 生成.ssh密钥目录</h4><p>1.返回根目录<span class="strong">cd ~ </span></p><p>2.使用命令<span class="strong">ssh-keygen -t rsa -C github账号</span>生成.ssh密钥目录，密钥文件夹在win10中默认路径为C:\Users\当前登录win10的用户名\.ssh</p><p>3. 文件夹中默认生成 id_rsa 和 id_rsa.pub文件,使用命令<span class="strong">cat id_rsa.p </span>或直接用记事本打开id_rsa.pub文件，复制内容</p><p>4. 打开github的头像→Settings→SSH and GPG keys 位置，New SSH Key 后进行粘贴</p><h4>5.2 配置ssh</h4><p>1.创建远程仓库别名 <span class="strong">git remote 别名 远程仓库ssh</span></p><p>2.此时使用<span class="strong">git remote -v </span>查看列表中将新增ssh地址，此时即可用<span class="strong">push ssh别名 远程分支</span>使用ssh进行操作。</p><h3>6. Github常见报错</h3><h4>6.1 无法连接</h4><p>    fatal: unable to access 'https://github.com/xxxxx.git/'之类的错误</p><p>将链接中的https改为git</p><h4>6.2 git push 时报错 error 10054</h4>最常见的问题，有时候是网络问题，还有个原因是push的文件太大，缓存默认只有1M，将缓存改为500M<div class="code">git config http.postBuffer 524288000 </div>]]></content>
    
    
    <summary type="html">git是由Linux之父Linus运用c语言开发的一款分布式版本控制工具，支持Linux命令。整理一下git的基本操作命令，方便查阅。</summary>
    
    
    
    
    <category term="笔记" scheme="https://shiwei11.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="git" scheme="https://shiwei11.github.io/blog/tags/git/"/>
    
  </entry>
  
</feed>
