<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHWIVI&#39;s blog</title>
  
  
  <link href="https://shiwei11.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://shiwei11.github.io/blog/"/>
  <updated>2024-12-04T02:23:29.545Z</updated>
  <id>https://shiwei11.github.io/blog/</id>
  
  <author>
    <name>SHIWIVI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>systemd</title>
    <link href="https://shiwei11.github.io/blog/2025/07/21/systemd/"/>
    <id>https://shiwei11.github.io/blog/2025/07/21/systemd/</id>
    <published>2025-07-20T16:00:00.000Z</published>
    <updated>2024-12-04T02:23:29.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>systemd 是由Lennart Poettering(当时就职于Red Hat公司)领导开发的一套Linux服务和系统管理工具，用来为Linux提供一种更高效的启动管理机制以替代曾经的initd守护进程，并为用户提供并行化管理服务。systemd在Linux启动时会作为系统的第一个进程(PID为1)启动，然后由其负责启动系统的其它进程，大多数现代 Linux 发行版(如 Ubuntu、Debian、Fedora、CentOS、Arch Linux 等)都默认使用systemd来管理服务和系统进程，systemd主要提供以下功能：</p><ul><li>服务管理：管理各类服务的启动、自启动、停止</li><li>依赖管理：管理服务依赖关系，确保服务按正确顺序启动</li><li>日志记录：提供 journald 日志系统，收集和存储系统日志</li><li>设备和挂载管理：支持动态设备挂载和自动挂载</li><li>维护基本系统配置：管理系统主机名、日期、区域设置，维护已登录用户和网络时间同步等</li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>systemd官网：<a href="https://systemd.io/">https://systemd.io/</a></div><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><h5 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h5><p>systemd 的配置文件路径是编译时指定的，用户无法修改，systemd所有的配置文件基本都存放在以下几个目录中，根据优先级顺序依次为：</p><ul><li><span class="strong">/etc/systemd/</span>：存放用户配置文件，<span class="tips">优先级最高</span>，如果其他目录中存在与该目录下的文件同名的配置文件，则该目录中的文件会覆盖其他路径中的同名文件</li><li><span class="strong">/run/systemd/</span>：运行时生成的配置文件目录，用于存放在运行时生成的单元文件等，<span class="tips">优先级次于用户配置文件</span>，通常由系统或服务动态创建</li><li><span class="strong">/usr/lib/systemd/(或 /lib/systemd/)</span>：系统提供的默认配置文件，<span class="tips">优先级最低</span>，方便用户覆盖</li></ul><p>除了以上目录外，用户还可以创建如/etc/systemd/*.conf.d/,/usr/lib/systemd/*.conf.d/等类似的drop-in配置子目录，这些drop-in将具有更高的优先级</p><h5 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h5><p>以上目录中通常同时包含多种不同类型的systemd配置文件，以<span class="tips">/etc/systemd/</span>为例，该目录下可能存在以下文件或目录：</p><ul><li>/etc/systemd/system.conf：系统级systemd配置文件，是systemd软件自身的配置文件，定义了很多影响 systemd 行为的全局设置。它控制系统级的资源管理、进程限制等</li><li>/etc/systemd/user.conf：用户级别的systemd配置文件，类似于 system.conf，该文件控制的是用户级别的服务行为</li><li>/etc/systemd/system/：存放全局的单元(Unit)文件，该目录中存放的单元文件通常是系统级的守护进程、服务、挂载单元、target单元、定时单元等，通常由管理员创建且需要root权限</li><li>/etc/systemd/user/：用于存放用户级别的单元文件，通常是一些仅在用户会话中运行的服务，不需要root权限</li><li>/etc/systemd/journald.conf：systemd日志系统journald的配置文件，用于定义日志的存储、大小、级别等参数</li><li>/etc/systemd/network/：该目录用于配置与网络相关的systemd 网络管理单元，包含网络接口配置文件(如静态IP配置)等</li><li>/etc/systemd/logind.conf：用于配置与systemd-logind相关服务，管理用户会话和登录等</li></ul><h5 id="配置文件语法"><a href="#配置文件语法" class="headerlink" title="配置文件语法"></a>配置文件语法</h5><p>systemd的配置文件语法参考了XDG Desktop Entry规范，而XDG的语法又受到Windows中.ini文件的影响，以下是systemd中各类配置文件的一些通用语法规则：</p><ul><li>配置文件都是纯文本文件，以<span class="tips">key=value</span>形式指定</li><li>空行和以<span class="tips">#</span>、<span class="tips">;</span>开头的文件会被忽略，因此这两个符号可用来写注释行</li><li>配置文件中，如果内容在一行中写不下，可以使用反斜杠<span class="tips">\</span>在下一行续写，systemd在读取时会将两行合并，并使用空格替换反斜杠。如果反斜杠后为注释行，则注释行会被忽略，systemd将合并注释行后的内容</li><li>配置文件中的布尔值可以以各种格式书写，如：1、yes、true、on等价；0、no、false、off等价</li><li>配置文件中的时间，不标注单位时默认以秒为单位，单位支持使用y(year,years)、M(months, month)、w(weeks, week)、d(days, day)、h(hours, hour, hr)、m(minutes, minute, min)、s(seconds, second, sec)、ms(msec)、us(usec)</li><li>配置文件支持使用C语言的转义字符</li></ul><h4 id="unit的类型"><a href="#unit的类型" class="headerlink" title="unit的类型"></a>unit的类型</h4><p>systemd将系统资源和服务抽象为各种单元(unit)，并使用单元配置文件来创建和管理单元，systemd一共提供了11种unit：</p><ul><li><span class="strong">Service unit</span> 用于定义和管理各类服务，如启动、停止、重启服务</li><li><span class="strong">Socket Unit</span> 用于管理网络或 FIFO管道，当有基于Socket的连接时自动启动对应的服务</li><li><span class="strong">Target unit</span> 将多个unit组合为一个组，进行统一的管理(开启、关闭、依赖等)</li><li><span class="strong">Mount Unit</span> 用于定义和管理挂载点</li><li><span class="strong">Automount Unit</span>用于自动挂载，通常与.mount 配合使用，仅在访问时才挂载资源</li><li><span class="strong">Path Unit</span> 用于监控文件或目录的状态变化，当条件满足时触发相关服务</li><li><span class="strong">Slice Unit</span> 切片单元，用于对一组进程进行系统资源的分配与限制</li><li><span class="strong">Scope Unit</span> 与service类似，但Scope是由systemd根据 D-bus 接口接收到的信息自动创建，通常用于管理非 Systemd启动的外部进程</li><li><span class="strong">Device Unit</span> 用于表示系统中的硬件设备</li><li><span class="strong">Swap Unit</span> 用于管理交换分区或交换文件</li><li><span class="strong">Timer Unit</span> 定时器，用来替代传统的crond等，以执行定时任务</li></ul><h4 id="unit的状态"><a href="#unit的状态" class="headerlink" title="unit的状态"></a>unit的状态</h4><p>系统中的unit通常可以处于以下状态，各种单元类型可能会在此基础之上具有许多额外的子状态</p><ul><li>active 活动状态，表示单元已经启动、激活等</li><li>inactive 停止</li><li>activating 正在启动</li><li>deactivating 正在停止</li><li>failed  失败</li><li>maintenance  单元已停止，且在进行维护操作</li><li>reloading 正在重新加载其配置</li></ul><h3 id="unit单元文件"><a href="#unit单元文件" class="headerlink" title="unit单元文件"></a>unit单元文件</h3><h4 id="单元文件路径"><a href="#单元文件路径" class="headerlink" title="单元文件路径"></a>单元文件路径</h4><p>unit单元文件目录位于systemd配置文件路径下，根据优先级顺序依次为：</p><ul><li><span class="strong">/etc/systemd/system/</span>：存放系统级单元文件，<span class="tips">优先级最高</span>，如果其他目录存在与系统单元文件同名的文件，则该目录中的文件会覆盖其他路径中的同名文件</li><li><span class="strong">/run/systemd/system/</span>：运行时生成的配置文件目录，用于存放在运行时生成的单元文件，<span class="tips">优先级次于用户配置文件</span>，通常由系统或服务动态创建</li><li><span class="strong">/usr/lib/systemd/system/(或 /lib/systemd/system/)</span>：系统提供的默认单元文件，<span class="tips">优先级较低</span>，通常由软件包管理器安装配置</li></ul><p>system目录用来存放系级单元文件，该路径下还存在user目录，如果需要存放用户单元文件，只需要将以上路径中的system改为user即可，单元文件名需要遵守以下规则：</p><ul><li>单元文件名前缀可以包含字母、数字和-._:\符号</li><li>必须包含单元类型后缀，如：game-start.service</li></ul><h4 id="Unit-块"><a href="#Unit-块" class="headerlink" title="[Unit]块"></a>[Unit]块</h4><p>[Unit]部分用来书写单元的通用信息，且所有类型的单元文件都会有该块，只列出了部分配置项，完整的[unit]块配置请参考：</p><div class="broadcast color-pink"><a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html">https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html</a></div><ul><li><p><span class="strong">Description=</span><br>指定对该单元的简短描述，根据官方文档，这里的属性虽然是Description，但所指定的字符串应该是对该单元功能或身份的简洁”标识”或”标签”，方便用户快速识别，而不是详细描述它，如果需要详细描述，应该写在Documentation字段指向的外部文档中。Description所指定的字符串，systemcted会在状态消息中(如执行 systemctl status时)显示该字符串(因此应该开头大写)，如：Description=Nginx Web Server，systemd将在启动nginx时显示Starting Nginx Web Server</p></li><li><p><span class="strong">Documentation=</span><br>该单元以及其配置文件的相关文档，可以指定多个URI(可以是URL或URN)，使用空格进行分隔。这里的URI仅支持”http://“、”https://“、”file：”、”info：”、”man：” 类型的 URI，如：man:command(6)</p></li><li><p><span class="strong">Wants=</span><br>指定该单元的弱依赖单元，即使依赖单元启动失败，该单元仍会继续运行。此选项可以多次指定，也可以在一个选项中指定多个空格分隔的单位。注意，该选项配置的依赖关系不会影响服务的启动顺序，通常情况下，依赖单元和当前单元会同时启动。向单元文件附带的 .wants/ 目录添加单元的符号链接等同于在该配置项中添加单元。</p></li><li><p><span class="strong">Requires=</span><br>指定该单元的强依赖单元，该单位启动时，也将启动该选项配置的这些单元。如果依赖单元启动失败、中途被”显式”停止或重启，该单元也将相应地启动失败、停止、重启。但这并不意味着当此单元运行时，另一个单元必须始终处于活动状态，如：单元启动成功后，某些依赖单元完成使命正常退出，这将不会影响到当前的单元。向单元文件附带的 .requires/ 目录添加单元的符号链接等同于在该配置项中添加单元。</p></li><li><p><span class="strong">Requisite=</span><br>类似于requires，但是，该选项配置的是当前单元运行的必要前提条件，即当前单元运行前，这些单元必须已经运行，如果该选项指定的单元未启动，systemd将不再尝试启动当前单元，而将直接判定启动失败。因此，该设置通常与 After= 结合使用，以确保当前单元不会在Requisite配置的单元之前启动</p></li><li><p><span class="strong">BindsTo=</span><br>类似于requires，但BindsTo所绑定的依赖关系更强，除了拥有requires的特点外，BindsTo会将当前单元的生命周期绑定到依赖单元，当前单元的运行严格依赖于依赖单元的存续。BindsTo所绑定的单元如果停止，则当前单元也将停止。该配置项用于需要紧密关联的单元，例如一个服务与其挂载点的绑定，如果挂载点被卸载或停止，当前服务也停止</p></li><li><p><span class="strong">Upholds=</span><br>类似于Wants，但不同点在于，当前单元对Wants所指定单元的依赖是一次性的，systemd只会在启动当前单元时尝试启动Wants中指定的依赖，后续这些依赖是否停止，systemd都不再关心。而当前单元对Upholds所指定单元的依赖是持续性的，如果后续当前单元还在运行，而Upholds单元中途停止，systemd将不断尝试重启它们，即便它们不是强依赖单元。</p></li><li><p><span class="strong">Conflicts=</span><br>指定冲突单元，表示两个单元之间存在冲突关系，不能同时运行。如：假设A.service的配置文件中配置了Conflicts=B.service，则在启动A时，如果B正在运行，将关闭B。同样，如果启动B时，A正在运行，则将关闭A，即时B的配置中未显式声明Conflicts=A。注意，Conflicts同样不会指定服务的启动或关闭顺序，如果需要确保在启动A单元之前，先停止B单元，需要显式添加After或Before配置</p></li><li><p><span class="strong">Before=</span><br>定义单元的启动顺序，表示当前单元必须在Before所指定的单元之前启动，关闭时必须在这些单元之后关闭。如：A的配置文件配置了Before=B，则A必须在B之前启动，在B之后关闭。</p></li><li><p><span class="strong">After=</span><br>定义单元的启动顺序，表示当前单元必须在After所指定的单元之后启动，关闭时必须在这些单元之前关闭。如：A的配置文件配置了After=B，则A必须在B之后启动，在B之前关闭。</p></li><li><p><span class="strong">ConditionPathExists=</span><br>检查所指定的路径和文件是否存在，如果指定的绝对路径名不存在，将停止启动单元。可以在路径前加上一个<span class="tips">!</span>，表示当该文件不存在时，才启动该单元</p></li></ul><h4 id="Install-块"><a href="#Install-块" class="headerlink" title="[Install]块"></a>[Install]块</h4><p>[Install]块用于配置单元的安装和启用信息，</p><div class="broadcast color-green"><a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options">https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BInstall%5D%20Section%20Options</a></div><ul><li><p><span class="strong">Alias=</span><br>定义单元的别名，<span class="tips">该别名必须与原单元文件名具有相同的后缀(即type)</span>，可以指定多个别名，空格分隔。指定了别名后，在使用systemctl enable开机自启用单元时，将在<span class="tips">/etc/systemd/system</span>对应目录中创建一个符号链接并指向<span class="tips">/usr/lib/systemd/system</span>目录中的原单元文件，此后，用户可以通过这些别名启动服务</p></li><li><p><span class="strong">WantedBy=</span><br>指定当前单元希望被哪些单元作为依赖使用(弱依赖)，可以指定多个值，空格分隔。指定了值后，当通过 systemctl enable 命令安装当前单元时(开机自启动)，将会在这些WantedBy所指定的每一个单元的<span class="tips">.wants/</span> 目录中创建一个当前单元的符号链接。这里通常会指定一个target类型的单元值，即指定当前单元在哪种Linux开机模式下会被启动，如：在服务A的配置文件中添加WantedBy　=　multi-user.target，则在执行systemctl enable A.service启用A单元后，systemd将在/etc/systemd/system/multi-user.target.wants目录中创建一个符号链接A.service，该符号链接指向/usr/lib/systemd/system/A.service，表示A服务会在Linux以常规多用户模式启动时开机自启动。当然配置的值也可以是其他unit类型，如：在服务A的配置文件中添加WantedBy　=　B.service，则A的符号链接将被添加到B.service.wants目录中，表示启动服务B时，希望启动A。指定服务依赖的功能和[Unit]块中的wants有点类似，不同点在于：</p><blockquote><blockquote><ul><li>Wants指定当前单元需要哪些依赖，WantedBy指定当前单元是其他单元的依赖</li><li>Wants指定单元运行时的依赖关系，单元的设置会在启动或加载时立即生效；WantedBy定义单元安装时依赖关系，需要使用 systemctl enable 使其生效</li></ul></blockquote></blockquote></li></ul><ul><li><p><span class="strong">RequiredBy=</span><br>指定当前单元必须被哪些单元作为依赖使用(强依赖)，这意味着当前单元的运行失败，将影响到其他单元的运行。用法与WantedBy类似，这里所指定的每一个单元，它们的<span class="tips">.Requires/</span>目录中将有可能被添加当前单元的符号链接(取决于当前单元是否开机自启动)</p></li><li><p><span class="strong">UpheldBy=</span><br>指定当前单元是哪些单元的维持性依赖，具体的依赖关系参考[Unit]块的Upholds，用法与WantedBy类似，但它没有类似的.Uphold目录，用于动态维持目标状态，使用场景较少</p></li><li><p><span class="strong">Also=</span><br>当使用systemctl enable 或 systemctl disable命令安装/卸载当前单元时，需要一起安装/卸载的其他单元，可以指定多个值，空格分隔</p></li></ul><h3 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h3><h4 id="Service-块"><a href="#Service-块" class="headerlink" title="[Service]块"></a>[Service]块</h4><p>[Service]块是service类型的单元文件专属块，也是必须块，[service]块的配置可参考:</p><div class="broadcast color-yellow"><a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html">systemd.service — Service unit configuration</a></div><ul><li><p><span class="strong">Type=</span><br>用于定义服务的启动类型，指定systemd 如何识别服务的启动完成状态以及如何管理服务的主进程，它支持以下值：</p><blockquote><blockquote><ul><li><span class="strong">simple</span>：systemd在启动服务时，会fork()一个systemd服务管理子进程，然后在子进程中运行该服务。当指定Type=simple时，systemd服务管理器会在fork()结束后立即返回服务已经启动的状态，即便此时服务的二进制文件还未真正执行，甚至可能会执行失败(如权限不足)，因此该值可能具有一些潜在风险(如systemctl start命令错误返回服务启动状态，systemd因为识别服务已经启动而继续启动其他依赖造成启动顺序错误)，该值适用于一些简单的单进程服务或脚本。当指定了 ExecStart= 但未指定 Type= 和 BusName=时，该值是默认值</li><li><span class="strong">exec</span>：类似于simple，但systemd服务管理器会等到fork()结束且服务的二进制文件被执行后才返回服务已启动的状态，因此该值不会存在二进制文件执行失败，但systemd识别为服务已经启动的情况。如果二进制文件执行失败，systemctl start 命令将正确报告服务启动失败状态。建议对长时间运行的服务使用 Type=exec</li><li><span class="strong">oneshot</span>：类似于simple，但oneshot表示该服务是一次性的短期任务，systemd会在该服务成功执行并退出后才视为服务启动完毕，然后开始执行后续任务。该类型适合用来配置哪些需要前期迅速执行完毕，为后续任务铺设环境的一次性任务，如初始化脚本、配置加载、清理上次登录的临时文件等任务。该选项通常需要配合 RemainAfterExit=true 配置项，来让systemd在返回其状态时返回值为”active”，否则，由于该服务会在执行完毕后退出，会导致其状态会直接从”activating”跳到”dead”或”deactivating”。当Type=和ExecStart=配置均未指定时，systemd将默认指定Type=oneshot</li><li><span class="strong">dbus</span>：dbus的行为类似于simple，但这种类型的单元必须指定 BusName= 配置，相反，如果指定了BusName=的值而未指定Type，则默认为Type=dbus。服务通过D-Bus总线注册完成后，systemd才会认为它已启动，该类型适用于基于D-Bus的服务</li><li><span class="strong">notify</span>：notify的行为类似于exec，不同之处在于服务在完成启动时会通过 sd_notify()或其他兼容的库的类似调用向systemd 发送”READY=1”消息，来告诉systemd当前服务已经启动完成。systemd会等待通知消息后再认为服务已启动。适用于需要执行一些初始化工作后，明确通知启动完成的服务</li><li><span class="strong">idle</span>：类似于simple，但服务的启动会延迟到所有其他任务完成后再运行，避免服务启动时，shell的输出混乱。该值仅用于避免控制台输出混乱，不用作通用的unit启动排序工具，因此服务启动延迟时间限制为5s，超时后无论如何都会启动服务。可用于非关键任务，让它们系统启动完成后再启动</li><li><span class="strong">forking</span>：服务会通过父进程创建子进程(fork)的方式运行，并且父进程会退出，子进程作为服务的主进程。这是传统UNIX守护进程设计模式的一种方式，当一个进程启动时，通常会绑定到启动它的终端tty，如果终端关闭，进程可能会受到 SIGHUP 信号的影响而退出，因此传统的守护进程(daemon)设计时，会先启动一个父进程，然后通过fork()创建子进程，然后父进程退出，子进程作为主进程继续运行。此时子进程可以在一个相对干净的环境中运行，且脱离了终端控制，成为孤儿进程并交由systemd接管。当Type=forking时，systemd会在父进程退出时，视为服务启动完成，由于这是传统UNIX的设计，因此对于现代项目，文档不建议使用此类型，而是建议改用 notify、notify-reload 或 dbus。如果一定要用该类型，建议同时PIDFile= 选项一起使用，以便 systemd 能够可靠地识别服务的主进程</li></ul></blockquote></blockquote></li><li><p><span class="strong">ExitType=</span><br>指定退出类型，告诉systemd服务管理器何时认为当前unit已经关闭，有以下两个取值：</p><blockquote><blockquote><ul><li><span class="strong">main</span>：默认值，当服务主进程退出时，认为该单元已经停止。由于oneshot类型的服务是在主进程退出后才视为服务开始启动，因此该值不能与Type=oneshot 一起使用，</li><li><span class="strong">cgroup</span>：只要 cgroup 中至少有一个进程尚未退出，该服务就会被视为正在运行</li></ul></blockquote></blockquote></li><li><p><span class="strong">ExecStart=</span><br>启动服务时执行的命令，如果服务类型Type是oneshot，可以指定多个命令，否则<span class="text-red">只能指定一个命令！</span>通过该命令启动的进程将被视为守护进程的主进程(Type=forking的服务除外，因为此时子进程才是主进程)。当Type=oneshot时，可以指定多个要执行的命令，空格分隔，systemd会依次执行它们，如果其中一个命令失败，则该单元会被视为启动失败。可以在命令前添加”-“，则此时即便该命令执行失败，systemd也会继续执行后续命令，且不会视为单元启动失败。</p></li><li><p><span class="strong">RemainAfterExit=</span><br>一个boolean值，该值指定是否应将服务视为活动状态，即使其所有进程都已退出，默认为 no，通常Type=oneshot会用到该配置项</p></li><li><p><span class="strong">PIDFile=</span><br>指定一个PID文件路径，通常是/run目录下的路径，该配置项通常用来搭配Type=forking配置，以此告诉systemd服务管理器从该PID文件中读取服务主进程的PID，文档建议现代项目中尽量少使用</p></li><li><p><span class="strong">BusName=</span><br>指定服务应使用的D-Bus目标名称，该配置项是Type=dbus时的必须配置</p></li><li><p><span class="strong">ExecStartPre=</span><br>在 ExecStart= 所指定的命令执行前执行的其他命令。语法与 ExecStart= 相同，但允许指定多个命令，命令会依次执行。这些命令中任何一个命令(不以”-“前缀)执行失败，都将不再执行后续命令，并视为该单元启动失败。ExecStart所指定的命令只会在ExecStartPre所指定的所有命令(不以”-“前缀)成功退出后才开始执行</p></li><li><p><span class="strong">ExecStartPost=</span><br>在 ExecStart= 所指定的命令执行后执行的其他命令。语法与 ExecStart= 相同，但允许指定多个命令，命令会依次执行。这些命令中任何一个命令(不以”-“前缀)执行失败，都将不再执行后续命令，并视为该单元启动失败。ExecStartPost所指定的命令只会在ExecStart所指定命令成功启动后执行，具体执行时间取决于systemd何时收到服务启动通知，具体参考Type配置项各类型的服务何时视为启动成功</p></li><li><p><span class="strong">ExecReload=</span><br>服务的配置被重新加载时需要执行的命令，可以指定多个命令，遵循与ExecStart=相同的配置方案</p></li><li><p><span class="strong">ExecStop=</span><br>指定停止当前服务时用户需要输入的命令，该配置遵循与ExecStart=相同的配置方案，该配置项是可选的，如果没有设置该配置，则服务停止时，将通过发送 KillSignal= 或 RestartKillSignal= 中指定的信号来终止进程。</p></li><li><p><span class="strong">ExecStopPost=</span><br>在服务停止后执行的其他命令，服务停止的方式可以是通过执行ExecStop所指定的命令、启动失败停止、服务意外退出、收到系统信号终止等，这些都会触发systemd执行ExecStopPost所指定的命令。该配置项常用来设置一些服务停止后的清理工作，或者服务启动失败时，清理不完整的初始化数据</p></li><li><p><span class="strong">RestartSec=</span><br>指定重新启动服务之前的休眠时间，可以直接指定一个数值(单位为秒)，也可以是时间跨度(如：5min 20s)，默认为100ms</p></li><li><p><span class="strong">Restart=</span><br>配置在服务进程退出(exit)、终止(kill)或达到超时(timeout)时是否应重新启动服务，支持以下值：</p><blockquote><blockquote><ul><li><span class="strong">no</span>：默认值，不重启服务</li><li><span class="strong">on-success</span>：仅当服务服务正常退出(退出代码是零)时才重启</li><li><span class="strong">on-failure</span>：服务因非零退出代码或异常信号失败时重启</li><li><span class="strong">on-abnormal</span>：服务因异常信号(如：SIGKILL、SIGSEGV等)终止时会重启</li><li><span class="strong">on-watchdog</span>：服务因看门狗超时被杀死时会重启，适用于需要高可靠性的服务，并启用了看门狗功能。systemd中，看门狗是用来监控服务或进程是否正常运行的进程，服务需要每隔一段时间就向看门狗发送一个报告，来表示服务在正常运行，如果超时时间内没有报告，systemd会认为服务卡住或挂起，然后会尝试重启或唤醒服务</li><li><span class="strong">on-abort</span>：服务因收到 SIGABRT信号终止时会重启，适用于需要响应服务主动触发中止操作的场景</li><li><span class="strong">always</span>：无论服务如何退出（成功、失败或异常），都进行重启</li></ul></blockquote></blockquote></li></ul><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>以下配置项也可以写于[service]块中以指定执行环境，参考文档：<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html">systemd.exec — Execution environment configuration</a></div><ul><li><p><span class="strong">StandardInput=</span><br>控制标准输入连接到何处，可取以下值：</p><blockquote><blockquote><ul><li><span class="strong">null</span>：(默认)连接到/dev/null，进程的所有读取尝试都将导致立即 EOF</li><li><span class="strong">tty</span>：连接到 TTY，通常还需要用TTYPath指定tty的挂载路径</li><li><span class="strong">file:绝对路径</span>：连接到该文件</li><li><span class="strong">data</span>：传递一段文本或二进制数据给当前服务，传递内容通过StandardInputText=/StandardInputData=指定</li></ul></blockquote></blockquote></li><li><p><span class="strong">StandardOutput=</span><br>控制标准输出连接到何处，可取以下值：</p><blockquote><blockquote><ul><li><span class="strong">inherit</span>：将标准输入的文件描述符复制给标准输出</li><li><span class="strong">null</span>：连接到 /dev/null，丢弃所有输出</li><li><span class="strong">tty</span>：连接到 TTY，通常还需要用TTYPath指定tty的挂载路径</li><li><span class="strong">journal</span>：(默认)连接到journal日志</li><li><span class="strong">kmsg</span>：连接到内核日志缓冲区</li><li><span class="strong">journal+console</span>：连接到日志并输出一份到控制台</li><li><span class="strong">file:绝对路径</span>：连接到该文件</li><li><span class="strong">append:绝对路径</span>：以附加形式连接到该文件</li></ul></blockquote></blockquote></li><li><p><span class="strong">StandardError=</span><br>控制标准错误输出连接到何处，可取与StandardOutput相似</p></li><li><p><span class="strong">StandardInputText=, StandardInputData=</span><br>指定一段文本或二进制数据，通过标准输入传递给当前服务，需要指定 StandardInput=data，否则该配置项不生效</p></li></ul><h4 id="service配置案例"><a href="#service配置案例" class="headerlink" title="service配置案例"></a>service配置案例</h4><div class="shell">e.g.Nginx的配置[Unit]Description=The NGINX HTTP and reverse proxy serverAfter=network.target</br>[Service]Type=forkingExecStart=/usr/sbin/nginxExecReload=/usr/sbin/nginx -s reloadExecStop=/usr/sbin/nginx -s stopPIDFile=/run/nginx.pidPrivateTmp=true</br>[Install]WantedBy=multi-user.target</div><div class="show">写一个shell脚本，通过systemd管理，要求：testA.sh的输出信息输出到终端而不是日志，testA.sh执行前输出启动提示文本testA.sh弱依赖testB.shtestB.sh的输出信息输出到日志1.编写/myShell/testA.sh内容#!/bin/bashecho "脚本A开始执行"sleep 5echo "脚本A执行完毕"2.编写/myShell/testB.sh内容#!/bin/bashecho "脚本B开始执行"sleep 3echo "脚本B执行完毕"3.赋予脚本可执行权限chmod +x testA.sh testB.sh4.编写/etc/systemd/system/testA.service内容[Unit]Description=test A serviceWants=testB.service<br>[Service]Type=oneshot  #simple类型不会等待脚本执行完毕返回，oneshot则会等待脚本执行ExecStart=/myShell/testA.shStandardOutput=ttyStandardError=ttyTTYPath=/dev/pts/0ExecStartPre=/bin/echo "服务A启动"5.编写/etc/systemd/system/testB.service内容[Unit]Description=test B service<br>[Service]Type=simpleExecStart=/myShell/testB.sh6.让systemd重新加载配置systemctl daemon-reload7.执行testA服务systemctl start testA</div><h3 id="Target类型"><a href="#Target类型" class="headerlink" title="Target类型"></a>Target类型</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>target 是一种特殊的单元类型，用于将多个相关的服务或单元组合到一起，然后一次性启动或关闭，这样就不需要手动一个个启动这些单元了。systemd预定义了一些target类型的单元，用于在特定情况启动(如：插入声卡、连接蓝牙时)，其中包括一些系统关闭或启动时会执行的单元，这些target类型的单元对应传统的 SysV 运行级别(runlevel)，用户也可以自行创建并配置target单元</p><p>target类型的Unit单元配置文件仅支持[Unit] 和 [Install]配置块，不存在专属[Target]块</p><h4 id="运行级别与预定义Target"><a href="#运行级别与预定义Target" class="headerlink" title="运行级别与预定义Target"></a>运行级别与预定义Target</h4><div class="table"><table><thead><tr><th>运行级别(runlevel)</th><th>systemd target(target别名)</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>poweroff.target(runlevel0.target)</td><td>关机</td></tr><tr><td>1</td><td>rescue.target(runlevel1.target)</td><td>单用户状态，只启动系统核心，用于系统修复和维护</td></tr><tr><td>2</td><td>multi-user.target(runlevel2.target)</td><td>多用户状态，禁用NFS(网络文件系统)和网络服务，可用于停机维护</td></tr><tr><td>3</td><td>multi-user.target(runlevel3.target)</td><td>完全多用户状态，具有完整的功能</td></tr><tr><td>4</td><td>无</td><td>系统未使用，保留</td></tr><tr><td>5</td><td>graphical.target(runlevel5.target)</td><td>GUI模式，桌面版Linux专属</td></tr><tr><td>6</td><td>reboot.target(runlevel6.target)</td><td>系统重启</td></tr></tbody></table></div><div class="broadcast color-pink">查看更多预定义的target：<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.special.html">systemd.special — Special systemd units</a></div><h4 id="target常用命令"><a href="#target常用命令" class="headerlink" title="target常用命令"></a>target常用命令</h4><ul><li><p><span class="strong">systemctl isolate target名</span>临时切换到该target(可以实现临时切换运行级别)</p></li><li><p><span class="strong">systemctl set-default target名</span>设置默认目标(持久化修改开机运行级别)</p></li></ul><h4 id="开机自启动与target"><a href="#开机自启动与target" class="headerlink" title="开机自启动与target"></a>开机自启动与target</h4><p>当用户执行<span class="tips">systemctl enable unit名</span>设置单元开机自启动时，systemd会在<span class="tips">/etc/systemd/system/multi-user.target.wants/</span>(假设当前开机默认启动target为multi-user.target)中创建一个该单元文件的符号链接，这样就实现了开机启动该单元的功能。相反，当用户执行<span class="tips">systemctl disable unit名</span>来禁止单元开机自启动时，systemd会删除<span class="tips">/etc/systemd/system/multi-user.target.wants/unit名 </span>符号链接，从而阻止其在系统启动时自动启动。</p><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>systemctl是systemd的提供的主要命令行工具，用来通过统一的接口来管理系统的各项服务，调用systemctl时会默认使用<span class="tips">-&zwnj;-system</span>选项，用于管理系统级单元，这可能需要root权限。如果需要管理用户级单元，应该显式指定<span class="strong">systemctl -&zwnj;-user</span></p><h4 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h4><p>在systemd被广泛运用到各发行版中后，Linux中传统的系统管理命令(如：halt、poweroff、reboot等)通常会调用systemd 提供的命令，如：执行 halt 实际上会调用 systemctl halt命令</p><ul><li><div class="strong">systemctl is-system-running</div>检查系统是否正常运行，是则返回0，如果系统处于正在启动、维护、关闭状态，或者有失败的启动服务时，返回非零值</li><li><span class="strong">systemctl default</span>进入默认模式</li><li><span class="strong">systemctl rescue</span>进入救援模式</li><li><span class="strong">systemctl emergency</span>进入紧急模式</li><li><span class="strong">systemctl halt</span>关闭系统，但保持硬件的开机状态</li><li><span class="strong">systemctl poweroff</span>关闭系统并关闭系统电源</li><li><span class="strong">systemctl reboot</span>重启系统</li><li><span class="strong">systemctl soft-reboot</span>软重启，重新启动用户空间</li><li><div class="strong">systemctl suspend</div>挂起(暂停)系统，系统会将当前的会话状态(如打开的应用程序和文件)保存在内存中，并将设备置于低功耗状态</li><li><div class="strong">systemctl hibernate</div>进入休眠状态，休眠模式会将系统的当前状态保存到硬盘(通常是交换分区或交换文件)，然后完全关闭电源，下次开机将从硬盘恢复系统状态</li><li><div class="strong">systemctl hybrid-sleep</div>进入混合睡眠状态，该状态下，系统首先将当前会话状态保存在内存中，并备份一份到硬盘，然后将设备置于低功耗状态。如果之后系统正常唤醒，直接从内存加载数据。如果系统意外关闭(例如电源耗尽)，用户也可以从硬盘恢复数据</li><li><div class="strong">systemctl suspend-then-hibernate</div>挂起后休眠，在这种模式下，系统首先进入挂起状态(suspend)，将当前会话的状态保存在内存中，在一定时间后(通常是系统设置的超时设置)，如果没有用户活动，系统会自动切换到休眠状态(hibernate)，将会话状态保存到硬盘中并完全关闭电源，此模式适合用户需要短时间内离开电脑，但又希望在长时间未使用时确保数据安全的状况</li><li><div class="strong">systemctl sleep</div>进入睡眠状态，sleep模式在不同发行版中设置可能有所不同，可能执行suspend、hibernate、hybrid-sleep、suspend-then-hibernate中的任意一种，默认情况下，通常可能为suspend-then-hibernate</li></ul><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>详细文档：<a href="https://www.freedesktop.org/software/systemd/man/latest/systemctl.html#System%20Commands">https://www.freedesktop.org/software/systemd/man/latest/systemctl.html#System%20Commands</a></div><h4 id="查看系统状态"><a href="#查看系统状态" class="headerlink" title="查看系统状态"></a>查看系统状态</h4><ul><li><p><span class="strong">systemctl status</span>查看系统状态</p></li><li><p><span class="strong">systemctl -&zwnj;-failed</span>列出失败的单元</p></li><li><p><span class="strong">systemctl list-unit-files</span>列出已经安装的单元</p></li><li><p><span class="strong">systemctl status PID值</span>查看对应PID进程的状态</p></li><li><p><span class="strong">systemctl daemon-reload</span>重新加载systemd单元配置，扫描单元变动</p></li></ul><h4 id="单元管理命令"><a href="#单元管理命令" class="headerlink" title="单元管理命令"></a>单元管理命令</h4><p><span class="strong">systemctl [选项] 命令 单元名/模式</span></p><ul><li>-t unit类型(-&zwnj;-type=unit类型)：在列出unit单元信息时，默认会列出所有类型的单元，通过该选项可以指定只列出某几个类型的单元</li><li>-&zwnj;-state=状态：在列出unit单元信息时，默认会列出所有状态的单元，通过该选项可以指定只列出处于所指定状态的单元</li><li>-p 属性名(-&zwnj;-property=属性名)：显式属性时，默认显式所有属性，该选项可以用来指定只显示所指定的1个或多个属性</li><li>该命令中的单元名，可以使用模式(PATTERN)来匹配多个单元(模式支持使用<span class="tips">*</span>和<span class="tips">?</span>，也支持使用<span class="tips">[]</span>匹配字符范围)，也可以是具体的单元名，当指定具体单元名时，需要指定其完整的单元名，包括扩展名(如：sshd.socket)，以下情况可以省略扩展名：<blockquote><blockquote><ul><li>如果不指定拓展名，systemctl会默认扩展名为<span class="tips">.service</span>，因此如果操作对象的unit类型为service，可以不指定拓展名</li><li>挂载点会自动指定为<span class="tips">.mount</span>单元，如：<span class="tips">/home</span>等价于<span class="tips">home.mount</span></li><li>设备会自动指定为<span class="tips">.device</span>单元，如：<span class="tips">/dev/sda2</span>等价于<span class="tips">dev-sda2.device</span></li><li>某些命令只能用来处理特定类型的单元，此时可以省略单元类型，如：systemctl isolate默认单元类型为target</li></ul></blockquote></blockquote></li></ul><h4 id="常用的单元管理命令"><a href="#常用的单元管理命令" class="headerlink" title="常用的单元管理命令"></a>常用的单元管理命令</h4><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><span class="strong">systemctl status 单元名或PID</span>单元名</td><td>查看单元或PID所属单元状态</td></tr><tr><td><span class="strong">systemctl start</span>单元名</td><td>启动单元，只能启动已经被systemd加载的单元</td></tr><tr><td><span class="strong">systemctl stop</span>单元名</td><td>停止单元</td></tr><tr><td><span class="strong">systemctl restart</span>单元名</td><td>重启单元，如果单元未启动，则启动单元</td></tr><tr><td>systemctl try-restart 单元名</td><td>重启已启动的单元，如果单元未启动，则不做任何操作</td></tr><tr><td><span class="strong">systemctl reload</span>单元名</td><td>让该单元重新加载其配置</td></tr><tr><td>systemctl reload-or-restart 单元名</td><td>尝试让单元重新加载其配置，如果加载失败，则尝试重启它。如果指定的单元尚未启动，则启动它</td></tr><tr><td>systemctl try-reload-or-restart  单元名</td><td>尝试让单元重新加载其配置，如果加载失败，则尝试重启它。如果指定的单元尚未启动，则不做任何操作</td></tr><tr><td><span class="strong">systemctl enable</span>单元名</td><td>开机自启动该单元</td></tr><tr><td><span class="strong">systemctl disable</span>单元名</td><td>取消开机自启动</td></tr><tr><td><span class="strong">systemctl reenable</span>单元名</td><td>重新启用单元</td></tr><tr><td><span class="strong">systemctl mask</span>单元名</td><td>屏蔽单元，该单元将无法手动启动，也无法作为依赖启动</td></tr><tr><td><span class="strong">systemctl unmask</span>单元名</td><td>取消屏蔽单元</td></tr></tbody></table></table></div><h5 id="systemctl-status返回值"><a href="#systemctl-status返回值" class="headerlink" title="systemctl status返回值"></a>systemctl status返回值</h5><ul><li><span class="strong">systemctl status</span> [单元名或PID]<br>如果指定了单元，则显示指定单元的运行时状态信息，以及这些单元最近的日志数据。如果指定了PID，那么显示指定PID所属单元的运行状态信息，以及这些单元最近的日志数据，默认输出10行日志，且会截断超长的部分。如果未指定任何单元或PID，那么显示整个系统的状态信息，此时若与 -&zwnj;-all 连用，则同时显示所有已加载单元(可以用-t选项限定单元类型)的状态信息。该命令旨在生成人类可读的输出，如果需要输出方便脚本分析的信息，应该使用systemctl show命令</li></ul><div class="shell">systemctl status nginx命令的返回值：<span style="color:#55ff55;">●</span> nginx.service -  Nginx is an HTTP(S) server, HTTP(S) reverse proxy and IMAP/POP3 proxy server   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; preset: enabled)   Active: <span style="color:#55ff55;">active (running)</span>  since Thu 2023-03-09 10:32:25 CST; 1 years 8 months ago     Docs: man:nginx(8) Main PID: 8473 (nginx)      CPU: 140ms   CGroup: /system.slice/nginx.service           ├─6205 nginx: worker process           └─8473 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<p>Nov 18 10:15:42 server-name nginx[1234]: 2021/11/18 10:15:42 [error] 2345#0: *1 open() …<br>Nov 18 10:15:53 server-name nginx[1234]: 2021/11/18 10:15:42 [error] 2345#0: *1 open() …</p></div><div class="show">以nginx为例，systemctl status nginx命令返回值主要包括以下部分：1. 第一行包含一个符号●，单元的名称，以及单元的简要描述符号●会根据单元的状态修改颜色和形状："inactive"或"maintenance"是一个白色圆圈 ○"active"是一个绿点 ●"deactivating"是一个白点 ●"failed"或"error"是一个红叉 ×"reloading"是一个绿色的顺时针圆箭头 ↻2. 第二行为单元Loaded状态，表示单元是否已经加载到了内存中loaded 表示服务配置文件已加载error 表示加载时出现问题not-found 表示未找到该单元的单元配置bad-setting 表示文件配置文件无法解析masked 表示单元文件被屏蔽/lib/systemd/system/nginx.service 为该单元文件路径enabled 表示服务被设置为开机自启动(disabled表示开机不自启，static表示服务是动态加载的，通常由其他服务触发运行)preset: enabled：预设值，表示服务被系统默认配置为启用3. 第三行为单元运行状态服务状态值通过颜色标识，绿色表示服务正常运行，黄色表示服务处于警告状态(例如未完全启动或有错误)，红色表示服务启动失败或停止服务状态值通常为"active"或"inactive"，也可能为"activating"(正在启动)或"deactivating"(正在关闭)，如果为"failed"，表示单元可能因为崩溃、错误退出、超时等情况进入了失败状态since之后表示服务启动时间，以及服务已经运行时间4. 第四行为文档信息，man:nginx(8)表示nginx的文档在man的第8部分5. 第五行为主进程信息，包含主进程PID，主进程的命令名称6. 第六部分通常为资源使用情况，通常可能包含内存使用情况，CPU的占用时间7. 第七部分为控制组信息，表示该服务所属的 cgroup 路径8. 第八部分为日志的部分信息</div><h4 id="单元状态查询命令"><a href="#单元状态查询命令" class="headerlink" title="单元状态查询命令"></a>单元状态查询命令</h4><ul><li><p><span class="strong">systemctl 或 systemctl list-units </span> 单元名<br>列出systemd已经加载的单元，默认列出处于活动、失败状态和正在处于任务队列的单元，使用-&zwnj;-all选项可以列出所有单元，可以使用-&zwnj;-type选项和-&zwnj;-state选项过滤要列出的单元</p></li><li><p><span class="strong">systemctl list-sockets [PATTERN]</span> 单元名<br>列出已加载的套接字(socket)单元，并按照监听地址排序。使用-&zwnj;-show-types选项可以显示套接字类型，支持-&zwnj;-all和-&zwnj;-state选项<br><span class="strong">systemctl list-timers [PATTERN]</span><br>列出已加载的定时器(timer)单元，并按照下次执行的时间点排序，支持-&zwnj;-all和-&zwnj;-state选项</p></li><li><p><span class="strong">systemctl is-active</span> 单元名<br>检查指定的单元中，是否有处于活动(active)状态的单元。如果存在至少一个处于活动(active)状态的单元，返回状态0，否则返回非零值。命令还会在标准输出打印单元状态，使用-&zwnj;-quiet选项可以禁止该输出</p></li><li><p><span class="strong">systemctl is-failed</span> 单元名<br>检查指定的单元中，是否有处于失败(failed)状态的单元。如果存在至少一个处于失败(failed)状态的单元，返回状态0，否则返回非零值。命令还会在标准输出打印单元状态，使用-&zwnj;-quiet选项可以禁止该输出</p></li><li><p><span class="strong">systemctl show</span> [单元名或JOB]<br>以”属性=值”的形式显示指定单元或任务的所有属性。单元用其名称表示，而任务则用其id表示。如果没有指定任何单元或任务，那么显示管理器(systemd)自身的属性。默认不显示属性值为空的属性，使用-&zwnj;-all选项可以显示所有属性。可以使用-&zwnj;-property选项可以仅显示特定的属性</p></li><li><p><span class="strong">systemctl cat</span> 单元名<br>显示指定单元的单元文件内容，首行会显示该单元文件的绝对路径</p></li><li><p><span class="strong">systemctl set-property</span> 属性名 值<br>在运行时修改单元的属性值，主要用于修改单元的资源控制属性值而无需直接修改单元文件，并非所有属性都可以在运行时被修改。 作修改会立即生效，并永久保存在磁盘上，以确保永远有效。如果使用了 -&zwnj;-runtime选项，那么此修改仅临时有效，下次重启此单元后，将会恢复到原有的设置。设置属性的语法与单元文件中的写法相同。如：systemctl set-property foobar.service CPUShares=777，可以同时修改多个属性值，只需依次将各个属性用空格分隔即可。</p></li><li><p><span class="strong">systemctl list-dependencies</span> [单元名]<br>显示单元的依赖关系，即显示由 Requires=, Requisite=, ConsistsOf=, Wants=, BindsTo= 所形成的依赖关系。如果没有明确指定单元的名称，那么表示显示default.target的依赖关系树。默认情况下，仅以递归方式显示 target 单元的依赖关系树，而对于其他类型的单元，仅显示一层依赖关系(不递归)。 但如果使用了-&zwnj;-all 选项，那么将对所有类型的单元都强制递归的显示完整的依赖关系树。还可以使用 -&zwnj;-reverse, -&zwnj;-after, -&zwnj;-before 选项指定仅显示特定类型的依赖关系</p></li></ul><h3 id="systemd-journald"><a href="#systemd-journald" class="headerlink" title="systemd-journald"></a>systemd-journald</h3><p>systemd-journald是systemd内置的日志收集和存储服务</p><h4 id="日志文件存储路径"><a href="#日志文件存储路径" class="headerlink" title="日志文件存储路径"></a>日志文件存储路径</h4><p>systemd-journald保存日志的方式有两种：<span class="tips">volatile</span>(临时存储，存储于内存)和<span class="tips">persistent</span>(持久化存储，存储于磁盘)，当前使用哪种存储方式取决于配置文件中的Storage配置项：</p><ul><li>持久化日志的存储位置为：<span class="tips">/var/log/journal/</span></li><li>临时日志的存储位置为：<span class="tips">/run/log/journal/</span>，该路径下存储的日志会在系统重启时丢失</li></ul><p>systemd-journald收集的日志文件通常分为两种，一种是当前处于活跃状态的(active)，通常文件名为<span class="tips">system.journal</span>，活跃状态的文件是journald正在写入的文件，通过journalctl命令删除日志时无论如何不会删除活跃的日志文件；另一种是已经归档的(archived)日志文件，文件名通常包含日志时间范围和系统标识符的哈希值，类似于<span class="tips"><code>system@0-000027b7a-000158412d.journal</code></span>，journald不会向这类文件再写入东西，这些通常是旧的日志文件。</p><h4 id="journalctl日志命令"><a href="#journalctl日志命令" class="headerlink" title="journalctl日志命令"></a>journalctl日志命令</h4><p>systemd-journald是以二进制格式存储日志的，不能使用传统vim、cat等工具直接打开，需要使用<span class="tips">journalctl</span>命令</p><p><span class="strong">journalctl [选项]</span></p><ul><li>默认情况下将显示所有日志，旧的日志显示在前，以分页形式显示，长行会被截断为屏幕宽度，可以使用左右箭头查看截断部分</li><li>-r 倒叙查看，最新的日志排于前</li><li>字段=值：过滤出指定的字段，如：_PID=1234(查看该PID服务的日志)，_UID=1111(查看该用户的日志)</li><li>-n 值：显示指定数量的日志条目</li><li>-u 服务名：查看指定服务的日志</li><li>-&zwnj;-since 日期：查看指定日期之后的日志，规范的指定日期形式为”yyyy-MM-dd HH:mm:ss”</li><li>-&zwnj;-untile 日期：查看指定日期之前的日志，规范的指定日期形式为”yyyy-MM-dd HH:mm:ss”</li><li>-f 实时查看日志，类似于tail -f命令</li><li>-p 日志等级：查看指定等级以上的日志，可取值有emerg, alert, crit, err, warning, notice, info, debug，也可以使用0-7的值依次代替这些等级</li><li>-o 输出格式：指定日志的输出格式，常用的输出格式有<blockquote><blockquote><ul><li>short：简洁格式</li><li>verbose：详细格式</li><li>json：JSON格式</li><li>cat：仅显示日志内容，不包含其他信息</li></ul></blockquote></blockquote></li><li>-&zwnj;-no-pager 禁用分页模式</li><li>-&zwnj;-disk-usage 显示所有日志文件在当前磁盘的占用情况</li><li>-&zwnj;-rotate 立即开始日志轮换，将当前活跃的日志文件立即归档并重命名，然后标记为archived，然后新建新的日志文件作为活跃文件</li><li>-&zwnj;-vacuum-size=值：删除最早的归档日志，直到日志所占用空间小于指定值，接受K、M、G、T单位</li><li>-&zwnj;-vacuum-time=值：删除早于指定时间跨度的归档日志，单位默认为s，接受m、h、days、weeks、months、years单位</li><li>-&zwnj;-vacuum-files=值：只保留指定数量的归档日志文件</li><li>-&zwnj;-sync 立即将日志同步到磁盘，在同步操作完成之前，此调用不会返回</li></ul><div class="broadcast color-purple">完整命令和选项参考官方文档：<a href="https://www.freedesktop.org/software/systemd/man/latest/journalctl.html">journalctl命令</a></div><h4 id="日志服务配置文件"><a href="#日志服务配置文件" class="headerlink" title="日志服务配置文件"></a>日志服务配置文件</h4><p>日志配置文件<span class="tips">journald.conf</span>的主文件路径是systemd编译时指定的，无法修改，这些路径包括<span class="tips">/etc/systemd/</span>、<span class="tips">/run/systemd/</span>、<span class="tips">/usr/local/lib/systemd/</span>、<span class="tips">/usr/lib/systemd/</span>，它们的优先级也是固定的，journald会按照上述顺序查找配置文件，只会加载第一个找到的文件。主配置文件用来定义系统默认配置，一般情况下，绝大部分Linux发行版的主配置文件只有<span class="tips">/etc/systemd/journald.conf</span>文件，且该文件中的配置项是被注释掉的，这是因为日志的默认配置在编译时内置到了journald服务中，journald.conf文件中的内容只是对这些默认值的说明，用来帮助管理员了解可以配置的选项及其默认行为。</p><p>除了主配置文件，日志服务还会从<span class="tips">/usr/lib/systemd/journald.conf.d/</span>、<span class="tips">/usr/local/lib/systemd/journald.conf.d/</span>、<span class="tips">/etc/systemd/journald.conf.d/</span>路径中查找配置文件，这些路径中的配置会覆盖系统的默认主配置，且这些路径中的配置文件会按上述顺序全部加载，对于只接受单个值的配置项，后面的配置会覆盖前面的，而对于接受多个值的配置项，所有配置都将生效。换而言之，<span class="tips">/etc/systemd/journald.conf.d/</span>路径下的配置文件优先级将是最高的，同一目录中的配置文件会按文件名字典顺序加载。</p><p>通常情况下，如果要修改日志的配置，只需要修改/etc/systemd/journald.conf文件即可，如果需要为不同的Unit单元或服务定制专属日志配置，则可以在/etc/systemd/目录中新建journald.conf.d(该目录通常需要自行创建)，然后在该目录中创建新的日志配置文件，如：my-global-settings.conf，该文件的优先级将是最高的，/etc/systemd/journald.conf文件的默认配置如下：</p><div class="shell">[Journal]#Storage=auto#Compress=yes#Seal=yes#SplitMode=uid#SyncIntervalSec=5m#RateLimitIntervalSec=30s#RateLimitBurst=10000#SystemMaxUse=#SystemKeepFree=#SystemMaxFileSize=#SystemMaxFiles=100#RuntimeMaxUse=#RuntimeKeepFree=#RuntimeMaxFileSize=#RuntimeMaxFiles=100#MaxRetentionSec=#MaxFileSec=1month#ForwardToSyslog=yes#ForwardToKMsg=no#ForwardToConsole=no#ForwardToWall=yes#TTYPath=/dev/console#MaxLevelStore=debug#MaxLevelSyslog=debug#MaxLevelKMsg=notice#MaxLevelConsole=info#MaxLevelWall=emerg#LineMax=48K#ReadKMsg=yes#Audit=no</div><h4 id="配置文件语法-1"><a href="#配置文件语法-1" class="headerlink" title="配置文件语法"></a>配置文件语法</h4><ul><li><p><span class="strong">Storage=</span><br>指定日志数据的存储方式，可以为以下值：</p><blockquote><blockquote><ul><li><span class="strong">volatile</span>：日志只存储于内存中，存储位置为：<span class="tips">/run/log/journal</span>,存储内容会在系统重启后丢失</li><li><span class="strong">persistent</span>：日志存储在磁盘上，存储位置为：<span class="tips">/var/log/journal</span>，但在系统引导初期(boot)以及磁盘无法写入时将回滚为volatile模式</li><li><span class="strong">auto</span>：如果目录/var/log/journal 存在，则写入磁盘，否则将回滚为volatile模式</li><li><span class="strong">none</span>：关闭日志存储，所有日志将被丢弃(但被转发到其他目标位置，如被转发到控制台、内核日志缓冲区或 syslog 套接字的配置仍将有效)</li></ul></blockquote></blockquote></li><li><p><span class="strong">Compress=</span><br>指定日志是否压缩，需要指定一个boolean值，默认为yes，此时会将大于默认阈值512bytes的数据进行压缩。也可以直接指定一个值，表示进行压缩的阈值，可以使用K、M、G等单位</p></li><li><p><span class="strong">Seal=</span><br>指定是否为持久化的日志文件启用安全密封(FSS)，以保护日志文件免受纂改，需要指定一个boolean值，默认为yes</p></li><li><p><span class="strong">SplitMode=</span><br>指定日志的分割方式,可以取以下值:</p><blockquote><blockquote><ul><li><soan class="strong">none</soan>：默认值,不分割日志</li><li><soan class="strong">uid</soan>：按用户ID分割日志</li></ul></blockquote></blockquote></li><li><p><span class="strong">RateLimitIntervalSec=,RateLimitBurst=</span><br>用于限制日志的写入速率，防止占用太多系统资源，默认值为30s内最多允许写入1000条日志，多余的日志会被丢弃。RateLimitIntervalSec用于指定限制时间，默认值为30，可以使用s、min、h、ms、us单位；RateLimitBurst用于指定上述时间内的限制写入条数，默认值为1000，二者需要搭配使用。当达到限制速率时，systemd-journald 会生成类似日志信息：”Rate limit reached for messages, suppressing X messages from Y services”，X表示被丢弃的日志数量，Y表示服务来源。将值设置为0表示不进行任何限制</p></li></ul><ul><li><p><span class="strong">RuntimeMaxUse=,SystemMaxUse=</span><br>指定内存，磁盘中日志最大占用空间，默认值均为当前文件系统大小的10%，上限为4G，当日志存储空间接近限制时，journald会删除旧的归档日志</p></li><li><p><span class="strong">RuntimeKeepFree=,SystemKeepFree=</span><br>指定需要为内存，磁盘保留多大空闲空间，默认值均为当前文件系统大小的15%，上限为4G。当内存或磁盘空间被非日志文件占用，剩余空间低于该设置的值时，journald将停止写入新日志，但不会去删除旧日志(是否删除旧日志取决于RuntimeMaxUse=或SystemMaxUse=设置的阈值)</p></li><li><p><span class="strong">RuntimeMaxFileSize=,SystemMaxFileSize=</span><br>指定单个日志文件的最大大小，达到此大小时，journald会创建一个新文件，默认值为SystemMaxUse= 和 RuntimeMaxUse= 的1/8，最大上限为128M，即如果SystemMaxUse的1/8超过了128M，上限仍为128M，如果启用了日志压缩，最大限制为4G</p></li><li><p><span class="strong">RuntimeMaxFiles=,SystemMaxFiles=</span><br>指定日志文件的最大数量，达到限制后，旧的日志文件会被删除，默认值为100</p></li><li><p><span class="strong">MaxFileSec=</span><br>指定单个日志文件能够记录数据的最长时间，一旦时间达到这个值，当前日志文件将被关闭并归档，journald 会启动一个新的日志文件来存储后续日志，默认值为1个月，可以使用year、month、week、day、h或m作为时间单位，默认单位为s，设置为0可以关闭此功能。如果日志数据量很大时，文件也有可能会因为达到SystemMaxFileSize值而被强制轮换，导致单个文件中记载的时间不足该指定值</p></li><li><p><span class="strong">MaxRetentionSec=</span><br>指定日志的最长保留时间。如果日志文件的最后修改时间早于这个时间阈值，它们将被删除。默认值为0，可以使用year、month、week、day、h或m作为时间单位，默认单位为s，设置为0可以关闭此功能。</p></li><li><p><span class="strong">SyncIntervalSec=</span><br>控制 journald 将内存中缓存的日志条目写入磁盘以持久化保存的时间间隔，默认值为5min写入一次。CRIT、ALERT 或 EMERG级别的日志会被立即写入磁盘而不受此设置影响，此设置仅适用于ERR、WARNING、NOTICE、INFO、DEBUG 级别的日志消息</p></li><li><p><span class="strong">ForwardToSyslog=, ForwardToKMsg=, ForwardToConsole=, ForwardToWall=, ForwardToSocket=</span><br>指定是否需要将日志转发到传统日志服务(syslog，默认为no)、内核日志缓冲区(/dev/kmsg，默认为no)、控制台(默认为no，可以通过TTYPath指定转发到哪个控制台)、所有登录用户(类似于wall命令，默认为yes)、Socket服务(该服务为/run/systemd/journal/socket上所监听的服务，如果要指定该配置则需要指定该服务的地址，默认无转发)，以上设置，默认仅启用转发到wall(且只有出现emerg级别的日志时才转发，参考MaxLevelSocket配置)</p></li><li><p><span class="strong">TTYPath=</span><br>指定日志转发的TTY设备设备路径，仅在 ForwardToConsole=yes 时生效，默认为/dev/console</p></li><li><p><span class="strong">MaxLevelStore=, MaxLevelSyslog=, MaxLevelKMsg=, MaxLevelConsole=, MaxLevelWall=, MaxLevelSocket=</span><br>指定存储、转发到syslog、内核日志缓冲区、控制台、所有登录用户、Socket服务的日志其日志等级，可选值有：emerg、alert、crit、err、warning、notice、info、debug，以下为默认值：</p><blockquote><blockquote><ul><li>MaxLevelStore=debug</li><li>MaxLevelSyslog=debug</li><li>MaxLevelKMsg=notice</li><li>MaxLevelConsole=info</li><li>MaxLevelWall=emerg</li><li>MaxLevelSocket=debug</li></ul></blockquote></blockquote></li><li><p><span class="strong">ReadKMsg=</span><br>控制journald是否读取内核环形缓冲区(/dev/kmsg)中的日志消息，这些消息通常由内核及其模块生成，是系统启动、硬件事件和内核日志的重要来源，默认为yes</p></li><li><p><span class="strong">Audit=</span><br>控制 journald 是否从内核审计子系统(Audit Framework)读取审计日志，审计日志记录系统的安全相关事件(如用户登录、权限更改等)，通常由内核的审计功能生成，默认为yes</p></li><li><p><span class="strong">LineMax=</span><br>指定journald从stdout/stderr读取流数据，并将其转换为记录日志时允许的最大行长度，默认为48k，超出部分会被journald截断并添加…后缀，表示此行已被截断。可以使用K、M、G、T为单位，最小可设置的值为79(bytes)，小于该值的设置会被提升到79bytes</p></li></ul>]]></content>
    
    
    <summary type="html">systemd单元文件配置和日志配置方法，以及常用命令</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="Serve" scheme="https://shiwei11.github.io/blog/tags/Serve/"/>
    
  </entry>
  
  <entry>
    <title>C语言</title>
    <link href="https://shiwei11.github.io/blog/2023/10/13/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/"/>
    <id>https://shiwei11.github.io/blog/2023/10/13/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/</id>
    <published>2023-10-13T15:28:06.000Z</published>
    <updated>2024-07-28T06:38:35.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><div class="contentFolded">在计算机诞生初期，人们使用<span class="strong">机器语言</span>来编写程序，机器语言的指令由操作码和操作数组成，均使用二进制代码表示，而二进制则通过在纸带上打孔来表示0或1，程序员将编写的机器语言指令打在纸带上并通过纸带机输入计算机中，以此进行运算。机器语言虽然能被计算机直接执行，但对人类来说难以阅读和记忆，不便编写。<p>为了简化机器语言的编写，1950年代中期，<span class="strong">汇编语言</span>应运而生。它使用助记符（mnemonic）来表示机器指令，极大地提高了程序员的工作效率。即便如此，书写和调试一个程序也需要用很长时间，并且需要程序员详细了解编写代码需要的指令、寄存器和CPU知识。</p><p>为了解决这些问题，IBM公司的一个研究小组开始着手研究一门能高效运行且简单易用的编程语言。1956年，IBM公司的John Backus带领他的团队开发出了世界上第一个<span class="strong">高级语言</span><span class="tips">FORTRAN</span>(FORmula TRANslation，意为公式翻译)，在科学和工程计算领域取得了很大成功，但该语言是专门为IBM 704计算机设计的，只能在特定型号的机器上工作。</p><p>为了解决这一问题，GAMM(德国应用数学和力学学会)、IBM、Datatron等公司要求ACM评估一种能脱离机器型号限定的“通用编程语言”。1958年5月，在美国计算机科学家Alan Jay Perlis的领导下，ACM、GAMM等代表在苏黎世会议上成立了IAL算法语言委员会，制定了国际算法语言(International Algorithmic Language,IAL)的定义并发布了IAL58语言。随后，ACM推崇IAL作为编程语言的标准，该算法语言由各种不同的“关键字”和“表达式”按照一定的语法规则组成，脱离了指令系统成为更接近人类的语言系统，编写者不必懂得完整的计算机的内部结构和工作原理也可以很好编写程序。</p><p>1959年，IAL被重新命名为ALGOL(算法语言)。</p><p>1960年，ALGOL算法语言委员会发布了<span class="tips">ALGOL 60</span>，里程碑式地引入了<span class="strong">递归</span>、<span class="strong">布尔类型</span>、<span class="strong">块结构</span>等概念，ALGOL 60也成为了后来所有计算机语言语法的鼻祖，Alan Jay Perlis也因此成为了世界首届图灵奖的获得者，以表彰其在 Algol 58 和 Algol 60 的形成和改进过程中的核心和关键作用。但ALGOL 60最大的缺点就是缺乏标准的输入输出能力，ALGOL 60编写的程序无法兼容不同的计算机外部设备，因此ALGOL 60迎来了进一步的迭代。</p><p>1963年，剑桥大学基于ALGOL 60发布了<span class="tips">CPL</span>（Combined Programming Langurage）语言，该语言旨在用于工业控制、数据处理等更为广泛的领域，因此规模宏大而复杂，编译器的编写进度十分缓慢，该语言并未大规模流行。</p><p>1967年，英国剑桥大学的Matin Richards对CPL语言做了简化，推出了<span class="tips">BCPL</span>(the Basic Combined Programming Language)语言，该语言是最早使用库函数封装基本输入输出的语言之一，主要用于编写系统和编译器，但BCPL对字符串的支持很差，并且内存管理很糟糕。</p><p>1969年，美国贝尔实验室的Kenneth Lane Thompson对BCPL语言做了改进和优化，由此衍生出了<span class="tips">B语言</span>，并用于书写<span class="strong">UNIX</span>系统，该语言的名字取自BCPL中的第一个字母，但此时的B语言过于简单，功能有限。</p><p>1972年，贝尔实验室的Dennis MacAlistair Ritchie在B语言的基础上设计出了<span class="tips">C语言</span>(取BCPL的第二个字母作为该语言的名字)，C语言保留了BCPL和B语言的优点，简练而接近硬件，又克服了它们无数据类型等缺点。1973年初， C语言的主体完成，汤普森和里奇使用C语言重写了UNIX操作系统，极大地提升了UNIX操作系统的可移植性，而C语言随着UNIX的广泛使用得到了迅速推广，成为了应用最广泛的计算机语言之一。</p><p>1983年，美国国家标准化协会(ANSI)制定了C语言标准——<span class="strong">ANSI C</span>，1987年，ANSI又公布了新的标准<span class="strong">87 ANSI C</span>，该标准于1990年被国际标准化组织(Internation Standard Organization)接受成为C语言国际标准——ISO/IEC 9899,简称<span class="strong">C89/C90</span>标准，是C语言的主流标准，被广泛应用于各个领域。1999年，ISO对C语言进行了大量扩展和改进，加入了如long long等新的数据类型，发布了<span class="strong">C99</span>标准，该标准在部分领域使用广泛，但在工业等领域普及度较低。目前最新标准为2018年发布的C17标准，但尚未被广泛使用。</div></p><h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><p>C语言源文件以<span class="tips">.c</span>为文件名后缀，从高级语言转换为机器码程需要经过<span class="strong">预处理</span>、<span class="strong">编译</span>、<span class="strong">汇编</span>、<span class="strong">链接</span>四个过程</p><h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>C语言源文件首先会被预处理，以一个名为hello.c的源文件为例，<span class="tips">hello.c</span>源文件经过预处理器处理，会生成一个<span class="tips">hello.i</span>临时文件，预处理阶段会进行以下工作：</p><ul><li>删除代码中的所有注释</li><li>对宏进行代码扩展，通过<span class="strong">#define</span>等指令定义的常量或表达式，会被替换到文件中，对<span class="strong">#if</span>等条件编译指令限定的代码进行选择性编译</li><li>包含文件，通过<span class="strong">#include</span>指令包含的文件，其内容会被添加到源文件中</li></ul><h6 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h6><p>编译器会将临时文件<span class="tips">hello.i</span>编译为汇编文件<span class="tips">hello.s</span>，该阶段编译器会对代码进行语法检查，并返回源代码中存在的语法错误和警告</p><h6 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h6><p>汇编程序将<span class="tips">hello.s</span>汇编文件编译成机器码，在<span class="strong">Windows</span>环境下生成<span class="tips">hello.obj</span>对象文件，在<span class="strong">Linux</span>环境下生成<span class="tips">hello.o</span>目标文件</p><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>链接器会将多个目标文件合并为一个文件，并与库函数文件(.lib)等依赖链接，生成可执行文件，在Windows环境下生成一个可执行文件 hello.exe，在 Linux环境下中生成 hello.out文件</p><p>库函数文件由各软件公司编写并已经编译成目标文件(.obj文件)，它们将在链接阶段与源程序编译而成的目标文件(.obj文件)相链接，生成可执行文件。</p><h4 id="C语言内存模型"><a href="#C语言内存模型" class="headerlink" title="C语言内存模型"></a>C语言内存模型</h4><p>准确来讲，这是Linux的虚拟空间布局的一部分，Linux系统内核进程和用户进程所占的虚拟内存比是1：3，Windows是2：2，以32位Linux系统为例，模拟一个4GB的内存地址块沙盘，其中高地址位的1GB内存为系统内核进程占用的内核空间，低地址位的3GB内存为用于用户内进程的用户空间，内核空间由操作系统负责维护和处理，因此本文只涉及日常开发中C程序可以操控的3GB用户空间部分。</p><p>该虚拟沙盘地址通过页表(Page Table)映射到物理内存，其中，蓝色区域会被映射到物理内存的不同内存段，白色区域只用于虚拟内存地址的分析，不会映射到物理内存中，不占用内存空间</p><img src="#" alt="C语言内存" data-src="/blog/images/20240316041218.png" style="max-width:420px;max-height:470px;"><h5 id="保留区-Reserved"><a href="#保留区-Reserved" class="headerlink" title="保留区(Reserved)"></a>保留区(Reserved)</h5><p>保留区是系统预留且禁止用户进程访问的地址区域，位于虚拟地址空间的最低部分，不赋予物理地址，一般用于捕捉空指针异常等情况。在大多数操作系统中，极小的地址空间通常都是不允许访问的，如NULL、0等。因此C语言也将无效指针赋值为0，因为0地址在正常情况下是不会存放有效的可访问数据的。</p><p>在32位X86架构的Linux系统中，系统将预留128MB的保留区，因此用户进程可执行程序一般从虚拟地址空间0x08048000开始加载内存区域。</p><h5 id="代码区-Code-Text"><a href="#代码区-Code-Text" class="headerlink" title="代码区(Code/Text)"></a>代码区(Code/Text)</h5><p>用于存放二进制代码，该区域是只读的，以防止恶意程序修改代码区的数据。代码段指令中包括操作码和操作数(操作对象)，如果操作对象是立即数(具体数值)，则该数据将直接包含在代码中；如果是字符串常量、变量中的数据，则将引用该数据地址。</p><h5 id="静态区-Static"><a href="#静态区-Static" class="headerlink" title="静态区(Static)"></a>静态区(Static)</h5><p>静态区又称全局区，这部分的空间大小在编译时就已经确定，因此是静态的，静态区分为<span class="strong">只读数据段</span>(RO Data，又称为常量区)、<span class="strong">已初始化数据段</span>(又称为读写数据段，RW Data)和<span class="strong">未初始化数据段</span>(又称为BSS段，Block Started by Symbol)三部分</p><ul><li><span class="strong">只读数据段(.rodata)：</span>只读，用于存储字符串常量，以及const修饰的只读全局变量(只读局部变量存储于栈区)、只读字符串变量，只读静态变量</li><li><span class="strong">已初始化数据段(.data)：</span>可读可写，存储已初始化且初值不为0的全局变量和静态局部变量</li><li><span class="strong">未初始化数据段(.bss)：</span>可读可写，存储未初始化或初始化为零的全局变量和静态变量。这些变量在编译阶段会被收集起来放到.bss段中，并在程序初始化时自动赋值为0(对数值型变量)或空字符(对字符变量)。由于.bss段的值全为0，因此这个段只记录段长，在编译-链接生成的可执行文件中不占用物理文件空间(全是0，没必要存储)，能在一定程度上节省磁盘空间。在程序执行(初始化)时，加载器(loader)根据其段长分配相应大小的内存，并将这些内存空间全部初始化为0。因此.bss段不占用物理文件尺寸，但占用内存空间；.data段占用物理文件，也占用内存空间</li></ul><h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h5><p>由程序员分配释放，如果程序员不释放，则操作系统在程序结束时回收，通过<span class="tips">malloc</span>、<span class="tips">realloc</span>、<span class="tips">calloc</span>语句开辟空间，通过<span class="tips">free</span>释放。</p><p>堆内存的增长方向为由低地址向高地址增长，其工作方式类似于数据结构中的<span class="tips">链表</span>。在操作系统中有一个记录空闲内存地址的链表，当使用malloc()等语句开辟内存空间时，操作系统会遍历该链表，寻找第一个空间大于等于所申请空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序，此外，系统会在该空间的首地址处记录所分配的空间大小，以便free语句能正确释放空间。</p><p>由于每次分配的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中，频繁的开辟、释放空间势必会造成内存空间的不连续，从而造成大量碎片。</p><p>堆空间的大小受限于系统的有效虚拟内存，32位Linux系统中堆内存可达2.9G空间。堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。</p><h5 id="内存映射段-mmap"><a href="#内存映射段-mmap" class="headerlink" title="内存映射段(mmap)"></a>内存映射段(mmap)</h5><p>该区域用于映射可执行文件用到的动态链接库到内存中，方便更快速地读取。<br>此外，在Linux中，如果通过malloc()请求一个大的内存空间，C运行库将在该区域创建一个匿名内存映射，而不使用堆内存。</p><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>内存映射是一种强大的文件I/O技术，用于高效读写文件。它将文件映射到虚拟内存空间中，并且支持按需加载文件，然后通过内存地址来访问文件，从而避免了大量的文件读写操作，比传统的文件读写操作更加快捷方便。</div><h5 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h5><p>栈内存由<span class="tips">编译器</span>负责分配和释放，主要用于存放：</p><ul><li>函数内部定义的局部自动变量(auto类型)，包括const修饰的只读局部变量</li><li>函数参数和返回值</li><li>调用函数时的上下文环境，如函数返回地址等</li><li>暂存一些算术表达式的计算结果</li><li>alloca()函数分配的栈内内存</li></ul><p>栈内存的增长方向为由高地址向低地址增长，其工作方式与数据结构中的栈相似，即先入后出，且栈分配的内存空间是连续的，不会有碎片化现象。栈是由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多</p><p>栈空间的大小由系统预定义(通常默认2M或10M)，当栈剩余空间大于所申请空间时，系统将分配内存，否则将抛出栈溢出(stack overflow)错误</p><h5 id="各段生成时间"><a href="#各段生成时间" class="headerlink" title="各段生成时间"></a>各段生成时间</h5><p>在C语言程序编译-链接后生成的映像文件中，将只包含代码段、只读数据段(.rodata)和读写数据段(.data)，双击运行该文件后，程序在初始化时将动态生成未初始化数据段(.bss)，程序的运行过程，将动态生成堆(Heap)和栈(Stack)</p><div class="show">char str[]="hello"; //数组末尾会添加'\0'代表存储结束char * str="hello";如果它们都是局部变量，则字符数组会在栈区申请空间，并将字符存储在数组空间中；而指针变量，字符串存储在全局区的只读数据段，栈中的指针变量存储的是其字符串在全局区中的地址如果它们声明为全局变量，则字符数组声明在全局const 声明的全局变量存储于静态区const 声明的局部变量存储于栈const 声明的字符串常量存储于静态区只读区 const char* str="hello"</div><h3 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h3><p>预处理命令是C语言源程序中用于改进程序设计环境、提高编程效率的特殊命令，不属于C语言的组成部分，无法进行编译，只会对其在预处理阶段作出相应处理。预处理命令以<span class="tips strong">#</span>开头，且不以分号结尾，以便与一般的C语言语句区分</p><h4 id="include文件包含"><a href="#include文件包含" class="headerlink" title="#include文件包含"></a>#include文件包含</h4><p><span class="strong">文件包含</span>处理指将一个源文件中的内容包含到另一个源文件中，被包含的文件称为<span class="strong">头文件</span>(或标题文件)，文件名常以<span class="tips">.h</span>作为后缀，也可以以<span class="tips">.c</span>作为后缀甚至没有后缀。在编译的预处理阶段，头文件中的内容会被复制到主文件中，替换掉 #include &lt;xxx.h&gt;语句，得到一个新的源文件，再对该文件进行编译。</p><ul><li><span class="strong">#include &lt;文件名&gt;</span>一般用于包含系统库函数头文件</li><li><span class="strong">#include “文件名”</span>一般用于包含用户自己编写的头文件</li></ul><div class="show">eg:C语言中常用的标准输入输出函数头文件#include &lt;stdio.h&gt;// std：standard(标准)，i为input，o为output，将包含标准输入/输出函数的头文件stdio.h包含到源文件中</div><p>注意事项：</p><ul><li>一个#include语句只能包含一个文件，如果要包含多个文件，则只能使用多个语句</li><li>使用<span class="tips">&lt;文件名&gt;</span>包含文件时，系统会到存放C语言库函数头文件的路径下寻找该文件，，使用<span class="tips">“文件名”</span>包含文件时，系统会首先在用户当前目录中寻找文件，如果没有，再去C语言库函数路径下</li><li>如果A文件包含了B文件，而B文件需要使用C文件中的内容，则可以在A文件中使用两个#include命令同时包含文件B和C，且包含C文件的指令需要出现在包含B文件的指令前。也可以嵌套包含，即B文件包含C文件，A文件包含B文件</li><li>A文件包含B文件后，B文件中的内容会在预处理阶段被复制到A文件中，因此B文件中的全局静态变量在A文件中有效，不需要extern声明语句</li><li>#include通常用于包含.h头文件，也可以包含其他文本文件，如：源代码文件(.c)、c++的头文件(.hpp或.hxx)、库文件(.lib、.dll、.a等)，甚至可以为.txt文本文件</li></ul><h4 id="define-宏定义"><a href="#define-宏定义" class="headerlink" title="#define 宏定义"></a>#define 宏定义</h4><p>用一个指定的标识符代表一个字符串，在编译预处理阶段，预处理器会对源代码中的宏名进行<span class="strong">宏展开</span>，即将宏名替换成对应的字符串</p><ul><li><span class="strong">#define 标识符 字符串</span> 定义无参宏定义</li><li><span class="strong">#undef 标识符</span> 终止宏定义</li><li><span class="strong">#define 标识符(参数表列) 字符串</span> 定义带参数的宏定义</li></ul><p>注意事项： </p><ol><li>宏名一般使用<span class="strong">大写字母</span>表示，以便与普通变量名区分</li><li>宏定义只用作字符串替换，与定义普通变量不同，不分配内存空间</li><li>宏定义可以嵌套定义</li><li>宏定义用于定义符号常量，定义完毕后不能再赋值，也不能被修改</li><li>宏定义语句写于函数外，作用范围为宏定义语句之后到本源文件结束，或者到<span class="tips">#undef 宏名</span>行终止</li><li>预处理阶段只对宏名进行字符串替换，不作语法准确性检查。如果宏定义中有错误，只有在宏名被宏展开后的编译阶段，编译器对源程序进行语法检查时才会发现宏定义中存在的错误</li></ol><div class="show"> //无参数宏定义#include &lt;stdio.h>#define PI 3.1415926#define R 4.0#define L 2*PI*R //嵌套定义宏int main(){    float l=L;    printf("%f",l);    return 0;}#undef R  //终止R的作用范围void f1(){....}</div><div class="show"> //带参宏定义#include &lt;stdio.h>#define L(r,s) r+s //带多个参数的宏定义#define M(r) 3*r*r #define N(r) 3*(r)*(r)int main(void){ int a=1,b=2,result; result=L(a,b); //展开为result=a+b; result=M(a+b); //展开为result=3*a+b*a+b<span class="tips">注意宏定义时参数不带()可能会被展开为错误形式</span> result=N(a+b); //展开为result=3*(a+b)*(a+b); return 0;}</div><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p><span class="strong">条件编译</span>指预处理器根据条件编译指令，选择性将源代码中的部分代码送到编译器进行编译</p><h6 id="ifdef宏定义判断"><a href="#ifdef宏定义判断" class="headerlink" title="#ifdef宏定义判断"></a>#ifdef宏定义判断</h6><p><span class="strong">#ifdef 标识符<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span><br>如果指定的标识符已经被#define定义过，则编译程序1，否则编译程序2，程序1和程序2既可以是C语句，也可以是预处理命令，类似于if…else…语句，#else可以不使用</p><div class="show">#include &lt;stdio.h>#define TEST //TEST定义甚至可以为空，也视为被定义过#ifdef TEST    #define SIZE 32 //TEST被定义过，所以执行该语句#else    #define SIZE 64#endif....</div><h6 id="ifndef无宏定义判断"><a href="#ifndef无宏定义判断" class="headerlink" title="#ifndef无宏定义判断"></a>#ifndef无宏定义判断</h6><p>逻辑与#ifdef相反，如果指定的标识符未被#define定义，则编译程序1，否则编译程序2<br><span class="strong">#ifndef 标识符<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span></p><h6 id="if表达式判断"><a href="#if表达式判断" class="headerlink" title="#if表达式判断"></a>#if表达式判断</h6><p>如果表达式值为真，编译程序1，否则编译程序2<br><span class="strong">#if 表达式<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span></p><div class="show">#include &lt;stdio.h>#define LINUX 1 //可以快速设置编译的目标平台，缩减源代码长度int main(void){    #if LINUX        printf("linux专用代码");    #else        printf("非linux用代码");    #endif    .....    return 0;}</div><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>C语言中变量的声明方式如下：<br><span class="strong"><span class="text-green">存储类型</span><span class="text-blue">数据类型 </span> 变量名;</span></p><ul><li>存储类型代表编译器为变量分配内存的方式，如：自动变量内存分配于动态存储器，静态变量和外部变量内存分配于静态存储区，寄存器变量存储位置分配于CPU中的寄存器</li><li>存储类型和作用域(变量定义的位置)决定了变量的生存期</li><li>数据类型指该变量存储的数据类型</li><li>变量名需要满足标识符命名规则</li></ul><h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p><span class="strong">标识符</span>即C语言中的变量名、符号常量名、函数名、数组名等用来给数据对象命名的字符序列，标识符需要满足以下规则：</p><ul><li>只能由英文字母、数字、下划线组成</li><li>不能以数字开头</li><li>不能使用关键字</li><li>严格区分大小写</li></ul><h4 id="变量的作用域和生存期"><a href="#变量的作用域和生存期" class="headerlink" title="变量的作用域和生存期"></a>变量的作用域和生存期</h4><p>变量从其作用域区分，分为局部变量和全局变量：</p><p><span class="strong">局部变量</span>：定义在函数内部或{ }包裹的代码块内部，只在本函数或代码块内生效，分为静态局部变量和动态局部变量。默认情况下，局部变量的存储类型为auto(动态局部变量)，变量内存位于动态存储区，代码块内的语句执行完毕变量就会被销毁，释放其内存。可以将局部变量的存储类型定义为static(静态局部变量)，此时变量内存位于静态存储区，整个程序运行期间其内存不会被释放</p><p><span class="strong">全局变量</span>：定义在函数的外部，默认存储类型为extern，有效作用域为变量定义位置开始到本源文件结束，其作用域可以通过extern声明进行拓展。全局变量在程序的整个执行过程都占用内存单元。<span class="tips">习惯上，全局变量的首字母用大写表示</span>，当全局变量名和局部变量名相同时，局部变量有效</p><p>变量的生存期是指变量从生成(分配内存)到被销毁(释放内存)的时间段。对于存储在静态存储区中的变量，其内存在编译时就已经确定，是静态的，内存空间在整个程序运行期间不会被释放，变量与程序共存亡。而对于存储在动态存储区中的变量，其内存由操作系统根据程序运行动态分配。变量的存储类型直接决定了变量的生存期。</p><div class="show">#include&lt;stdio.h>int Number=0;   //全局变量首字母大写int main(void){    void test();    int num=10;    int Number=10; //局部变量生效，全局变量被"屏蔽"    test();    return 0;}void test(){    Number=100; //全局变量可以被任意函数访问和修改，会降低程序清晰性}</div><h4 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h4><p>C语言提供的存储类型主要有以下几种：</p><ul><li>自动变量 auto</li><li>静态变量 static</li><li>外部变量 extern</li><li>寄存器变量 register</li></ul><h5 id="auto自动变量"><a href="#auto自动变量" class="headerlink" title="auto自动变量"></a>auto自动变量</h5><p>又称动态局部变量或局部作用域变量，定义于函数内部，是C语言中极为常用的变量类型，因此C语言把它设计为缺省类型(默认类型)，即auto可以省略不写，反之，如果没有指定局部变量的存储类型，则默认为auto，因此以下两个语句等价</p><div class="show"><code>&#123;int num=10;auto int num=10;&#125;</code></div><p>自动变量数据存储在<span class="text-blue">动态存储区</span>中，操作系统会在代码执行到变量定义语句时为其分配内存，退出所属语句块时释放内存。函数形参和函数内定义的变量(未明确声明为static)都属于该类变量。自动变量有以下特点：</p><ul><li>自动变量在定义时不会自动初始化。所以除非程序员显式指定初值，否则自动变量的值是随机的垃圾值</li><li>自动变量在退出函数(语句块)后，其分配的内存立即被释放，再次进入该语句块，该变量被重新分配内存，所以不会保存上一次退出时的值</li></ul><h5 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h5><p>静态变量分为静态局部变量和静态外部变量，二者用于不同的场景。静态变量在<span class="text-blue">静态存储区</span>分配内存，在整个程序运行期间不会被释放，与程序共存亡。对于已经初始化的静态变量，其内存空间位于静态存储区的.data段，在编译时赋予内存。对于未初始化的静态变量，其内存空间位于静态存储区的.bss段，并在程序初始化时，给变量赋值0(对数值型变量)或空字符(对字符变量)。</p><h6 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h6><p>自动变量的内存会在代码退出函数块后被释放，其值也不会被保留，下次进入该函数块，该变量会被分配新的内存，如果希望变量的值在退出函数语句块后依旧被保留，其占用的存储单元不释放，方便函数基于上一次的运算结果进一步进行计算，此时可以使用static关键字将局部变量定义为静态局部变量。</p><div class="show">eg:计算n的阶乘<code>int main(void)&#123;    int i,n;    scanf("%d",&n);    for(i=1;i&lt;=n;i++)&#123;        Func(i);    &#125;    return 0;&#125;long Func(int n)&#123;    static long p=1;    return p*n;&#125;</code></div><p>静态局部变量，有以下特点：</p><ul><li>如果定义静态局部变量时不赋初值，编译器会自动赋为0(对数值型变量)或空字符(对字符变量)</li><li>自动变量(动态局部变量)占据的内存在函数调用结束后会被释放，每次调用都需要重新初始化。而静态局部变量仅在第一次调用函数时被初始化一次，其占据的内存在退出函数后不会被释放，再次调用该函数其值上次退出函数时的值</li><li>虽然静态局部变量在函数调用结束时仍然存在，但其他函数是无法引用它的</li></ul><h6 id="静态外部变量"><a href="#静态外部变量" class="headerlink" title="静态外部变量"></a>静态外部变量</h6><p>外部变量默认存储类型为extern，可以被其他文件使用extern声明后引用，如果希望外部变量只限于被本文件使用，而不能被其他文件引用，则可以在声明外部变量时添加static声明，将其声明为静态外部变量，该类变量可以应用于以下场景：</p><ul><li>多人开发时，可以在不同文件中声明同名外部变量而互不干扰</li><li>权限控制，避免其他文件引用或修改外部变量的值</li></ul><div class="show"><code>static int Number;</code></div><h5 id="extern外部变量"><a href="#extern外部变量" class="headerlink" title="extern外部变量"></a>extern外部变量</h5><p>如果定义在函数之外的变量没有指定其他存储类别，那么它就是一个外部变量，外部变量是全局变量，作用域是从它的定义点到本文件末尾。但如果要在定义点之前或在其他文件中使用它，那就需要使用关键字extern对其进行声明(注意不是定义，编译器不为其分配内存)<br>声明语句为:<br><span class="strong">extern 类型名 变量名;</span><br>其中类型名可以省略，因此以下语句等价</p><div class="show"><code>extern int Num1;extern Num1;</code>注意！在定义外部变量时，直接在函数外定义 int Num1;  即可int Num1;  是“定义性声明”语句，会给变量分配内存空间，extern int Num1;  为“引用性声明”语句，用于拓展外部变量作用域，不会分配内存，不能用来定义一个未初始化的外部变量但如果在定义时进行初始化，根据右结合原则，会当作定义了变量，并进行了extern作用域拓展处理extern int Num1=200;//既是定义语句，也是extern声明语句</div><h6 id="在一个文件内声明外部变量"><a href="#在一个文件内声明外部变量" class="headerlink" title="在一个文件内声明外部变量"></a>在一个文件内声明外部变量</h6><p>如果外部变量不在文件开头定义，那么它的作用域就是从它的定义点到本文件末尾。如果在定义点之前想要引用该变量，则需要在引用之前对使用extern对其进行外部变量声明，声明后就可以从声明之处起，合法使用该外部变量</p><div class="show"><code>int main(void)&#123;    int getMax(int ,int);    <span class="text-blue">extern Num1,Num2;</span>//外部变量声明(仅作声明，不分配内存)    printf("max is:%d", getMax(Num1,Num2);)//在定义前引用变量&#125;int Num1=10,Num2=20;//定义外部变量int getMax(int x,int y)&#123;    return x>y?x:y;&#125;</code></div><h6 id="在多文件中声明外部变量"><a href="#在多文件中声明外部变量" class="headerlink" title="在多文件中声明外部变量"></a>在多文件中声明外部变量</h6><p>C语言程序也可以由多个源文件组成，如果多个文件都需要用到同一个外部变量，不能在多个文件中都同时定义该变量，否则程序在链接阶段会出现“重复定义”错误。正确做法是：在某一个文件中定义外部变量，其他文件中用extern对该变量作“外部变量声明”，将变量的作用域拓展到这些文件中，然后在这些文件中合法引用外部变量。</p><div class="show">eg:文件file1.c中输入变量Num的值，文件file2.c对Num扩大10倍后返回结果file1.c文件:<code>#include&lt;stdio.h&gt;<span class="text-blue">int Num;</span>//定义外部变量int main(void)&#123;    int getValue(int);    printf("Input the value of Num:");    scanf("%d",&Num);    printf("%d",getValue(10));    return 0;&#125;</code>file2.c文件:<code><span class="text-red">extern Num;</span>//声明A为其他文件已经定义的外部变量int getValue(int n)&#123;    return Num*n;&#125;</code></div><h5 id="register寄存器变量"><a href="#register寄存器变量" class="headerlink" title="register寄存器变量"></a>register寄存器变量</h5><p>对于使用频率较高的变量，可以将其声明为寄存器变量，减少CPU对内存的频繁数据访问，使得程序更小，执行速度更快</p><div class="show"><code>int main(void)&#123;    int n;    long countNum(int);    scanf("%d",&n);    countNum(n);    return 0;&#125;long countNum(int n)&#123;    register long i,f=1;    for(i=1;i&lt;n;i++)&#123;          f=f*i;    &#125;    return f;&#125;</code></div><p>寄存器变量有以下特点：</p><ul><li>只有局部自动变量和形参可以作为寄存器变量</li><li>CPU中的寄存器数量有限，不能定义太多的寄存器变量</li><li>有的系统把寄存器变量当作自动变量处理，在内存中分配存储空间，并非放到寄存器中</li></ul><p>现代编译器能自动优化程序，自动把普通变量优化为寄存器变量，并且可以忽略用户定义的寄存器变量，因此一般无需特别声明变量为register，仅作了解。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="数据类型总览"><a href="#数据类型总览" class="headerlink" title="数据类型总览"></a>数据类型总览</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><div class="table"><table>        <thead>            <tr>                <th colspan="2">分类</th>                <th>关键字</th>                <th>长度(Bytes)</th>                <th>示例</th>            </tr>        </thead>        <tbody>            <tr>                <td rowspan="5">整型</td>                <td>短整型</td>                <td>short</td>                <td>2</td>                <td>short a;或                    short int a;                </td>            </tr>            <tr>                <td>整型</td>                <td>int</td>                <td>4</td>                <td>int a;</td>            </tr>            <tr>                <td>长整型</td>                <td>long</td>                <td>4</td>                <td>long a;或                    long int a;                </td>            </tr>            <tr>                <td>长长整型</td>                <td>long long</td>                <td>8</td>                <td>long long a;或                    long long int a;                </td>            </tr>            <tr>                <td>无符号整型</td>                <td>unsigned</td>                <td>8</td>                <td><div>unsigned int a;</div>                     unsigned long  a;                </td>            </tr>            <tr>                <td rowspan="3">浮点型(实型)</td>                <td>单精度</td>                <td>float</td>                <td>4</td>                <td>float a;</td>            </tr>            <tr>                <td>双精度</td>                <td>double</td>                <td>8</td>                <td>double a;</td>            </tr>            <tr>                <td>长双精度</td>                <td>long double</td>                <td>12或8</td>                <td>long double a;</td>            </tr>            <tr>                <td colspan="2">字符型</td>                <td>char</td>                <td>1</td>                <td>char a;</td>            </tr>            <tr>                <td colspan="2">枚举型</td>                <td>enum</td>                <td>-</td>                <td>enum res{yes,no,none};</td>            </tr>        </tbody>    </table></div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>long long,unsigned long long,long double是C99标准新增的，部分编译器默认使用C89标准，需要手动指定使用C99标准编译才支持以上数据类型。此外，ANSI C标准对于数据类型所占内存的字节数并无明确定义，因此不同编译器中各数据类型的字节数可能不同</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>C语言中没有string类型，处理字符串一般使用字符数组或指针，也没有bool类型，不能使用true和false逻辑常量</div><h5 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h5><div class="table"><table><thead><tr><th>构造类型</th><th>关键字</th><th>示例</th></tr></thead><tbody><tr><td>数组</td><td>-</td><td>int num[10];</td></tr><tr><td>结构体</td><td>struct</td><td></td></tr><tr><td>共用体</td><td>union</td><td>union{int num;char name[5];}man</td></tr></tbody></table></div><h5 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h5><div class="table"><table><thead><tr><th>数据类型</th><th>关键字</th><th>示例</th></tr></thead><tbody><tr><td>指针</td><td>-</td><td>int * p;</td></tr><tr><td>无类型</td><td>void</td><td>void f1(){…}</td></tr></tbody></table></div><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型从符号位的归属可分为<span class="strong">有符号整型(signed)</span>和<span class="strong">无符号整型(unsigned)</span>。有符号整型最高位为符号位，0表示该值为正数，1表示该值为负数，而无符号整型的最高位不表示正负，依旧用于储存数值，因此无符号整型只能表示0和正整数，但无符号整型可存储的数值范围要比同位数的有符号整型大2倍，如：signed int数值范围为-32768-32767，而unsigned int 数值范围为0-65535。如果一个整型不声明为unsigned或signed，则默认隐含为signed，因而signed可以省略不写。</p><p>对于短整型和长整型，int也可以省略不写(以下[]内的均可省略不写)</p><div class="table"><table><thead><tr><th>类型</th><th>比特位数</th><th>取值范围</th></tr></thead><tbody><tr><td>[signed] short [int]</td><td>16</td><td>-2<sup>15</sup>~(2<sup>15</sup>-1)</td></tr><tr><td>unsigned short [int]</td><td>16</td><td>0~(2<sup>16</sup>-1)</td></tr><tr><td>[signed] long [int]</td><td>32</td><td>-2<sup>31</sup>~(2<sup>31</sup>-1)</td></tr><tr><td>unsigned long [int]</td><td>32</td><td>0~(2<sup>32</sup>-1)</td></tr></tbody></table></div><p>对于整型常量，通常在其数值后加上相应符号表示其具体类型，如：加上<span class="tips">U或u</span>表示无符号整型，加上<span class="tips">L或者l</span>表示长整型</p><div class="show">233u或233U为无符号整型-1024l或-1024L为长整型203lu为无符号长整型</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>如果使用u标识一个负整数,如-12345u，则将取-12345补码对应的无符号整数53191按无符号数存储</div><div class="show">-12345原码：1011 0000 0011 1001反码：1100 1111 1100 0110补码：1100 1111 1100 0111 --->对应无符号数值为53191</div><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点数有两种表示方式：</p><ul><li>十进制小数形式，如：0.5,1.3,.95(省略0)</li><li>指数形式，以e或E为底数(其中e代表10)，e的左边为数值部分，e的右边为指数部分(必须为整数)，如：12.3可以表示为1.23e1、0.123e2、123e-1等形式，如果e左边的数值部分，小数点左边有且只有一位非零的数字，则该表示方法称为<span class="tips">“规范化的指数形式”</span>，如：1.23e1为规范化的指数形式，而0.123e2、123e-1不是</li></ul><p>C语言默认将浮点型常量作为<span class="tips">双精度(double)</span>类型进行处理，如果在常量后加上<span class="tips">f或F</span>将作为float型处理，加上<span class="tips">l或L</span>则作为long double型处理，eg:1.25e-2f，1.25L</p><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符常量使用<span class="tips">单引号’’</span>包裹，一个字符占用一个字节(中文字符需要两个字节)。字符在内存中以ASCII码形式存储，因此字符型数据和整型数据是通用且可以用于计算的(仅限于0-255之间的整数)，常见的应用为<span class="tips">大写字符+32转换为小写字符</span></p><div class="show">char a=97;int  asciiA=a-32;printf("%c\n",asciiA)//输出Aprintf("%d",asciiA)//输出65</div><p>此外，C语言中还有一些特殊的转义字符，作用如下</p><div class="table"><table><thead><tr><th>字符</th><th>含义</th><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行</td><td>\a</td><td>响铃报警提示音</td></tr><tr><td>\r</td><td>回车(不换行)，将光标位置移到当前行开头</td><td>\“</td><td>双引号</td></tr><tr><td>\0</td><td>空操作字符，常用作字符串结束标志</td><td>\‘</td><td>单引号</td></tr><tr><td>\t</td><td>水平制表，跳到下一个Tab位置</td><td>\\</td><td>反斜线</td></tr><tr><td>\v</td><td>垂直制表</td><td>\?</td><td>问号</td></tr><tr><td>\b</td><td>光标位置退一格</td><td>\ddd</td><td>1到3位八进制ASCII码代表的字符</td></tr><tr><td>\f</td><td>换页</td><td>\xhh</td><td>1到2位十六进制ASCII码代表的字符</td></tr></tbody></table></div><div class="show">1. \ddd和\xhh是用一个八进制或者十六进制的ASCII码表示一个字符，如："\101"和"\x41"转换为十进制为65，表示ASCII码值为65的字符A2.注意\r和\b的使用，会覆盖掉\r、\b之前的字符printf("abcdefg\r1234");//输出1234 fg，光标回到本行开头，1234\0替换掉abcde(字符串末尾会添加\0，因此\0替换e并输出空白字符)printf("abcdefg\b\b\b\b123");//输出abc 123printf("abcdefg\b\b\b\b\b\b\b123");//输出123 efgprintf("abcdefg\b\b\b\b\b\b\b123\n");//输出123defg</div><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串常量使用<span class="tips">双引号””</span>包裹，字符串末尾会被加上<span class="tips">‘\0’</span>作为字符串结束的标志。C语言中没有专门的关键字用来声明字符串变量，因此需要使用字符数组或者指针来存储和处理字符串</p><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>字符串可以存储于字符数组中，但字符数组中存储的并不一定是字符串，这取决于字符数组最后一个元素是否是字符串结束标志’\0’，’\0’也占用一个字节内存，但它不计入字符串的实际长度，只计入数组长度。注意，如果字符数组最后没有’\0’，系统将无法将该数组当作字符串来处理(如：无法正确被printf(“%s”,xx)输出)</p><div class="show">对于字符数组，可以像其他数组一样用同样的方式初始化，如：<code>char str[6]=&#123;'H','e','l','l','o','\0'&#125;;</code>如果省略对数组长度的声明，则必须人为在初始化列表中添加'\0'，否则系统将无法将str当作字符串来处理<code>char str[]=&#123;'H','e','l','l','o'&#125;;//长度为5的普通字符数组char str[]=&#123;'H','e','l','l','o','\0'&#125;;//长度为6的字符串</code>用printf("%s",str)语句输出上述变量时，第一个变量由于缺少'\0'，输出语句会在输出完Hello后继续输出乱码，直到遇见'\0'，而第二个变量会被正常输出<p>也可以用字符串常量初始化字符数组，这样可以不指定数组大小，且由于字符串常量”Hello”末尾自带’\0’，可以不必人为添加’\0’<br><code>char str[6]=&#123;"Hello"&#125;;<br>char str[]=&#123;"Hello"&#125;;//数组长度可省略<br>char str[]="Hello";//大括号可省略</code><br><span class="text-red">但只允许在定义时整体赋值，不允许在赋值语句中整体赋值</span><br><code>char str[6];<br>str[]=&#123;"Hello"&#125;;//不允许先定义，定义完在赋值语句中整体赋值,Visual Studio报错：不允许使用不完整的类型</code><br>无论用哪种方式初始化字符数组，如果指定数组长度，都要保证预留足够空间以便存储字符串结束标志，即：字符数组大小一定要比字符串的实际字符数大1<br>可以使用数组下标访问字符串的单个字符，如：<br>str[1]代表字符’e’</div></p><div class="show">一个字符串可以用一维字符数组存储，多个字符串可以用二维字符数组存储。数组的第一维长度代表要存储的字符串个数，可以省略；第二维长度不能省略，应当设定为最长那个字符串长度+1，eg:<code>char weekday[][10]=&#123;"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"&#125;;</code>其中最长的字符串"Wendesday"长度为9，因此第二维长度应当为10，对于长度小于10的字符串，其剩余的内存单元会被'\0'填充如果字符串太长，可以拆分为几个小片段写在不同行，其中空格也将占用数组长度和空间<code>char longString[]="One day you will leave this world behind""so live a life you will remember"</code></div><h4 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h4><p>字符指针是指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一确定的地址，因此只要将字符串首地址赋值给指针变量，就可以让字符指针指向一个字符串。对于字符串常量，C语言按字符数组处理，在内存中开辟一个字符数组存储该字符串，字符串常量本身就代表存放它的常量存储区的首地址。</p><div class="show">1. 以下两个初始化语句等价，均表示将字符串常量在常量存储区中"Hello"的首地址赋值给ptr<code>char * ptr="Hello";</code>等价于<code>char * ptr;ptr="Hello";</code>2. 由于字符串常量存储于只读的常量存储区中，因此只可以修改指针变量的指向，不能修改ptr所指向存储单元的内容*ptr='a';//错误！写入权限异常，不能修改所指向存储空间的内容ptr="another";//允许修改指针的指向3. 通过指针也可以访问单个字符，如：*(ptr+1)代表字符'e'也可以修改指针指向位置，使其从所指位置开始输出，直至遇到'\0'，以此输出字符串的部分内容，如：<code>char * sentence="Meet you like the wind";sentence=sentence+14;printf("%s",sentence);//输出the wind</code></div><h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><p>字符串的输出支持以下三种方法：</p><div class="show">1. 依次输出单个字符<code>for(int i=0;i&lt;6;i++)&#123;    printf("%c",str[i]);&#125;</code>由于字符串长度并不等于字符数组大小，且上述方法无法灵活输出不同长度字符串，因此一般会借助字符串结束标志'\0'来结束字符串输出，如：<code>for(int i=0;str[i]!='\0';i++)&#123;    printf("%c",str[i]);&#125;</code>2. 用格式符s，将字符串作为一个整体输出，同样输出到字符串结束标志为止<code><span class="text-red">printf("%s",str)</span></code>3. 使用<span class="text-blue">puts()</span>函数(&lt;stdio.h>库函数)，puts()函数用于从括号内的参数给出的地址开始，依次输出存储单元中的字符，直到遇到第一个'\0'时输出结束，并自动输出一个换行符，缺点是该函数无法如printf()函数一样添加其他字符信息并控制输出格式<code><span class="text-red">puts(str)</span></code></div><p>字符串指针变量可以指向一个格式字符串，可以替代printf()函数中的格式，作为一种可变格式的字符串输出</p><div class="show"><code>char * format;format="a=%d,b=%f\n";printf(format,a,b);也可以用字符数组实现char format[]="a=%d,b=%f\n";printf(format,a,b);</code></div><h4 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h4><p>与输出相似，字符串的输入支持以下三种方法：</p><div class="show">1. 依次输入单个字符<code>for(int i=0;i&lt;6;i++)&#123;    scanf("%c",&str[i]);&#125;</code>2. 用格式符s，将字符串作为一个整体输入，直至遇到<span class="tips">空白字符、空格、回车符、制表符</span>为止，注意！<span class="text-blue">由于字符数组名str本身已经代表字符串的首地址，因此str前不能再加上取地址符&</span>，此外，用scanf()不能输入带空格、制表符的字符串，空格、制表符、回车符及其之后的字符会被留在输入缓冲区<code><span class="text-red">scanf("%s",str);</span></code>3. 使用<span class="text-blue">gets()</span>函数(&lt;stdio.h>库函数)，gets()函数以回车符作为输入终止符，同时将回车符从输入缓冲区读走，但不作为字符串的一部分，因此该函数可用于输入带空格的字符串<code><span class="text-red">gets(str);</span></code><p>以上方法都有一定的安全隐患，如果输入字符数超过了定义的字符数组大小，多出的字符可能引起缓冲区溢出，带来安全隐患，因此可以使用能限制输入字符串长度的函数<br><span class="text-blue">fgets(str,sizeof(str),stdin)</span><br>该语句表示从标准输入stdin中读取一行长度为sizeof(str)的字符串存储到str为首地址的存储区中，多余的字符舍弃</div></p><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>注意！如果使用字符指针输入字符串，必须保证字符指针事先已经指向一个字符数组地址或确定的存储单元，否则可能导致非法内存访问错误！</div><div class="show">使用字符指针输入字符串需要注意以下情况<code>char * ptr;//ptr未被初始化scanf("%s",ptr);</code>上述代码，编译时给指针变量ptr分配了内存单元，但ptr中的值是一个不可预料的垃圾值，该指针指向一个未确定的存储单元，可能指向空白存储区，也可能指向已经存放指令或数据的内存段，在现代编译器中会报错使用了未初始化的局部变量“ptr”，然而在低版本编译器中可能顺利通过编译，带来潜在安全隐患因此，推荐使用字符数组输入字符串<code>char str[10];scanf("%s",str);</code>如果使用字符指针输入字符串，则保证该指针指向了确定的地址<code> char str[10];<span class="text-red">char * ptr=str;</span> gets(ptr);</code></div><h3 id="构造类型-1"><a href="#构造类型-1" class="headerlink" title="构造类型"></a>构造类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>定义方式： </p><div class="apiBox">类型 数组名[数组长度]</div><p>数组名的命名规则遵守标识符命名规范，数组长度需要使用常量表达式，<span class="tips">不能包含变量</span>，一维数组的初始化可以使用以下方法：</p><ul><li>在定义时赋予全部初值，如：int nums[5]={0,1,2,3,4};</li><li>也可以只给一部分元素赋值，其余元素会被赋0(char类型赋’\0’)，如：int nums[5]={0,1};</li><li>如果全部元素相同，可以只写一个值，如:int nums[5]={0};</li><li>如果对全部元素赋予初值，由数据个数已经确定，可以不指定数组长度，如：int nums[]={0,1,2,3,4};</li></ul><div class="show">1. 数组在定义时可以被整体初始化赋值<code>int nums[5]=&#123;11,22,33,44,55&#125;;</code><span class="text-red">但不允许在赋值语句中被整体赋值</span><code>int nums[5];nums[]=&#123;11,22,33,44,55&#125;;//错误</code>这是由于数组在定义时，编译系统就会为其分配连续的内存单元，其内存空间大小就已确定，后续的整体赋值语句如果执行，可能会导致内存覆盖或溢出等不可预期的行为，所以需要注意用数组和指针操作字符串时的不同情况<code>char str[6];str[]=&#123;"Hello"&#125;;//错误char * ptr;ptr="Hello";//正确</code>2. <span class="text-blue">数组名代表数组首元素的内存地址，即数组的起始地址，是一个地址常量，不能像修改指针变量一样对数组名进行++或--等操作</span><code>int a[10];int *p;p=a;p++;//允许，指针指向a[1]a++;//不允许，a是数组首地址，无法修改</code>3. C语言数组无length属性，获取数组长度可借助sizeof()函数<code>int nums[] = &#123;1,2,3,4,5&#125;;printf("%d", sizeof(nums)/sizeof(nums[0]));</code></div><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>定义方式： </p><div class="apiBox">类型 数组名[数组长度][数组长度]</div><p>对数组名和数组长度的要求同一维数组，二维数组的初始化可以使用以下方法：</p><ul><li>分行赋值，如：<code>int nums[3][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;</code></li><li>也可以一次性统一赋值，但不如第一种赋值方法清晰，如：<code>int nums[3][2]=&#123;1,2,3,4,5,6&#125;</code></li><li>可以只给部分元素赋值，同样其余元素会被赋0(char类型赋’\0’)，如：<code>int nums[3][2]=&#123;&#123;1&#125;,&#123;&#125;,&#123;0,6&#125;&#125;</code></li><li>如果对所有元素赋初值，可以不指定第一维的长度，但<span class="tips">第二维的长度声明永远不能省略</span></li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>对于复杂数据对象，仅仅使用几种基本数据类型无法准确反映它们之间的内在联系，也无法做统一处理，于是衍生出了允许用户自定义的数据类型，C语言中称之为构造数据类型(复合数据类型)，结构体就是构造数据类型的典型代表</p><p>结构体模板的声明格式如下：</p><div class="apiBox">struct 结构体名{    结构体成员};</div><p>结构体模板只是声明了一种数据类型，并未声明结构体类型的变量，编译器不为其分配内存，需要再使用以下语句声明结构体变量，编译器才会为结构体变量分配内存：<br><span class="strong">struct 结构体名 结构体变量名;</span></p><ul><li>结构体的名字又称为结构体标签，用于标记用户自定义的结构体类型，struct+结构体名 共同构成一个数据类型，如：下述例子中的struct student是一个类型名，作用同系统提供的标准类型(如int、char等)，因此不为其分配内存</li><li>结构体成员的命名遵从变量的命名规则</li><li>结构体成员也可以为一个结构体，即结构体可以嵌套</li><li>结构体成员名可以与程序其他位置的变量名相同，二者互不干扰</li></ul><div class="show">eg:先声明结构体模板，再声明结构体变量<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;;//声明结构体模板，末尾;不可省略struct student stu1,stu2;//声明结构体变量</code></div><p>也可以在声明结构体模板时，定义结构体变量：</p><div class="apiBox">struct 结构体名{    结构体成员}变量名1,变量名2...;</div><div class="show">eg:声明结构体模板同时声明结构体变量<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;stu1,stu2;</code>eg:当结构体模板与结构体变量一起声明时，结构体名是可以省略的，但该方法由于未指定结构体名，无法在程序其他地方再定义结构体变量，因此并不常用<code>struct//无结构体名&#123;    long studentID;    char studentName[10];    int score[4];&#125;stu1,stu2;</code></div><p>关键字<span class="strong">typedef</span>用于为已有数据类型定义一个别名，数据类型别名通常大写，便于区分已有数据类型。定义结构体时可用typedef定义一个结构体别名，便于使用更简洁的形式定义结构体变量</p><div class="show">为结构体定义别名时，以下两个别名定义形式等价：<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;;<span class="text-blue">typedef struct student STUDENT;</span>与<span class="text-blue">typedef</span> struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;<span class="text-blue">STUDENT</span>;</code>二者都为struct student类型定义了一个新名字STUDENT，因此以下两条定义结构变量的语句等价：<code>STUDENT stu1,stu2;//简洁形式struct student stu1,stu2;</code></div><h4 id="结构体变量初始化与成员引用"><a href="#结构体变量初始化与成员引用" class="headerlink" title="结构体变量初始化与成员引用"></a>结构体变量初始化与成员引用</h4><p>结构体变量的成员可以通过将成员初值置于花括号内进行初始化</p><div class="show">eg:在定义结构体变量时初始化<code>STUDENT stu1=&#123;114604,"SHIWIVI",&#123;111,222,333,444&#125;&#125;</code>也可以在定义结构体模板和变量同时初始化<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;stu1=&#123;114604,"SHIWIVI",&#123;111,222,333,444&#125;&#125;</code></div><p>访问结构体变量的成员必须使用<span class="tipe">成员选择运算符</span>(圆点运算符)，访问格式为：<br><span class="apiBox">结构体变量名.成员名</span></p><ul><li>C语言规定，不能将结构体变量作为一个整体输入、输出，如：printf(“%d%s..”,stu1)为非法语句</li><li>只能通过用圆点运算符访问结构体成员的方式来输入输出，如：printf(“%s”,stu1.studentName)</li><li>成员运算符<span class="tips">.</span>在所有运算符中优先级最高，因此通常可以将stu1.studentName当成一个整体看待</li><li>结构体嵌套时，必须以级联方式访问结构体成员，如：stu1.birthday.year</li><li>结构体成员可以像普通变量一样进行各种运算，如：stu1.birthday.year++</li><li>C语言允许对具有相同结构体类型的变量进行整体赋值，如：stu1初始化后，可以通过stu2=stu1对stu2进行初始化，结构体成员会进行逐一顺序赋值</li><li>也可以使用=号对结构体成员进行分开赋值，但注意，当结构体成员为字符数组时，由于<span class="text-red">字符数组名是该数组的首地址，是一个地址常量，不能作为赋值表达式左值</span>，因此对字符数组类型的结构体成员进行赋值时，必须使用字符串处理函数<span class="text-blue">strcpy()</span></li><li>结构体变量的地址是其所占存储空间的首地址，而结构体成员的地址与该成员在结构体中的所处位置和所占内存字节数有关，可以单独访问成员地址，如：&amp;su1.studentID</li></ul><div class="show"><code>#include&lt;stdio.h&gt;typedef struct date&#123;    int year;    int month;    int day;&#125;<span class="strong">DATE</span>;typedef struct student&#123;    long studentID;    char studentName[10];    <span class="strong">DATE</span> birthday;    int score[4];&#125;int main(void)&#123;    STUDENT stu1=&#123;114604,"SHIWIVI",&#123;1998,10,1&#125;,&#123;111,222,333,444&#125;&#125;;    STUDENT stu2;    <span class="text-blue">stu2=stu1;//整体赋值</span>    //也可以对结构体成员分开赋值，整体赋值等价于下述赋值语句    stu2.studentID=stu1.studentID;    <span class="text-blue">strcpy(stu2.studentName,stu1.studentName);</span>    stu2.birthday.year=stu1.birthday.year;    ...    stu2.score[0]=stu1.score[0];    ...    //通过键盘输入成员值时，单独访问成员变量地址    scanf("ld%",&su1.studentID);    scanf("%s",stu1.studentName);    scanf("%d",&stu1.birthday.year);    for(int i=0;i&lt;4;i++)&#123;        scanf("%d",&stu1.score[i]);    &#125;    return 0;&#125;</code></div><h4 id="结构体所占内存字节数"><a href="#结构体所占内存字节数" class="headerlink" title="结构体所占内存字节数"></a>结构体所占内存字节数</h4><p>系统为结构体变量分配内存大小时，结构体类型所占字节数，并非是所有成员所占内存字节数的总和，这是因为许多计算机系统为了提高寻址效率，处理器体系为特定的数据类型引入了<span class="strong">内存对齐</span>需求，编译器为了满足处理器的对齐要求，会在较小的成员后加入补位，从而导致结构体实际所占内存字节数会比预计的多出一些字节。<br>如：32位计算机体系结构，short型数据从偶数地址开始存放，int型数据则被对齐在4字节地址边界，这样就保证了一个int型数据通过一次内存操作就能被访问到，而读取存储在没有对齐地址处的32位整数，则需要两次读取操作，再从两次读取到的64位数据中提取该32位整数相关的数据，这样会导致系统性能下降</p><p>因此计算结构体类型大小时一定要使用<span class="text-red">sizeof()</span>运算符，不能想当然直接对各成员所占内存进行简单求和。</p><div class="show"><code>#include&lt;stdio.h>typedef struct sample &#123;    char c1;    int num;    char c2;&#125;SAMPLE;int main(void) &#123;    SAMPLE s = &#123; 'a',10,'b' &#125;;    printf("%d", sizeof(s));//12而非6    return 0;&#125;</code>根据内存对齐需求，如下图所示，c1和c2后会被增补3个字节补位，以达到与成员变量num内存地址对齐的要求，因此结构体变量s将占用12个字节的存储单元而非6个字节。如果将int类型改为short，则c1和c2将以short(2字节)为基准，后补1个字节空闲存储单元，s将占用6个字节内存<p><canvas width="200" height="110" id="canvasStruct" style="display:block;width:200px;height:110px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>const canvasStruct=document.getElementById("canvasStruct");const ctxSt=canvasStruct.getContext('2d');ctxSt.strokeRect(50, 10, 120, 90);ctxSt.moveTo(50,40);ctxSt.lineTo(170,40);ctxSt.strokeRect(80, 10, 30, 30);ctxSt.strokeRect(110, 10, 30, 30);ctxSt.moveTo(50,70);ctxSt.lineTo(170,70);ctxSt.strokeRect(80, 70, 30, 30);ctxSt.strokeRect(110, 70, 30, 30);ctxSt.stroke();ctxSt.font="600 13px Serif";ctxSt.fillText("成员1", 10, 30);ctxSt.fillText("c1", 60, 30);ctxSt.fillText("成员2", 10, 60);ctxSt.fillText("num", 100, 60);ctxSt.fillText("成员3", 10, 90);ctxSt.fillText("c2", 60, 90);</script></div><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>与普通数组类似，结构体数组也可以在定义时统一初始化</p><div class="show">eg:在结构体数组定义时初始化数组，如果只初始化部分数组元素，则其余数组元素会被自动赋为0值<code>STUDENT stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;//数组长度可以省略不写或struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125; stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;访问数组元素的方法与普通数组一样printf("%ld",stu[1].studentID);</code></div><h4 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h4><p>可以使用一个指针变量p指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址，随后，就可以使用<span class="text-red">指向运算符</span>(箭头运算符)访问结构体的成员，以下三种访问结构体成员变量的方式等价：</p><ul><li><span class="strong">结构体变量.成员名</span></li><li><span class="strong">(*p).成员名</span></li><li><span class="strong">p-&gt;成员名</span><div class="show"><code>struct student stu1=&#123;1101,"LiLin",11,22,33,44&#125;;<span class="text-blue">struct student * p=&stu1;</span>printf("%ld"，<span class="text-red">stu1.studentID</span>);printf("%ld"，<span class="text-red">(*p).studentID</span>);printf("%ld"，<span class="text-red">p->studentID</span>);</code></div></li></ul><p>指针也可以指向结构体数组，操作同指向普通数组类似，对指针进行的++操作会使指针指向下一个结构体数组元素</p><div class="show"><code>STUDENT stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;struct student * p=stu;for(;p&lt;stu+3;p++)&#123;    printf("%s\n",p->studentName);&#125;//p被定义为是指向struct student类型的指针，如果需要将其指向其他类型，可以使用强制类型转换p=(struct student *)stu[0].studentName;printf("%s",p);//输出stu[0]的studentName//但此时p仍然保持原来的类型，p+1将指向stu[1]的studentNameprintf("%s",p+1);</code></div><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体(也称为联合,Union)是将不同类型的数据存放在一起，占用同一段内存的一种构造数据类型，共用体的声明形式与结构体类似：</p><div class="apiBox">union 共用体名{    共用体成员};</div><ul><li>共用体类型所占内存大小取决于其成员中所占内存空间最大的成员变量</li><li>共用体同一内存段可以用来存放不同类型的数据，但在同一时间只能存放其中一种类型的成员，也就是说，同一时刻只能有一个成员起作用</li><li>共用体变量中起作用的成员是最后一个被赋值的成员，在存入一个新的成员值后，原有的成员值会被覆盖</li><li>共用体的成员一般单独赋值、调用</li><li>共用体变量的地址和其各成员的地址都是同一个地址</li><li>共用体不能进行比较操作</li><li>共用体不能作为函数参数，也不能作为函数返回值，但可以使用指向共用体变量的指针</li><li>不能只引用共用体变量，需要引用共用体的具体成员</li></ul><div class="show"><code>union sample&#123;    short i;    char ch;    float f;&#125;;union sample a;//共用体a中i,ch,f共占一段内存空间，因此a的大小由成员最大数据类型float决定，占用4个字节a.i=10;//可以给共用体成员单独赋值a.ch='R';a.f=11.11;//完成上述3个赋值运算后，只有a.f有效，a.i和a.ch将被覆盖失效//如果在定义时初始化共用体的成员初值，C89规定只能对共用体的第一个成员进行初始化，但c99无该限制，允许按以下形式按名设置成员初值<span class="text-blue">union sample b=&#123;.i=10,.ch='b',.f=22.22&#125;;</span>//但也只有f会生效</code></div><p>共用体可以用来存储程序中逻辑相关但情形互斥的变量，共享内存空间可以节省内存，也避免了操作失误引起的逻辑冲突。如：职工管理系统中，职工的个人婚姻状况只能有三种情况：未婚、已婚、离婚。且这三种情况应当是互斥的，此时可以用共用体来存储该数据</p><div class="show">eg:未婚标识为0，已婚则记录结婚日期、配偶姓名，离婚则记录离婚日期<code>struct date&#123;    int year;    int month;    int day;&#125;;struct marriedState //已婚信息&#123;    struct date marryDate;//记录结婚日期    char spouseName[20];//记录配偶姓名&#125;;struct divorceState //离婚信息&#123;    struct date divorceDay;//记录离婚日期&#125;;<span class="text-blue">union maritalState</span> //共用体，存储婚姻状况&#123;    int single;//未婚    struct marriedState married;//已婚    struct divorceState divorce;//离婚&#125;;struct person&#123;    char name[20];    char sex;    int age;    union maritalState marital;    int marryFlag; //共用体无法直接看出是哪个成员生效，因此使用一个变量标记婚姻状态&#125;;</code></div><p>共用体也可以用来构造混合数据结构，高效使用存储空间，如：需要存储的数据是int和float型数据的混合，可以定义如下共用体：</p><div class="show"><code>typedef union&#123;    int i;    float f;&#125;NUMBER;NUMBER array[20];//既可以存储int数据，也可以存储float数据</code></div><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>当一个变量只有几种固定的值时，就可以使用枚举表示，枚举类型的定义方法与结构体类似，需要使用enum关键字：</p><div class="apiBox">enum 枚举标签名{    枚举常量}枚举变量名;</div><ul><li><span class="strong">枚举常量都是整型常量</span>，除非特别指定，否则其值按顺序为0，1，2….</li><li>允许在定义时明确指定枚举常量的值，如：enum response {no=1,yes=1,none=0}，也可以只指定前几个值，其后的值会自动递增，如：enum month{Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec};</li><li>程序员在花括号内定义的枚举常量只作为标识符使用，并不代表什么含义，其值本质仍是整型常量，不是字符串</li><li>枚举常量可以作为整型值进行比较、输出操作</li><li>可以定义枚举型数组，如：enum response answers[10];</li></ul><div class="show"><code>enum response&#123;no,yes,none&#125;;enum response res1,res2;或enum response&#123;no,yes,none&#125; res1,res2;或enum &#123;no,yes,none&#125; res1,res2;//枚举类型和枚举变量一起定义时，枚举标签可省略</code></div><div class="show"><code>1. 枚举变量的赋值只能从枚举常量中选取enum response&#123;no,yes,none&#125; res1,res2;res1=yes;//只能赋值no、yes、none中的其中一个2. 枚举变量可以用于条件语句，比较规则是按其定义时的整型值进行比较，默认情况下为：no=0,yes=1,none=2if(res1==yes)if(res1>none)3. 枚举常量的值是整型常量，因此只能作为整型值处理，而不能作为字符串来使用printf("%d",res1);//正确，输出res1为1printf("%s",res1);//错误！不能作为字符串使用，无法输出yes4. 虽然枚举常量都表示为整型常量，但不能直接将整型常量赋值给枚举变量，因为它们属于不同类型res1=2; //错误可以进行强制类型转换，相当于将值为2的none赋给res1，2也可以替换为表达式res1=(enum response)2;</code></div><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h4><div class="table"><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>int * p</td><td>指向整型数据的指针变量</td></tr><tr><td>int *p[n]</td><td>指针数组，数组中含n个指针</td></tr><tr><td>int (*p)[n]</td><td>二维数组的行指针，p指向含n个元素的一维数组</td></tr><tr><td>int * p()</td><td>p为返回指针的函数，该指针指向整型值</td></tr><tr><td>int (*p)()</td><td>p为指向函数的指针，该函数返回整型值</td></tr><tr><td>int **p</td><td>p为指向指针的指针，p指向的指针指向整型数据</td></tr></tbody></table></div><ul><li><span class="strong">指针</span>：一个变量的地址称为该变量的”指针”，反之亦然，变量的指针即变量的地址</li><li><span class="strong">指针变量</span>：专门用于存放地址的变量</li><li><span class="strong">&amp;</span>：取地址运算符</li><li><span class="strong">*</span>：指针运算符，取出指针变量指向的内容，又称为间接寻址运算符<br>指针的定义：<div class="apiBox">数据类型 * 变量名</div></li></ul><div class="show"><code>int a=10;int * p;//定义int *类型的变量p，p只能用于存储地址，*只是表明该变量是指针变量p=&a;//取出变量a的地址并存储到p中printf("%d",* p);//*p表示取出变量p中地址指向的内容，等价于printf("%d",a)printf("%p",&a);//输出变量a在内存中所占存储空间的首地址，等价于printf("%p",p)</code></div><p>使用指针的注意事项：</p><ul><li><span class="text-red">不要使用未初始化的指针变量</span>，未决定指针指向时，可以使指针变量初始化为<span class="text-blue">NULL</span>(stdio.h中定义为零值的宏)</li><li>要永远清楚指针指向哪里，指针必须指向一块有意义的内存</li><li>要永远清楚每个指针指向的对象内容是什么</li></ul><h4 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h4><p>使用指针操作数组可以有效提高运行速度，减小内存占用。数组在定义时，编译系统就会为其分配连续的内存单元，相应地，内存首地址也确定了。C语言中，数组名代表数组首元素的内存地址(数组名作形参时除外，此时数组名不占据内存单元)，因此可以直接将数组名赋值给指针变量</p><div class="show">由于<ul><li>数组变量名代表数组起始内存地址</li><li>数组首元素地址也是数组起始内存地址</li></ul>因此指针初始化一般可以用两个赋值方法，两个赋值语句等价:int a[10]; int * p;<span class="text-red">p=a;</span>或<span class="text-red">p=&a[0];</span></div><p>而后，就可以使用指针引用数组元素。对于指针变量p，p+1将指向数组的下一个元素，即地址跳到<span class="text-green">1*sizeof(基类型)</span>个字节以后，而非对p中的地址进行简单加1，如：如果p指向int类型的数组，p+1会将p中的地址值增加4个字节对应的地址值，使其指向4个字节以后的空间。使用指针引用数组元素有以下特点：</p><div class="apiBox">p+i和a+i均是a[i]的地址*(p+i)和*(a+i)均是a[i]的值</div><p>实际上，读取数组元素a[i]就是通过*(a+i)处理，即在数组首元素地址的基础上加上地址偏移量得到要找元素的地址，然后取出该地址中的数据，由此可得，<span class="tips">[ ]实际上是变址运算符</span>，指向数组的指针变量也可以使用该变址运算符，如：p[i]等价于*(p+i)等价于i[p]</p><div class="show">数组元素a[i]的表示方法有：<span class="strong">a[i]</span>、<span class="strong">i[a]</span>、<span class="strong">p[i]</span>、<span class="strong">i[p]</span>、<span class="strong">*(a+i)</span>、<span class="strong">*(p+i)</span></div><h5 id="常用的指针变量运算"><a href="#常用的指针变量运算" class="headerlink" title="常用的指针变量运算"></a>常用的指针变量运算</h5><ul><li><span class="strong">*p++</span> 右结合，解析为*(p++)，先获得*p的值，再使p+1=&gt;p</li><li><span class="strong">*(++p)</span> 先对p加1，使其指向下一个元素，再获得此时*p的值</li><li><span class="strong">(*p)++</span> 获得*p的值，并对该值加1</li><li><span class="strong">*(p--)，*(--p)，(*p)--</span> 与上类似</li></ul><!-- <div class="show">1. &*p等价于&a2. *&a等价于a3. (*p)++等价于a++，由于++和*同优先级且右结合，因此不能写为*p++，否则会被解析为*(p++)</div> --><h5 id="数组元素的遍历"><a href="#数组元素的遍历" class="headerlink" title="数组元素的遍历"></a>数组元素的遍历</h5><p>在遍历数组元素时，通过数组下标或通过数组元素地址遍历，二者执行效率是相同的，C编译系统对nums[i]的处理也是将其转换为*(nums+i)来作处理的，即根据首元素地址重新计算元素偏移地址，再访问该地址</p><p>而通过指针变量遍历时，指针变量通过有规律地改变地址值(p++)，直接指向元素，不必每次都重新计算地址，极大提高了执行效率</p><div class="show">遍历数组的三种方法：int nums[5]={11,22,33,44,55};//1.利用数组下标for(int i=0;i&lt;5;i++){    printf("%d",nums[i])}//2.通过求出数组元素地址，获得值for(int i=0;i&lt;5;i++){    printf("%d",*(nums+i))}<span class="strong">//3.通过指针变量for(int *p=nums;p&lt;(nums+5);p++){    printf("%d",*p)}</span>注意：p++和p+1本质是两个不同的操作，特别对于指针变量而言，p++有赋值操作，会修改p的值从而使p指向下一个元素，而p+1并不改变当前指针的指向<p><span class="text-red">数组名nums代表数组元素首地址，是一个指针常量，它的值是固定不变的，因此只能像*(nums+i)一样基于此地址进行计算,不能使用nums++改变该地址值</span><br>for(int *p=nums;nums&lt;(p+5);nums++){//错误代码<br>    printf(“%d”,*a)<br>}</div></p><h4 id="指针与函数传参"><a href="#指针与函数传参" class="headerlink" title="指针与函数传参"></a>指针与函数传参</h4><p>使用指针作为函数参数时，不再是简单的<span class="tips">值传递</span>，而是<span class="tips">地址传递</span>，可以直接修改原参数的值</p><div class="show">eg:将一个数组中的值反序存放并输出<code>#include&lt;stdio.h>int main(void) &#123;    void inv(int*, int);    int nums[10] = &#123; 0,11,22,33,44,55,66,77,88,99 &#125;;    printf("original array：");    for (int* p = nums; p < nums + 10; p++) &#123;        printf("%d ", *p);    &#125;    <span class="text-red">inv(nums, 10);</span>    printf("\ninverted array：");    for (int* p = nums; p < nums + 10; p++) &#123;        printf("%d ", *p);    &#125;    return 0;&#125;void inv(<span class="text-red">int * p,int n</span>) &#123;//n为数组长度    int temp;    for (int i = 0; i < n / 2; i++) &#123;        temp = *(p+i);        *(p + i) = *(p + n - 1 - i);        *(p + n - 1 - i) = temp;    &#125;&#125;</code>在函数中修改数组值，实参与形参的对应关系一般有以下4中1. 形参和实参都用数组名，形参接收实参的数组首地址，因此形参和实参数组共用一段内存空间。定义形参a[]时，可以不指定数组长度，因为编译器实际上是将形参数组名作为指针变量来处理，并不会真的开辟一个数组空间void inv(int a[],int n)             inv(nums,10)2. 实参用数组名，形参用指针变量。形参的指针初始指向数组元素首地址void inv(int *p,int n)              inv(nums,10)3. 实参和形参都用指针变量。实参n先指向数组首地址，再将该地址值传递给形参p，初始时两个指针指向同一个地址void inv(int *p,int n)              int *n=nums; inv(n,10)4. 实参为指针变量，形参为数组名。编译时，编译系统会将形参数组名作为a作为指针变量来处理，同样，初始时两个指针指向同一个地址void inv(int a[],int n)             int *n=nums; inv(n,10)</div><h4 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a>二维数组与指针</h4><p>一维数组可以拓展到二维数组、三维数组等等，以二维数组为例，一个二维数组可以视为是由多个一维数组构成的，即二维数组的数组元素也是一个数组。</p><div class="show">设一个3行4列的二维数组<code>int a[3][4]={{0,0,0,0},{11,11,11,11},{22,22,22,22}};</code>对于该数组，可以视为数组a中包含3个元素：a[0],a[1],a[2]，而这3个元素每个都是一维数组:<span class="strong">a[0]</span>==> a[0][0]、a[0][1]、a[0][2]、a[0][3]<span class="strong">a[1]</span>==> a[1][0]、a[0][1]、a[0][2]、a[0][3]<span class="strong">a[2]</span>==> a[2][0]、a[0][1]、a[0][2]、a[0][3]暂且忽略a[0],a[1],a[2]内部包含的内容，将它们当作普通的数组元素，由此：数组a是包含a[0]、a[1]、a[2]三个数组元素的一维数组，其中：a是数组首元素a[0]的地址(即&a[0])，a+1是a[1]的地址(&a[1])，a+2是a[2]的地址(&a[2])，所以：<span class="strong">a=&a[0]，a+1=&a[1]，a+2=&a[2]</span>;<span class="text-red">*(a+0)=a[0]，*(a+1)=a[1]，*(a+2)=a[2]</span>;<p>此时将a[0]、a[1]、a[2]展开，这三个元素每个都是一维数组，在这三个数组内部，a[0]、a[1]、a[2]分别是它们内部一维数组的数组名，又因为C语言中数组名代表数组首元素地址，因此：<br>a[0]即为a[0][0]的地址，即&amp;a[0][0]，a[0]+1则为a[0][1]的地址 &amp;a[0][1]……<br>即：<br><span class="strong">a[0]+0=&amp;a[0][0]，a[0]+1=&amp;a[0][1]，a[0]+2=&amp;a[0][2]，a[0]+3=&amp;a[0][3]</span><br><span class="text-red">*(a[0]+0)=a[0][0]，*(a[0]+1)=a[0][1]，*(a[0]+2)=a[0][2]，*(a[0]+3)=a[0][3]</span>;</p><p>由于<span class="text-red">a[0]和*a</span>等价，因此<br>a[0]+0与*(a+0)均是a[0][0]的地址，a[0]+1与*(a+0)+1均是a[0][1]的地址，其他同理，由此可得：<br><span class="text-blue">*(a[0])=*(*(a+0)+0)=**a=a[0][0]，*(a[0]+1)=*(*(a+0)+1)=*(*a+1)=a[0][1]</span><br><span class="text-blue">*(a[1]+2)=*(*(a+1)+2)=a[1][2]，*(a[2]+3)=*(*(a+2)+3)=a[2][3]</span><br><span class="text-blue">其他以此类推</span></p><p><span class="text-red">注意！<br>对于一维数组，a[i]代表一个数组元素，占据内存单元，拥有物理地址，但在二维数组中，a[i]代表一维数组名，只是一个地址(如同一维数组中的数组名只是一个指针常量一样)，务必记住，a[i]和*(a+i)是等价的</span></p></div><p>由上，总结：</p><p>表示a[i][j]<span class="text-blue">地址</span>的方法：</p><ul><li><span class="text-blue">a[i]+j</span></li><li><span class="text-blue">*(a+i)+j</span></li><li><span class="text-blue">&amp;a[i][j]</span></li></ul><p>表示a[i][j]<span class="text-red">值</span>的方法：</p><ul><li><span class="text-red">*(a[i]+j)</span></li><li><span class="text-red">*(*(a+i)+j)</span></li><li><span class="text-red">(*(a+i))[j]</span></li><li><span class="text-red">a[i][j]</span></li></ul><h6 id="二维数组的行指针与列指针"><a href="#二维数组的行指针与列指针" class="headerlink" title="二维数组的行指针与列指针"></a>二维数组的行指针与列指针</h6><div class="show">对于二维数组，其地址也可以分为行地址和列地址，如图所示：<div class="table"><table><thead><tr><th colspan="5">二维数组存储</th></tr></thead><tbody><tr style="color:#fb5b33;"><td style="color:#056efb;">行/列地址</td><td>a[i]+1</td><td>a[i]+2</td><td>a[i]+3</td><td>a[i]+4</td></tr><tr><td style="color:#25ccf7;">a+0</td><td>a[0][0]</td><td>a[0][1]</td><td>a[0][2]</td><td>a[0][3]</td></tr><tr><td style="color:#25ccf7;">a+1</td><td>a[1][0]</td><td>a[1][1]</td><td>a[1][2]</td><td>a[1][3]</td></tr><tr><td style="color:#25ccf7;">a+2</td><td>a[2][0]</td><td>a[2][1]</td><td>a[2][2]</td><td>a[2][3]</td></tr></tbody></table></div><p>其中，二维数组名a是指向行地址的，因此a+1中的"1"代表一个含有4个整型元素的一维数组所占存储单元的字节数，即<span class="text-green">4*sizeof(int)</span>，a+1将指向下一行</p><p>一维数组名a[0]、a[1]、a[2]是指向列元素的，a[0]+1中的1代表一个整型元素所占存储单元的字节数，a[0]+1将指向下一个列元素</p><p>在指向行的指针前加一个*，就转换为指向列的指针，如：指针a和a+1是指向行的，而*a和*(a+1)则是指向列的，它们拓展为*(a+0)+0和*(a+1)+0，分别指向第0行0列元素和第1行第0列。反之，在指向列的指针前加上&，该指针就变成了指向行的指针，如：列指针a[0]指向第0行第0列的元素，而&a[0]等价于&*(a+0)，而&*a等价于a，因此&a[0]是指向第0行的行指针。注意，&a[i]不能理解为a[i]的物理地址，因为二维数组中并不存在a[i]元素，它只是一个地址计算方法，能得到第i行的起始地址。</p>练习：a、a+0、&a[0]代表第0行首地址*a、*(a+0),a[0],a[0]+0代表第0行第0列的地址&a[0][0]代表第0行第0列元素地址a[0][0]、**a代表第0行第0列元素值a+i、&a[i]代表第i行地址a[i]+j、\*(a+i)+j,&a[i][j]代表第i行第j列地址a[i][j]、\*(\*(a+i)+j)代表第i行第j列元素值</div><h5 id="二维数组元素的引用-指针变量"><a href="#二维数组元素的引用-指针变量" class="headerlink" title="二维数组元素的引用(指针变量)"></a>二维数组元素的引用(指针变量)</h5><h6 id="通过二维数组的列指针变量引用"><a href="#通过二维数组的列指针变量引用" class="headerlink" title="通过二维数组的列指针变量引用"></a>通过二维数组的列指针变量引用</h6><p>由于列指针指向数组的具体元素，因此定义列指针与定义同类型普通指针相同：<br><span class="strong">int * p</span><br>可以用以下三种等价方法对其进行初始化：</p><ul><li><span class="strong">p=a[0]</span></li><li><span class="strong">p=*a</span></li><li><span class="strong">p=&amp;a[0][0]</span></li></ul><p>此时，由于需要使用列指针对二维数组元素进行引用，因此可以将二维数组看成一个由m行*n列个元素组成的一维数组，获取第i行j列的元素，则其在一维数组中的索引为i*n+j，因此a[i][j]元素的地址为<span class="text-blue">p+i*n+j</span>，其值表示方法为<span class="text-red">*(p+i*n+j)</span>或<span class="text-red">p[i*n+j]</span></p><p>注意，此时不能用p[i][j]来表示数组元素，因为给p赋初值时将其赋为了列指针，即是将二维数组作为一维数组来进行处理的，p++将使指针依次指向下一个数组元素。正因如此，在定义二维数组的列指针时，无须指定它所指向的二维数组的列数。因此二维数组的列指针也常常用作函数参数，以实现二维数组的行列数需要动态指定的场合。</p><div class="show">eg:使用二维数组列指针引用数组元素<code>#include&lt;stdio.h>int main(void) &#123;    void outputArray(int *,int);    int a[3][4] = &#123; &#123;11,11,11,11&#125;,&#123;22,22,22,22&#125;,&#123;33,33,33,33&#125; &#125;;    <span class="text-red">outputArray(a[0], 12);//列指针初始化int *p=a[0]</span>    <span class="text-blue">outputArray(*a, 12);//列指针初始化int *p=*a</span>    <span class="text-green">outputArray(&a[0][0], 12);//列指针初始化int *p=&a[0][0]</span>    return 0;&#125;void outputArray(int* p, int length) &#123;    for (int* index = p; index < p + length; index++) &#123;        printf("%d,", *index);    &#125;    printf("\n");&#125;</code></div><h6 id="通过二维数组的行指针变量引用"><a href="#通过二维数组的行指针变量引用" class="headerlink" title="通过二维数组的行指针变量引用"></a>通过二维数组的行指针变量引用</h6><p>由于行指针不再指向数组元素，而是指向一维数组，因此行指针变量比较特殊：<br><span class="strong">int (*p)[4]</span><br>可以用以下方法对其进行初始化：</p><ul><li><span class="strong">p=a</span></li><li><span class="strong">p=&amp;a[0]</span></li></ul><p>说明：定义了一个可指向含有4个元素一维整型数组的指针变量，[4]表示所指一维数组的长度，<span class="tips">在声明变量时必须显式指定，不可省略!</span>该指针可以作为一个指向二维数组的行指针，且它所指向的二维数组的每一行有4个元素。注意：定义该行指针变量时( )也不可省略，因为[ ]优先级高于*，p会优先与[ ]结合，int *p[4]是指针数组的定义方式。<br>可以用以下四种等价形式引用a[i][j]的值:</p><ul><li><span class="strong">p[i][j]</span></li><li><span class="strong">*(p[i]+j)</span></li><li><span class="strong">*(*(p+i)+j)</span></li><li><span class="strong">(*(p+i))[j]</span></li></ul><p>对于行指针变量，p++将指向二维数组的下一行，即移动4*sizeof(int)字节，因此需要显式指定所指一维数组的长度int (*p)[4]，否则无法计算指针移动的字节数。</p><div class="show">eg:使用行指针读入、输出二维数组元素<code>#include&lt;stdio.h>#define N 3int main(void) &#123;    <span class="text-red">//用普通的二维数组方式操作数组    void inputArray(int p[][N], int,int);    void outputArray(int p[][N], int,int);</span>    <span class="text-blue">//只使用行指针操作数组元素    void inputArray(int(*p)[N], int, int);    void outputArray(int(*p)[N], int, int);</span>    int a[2][3];    printf("Input 2*3 numbers:\n");    inputArray(a, 2,3);//把数组行数和列数也传参    outputArray(a, 2,3);    return 0;&#125;<span class="text-red">void inputArray(int p[][N], int rows,int columns) &#123;</span><span class="text-blue">void inputArray(int (*p)[N], int rows, int columns) &#123;</span>    printf("Input numbers:\n");    for (int i = 0; i < rows; i++) &#123;        for (int j = 0; j < columns; j++)        &#123;            <span class="text-red">scanf_s("%d", &p[i][j]);</span>            <span class="text-blue">scanf_s("%d", *(p+i)+j);</span>        &#125;    &#125;&#125;<span class="text-red">void outputArray(int p[][N], int rows, int columns) &#123;</span><span class="text-blue">void outputArray(int (*p)[N], int rows, int columns) &#123;</span>    printf("Output numbers:\n");    for (int i = 0; i < rows; i++) &#123;        for (int j = 0; j < columns; j++)        &#123;            <span class="text-red">printf("%d,", p[i][j]);</span>            <span class="text-blue">printf("%d,", *(*(p+i)+j));</span>        &#125;    &#125;&#125;</code></div><h4 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h4><p>一个函数在编译时被分配一个入口地址，与数组类似，函数名代表该函数的入口地址，函数的入口地址就称为该函数的指针，可以用一个指针变量指向函数，然后通过该指针变量调用该函数，指向函数的指针变量的定义形式为：<br><span class="strong">函数返回值类型 (* 指针变量名)(函数参数)</span></p><ul><li>定义举例：int (*p)(int,int)，表示定义一个指向函数的指针变量p，它可以任意指向同类型的不同函数(该函数应是int类型且有两个int参数)，并非固定指向一个函数</li><li>*p两侧的括号不能省略，p先与*结合表明是指针变量，再与后面的( )结合表明该指针变量指向函数</li><li>对指向函数的指针变量进行p++、p+n等操作是无意义的</li></ul><div class="show">eg:<code>int main(void)&#123;    int getMax(int,int);    <span class="text-blue">int (*p)(int,int);</span>//定义指向函数的指针    int a=10,b=20;    <span class="text-blue">p=getMax;</span>//将函数地址赋给p，不涉及实参和形参问题，因此不需要写任何参数    int result=<span class="text-blue">(*p)(a,b)</span>;//使用指针调用函数，只需用(*p)替代函数名即可    return 0;&#125;int getMax(int a,int b)&#123;    return a>b?a:b;&#125;</code></div><p>函数指针变量的用途之一是将函数作为参数传递到其他函数，即实现函数入口地址的传递，常见用法是：调用同一个函数时，在不同情况下实现不同的功能</p><div class="show">eg:多次调用process函数，依次实现求最大值、求和、求积功能<code>#include&lt;stdio.h>int main(void) &#123;    int getMax(int, int);    int add(int, int);    int multiply(int, int);    <span class="text-blue">void process(int, int, int (* fun)(int, int));</span>    int a = 10, b = 20;    <span class="text-blue">process(a, b, getMax);    process(a, b, add);    process(a, b, multiply);</span>    return 0;&#125;void process(int a,int b,int (* fun)(int,int)) &#123;    int result =<span class="text-blue">(*fun)(a, b)</span>;//fun指向不同函数地址，实现不同功能    printf("%d\n", result);&#125;int getMax(int a, int b) &#123;    return a > b ? a : b;&#125;int add(int a, int b) &#123;    return a + b;&#125;int multiply(int a, int b) &#123;    return a * b;&#125;</code></div><h4 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h4><p>函数除了可以返回整型值、字符值等，也可以返回一个指针(返回一个地址)，这种返回指针的函数，定义形式为:<br><span class="strong">类型 * 函数名(参数)</span></p><ul><li>函数定义举例：int * fun(int,int)，定义一个函数fun，该函数返回类型为int *，即返回一个指针，该指针指向int类型的数据，函数名fun和*两侧没有( )，fun先与(int,int)结合表明fun()是个函数</li><li>通过返回指针，C语言就可以实现返回数组、字符串等数据</li></ul><div class="show">eg:拼接两个字符串，返回一个新的字符串<code>#include&lt;stdio.h>int main(void) &#123;    char* str1 = "aaa", * str2 = "111";    char result[20];//存储拼接后的字符串，空间要足够大    <span class="text-blue">char* strCat(char*, char*,char *);</span>    printf("%s", strCat(result, str1, str2));    return 0;&#125;char* strCat(char * result,char* str1, char* str2) &#123;    char* p = result;    while (*str1 != '\0') &#123;        *p = *str1;        str1++;        p++;    &#125;    while (*str2 != '\0') &#123;        *p = *str2;        str2++;        p++;    &#125;    *p = '\0';//拼接后的字符串末尾加上字符串结束标志符    return result;//返回result数组的初始起始地址&#125;</code></div><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>一个数组，若其元素均为指针，则该数组为指针数组，一维指针数组的定义形式为：<br><span class="strong">类型名 * 数组名[数组长度]</span></p><ul><li>如：int *p[4]，p先与[4]结合，形成p[4]，表明这是一个数组，再与*结合，表明该数组是指针类型</li><li>注意区分于int (*p)[4]，这是指向一维数组的指针变量，即指向二维数组指针变量中的行指针</li><li>指针数组可用于指向不等长字符串、不等长数组等场景</li></ul><div class="show">指针数组可以指向若干不等长的字符串，如果用二维数组存储字符串，需要指定第二维的长度(一般为最长字符串的长度+1)，相较于二维数组，指针数组更为灵活快捷eg:将若干字符串按字母顺序排序<code>#include&lt;stdio.h>#include&lt;string.h>int main(void) &#123;    void sort(char* ptr[], int length);    <span class="text-blue">char* ptr[]</span>= &#123; "Document","ASCII","Java","CPP" &#125;;     sort(ptr, 4);     for (int i = 0; i < 4; i++) &#123;         printf("%s\n", ptr[i]);     &#125;    return 0;&#125;void sort(char* ptr[], int length) &#123;    char* temp;    int i, j, k;    for (i = 0; i < length-1; i++) &#123;        k = i;        for (j = i + 1; j < length; j++) &#123;//内循环找出全部字符串中字符顺序最小的字符串            if (strcmp(ptr[k], ptr[j]) > 0) &#123;//strcmp()函数，ptr[k]中的字母在ASCII中位置大于ptr[j]，则返回值大于0                k = j;            &#125;        &#125;        if (k != i) &#123;//如果找到的字符串不是i，调换顺序            temp = ptr[i]; ptr[i] = ptr[k]; ptr[k] = temp;        &#125;    &#125;&#125;</code></div><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>指针变量也可以指向一个另一个指针，指向指针的指针变量定义形式为：<br><span class="strong">类型 *** 变量名</span></p><ul><li>如：char **p，指针变量p指向另一个指针变量，被p指向的指针变量指向一个字符型数据</li><li>结合上一节的指针数组，就可以用指向指针的指针操作指针数组中的指针所指向的数据</li><li>理论上指向指针的指针可以无限套娃，如：int *****p，但多层指针嵌套容易混乱，难以理解</li></ul><div class="show">1. eg:用指向指针的指针输出指针数组指向的内容<code>#include&lt;stdio.h>int main(void)&#123;    char* ptr[]= &#123; "Document","ASCII","Java","CPP" &#125;;    <span class="text-blue"> char **p;</span>    for(int i=0;i&lt;4;i++)&#123;        p=ptr+i;        printf("%s\n",<span class="text-blue">*p</span>);    &#125;&#125;</code>2. eg:注意输出字符串、数组数据与整型等其他普通类型数据时，指针运算符(间接寻址运算符)需要取到哪一层值(取出的值是地址值还是变量本身的值)<code>#include&lt;stdio.h>int main(void)&#123;    int a = 11, b = 22;    int c = a + b;    int d = a + b + c;    int* nums[] = &#123; &a,&b,&c,&d &#125;;    <span class="text-blue">int** p=nums;</span>    for (int i = 0; i < 4; i++,p++) &#123;         printf("%d\n",<span class="text-blue">**p</span>);    &#125;    return 0;&#125;</code></div><h4 id="void-无类型指针"><a href="#void-无类型指针" class="headerlink" title="void * 无类型指针"></a>void * 无类型指针</h4><p>void *称为通用指针或无类型指针，用于声明基类型未知的指针变量，即声明了一个指针变量，但未指定它指向哪一种基类型的数据。它可以指向任意类型的数据，只需要在将它的值赋给其他类型的指针变量时，进行强制类型转换即可。ANSI标准要求动态分配内存的函数(malloc、calloc等)返回类型为void *无类型指针，方便将其转换为其他任意类型的指针变量。</p><p>注意区别于<span class="tips">空指针(NULL)</span>，空指针未指向任何有效内存(指向低地址保留区)，而<span class="tips">void *</span>当值不为NULL时，它指向了有效内存空间，只是尚未指定它指向的基类型。</p><div class="show">void *和其他类型的指针可以相互转换<code>char *str;void *p;str=(char *)p;或p=(void *)str;</code>动态分配内存函数返回值根据指向数据类型需要转换为其他类型<code>int * p=(int *)malloc(10*sizeof(int));</code></div><h4 id="指针数组与main函数的形参"><a href="#指针数组与main函数的形参" class="headerlink" title="指针数组与main函数的形参"></a>指针数组与main函数的形参</h4><p>一般情况下，main函数一般会写为空参数形式：int main(void)，实际上main函数可以带有参数，如：<br><span class="strong">int main(int argc,char * argv[])</span><br>Java语言中的main默认就为上述形式，argc和argv就是main函数的形参。main函数由操作系统调用，在main所在的.c文件被编译后，会生成可执行文件(windows下后缀为.exe)，在系统命令终端下(如：Linux的shell、windows的cmd)，输入<span class="strong">文件路径/可执行文件名 参数1 参数2…</span>即可调用该可执行文件并将参数传递给main函数</p><div class="show">假设main函数写于文件file.c文件中，编译后生成file.out文件在该文件所属路径下执行命令：<span class="strong">file.out data1 data2</span>对于main函数原型<span class="strong">int main(int argc,char * argv[])</span>argc指命令行中的参数个数，argv[]是存储参数字符串首地址的指针数组它收到3个命令行参数：file.out，data1，data2 //file.out也算一个参数所以argc=3，"file.out"、"data1"、"data2"字符串的首地址构成一个指针数组，存储于argv中：argv[0]--->"file.out\0"argv[1]--->"data1\0"argv[2]--->"data2\0"由于并不清楚输入的参数会多长，使用指针数组就可以巧妙解决这个问题可以写一个main函数输出执行时传入的参数内容：<code>int main(int argc,char * argv[])&#123;    while(argc&gt;1)&#123;         ++argv;        printf("%s\n",*argv);        --argc;    &#125;&#125;</code></div><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h4><div class="table"><table><thead><tr><th>优先级</th><th>运算符</th><th>名称</th><th>使用</th><th>说明</th><th>结合方式</th></tr></thead><tbody><tr><td rowspan="4">1</td><td>[&nbsp;]</td><td>数组下标</td><td>数组名[]</td><td rowspan="4"></td><td rowspan="4">从左到右</td></tr><tr><td>(&nbsp;)</td><td>圆括号</td><td>(表达式)</td></tr></tr><td>.</td><td>成员选择（对象）</td><td>对象.成员名</td></tr></tr><td>-&gt;</td><td>成员选择（指针）</td><td>对象指针->成员名</td></tr><tr><td rowspan="9">2</td><td>-</td><td>负号</td><td>-表达式</td><td rowspan="9">单目运算符</td><td rowspan="9"><span class="tips">从右到左</span></td></tr><tr><td>(类型)</td><td>类型转换</td><td>(数据类型)表达式</td></tr><tr><td>sizeof(&nbsp;)</td><td>长度运算符</td><td>sizeof(表达式)</td></tr><tr><td>！</td><td>逻辑非</td><td>!表达式</td></tr><tr><td>~</td><td>按位取反</td><td>~表达式</td></tr><tr><td>*</td><td>取值</td><td>*指针变量</td></tr><tr><td>&</td><td>取地址运算符</td><td>&变量名</td></tr><tr><td>++</td><td>自增</td><td>++变量名或变量名++</td></tr><tr><td>--</td><td>自减</td><td>--变量名或变量名--</td></tr><tr><td rowspan="3">3</td><td>*</td><td>乘</td><td>表达式*表达式</td><td rowspan="3">双目运算符</td><td rowspan="3">从左到右</td></tr><tr><td>/</td><td>除</td><td>表达式/表达式</td></tr><tr><td>%</td><td>求余</td><td>表达式%表达式</td></tr><tr><td rowspan="2">4</td><td>+</td><td>加</td><td>表达式+表达式</td><td rowspan="2">双目运算符</td><td rowspan="2">从左到右</td></tr><tr><td>-</td><td>减</td><td>a-b</td></tr><tr><td rowspan="2">5</td><td>&lt;&lt;</td><td>左移</td><td>变量&lt;&lt;表达式</td><td rowspan="2">双目运算符</td><td rowspan="2">从左到右</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td></tr><tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=</td><td>关系运算(大于，大于等于，小于，小于等于)</td><td>a&lt;b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>7</td><td>==、!=</td><td>是否等于</td><td>if(a==b)</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>8</td><td>&</td><td>按位与</td><td>a&b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>9</td><td>^</td><td>按位异或</td><td>a^b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>10</td><td>|</td><td>按位或</td><td>a|b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>11</td><td>&&</td><td>逻辑与</td><td>a&&b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>12</td><td>||</td><td>逻辑或</td><td>a||b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>13</td><td>?&nbsp;:</td><td>条件运算</td><td>a>b?true:false</td><td>三目运算符</td><td><span class="tips">从右到左</span></td></tr><tr><td rowspan="2">14</td><td>=</td><td>赋值运算</td><td>a=10</td><td rowspan="2">双目运算符</td><td rowspan="2"><span class="tips">从右到左</span></td></tr><tr><td>+=、-=、*=、/=、%=、>>=、<<=、&=、^=、|=</td><td>运算后赋值</td><td>a+=10</td></tr><tr><td>15</td><td>,</td><td>逗号运算符(按顺序求值)</td><td>a,b,c</td><td></td><td>从左到右</td></tr></tbody></table></div><h4 id="赋值与复合赋值"><a href="#赋值与复合赋值" class="headerlink" title="赋值与复合赋值"></a>赋值与复合赋值</h4><p>静态变量和全局变量的赋值在编译阶段进行，而局部自动变量的赋值在程序运行到该语句时进行。赋值语句遵循<span class="tips">右结合</span>原则(从右向左运算)</p><div class="show">1. 赋值遵循右结合int a,b,c;a=b=c=0;执行过程为a=(b=(c=0))2. 复合赋值n*=m+1;等价于n=n*(m+1)3. 复合赋值会即时修改变量值int a=3;a+=a-=a*a;//执行完a=-12a+=a-=a*=a;//执行完a=0</div><p>赋值语句需要注意：将字节数长的数据赋值给字节数短的变量，会截取部分数据，也可能造成整个数据错误</p><ul><li>浮点型(float、double)数据赋值给整型变量，将舍弃小数部分</li><li>将double数据赋值给float变量，将截取前7位有效数字</li><li>将int、short、long型数据赋值给char变量，只截取该数据的低8位到char变量中</li><li>将unsigned 数据赋值给有符号整型时，进行高位补0即可，但如果该unsigned 数据的数值超出了有符号整型最大值范围时，会产生数据错误!</li></ul><p>将字节数短的数据赋值给字节数长的变量，一般需要进行位拓展</p><ul><li>将整型数据赋值给浮点型变量，数值不变，拓展小数部分为0以浮点数形式进行存储</li><li>将float数据赋值给double，数值不变，拓展有效位数</li><li>将char数据赋值给整型变量，将char的1个字节数据存储到低8位，如果该整型变量为无符号整型(unsigned)，则高8位补0。如果该整型变量为有符号整型，且该char字符最高位为0，则高8位补0，若char字符最高位为1，则高8位补1，以保证char对应的数值不变</li><li>将带符号的int赋值给long型变量，将int的值存入long的低16位，如果int为正整数(最高位为0)，则long的高16位补0，反之补1</li></ul><h4 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减"></a>自增与自减</h4><p>用于对变量进行加1或减1操作，自增和自减运算符都属于一元运算符，只需要一个操作数，且<span class="tips">操作数必须是变量，不能是常量或表达式</span>。自增与自减运算符分为前缀(如++i)和后缀(i++)形式。区别在于前缀是先对变量进行加1操作，再使用变量。后缀形式是先使用变量的当前值，再进行加1操作，自减运算符同理。</p><div class="show">-i++;//应当解析为-(i++)，而非(-i)++，因为自增运算符操作数不能为表达式-i，(-i)++是非法语句i+++j;//应当解析为(i++)+j，C编译系统会从左至右尽可能多地将若干个字符组成一个运算符</div><h4 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h4><p><span class="strong">表达式1,表达式2,…表达式n</span><br>用于串联多个表达式，表达式从左至右顺序运算，<span class="tips">整个逗号表达式的值是最后一个表达式的值</span><span class="tips"></span>。多数情况下，逗号表达式仅用来顺序求值，并不一定用到整个逗号表达式的最终值。常见的情况是用于for语句进行多个变量的顺序运算，<span class="tips">逗号表达式的运算优先级是所有运算种最低的</span>。</p><div class="show">a=2*5,a*4;//逗号表达式运算优先级最低，所以a=10，整个逗号表达式值等于40b=(a=2*5,a*4);//正确获得逗号表达式值的方法，运算结果：a=10,b=40(a=3*5,a*4),a+5;//逗号表达式也可以嵌套到其他的逗号表达式中，运算结果：a=15，逗号表达式=20for(i=0,j=0;i&lt;array.length,j&lt;i;i++,j++);//逗号表达式常用于for语句多变量运算printf("%d,%d,%d",a,b,c);//逗号用于间隔函数参数,并不是逗号表达式printf("%d,%d,%d",(a,b,c),b,c);//(a,b,c)是逗号表达式，输出值为c的值</div><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>位运算是直接对二进制位进行运算，<span class="tips">只能用于整型或字符型数据</span>，不能用于浮点型，位运算符常用于编写系统软件。对于需要两个操作数的位运算，如果给的两个操作数长度不同，则系统将给较短的操作数高位补0或1，以保证两个操作数长度相同。如果该数是无符号数或者正数，则高位补0，如果为负数则高位补1。</p><h6 id="取反"><a href="#取反" class="headerlink" title="取反~"></a>取反~</h6><p>取反运算为单目运算符，用于将二进制数按位取反,eg:~12=-13</p><h6 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与&amp;"></a>按位与&amp;</h6><p>对两个数的二进制码进行按位与，该运算有一些特殊用途：</p><ul><li>数据清零，使之与0相与即可将所有二进制位置为0</li><li>保留或截取一个数中的某些指定位</li></ul><div class="show">1. 正数取原码相与，负数取其补码相与3&5=1   0000 0011   0000 0101 ------------   0000 0001  2. 若要保留一个数的低4位，将其与0000 1111相与  1100 1011  0000 1111 -----------  0000 1011 </div><h6 id="按位或"><a href="#按位或" class="headerlink" title="按位或|"></a>按位或|</h6><p>可用于将指定的二进制位置为1</p><h6 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或^"></a>按位异或^</h6><ul><li>使指定二进制位翻转</li><li>交换两个值，不使用临时变量</li><li>一个数与0相^，保留原值</li><li>一个数同本身相^，结果为0</li></ul><div class="show">1.使0100 1011的低四位翻转，可以与0000 1111相异或0100 10110000 1111----------0100 01002. 异或可以交换两个值，且不使用临时变量eg:a=3,b=4;交换a与b的值，可以使用：a=a^b;b=b^a;a=a^b;解析：由上述语句1,2可得：b=b^a=b^(a^b)=a^b^b=a^0=a;即b获得了a的值由语句3可得：a=(a^b)^(a^b^b)=a^a^b^b^b=b;</div><h6 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符&lt;&lt;"></a>左移运算符&lt;&lt;</h6><p>将一个数的二进制位左移若干位，高位溢出部分舍弃，低位补0。一个数左移n位，如果左边被舍弃的部分全为0，则该数相当于乘以2<sup>n</sup></p><div class="show">int result = 30&lt;&lt;2;//result=120</div><h6 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符&gt;&gt;"></a>右移运算符&gt;&gt;</h6><p>将一个数的二进制位右移若干位，低位溢出部分舍弃，高位补的值取决于该数值本身。如果是无符号数，或者该数符号位为0(该数为正)，则高位补0，如果该数为负数，高位补0还是补1取决于编译器，补0称为”逻辑右移”，补1称为”算术右移”。</p><p>同理，如果右边移除部分均为0，则右移n位相当于该数除以2<sup>n</sup></p><h6 id="位运算赋值运算符"><a href="#位运算赋值运算符" class="headerlink" title="位运算赋值运算符"></a>位运算赋值运算符</h6><p>位运算和赋值运算可以组成复合赋值运算符，如：&amp;=、|=、&lt;&lt;=、&gt;&gt;=、^=等</p><div class="show">a&lt;&lt;=2等价于a=a&lt;&lt;2</div><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>注意，关系运算符的优先级<span class="tips">低于</span>算术运算符，<span class="tips">高于</span>赋值运算符，且关系运算符中<span class="tips">&lt;</span>、<span class="tips">&lt;=</span>、<span class="tips">&gt;</span>、<span class="tips">&gt;=</span>的优先级是高于<span class="tips">==</span>、<span class="tips">!=</span>的</p><div class="show">c&lt;a+b等价于c&lt;(a+b)a=b&gt;c等价于a=(b&gt;c)a==b&lt;c应当等价于a==(a&lt;c)</div><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>逻辑运算符中优先级顺序为<span class="tips">!高于&amp;&amp;高于||</span>，且&amp;&amp;和||有<span class="tips">短路特性</span></p><p>C语言中没有逻辑常量true和false，编译器在表示逻辑时使用1代表真，0代表假，在表示数值时，以非0代表真，0代表假</p><div class="show">优先计算!，再计算&&，最后计算||!a&&b||x>y&&c</div><h4 id="条件运算-三元表达式"><a href="#条件运算-三元表达式" class="headerlink" title="条件运算(三元表达式)"></a>条件运算(三元表达式)</h4><p><span class="strong">条件判断语句?表达式1:表达式2</span><br>先求解条件判断语句，若为真则执行表达式1，整个条件表达式的值<br>为表达式1的值，否则执行表达式2并作为条件表达式的值</p><div class="show">1. 条件运算符优先级高于赋值max=a>b?a:b;等价于max=(a>b?a:b);2. 条件运算符结合方向为从右至左a>b?c:d>e?f:g;等价于a>b?c:(d>e?f:g)</div><h3 id="选择与循环控制"><a href="#选择与循环控制" class="headerlink" title="选择与循环控制"></a>选择与循环控制</h3><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><p><span class="tips">if()..else</span>、<span class="tips">while()</span>、<span class="tips">do…while()</span>、<span class="tips">for</span></p><h5 id="switch多分支选择"><a href="#switch多分支选择" class="headerlink" title="switch多分支选择"></a>switch多分支选择</h5><div class="apiBox">switch(表达式)  {    case 常量表达式:语句1    case 常量表达式:语句2    ....    default:       语句n}</div><ul><li>case语句只起语句标号的作用，并不是在该处进行条件判断</li><li>switch语句表达式的值找到匹配的case入口标号后，会一直执行下去，不再进行判断，直到执行完或遇到break语句</li></ul><div class="show">1.满足匹配条件后，将依次执行后面的所有case语句，所以需要及时break。并且由于是依次执行，所以case后面是多个语句也不需要使用{ }括起来switch(num)  {    case 1:printf("get 1");//如果num=1，则将输出get1、get2    case 2:printf("get 2");break;    case 3:{printf("get 3");break;}//可以不使用{ }    default:printf("error\n");}2. 多个分支可以共用一个执行语句switch(num)  {    case 1:    case 2:    case 3:printf("down");break;    default:printf("error\n");}</div><h5 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h5><p>break用于终止循环和跳出switch，只能用于循环语句和switch语句。continue用于结束本次循环，代码将继续下一次循环判定。使用goto语句的形成的循环体不能使用这两个语句跳出循环。</p><div class="show">while(i&lt;10){    if(i==5) break;    .....    i++;}while(i&lt;10){     i++;    if(i==5) continue;    .....}</div><h5 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h5><p>goto语句为无条件转向语句，语法为：</p><div class="apiBox">goto 语句标号;</div><p>语句标号用标识符表示，命名规则同变量，常用于组成循环，或者从循环内部跳出循环，但会导致程序可读性差，结构混乱，应当谨慎使用。</p><div class="show">int i,sum;i=sum=0;loop:if(i&lt;10){    sum+=i;    i++;    goto loop;}</div><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>谭浩强书的主函数一般写为void man()，但C语言标准(C99)定义的标准main函数写法为</p><div class="apiBox">int main(void){    .....return 0; }或者int main(int argc,char argv[]){.....return 0;}</div><div class="show">在C语言中int main()表示主函数可以传入任意个数的参数，而int main(void)表示该函数参数为空，不能传入任何参数在C++中，int main()和int main(void)等效</div><h4 id="标准输入输出函数"><a href="#标准输入输出函数" class="headerlink" title="标准输入输出函数"></a>标准输入输出函数</h4><p>C语言本身不提供输入输出语句，输入输出操作由C函数库中的函数提供支持。这是因为输入输出涉及到硬件操作，没有输入输出语句可以让C语言编译器避免在编译阶段处理硬件有关的问题，可以极大地简化编译系统，并提高其通用性和可移植性。</p><p>C函数库由各软件公司编写，并已经编译成目标文件(.obj文件)，源程序中的printf()等语句在编译阶段并不会被编译为目标指令，而是等待链接阶段源程序和库函数链接后，在执行阶段直接调用库函数目标文件(.obj文件)中的printf()函数。不同函数库提供的函数名、功能完全不同，但有一些通用的”标准输入输出函数”，调用这些函数需要引入头文件<span class="tips">#inculde&lt;stdio.h&gt;</span></p><h5 id="printf输出函数"><a href="#printf输出函数" class="headerlink" title="printf输出函数"></a>printf输出函数</h5><p>标准输出语句格式为：</p><div class="apiBox">printf("格式控制",输出表列)</div><p>输出表列即需要输出的数据，多个输出的数据使用<span class="tips">,</span>分隔，可以为表达式；格式控制需要使用双引号括起来，可以包括两种信息</p><ul><li>普通字符：printf会原样输出普通字符，包括空格、换行符等</li><li>格式字符：由%和格式字符组成，用于指定输出数据的格式</li></ul><div class="show">用于输出整型、浮点型、指数的格式字符:1.<span class="tips">%d或%i</span>，用于输出int类型(-32768~32767之间)的十进制整数2.<span class="tips">%ld</span>，输出长整型。%hd输出short类型，%I64d输出long long类型3.<span class="tips">%md</span>,m用于指定宽度，若数据位数大于m则将原数据正常输出，小于m则左补空格<code>eg: a=12345,b=123printf("%4d,%4d",a,b);//输出12345, 123(123前补个空格)</code>4.<span class="tips">%o,%x,%X</span>，以八进制、十六进制(字母小写)、十六进制(字母大写)形式输出整型(不输出前导符0和0x)，该输出方式会将符号位也作为八进制和十六进制的数值位输出，因此无法输出负数，输出时支持指定输出位数。同样,八进制和十六进制支持用<span class="tips">l</span>(long)、<span class="tips">h</span>(short)、<span class="tips">m</span>(输出位宽)修饰5.<span class="tips">%u</span>，输出无符号(unsigned)整型，%lu输出unsigned long类型6.<span class="tips">%c</span>，输出一个字符，支持将0~255内的整数输出为ASCII码对应字符，也支持将这些字符输出为整数7.<span class="tips">%s</span>，输出字符串<ul style="white-space: normal;"><li><span class="strong">%ms</span>，指定输出的字符个数，若字符串串长大于m则原样输出字符串，若小于m则左补空格</li><li><span class="strong">%-ms</span>，同上，但是右补空格</li><li><span class="strong">%m.ns</span>，输出m个字符，但只取字符串左端n个字符，右对齐，左补空格</li><li><span class="strong">%-m.ns</span>，同上，但左对齐，右补空格</li></ul><code>eg：printf("%5.2s","china");//输出   ch(左补3个空格)printf("%4.2s","china");//输出  ch(右补2个空格)printf("%-5.2s","china");//输出ch   (右补3个空格)</code>8.<span class="tips">%f</span>，输出浮点数(包括单、双精度)，输出全部整数部分，并输出6位小数。单精度浮点数有效位数一般为7位，双精度浮点数有效位数一般为16位，给出小数6位。<ul style="white-space: normal;"><li><span class="strong">%m.nf</span>，输出m列(小数点算一列)，其中保留有n位小数(四舍五入)，左补空格</li><li><span class="strong">%-m.nf</span>，同上，但左对齐，右补空格</li><li><span class="strong">%.nf</span>，省略m，即输出所有整数部分，保留n位小数</li></ul><code>eg：float a=123.456printf("%f",a);//输出123.456001，输出6位小数，有一定存储误差printf("%8.2f",a);//输出  123.46，左补2个空格，保留2位小数，小数四舍五入printf("%-8.2f",a);//输出123.46  ，右补2个空格printf("%.2f",a);//输出123.46，整数部分全部输出，小数部分保留2位 float x,y;x=111111.111,y=222222.222;printf("%f",x+y);//输出333333.328125，只有前7位有效</code>9. <span class="tips">%e或%E</span>，以规格化指数形式输出小数，e和E分别表示指数e的大小写形式，可以使用<span class="tips">%m.ne或%m.nE</span>形式指定输出位数和数字部分的小数位数，一般默认数字部分的小数数位为6位，指数部分为5位(如：e+002)<code>printf("%e",123.456);printf("%e",123.456);//输出1.234560e+002，默认数字部分6位小数printf("%10.2E",123.456);//输出 1.23E+002，左补1个空格，数字部分的小数保留2位，注意：小数点、e、+等字符均占用一个位置</code>10.<span class="tips">%g或%G</span>，根据数值大小自动选择使用%f或%e形式，保证输出宽度最小，不输出无意义的011.<span class="tips">%%</span>，输出%12.<span class="tips">%p</span>，以十六进制无符号整数形式输出变量或指针变量的地址<code>int num = 10;int* p;p = &num ;printf("%p\n", &num);//输出结果参考:001DFB0Cprintf("%p\n", p);</code></div><h5 id="scanf输入函数"><a href="#scanf输入函数" class="headerlink" title="scanf输入函数"></a>scanf输入函数</h5><p>标准输入语句格式为：</p><div class="apiBox">scanf("格式控制",地址表列)</div><p>格式控制与printf()函数的格式控制类似，如果格式控制中有格式说明以外的字符，则输入数据时需要在对应位置输入相同的字符；地址表列可以为变量地址、字符串首地址，通常需要用取地址符<span class="tips">&amp;</span>加以引导，多个地址参数使用<span class="tips">,</span>分隔。</p><div class="table"><table><thead><tr><th>格式输入符</th><th>说明</th></tr></thead><tbody><tr><td>%d或%i</td><td>输入有符号十进制整数</td></tr><tr><td>%I64d</td><td>输入long long类型整数</td></tr><tr><td>%u</td><td>输入无符号十进制整数</td></tr><tr><td>%o</td><td>输入无符号八进制整数</td></tr><tr><td>%x或%X</td><td>输入无符号十六进制整数</td></tr><tr><td>%c</td><td>输入一个字符，空白字符、回车、制表符也视为有效字符</td></tr><tr><td>%s</td><td>输入字符串，输入空白字符、回车、制表符会被认为输入结束，但开头输入空白字符会被系统跳过</td></tr><tr><td>%f</td><td>输入小数，可以用小数形式或指数形式</td></tr><tr><td>%e,%E,%g,%G</td><td>与%f相同，大小写作用相同</td></tr><tr><td>%%</td><td>输入一个%</td></tr></tbody></table></div><div class="table"><table><thead><tr><th>格式修饰符</th><th>说明</th></tr></thead><tbody><tr><td>l</td><td>用于输入长整型数据(%ld,%lo,%lx,%lu)和double型数据(%lf,%le)</td></tr><tr><td>h</td><td>用于输入短整型数据(%hd,%ho,%hx)</td></tr><tr><td>域宽m(正整数)</td><td>指定输入数据的宽度(列数)，系统根据此宽度自动截取数据</td></tr><tr><td>*</td><td>忽略输入修饰符，表示对应的输入项在读入后不赋给相应变量</td></tr></tbody></table></div><p>用scanf()输入数据时，遇到以下情况会被认为数据输入结束：</p><ul><li>遇到空格符、回车符、制表符(Tab)</li><li>达到输入域宽</li><li>遇到非法字符输入</li></ul><div class="show">1. 格式控制中有普通字符，则输入数据时也要输入对应字符(包括空格)scanf("a=%d,b=%d",&a,&b);//输入形式必须为a=10,b=202. 可以指定输入数据所占的列宽，系统会自动截取scanf("%3d%3d",&a,&b);//输入123456a1，则123赋值给a，456赋值给b，多余部分a1抛弃3. 可以用*跳过指定列数scanf("%d%*c%d",&a,&b);//输入123 456，则123赋值给a，456赋值给b，中间的空格符根据%*c跳过scanf("%2d%*3d%2d",&a,&b);//输入1234567，则12赋值给a，345被忽略，67赋值给b4. scanf()函数的返回值一般为正确读入数据的个数scanf("%2d%2d",&a,&b);//输入1234返回值为2scanf("%2d%2d",&a,&b);//输入12a,只给a读入了正确值，返回值为1scanf("%2d%2d",&a,&b);//输入a，返回值为0</div><h5 id="putchar-与getchar"><a href="#putchar-与getchar" class="headerlink" title="putchar()与getchar()"></a>putchar()与getchar()</h5><p>用于输入或输出一个字符，只能用于处理字符</p><ul><li><span class="strong">getchar() 输入一个字符，无参数</span></li><li><span class="strong">putchar(参数) 输出一个字符，参数可以为字符变量、整型变量，也可以为一个字符常量或转义字符</span></li></ul><div class="show">char a;a=getchar();putchar(a);putchar('a');putchar('\n');</div><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>自定义函数的定义语法为：</p><div class="apiBox">返回值类型 函数名(类型 形参1,....){        /*函数体*/}</div><ul><li>函数返回值只能有一个，返回值类型可以是除数组外的任何类型</li><li>函数无返回值时，返回值类型需要声明为<span class="strong">void</span>，可以不需要return语句，但通常会以 <span class="tips">return;</span>作为程序结束语句，表示程序正常执行结束且返回值为空，这是一种良好的编程习惯</li><li>如果函数返回值和函数定义时声明的返回值类型不同，则将以函数类型为准，系统自动进行数据转换</li><li>在定义函数时如果不指定返回值类型，系统会隐含指定为int型</li><li>函数名的命名规则与变量相同</li><li>形参(形式参数)必须指定类型，但变量名任意</li><li>形参在函数调用前，不占用存储单元，函数调用时才被分配内存，并在执行完后会被回收</li></ul><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>函数调用语法：</p><div class="apiBox">函数名(实参1,....)</div><ul><li>实参(实际参数)可以为常量，或者有确定值的变量或表达式</li><li>实参和形参的数据类型应该相同，或者<span class="tips">赋值兼容</span>(参考赋值一节的赋值规则，如字符型和整型相互通用)，但应该尽量避免使用赋值兼容</li></ul><div class="show"><code>#include&lt;stdio.h>//函数定义时不指定返回值类型，隐含为int类型//用Visual Studio编译这段代码时，会有提示warning C4013: “getMax”未定义；假设外部返回 intgetMax(int a, int b) &#123;    return a > b ? a : b;&#125;int main(void) &#123;    printf("%d", getMax(10, 20));    return 0;&#125;</code></div><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>又称<span class="strong">函数原型</span>(Function Prototype)声明，其作用是将函数名、函数类型、形参类型、个数和顺序通知编译系统，以便调用该函数时系统按此进行对照检查。函数声明语法：</p><div class="apiBox">函数类型 函数名(形参1,....)</div><ul><li>如果被调用的函数定义在主调函数之前，可以不加声明，编译器会根据函数定义时首部提供的信息对函数调用作准确性检查</li><li>如果被调用函数类型为整型，也可以不加声明</li><li>函数声明可以在文件开头(所有函数前)，也可以在主调函数中</li><li>对于形参，编译器只检查形参类型和个数，不检查参数名，因此参数名任意，也可以省略</li></ul><div class="show"><code>#include&lt;stdio.h>int main(void) &#123;    int  getMax(int, int);//原型声明    printf("%d", getMax(10, 20));    return 0;&#125;int getMax(int a, int b) &#123;    return a > b ? a : b;&#125;</code></div><h4 id="内部函数与外部函数"><a href="#内部函数与外部函数" class="headerlink" title="内部函数与外部函数"></a>内部函数与外部函数</h4><p><span class="strong">外部函数：</span>定义函数时，可以在函数返回值类型前加上<span class="text-blue">extern</span>将其定义为外部函数，extern可以省略，因此如果函数未特意声明为内部函数，则默认隐含为外部函数，即<span class="tips">C语言中，函数默认为外部函数</span>，外部函数可以被其他文件调用，只需要在要调用此函数的文件中，用extern作函数原型声明即可，其中函数原型声明前的extern也可以省略</p><p><span class="strong">内部函数：</span>又称静态函数，定义函数时在函数首部添加<span class="text-blue">static</span>修饰即可定义内部函数，内部函数作用域仅限于本文件，不能被其他文件调用，不同的文件可以有同名的内部函数，互不干扰</p><div class="show">eg:文件file1.c调用文件file2.c中的函数file1.c<code>#include&lt;stdio.h&gt;int main(void)&#123;    <span class="text-blue"> extern void getStrings(char str[]);</span>//extern可以省略，写为void getString(char str[])    <span class="text-red">static void test();</span>//调用内部函数需要static声明    char str[50];    getStrings(str);    printf("%s\n", str);    test();//调用本文件中的test()函数    return 0;&#125;<span class="text-red">static void test()</span>//内部函数，仅供本文件调用&#123;    printf("file1.c");    return;&#125;</code>file2.c<code>#include&lt;stdio.h&gt;<span class="text-blue">extern void getStrings(char str[])</span>//extern 可以省略&#123;    gets(str);&#125;<span class="text-red">static void test()</span>//内部函数，可以与file1.c中的test()函数同名&#123;    printf("file2.c");    return;&#125;</code></div><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>由此可见，声明函数原型的作用除了在调用时作准确性检查，还可以拓展函数作用域到定义本函数的文件之外，只要在所有调用该函数的文件中作一个函数原型声明即可。如：各种库提供的头文件中，就包含了大量函数及其函数原型声明，我们只需要使用#include命令将其包含到我们的c文件中，就可以不需要了解其函数和函数原型，就直接使用该函数。原型声明时extern可以省略，但我们自己编写头文件中的原型声明时应当保留extern关键字来保证代码清晰性。</div><h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><p>C语言中，类型限定符用于指定数据的访问属性。常见的类型限定符包括<span class="tips">const</span>(常量)、<span class="tips">volatile</span>(易变的)、<span class="tips">restrict</span>(限定)和<span class="tips">_Atomic</span>(原子)</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><h5 id="const修饰变量"><a href="#const修饰变量" class="headerlink" title="const修饰变量"></a>const修饰变量</h5><p>const用于限定变量的值不能被修改，表明变量中存储的值是一个常量，这类变量本质是变量，但又有常量属性，因此又称为”常变量”，const修饰的常变量必须在定义的同时赋值，而后其值就不能再改变，任何赋值行为都将引发错误。定义常变量时，const和变量类型位置可以互换，因此以下两个语句等价：</p><div class="show"><code>const int num=100;int const num=100;</code></div><p>全局常变量存储于静态存储区的.rodata段，而局部常变量存储于栈内存中。对于局部常变量，由于栈内存本身是可读写的，所以即便编译器会对const修饰的局部变量进行内存保护，防止该变量的值被修改，但我们依然可以用其他方法修改该变量的值：</p><div class="show"><code>const int num=100;int *p=&num ;*p=0;printf("%d",num);//num值被修改为0</code></div>这种通过指针来间接操作访问和操作指针所指对象值的方法称为指针解引用(dereference)，C语言标准明确指出，通过指针解引用的方式去修改一个const修饰的变量，其行为是未定义的，因此对于局部常变量，我们不应该通过该方法修改其值。对于全局常变量，数据存储于.rodata段，该段内存只有读权限，通过任何方法修改数据都会抛出写入访问权限冲突异常，在某些嵌入式系统中，全局常变量和代码会被一起存入ROM存储介质中无法修改。<h5 id="const修饰数组"><a href="#const修饰数组" class="headerlink" title="const修饰数组"></a>const修饰数组</h5><p>对于数组，由于数组名本身就代表数组起始地址，是一个地址常量，不能被任何限定符修饰，因此const修饰数组时，将用于修饰数组元素，即const修饰数组时，数组元素为常量无法修改</p><div class="show"><code>const int nums[] = &#123; 10,20,30,40,50 &#125;;<span class="text-red">nums[2] *= 10;//错误！无法修改</span></code></div><h5 id="const修饰复合类型"><a href="#const修饰复合类型" class="headerlink" title="const修饰复合类型"></a>const修饰复合类型</h5><p>const修饰结构体、枚举等复合类型时，表示该类型中的所有成员值不能被修改</p><div class="show"><code>struct test &#123;        int a;        int b;    &#125;;    const struct test num = &#123; 10,20 &#125;;或    const struct test &#123;        int a;        int b;    &#125; num = &#123;10,20&#125;;或struct test &#123;        int a;        int b;    &#125; const num = &#123;10,20&#125;;初始化完毕成员变量值不能再被修改<span class="text-red">num.a=100;//错误！不能修改成员值</span></code></div><h5 id="指针与const类型限定符"><a href="#指针与const类型限定符" class="headerlink" title="指针与const类型限定符"></a>指针与const类型限定符</h5><p>指针常用来在函数间传递数据，方便调用者直接对数据进行操作，但有时我们只希望将数据传到函数内部，而不希望它们在函数内被修改，此时，我们可以使用<span class="tips">const</span>对参数进行限定</p><div class="show">const位于声明语句的不同位置，将表示不同的含义，以int类型为例：<code>int a,b;</code>1. const放在类型关键字前面<span class="text-blue">const int * p=&a;</span>按从右到左解析为：p是一个指针变量，可指向一个整型常量，*p是一个常量，而p不是。即*p的值是不可修改的，无法用*p=10;等方式重新赋值，但指针变量p的指向是可以被修改的，即p=&b是允许的2. const位于类型关键字后*变量名前<span class="text-blue">int const *p=&a;</span>按从右到左解析为：p是一个指针常量，可以指向一个常量整数，同样*p是一个常量，而p不是，不能用指针变量p去修改这个"为常量的整数"，与第一种情况作用相同3. const位于*后，变量名前<span class="text-blue">int * const p=&a;</span>按从右到左解析为：p是一个指针常量，可以指向一个整型数据，它表明p是一个常量，而*p不是。由于p是常量指针，因此不能修改p的指向，p=&b操作是非法的，但*p=20是合法的4. 两个const修饰，一个位于类型关键字前，一个位于*后<span class="text-blue">const int * const p=&a;</span>按从右到左解析为：p是一个指针常量，可指向一个整型常量，它表明p和*p都是常量，是只读的，*p=20和p=&b操作都是非法的上述四种用法中，第一种用法较为常用，C语言很多库函数都使用该方法，只允许函数访问该指针指向的内容，不允许修改其内容，如：<code>int puts(const char * str);int printf(const char * format , ...);</code></div><p>对于被const限制的指针变量，不能将普通指针变量赋值给被限制的指针变量，但反过来可以，如：<span class="tips">const char *</span>和<span class="tips">char *</span>是不同的类型，const char *指向的数据只有读取权限，而char *指向的数据有读写权限，因此不能将const char *赋值给char *，但可以将char *类型的数据赋值给const char *类型的变量</p><div class="show">C语言函数库中很多函数参数都被const限制了，但我们仍然可以将非const类型的数据传递给const类型的形参，如对于函数原型int puts(const char * str);可以直接传递非const类型的数据char * str="Hello";puts(str);</div><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile用于声明变量的值是易变的，每次用到该变量的值时都需要去内存中重新读取这个变量的值，而不是读取其在寄存器中的备份。在多线程环境下，volatile 表示变量可能会被多个同时执行的线程修改，存取时无需额外的内存保护，并且防止优化编译器把变量从内存装入寄存器中，因为如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，造成程序的错误执行，volatile的声明方式为：</p><div class="show"><code>volatile int counter;</code></div><h4 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h4><p>restrict是C99标准新增的限定符，该限定符只能用于指针变量，其作用是程序员通过该限定符告知编译器，restrict修饰的指针独占其所指向的内存，所有对该内存的操作都将基于该指针，而不再会有其他任何变量或指针操作该内存，以便让编译器进行一些针对性的优化。这种优化是针对特殊使用场景的，因此可能出现没有任何优化的情况，并且由于restrict指针独占是由程序员来判断并加以限定的，可能会出现误判的情况，因此，restrict一般用于非常需要性能优化，并且已经确认两个指针不会指向同一内存的场景，其定义语法为：</p><div class="show"><code>int * restrict a;</code>eg:业务上明确得知，某个malloc开辟的空间，只会通过mySpace指针变量进行操作，则可以使用restrict限定符告知编译器，由其进行优化<code>int * restrict mySpace=(int *)malloc(10*sizeof(int));</code></div><h4 id="Atomic"><a href="#Atomic" class="headerlink" title="_Atomic"></a>_Atomic</h4><p>_Atomic是C11标准引入的限定符，用于指定原子类型，提供原子性操作。原子操作是指对原子对象的操作是不可被打断的，该操作一旦执行，不会被其他线程或者事件中断，直到操作执行完毕。默认的声明方式为：</p><div class="show"><code>_Atomic int x=0;</code></div><p>但在实际使用时，应该使用<span class="text-blue">&lt;stdatomic.h&gt;</span>头文件中已经定义好的原子类型，该头文件还定义了相关的原子操作函数</p><div class="show">一些stdatomic.h头文件定义的原子类型和原子操作举例<code>typedef _Atomic int atomic_int;typedef _Atomic char atomic_char;...atomic_init(volatile A* obj, C desired )初始化原子类型变量....</code>eg:定义一个原子类型变量并初始化<code>#include &lt;stdio.h>#include &lt;stdatomic.h>int main(void)&#123;    atomic_int a;    atomic_init(&a,10);    return 0;&#125;</code></div><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>动态内存分配函数在堆上分配内存，使用前需要包含<span class="tips">&lt;stdlib.h&gt;</span>头文件</p><h4 id="内存空间申请与释放"><a href="#内存空间申请与释放" class="headerlink" title="内存空间申请与释放"></a>内存空间申请与释放</h4><ul><li><span class="strong">void *malloc(unsigned int size);</span></li></ul><p>分配长为size字节的内存空间，返回该内存首地址，若无足够内存单元，则返回空指针NULL</p><div class="show"><code>int *p=(int *)malloc(4*sizeof(int))</code></div><ul><li><span class="strong">void *calloc(unsigned int num,unsigned int size);</span></li></ul><p>用于给同一类型的数据分配连续的内存空间并赋值为0(数值型)或空(字符型)。它相对于声明了一个一维数组，并且会初始化该数组值为0或空，参数num为所需申请的内存空间数量，相对于数组长度，参数size为每个内存空间的字节数，相对于数组基类型的字节长度。若申请成功，返回该内存空间的首地址，否则返回空指针NULL</p><div class="show"><code>int * p=(int *)calloc(10,sizeof(int));相对于int * p=(int *)malloc(10*sizeof(int));但calloc()会将分配的内存自动初始化为0或空，更为安全</code></div><ul><li><span class="strong">void *realloc(void *p,unsigned int size);</span></li></ul><p>用于改变原来分配的内存，将p所指向的存储空间大小改为size个字节，返回值是新分配的内存空间首地址，与原来分配的首地址不一定相同</p><ul><li> <span class="strong">void free(void *p);</span></li></ul><p>用于释放所申请的内存空间，即p所指向的空间，其中p只能是由malloc()和calloc()申请的内存地址</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="二进制文件与文本文件"><a href="#二进制文件与文本文件" class="headerlink" title="二进制文件与文本文件"></a>二进制文件与文本文件</h4><p>C语言文件有两种类型：<span class="text-blue">文本文件</span>(也称ASCII码文件)和<span class="text-blue">二进制文件</span>。二者的区别在于存储数值型数据的方式不同。二进制文件中，数值型数据是将整个数值转码为二进制形式存储；而在文本文件中，数值型数据的每一位数字作为一个字符以其ASCII码形式存储，每个数字都单独占用一个字节的存储空间。如：对于short int n=123，二进制文件中，变量n为short类型仅占用2个字节存储空间，而在文本文件中占用3个字节存储空间。</p><p>二进制文件和文本文件各有优缺点。文本文件可以很方便被其他程序读取，包括文本编辑器、Office办公软件等，且输出内容与字符一一对应，一个字节表示一个字符，便于对字符逐个处理，便于输出字符，但一般占用的存储空间较大，且ASCII码和字符转换需要花费一定时间。二进制文件可以节省空间和转换时间，但不方便其他程序读取，不能直接输出其字符形式。</p><p>无论文件内容是什么形式，C语言一律将数据看成由字节构成的序列，即<span class="text-blue">字节流</span>，对文件的存取也是以字节为单位进行的，输入、输出的数据仅受程序控制而不受物理符号(如回车换行符)控制，因此，C语言文件又称为流式文件。</p><p>C语言文件系统分为<span class="text-blue">缓冲型</span>和<span class="text-blue">非缓冲型</span>，缓冲型文件系统是指系统自动为每一个正在使用的文件在内存中开辟一个输入/输出文件缓冲区，作为程序和文件之间数据交换的缓冲区域。在读文件时，数据先从磁盘送到缓冲区，再传给C语言程序；在写文件时，数据从C语言程序送到缓冲区，装满缓冲区后再输出到磁盘。缓冲文件系统利用<span class="text-red">文件指针</span>标识文件，不同版本的C语言缓冲区大小不一样，一般为512字节。而非缓冲文件系统不会自动数值文件缓冲区，缓冲区必须由程序员自己设定，它使用称为文件号的整数来标识文件。</p><p>在UNIX系统中，缓冲文件系统用来处理文本文件，用非缓冲文件系统来处理二进制文件。用缓冲文件系统进行输入输出的操作又称为高级文件操作，用非缓冲文件系统来处理输入输出的操作又称为低级输入输出操作。ANSI C标准规定只采用缓冲文件系统，即既用缓冲文件系统处理文本文件，也用它处理二进制文件，因此下文主要为高级文件操作函数。</p><h4 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h4><p>缓冲文件系统中，系统为每个正在使用的文件在内存中开辟了一个缓冲区，用来存放文件的有关信息(如：文件名、文件句柄、文件状态、文件路径等)，这些信息保存在一个结构体变量中，该结构体类型由系统定义，名为<span class="text-red">FILE</span>，stdio.h文件中有该文件类型声明：</p><div class="show"><code>typedef struct&#123;   short level;    //缓冲区"满"或"空"的程度    unsigned flags;//文件状态标志    char fd;      //文件描述符    unsigned char hold;//如果无缓冲区不读取字符    short bsize;//缓冲区大小    unsigned char *buffer;//数据缓冲区位置    unsigned ar *curp;//指针当前指向    unsigned istemp;//临时文件指示器    short token;//用于有效性检查&#125;FILE;</code></div><p>由此，我们可以定义一个文件类型的指针变量：<span class="text-red">FILE *fp</span>，然后将该指针指向一个文件的结构体变量，从而通过该指针访问该结构体变量中的文件信息，并通过这些信息访问该文件。</p><h4 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h4><h5 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h5><p>函数fopen()用于打开文件，其函数原型如下：</p><div class="apiBox">FILE * fopen(const char * filename,const char * mode)</div><p>该函数返回一个文件类型的指针，如果文件打开失败，则返回一个空指针NULL(NULL在stdio.h文件中被定义为0)。fopen()有两个形参，第一个形参filename表示文件名，可以包含<span class="strong">文件路径和文件名</span>两部分，第二个形参mode表示文件的打开方式，取值如下所示：</p><div class="table"><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>以<span class="text-yellow">只读方式</span>打开<span class="text-blue">文本文件</span>，只能读出而不能写入数据，若文件不存在，则报错</td></tr><tr><td>w</td><td>以<span class="text-yellow">只写方式</span>(新建形式)，创建并打开<span class="text-blue">文本文件</span>，无论文件是否存在，都会创建一个新的文本文件，只能写入数据，已经存在的文件将被覆盖</td></tr><tr><td>a</td><td>以<span class="text-yellow">只写方式</span>(追加形式)，打开<span class="text-blue">文本文件</span>，位置指针移到文件末尾，向文件尾部添加新数据，若文件不存在，则会新建一个文件</td></tr><tr><td>b</td><td>与上面的字符串组合，表示打开二进制文件</td></tr><tr><td>rb</td><td>以<span class="text-yellow">只读方式</span>打开<span class="text-red">二进制文件</span></td></tr><tr><td>wb</td><td>以<span class="text-yellow">只写方式</span>打开<span class="text-red">二进制文件</span></td></tr><tr><td>ab</td><td>以<span class="text-yellow">只写方式</span>向<span class="text-red">二进制文件</span>末尾添加数据</td></tr><tr><td>+</td><td>与上面的字符串组合，表示以读写方式打开文本文件，既可以向文件中写入数据，也可以从文件中读取数据</td></tr><tr><td>r+</td><td>以<span class="text-green">可读可写</span>的方式打开<span class="text-blue">文本文件</span></td></tr><tr><td>w+</td><td>以<span class="text-green">可读可写</span>方式创建一个新的<span class="text-blue">文本文件</span></td></tr><tr><td>a+</td><td>以<span class="text-green">可读可写</span>方式向<span class="text-blue">文本文件</span>末尾追加数据</td></tr><tr><td>rb+</td><td>以<span class="text-green">可读可写</span>的方式打开<span class="text-red">二进制文件</span></td></tr><tr><td>wb+</td><td>以<span class="text-green">可读可写</span>方式创建一个新的<span class="text-red">二进制文件</span></td></tr><tr><td>ab+</td><td>以<span class="text-green">可读可写</span>方式向<span class="text-red">二进制文件</span>末尾追加数据</td></tr></tbody></table></div><p>注意：</p><ul><li>有的C语言编译系统可能不完全提供上述功能，如：有的C语言编译器不支持r+、w+、a+</li><li>输入文本文件时，内容中的回车换行符会被转换为一个换行符，在输出时，则会将换行符转换为回车和换行两个字符。而在输入输出二进制文件时，不会进行这种转换，文件中的数据与内存中的数据完全一致，一一对应</li></ul><h5 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose()函数"></a>fclose()函数</h5><p>函数fclose()用来关闭一个由函数fopen()打开的文件，其函数原型如下：</p><div class="apiBox">int fclose(FILE *fp);</div><p>函数返回一个整型值，当文件成功关闭时，返回0值，否则返回一个非0值(一般为EOF -1)，可用于判断文件是否关闭成功。当使用fclose()关闭文件后，指针fp将不再指向该文件。</p><p>由于操作系统对于同时打开的文件数目是有限制的，所以文件使用结束后必须关闭文件。此外，不建议使用读写方式打开文件，因为读写共用一个缓冲区，每次读写都会改变文件位置指针，很容易写乱，破坏文件内容，并且需要调用文件定位函数才能在读写之间切换。</p><div class="show"><code>FILE * fp;fp=fopen("D:\\demo.text","a+");fclose(fp);</code></div><h4 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h4><h5 id="按字符读写"><a href="#按字符读写" class="headerlink" title="按字符读写"></a>按字符读写</h5><ul><li><span class="strong">int fgetc(FILE *fp)</span> 从fp所指向文件读取一个字符，并使位置指针指向下一个字符。如果读取成功，则返回该字符，若读取到文件末尾，则返回EOF(stdio定义为-1)</li><li><span class="strong">int fputc(int c,FILE *fp)</span> 将字符c(尽管c定义为int型，但只写入低字节)写到文件指针fp所指向的文件中。若写入错误，则返回EOF，否则返回字符c</li></ul><div class="show">在读入文本文件时，可通过fgetc()函数的返回值来判断是否读取到了文件末尾(文件是否读取完毕)，当读入的字符值等于-1(即EOF)时，说明文件已经读取完毕。但在读入二进制文件时，读入的数据可能刚好为-1(EOF)，此时就需要使用feof()函数判断当前文件是否读取完毕。如果文件结束，则feof(fp)的值为1(真)，否则为0(假)eg:从键盘输入字符，并将这些字符存储到磁盘文件中，直到输入"#"为止<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123;    FILE *fp;    char ch,filename[10];    scanf("%s",filename);//输入文件名    if((fp=fopen(filename,"w"))==NULL)&#123;        printf("文件打开失败\n");        exit(0);    &#125;    ch=getchar();//接收执行scanf语句时输入的回车符    ch=getchar();    while(ch!='#')    &#123;        <span class="text-blue">fputc(ch,fp);</span>        ch=getchar();    &#125;    fclose(fp);        return 0;&#125;</code>eg:从当前路径文件夹下读取名为"myTest.txt"的文件，并将内容输出到控制台<code>int main(void) &#123;    FILE* fp;    char ch;    if ((fp = fopen("myTest.txt", "r")) == NULL) &#123;        printf("文件打开失败！\n");        exit(0);    &#125;    while (<span class="text-red">!feof(fp)</span>) &#123;        ch = fgetc(fp);        putchar(ch);    &#125;    return 0;&#125;</code></div><h5 id="按字符串读写"><a href="#按字符串读写" class="headerlink" title="按字符串读写"></a>按字符串读写</h5><ul><li><span class="strong">char * fgets(char *s,int n,FILE *fp)</span> 从fp所指向文件中读取最多含n-1个字符的字符串，并在字符串末尾添加’\0’，然后存入s。当读取到回车换行符、到达文件末尾或者读满n-1个字符时，函数返回该字符串的首地址，即指针s的值；读取失败时返回空指针NULL</li><li><span class="strong">int fputs(const char *s,FILE * fp)</span> 将字符串s写入文件fp，若写入错误，则返回EOF(-1)，否则返回一个非负数</li></ul><div class="show">eg:从键盘输入一个字符串，追加到文件末尾<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123;    FILE * fp;    char str[20];    if((fp=fopen("demo.txt","a"))==NULL)&#123;        printf("Failure to open file!\n");        exit(0);    &#125;    gets(str);    fputs(str,fp);    fclose(fp);    if((fp=fopen("demo.txt","r"))==NULL)&#123;        printf("Failure to open file!\n");        exit(0);    &#125;    fgets(str,20,fp);    puts(str);    fclose(fp);    return 0;&#125;</code></div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>这两个函数与puts()和gets()类似，区别在于，gets()函数从输入缓冲区读取字符串时，会将回车符也从缓冲区读走，但不作为字符串的一部分，而fgets()函数读到换行符时会将换行符作为字符串的一部分读到字符串中来。输出时，puts()函数在向终端输出字符串时，会在字符串输出结束后，自动输出一个换行符，而fputs()函数不会在字符串末尾加上换行符。</div><h5 id="按格式读写文件"><a href="#按格式读写文件" class="headerlink" title="按格式读写文件"></a>按格式读写文件</h5><ul><li><span class="strong">int fscanf(FILE *fp,格式字符串,输入表列地址)</span>从指定文件按格式读取数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为输入变量的地址表列</li><li><span class="strong">int fprintf(FILE *fp,格式字符串,输出表列)</span>按指定格式向文件写入数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为要写入的变量</li></ul><p>用函数fscanf()和fprintf()进行文件的格式化读写，读写方便，容易理解，但输入时要将ASCII字符转换为二进制数，输出时要将二进制数转换为ASCII字符，耗时较多。因此，内存和磁盘进行频繁数据交换时，应当尽量避免使用这两个函数，而用fread()和fwrite()函数</p><div class="show"><code>int i=10;float j=4.5;fprintf(fp,"%d,%6.2f",i,j);//保存为10,  4.50fscanf(fp,"%d,%f",&i,&j);//假设文件内容为10,4.5，则i赋值为10，j赋值为4.5</code></div><h5 id="按数据块读写文件"><a href="#按数据块读写文件" class="headerlink" title="按数据块读写文件"></a>按数据块读写文件</h5><ul><li><span class="strong">unsigned int fread(void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 从fp所指的文件读取数据块并存储到buffer所指向的内存。buffer是待存入数据块的起始地址，可以是数组起始地址、结构体变量起始地址等，size是每个数据块的大小，count是最多允许读取的数据块个数，函数返回的是实际读取到的数据块个数</li><li><span class="strong">unsigned int fwrite(const void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 将buffer所指内存中的数据块写入fp所指的文件。同样，buffer是待读出数据块的起始地址，size是每个数据块的大小，count是最多允许写入的数据块个数，函数返回的是实际写入的数据块个数<br>块数据读写允许用户以数组、结构体等数据类型整块读写，不再局限于一次只读写一个字符或字符串，可以指定想要读写的内存块大小，最小为1字节，最大可以为整个文件</li></ul><div class="show">eg:整块读写数组内容<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void) &#123;    int nums[] = &#123; 11,22,33,44,55,66,77,88,99 &#125;;    int numsRead[9];    FILE* fp;    if ((fp = fopen("data.txt", "w")) == NULL) &#123;        printf("文件打开失败!");        exit(0);    &#125;    <span class="text-blue">fwrite(nums, 4, sizeof(nums)/4, fp);</span>//将数组nums到文件fp中，数组为int类型，数据块为4Bytes，需要写入9个数据块    fclose(fp);    if ((fp = fopen("data.txt", "r")) == NULL) &#123;        printf("文件打开失败!");        exit(0);    &#125;    <span class="text-red">fread(numsRead, 4, 9, fp);</span>//从fp文件中读取9个4Bytes的数据块，并存储到numsRead数组中    for (int i = 0; i < 9; i++) &#123;        printf("%4d", numsRead[i]);    &#125;    fclose(fp);    return 0;&#125;</code></div><p>eg:按块文件读写结构体变量，输入每个学生的信息并保存到studentData.txt文件中，并添加从该文件中读出学生信息并打印到控制台的功能</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10typedef struct student &#123;    char name[10];    long studentID;    int age;    int classID;&#125;STUDENT;int main(void) &#123;    void writeToFile(STUDENT[], int);    int readFromFile(STUDENT[]);    void printToScreen(STUDENT[], int);    STUDENT stu[MAXSIZE];    int studentNum;    printf("请输入学生数量：\n");    scanf("%d", &studentNum);    printf("请输入学生信息：\n");    for (int i = 0; i &lt;studentNum; i++) &#123;        scanf("%s %ld %d %d", stu[i].name, &stu[i].studentID, &stu[i].age, &stu[i].classID);    &#125;    writeToFile(stu, studentNum);    studentNum = readFromFile(stu);    printToScreen(stu, studentNum);    return 0;&#125;void writeToFile(STUDENT stu[], int n) &#123;    FILE* fp;    if ((fp = fopen("studentData.txt", "w")) == NULL) &#123;        printf("文件打开失败！");        exit(0);    &#125;    fwrite(stu, sizeof(STUDENT), n, fp);    fclose(fp);&#125;int readFromFile(STUDENT stu[]) &#123;    FILE* fp;    int i;    if ((fp = fopen("studentData.txt", "r")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    for (i = 0; !feof(fp); i++) &#123;        fread(&stu[i], sizeof(STUDENT), 1, fp);    &#125;    fclose(fp);    return i - 1;&#125;void printToScreen(STUDENT stu[], int num) &#123;    printf("----------------------\n");    for (int i = 0; i &lt; num; i++) &#123;        printf("%6s%10ld%4d%4d\n", stu[i].name, stu[i].studentID, stu[i].age, stu[i].classID);    &#125;&#125;</code></pre><h5 id="数字读写putw-和getw"><a href="#数字读写putw-和getw" class="headerlink" title="数字读写putw()和getw()"></a>数字读写putw()和getw()</h5><p>putw()和getw()不是ANSI C标准定义的函数，但很多编译器提供这两个函数，有的编译器将其命名为_putw()和_getw()函数(Visual Studio 2019(编译器版本主要支持ANSI C89标准，但其中包含几个Microsoft扩展支持ISO C99的一部分函数)只能用这两个函数名)，因此这两个函数的在不同编译器中函数名可能不同，函数名中的<span class="tips">w</span>是指<span class="tips">word(字)</span></p><ul><li><span class="strong"> int getw(FILE *fp)</span> 从fp读取一个整数，如果读取成功，返回该整数，读取失败或文件结束，返回-1</li><li><span class="strong">int putw(int w, FILE *fp)</span> 将一个字符或字输出到文件fp，返回值为输出的整数</li></ul><div class="show">eg:存储0-9整数到文件test.txt中，读出后输出到控制台<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void) &#123;    FILE* fp;    int getNum;    if ((fp = fopen("test.txt", "w")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    for (int i = 0; i < 10; i++) &#123;        <span class="text-blue">_putw(i, fp);</span>    &#125;    fclose(fp);    if ((fp = fopen("test.txt", "r")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    for (int i = 0; i < 10; i++) &#123;        <span class="text-blue">getNum = _getw(fp);</span>        printf("%4d", getNum);    &#125;    fclose(fp);    return 0;&#125;</code></div><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><p>之前的示例执行的都是顺序文件处理，数据项是依次进行读写的，如果需要读取第5个数据项，按顺序文件处理方法必须先读取前4个数据项。如果要读写指定位置的数据项，则需要使用文件的随机访问，允许在文件中随机定位，并在文件任意位置读写数据。</p><p>为了实现文件的定位，每一个打开的文件中，都有一个<span class="text-blue">文件位置指针</span>，用来指向当前文件读写位置。当对文件进行顺序读写时，每读完一个字节，位置指针就会自动指向下一个字节。当需要随机读写时，需要我们人为指定位置指针的指向，C语言提供了几个关于位置指针的函数</p><h5 id="重置位置指针rewind"><a href="#重置位置指针rewind" class="headerlink" title="重置位置指针rewind()"></a>重置位置指针rewind()</h5><p><span class="strong">void rewind(FILE *fp)</span> 使fp文件的位置指针指向文件首字节，即重置位置指针到文件开头</p><div class="show">eg:打印file1文件内容到控制台，并将其复制到file2，两个任务分开执行。第一次打印完file1文件，文件位置指针位于文件末尾，使用rewind()函数将file1文件位置指针重置到文件开头，执行其他任务<code>FILE *fp1=fopen("file1.txt","r");FILE *fp2=fopen("file2.txt","r");//应当有文件打开失败的错误处理，这里省略while(!feof(fp1))&#123;    putchar(getc(fp1));&#125;<span class="text-blue">rewind(fp1);</span>while(!feof(fp1))&#123;   putc(getc(fp1),fp2);&#125;fclose(fp1);fclose(fp2);</code></div><h5 id="指定指针位置fseek"><a href="#指定指针位置fseek" class="headerlink" title="指定指针位置fseek()"></a>指定指针位置fseek()</h5><p><span class="strong">int fseek(FILE *fp,long offset,int fromwhere);</span>将fp的位置指针从fromwhere移动offset个字节</p><p>offset是一个偏移量，告诉文件指针跳过多少个字节，ANSI C要求offset是<span class="tips">long</span>类型的(其常量值后面要加L)，这样当文件长度大于64kb时不至于出问题。当offset为正时，位置指针向后移动，为负时向前移动。由于需要指定具体字节数，因此该参数往往需要<span class="tips">sizeof(数据类型)</span>函数来获取相应类型的字节数。</p><p>fromwhere用于确定偏移量计算的起始位置，可以取以下三个值：</p><div class="table"><table><thead><tr><th>起始点</th><th>别名</th><th>值</th></tr></thead><tbody><tr><td>文件开始</td><td>SEEK_SET</td><td>0</td></tr><tr><td>文件当前位置</td><td>SEEK_CUR</td><td>1</td></tr><tr><td>文件末尾</td><td>SEEK_END</td><td>2</td></tr></tbody></table></div><div class="show">eg:读取studentData.txt中的第k条数据并打印到控制台，k由用户输入<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10typedef struct student &#123;    char name[10];    long studentID;    int age;    int classID;&#125;STUDENT;int main(void) &#123;    void searchData(char fileName[],long k);    long k;    printf("Input the searching record number:");    scanf("%ld",&k);    searchData("studentData.txt",k);    return 0;&#125;void searchData(char fileName[],long k)&#123;    FILE* fp;    STUDENT stu;    if ((fp = fopen(filename, "r")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    <span class="text-blue">fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);</span>    <span class="text-red">fread(&stu, sizeof(STUDENT), 1, fp);</span>    printf("%8s%8ld%4d%4d", stu.name, stu.studentID, stu.age, stu.classID);    fclose(fp);&#125;</code></div><h5 id="返回指针位置ftell"><a href="#返回指针位置ftell" class="headerlink" title="返回指针位置ftell()"></a>返回指针位置ftell()</h5><p><span class="strong">long ftell(FILE *fp)</span>返回当前位置指针相对于文件开头的位移量(字节数)，若函数调用失败则返回-1L</p><div class="show">eg:ftell()返回的文件位置是用字节偏移量表示的，如果要获取记录号(第几条数据)则还要除以sizeof(STUDENT)<code>fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);//执行完指针跳转，不确定指针指向哪里，可以用ftell()返回指针位置long num=ftell(fp);//指针相对于文件头的偏移字节数int k=num/sizeof(STUDENT);//指针指向的数据序号</code></div><h4 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h4><ul><li><span class="strong">int feof(FILE *fp)</span>检查fp所指向文件是否已经读到文件末尾。当文件位置指针指向文件结束符时，返回非0值，否则返回0值</li><li><span class="strong">int ferror(FILE *fp)</span>检查对文件的输入输出操作是否出错，如果出错返回非零值，如果未出错，返回0。对同一个文件，每调用一次输入输出函数，ferror()函数的值都会更新</li><li><span class="strong">void clearerr(FILE *fp)</span>将fp所指向文件的文件错误标志和文件结束标志置为0</li><li><span class="strong">void perror(const char *str)</span>向标准错误输出字符串str，并随后附上冒号以及全局变量errno代表的错误消息的文字说明，无返回值</li><li><span class="strong">int rename(const char *old,const char *new)</span>将文件名old所指的文件改为new，成功返回0，出错返回1<h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4>在从终端设备输入输出时，系统会自动打开三个标准文件：标准输入、标准输出、标准出错输出。系统为其定义了三个文件指针：stdin、stdout和stderr，分别指向终端输入、终端输出和标准出错输出(也从终端输出)。在默认情况下，标准输入设备是键盘，标准输出设备是屏幕，我们从终端输入、输出时不需要手动打开终端文件，系统会自动打开，同样，如果程序指定从stdin所指的文件输入数据，其实就是指从终端键盘输入数据。</li></ul><p>文件读写操作中的很多函数是标准输入输出函数的文件操作版，如：fprintf()是printf()的文件操作版，二者差别在于fprintf()多了一个文件指针类型的参数(FILE * fp)，如果给该参数传递的值是stdout，那么fprintf()就和printf()完全一样了，同理，以下语句是两两等价的：</p><div class="show"><code>putchar(c)等价于fputc(c,stdout)puts(str)等价于fputs(str,stdout)getchar()等价于fgetc(stdin)以下函数，fgets()比gets()还多了一个参数sizechar *fgets(char *str,int size,FILE *fp);char *gets(char *str);参数size用于限制输入字符串的长度，说明fgets()函数输入缓冲区大小，使读入的字符数不能超过限定的缓冲区大小，从而达到防止缓冲区溢出攻击的目的，因此，以下语句，后者安全性更高gets(str);fgets(str,sizeof(str),stdin);</code></div><p>虽然系统隐含的标准I/O文件是指终端文件，但标准输入和标准输出是可以重定向的，操作系统可以把它们重定向到其他文件或具有文件属性的设备，只有标准错误输出不能进行一般的输出重定向，如：把标准输出重定向到打印机，把标准输入重定向到U盘文件等。使用<span class="strong">“&lt;”</span>表示输入重定向，用<span class="strong">“&gt;”</span>表示输出重定向。如：file.exe是可执行文件，执行该程序时需要从键盘输入数据，如果现在要求从文件file.in读取所需要输入的数据，那么只需在DOS命令提示符下，输入以下命令即可：</p><div class="shell">c:\file.exe &lt; file.in</div>这样file.exe的标准输入就被"&lt;"重定向到了file.in文件，此时程序只会从文件file.in读取数据，而不再理会任何键盘输入。同样，以下命令可以将标准输出重定向到文件file.out：<div class="shell">c:\file.exe &gt; file.out</div><h3 id="C语言中的随机数"><a href="#C语言中的随机数" class="headerlink" title="C语言中的随机数"></a>C语言中的随机数</h3><p>C语言标准库在&lt;stdlib.h&gt;头文件中提供了用于生成随机数的函数<span class="text-red">rand()</span>，其函数原型为：<span class="strong">int rand(void)</span>，该函数可以生成<span class="text-blue">0~32767</span>范围内的随机数，但该函数生成的数是伪随机数，每次调用该函数都会重复生成以下值：</p><div class="show"><code>    printf("%d\n", rand());//41    printf("%d\n", rand());//18467    printf("%d\n", rand());//6334    printf("%d\n", rand());//26500    printf("%d\n", rand());//19169    ......</code></div><p>这是由于，各编程语言获取随机数实际上都是基于递推公式计算出一组数值，当序列足够长，这组数值可以近似满足均匀分布。在计算随机数时，这些随机函数都是基于一种名为”种子”的基准值进行运算，当种子值不变，生成的随机数也将固定。C语言中,rand()函数的种子值默认为1，可以通过<span class="text-red">srand()</span>函数来修改该种子值，其函数原型为:<br><span class="strong">void srand(unsigned int seed);</span></p><div class="show"><code>    srand(6);    printf("%d\n", rand());//58    printf("%d\n", rand());//6673    printf("%d\n", rand());//30119    printf("%d\n", rand());//15745    printf("%d\n", rand());//5206</code></div><p>如果将种子值设为当前时间，由于时间是每时每刻都不一样的，此时就可以真正生成一个随机数，C语言提供了获取当前时间戳的函数：<br><span class="strong">time_t time(time_t *timer);</span></p><p>该函数会当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，其返回值类型为time_t(但本质上为64位整型)，在用作生成随机数时，传入的参数一般为空指针NULL(或0)</p><div class="show"><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main()&#123;   <span class="text-red">srand((unsigned int)time(NULL));</span>    printf("%d\n", rand());    printf("%d\n", rand());    return 0;&#125;</code></div><p>如果需要指定生成随机数的范围，则还需要一些额外的运算</p><div class="show">以下操作建立在设置了随机数种子的前提下<code>srand((unsigned int)time(NULL));</code>1. 通过取模运算来限制随机数范围<code>int randomNum = rand() % 100;//生成0-99之间的随机整数int randomNum = rand()%100+1;//生成1-100之间的随机整数该语句解析为：int randomNum = rand()%(101-1)+1;//生成1-101(不包括101)之间的整数</code>生成min-max(不包括max)之间的随机整数<span class="text-blue">rand()%(max-min)+min</span>2. 将随机整数除以RAND_MAX宏常量来获取随机小数：stdlib.h定义了rand()函数能返回伪随机数的最大值RAND_MAX，其值一般为32767，我们将获得的随机整数除以该常量值，就获得了一个0.0-1.0之间的随机小数<code>double random_double = (double)rand()/(double)RAND_MAX;</code>类似地可以限定该随机小数的范围为a-b：<span class="text-blue">(double)rand() / RAND_MAX * (b - a) + a;</span></div><h3 id="常用函数和头文件"><a href="#常用函数和头文件" class="headerlink" title="常用函数和头文件"></a>常用函数和头文件</h3><p>列出了一些常用的函数及其头文件，这些头文件中还有很多其他函数，可以参考文档：<a href="https://cplusplus.com/reference/">https://cplusplus.com/reference/</a>，里面罗列了很多C语言和C++的头文件和函数，二者文件名和函数形参可能有所不同但能类似套用</p><h4 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h4><p>以下是对部分字符的定义</p><div class="table"><table><thead><tr><th>字符类</th><th>说明</th></tr></thead><tbody><tr><td>标点符号字符</td><td>!@”#$%^&amp;’(),*+-./:&lt;=&gt;;[]\_{</td></tr><tr><td>图形字符</td><td>包括字母、数字、标点符号</td></tr><tr><td>空白字符</td><td>空格符、水平制表符\t、换行符\n、垂直制表符\v、换页符\f、回车符\r</td></tr><tr><td>控制字符</td><td>在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）</td></tr><tr><td>可打印字符</td><td>包括字母、数字、标点符号和空格字符</td></tr></tbody></table></div><p>以下函数用于测试和映射字符，需要包含字符串<span class="text-red">&lt;ctype.h&gt;</span>，除了最后的大小写转换函数，其余函数如果参数 c 满足描述的条件，则这些函数返回非零值(true)，一般返回值为1，否则返回零(false)</p><div class="table"><table><thead><tr><th>函数名</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>isalnum</td><td>int isalnum(int c)</td><td>检查字符c是否是字母和数字</td></tr><tr><td>isalpha</td><td>int isalpha(int c)</td><td>检查字符c是否是字母</td></tr><tr><td>iscntrl</td><td>int iscntrl(int c)</td><td>检查字符c是否是控制字符</td></tr><tr><td>isprint</td><td>int isprint(int c)</td><td>检查字符c是否是可打印的</td></tr><tr><td>isdigit</td><td>int isdigit(int c)</td><td>检查字符c是否是十进制数字</td></tr><tr><td>isxdigit</td><td>int isxdigit(int c)</td><td>检查字符c是否是十六进制数字</td></tr><tr><td>isgraph</td><td>int isgraph(int c)</td><td>检查字符c是否有图形表示法，有图形表示法的字符是指除了空白字符以外的所有可打印的字符</td></tr><tr><td>islower</td><td>int islower(int c)</td><td>检查字符c是否是小写字母</td></tr><tr><td>isupper</td><td>int isupper(int c)</td><td>检查字符c是否是大写字母</td></tr><tr><td>ispunct</td><td>int ispunct(int c)</td><td>检查字符c是否是标点符号字符</td></tr><tr><td>isspace</td><td>int isspace(int c)</td><td>检查字符c是否是空白字符</td></tr><tr><td>tolower</td><td>int tolower(int c)</td><td>把给定的字符c转换为小写字母，如果已经是小写字母则c不变</td></tr><tr><td>toupper</td><td>int toupper(int c)</td><td>把给定的字符c转换为大写字母，如果已经是大写字母则c不变</td></tr></tbody></table></div><p>以下函数用于处理字符串，需要包含头文件<span class="text-red">&lt;string.h&gt;</span></p><div class="table"><table><thead><tr><th>函数名</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>strlen</td><td>unsigned int strlen( const char *str);</td><td>返回字符串str中实际字符的个数(不包括终止符’\0’)</td></tr><tr><td>strcat</td><td>char *strcat(char *str1,const char *str2)</td><td>把字符串str2拼接到str1后面,并在拼接好的str1串末尾添加一个’\0’,原str1末尾的’\0’将被覆盖。因无边界检查,调用时应保证str1的空间足够大,能存放原始str1和str2两个串的内容。函数返回指向str1的指针</td></tr><tr><td>strncat</td><td>char * strncat( char * strl, constchar * str2, unsigned int count);</td><td>把字符串str2中不多于count个字符拼接到str1后面,并添加\0’,原str1末尾的’\0’将覆盖，函数指向返回str1的指针</td></tr><tr><td>strcpy</td><td>char * strcpy( char * strl, constchar *str2);</td><td>把str2指向的字符串复制到str1中，str2必须是终止符为’\0’的字符串指针，函数返回指向str1的指针</td></tr><tr><td>strncpy</td><td>char *strncpy(char * strl, constchar *str2,unsigned int count);</td><td>把str2指向的字符串中的count个字符复制到st1中，str2必须是终止符为’\0’的字符串指针。如果str2指向的字符串少于 count个字符，则将’\0’加到str1的尾部,直到满足coun个字符为止。如果str2指向的字符串长度大于count个字符，则结果串str1不用’\0’结尾，函数返回指向strl的指针</td></tr><tr><td>strcmp</td><td>int strcmp(const char * strl,const char * str2);</td><td>按字典顺序比较两个字符串str1和str2。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数</td></tr><tr><td>strcnmp</td><td>int strcnmp( const char * strl,const char*str2,unsigned intcount);</td><td>按字典顺序比较两个字符串str1和str2的不多于count个字符。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数</td></tr><tr><td>strtr</td><td>char * strstr(char * strl, char *str2);</td><td>找出str2字符串在str1字符串中第一次出现的位置(不包括str2的串结束符)。函数返回该位置的指针。若找不到则返回空指针</td></tr></tbody></table></div><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>使用以下函数，源文件需要包含<span class="tips">&lt;math.h&gt;</span>头文件，以下函数这里只写出了返回值和形参为double类型的函数原型，它们中的绝大多数还有一个返回值和形参为float或long double类型的函数原型，因此可以类似地套用</p><div class="table"><table><thead><tr><th>函数名</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>fabs</td><td>double fabs( double x);</td><td>计算x的绝对值，返回浮点数</td></tr><tr><td>abs</td><td>double abs (double x);</td><td>在c++中该函数声明于cmath头文件，可以用于计算double、float、long double的绝对值，在c语言中声明于stdlib.h文件，用于计算int的绝对值</td></tr><tr><td>ceil</td><td>double ceil (double x);</td><td>向上取整</td></tr><tr><td>floor</td><td>double floor( double x);</td><td>向下取整，计算不大于x的最大整数</td></tr><tr><td>round</td><td>double round  (double x);</td><td>四舍五入取整</td></tr><tr><td>pow</td><td>double pow( double base, doubleexp);</td><td>返回base为底的exp次幂,即base<sup>exp</sup>,返回计算结果。当base等于0而exp小于0时或者base小于0而exp不为整数时,出现结果错误。该函数要求参数base和exp以及函数的返回值为double类型,否则有可能出现数值溢出问题</td></tr><tr><td>sqrt</td><td>double sqrt(double x)</td><td>计算√x(根号下x)的值，注意x&gt;=0</td></tr><tr><td>exp</td><td>double exp( double x);</td><td>计算e<sup>x</sup>的值</td></tr><tr><td>fmod</td><td>double fmod ( double x, double y);</td><td>计算整除x/y的余数</td></tr><tr><td>log</td><td>double log( double x );</td><td>计算log<sub>e</sub>x,即lnx,返回计算结果。注意,x&gt;0</td></tr><tr><td>log10</td><td>double log10( double x);</td><td>计算 log<sub>10</sub>x,返回计算结果。注意,x&gt;0</td></tr><tr><td>sin</td><td>double sin(double x)</td><td>计算sinx的值，x为弧度值</td></tr><tr><td>cos</td><td>double cos(double x)</td><td>计算cos(x)的值，x为弧度值</td></tr><tr><td>tan</td><td>double tan(double x);</td><td>计算tanx的值</td></tr><tr><td>asin</td><td>double asin(double x)</td><td>计算cos<sup>-1</sup>(x)的值，注意，x应为-1到1范围</td></tr><tr><td>acos</td><td>double acos(double x)</td><td>计算sin<sup>-1</sup>(x)的值，注意，x应为-1到1范围</td></tr><tr><td>atan</td><td>double atan(double x)</td><td>计算tan<sup>-1</sup>(x)的值</td></tr><tr><td>atan2</td><td>double atan2(double x,double y)</td><td>计算tan<sup>-1</sup>(x/y)的值</td></tr><tr><td>sinh</td><td>double sinh(double x)</td><td>计算x的双曲正弦函数sinh(x)的值</td></tr><tr><td>cosh</td><td>double cosh(double x)</td><td>计算x的双曲余弦 cosh(x)的值</td></tr><tr><td>tanh</td><td>double tanh(double x)</td><td>计算x的双曲正切函数tanh(x)的值</td></tr><tr><td>frexp</td><td>double frexp(double val,int*eptr);</td><td>把双精度数val分解为小数部分(尾数)x和以2为底的指数n(阶码),即val=x*2 <sup>n</sup>,n存放在eptr指向的变量中,函数返回小数部分x,0.5≤x&lt;1</td></tr><tr><td>modf</td><td>double modf( double val, double *iptr);</td><td>把双精度数val分解为整数部分和小数部分,把整数部分存到iptr指向的单元。返回val的小数部分</td></tr></tbody></table></div><h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><div class="table"><table><thead><tr><th>函数名</th><th>头文件</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>atof</td><td>stdlib.h</td><td>double atof(const char * str);</td><td>把str指向的字符串转换成双精度浮点值,串中必须含合法的浮点数,否则返回值无定义。函数返回转换后的双精度浮点值</td></tr><tr><td>atoi</td><td>stdlib.h</td><td>int atoi(const char *str);</td><td>把str指向的字符串转换成整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的整型值</td></tr><tr><td>alol</td><td>stdlib.h</td><td>long int atol(const char * str);</td><td>把str指向的字符串转换成长整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的长整型值</td></tr><tr><td>exit</td><td>stdlib.h</td><td>void exit(int code);</td><td>使程序立即终止,清空和关闭任何打开的文件。程序正常退出状态由code等于0或EXITSUCCESS表示，如exit(0)，非0值或EXIT_FAILURE表明定义实现错误。函数无返回值</td></tr><tr><td>rand</td><td>stdlib.h</td><td>int rand(void);</td><td>产生伪随机数序列。函数返回0到RAND_MAX之间的随机整数,RAND_MAX至少是32767</td></tr><tr><td>srand</td><td>stdlib.h</td><td>void srand(unsigned int seed );</td><td>为函数rand()生成的伪随机数序列设置起点种子值，函数无返回值</td></tr><tr><td>time</td><td>time.h</td><td>time_t time(time_t *timer)</td><td>如果传入的参数为空指针NULL，则该函数返回当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，返回值类型为time_t(但本质上为64位整型)。如果参数为time_t类型指针变量timer，则该时间差值也将放于timer所指向的内存中</td></tr><tr><td>clock</td><td>time.h</td><td>clock_t clock(void);</td><td>clock_t是long类型，该函数返回硬件的时钟节拍数，需要换成秒或者毫秒，通常需要除以CLK_TCK或者CLOCKS_PER_SEC。例如,在VC6.0下,这两个量的值都是1000,表示硬件1秒钟的时钟节拍数为1000，该函数常用于测量从程序开始运行到clock()被调用时所消耗的时间，或用于实现计时器功能，如：计算一个进程的时间需要用clock()除以1000。注意:本函数仅能返回ms级的计时精度</td></tr><tr><td>Sleep</td><td>stdlih.h</td><td>Sleep(unsigned long second);</td><td>在标准C中和Linux下是函数的首字母不大写。但在VC和Code::blocks环境下首字母要大写。Sleep()函数的功能是将进程挂起一段时间,即起到延时的作用。参数的单是毫秒</td></tr><tr><td>system</td><td>stdlib.h</td><td>int system(char * command);</td><td>发出一个DOS命令。例如,system(“CLS”)可以实现清屏操作</td></tr><tr><td>kbhit</td><td>conio.h</td><td>int kbhit(void);</td><td>检查当前是否有键盘输人,若有则返回一个非0值,否则回 0</td></tr><tr><td>getch</td><td>conio.h</td><td>int getch(void);</td><td>无需用户按回车键即可得到入户输入，只要用户按下一个键，立刻返回用户输入字符的ASCII码值，但输入的字符不会显示在屏幕上，出错时返回-1，该函数在游戏中比较常用</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">写C语言没有对象，我学Java去了</summary>
    
    
    
    
    <category term="C" scheme="https://shiwei11.github.io/blog/tags/C/"/>
    
    <category term="note" scheme="https://shiwei11.github.io/blog/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的各种尺寸</title>
    <link href="https://shiwei11.github.io/blog/2023/09/07/JavaScript%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B0%BA%E5%AF%B8/"/>
    <id>https://shiwei11.github.io/blog/2023/09/07/JavaScript%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B0%BA%E5%AF%B8/</id>
    <published>2023-09-06T16:35:30.000Z</published>
    <updated>2023-10-15T15:53:11.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局尺寸"><a href="#全局尺寸" class="headerlink" title="全局尺寸"></a>全局尺寸</h3><h4 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h4><ul><li><span class="strong">window.screen.height</span>返回整个屏幕的高度</li><li><span class="strong">window.screen.width</span>返回整个屏幕的宽度</li><li><span class="strong">window.screen.availHeight</span>返回屏幕可用高度(去掉任务栏高度)</li><li><span class="strong">window.screen.availWidth</span>返回屏幕可用宽度(去掉任务栏宽度)</li><li><span class="strong">window.screenTop/window.sceenY</span>返回浏览器左边界到屏幕左边缘的距离</li><li><span class="strong">window.screenLeft/window.screenX</span>返回浏览器的上边界到屏幕上边缘的距离</li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>availHeight和availWidth主要用于PC端，一般情况下，任务栏位于屏幕底部占用了屏幕高度，所以window.screen.availHeight的值是window.screen.height减去任务栏高度后得出的值，如果任务栏隐藏，screen.availHeight的值将等于screen.height。同理，当任务栏在屏幕左侧或右侧时，可以用availWidth获得当前屏幕可用宽度。</div><h4 id="浏览器尺寸"><a href="#浏览器尺寸" class="headerlink" title="浏览器尺寸"></a>浏览器尺寸</h4><ul><li><span class="strong">window.outerHeight</span>返回整个浏览器窗口的高度，包括地址栏、标签栏、收藏栏和显示网页的布局视口高度</li><li><span class="strong">window.outerWidth</span>返回整个浏览器窗口的宽度</li><li><span class="strong">window.innerHeight</span>返回浏览器显示网页用的布局视口(layout viewport)高度，包含滚动条(如果有)，不包含地址栏、标签栏、收藏栏的高度</li><li><span class="strong">window.innerWidth</span>返回浏览器视口宽度，包含滚动条(如果有)</li></ul><p>任何窗口对象window、frame、frameset都支持window.innerHeight属性，outerHeight和innerHeight区别如下(图片来源于MDN文档)</p><img data-src="/blog/images/innervsouterheight.png" src="#" alt="innerHeight"><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>在Android端浏览器中，上述4个属性的返回值可能不可靠，如可能出现innerHeight值大于outerHeight等情况，不同Android系统版本返回值不同，因此在移动端中请慎用，Stack Overflow上有一篇讨论这一问题的帖子：<a href="https://stackoverflow.com/questions/10610743/android-browsers-screen-width-screen-height-window-innerwidth-window-inner" target="_blank">Android browser's screen.width, screen.height & window.innerWidth & window.innerHeight are unreliable</a></div><h4 id="鼠标位置"><a href="#鼠标位置" class="headerlink" title="鼠标位置"></a>鼠标位置</h4><p>鼠标事件触发时，与鼠标位置有关的坐标</p><ul><li><span class="strong">event.screenY</span>返回触发事件时，鼠标在屏幕中的Y坐标值</li><li><span class="strong">event.screenX</span>返回触发事件时，鼠标在屏幕中的X坐标值</li><li><span class="strong">event.pageY</span>返回触发事件时，鼠标相对于整个document的Y坐标值，其值会受文档滚动影响</li><li><span class="strong">event.pageX</span>返回触发事件时，鼠标相对于整个document的X坐标值，其值会受文档滚动影响</li><li><span class="strong">event.clientY</span>返回触发事件时，鼠标相对于浏览器当前网页视口的Y坐标值，其值不受滚动影响</li><li><span class="strong">event.clientX</span>返回触发事件时，鼠标相对于浏览器当前网页视口的X坐标值，其值不受滚动影响</li><li><span class="strong">event.offsetY</span>返回触发事件时，鼠标相对于事件触发源Dom上边界的Y坐标值，其值会受该Dom滚动的影响</li><li><span class="strong">event.offsetX</span>返回触发事件时，鼠标相对于事件触发源Dom左边界的X坐标值，其值会受该Dom滚动的影响</li><li>event.movementY 返回当前事件和上一个mousemove事件之间，鼠标在竖直方向上的移动值</li><li>event.movementX 返回当前事件和上一个mousemove事件之间，鼠标在水平方向上的移动值</li><li>event.x 即event.clientX的别名，实验性属性，兼容性较差</li><li>event.y 即event.clientY的别名，实验性属性，兼容性较差</li></ul><p><canvas width="300" height="400" id="canvasMouseEvent"        style="display:block;width:300px;height:400px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>        const canvasMouseEvent = document.getElementById('canvasMouseEvent');        const ctxME = canvasMouseEvent.getContext('2d');        ctxME.beginPath();        ctxME.lineWidth = 2;        ctxME.strokeRect(10, 150, 280, 200);        ctxME.lineWidth = 1;        ctxME.strokeRect(60, 200, 180, 100);        ctxME.arc(160,250,3,0,Math.PI*2);        ctxME.stroke();        ctxME.closePath();        ctxME.beginPath();        ctxME.lineWidth = 1;        ctxME.strokeStyle = "#f00";        ctxME.moveTo(160, 200);        ctxME.lineTo(160, 250);        ctxME.moveTo(155, 205);        ctxME.lineTo(160, 200);        ctxME.lineTo(165, 205);        ctxME.moveTo(160, 250);        ctxME.lineTo(60, 250);        ctxME.moveTo(65, 255);        ctxME.lineTo(60, 250);        ctxME.lineTo(65, 245);        ctxME.font = "16px Serif";        ctxME.fillStyle = "#f00";        ctxME.fillText('offsetY', 160, 230)        ctxME.fillText('offsetX', 80, 245)        ctxME.stroke();        ctxME.closePath();        ctxME.beginPath();        ctxME.strokeStyle = "#00f";        ctxME.moveTo(190, 10);        ctxME.lineTo(190, 250);        ctxME.moveTo(185, 25);        ctxME.lineTo(190, 10);        ctxME.lineTo(195, 25);        ctxME.moveTo(10, 280);        ctxME.lineTo(160, 280);        ctxME.moveTo(20, 275);        ctxME.lineTo(10, 280);        ctxME.lineTo(20, 285);        ctxME.fillStyle = "#00f";        ctxME.fillText('pageY', 200, 80)        ctxME.fillText('pageX', 80, 295)        ctxME.stroke();        ctxME.closePath();        ctxME.beginPath();        ctxME.strokeStyle = "#05fe05";        ctxME.moveTo(170, 152);        ctxME.lineTo(170, 250);        ctxME.moveTo(165, 167);        ctxME.lineTo(170, 152);        ctxME.lineTo(175, 167);        ctxME.moveTo(10, 260);        ctxME.lineTo(160, 260);        ctxME.moveTo(25, 265);        ctxME.lineTo(10, 260);        ctxME.lineTo(25, 255);        ctxME.stroke();        ctxME.font = "16px Serif";        ctxME.fillStyle = "#05fe05";        ctxME.fillText('clientY', 170, 190);        ctxME.fillText('clientX', 70, 275);        ctxME.closePath();        ctxME.fillStyle = "#000";        ctxME.fillText('浏览器可视区', 15, 170)        ctxME.fillText('document溢出部分', 15, 30)        ctxME.fillText('dom', 65, 215)        ctxME.fillText('鼠标事件', 165, 265)        ctxME.beginPath();        ctxME.strokeStyle = "#000";        ctxME.setLineDash([10, 5]);        ctxME.strokeRect(10, 10, 280, 380);        ctxME.closePath();</script><div class="show">pageY、pageX、offsetY、offsetX的值会受到文档/Dom滚动的影响，即在鼠标位置不变的情况下，文档和Dom滚动前后，鼠标事件触发获得的返回值不一样，因为鼠标相对于整个文档/Dom的位置改变了。而clientX、clientY的返回值始终是以当前网页视口左上角为基准进行计算的，与文档、Dom滚动无关box.addEventListener('click',e=>{            e.stopPropagation();            console.log('offsetX:'+e.offsetX+'px;\noffsetY:'+e.offsetY+'px;\n');            console.log('pageX:'+e.pageX+'px;\npageY'+e.pageY+'px;\n');        })</div><h3 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h3><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><ul><li><span class="strong">Element.clientHeight</span>元素内部的高度，包含padding值，但不包含border，margin和滚动条带来的高度</li><li><span class="strong">Element.clientWidth</span>元素内部的宽度，同上</li><li><span class="strong">Element.clientTop</span>返回元素顶部边框的宽度，即border–top-width的值，表示元素内容(content)到元素顶部的距离</li><li><span class="strong">Element.clientLeft</span>返回元素左边框的宽度，即border-left-width的值，表示元素内容到元素左侧的距离。如果元素左边有垂直滚动条，则该属性包括滚动条的宽度</li></ul><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><ul><li><span class="strong">Element.offsetHeight</span>元素高度，包含padding，border和滚动条，不包含:before 或:after 等伪类元素的高度</li><li><span class="strong">Element.offsetWidth</span>元素的宽度，同上</li><li><span class="strong">Element.offsetTop</span>返回当前元素相对于最近的祖先定位元素的顶部距离，一般是top值+子元素的margin-top值</li><li><span class="strong">Element.offsetLeft</span>返回当前元素相对于最近的祖先定位元素的左侧距离，一般是left值+子元素的margin-left值</li></ul><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><ul><li><p><span class="strong">Element.scrollHeight</span> 返回包括溢出部分的元素高度，包括padding值、伪元素的高度，但不包括border、margin和滚动条的值，如果元素不溢出，则该值等于clientHeight</p></li><li><p><span class="strong">Element.scrollWidth</span>返回包括溢出部分的元素宽度，内容同上</p></li><li><p><span class="strong">Element.scrollTop</span>可以设置和获取，代表元素的内容顶部到它的视口可见内容顶部的距离</p></li><li><p><span class="strong">Element.scrollTop</span>可以设置和获取，代表元素的内容左边界到它的视口可见内容左边界的距离</p></li></ul><p><canvas width="300" height="500" id="canvasScroll" style="display:block;width:300px;height:500px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>      const canvasScroll = document.getElementById('canvasScroll');        const ctxScroll = canvasScroll.getContext('2d');        ctxScroll.beginPath();        ctxScroll.lineWidth = 5;        ctxScroll.strokeRect(10, 150, 280, 200);        ctxScroll.closePath();        ctxScroll.beginPath();        ctxScroll.lineWidth = 1;        ctxScroll.strokeStyle = "#f00";        ctxScroll.moveTo(40, 10);        ctxScroll.lineTo(40, 490);        ctxScroll.moveTo(35, 25);        ctxScroll.lineTo(40, 10);        ctxScroll.lineTo(45, 25);        ctxScroll.moveTo(35, 475);        ctxScroll.lineTo(40, 490);        ctxScroll.lineTo(45, 475);        ctxScroll.font = "20px Serif";        ctxScroll.fillStyle = "#f00";        ctxScroll.fillText('scrollHeight', 40, 250)        ctxScroll.stroke();        ctxScroll.closePath();        ctxScroll.beginPath();        ctxScroll.strokeStyle = "#00f";        ctxScroll.moveTo(190, 10);        ctxScroll.lineTo(190, 150);        ctxScroll.moveTo(185, 25);        ctxScroll.lineTo(190, 10);        ctxScroll.lineTo(195, 25);        ctxScroll.moveTo(185, 135);        ctxScroll.lineTo(190, 150);        ctxScroll.lineTo(195, 135);        ctxScroll.fillStyle = "#00f";        ctxScroll.fillText('scrollTop', 190, 80)        ctxScroll.stroke();        ctxScroll.closePath();        ctxScroll.beginPath();        ctxScroll.strokeStyle = "#05fe05";        ctxScroll.moveTo(170, 152);        ctxScroll.lineTo(170, 348);        ctxScroll.moveTo(165, 167);        ctxScroll.lineTo(170, 152);        ctxScroll.lineTo(175, 167);        ctxScroll.moveTo(165, 333);        ctxScroll.lineTo(170, 348);        ctxScroll.lineTo(175, 333);        ctxScroll.stroke();        ctxScroll.font = "20px Serif";        ctxScroll.fillStyle = "#05fe05";        ctxScroll.fillText('clientHeight', 170, 250)        ctxScroll.closePath();        ctxScroll.fillStyle = "#000";        ctxScroll.fillText('元素显示部分', 45, 180)        ctxScroll.fillText('元素溢出部分', 45, 30)        ctxScroll.beginPath();        ctxScroll.strokeStyle = "#000";        ctxScroll.setLineDash([10, 5]);        ctxScroll.strokeRect(20, 10, 260, 480);        ctxScroll.closePath();</script><div class="show">判断元素是否已经滚到底部，以及判定用户是否已经阅读完文本的解决方案：判断是否满足scrollHeight-scrollTop=clientHeight，由于scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的整数，因此判断三个值的差值小于某个阈值即可Math.abs(ele.scrollHeight - ele.clientHeight - ele.scrollTop)&lt;3</div><h3 id="DOMRect对象"><a href="#DOMRect对象" class="headerlink" title="DOMRect对象"></a>DOMRect对象</h3><p>上述属性返回值一般为四舍五入的整数值，通过DOMRect对象可以获得更为精确的浮点数坐标值</p><h4 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h4><p>该方法会返回一个DOMRect对象，该对象提供了几个描述该Dom位置和大小的属性，这些属性都是基于网页可视窗口的左上角作为坐标原点进行计算的</p><ul><li><span class="strong">width</span>返回Dom的宽度，包含padding值和border-width值</li><li><span class="strong">height</span>返回Dom的高度，包含padding值和border-width值</li><li><span class="strong">x/left</span>返回Dom左边界到网页可视窗口左边界的距离</li><li><span class="strong">y/top</span>返回Dom上边界到网页可视窗口上边界的距离</li><li><span class="strong">right</span>返回Dom右边界到网页可视窗口左边界的距离</li><li><span class="strong">bottom</span>返回Dom下边界到网页可视窗口左边界的距离</li></ul><p><canvas width="300" height="300" id="canvasDomRect"        style="display:block;width:300px;height:300px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>        const canvasDomRect = document.getElementById('canvasDomRect');        const ctxDR = canvasDomRect.getContext('2d');        ctxDR.beginPath();        ctxDR.lineWidth = 2;        ctxDR.strokeRect(10, 10, 280, 280);        ctxDR.lineWidth = 1;        ctxDR.strokeRect(70, 70, 150, 150);        ctxDR.stroke();        ctxDR.closePath();        ctxDR.beginPath();        ctxDR.font = "16px Serif";        ctxDR.strokeStyle = "#f00";        ctxDR.moveTo(70,200);        ctxDR.lineTo(220,200);        ctxDR.moveTo(85,195);        ctxDR.lineTo(70,200);        ctxDR.lineTo(85,205);        ctxDR.moveTo(205,195);        ctxDR.lineTo(220,200);        ctxDR.lineTo(205,205);        ctxDR.fillStyle = "#f00";        ctxDR.fillText('width', 130, 190)        ctxDR.fillText('height', 165, 150);        ctxDR.moveTo(200,70);        ctxDR.lineTo(200,220);        ctxDR.moveTo(195,85);        ctxDR.lineTo(200,70);        ctxDR.lineTo(205,85);        ctxDR.moveTo(195,205);        ctxDR.lineTo(200,220);        ctxDR.lineTo(205,205);        ctxDR.stroke();        ctxDR.closePath();        ctxDR.beginPath();        ctxDR.strokeStyle = "#00f";        ctxDR.moveTo(100, 10);        ctxDR.lineTo(100, 70);        ctxDR.moveTo(95, 25);        ctxDR.lineTo(100, 10);        ctxDR.lineTo(105, 25);        ctxDR.moveTo(10, 100);        ctxDR.lineTo(70, 100);        ctxDR.moveTo(25, 95);        ctxDR.lineTo(10, 100);        ctxDR.lineTo(25, 105);        ctxDR.fillStyle = "#00f";        ctxDR.fillText('y/top', 110, 45)        ctxDR.fillText('x/left', 15, 90)        ctxDR.stroke();        ctxDR.closePath();        ctxDR.beginPath();        ctxDR.strokeStyle = "#05fe05";        ctxDR.moveTo(240, 10);        ctxDR.lineTo(240, 220);        ctxDR.moveTo(235, 25);        ctxDR.lineTo(240, 10);        ctxDR.lineTo(245, 25);        ctxDR.moveTo(10, 240);        ctxDR.lineTo(220, 240);        ctxDR.moveTo(25, 245);        ctxDR.lineTo(10, 240);        ctxDR.lineTo(25, 235);        ctxDR.stroke();        ctxDR.setLineDash([5,2]);        ctxDR.moveTo(260,220);        ctxDR.lineTo(220, 220);        ctxDR.lineTo(220, 260);        ctxDR.stroke();        ctxDR.fillStyle = "#05fe05";        ctxDR.fillText('bottom', 230, 140);        ctxDR.fillText('right', 100, 255);        ctxDR.closePath();        ctxDR.fillStyle = "#000";        ctxDR.fillText('viewPort', 15, 30);        ctxDR.fillText('Element', 125, 85);    </script><div class="show">使用前，使用css清除浏览器默认的padding和margin值，避免浏览器默认值带来的影响*{            margin: 0;            padding: 0;        }但返回值还是会有一些底层渲染和二进制转化带来的误差  const box=document.querySelector('.box');  const boxRect=box.getBoundingClientRect();  console.log(boxRect.width);//eg: 309.6000061035156  console.log(boxRect.left);</div>]]></content>
    
    
    <summary type="html">整理了javaScript中经常用到的计算各种尺寸的API，包括计算屏幕尺寸、浏览器尺寸、鼠标位置、DOM位置和DOMRect对象的常用API</summary>
    
    
    
    
    <category term="javaScript" scheme="https://shiwei11.github.io/blog/tags/javaScript/"/>
    
    <category term="html" scheme="https://shiwei11.github.io/blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>xml</title>
    <link href="https://shiwei11.github.io/blog/2023/05/25/xml/"/>
    <id>https://shiwei11.github.io/blog/2023/05/25/xml/</id>
    <published>2023-05-25T07:27:27.000Z</published>
    <updated>2023-11-06T20:06:18.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>XML 指可扩展标记语言(EXtensible Markup Language)，其文件以<span class="tips">.xml</span>为后缀名，主要用于数据存储、数据传输、编写配置文件，语法格式与HTML相似，二者主要差异有：</p><ul><li>XML标签没有被预定义，需要自行定义标签；HTML虽然支持自定义标签，但主要使用预定义标签</li><li>XML主要用于传输和存储数据，HTML主要用于显示数据</li><li>XML语法要求比HTML严格</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>xml文档基本由以下模块组成</p><ul><li>标签(元素)：文档主要部分，将被解析为XML DOM</li><li>标签属性：提供关于标签的信息</li><li>转义字符(实体)：XML中预用字符的实体引用</li><li>PCDATA(Parsed Character Data)：需要由解析器解析的文本</li><li>CDATA(Character Data)：解析器不会解析的文本，内容将视为字符串</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="xml标签定义规范"><a href="#xml标签定义规范" class="headerlink" title="xml标签定义规范"></a>xml标签定义规范</h4><p>xml中的标签需要自定义，标签名需要遵循以下规范</p><ul><li>可以包含字母、数字和其他符号，包括连字符(-)、下划线(_)和点号(.)</li><li>不能以数字或者标点符号开始</li><li>不能以xml、 XML、Xml开始</li><li>不能包含空格</li><li>尽量避免使用<span class="tips">-</span>和<span class="tips">.</span>字符，该类字符在某些XML解析器中中可能会被错误解析</li><li>避免使用<span class="tips">:</span>，该字符用于命名空间</li></ul><h4 id="xml基本语法格式"><a href="#xml基本语法格式" class="headerlink" title="xml基本语法格式"></a>xml基本语法格式</h4><div class="code">&lt;?xml version="1.0" encoding="utf-8"?>&lt;web> &lt;author>SHIWIVI&lt;/author>&lt;license>CC BY-NC&lt;/license>&lt;heading>&lt;type>Document&lt;/type>&lt;/heading>&lt;body>Meet you like the wind&lt;/body>&lt;/web></div><ul><li>首行进行xml文档声明，version属性定义版本，encoding声明编码格式</li><li>必须包含一个根标签，标签名自定义</li><li>XML标签大小写敏感</li><li>所有XML标签都必须闭合，自闭合标签禁止省略<span class="tips strong">/</span></li><li>XML的属性值须加引号，即便属性值是数值，单双引号均可用</li><li>XML标签禁止交叉嵌套</li><li>XML中多个连续空格也会被保留，HTML中会被合并</li><li>XML 以 LF 存储换行</li></ul><div class="show">xml正确嵌套：&lt;a>&lt;b>content&lt;/b>&lt;/a>严禁交叉嵌套：&lt;a>&lt;b>content&lt;/a>&lt;/b></div><h5 id="空标签"><a href="#空标签" class="headerlink" title="空标签"></a>空标签</h5><p>xml允许空标签，即标签中无内容</p><div class="show">&lt;element>&lt;/element>空标签可以使用自闭合，但禁止省略 /&lt;element /></div><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>以下字符在XML中被预定义，使用时需要转义</p><div class="table"><table><thead><tr><th>字符</th><th>转义</th><th>字符</th><th>转义</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;lt;</td><td>&apos;</td><td>&amp;apos;</td></tr><tr><td>&gt;</td><td>&amp;gt;</td><td>&quot;</td><td>&amp;quot;</td></tr><tr><td>&amp;</td><td>&amp;amp;</td><td></td><td></td></tr></tbody></table></div><h4 id="CDATA字符数据"><a href="#CDATA字符数据" class="headerlink" title="CDATA字符数据"></a>CDATA字符数据</h4><p>CDATA(character data)指不被xml解析器解析的文本数据，当文档中出现需要大量转义的字符时，可以直接使用CDATA进行引用，这样，这些字符将不会被xml解析器解析，</p><p>CDATA 部分由<span class="strong tips">&lt;![CDATA[</span>开始，<span class="strong tips">]]&gt;</span>结束</p><div class="show">&lt;root>&lt;title>标题&lt;/title>&lt;![CDATA[    if(a&lt;b&&b&lt;c){    ....        }    ]]&gt;&lt;/root></div><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>由于xml中标签是自定义的，多个xml文档同时使用可能出现标签名相同导致命名冲突的情况，此时需要使用命名空间来解决标签名冲突问题</p><div class="show">&lt;person>&lt;name>周杰伦&lt;/name>&lt;song>米兰的小铁匠&lt;/song>&lt;/person></div><div class="show">&lt;person>&lt;name>东野圭吾&lt;/name>&lt;writing>解忧杂货店&lt;/writing>&lt;/person></div><h4 id="添加前缀"><a href="#添加前缀" class="headerlink" title="添加前缀"></a>添加前缀</h4><p>在标签名前添加前缀，来定义不同的标签，从而对不同文档的同名标签加以区分</p><div class="show">&lt;j:person>&lt;j:name>周杰伦&lt;/j:name>&lt;j:song>米兰的小铁匠&lt;/j:song>&lt;/j:person>&lt;h:person>&lt;h:name>东野圭吾&lt;/h:name>&lt;h:writing>解忧杂货店&lt;/h:writing>&lt;/h:person></div><h4 id="添加XML-Namespace-xmlns-属性"><a href="#添加XML-Namespace-xmlns-属性" class="headerlink" title="添加XML Namespace(xmlns)属性"></a>添加XML Namespace(xmlns)属性</h4><p>可以在父标签中添加命名空间属性，以此定义一个命名空间，之后带有相同前缀的子标签都将同属于该命名空间<br><span class="strong">xmlns:命名前缀=”namespaceURI”</span></p><div class="show">&lt;j:person xmlns:j="Jay Chou">&lt;j:name>周杰伦&lt;/j:name>&lt;j:song>米兰的小铁匠&lt;/j:song>&lt;/j:person>&lt;h:person xmlns:h="Higashino Keigo">&lt;h:name>东野圭吾&lt;/h:name>&lt;h:writing>解忧杂货店&lt;/h:writing>&lt;/h:person></div><h4 id="使用默认的命名空间"><a href="#使用默认的命名空间" class="headerlink" title="使用默认的命名空间"></a>使用默认的命名空间</h4><p>当父元素定义默认的命名空间时，我们可以省略子元素中的前缀<br><span class="strong">xmlns=”namespaceURI”</span></p><div class="show">&lt;person xmlns="Jay Chou">&lt;name>周杰伦&lt;/name>&lt;song>米兰的小铁匠&lt;/song>&lt;/person>&lt;person xmlns="Higashino Keigo">&lt;name>东野圭吾&lt;/name>&lt;writing>解忧杂货店&lt;/writing>&lt;/person></div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>URI指统一资源标识符(Uniform Resource Identifier)，用于标识因特网资源，最常用的 URI 是用来标示因特网域名地址的统一资源定位器(URL)，另一个不那么常用的 URI 是统一资源命名(URN)，在使用命名空间时，很多xml文档会将名称写为一个链接形式，但该链接仅作为该命名空间的字符串名称，并不是要”链接”到某个地址，不会引入任何资源</div><h3 id="DTD验证"><a href="#DTD验证" class="headerlink" title="DTD验证"></a>DTD验证</h3><p>DTD(Document Type Definition):文档类型定义，是一套为了进行程序间的数据交换而建立的关于标记符的语法规则</p><p>xml的标签是可以自由定义的，每个人写的xml将完全不同。但在一个团队内部，我们往往希望拥有一个统一的文件格式来进行数据交换。此时，我们可以使用DTD来对xml文件进行约束，使用一个标准的 DTD 来交换数据</p><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>使用IntelliJ IDEA写xml文件可以即时校验文档内容是否满足DTD验证</div><h4 id="标签声明"><a href="#标签声明" class="headerlink" title="标签声明"></a>标签声明</h4><p>限制标签内可以写入哪些内容</p><ul><li><span class="strong">&lt;!ELEMENT 标签名 (child1,child2…)&gt; 标签中可以包含的子标签</span><br>父标签中按顺序声明其中可以包含的子标签，子标签必须以相同的顺序出现在xml文档中，并且所有子标签也要声明其中可以写入的内容，子标签可以嵌套地拥有子标签</li><li><span class="strong">&lt;!ELEMENT 标签名 (child1,(child2|child3)…)&gt; 标签中可以包含的子标签并可选</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (#PCDATA)&gt; 标签中仅包含需要解析的字符数据(可以为空)</span></li><li><span class="strong">&lt;!ELEMENT 标签名 EMPTY&gt; 声明为空标签</span></li><li><span class="strong">&lt;!ELEMENT 标签名 ANY&gt; 标签中可包含任何内容 </span></li><li><span class="strong">&lt;!ELEMENT 标签名 (#PCDATA|child1|child2|…)*&gt; 标签中可包含PCDATA数据，也可以包含指定子标签<span class="tips">必须添加*号</span></span></li></ul><h5 id="限制子标签的数量"><a href="#限制子标签的数量" class="headerlink" title="限制子标签的数量"></a>限制子标签的数量</h5><ul><li><span class="strong">&lt;!ELEMENT 标签名 (child)&gt; 子标签必须出现一次，且只能出现一次</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (child+)&gt; 子元素至少出现一次</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (child*)&gt; 子元素出现零次或多次</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (child?)&gt; 子元素出现零次或一次</span></li></ul><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [        &lt;!ELEMENT web (author,license,(body|content))>        &lt;!ELEMENT author     (#PCDATA)>        &lt;!ELEMENT license    (#PCDATA)>        &lt;!ELEMENT heading    (#PCDATA|type)*>        &lt;!ELEMENT type       (#PCDATA)>        &lt;!ELEMENT body       (#PCDATA)>        &lt;!ELEMENT content    (#PCDATA)>]>&lt;web>     &lt;author>SHIWIVI&lt;/author>    &lt;license>lol&lt;/license>    &lt;heading>&lt;type>Document&lt;/type>&lt;/heading>    &lt;body>Meet you like the wind&lt;/body>&lt;/web>1. !DOCTYPE web -  声明文档的根标签是web2. !ELEMENT web -  声明web元素必须包含元素：author,license标签，body和content标签可二选一3. !ELEMENT author - 声明author标签内容为 "#PCDATA"(其余语句同理)4. !ELEMENT heading  - 声明author标签内容为 "#PCDATA"或type标签，由于标签内容受限，需添加*号表示可出现零次或多次</div><h5 id="声明实体"><a href="#声明实体" class="headerlink" title="声明实体"></a>声明实体</h5><p><span class="strong">&lt;!ENTITY 实体引用名称 “实体实际代表含义”&gt; 定义一个实体</span><br>引用实体需要添加<span class="tips">&amp;</span>和<span class="tips">;</span></p><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [        &lt;!ELEMENT web (author,license)>        &lt;!ELEMENT author (#PCDATA)>        &lt;!ELEMENT license (#PCDATA)>        &lt;!ENTITY sm "shiwivi.com">//实体声明        &lt;!ENTITY license "License CC BY-NC 4.0">        ]>&lt;web>    &lt;author>&amp;sm;&lt;/author>//将解析为&lt;author>shiwivi.com&lt;/author>    &lt;license>&amp;license;&lt;/license>&lt;/web></div><h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h4><p>限制标签可添加的属性以及属性值，语法格式为：<br><span class="strong">&lt;!ATTLIST 标签名 属性名 属性类型 属性值&gt;</span></p><div class="table"><table><thead><tr><th>属性类型</th><th>说明</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>CDATA</td><td>字符</td><td>NMTOKEN</td><td>该值是有效的XML名称</td></tr><tr><td>(v1|v2|..)</td><td>值只能为指定内容(枚举)</td><td>NMTOKENS</td><td>该值是有效XML名称的列表</td></tr><tr><td>ID</td><td>值为唯一ID</td><td>ENTITY</td><td>值是一个实体</td></tr><tr><td>IDREF</td><td>值是另一个元素的id</td><td>ENTITIES</td><td>值是实体列表</td></tr><tr><td>IDREFS</td><td>该值是其他ID的列表</td><td>xml:</td><td>该值是预定义的xml值</td></tr></tbody></table></div><div class="table"><table><thead><tr><th>属性值</th><th>说明</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>字符串</td><td>属性默认值</td><td>#REQUIRED</td><td>属性是必需的</td></tr><tr><td>#IMPLIED</td><td>属性是可选的</td><td>#FIXED 值</td><td>属性值是固定的</td></tr></tbody></table></div><div class="show">1. 限制为test标签添加的属性只能为code，如果开发者不指定属性值，则默认值为java&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [        &lt;!ELEMENT web (test)>        &lt;!ELEMENT test EMPTY>        &lt;!ATTLIST test code "java">//属性声明        ]>&lt;web>    &lt;test code="javaScript"/>&lt;/web>2. 该标签必须添加code属性，并且不指定默认值&lt;!ATTLIST test code CDATA #REQUIRED>3. 该标签不强制要求添加code属性，也不指定默认值&lt;!ATTLIST test code CDATA #IMPLIED>4. 该标签强制拥有code属性并指定属性值为java，且不允许修改&lt;!ATTLIST test code CDATA #FIXED "java"></div><h4 id="DTD文件引入"><a href="#DTD文件引入" class="headerlink" title="DTD文件引入"></a>DTD文件引入</h4><h5 id="内部DTD"><a href="#内部DTD" class="headerlink" title="内部DTD"></a>内部DTD</h5><p>如果DTD被包含在xml文件中，需要被包装于<span class="tips">DOCTYPE</span>声明中<br><span class="strong">&lt;!DOCTYPE 根标签 [标签声明内容]&gt;</span></p><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [     &lt;!ELEMENT web (author,license)>     &lt;!ELEMENT author (#PCDATA)>     &lt;!ELEMENT license (#PCDATA)>]&gt;&lt;web>     .....&lt;/web></div><h5 id="外部私有DTD"><a href="#外部私有DTD" class="headerlink" title="外部私有DTD"></a>外部私有DTD</h5><p>可以将DTD声明为一个外部文件，然后引用到xml文档中<br><span class="strong">&lt;!DOCTYPE 根标签 SYSTEM “DTD的URL”&gt;</span></p><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web SYSTEM "./check.dtd">&lt;web>     ....&lt;/web></div><div class="code">&lt;!--check.dtd文件-->&lt;!ELEMENT web (author,license)>     &lt;!ELEMENT author (#PCDATA)>     &lt;!ELEMENT license (#PCDATA)></div><h5 id="外部公用DTD"><a href="#外部公用DTD" class="headerlink" title="外部公用DTD"></a>外部公用DTD</h5><p>也可以使用一些标准化组织或权威机构提供的DTD<br><span class="strong">&lt;!DOCTYPE 根标签 PUBLIC “DTD公共名称” “DTD的URL”&gt;</span></p><p>DTD公共名称格式为：<span class="strong">“是(否)ISO注册//注册组织//DTD所描述的文件的信息//语言”</span></p><ul><li>是否由国际标准化组织(ISO)注册，+表示是，-表示不是</li><li>注册组织或个人</li><li>该DTD所验证文件的描述性信息，经常还会添加版本号</li><li>语言标识，如：ZH为中文，EN为英文<div class="show">lt;!DOCTYPE web PUBLIC "-//shiwivi//blog config//CN" "http://www.shiwivi.com/blog/check.dtd"></div></li></ul>]]></content>
    
    
    <summary type="html">XML文件的语法规则，以及对xml文件进行DTD验证的方法</summary>
    
    
    
    
    <category term="Serve" scheme="https://shiwei11.github.io/blog/tags/Serve/"/>
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SVG矢量图</title>
    <link href="https://shiwei11.github.io/blog/2023/05/19/SVG%E7%9F%A2%E9%87%8F%E5%9B%BE/"/>
    <id>https://shiwei11.github.io/blog/2023/05/19/SVG%E7%9F%A2%E9%87%8F%E5%9B%BE/</id>
    <published>2023-05-19T08:42:15.000Z</published>
    <updated>2023-10-19T08:12:21.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><span class="strong">SVG</span>(Scalable Vector Graphics)全称为可缩放矢量图形，是一种用 XML 标记语言描述二维矢量图形的技术，它有以下特点：</p><ul><li>使用XML语法文本定义图形，因此SVG图形可以被索引、搜索、选中，很适合制作地图</li><li>SVG提供的是矢量图，可以被无限放大且不会失真，也可以在任何分辨率下被高质量地打印</li><li>SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在HTML中使用SVG，可以直接在文档中直接创建SVG标签，也可以先创建svg文件或者xml文件，再引入到HTML中</p><h4 id="svg文件"><a href="#svg文件" class="headerlink" title="svg文件"></a>svg文件</h4><p>SVG文件通常以<span class="tips">.svg</span>作为文件后缀，使用<span class="tips">gzip</span>压缩的SVG文件以<span class="tips">.svgz</span>为后缀名</p><div class="show">&lt;svg version="1.1"     baseProfile="full"     width="300" height="200"     viewBox="0 0 100 100"     xmlns="http://www.w3.org/2000/svg">&lt;/svg></div><ul><li>version属性用于验证识别SVG版本，SVG 2之后的版本不再推荐使用该属性值</li><li>baseProfile 属性用于描述作者认为正确呈现内容所必需的最小SVG语言配置文件，当用户修改内容超出所指定的基准概述范围时，编辑工具会发出警告，一般可以不指定，即使用默认值none，可取值：<blockquote><ul><li>none(默认)，代表作者无观点，使用最小的 SVG 语言配置</li><li>full(正常)，适用于PC</li><li>basic(轻量级)，适用于平板电脑等PDA</li><li>tiny(更轻量级)，适用于手机</li></ul></blockquote></li><li>width和height属性用于指定画布大小，单位会自行解析为px而无需指定，默认大小为300px*150px</li><li>viewBox属性用于指定显示区域，上述参数解析为仅显示从(0,0)坐标开始，长宽均为100px的矩形区域内的图形</li><li>xmlns属性用于声明命名空间，这里的URL只做该命名空间的字符串名称，并不是要”链接”到某个地址。命名空间用于多个文档声明了相同的标签时，帮助XML内容的使用者区别该标签属于哪一个命名空间</li><li>拥有命名空间后意味着该&lt;svg&gt; 标签和它的子节点都属于该命名空间</li></ul><h5 id="svg写入xml文件"><a href="#svg写入xml文件" class="headerlink" title="svg写入xml文件"></a>svg写入xml文件</h5><div class="show">&lt;?xml version="1.0" ?>&lt;svg version="1.1"     baseProfile="full"     width="300" height="200"     xmlns="http://www.w3.org/2000/svg">     &lt;circle cx="150" cy="100" r="80" fill="green" />&lt;/svg></div><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><h5 id="直接插入-lt-svg-gt-标签"><a href="#直接插入-lt-svg-gt-标签" class="headerlink" title="直接插入&lt;svg&gt;标签"></a>直接插入&lt;svg&gt;标签</h5><p>可以直接在HTML所需位置插入&lt;svg&gt;标签</p><div class="show">&lt;body>     &lt;svg width="400" height="300">          &lt;!--svg内容-->     &lt;/svg>&lt;/body>     </div><h5 id="通过img标签引入"><a href="#通过img标签引入" class="headerlink" title="通过img标签引入"></a>通过img标签引入</h5><p>可以将svg定义为一个单独文件，然后通过img标签引入图片</p><div class="show">&lt;img src="./index.svg" alt="未加载SVG"></div><h5 id="CSS引入"><a href="#CSS引入" class="headerlink" title="CSS引入"></a>CSS引入</h5><p>在CSS样式中将svg作为背景图引入</p><div class="show">.svgPic{         width: 400px;         height: 300px;         background-image: url(./index.svg);         background-repeat: no-repeat;     }</div><h5 id="object标签引入"><a href="#object标签引入" class="headerlink" title="object标签引入"></a>object标签引入</h5><p>object标签可用于包含音视频及图形对象，并且支持<span class="tips">.svg</span>和<span class="tips">.xml</span>格式的文件</p><div class="show">&lt;object data="./index.svg" type="image/svg+xml" width="400" height="300">未加载SVG&lt;/object></div><div class="show">&lt;object data="./index.xml" type="image/svg+xml" width="400" height="300">未加载SVG&lt;/object></div><h5 id="iframe标签引入"><a href="#iframe标签引入" class="headerlink" title="iframe标签引入"></a>iframe标签引入</h5><p>使用内联框架引入svg数据，该标签也同时支持<span class="tips">.svg</span>和<span class="tips">.xml</span>文件</p><div class="show">&lt;iframe src="./index.svg"  width="400" height="300">浏览器不支持iframe标签&lt;/iframe></div><div class="show">&lt;iframe src="./index.xml"  width="400" height="300">浏览器不支持iframe标签&lt;/iframe></div><h3 id="基本图形"><a href="#基本图形" class="headerlink" title="基本图形"></a>基本图形</h3><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p><span class="strong">rect标签</span></p><div class="show">&lt;rect x="10" y="10" rx="20" ry="40" width="200" height="200" >&lt;/rect></div><ul><li>(x,y)为矩形左上角坐标</li><li>width,height为矩形长和高，不能为负值！(与canvas不同)</li><li>rx为矩形与x轴平行的两条边的圆角半径，默认为0</li><li>ry为矩形与y轴平行的两条边的圆角半径，默认为0</li></ul><h4 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h4><p><span class="strong">circle标签</span></p><div class="show">&lt;circle cx="100" cy="100" r="50">&lt;/circle></div><ul><li>(cx,cy)为圆心坐标</li><li>r为圆的半径</li></ul><h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><p><span class="strong">ellipse标签</span></p><div class="show">&lt;ellipse cx="200" cy="200" rx="100" ry="50">&lt;/ellipse></div><ul><li>(cx,cy)为椭圆中心的坐标</li><li>rx为椭圆的 x 半径，ry为椭圆的 y 半径</li></ul><h4 id="线段line"><a href="#线段line" class="headerlink" title="线段line"></a>线段line</h4><div class="show">&lt;line x1="150" y1="300" x2="300" y2="350"stroke="#fff" stroke-width="5">&lt;/line></div><ul><li>(x1,y1)为线段起始坐标</li><li>(x2,y2)为线段终点坐标</li><li>stroke指定线段绘制颜色</li></ul><h4 id="折线polyline"><a href="#折线polyline" class="headerlink" title="折线polyline"></a>折线polyline</h4><div class="show">&lt;polyline points="0 0,10 10,20 0,30 10" style="stroke:#fff;" /></div><ul><li>points属性指定折线折点，每个折点必须指定x,y坐标</li><li>坐标之间可以用空白符、逗号、或者可附带空格的换行符分隔开</li></ul><div class="show">以下写法均可以表示(0,0)、(10,10)、(20,0)、(30,10)四个坐标点，也可以用换行替代points="0 0 10 10 20 0 30 10"points="0 0,10 10,20 0,30 10"points="0,0 10,10 20,0 30,10"</div><h4 id="多边形polygon"><a href="#多边形polygon" class="headerlink" title="多边形polygon"></a>多边形polygon</h4><div class="show">&lt;polygon points="10 10,60 30,120 10" style="stroke:#fff;" /></div><ul><li>points属性与polyline类似</li><li>坐标最后一个点会和第一个点闭合</li></ul><h3 id="path路径"><a href="#path路径" class="headerlink" title="path路径"></a>path路径</h3><p>通过描述路径坐标理论上可绘制任意图形，路径坐标的表示方法与上述points属性坐标表示方法相同，可以用空白符、逗号、或者可附带空格的换行符进行分隔</p><h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><div class="show">&lt;path d="M250 150 L150 350 L350 350 Z" /></div><ul><li>d属性通过”命令+坐标参数”的组合来描述路径</li><li>命令为<span class="tips">大写字母</span>时表示<span class="strong">绝对定位</span>，即相对于svg左上角坐标原点的坐标，命令为<span class="tips">小写字母</span>时表示<span class="strong">相对定位</span>，即相对于上一个命令终点的相对位移</li></ul><p> 命令包括以下：</p><ul><li>M = moveto，移动画笔</li><li>L = lineto，绘制直线</li><li>H = horizontal lineto，绘制水平直线，只需要x一个参数</li><li>V = vertical lineto，绘制垂直直线，只需要y一个参数</li><li>C = curveto，绘制三次贝塞尔曲线</li><li>S = smooth curveto，可衔接的三次贝塞尔曲线</li><li>Q = quadratic Belzier curve，绘制二次贝塞尔曲线</li><li>T = smooth quadratic Belzier curveto，绘制可衔接的二次贝塞尔曲线</li><li>A = elliptical Arc，绘制弧线</li><li>Z = closepath，闭合路径，一般用于路径最后</li></ul><h4 id="二阶贝塞尔曲线"><a href="#二阶贝塞尔曲线" class="headerlink" title="二阶贝塞尔曲线"></a>二阶贝塞尔曲线</h4><p>通过给定一个控制点坐标和曲线终点坐标绘制贝塞尔曲线<br><span class="strong">Q x1 y1, x y</span></p><ul><li>只需要一个控制点(x1,y1)</li><li>(x,y)为终点坐标</li></ul><h5 id="延长的平滑二阶贝塞尔曲线"><a href="#延长的平滑二阶贝塞尔曲线" class="headerlink" title="延长的平滑二阶贝塞尔曲线"></a>延长的平滑二阶贝塞尔曲线</h5><p>可以将多个贝塞尔曲线衔接起来，形成一条更长的曲线<br><span class="strong">T x y</span></p><ul><li>只需要指定曲线终点坐标(x,y)</li><li>如果该命令前为另一个Q命令或T命令，该命令会把上一个命令控制点关于曲线终点的中心对称点作为其控制点</li><li>如果该命令单独使用，则会认为控制点和终点为同一点，绘制一条直线<div class="show">&lt;path d="M 10 80 Q 50 200 100 100 T 200 120"/></div><svg width="220" height="200" style="display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;"> <circle cx="10" cy="80" r="4" style="fill:#f00;"/><circle cx="50" cy="196" r="4" style="fill:#f00;"/><circle cx="100" cy="100" r="4" style="fill:#f00;"/><polyline points="10 80, 50 196,100 100" style="stroke:f00;" /><circle cx="150" cy="4" r="4" style="fill:#00f;"/><circle cx="200" cy="120" r="4" style="fill:#00f;"/><polyline points="100 100, 150 4,200 120" style="stroke:#00f;" /><path d="M 10 80 Q 50 200 100 100 T 200 120"/></svg></li></ul><h4 id="三阶贝塞尔曲线"><a href="#三阶贝塞尔曲线" class="headerlink" title="三阶贝塞尔曲线"></a>三阶贝塞尔曲线</h4><p>通过指定两个控制点，一个终点坐标绘制曲线<br><span class="strong">C x1 y1, x2 y2, x y</span></p><ul><li>(x1,y1)(x2,y2)为控制点坐标</li><li>(x,y)为曲线终点坐标</li><li>c小写时(x,y)应当为上一个路径终点的相对坐标(dx,dy)<div class="show">&lt;path d="M 10 10 C 0 200, 150 20, 300 300 "/></div></li></ul><p>同理，可以将多个三阶贝塞尔曲线衔接起来，形成一条更长的曲线<br><span class="strong">S x2 y2, x y</span></p><ul><li>(x2,y2)为控制点坐标</li><li>(x,y)为终点坐标</li><li>如果该命令跟在一个 C 或 S 命令后面，则该曲线的第一个控制点会被设置为前一个曲线第二个控制点关于曲线终点的中心对称点(以此保持斜率不变来保证曲线可以平滑衔接)<div class="show">&lt;path d="M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 "/></div><svg width="400" height="200" style="display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;"><circle cx="10" cy="10" r="4" style="fill:#f00;"/><circle cx="10" cy="150" r="4" style="fill:#f00;"/><circle cx="150" cy="20" r="4" style="fill:#f00;"/><circle cx="200" cy="50" r="4" style="fill:#f00;"/><line x1="10" y1="10" x2="10" y2="150" style="stroke:#f00;" /><line x1="150" y1="20" x2="200" y2="50" style="stroke:#f00;" /><circle cx="250" cy="80" r="4" style="fill:#00f;"/><circle cx="160" cy="150" r="4" style="fill:#00f;"/><circle cx="396" cy="100" r="4" style="fill:#00f;"/><line x1="200" y1="50" x2="250" y2="80" style="stroke:#00f;" /><line x1="160" y1="150" x2="396" y2="100" style="stroke:#00f;" /><path d="M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 "/></svg></li></ul><h3 id="颜色与样式"><a href="#颜色与样式" class="headerlink" title="颜色与样式"></a>颜色与样式</h3><h4 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h4><p>默认情况下，创建路径后不会进行描边，需要使用<span class="stroke">stroke</span>属性指定描边颜色</p><ul><li><span class="strong">stroke=”颜色” 指定描边颜色，取值同CSS</span></li><li><span class="strong">stroke-opacity=”值” 单独指定不透明度</span></li><li><span class="strong">stroke-width=”值” 指定描边线宽度</span></li></ul><h4 id="描边终点与折点样式"><a href="#描边终点与折点样式" class="headerlink" title="描边终点与折点样式"></a>描边终点与折点样式</h4><ul><li><span class="strong">stroke-linecap=”butt/round/square”  描边终点为正常(平头截断)/圆形线帽/矩形线帽</span></li><li><span class="strong">stroke-linejoin=”miter/round/bevel” 描边折点为尖角/圆角/切角</span></li><li><span class="strong">stroke-miterlimit=”值” 设置折点斜切面的限制长度</span></li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>具体样式区别可以参考这篇博文：<a href="http://localhost:4000/blog/2023/05/03/canvas/#%E7%BA%BF%E6%AE%B5%E6%8A%98%E7%82%B9" target="_blank">canvas绘制线段-实线部分</a></div><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>默认情况下，闭合图形或路径的填充色为黑色，可以通过<span class="tips">fill</span>属性修改</p><ul><li><span class="strong">fill=”颜色” 指定填充颜色，取值同CSS</span></li><li><span class="strong">fill-opacity=”值” 单独指定填充不透明度</span></li></ul><h4 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h4><ul><li><span class="strong">stroke-dasharray=”值,值…” 设置虚线线段和间隙的长度</span></li><li><span class="strong">stroke-dashoffset=”值” 设置虚线偏移值</span></li></ul><h4 id="使用CSS定义样式"><a href="#使用CSS定义样式" class="headerlink" title="使用CSS定义样式"></a>使用CSS定义样式</h4><p>svg的属性除了能在标签属性中定义外，也能在CSS中直接声明，但仅适用于部分属性</p><ul><li>stroke</li><li>fill</li></ul><h3 id="特殊标签"><a href="#特殊标签" class="headerlink" title="特殊标签"></a>特殊标签</h3><h4 id="defs标签"><a href="#defs标签" class="headerlink" title="defs标签"></a>defs标签</h4><p>defs标签用于定义需要重复使用的图形元素，该标签中定义的图形元素不会直接呈现，只供后续调用</p><h4 id="g标签"><a href="#g标签" class="headerlink" title="g标签"></a>g标签</h4><p>容器标签，用于包含一组标签，然后将该组标签的共同样式属性添加到g标签上，这样该属性值会对所有子标签继承。注意：g标签不支持使用x,y属性来进行定位，需要修改位置时，可以使用transform属性或CSS修改</p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><p>在<span class="tips">&lt;defs&gt;</span>标签内创建一个<span class="tips">&lt;linearGradient&gt;</span>标签，在该标签内定义线性渐变，并通过<span class="tips">&lt;stop/&gt;</span>标签的属性定义颜色、渐变位置、不透明度，然后在需要调用的图形中，用<span class="tips">fill</span>属性或<span class="tips">stroke</span>属性调用<span class="tips">url</span>引用<span class="tips">&lt;linearGradient&gt;</span>标签的<span class="tips">ID</span>值(调用类名无效)</p><p><span class="strong">&lt;linearGradient x1=”0” x2=”1” y1=”0” y2=”0”&gt;&lt;/linearGradient&gt;</span></p><ul><li>x1,x2,y1,y2通过确定两个点来定义渐变路径走向，一般取值0-1间的小数，取大于1的值将导致渐变超出图形范围(溢出的渐变部分不可见)</li><li>默认从左往右，即x1=”0” x2=”1” y1=”0” y2=”0”</li><li>x1=”0” x2=”0” y1=”0” y2=”1”即调整为从上到下</li></ul><p><span class="strong">&lt;stop offset=”50%” stop-color=”#00f” /&gt;</span></p><ul><li>offset属性定义颜色渐变(偏移)位置，可以取0%-100%，也可以取0-1间的小数</li><li>stop-color定义颜色，取值同CSS</li><li>stop-opacity定义不透明度</li></ul><div class="show">&lt;defs>     &lt;linearGradient id="G1">          &lt;stop offset="0%" stop-color="red"/>          &lt;stop offset="50%" stop-color="yellow"/>          &lt;stop offset="100%" stop-color="blue"/>     &lt;/linearGradient>&lt;/defs>&lt;rect x="0" y="0" rx="10" ry="10" width="300" height="300" fill="url(#G1)"/></div><h4 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h4><p>与线性渐变类似，径向渐变需要在<span class="tips">&lt;defs&gt;</span>标签内创建一个<span class="tips">&lt;radialGradient&gt;</span>标签，然后通过<span class="tips">&lt;stop/&gt;</span>标签的属性定义颜色、渐变位置、不透明度</p><p><span class="strong">&lt;radialGradient cx=”.5” cy=”.5” r=”.5” fx=”.2” fy=”.2”&gt;&lt;radialGradient&gt;</span></p><ul><li>cx,cy定义渐变结束所围绕的圆环，取值0-1</li><li>r定义渐变圆在当前图形中的占用半径，一般取值0-1，大于1将导致渐变溢出图形</li><li>fx,fy定义渐变开始的位置</li></ul><div class="show">&lt;defs>     &lt;radialGradient cx=".5" cy=".5" r=".5" fx=".2" fy=".2"  id="R1">          &lt;stop offset="0%" stop-color="red"/>          &lt;stop offset="25%" stop-color="yellow"/>          &lt;stop offset="50%" stop-color="blue"/>          &lt;stop offset="75%" stop-color="green"/>          &lt;stop offset="100%" stop-color="purple"/>     &lt;/radialGradient>&lt;/defs>&lt;rect class="fillRect" x="0" y="0"  width="200" height="200" fill="url(#R1)"/>1. 渐变开始位置为矩形图20%,20%位置2. 渐变结束所形成的圆环：圆心位于矩形50%,50%点处，半径为矩形长的50%</div><svg width="200" height="200" xmlns="radialGradientSVG" style="display:block;margin:0 auto;"><defs><radialGradient cx=".5" cy=".5" r=".5" fx=".2" fy=".2"  id="R1"><stop offset="0%" stop-color="red"/><stop offset="25%" stop-color="yellow"/><stop offset="50%" stop-color="blue"/><stop offset="75%" stop-color="green"/><stop offset="100%" stop-color="purple"/></radialGradient></defs><rect class="fillRect" x="0" y="0"  width="200" height="200" fill="url(#R1)"/></svg><h4 id="spreadMethod属性"><a href="#spreadMethod属性" class="headerlink" title="spreadMethod属性"></a>spreadMethod属性</h4><p>spreadMethod属性用于指定渐变到达终点的行为，默认情况下，offset为100%时的颜色会填充剩余部分，该属性对线性渐变和径向渐变均生效</p><ul><li>pad(默认)，渐变结束后使用终点颜色填充剩下区域</li><li>reflect，渐变结束后按反向颜色顺序填充剩下区域</li><li>repeat，渐变结束后从头开始填充剩下区域</li></ul><div class="show">&lt;linearGradient  id="g2" x1="0" x2=".5" y1="0" y2="0" spreadMethod="pad">//            &lt;stop offset="0%" stop-color="red"/>            &lt;stop offset="33%" stop-color="yellow"/>            &lt;stop offset="66%" stop-color="blue"/>            &lt;stop offset="100%" stop-color="green"/>&lt;/linearGradient>1. x2=".5"指定了颜色渐变填充到矩形的50%位置2. pad值会用终点颜色填充剩下区域3. reflect值会按绿，蓝，黄，红顺序(与原顺序相反)填充剩下区域3. repeat值会按颜色顺序(从头开始)填充剩下区域</div><svg style="display:block;margin:0 auto;" width="340" height="200" xmlns="spreadMethodSVG"><defs><linearGradient  id="g2" x1="0" x2=".5" y1="0" y2="0" spreadMethod="pad">            <stop offset="0%" stop-color="red"/>            <stop offset="33%" stop-color="yellow"/>            <stop offset="66%" stop-color="blue"/>            <stop offset="100%" stop-color="green"/>        </linearGradient>        <linearGradient  id="g3" x1="0" x2=".5" y1="0" y2="0" spreadMethod="reflect">            <stop offset="0%" stop-color="red"/>            <stop offset="33%" stop-color="yellow"/>            <stop offset="66%" stop-color="blue"/>            <stop offset="100%" stop-color="green"/>        </linearGradient>        <linearGradient  id="g4" x1="0" x2=".5" y1="0" y2="0" spreadMethod="repeat">            <stop offset="0%" stop-color="red"/>            <stop offset="33%" stop-color="yellow"/>            <stop offset="66%" stop-color="blue"/>            <stop offset="100%" stop-color="green"/>        </linearGradient></defs>        <rect  x="0" y="0" width="100" height="130" fill="url(#g2)"/>        <rect  x="110" y="0" width="100" height="130" fill="url(#g3)"/>        <rect  x="220" y="0" width="100" height="130" fill="url(#g4)"/></svg><h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>与canvas相同，svg也有一个模板对象，常用于定义需要重复填充的背景图等。与渐变一样，&lt;pattern&gt; 也需要定义在的 &lt;defs&gt; 内部，然后使用其他图形引用Patterns的ID<br><span class="strong">&lt;pattern x=”0” y=”0” width=”.25” height=”.25”&gt;&lt;/pattern&gt;</span></p><ul><li>x,y定义Pattern图形的开始位置</li><li>width,height决定该Pattern图形会在x轴和y轴上重复几次，0.25意味着将在横轴和纵轴方向上均重复4次</li></ul><div class="show">&lt;svg width="200" height="200">        &lt;defs>&lt;pattern id="Pattern" x="0" y="0" width=".25" height=".25">&lt;rect x="0" y="0" width="50" height="50" fill="skyblue"/>&lt;circle cx="25" cy="25" r="20" fill="yellow" fill-opacity="0.5"/>    &lt;/pattern>        &lt;/defs>&lt;rect fill="url(#Pattern)" stroke="black" x="0" y="0" width="200" height="200"/>    &lt;/svg></div><p><svg width="200" height="200" xmlns="pattern" style="display:block;margin:0 auto;"><defs><pattern id="pattern" x="0" y="0" width=".25" height=".25"><rect x="0" y="0" width="50" height="50" fill="skyblue" stroke="#000"/><circle cx="25" cy="25" r="20" fill="yellow" fill-opacity="0.5"/></pattern></defs><rect fill="url(#pattern)" x="0" y="0" width="200" height="200"/><br></svg></p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="text标签"><a href="#text标签" class="headerlink" title="text标签"></a>text标签</h4><p><span class="strong">&lt;text x=”0” y=”0”&gt;&lt;/text&gt;</span></p><ul><li>x,y定义文字左下角在SVG中的开始位置(y值)</li><li>通过fill属性和stroke属性指定文字填充/描边颜色</li><li>text-anchor属性决定文本开始方向，可取值：start、middle、end、inherit(该属性一般用于阿拉伯语等从右到左阅读的语言)</li><li>以下属性定义文字大小、字间距等，可以直接定义在标签中，也可以定义在CSS中，取值和CSS大致相同：<span class="tips">font-family</span>、<span class="tips">font-style</span>、<span class="tips">font-weight</span>、<span class="tips">font-size</span>、<span class="tips">letter-spacing</span>、<span class="tips">word-spacing</span>、<span class="tips">text-decoration</span>、<span class="tips">font-variant</span>、<span class="tips">font-size-adjust</span>等，注意，文字的填充和描边需要使用<span class="tip">fill</span>和<span class="tips">stroke</span>属性指定颜色</li></ul><div class="show">&lt;style> #svgText{            text-anchor:start;            fill: red;            font-size: 20px;            font-weight: 900;        }&lt;/style>&lt;svg width="600" height="600"  xmlns="http://www.w3.org/2000/svg">&lt;text id="svgText" x="10" y="30">手写的从前&lt;/text>&lt;/svg></div><h4 id="tspan标签"><a href="#tspan标签" class="headerlink" title="tspan标签"></a>tspan标签</h4><p>tspan标签常用于标记出一段文本中的特殊部分，如将某句话的关键词加粗标识，该标签必须包含于<span class="tips">text</span>标签或<span class="tips">tspan</span>标签中<br><span class="strong">&lt;tspan&gt;文本内容&lt;/tspan&gt;</span></p><ul><li>该标签需要置于父级text标签或tspan标签内，且文本在svg的位置跟随父级标签</li><li>x,y属性可以为该标签设置一个新的位置坐标，该坐标是相对于svg的坐标原点，无视父级坐标</li><li>dx,dy属性可以在父级坐标的基础上，进行偏移</li><li>rotate属性可以将文字 进行旋转</li><li>上述属性都允许赋值一个数列，表示为tspan标签中的每个字符设置单独的坐标/旋转值</li></ul><div class="show">1. x和y属性是相对于SVG的坐标，可能导致tspan标签内容覆盖到父级文本之上&lt;text y="20" fill="#fff">父级标签&lt;tspan x="20" fill="red">x属性&lt;/tspan>父级标签&lt;/text>2. dx,dy属性是在父级坐标基础上进行位移&lt;text y="20" fill="#fff">父级标签&lt;tspan dx="20" fill="red">dx属性&lt;/tspan>父级标签&lt;/text>3. x,y,dx,dy的属性值可以为一组数列值，依次指定标签中每个字符的坐标&lt;text y="20" fill="#fff">父级标签&lt;tspan dx="20,25,30,35" fill="red">dx属性赋值数列&lt;/tspan>父级标签&lt;/text>4. rotate属性值也可以是单个，或者为一组数列，对字符进行旋转&lt;text y="20" fill="#fff">父级标签&lt;tspan rotate="20,30,40,50,60,70,80" fill="red">dx属性赋值数列&lt;/tspan>父级标签&lt;/text></div><p><svg width="400" height="180" xmlns="tspan" style="display:block;margin:0 auto;font-size:18px;"><rect x="0" y="0" width="400" height="400" fill="skyblue" /><text x="0" y="20" fill="#fff">1.父级标签<tspan x="20" fill="red">x属性</tspan>父级标签</text><text x="0" y="60" fill="#fff">2.父级标签<tspan  dx="20" fill="red">dx属性</tspan>父级标签</text><text x="0" y="100" fill="#fff">3.父级标签<tspan  dx="20,25,30,35,40" fill="red">dx属性赋值数列</tspan>父级标签</text><text x="0" y="140" fill="#fff">4.父级标签<tspan  rotate="20,30,40,50,60,70,80" fill="red">rotate属性赋值数列</tspan>父级标签</text><br></svg></p><h4 id="textPath标签"><a href="#textPath标签" class="headerlink" title="textPath标签"></a>textPath标签</h4><p>textPath可创建出跟随路径排列的文本，需要通过<span class="tips">xlink:href</span>属性引用路径ID</p><div class="show">&lt;path d="M 10 80 Q 50 200 100 100 T 200 120" id="my_path" fill="none" stroke="red"/>&lt;text fill="skyblue" font-size="20">&lt;textPath  xlink:href="#my_path">So live a life you will remember&lt;/textPath>&lt;/text></div><p><svg width="300" height="150" xmlns="textPath" style="display:block;margin:0 auto;"><path d="M 10 80 Q 50 200 100 100 T 200 120" id="my_path" fill="none" stroke="red"/><text fill="skyblue" font-size="20"> <textPath  xlink:href="#my_path">So live a life you will remember</textPath><br></svg></p><h3 id="变形、剪切、遮罩、图片"><a href="#变形、剪切、遮罩、图片" class="headerlink" title="变形、剪切、遮罩、图片"></a>变形、剪切、遮罩、图片</h3><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><ul><li><span class="strong">transform=”translate(x,y)” 平移</span>(如果只指定一个值，则默认第二个值为0)</li><li><span class="strong">transform=”rotate(角度值)” 沿着图形左上角顺时针(正值)旋转</span></li><li><span class="strong">transform=”skewX(角度值)或skewY(角度值)” 在x/y轴方向上斜切</span></li><li><span class="strong">transform=”scale(x缩放,y缩放)” 在x/y轴进行缩放</span>(如果只指定一个值，则默认第二个值等于第一个值)</li><li>多个属性值可以写到一个transform中，用空格隔开</li></ul><div class="show"> &lt;rect x="0" y="0" width="200" height="200" fill="red" transform="translate(50,10) scale(.2,1.2) rotate(60)"/></div><h4 id="clipPath剪切"><a href="#clipPath剪切" class="headerlink" title="clipPath剪切"></a>clipPath剪切</h4><p>定义一个<span class="tips">clipPath</span>标签并指定路径或图形，然后在需要裁剪的目标元素上使用<span class="tips">clip-path</span>属性调用<span class="tips">clipPath</span>标签的ID值进行裁剪，剪裁会保留二者相同部分，对其余部分进行裁剪。该标签一般定义于<span class="tips">defs</span>标签中</p><div class="show">&lt;defs>        &lt;clipPath id="cut">            &lt;rect x="200" y="200" width="200" height="100"/>        &lt;/clipPath>    &lt;/defs> &lt;circle cx="300" cy="300" r="100" fill="yellow" clip-path="url(#cut)"/></div><h4 id="mask遮罩"><a href="#mask遮罩" class="headerlink" title="mask遮罩"></a>mask遮罩</h4><p> 遮罩常用于制作淡出淡入效果，<span class="tips">mask</span>标签定义于defs标签中，然后在需要添加遮罩的标签中使用<span class="tips">mask</span>属性引用遮罩ID</p> <div class="show">&lt;defs>    &lt;linearGradient id="Gradient">      &lt;stop offset="0" stop-color="white" stop-opacity="0"/>      &lt;stop offset="1" stop-color="white" stop-opacity="1"/>    &lt;/linearGradient>    &lt;mask id="Mask">      &lt;rect x="0" y="0" width="200" height="200" fill="url(#Gradient)"/>    &lt;/mask>&lt;/defs><p>  &lt;rect x=”0” y=”0” width=”200” height=”200” fill=”green”/&gt;<br>  &lt;rect x=”0” y=”0” width=”200” height=”200” fill=”red” mask=”url(#Mask)” /&gt;</div></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>SVG使用<span class="tips">image</span>标签插入图片，并且可以在图像上使用剪切、变形、遮罩等SVG提供的功能<br><span class="strong">&lt;image xlink:href=””/&gt;</span></p><ul><li>可以使用x,y属性指定图片位置</li><li>可以使用width,height属性指定图片宽高</li><li>xlink:href属性用于指定图片地址<div class="show">&lt;image x="50" y="50" width="300" height="300"  xlink:href="../dog.jpg"/></div></li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>SVG中还有链接、动画、滤镜等标签，详见MDN文档:<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element</a></div>]]></content>
    
    
    <summary type="html">svg标签的使用方法，包括基本图形的绘制，贝塞尔曲线的绘制，颜色样式的设置，渐变、变形、剪切、遮罩的添加，以及文字和图片的绘制</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="html" scheme="https://shiwei11.github.io/blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Canvas</title>
    <link href="https://shiwei11.github.io/blog/2023/05/03/canvas/"/>
    <id>https://shiwei11.github.io/blog/2023/05/03/canvas/</id>
    <published>2023-05-03T00:59:30.000Z</published>
    <updated>2023-10-19T08:06:26.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p><span class="tips">canvas</span>是HTML5新增的标签，用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面，canvas不支持IE8及IE8以下浏览器</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>具体的兼容性可以参考MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas</a></div><h4 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h4><h5 id="通过HTML标签"><a href="#通过HTML标签" class="headerlink" title="通过HTML标签"></a>通过HTML标签</h5><p>可以通过直接添加HTML标签的方式创建canvas，并设置画布的宽高，然后通过<span class="tips">getContext()</span>方法获得画布的 2D 渲染上下文对象，需要为该方法提供<span class="tips">‘2d’</span>作为参数，该对象提供了用于在画布上绘图的方法和属性</p><pre><code>&lt;body>    &lt;canvas width="600" height="400" id="canvas">&lt/canvas>    &ltscript>        const canvas=document.getElementById('canvas');        const context = canvas.getContext('2d');    &lt;/script>&lt;/body></code></pre><h5 id="通过JavaScript动态创建"><a href="#通过JavaScript动态创建" class="headerlink" title="通过JavaScript动态创建"></a>通过JavaScript动态创建</h5><p>也可以通过JavaScript动态添加canvas并指定宽高，tips:通过JavaScript创建的canvas在写代码时IDE会有代码补全提示</p><pre><code> const canvas=document.createElement("canvas");    canvas.width=600;    canvas.height=400;    document.body.appendChild(canvas); const context = canvas.getContext('2d');</code></pre><h5 id="画布尺寸的说明"><a href="#画布尺寸的说明" class="headerlink" title="画布尺寸的说明"></a>画布尺寸的说明</h5><ul><li>canvas需要通过属性来设置宽度、高度，且不需要单位</li><li>通过CSS设置canvas的width和height属性，仅用于缩放图像，无法改变画布尺寸，当CSS指定的宽高与画布的宽高比例不一致时，图像会出现扭曲</li><li>默认画布大小为300px * 150px，宽高比为2:1，如果不指定画布的宽高，或者设置了无效值(如负数)，则会使用默认值</li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>通过CSS设置的Canvas宽高样式只会修改浏览器渲染后所显示图像的宽高，不会修改画布本身及其图像本身的宽高。浏览器会在渲染期间根据CSS对源图像进行伸缩，以适应指定的CSS样式大小。如果 CSS 的指定的宽高尺寸与画布的宽高比例不一致，图像有可能出现扭曲。而通过属性修改的画布宽度和高度，实际会修改Canvas DOM对象的属性值，即画布本身的宽度和高度，并将该DOM对象传递给canvas内部的2d渲染上下文环境对象(CanvasRenderingContext2D)</div><h4 id="兼容性检查"><a href="#兼容性检查" class="headerlink" title="兼容性检查"></a>兼容性检查</h4><p>IE9之前的浏览器不支持Canvas，如果不兼容canvas，canvas 标签会被浏览器解析为自定义标签，显示标签内的提示信息</p><div class="show">&lt;canvas id="canvas">抱歉，您的浏览器不支持 canvas 标签&lt;/canvas></div>    同时要做好JavaScript兼容性检查<div class="show">const canvas = document.getElementById('canvas');        if (canvas.getContext){          const ctx = canvas.getContext('2d');        }</div><h1 id="Canvas-2D渲染API"><a href="#Canvas-2D渲染API" class="headerlink" title="Canvas 2D渲染API"></a>Canvas 2D渲染API</h1><p>所有API都是基于canvas的2d渲染上下文对象，文中以context或ctx为对象名</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><ul><li><p><span class="strong">moveTo(x,y) 移动画笔到指定坐标</span><br>指定画笔最先开始绘制的点，此后Canvas的绘制方法都是基于上一次的路径终点进行的，仍可以使用moveTo(x,y)修改画笔的坐标到路径终点以外</p></li><li><p><span class="strong">context.beginPath() 创建一个新路径</span></p></li></ul><p>在同一个画布中绘制多个独立的图像，应当为每个图像创建不同的子路径，如:为不同的线段设置不同的颜色、线宽等样式，应当为每个线段创建独立的子路径，每个路径内部的样式、属性单独声明，否则后声明的样式会覆盖前面的样式，并且应当为每个独立的路径指定画笔初始点，执行绘制方法</p><div class="show">const canvasPath=document.getElementById("canvasPath");   const ctxPath = canvasPath.getContext('2d');        ctxPath.lineWidth=5;        ctxPath.beginPath();        ctxPath.strokeStyle="red";        ctxPath.moveTo(150,50);        ctxPath.lineTo(50,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="blue";        ctxPath.moveTo(50,200);        ctxPath.lineTo(250,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="yellow";        ctxPath.moveTo(250,200);        ctxPath.lineTo(150,50);        ctxPath.stroke();</div><canvas width="300" height="300" id="canvasPath" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas><script>   const canvasPath=document.getElementById("canvasPath");   const ctxPath = canvasPath.getContext('2d');        ctxPath.lineWidth=5;        ctxPath.beginPath();        ctxPath.strokeStyle="red";        ctxPath.moveTo(150,50);        ctxPath.lineTo(50,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="blue";        ctxPath.moveTo(50,200);        ctxPath.lineTo(250,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="yellow";        ctxPath.moveTo(250,200);        ctxPath.lineTo(150,50);        ctxPath.stroke();</script><p>在使用循环定时器创建动画时，往往需要在每次定时器执行时创建一个新路径，避免上次的路径影响到本次路径的绘制</p><div class="show">const canvas=document.createElement("canvas");        canvas.width=300;        canvas.height=300;        document.body.appendChild(canvas);        const ctx = canvas.getContext('2d');        let cpx=10;        let timer=setInterval(()=>{        ctx.beginPath();//每次计时器开始时，开始新路径        ctx.clearRect(0,0,300,300);//清空画布        ctx.moveTo(50,50);        ctx.quadraticCurveTo(cpx+=10,100,50,250);//动态绘制贝塞尔曲线        ctx.stroke();        if(cpx>=250){            clearInterval(timer)        }        },50)</div><ul><li><span class="strong">context.closePath(); 闭合当前子路径</span><br>将画笔坐标移回到当前子路径起始点，该方法会尝试从当前点到起始点绘制一条直线，如果图形已经是封闭的或者只有一个点，该方法不会做任何操作，可用于闭合图形</li></ul><div class="show">const canvasLine=document.getElementById("canvasLine");        const ctxLine = canvasLine.getContext('2d');        ctxLine.lineWidth=3;        ctxLine.moveTo(150,50);        ctxLine.lineTo(100,150);        ctxLine.lineTo(200,150);        ctxLine.closePath();        ctxLine.stroke();</div><h4 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h4><ul><li><span class="strong">context.stroke() 绘制当前路径</span></li><li><span class="strong">context.lineWidth=值; 修改描边线条的宽度</span></li><li><span class="strong">context.strokeStyle=”颜色/渐变对象/Pattern对象”; 设置描边样式</span></li></ul><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><ul><li><span class="strong">context.fill() 填充已闭合的路径</span></li><li><span class="strong">context.fillStyle=”颜色/渐变对象/Pattern对象”; 设置填充的样式</span></li></ul><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><p><span class="strong">context.clip() 根据当前路径进行裁剪</span><br>沿着路径进行裁剪，裁剪路径外的图形将不再显示在Canvas中</p><h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><p><span class="strong">context.clearRect(x,y,width,height) 清除指定区域内的画布内容</span></p><div class="show">context.clearRect(0,0,canvas.width,canvas.height)//清空整个画布</div><h4 id="封装路径-Path2D对象"><a href="#封装路径-Path2D对象" class="headerlink" title="封装路径-Path2D对象"></a>封装路径-Path2D对象</h4><p> <span class="strong">let myPath2D=new Path2D();</span><br>返回一个Path2D对象，之后可以将路径添加到该对象中，并直接重用对象中的所有路径，stroke()、fill()、clip()均接收该对象作为参数</p><div class="show">const canvas=document.getElementById("canvas");        const context = canvas.getContext('2d');        let myDesign=new Path2D();        //将路径封装到Path2D对象中而非context对象上        myDesign.moveTo(50,50);        myDesign.lineTo(100,50);        myDesign.lineTo(100,100);        myDesign.lineTo(50,100);        myDesign.lineTo(50,50);        //之后可以直接重用封装好的路径        context.stroke(myDesign);//描边        context.fill(myDesign);//填充        context.clip(myDesign);//裁剪</div><h4 id="位置判断"><a href="#位置判断" class="headerlink" title="位置判断"></a>位置判断</h4><ul><li><span class="strong">context.isPointInStroke(x, y) 返回boolean值，判断(x,y)点是否在当前路径上</span></li><li><span class="strong">context.isPointInStroke(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径上</span></li><li><span class="strong">context.isPointInPath(x, y) 返回boolean值，判断(x,y)点是否在当前路径内</span></li><li><span class="strong">context.isPointInPath(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径内</span></li></ul><h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><h4 id="实线线段"><a href="#实线线段" class="headerlink" title="实线线段"></a>实线线段</h4><h5 id="线段路径"><a href="#线段路径" class="headerlink" title="线段路径"></a>线段路径</h5><p><span class="strong">context.lineTo(x,y) 连接直线路径到指定坐标</span></p><h5 id="线段折点"><a href="#线段折点" class="headerlink" title="线段折点"></a>线段折点</h5><p><span class="strong">context.lineJoin=”miter/round/bevel”; </span></p><p>设置或返回两条线交汇时，线段折线处的样式</p><ul><li><strong>miter</strong> 尖锐折线(默认)</li><li><strong>round</strong> 圆角折线</li><li><strong>bevel</strong> 切角折线</li></ul><p><span class="strong">ctx.miterLimit = value; </span><br>设置或返回边角斜切面的限制长度(默认为10)，下图为miterLimit=2(左)以及miterLimit=10(右)的区别<br><canvas width="300" height="150" id="canvasLimit" style="display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasLimit=document.getElementById("canvasLimit");        const ctxLimit = canvasLimit.getContext('2d');        ctxLimit.lineWidth=20;        ctxLimit.lineJoin="miter";        ctxLimit.beginPath();        ctxLimit.miterLimit=2;        ctxLimit.moveTo(40,20);        ctxLimit.lineTo(70,100);        ctxLimit.lineTo(100,20);        ctxLimit.stroke();        ctxLimit.beginPath();        ctxLimit.miterLimit=10;        ctxLimit.moveTo(190,20);        ctxLimit.lineTo(220,100);        ctxLimit.lineTo(250,20);        ctxLimit.stroke();       </script><h5 id="线段末端"><a href="#线段末端" class="headerlink" title="线段末端"></a>线段末端</h5><p><span class="strong">context.lineCap=”butt/round/square;”</span></p><p>设置或返回线段末端线帽的样式，”round” 和 “square” 值会使线条略微变长</p><ul><li><strong>butt</strong> 末端以方形结束(默认)</li><li><strong>round</strong>末端添加圆形线帽</li><li><strong>square</strong>末端添加一个宽度相同，长度为宽度一半的矩形线帽</li></ul><p><canvas width="400" height="150" id="canvasLine" style="display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasLine=document.getElementById("canvasLine");        const ctxLine = canvasLine.getContext('2d');        ctxLine.lineWidth=10;        ctxLine.beginPath();        ctxLine.lineCap="butt";        ctxLine.lineJoin="miter";        ctxLine.moveTo(90,50);        ctxLine.lineTo(150,50);        ctxLine.lineTo(190,10);        ctxLine.lineTo(230,50);        ctxLine.lineTo(290,50);        ctxLine.stroke();        ctxLine.beginPath();        ctxLine.lineCap="round";        ctxLine.lineJoin="round";        ctxLine.moveTo(90,100);        ctxLine.lineTo(150,100);        ctxLine.lineTo(190,60);        ctxLine.lineTo(230,100);        ctxLine.lineTo(290,100);        ctxLine.stroke();        ctxLine.beginPath();        ctxLine.lineCap="square";        ctxLine.lineJoin="bevel";        ctxLine.moveTo(90,140);        ctxLine.lineTo(150,140);        ctxLine.lineTo(190,100);        ctxLine.lineTo(230,140);        ctxLine.lineTo(290,140);        ctxLine.stroke();        ctxLine.beginPath();        ctxLine.setLineDash([5,10]);        ctxLine.lineWidth=1;        ctxLine.strokeStyle="red";        ctxLine.moveTo(90,0)        ctxLine.lineTo(90,200)        ctxLine.moveTo(290,0)        ctxLine.lineTo(290,200)        ctxLine.stroke();</script><h4 id="虚线线段"><a href="#虚线线段" class="headerlink" title="虚线线段"></a>虚线线段</h4><ul><li><span class="strong">context.setLineDash([数组]);</span> 传递一个数组来指定虚线线段和间隙的交替长度，空数组将设置为实线</li><li><span class="strong">context.getLineDash();</span> 返回一个数组，获取当前线段的样式</li></ul><div class="show">context.setLineDash([2,10,5,10])context.moveTo(0,0)context.lineTo(100,200);context.stroke();</div><p><span class="strong">context.lineDashOffset = value;</span><br>设置虚线偏移值，可实现蚂蚁线效果</p><div class="show">const canvasDash=document.getElementById("canvasDash");   const ctxDash = canvasDash.getContext('2d');   let offset=0;   ctxDash.lineWidth=5;   ctxDash.setLineDash([30,20])   ctxDash.setLineDash([30,20])   ctxDash.moveTo(0,100)   ctxDash.lineTo(300,100);   function render(){       offset++;    if(offset>50){        offset=0    }    ctxDash.clearRect(0,0,300,300)    ctxDash.lineDashOffset=offset;    ctxDash.stroke();    requestAnimationFrame(render)    }    render();</div><canvas width="300" height="300" id="canvasDash" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas><script>  const canvasDash=document.getElementById("canvasDash");   const ctxDash = canvasDash.getContext('2d');   let offset=0;   ctxDash.lineWidth=5;   ctxDash.setLineDash([30,20])   ctxDash.setLineDash([30,20])   ctxDash.moveTo(0,100)   ctxDash.lineTo(300,100);   function render(){       offset++;    if(offset>50){        offset=0    }    ctxDash.clearRect(0,0,300,300)    ctxDash.lineDashOffset=offset;    ctxDash.stroke();    requestAnimationFrame(render)    }    render();</script><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><h5 id="矩形路径"><a href="#矩形路径" class="headerlink" title="矩形路径"></a>矩形路径</h5><p><span class="strong">context.rect(x,y,width,height) 创建矩形路径</span></p><ul><li>x, y为矩形坐标</li><li>width为矩形的宽度，正值矩形位于x坐标右侧，负值则位于左侧</li><li>height为矩形的高度，正值矩形位于y坐标下方，负值则在上方</li></ul><p>仅创建矩形路径，不会显示在画布中，可以使用stroke()方法或fill()方法进行描边绘制或者填充绘制</p><h5 id="描边矩形"><a href="#描边矩形" class="headerlink" title="描边矩形"></a>描边矩形</h5><p><span class="strong">context.strokeRect(x, y, width, height) 绘制描边矩形</span></p><p>创建矩形路径并描边，参数同上，相当于rect()方法和stroke()方法同时执行，可以使用<span class="tips">lineWidth</span>修改线宽，使用<span class="tips">strokeStyle</span>修改线条样式</p><h5 id="填充矩形"><a href="#填充矩形" class="headerlink" title="填充矩形"></a>填充矩形</h5><p><span class="strong">context.fillRect(x, y, width, height) 填充一个矩形</span></p><p>创建矩形路径并填充，参数同上，相当于rect()方法和fill()方法同时执行，可以使用<span class="tips">fillStyle</span>修改填充样式</p><h3 id="渐变对象"><a href="#渐变对象" class="headerlink" title="渐变对象"></a>渐变对象</h3><h4 id="添加渐变色"><a href="#添加渐变色" class="headerlink" title="添加渐变色"></a>添加渐变色</h4><p><span class="strong">渐变对象名.addColorStop(偏移量,”颜色”)</span></p><ul><li>对象名为以下三种渐变对象创建的实例</li><li>偏移量为0~1之间的值，代表渐变开始到渐变终止的位置，等同于CSS中的百分比位置</li><li>颜色取值同CSS</li></ul><h4 id="线性渐变对象"><a href="#线性渐变对象" class="headerlink" title="线性渐变对象"></a>线性渐变对象</h4><p><span class="strong">context.createLinearGradient(x1,y1,x2,y2)</span><br>在(x1,y1)到(x2,y2)矢量方向上创建径向渐变对象，并返回该对象</p><div class="show">const ctx = canvas.getContext('2d');const gradient=ctx.createLinearGradient(0,0,600,400);        gradient.addColorStop(0,"red");        gradient.addColorStop(.3,"#df0");        gradient.addColorStop(1,"blue");        ctx.strokeStyle=gradient;</div><h4 id="径向渐变对象"><a href="#径向渐变对象" class="headerlink" title="径向渐变对象"></a>径向渐变对象</h4><p><span class="strong">context.createRadialGradient(x0, y0, r0, x1, y1, r1);</span><br>以(x0,y0)为圆心，r0为半径确定一圆，以(x1,y1)为圆心，r1为半径确定另一圆，</p><p>根据参数确定两个圆的坐标，绘制放射性渐变的方法</p><div class="show">const canvas1=document.getElementById("canvas1");    const ctx1 = canvas1.getContext('2d');    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);    radial.addColorStop(0,"red");    radial.addColorStop(.25,"yellow");    radial.addColorStop(.5,"green");    radial.addColorStop(.75,"#ff00fb");    radial.addColorStop(1,"blue");    ctx1.fillStyle=radial;    ctx1.fillRect(0,0,300,300)</div><p><canvas width="300" height="300" id="canvas1" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;"></canvas></p><script>    const canvas1=document.getElementById("canvas1");    const ctx1 = canvas1.getContext('2d');    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);    radial.addColorStop(0,"red");    radial.addColorStop(.25,"yellow");    radial.addColorStop(.5,"green");    radial.addColorStop(.75,"#ff00fb");    radial.addColorStop(1,"blue");    ctx1.fillStyle=radial;    ctx1.fillRect(0,0,300,300)     ctx1.moveTo(0,0);    ctx1.lineTo(50,50);    ctx1.stroke();    ctx1.moveTo(250,250);    ctx1.lineTo(300,300);    ctx1.stroke();</script><h4 id="锥形渐变对象"><a href="#锥形渐变对象" class="headerlink" title="锥形渐变对象"></a>锥形渐变对象</h4><p><span class="strong">context.createConicGradient(弧度值,x,y)</span><br>以(x,y)为锥形中心创建锥形渐变对象，弧度值角度为渐变开始的位置，角度通过<span class="tips">Math.PI*角度/180</span>运算为弧度值，值可正可负</p><div class="show">const canvas=document.getElementById("canvas");   const ctx = canvas.getContext('2d');    const cg=ctx.createConicGradient(Math.PI*45/180,150,150);    cg.addColorStop(0,"red");    cg.addColorStop(.25,"yellow");    cg.addColorStop(.5,"green");    cg.addColorStop(.75,"#ff00fb");    cg.addColorStop(1,"blue");    ctx.fillStyle=cg;    ctx.fillRect(0,0,300,300);</div><p><canvas width="300" height="300" id="canvasCG" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasCG=document.getElementById("canvasCG");   const ctxCG = canvasCG.getContext('2d');   try{     const cg=ctxCG.createConicGradient(Math.PI*45/180,150,150);      cg.addColorStop(0,"red");    cg.addColorStop(.25,"yellow");    cg.addColorStop(.5,"green");    cg.addColorStop(.75,"#ff00fb");    cg.addColorStop(1,"blue");    ctxCG.fillStyle=cg;    ctxCG.fillRect(0,0,300,300);   }   catch(error){    ctxCG.font=" 800 58px Serif"    ctxCG.fillText("浏览器不支", 0, 100);    ctxCG.fillText("持锥形渐变", 0, 150);    console.warn("浏览器不支持锥形渐变createConicGradient()方法")}   </script><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>锥形渐变兼容性远比线性渐变、径向渐变差，对浏览器内核版本要求较高，详见MDN文档：<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient" style="display:block;word-break: break-all;">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient</a></div><h3 id="Pattern对象"><a href="#Pattern对象" class="headerlink" title="Pattern对象"></a>Pattern对象</h3><p>创建模板对象，</p><p><span class="strong">createPattern(image,重复模式)</span><br>image为图像源，可以是<span class="tips">&lt;img&gt;图像</span>、<span class="tips">&lt;video&gt;视频</span>、<span class="tips">&lt;canvas&gt;另外一个canvas对象</span>、<span class="tips">canvas的2d上下文对象(CanvasRenderingContext2D)</span>等</p><p>图像的重复模式可以为<span class="tips">repeat</span>、<span class="tips">repeat-x</span>、<span class="tips">repeat-y</span>、<span class="tips">no-repeat</span>，用法同CSS</p><div class="show"> const canvas=document.createElement("canvas");        canvas.width=1000;        canvas.height=1000;        document.body.appendChild(canvas);        const ctx=canvas.getContext("2d");        let img=new Image();        img.src="./dog.jpg";        img.onload=function(){            const p=ctx.createPattern(img,'repeat-y')            ctx.fillStyle=p;            ctx.fillRect(0,0,1000,1000)        }</div><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="圆与圆弧线绘制"><a href="#圆与圆弧线绘制" class="headerlink" title="圆与圆弧线绘制"></a>圆与圆弧线绘制</h4><p><span class="strong">context.arc(x,y,r,startAngle, endAngle, anticlockwise)</span></p><ul><li>x,y为圆弧中心</li><li>r为圆弧半径</li><li>startAngle, endAngle为圆弧起始点和终点角度，弧度表示，角度为css坐标x轴与y轴夹角</li><li>anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制<div class="show">const canvasArc=document.getElementById("canvasArc"); const ctxArc = canvasArc.getContext('2d'); ctxArc.lineWidth=5; ctxArc.arc(150,150,100,0,90/180*Math.PI,true); ctxArc.stroke();</div></li></ul><p><canvas width="300" height="300" id="canvasArc" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasArc=document.getElementById("canvasArc");   const ctxArc = canvasArc.getContext('2d');   ctxArc.lineWidth=5;   ctxArc.arc(150,150,100,0,90/180*Math.PI,true);   ctxArc.stroke();</script><h4 id="圆弧线绘制方法2"><a href="#圆弧线绘制方法2" class="headerlink" title="圆弧线绘制方法2"></a>圆弧线绘制方法2</h4><p><span class="strong">context.arcTo(x1, y1, x2, y2, radius)</span></p><ul><li>x1, y1为第一个控制点坐标</li><li>x2, y2为第二个控制点坐标</li><li>radius 为圆弧半径</li></ul><p>将当前路径终点与控制点 1 连接的直线，和控制点 1 与控制点 2 连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径</p><div class="show"> const canvasArcTo=document.getElementById("canvasArcTo");   const ctxArcTo = canvasArcTo.getContext('2d');    ctxArcTo.beginPath();    ctxArcTo.moveTo(100,50)    ctxArcTo.strokeStyle="#000";    ctxArcTo.lineWidth=5;    ctxArcTo.arcTo(250,50,250,250,150);    ctxArcTo.stroke()    ctxArcTo.beginPath();    ctxArcTo.moveTo(50,50)    ctxArcTo.setLineDash([5,10]);    ctxArcTo.lineWidth=5;    ctxArcTo.strokeStyle="blue";    ctxArcTo.lineTo(250,50)    ctxArcTo.lineTo(250,250)    ctxArcTo.stroke()</div><p><canvas width="300" height="300" id="canvasArcTo" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasArcTo=document.getElementById("canvasArcTo");   const ctxArcTo = canvasArcTo.getContext('2d');    ctxArcTo.beginPath();    ctxArcTo.moveTo(100,50)    ctxArcTo.strokeStyle="#000";    ctxArcTo.lineWidth=5;    ctxArcTo.arcTo(250,50,250,250,150);    ctxArcTo.stroke()    ctxArcTo.beginPath();    ctxArcTo.moveTo(50,50)    ctxArcTo.setLineDash([5,10]);    ctxArcTo.lineWidth=5;    ctxArcTo.strokeStyle="blue";    ctxArcTo.lineTo(250,50)    ctxArcTo.lineTo(250,250)    ctxArcTo.stroke()</script><h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><p><span class="strong">context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);</span></p><ul><li>x,y为椭圆圆心的坐标</li><li>radiusX 为椭圆长轴的半径，radiusY 为椭圆短轴半径</li><li>rotation 为椭圆的旋转角度，以弧度表示</li><li>startAngle, endAngle为椭圆圆弧起始点和终点角度，弧度表示</li><li>anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制</li></ul><div class="show"> const canvasEllipse=document.getElementById("canvasEllipse");   const ctxEll = canvasEllipse.getContext('2d');   ctxEll.lineWidth=5;   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)   ctxEll.stroke();</div><p><canvas width="300" height="300" id="canvasEllipse" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasEllipse=document.getElementById("canvasEllipse");   const ctxEll = canvasEllipse.getContext('2d');   ctxEll.lineWidth=5;   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)   ctxEll.stroke();</script><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><h5 id="二阶贝塞尔曲线"><a href="#二阶贝塞尔曲线" class="headerlink" title="二阶贝塞尔曲线"></a>二阶贝塞尔曲线</h5><p><span class="strong"> context.quadraticCurveTo(cpx, cpy, x, y)</span></p><ul><li>cpx, cpy为控制点的坐标</li><li>x, y为曲线终点坐标</li><li>起始点坐标为当前路径所在终点，或者可以使用moveTo()控制</li></ul><div class="show"> const canvasBC=document.getElementById("canvasBezierCurve");   const ctxBC = canvasBC.getContext('2d');   ctxBC.lineWidth=2;   ctxBC.moveTo(50,50);        let cpx=50;        let timerBC=setInterval(()=>{        //想绘制为动画还需再添加beginPath()和clearRect()方法        ctxBC.moveTo(50,50)        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)        ctxBC.stroke()        if(cpx>=350){            clearInterval(timerBC)        }        },100)</div><canvas width="300" height="300" id="canvasBezierCurve" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas><script>   const canvasBC=document.getElementById("canvasBezierCurve");   const ctxBC = canvasBC.getContext('2d');   ctxBC.lineWidth=2;   ctxBC.moveTo(50,50);        let cpx=50;        let timerBC=setInterval(()=>{        ctxBC.moveTo(50,50)        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)        ctxBC.stroke()        if(cpx>=350){            clearInterval(timerBC)        }        },100)</script><h5 id="三阶贝塞尔曲线"><a href="#三阶贝塞尔曲线" class="headerlink" title="三阶贝塞尔曲线"></a>三阶贝塞尔曲线</h5><p><span class="strong"> context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</span></p><ul><li>cp1x, cp1y为第一个控制点的坐标</li><li>cp2x, cp2y为第二个控制点的坐标</li><li>x, y为曲线终点坐标</li><li>起始点坐标为当前路径所在终点，或者可以使用moveTo()控制</li></ul><div class="show"> const canvasBC2=document.getElementById("canvasBezierCurve2");   const ctxBC2 = canvasBC2.getContext('2d');   ctxBC2.lineWidth=2;   ctxBC2.moveTo(50,50);    ctxBC2.bezierCurveTo(300, 50, 50, 300,250, 290);    ctx2BC.stroke()</div><p><canvas width="300" height="300" id="canvasBezierCurve2" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasBC2=document.getElementById("canvasBezierCurve2");   const ctxBC2 = canvasBC2.getContext('2d');   ctxBC2.lineWidth=2;   ctxBC2.moveTo(50,50);   ctxBC2.bezierCurveTo(250, 50, 50, 250,250, 290);   ctxBC2.stroke()  </script><h3 id="文字绘制"><a href="#文字绘制" class="headerlink" title="文字绘制"></a>文字绘制</h3><h4 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h4><p><span class="strong">context.fillText(text, x, y, [maxWidth]); 对文字进行填充</span></p><p><span class="strong">context.strokeText(text, x, y, [maxWidth]); 对文字进行描边</span></p><ul><li>text指定文本内容</li><li>x, y为文本左下角在画布中开始绘制的坐标(因此坐标不应该为0,0)</li><li>maxWidth(可选)，指定绘制的最大宽度，会对文本进行水平缩放</li></ul><h4 id="获取文本宽度"><a href="#获取文本宽度" class="headerlink" title="获取文本宽度"></a>获取文本宽度</h4><p><span class="strong">context.measureText(“文本”);</span></p><p>返回文本的TextMetrics 对象，一般会从该对象中获得文本宽度，以判断文字是否需要在Canva中进行换行</p><div class="show">&lt;canvas width="300" height="700" id="canvasText">&lt;/canvas>&lt;script>const canvasText=document.getElementById("canvasText");const ctxText = canvasText.getContext('2d');let string="微风需要竹林，溪流需要蜻蜓，乡愁般的离开，需要片片浮萍，青春属于表白，阳光属于窗台，而我想我属于一个，拥有你的未来";ctxText.font=" 30px Serif";let rowNum=1;//行号let lastIndex=0;//上一行文字的截取索引位置let rowWidth=0;//每一行的文本长度    for(let i=0;i&lt;string.length;i++){    rowWidth+=ctxText.measureText(string[i]).width;        if(rowWidth>canvasText.width){            ctxText.fillText(string.substring(lastIndex,i),0,50*rowNum)            lastIndex=i--;//substring()截左不截右            rowNum++;            rowWidth=0;        }        if(i==string.length-1){            ctxText.fillText(string.substring(lastIndex,i+1),0,50*rowNum)        }}&lt;/script></div><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><span class="strong">context.font = “value”;</span><br>指定文本属性，默认为 10px sans-serif，value为CSS中的font简写属性，可以按顺序设置<span class="tips">[font-style]&emsp; [font-variant]&emsp;[font-weight]&emsp; font-size[/line-height] &emsp;font-family</span></p><ul><li>必须包含font-size和font-family</li><li>font-style：字体样式，常用取值normal(正常)、italic(斜体)、oblique(倾斜)</li><li>font-variant：设置小型大写字母，将字母写为大写，但除首字母外的文本将缩小字号，默认为normal，可以修改为small-caps(小型大写字母)</li><li>font-weight：设置文本的粗细，常用值：normal(正常)，bold(粗体)，bolder(再加粗)，lighter(细体)，以及100-900的整百数值</li><li>font-size必须，line-height为非必须，有line-height时要写为如：16px/20px 的形式</li><li>font-family：字体族，5个通用字体：Serif(衬线字体)、Sans-serif(无衬线字体)、Monospace(等宽字体)、Cursive(草书字体)、Fantasy(幻想字体)</li></ul><div class="show">const canvasText=document.getElementById("canvasText");const ctxText = canvasText.getContext('2d');ctxText.font=" 60px Serif";ctxText.fillText("hello world",50,60) //对文字进行填充ctxText.strokeText("hello world",50,180)//对文字进行描边</div><canvas width="400" height="200" id="canvasText" style="display:block;width:340px;height:160px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas>    <script>       const canvasText=document.getElementById("canvasText");       const ctxText = canvasText.getContext('2d');       ctxText.font=" 60px Serif";       ctxText.fillText("hello world",50,60)       ctxText.strokeText("hello world",50,180)    </script><h4 id="文本方向"><a href="#文本方向" class="headerlink" title="文本方向"></a>文本方向</h4><p><span class="strong">context.direction =”ltr/rtl/inherit”; 设置当前文本方向</span> </p><ul><li>ltr ,从左往右</li><li>rtl ,从右往左(部分国家读写习惯)</li><li>inherit(默认)，从父元素继承</li></ul><p><span class="strong">context.textAlign = “left/right/center/start/end”; 定义文本水平方向上的对齐方式</span> </p><ul><li>center以绘制文本时的x坐标为基准，一半位于x左边，一半位于右边</li><li>start与end属性以direction定义的文本方向为基准</li></ul><p><span class="strong">context.textBaseline = “tophanging/middle/alphabetic/ideographic/bottom”; 定义文本垂直方向上的对齐方式</span></p><ul><li>与CSS相同，以文本基线为基准，详见MDN文档</li></ul><h3 id="图像与视频绘制"><a href="#图像与视频绘制" class="headerlink" title="图像与视频绘制"></a>图像与视频绘制</h3><ul><li><p><span class="strong">drawImage(image, dx, dy)</span></p></li><li><p><span class="strong">drawImage(image, dx, dy, dWidth, dHeight)  </span></p></li><li><p><span class="strong">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) </span></p><ul><li>image为图像源，可以是图片、SVG矢量图、视频、canvas等</li><li>dx, dy为图片左上角在画布中开始绘制的位置</li><li>dWidth, dHeight为图像在画布上绘制出来的尺寸，会对其进行缩 放、拉抻</li><li>sx, sy为裁剪时，距离图像左上角的开始裁剪的位置</li><li>sWidth, sHeight为裁剪的宽度和高度，省略该参数则默认裁剪到&gt;右下角，sHeight为负值将从sy反向裁剪</li></ul></li></ul><div class="show">const canvasImg=document.getElementById("canvasImg");       const ctxImg = canvasImg.getContext('2d');       let img=new Image();       img.src="./dog.jpg";       img.onload=function(){        //仅指定图片在画布中的位置        ctxImg.drawImage(img, 50, 50);        //指定图片在画布中的位置及缩放尺寸        ctxImg.drawImage(img, 50, 50,300,200);        //裁剪图片，并指定图片在画布中的位置及缩放尺寸        ctxImg.drawImage(img, 50, 50,300,200,0,0,300,300);       }</div><h3 id="移动、旋转、缩放"><a href="#移动、旋转、缩放" class="headerlink" title="移动、旋转、缩放"></a>移动、旋转、缩放</h3><p><span class="strong">context.translate(x, y); 进行水平和垂直位移</span><br>  修改坐标系的原点，默认原点位于(0,0)，由此移动图像在Canvas中的相对位置，可以在上一次translate(x, y)的基础上再次移动坐标系，多次修改坐标原点</p><p><span class="strong">context.rotate(弧度值); 进行旋转变换</span><br>  修改坐标系的旋转角度，参数为弧度值</p><p><span class="strong">context.scale(x, y); 进行水平和垂直缩放</span><br>  对坐标系x轴和y轴进行伸缩，0-1进行缩小，大于1进行放大，负值则进行水平/垂直翻转后进行缩放</p><div class="show">const canvas=document.createElement('canvas');        canvas.width=600;        canvas.height=600;        document.body.append(canvas);        const ctx=canvas.getContext('2d');        ctx.translate(50,50);        ctx.fillRect(0,0,50,100)        ctx.translate(100,100);        ctx.scale(1,-2)        ctx.rotate(180*Math.PI/180)        ctx.fillRect(0,0,50,100)</div><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>类似于CSS的阴影效果，注意，阴影应当设置在图形绘画之前，如果设置阴影效果之前已经有图形和文字存在，则阴影不会对这些图形和文字生效</p><ul><li><span class="strong">context.shadowOffsetX = value; 阴影的水平偏移距离</span></li><li><span class="strong">context.shadowOffsetY = value; 阴影的垂直偏移距离</span></li><li><span class="strong">context.shadowBlur = value;  阴影的模糊值</span></li><li><span class="strong">context.shadowColor = “颜色”; 阴影颜色</span><div class="show">const ctx=canvas.getContext('2d');ctx.shadowOffsetX=16;ctx.shadowOffsetY=8;ctx.shadowBlur=5;ctx.shadowColor="#575656";ctx.moveTo(50,50);ctx.bezierCurveTo(300, 50, 50, 300,250, 290);ctx.stroke()</div></li></ul><h3 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h3><p>类似于CSS3中的效果<br><span class="strong">context.filter = “一个或多个值”</span></p><ul><li>blur(值px)：高斯模糊</li><li>brightness(百分比)：亮度</li><li>contrast(百分比)：对比度</li><li>grayscale(百分比)：灰度滤镜</li><li>hue-rotate(角度deg)：对图像进行色彩旋转的处理</li><li>invert(百分比)：反色(呈现出照片底片的效果)</li><li>opacity(百分比)：不透明度</li><li>sepia(百分比)：褐色处理(怀旧风格)</li><li>drop-shadow(x, y, 模糊值, 阴影扩张/收缩, 阴影色)：阴影效果</li></ul><h3 id="图像合成模式"><a href="#图像合成模式" class="headerlink" title="图像合成模式"></a>图像合成模式</h3><p><span class="strong">context.globalCompositeOperation = “type”;</span></p><ul><li><span class="strong">source-over</span> 图像叠加显示(默认)</li><li><span class="strong">source-in</span> 只显示图像重叠部分</li><li><span class="strong">source-out</span> 只显示图像不重叠的部分</li><li><span class="strong">source-atop</span> 后叠加的图像只显示与原图像重叠的部分</li><li><span class="strong">destination-over</span> 将后叠加的图像置于原图像之下</li><li><span class="strong">destination-in</span> 只显示图像重叠部分，并且只显示原图像部分</li><li><span class="strong">destination-out</span> 将原图像抠去与后图像叠加部分显示，并且后图像不显示</li><li><span class="strong">destination-atop</span>将后图像重叠部分替换为原图像并显示</li><li><span class="strong">lighter</span>两图像重叠部分进行颜色相加</li><li><span class="strong">copy</span>去除原图像，只显示新图像</li><li><span class="strong">xor</span>重叠部分透明，其他正常显示</li><li><span class="strong">multiply</span>将重叠部分的顶层像素与底层像素相乘，重叠部分显示为暗黑色</li><li><span class="strong">screen</span>将重叠部分像素倒转，相乘，再倒转，重叠部分显示为亮色</li><li><span class="strong">overlay</span>multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮</li><li><span class="strong">darken</span>保留两个图层中最暗的像素</li><li><span class="strong">lighten</span>保留两个图层中最亮的像素</li><li><span class="strong">color-dodge</span>将底层除以顶层的反置</li><li><span class="strong">color-burn</span>将反置的底层除以顶层，然后将结果反过来</li><li><span class="strong">hard-light</span>类似于叠加，上下图层互换</li><li><span class="strong">soft-light</span>用顶层减去底层或者相反来得到一个正值</li><li><span class="strong">difference</span>一个柔和版本的强光(hard-light),纯黑或纯白不会导致纯黑或纯白</li><li><span class="strong">exclusion</span>和 difference 相似，但对比度较低</li><li><span class="strong">hue</span>保留底层的亮度和色度，同时采用顶层的色调</li><li><span class="strong">saturation</span>保留底层的亮度和色调，同时采用顶层的色度</li><li><span class="strong">color</span>保留了底层的亮度，同时采用了顶层的色调和色度</li><li><span class="strong">luminosity</span>保持底层的色调和色度，同时采用顶层的亮度</li></ul><h3 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h3><ul><li><span class="strong">context.save() 将当前状态推入栈中</span></li><li><span class="strong">context.restore() 读取栈顶的状态</span></li></ul><p>将保存当前的裁剪区域、虚线列表、以及各属性值压入栈中，之后可以直接依次读取栈顶存储的状态并直接绘制，会保存的属性值包括：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled</p><div class="show">const canvas=document.getElementById("canvas");const ctx=canvas.getContext('2d');ctx.fillStyle="red";ctx.save(); //依次压栈ctx.fillStyle="yellow";ctx.save(); //依次压栈ctx.fillStyle="green";ctx.restore(); //弹栈ctx.fillRect(50,50,100,100);//将绘制为黄色而非绿色</div><h3 id="像素操作-ImageData对象"><a href="#像素操作-ImageData对象" class="headerlink" title="像素操作-ImageData对象"></a>像素操作-ImageData对象</h3><p>ImageData对象保存了Canvas图像的底层实际像素，可以直接进行读取和写入。其中，像素被保存在Uint8ClampedArray类型的一维数组中，每个数组元素为0-255之间的数据，每4个数组元素为一组代表了一个像素点的RGBA值。如：索引为0-3的数组元素，存储了第一个像素点的红、绿、蓝、不透明度对应的0-255十进制数值，以此类推</p><p><span class="strong">context.getImageData(x,y,width,height)</span><br>返回ImageData对象，获取(x,y)坐标开始，width为宽，height为高的矩形区域中的像素。返回的对象中包含width、height、data数组(Uint8ClampedArray类型)三个属性</p><p> <span class="strong">context.putImageData(imagedata对象, dx偏移, dy偏移)</span></p><p>getImageData()方法可以从(x,y)坐标开始获取一个矩形区域内的像素数据，将该部分数据修改后，可以通过putImageData()方法将数据绘制到canvas中。其中，dx，dy为在(x,y)的基础上进行的偏移量，之前获取到的(x,y)到(x+width,y+height)矩形区域内的图形，修改像素数据后将被绘制到(x+dx,y+dy)开始的同大小矩形区域内</p><p> <span class="strong">context.putImageData(imagedata对象,dx偏移, dy偏移, dirtyX, dirtyY,dirtyWidth, dirtyHeight)</span></p><ul><li>dx偏移, dy偏移作用同上</li><li>(dirtyX, dirtyY)为进行修改像素操作开始的位置坐标</li><li>dirtyWidth, dirtyHeight为将进行修改像素操作的矩形区域的长宽</li></ul><div class="show">&lt;canvas width="300" height="300" id="canvas">&lt;/canvas>    &lt;script>       const canvas=document.getElementById("canvas");       const ctx = canvas.getContext('2d');       let img=new Image();       img.src="./dog.jpg";       img.onload=function(){        ctx.drawImage(img,0,0,300,300);        let imageDate=ctx.getImageData(0, 0, 100, 100);        //每4个索引为一组，代表一个像素的RGBA值        for(let i=0;i&lt;imageDate.data.length;i+=4){            //计算每个像素点的灰度值            let avg=(imageDate.data[i]+imageDate.data[i+1]+imageDate.data[i+2])/3;            imageDate.data[i]=avg; //修改像素点的R            imageDate.data[i+1]=avg;//修改像素点的G            imageDate.data[i+2]=avg;//修改像素点的B            imageDate.data[i+3]=255;//修改像素点不透明度A为1        }        // 将(10,10)开始，长200，宽200的区域内的像素调为灰色        ctxImg.putImageData(imageDate,0,0,10,10,200,200)       }    &lt;/script></div><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>使用图像合成模式的<span class="strong">“destination-out”</span>属性值制作刮刮卡</p><div class="ticketContainer" style="position:relative;width:100%;"><div class="scratchTicket" style="width: 300px;height: 150px;font-size: 24px;color: red;text-align: center;line-height: 150px;margin:0 auto;letter-spacing: 8px;background-color: #ffffff;pointer-events: none;user-select: none;">再刮一次</div><canvas width="300" height="150" id="canvasTicket" style="position:absolute;top:0;left:50%;transform:translateX(-50%);"></canvas><div class="tryAgain" onclick="tryAgain()" style="width: 100px;height: 35px;line-height: 35px;text-align: center;background-color: aqua;border-radius: 5px;cursor: pointer;user-select: none;margin:10px auto;">再刮一次</div></div><script>       const ticketContainer=document.querySelector(".ticketContainer");       const canvasTicket=document.getElementById("canvasTicket");       const contextTicket=canvasTicket.getContext('2d');       const p=contextTicket.createPattern(cover(),"repeat");        contextTicket.fillStyle=p;        tryAgain();        function tryAgain(){            document.querySelector(".scratchTicket").innerText=Math.random()>.6?"恭喜中奖":"再刮一次";            contextTicket.clearRect(0,0,300,150);            contextTicket.globalCompositeOperation="copy";            contextTicket.fillRect(0,0,300,150);        }        function cover(){            const canvasCover=document.createElement('canvas');            const coverCtx=canvasCover.getContext('2d');            canvasCover.width=60;            canvasCover.height=50;            coverCtx.fillStyle="#6f6d6d"            coverCtx.fillRect(0,0,60,50)            coverCtx.rotate(45*Math.PI/180);            coverCtx.font="300 15px Serif";            coverCtx.fillStyle="#333333"            coverCtx.fillText("发大财",20,0)            return canvasCover;        }        let allowedDraw=false;        canvasTicket.addEventListener('mousedown',function(){            allowedDraw=true;        })         canvasTicket.addEventListener('mouseup',function(){            allowedDraw=false;        })        canvasTicket.addEventListener('mousemove',function(event){            var event = event || window.event;            if(allowedDraw){             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器              var  x = event.offsetX;              var y = event.offsetY;            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器              var x = event.layerX;              var y = event.layerY;            }            contextTicket.globalCompositeOperation="destination-out";            contextTicket.beginPath();            contextTicket.arc(x,y,20,0,2*Math.PI);            contextTicket.fill();            }})            canvasTicket.addEventListener('touchstart',function(){            let canvasTicketRect=canvasTicket.getBoundingClientRect();            canvasTicket.addEventListener('touchmove',function(e){                e.preventDefault();            var x=e.targetTouches[0].pageX-canvasTicketRect.left;            var y=e.targetTouches[0].pageY-canvasTicketRect.top;            contextTicket.globalCompositeOperation="destination-out";            contextTicket.beginPath();            contextTicket.arc(x,y,20,0,2*Math.PI);            contextTicket.fill();            },{passive:false})            },{passive:false})    </script><pre><code>&lt;div class="card">&lt;/div>//底层卡片，显示是否中奖&lt;canvas width="300" height="150" id="canvas1">&lt;/canvas>//刮刮乐灰色图层，监听刮开区域&lt;div class="tryAgain" onclick="tryAgain()">再刮一次&lt;/div>//重新开始按钮&lt;/div>&lt;script>       const canvas=document.getElementById("canvas1");       const context=canvas.getContext('2d');       const p=context.createPattern(cover(),"repeat");//创建模板对象，设置图像重复模式        context.fillStyle=p;        function tryAgain()&#123;            document.querySelector(".card").innerText=Math.random()>.8?"恭喜中奖":"再刮一次";            context.clearRect(0,0,300,150);            context.globalCompositeOperation="copy";            context.fillRect(0,0,300,150);        &#125;        tryAgain();        /*        *制作刮刮乐封面，返回canvas DOM        */        function cover()&#123;            const canvasCover=document.createElement('canvas');            const coverCtx=canvasCover.getContext('2d');            canvasCover.width=60;            canvasCover.height=50;            coverCtx.fillStyle="#6f6d6d"            coverCtx.fillRect(0,0,60,50)            coverCtx.rotate(45*Math.PI/180);            coverCtx.font="300 15px Serif";            coverCtx.fillStyle="#333333"            coverCtx.fillText("发大财",20,0)            return canvasCover;        &#125;        let allowedDraw=false;        canvas.addEventListener('mousedown',function()&#123;            allowedDraw=true;        &#125;)         canvas.addEventListener('mouseup',function()&#123;            allowedDraw=false;        &#125;)        canvas.addEventListener('mousemove',function(event)&#123;            var event = event || window.event;            if(allowedDraw)&#123;             if (event.offsetX || event.offsetY) &#123;  //非Mozilla浏览器              var  x = event.offsetX;              var y = event.offsetY;            &#125; else if (event.layerX || event.layerY) &#123;  //兼容Mozilla浏览器              var x = event.layerX;              var y = event.layerY;            &#125;            context.globalCompositeOperation="destination-out";            context.beginPath();            context.arc(x,y,20,0,2*Math.PI);            context.fill();            &#125;&#125;)            //移动端            canvas.addEventListener('touchstart',function()&#123;            let canvasRect=canvas.getBoundingClientRect();            canvas.addEventListener('touchmove',function(e)&#123;                e.preventDefault();            var x=e.targetTouches[0].pageX-canvasRect.left;            var y=e.targetTouches[0].pageY-canvasRect.top;            context.globalCompositeOperation="destination-out";            context.beginPath();            context.arc(x,y,20,0,2*Math.PI);            context.fill();            &#125;,&#123;passive:false&#125;)            &#125;,&#123;passive:false&#125;)    &lt;/script></code></pre>]]></content>
    
    
    <summary type="html">只涉及Canvas Context2D对象提供的API，包括基本图形、弧线、贝塞尔曲线的绘制，渐变、阴影、滤镜、文字的添加，以及对图像合成模式和像素的操作</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="javaScript" scheme="https://shiwei11.github.io/blog/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Web的发展旅程</title>
    <link href="https://shiwei11.github.io/blog/2022/09/18/History-of-browser/"/>
    <id>https://shiwei11.github.io/blog/2022/09/18/History-of-browser/</id>
    <published>2022-09-18T07:46:45.000Z</published>
    <updated>2023-09-20T18:53:51.448Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>了解这些历史解开了此前我心中的一些疑惑，比如：UA标识里为什么同时会有好几个内核的标识？CSS为什么需要写浏览器前缀来做兼容性？</div><h3 id="世界线的开端"><a href="#世界线的开端" class="headerlink" title="世界线的开端"></a>世界线的开端</h3><h4 id="超文本-Hyper-Text"><a href="#超文本-Hyper-Text" class="headerlink" title="超文本(Hyper Text )"></a>超文本(Hyper Text )</h4><p><span class="strong">超文本:</span>是指利用链接将非线性分布的节点上的信息联结，把各种不同空间的文字信息组织在一起形成的超级文本。它使得原先的线性文本变成可以通向四面八方的非线性文本，读者查阅文本时可以在任何一个关节点上停下来，进入其他文本，然后再点击、再进入另一文本，理论上，这个过程是可以无限重复的。从而，原先单一的文本变成了无限延伸、扩展的超级文本。</p><p>1945年，美国工程师Vannevar Bush(曼哈顿计划的主要组织者、雷神公司创始人之一)提出了一种基于静态缩微胶片页面的memex(memory extender)设备,人们可以在该设备中压缩和存储书籍、文件、通信记录及其索引，并以极快的速度对其进行检索查询。这意味着，人们不用再根据特定的程序，一步一步寻找信息，利用文本间的交叉引用链接,人们可以用非线性的方式查阅信息，由于条件所限，Vannevar Bush的思想在当时并没有变成现实，但这一开创性的信息组织方法，奠定了超文本的基础。</p><p>1960年，Ted Nelson在哈弗大学参加计算机编程课时，考虑编写一个文档系统来索引和管理他收藏的笔记，他在进入哈弗大学前曾担任电影制片人，因此他准备将电影镜头引入了该系统的设计中。所有信息都可以通过其他任何地方的链接访问，信息导航是非线性的，这取决于每个访问信息的人，人们可以从一个信息跳转到另外一则信息，就像从一个镜头切换到另外一个镜头。基于这个想法，1963年，Ted Nelson 首次提出了“超文本”的概念。</p><p>1968年，美国科学家Doug Engelbart在美国秋季联合计算机会议上展示了第一个超文本系统NLS(oN-Line System)，并首次展示了鼠标、第一个图形用户界面。</p><h4 id="万维网的诞生"><a href="#万维网的诞生" class="headerlink" title="万维网的诞生"></a>万维网的诞生</h4><p>1989年，工作于CERN(欧洲核子研究所)的Tim Berners Lee为查找存储在不同计算机上的信息而苦恼，不兼容的网络、磁盘、数据格式和字符编码使得人们查找信息十分困难且低效。于是，他向CERN的领导层提交了一个超文本项目提案，该提案提出建立一个用于CERN研究人员之间交流信息的系统，用以帮助处于不同网络、计算机系统、国家的研究人员共享信息和交流问题。</p><p>1990年，Tim Berners Lee开发出了构建Web所需要的三个基本技术：</p><ul><li><span class="strong">统一资源定位符(URL)</span></li><li><span class="strong">超文本标记语言(HTML)</span></li><li><span class="strong">超文本传输协议(HTTP)</span></li></ul><p>同年，在同事Robert Cailliau的帮助下，Tim Berners Lee发起建立了一个名为World Wide Web (万维网)的超文本项目。1990年12月，Tim Berners Lee和他的团队开发出了世界上第一个Web浏览器(WorldWideWeb，与万维网同名)，第一个Web服务器(CERN httpd)，并发布了世界上第一个网站：<a href="http://info.cern.ch/">http://info.cern.ch/</a>，万维网就此诞生！</p><p>1994年，W3C联盟(万维网联盟)正式成立，由Tim Berners-Lee 担任W3C联盟主任，这是一个非营利性技术组织，旨在对 web 技术进行标准化，以协调服务提供商、内容供应商、实验室等各方协同工作，致力在万维网发展方向上达成共识，并起草发布<span class="strong">W3C标准</span>，主要包括HTML、XHTML、CSS、DOM、ECMAScript标准的规划制定。</p><h4 id="浏览器的发展"><a href="#浏览器的发展" class="headerlink" title="浏览器的发展"></a>浏览器的发展</h4><p>WorldWideWeb浏览器最初只能在NeXTSTEP操作系统上使用(next公司老板是大名鼎鼎的乔布斯，后来next被苹果收购，NeXTSTEP系统和OpenStep结合，衍生出了MacOS)，为了解决这个问题，Tim Berners Lee的团队使用C语言重写了WorldWideWeb的许多组件，从而创建了libwww API。</p><p>1992年4月，在Robert Cailliau的指导下，赫尔辛基理工大学的4名硕士生小组联合开发出了第一个可运行于Unix的浏览器Erwise，该项目在学生毕业后被搁置了，Tim Berners Lee前往芬兰鼓励该小组毕业后继续开发该项目，但后期由于缺少资金该项目再次被搁置。</p><p>1992年，加州大学伯克利分校学生魏培源使用Viola语言将WWW浏览器的组件组合了起来，发布了第二个可以运行于Unix系统中的浏览器ViolaWWW，这是第一个支持添加扩展功能的浏览器，该浏览器得到了CERN的推崇，成为了第一个流行于万维网中的浏览器。</p><p>1993年，美国国家超级计算应用中心(NCSA)的俩名员工Marc Andreessen和Eric Bina在接触了ViolaWWW后，为Unix的X窗口系统设计出了Mosaic浏览器，这是第一款可以显示图形界面和图片的浏览器，设计之初就考虑到了非技术用户的使用体验，由此引发了Web网络的爆炸式发展，Web在短短几个月内从鲜为人知变成了无处不在，该浏览器也很快被移植到Amiga、Apple Macintosh和Windows等平台。</p><h3 id="内核的发展"><a href="#内核的发展" class="headerlink" title="内核的发展"></a>内核的发展</h3><h4 id="开拓者-网景导航者"><a href="#开拓者-网景导航者" class="headerlink" title="开拓者 网景导航者"></a>开拓者 网景导航者</h4><p>1994年4月，Mosaic浏览器的核心开发人员Marc Andreessen离开了NCSA，与几何图形发生器的发明人Jim Clark共同创办了网景公司（Netscape Communications Corporation），网景大量聘用了原有的Mosaic浏览器工程师，但由于Mosaic的版权在NCSA，于是开发团队重写了浏览器代码。</p><p>1994年11月，网景发布了大名鼎鼎的<span class="strong">网景导航者（Netscape Navigator）</span>浏览器1.0版本，这是全球第一款商业浏览器，由于公司目标是替代NCSA Mosaic成为全球第一的浏览器，因此将其内部代号定为了”Mozilla”，意为Mosaic杀手。1995年，网景开发出了<span class="strong">HTTP cookie、</span><span class="strong">Frame框架、</span><span class="strong">SSL</span>等一系列技术，并创建了<span class="strong">JavaScript</span>语言，网景导航者由于其功能更新迅速，又有新技术的加持，市场份额一度达到了86%。</p><p>意气风发的网景将目光转向了操作系统的开发，网景希望开发出一款基于浏览器的操作系统，类似于如今的Chrome OS。这引起了微软的警觉，这一跨越浏览器界限的作业系统，被微软视为是对Windows的直接威胁，微软担心网景抢占他们在操作系统和应用软件方面的市场份额。</p><h4 id="泥石流-IE"><a href="#泥石流-IE" class="headerlink" title="泥石流 IE"></a>泥石流 IE</h4><p>1995年，为了对抗网景导航者，微软从Spyglass公司(Spyglass是NCSA创建的商业化公司)购买了Mosaic浏览器的源代码和许可，同年8月，微软推出了基于此开发的<span class="strong">Internet Explorer</span>浏览器1.0版本。IE浏览器的发布引发了“浏览器大战”，网景和微软竭力为各自的产品推陈出新，以求占据更大的市场份额。</p><p>1996年，微软推出了IE3,这是第一款支持<span class="strong">CSS</span>的商用浏览器。</p><p>1997年9月，微软发布了<span class="strong">Trident</span>内核，并推出了第一个以该内核作为引擎的浏览器 IE4。事态开始逐渐失控，微软的团队制作了一个巨大的字母”E”模型并将它放在了网景总部的草坪上。网景的团队不甘示弱，推倒了模型并放上了Mozilla的恐龙吉祥物，并写上标语”Netscape 72，Microsoft 18”以嘲讽微软IE浏览器的市场份额比网景低。</p><p>随后，微软开始不讲武德，将IE集成到了Windows中进行捆绑发行，并投给了苹果1.5亿美元，让苹果撤销之前对微软的侵权指控，附加条件是让苹果在其Macintosh上内置IE浏览器。此外，微软在授权条款中，要求主机厂商们在桌面上展示IE的图标，并不得加入Netscape，否则以涨价方式作为处罚。</p><p>微软的垄断式发行卓有成效，当人们看到打开操作系统就有开箱即用的浏览器时，很少会有人再想到网景导航者了，更何况IE是免费的而网景导航者需要付费。微软的一系列操作让IE浏览器的市场份额很快暴涨，直至2002年，IE浏览器的市场份额达到恐怖的96%，比网景的峰值还高。</p><p>过高的市场占有率开始使微软养尊处优，没有了网景这一竞争对手的压力，微软放慢了对内核的更新进程，并开始奉行一套自己的Web标准，在IE浏览器中加入了VBScript，DHTML等不遵循W3C公开标准的专属技术，以巩固自己的霸主地位，IE浏览器开始变得臃肿而笨重。由于IE浏览器垄断了市场，不少网页开发者只能迎合微软的Web标准，公开的W3C标准反而不被关注，从而衍生出了一大堆只和IE专属技术契合的网站，使得一些网站只能使用IE浏览器打开。</p><p>此外，IE由于市场占有率高，已然成为了蠕虫病毒的主要攻击目标，IE浏览器一旦被发现安全漏洞，蠕虫病毒会由于IE的普及高速传播。IE的泥石流行径为web的发展带来了难以根治的后遗症，而微软的不正当竞争行径也使之背负了多年的反垄断指控。</p><h4 id="网景的继承-Mozilla火狐"><a href="#网景的继承-Mozilla火狐" class="headerlink" title="网景的继承 Mozilla火狐"></a>网景的继承 Mozilla火狐</h4><p>除了微软的垄断式打压，网景后期对浏览器的错误定位也成为了网景覆灭的导火索之一。网景在与微软的“浏览器大战”中过分追求为浏览器增加特色功能，将电子邮件、新闻组件、文件编辑等功能塞入了浏览器中，并将其更名为了 Netscape Communicator4.0（网景通讯家）。过多的组件造成整个软件渲染缓慢，臃肿不堪。并且其新增的“特色”功能并没有革命性的创新，反而逐渐脱离了W3C的标准，期间曾一度创造了臭名昭著的<span class="tips">&lt;blink&gt;</span>标签。欠缺的使用体验，再加上微软的流氓式打压，网景浏览器的市场份额一落千丈。</p><p>1998年1月，在与微软的“浏览器大战”中失利后，为了挽回市场，网景宣布旗下所有软件对公众免费，并开源了Netscape Communicator4.0的源代码。与此同时，网景发布了一个全新的开源项目Mozilla，其中包含了全新的排版引擎<span class="strong">Gecko</span>，并建立了非正式组织Mozilla，以支持后续的Netscape Communicator开发。</p><p>1998年10月，网景宣布Netscape Communicator5.0将使用全新的Gecko引擎，这引起了Netscape开发人员的不满，因为在此之前他们对旧引擎<span class="strong">Mariner</span>进行了长达六个月的改进工作，而此举意味着他们此前的努力将付诸东流。网景的盈利主要依靠网景导航者及其衍生产品的收益，主要支柱遭受巨大打击，此时的网景已经摇摇欲坠，内部进行了大量人员裁剪。诸多原因直接导致Netscape Communicator5.0的发布被极大地推迟了，而此前微软发布的IE4比旧版本的网景通讯家拥有更好的性能，包括对HTML4、CSS、DOM和ECMAScript等W3C标准的支持，市场的天平进一步向微软倾斜。</p><p>1998年11月，AOL(美国在线)公司以42亿美元、免税换股的方式收购了网景通讯公司。AOL在证实微软因滥用垄断能力而败诉后(此前微软因垄断问题在和苹果等公司打官司)，AOL向微软提出了索偿诉讼，指控微软在与网景的竞争中滥用垄断能力。2003年5月，微软和AOL达成和解协议，微软将向网景支付7.5亿美元，而AOL允许微软在7年无限制的使用和散布IE浏览器，AOL的这一举动带领网景走向了覆灭。</p><p>2000年11月，在推迟将近两年后，网景跳过了Netscape Communicator5.0，发布了基于Gecko引擎的Netscape 6，但此时已是IE5的天下。</p><p>2003年7月15日，AOL解散了网景公司，解雇了Gecko的开发人员，并将Gecko及其相关产品的知识产权交给了Mozilla组织，Mozilla组织接收了大量Gecko的开发人员。同一天，Mozilla基金会正式成立，其目的是保证Mozilla组织可以在没有网景以后能继续生存下去。</p><p>2004年11月，Mozilla发布了Firefox(火狐)1.0版本，起初，Firefox被命名为Phoenix，寓意网景导航者的欲火重生，但由于与一家科技公司重名而改为了Firebird，该名称又和一个数据库软件重名，最后Mozilla 将名称确定为了Firefox。</p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>Mozilla还负责运行维护MDN开发者平台，该平台提供了大量关于HTML、CSS、JavaScript和Web API的免费文档资料，是最好的Web开发资源平台之一。</div><h4 id="勤劳的蜜蜂-苹果safari"><a href="#勤劳的蜜蜂-苹果safari" class="headerlink" title="勤劳的蜜蜂 苹果safari"></a>勤劳的蜜蜂 苹果safari</h4><p>在safari之前，苹果Macintosh系列计算机所使用的默认浏览器为网景导航者、Cyberdog（苹果自行开发的浏览器，由于苹果经营不善该项目被裁掉）和IE。</p><p>2001年6月，苹果fork了由KDE社区(一个崇尚开源自由的软件社区)开发的开源渲染引擎KHTML和JS引擎KJS，然后利用适配器库将其移植到了苹果的Mac OS X系统上，并重命名为WebCore和JavaScriptCore。经过苹果二次开发的KHTML和KJS拥有了更为严谨的代码结构和更快的渲染速度，苹果将其命名为<span class="strong">Webkit</span>引擎。</p><p>2003年1月，苹果发布了首个以此为内核的<span class="strong">safari</span>浏览器</p><p>2005年6月，苹果开源了Webkit源代码，同年12月，添加了对SVG(矢量图)的支持</p><p>2007年，苹果开始对CSS进行拓展，使得CSS开始支持动画、过渡、2D和3D变换，并于2009年将其以草案的方式发布给了网维网联盟进行标准化，辛勤的苹果为CSS标准库提供了大量的草案和建议。</p><h4 id="新的引领-谷歌chrome"><a href="#新的引领-谷歌chrome" class="headerlink" title="新的引领 谷歌chrome"></a>新的引领 谷歌chrome</h4><p>Webkit的高效和稳定引来了谷歌的青睐，2008年9月，谷歌发布了以Webkit为引擎的<span class="strong">Chrome</span>浏览器,实际上，Chrome还使用了Mozilla等组织的诸多开源组件来增强性能。</p><p>2010年苹果发布了Webkit2，由于Webkit2使用的进程隔离技术与谷歌的沙箱设计存在冲突，谷歌决定在WebKit的基础上自行开发引擎。谷歌的工程师们fork了WebKit的Webcore渲染引擎，并对源代码作了大量的精简和修改，而JS引擎将谷歌自行开发。</p><p>2013年4月，谷歌发布并开源了全新的浏览器内核<span class="strong">Blink</span>，其名字来源于网景创建的臭名昭著的<span class="tips">&lt;blink&gt;</span>标签，谷歌的工程师戏虐的表示：”我们永远不会支持blink标签”。此外，谷歌还开发出了强悍的JavaScript解释器——V8引擎(基于Strongtalk)，大大加快了chrome的JS解析速度。</p><p>随着Blink的发布，Opera等浏览器厂商纷纷宣布将转向使用Blink引擎。2015年3月，微软宣布放弃IE浏览器的开发，转而使用Microsoft Edge取代IE。2020年，微软宣布Microsoft Edge浏览器将弃用EdgeHTML转而使用Blink内核。</p><h4 id="兢兢业业的Opear"><a href="#兢兢业业的Opear" class="headerlink" title="兢兢业业的Opear"></a>兢兢业业的Opear</h4><p>1994年，挪威电信公司Telenor的两名员工Jon Stephenson von Tetzchner和Geir Ivarsøy开始开发Opear浏览器，后来，他们离开了Telenor并创立了Opear Software，并于1995年4月发布了Opear浏览器</p><p>2003年1月，欧朋发布就基于<span class="strong">Presto</span>内核的Opera 7</p><p>2010年，欧朋首创了选项卡堆叠、鼠标手势等功能，这些功能后来也被其他浏览器大量应用</p><p>2013年2月，欧朋宣布放弃presto转而使用Webkit，2013年4月，欧朋跟随谷歌转而使用Blink引擎。</p><p>2016年2月，欧朋被360公司和昆仑万维收购</p><p>欧朋浏览器自发布以来严格遵守W3C标准，老老实实地开发使用符合W3C规范的技术拓展，然而“浏览器大战”与IE的横行造就了一大堆不符合W3C标准的网页，由于Opear不支持非标准的技术栈，这些网页在Opear上往往会解析错误，Opear的兢兢业业反而为其带来了负面的用户口碑，因为用户只会将页面的不解析归咎于浏览器的问题。</p><p>2001年10月，随着WindowsXP的发布，微软对MSN通讯软件进行了重大更新，随后就有用户反馈无法使用Opear浏览器进入MSN主页。微软随即甩锅解释是因为Opear浏览器不支持W3C的XHTML技术规范导致。Opear公司反驳表示，Opear浏览器比微软更能满足W3C标准，并给出了W3C验证服务结果：微软的MSN主页使用了非标准的编码。Opear公司还制作了一份标准XHTML的页面进行还击，经过测试，网景6、Opear 等浏览器能正确访问该页面，而IE 6则无法正常显示。随后，微软开始排挤Opear用户，谷歌在发布Chrome后也曾排挤Opear，直至Opear改用Blink引擎后才有所好转。</p><p>Opear在不断遭受排挤后开始考虑支持非标准拓展，Opear公司为浏览器添加了伪装功能，允许用户将Opear伪装为IE、Firefox等浏览器以解决某些网站排挤Opear的问题，兢兢业业的欧朋由于遵守W3C标准反而吃了不少亏，这不是欺负老实人吗!!（胡万腔）</p><h4 id="国产浏览器"><a href="#国产浏览器" class="headerlink" title="国产浏览器"></a>国产浏览器</h4><p>中国互联网发展最快的时间刚好遇上了IE浏览器霸榜的时代，由于IE的Trident内核市场占有率较高，许多网页设计者不得不将以IE的标准作为优先考量，直接导致许多政府机构、高校、企业、银行的网站只能在IE浏览器上正常访问，而在更支持W3C标准的safari、chrome、Firefox等浏览器反而会出现加载或解析错误的情况。为此，国内的浏览器厂商们整合了IE的Trident内核与苹果的Webkit内核，美其名曰双内核并以此作为宣传浏览器的噱头(其实都是别人家的内核)。兼容模式下，浏览器会启用Trident内核以适应脱离w3c标准的垃圾网页。</p><h3 id="浏览器UA标识"><a href="#浏览器UA标识" class="headerlink" title="浏览器UA标识"></a>浏览器UA标识</h3><p>UA为User Agent的简写，指浏览器等软件在网络协议中工作时，会向服务器等对等方提交一个特征字符串，方便对方识别应用类型、操作系统、软件版本号等信息。例如：由于手机屏幕和电脑屏幕尺寸相差巨大，网站设计者一般会为手机端和电脑端设计两个不同大小的网页(或者响应式网页)，当我们访问网站时，服务器会通过UA标识(或者屏幕大小)检测到我们使用的设备是手机还是电脑，从而返回相应的网页。浏览器UA的语法格式通常为：</p><div class="show"><span class="strong">&lt;product> /&lt;version> (&lt;system-information>) &lt;platform> (&lt;platform-details>) &lt;extensions></span></div><p>UA也起源于著名的“浏览器之战”，当时，由于网景首先开创使用了JavaScript、Frames框架等技术，使得网景导航者浏览器的使用体验一骑绝尘，当时的网景导航者支持图片嵌入、网页嵌入等技术，而Mosaic、Samba等一些比较旧的浏览器只支持显示简单的HTML文档。为了提高网站的使用体验，网站设计者们往往希望网页拥有比较前沿的技术设计，但用户的浏览器却不一定支持网站的新颖技术。解决这一问题，UA嗅探技术诞生了。通过UA，网站会动态识别访问用户的浏览器，如：如果是网景导航者，则返回带有Frames框架技术的高级网页内容，如果为Mosaic，则只需返回简单的HTML文档即可。</p><p>起初，网景的UA长这样：</p><div class="show"><code>Mozilla/1.0 (win3.1)</code></div><p>后来，IE浏览器诞生，IE及其他浏览器逐步追上了网景的脚步，并开始支持网景的特色功能，但由于它们起步较晚，绝大多数网站仍只支持为带有Mozilla标识的浏览器返回高级网页。于是乎，微软等公司的在UA中添加了Mozilla的标识来“欺骗”Web服务器，于是，IE浏览器的标识写为了：</p><div class="show"><code>Mozilla/1.22 (compatible;MSIE 2.0;Windows 95)</code></div><p>后来，网景飞升，留下了遗孤Mozilla ，Mozilla 打造 Gecko并发布了Firefox，Firefox的UA写为了</p><div class="show"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0</code></div><p>再后来，KDE社区开发出了KHTML引擎，并发布了嵌入式浏览器 Konqueror，但网页不给他们分发高级内容，他们很烦，于是他们也伪装成了Mozilla，并且表示KHTML跟Gecko一样好~</p><div class="show"><code>Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)</code></div><p>后来，苹果基于KHTML开发出了WebKit，他们又在KHTML的UA上套了一层娃</p><div class="show"><code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5</code></div><p>再再后来，谷歌又在WebKit基础上开发出了blink，他们也想套娃</p><div class="show"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13</code></div><p>于是，人人都是网景Mozilla</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>参考：<a href="https://webaim.org/blog/user-agent-string-history/">user-agent-string-history</a></div><h3 id="代码兼容性"><a href="#代码兼容性" class="headerlink" title="代码兼容性"></a>代码兼容性</h3><h4 id="CSS浏览器前缀"><a href="#CSS浏览器前缀" class="headerlink" title="CSS浏览器前缀"></a>CSS浏览器前缀</h4><p>为了兼容旧版本的浏览器，对于比较新颖的CSS样式我们需要添加浏览器前缀</p><div class="table"><table><thead><tr><th>浏览器</th><th>内核</th><th>前缀</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>-ms-</td></tr><tr><td>Firefox</td><td>Gecko</td><td>-moz-</td></tr><tr><td>Opera</td><td>Presto</td><td>-o-</td></tr><tr><td>Safari</td><td>WebKit</td><td>-webkit-</td></tr><tr><td>Chrome</td><td>WebKit</td><td>-webkit-</td></tr></tbody></table></div><h4 id="渲染内核"><a href="#渲染内核" class="headerlink" title="渲染内核"></a>渲染内核</h4><h5 id="双核浏览器"><a href="#双核浏览器" class="headerlink" title="双核浏览器"></a>双核浏览器</h5><p>对于双核浏览器，我们可以使用<span class="tips">meta</span>标签指定内核渲染网页，国内的双核浏览器一般是Trident内核和webkit内核，因此选其一。</p><div class="show">使用webkit渲染网页，用于提高渲染速度&lt;meta name="renderer" content="webkit"> 使用IE兼容内核，用于兼容为低版本IE浏览器&lt;meta name="renderer" content="ie-comp">使用IE标准内核，用于网站用了IE专属技术&lt;meta name="renderer" content="ie-stand"></div><h5 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h5><p><span class="tips">X-UA-Compatible</span>是IE8的一个专有<meta>属性，它用来指示IE8以上浏览器采用何种IE版本去渲染网页</p><p>常用值有：</p><div class="show">使用最高版本的IE内核渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;启用谷歌内嵌框架Chrome Frame(谷歌推出的IE插件)进行渲染，没有则使用最高版本的IE内核渲染（推荐使用）&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" /></div><p>其他还支持</p><div class="show">使用IE7内核渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=7" />值可并列，该值表示IE8降级使用IE7内核渲染，若有IE9则使用IE9&lt;meta http-equiv="X-UA-Compatible" content="IE=7;IE=9" /></div>]]></content>
    
    
    <summary type="html">了解Web发展的历史，本文包括超文本的由来、内核的发展、UA标识的语法组成，以及如何指定渲染引擎</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>基于certbot获取TLS证书</title>
    <link href="https://shiwei11.github.io/blog/2022/07/29/lets-encrypt/"/>
    <id>https://shiwei11.github.io/blog/2022/07/29/lets-encrypt/</id>
    <published>2022-07-29T06:58:33.000Z</published>
    <updated>2023-11-06T20:06:18.076Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>Let’s Encrypt 官网：<a href="https://letsencrypt.org/">https://letsencrypt.org/</a></div><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><h4 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title="Let’s Encrypt"></a>Let’s Encrypt</h4><p>Let’s Encrypt 是由 ISRG (Internet Security Research Group)推出的免费安全证书计划，我们可以利用Let’s Encrypt 提供的TLS证书，在我们的网站上部署HTTPS 服务。</p><h4 id="ISRG"><a href="#ISRG" class="headerlink" title="ISRG"></a>ISRG</h4><p>ISRG（Internet Security Research Group ，互联网安全研究小组）是一个公益性的组织，该公益组织旨在减少资金、技术、教育障碍，以保护互联网上的通信，推动全球网站的HTTPS化。ISRG成立于2013 年 5 月，起初由Mozilla、电子前沿基金会(EFF)、密歇根大学、思科和 Akamai共同建立，后来又得了谷歌、亚马逊、讯飞、IBM、RedHat、Linux基金会等大厂商的赞助，所以他们的技术和证书安全是可以保障的。</p><h4 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h4><p>Certbot 是由电子前沿基金会 (EFF)制作的免费开源软件工具，用于在网站上申请、管理、使用由Let’s Encrypt颁发的证书，证书每60天更新一次。</p><h3 id="前置需要"><a href="#前置需要" class="headerlink" title="前置需要"></a>前置需要</h3><ul><li>一台可用的服务器，并拥有<span class="tips">root</span>权限</li><li>安装了Web服务，以<span class="tips">Nginx</span>为例</li><li>一个可用的域名，并解析到了该服务器上</li></ul><h3 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h3><h4 id="官方安装"><a href="#官方安装" class="headerlink" title="官方安装"></a>官方安装</h4><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>certbot官方文档：<a href="https://certbot.eff.org/">https://certbot.eff.org/</a></div><p>官网文档里给出了不同系统的详细安装方法，但在安装过程中会遇到不少问题，有些甚至涉及到需要重新编译Linux内核，这在已经部署业务的服务器上往往是无法实现的。</p><p>以CentOS7为例，根据官方的文档，安装Certbot需要先添加EPEL存储库，然后从中安装snapd软件包，但安装snapd需要解决诸多依赖问题：</p><ul><li>安装snapd需要Linux内核支持 SquashFS 文件系统</li><li>手动编译安装的SquashFS 文件系统，yum可能无法识别</li><li>内核编译时需要启用CONFIG_DEVPTS_MULTIPLE_INSTANCES 选项，如果没有需要重新编译内核</li></ul><h4 id="通过pip3安装"><a href="#通过pip3安装" class="headerlink" title="通过pip3安装"></a>通过pip3安装</h4><p>如果无法安装snapd，那只能绕过它，通过其他包管理工具安装，以pip（python包管理工具）为例</p><p>安装python并通过pip安装certbot</p><pre><code>yum install -y python3 && pip3 install certbot</code></pre><h5 id="pip3版本较低报错问题"><a href="#pip3版本较低报错问题" class="headerlink" title="pip3版本较低报错问题"></a>pip3版本较低报错问题</h5><p>在安装certbot时，如果yum源中的pip3版本较低，可能会导致模块导入失败，从而报错</p><div class="shell">Complete output from command python setup.py egg_info:            =============================DEBUG ASSISTANCE==========================            If you are seeing an error here please try the following to            successfully install cryptography:            Upgrade to the latest pip and try again. This will fix errors for most            users. See: https://pip.pypa.io/en/stable/installing/#upgrading-pip            =============================DEBUG ASSISTANCE==========================    Traceback (most recent call last):      File "&lt;string>", line 1, in &lt;module>      File "/tmp/pip-build-2bwzqu_0/cryptography/setup.py", line 14, in &lt;module>        from setuptools_rust import RustExtension    ModuleNotFoundError: No module named 'setuptools_rust'    ----------------------------------------Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-2bwzqu_0/cryptography/</div><p>此时根据报错提示，升级pip3到最新版本即可</p><pre><code>sudo pip3 install --upgrade pip</code></pre><p>升级完毕再安装certbot</p><pre><code>pip3 install certbot</code></pre><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><h4 id="验证域名"><a href="#验证域名" class="headerlink" title="验证域名"></a>验证域名</h4><p>申请证书前，Let’s Encrypt需要先验证域名，以确认用户拥有对域名的控制权。验证通过后，certbot会立马进入申请流程，因此下述命令会同时验证域名和申请证书。certbot针对不同的web服务器和需求，有多种不同的验证方式：</p><h5 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1. Nginx"></a>1. Nginx</h5><p>如果部署了Nginx，可以直接执行（但要确保安装了certbot-nginx插件）</p><pre><code>sudo certbot --nginx</code></pre><p>certbot将自动获取域名，并在进入证书申请流程时让你确认域名，也可以在执行上述命令时通过添加<span class="tips">-d</span>参数来指定域名，如：</p><div class="show"><code>sudo certbot -&zwnj;-nginx -d  shiwivi.com -d  www.shiwivi.com</code></div><p>可以通过<span class="tips">-&zwnj;-email</span>来添加邮箱，Let’s Encrypt会在证书即将到期时发邮件通知你更新证书。</p><div class="show"><code>sudo certbot -&zwnj;-nginx --email xxxx@gmail.com -d  shiwivi.com -d  www.shiwivi.com</code></div><p>如果不添加上述参数，certbot会在验证通过后要求你添加，邮箱一般只需要在首次验证证书或者更改邮箱时添加。</p><h5 id="2-Apache"><a href="#2-Apache" class="headerlink" title="2. Apache"></a>2. Apache</h5><p>Apache中的验证方法与上类似</p><pre><code>sudo certbot --apache</code></pre><h5 id="3-Webroot模式"><a href="#3-Webroot模式" class="headerlink" title="3. Webroot模式"></a>3. Webroot模式</h5><p>上述方法会重启我们的web服务以重新加载配置文件，如果我们希望在颁发证书时，不重启web服务，则可以使用webroot模式。webroot模式下，certbot 会利用已经部署的 web 服务，在其 web 服务根目录下创建名为<span class="tips">/.well-known/acme-challenge</span>的隐藏文件，然后由 Let’s Encrypt 服务端通过域名来访问该隐藏文件，从而完成验证。</p><p>因此，在执行命令时，我们需要添加<span class="tips">-w</span>参数来引导certbot找到web服务的根目录</p><pre><code>certbot certonly --webroot -w 网站根目录 -d 域名</code></pre><p>如：Nginx默认放置网页的根目录为：<span class="tips">/usr/local/nginx/html</span>，则对应命令为</p><div class="show"><code>certbot certonly --webroot -w /usr/local/nginx/html -d shiwivi.com</code></div><h5 id="3-Standalone模式"><a href="#3-Standalone模式" class="headerlink" title="3. Standalone模式"></a>3. Standalone模式</h5><p>如果服务器上没有部署任何web服务，或者不想使用已部署的服务，则可以使用Standalone模式，该模式下，certbot 会自动运行一个 web server 来进行验证。该服务需要占用<span class="tips">80</span>端口，如果我们自己的服务器上已经有 web server 正在运行 （如 Nginx 或 Apache ）并且占用了80端口，则使用Standalone前应该关闭相关服务或修改端口。</p><pre><code>certbot certonly --standalone -d 域名</code></pre><p>可以在命令中指定验证的端口和协议</p><div class="show"><code>certbot certonly --standalone --&lt;challenge-type>-address  -d 域名</code></div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>更多验证方法详见官方文档：<a href="https://eff-certbot.readthedocs.io/en/stable/">https://eff-certbot.readthedocs.io/en/stable/</a></div><h4 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h4><p>certbot完成认证后会开始进入申请流程，初次申请证书，可能需要经历以下流程：</p><ul><li>certbot会提示你阅读并同意使用者条款</li><li>让你输入一个email地址以推送消息，在证书快到期时，lets encrypt会发邮件提醒你及时更新证书</li><li>询问是否愿意将该邮箱提供给EFF，他们会推送有关lets encrypt 的资讯</li></ul><p>邮箱的添加可以在一开始使用<span class="tips"></span></p><p>证书申请成功后，certbot会返回如下提示信息，其中较为重要的信息包括证书与密钥路径，证书到期时间</p><div class="shell">IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at:   /etc/letsencrypt/live/newyear1234.xyz/fullchain.pem   Your key file has been saved at:   /etc/letsencrypt/live/newyear1234.xyz/privkey.pem   Your certificate will expire on 2022-10-27. To obtain a new or   tweaked version of this certificate in the future, simply run   certbot again. To non-interactively renew *all* of your   certificates, run "certbot renew" - If you like Certbot, please consider supporting our work by:<p>   Donating to ISRG / Let’s Encrypt:   <a href="https://letsencrypt.org/donate">https://letsencrypt.org/donate</a><br>   Donating to EFF:                    <a href="https://eff.org/donate-le">https://eff.org/donate-le</a></div></p><h4 id="插件未安装报错问题"><a href="#插件未安装报错问题" class="headerlink" title="插件未安装报错问题"></a>插件未安装报错问题</h4><p>以nginx为例，执行<span class="tips">sudo certbot -&zwnj;-nginx</span>时，可能会有nginx插件未被正确安装报错</p><div class="shell">The requested nginx plugin does not appear to be installed</div><p>安装nginx插件</p><pre><code>yum install python-certbot-nginx</code></pre><p>问题叠问题，如果源中没有该插件包，又可能会遇到报错提示无有效的包</p><div class="shell">No package python-certbot-nginx available.Error: Nothing to do</div><p>此时需要更换一下repo 源，更换前记得先将自己的源的备份</p><pre><code>yum remove -y epel-release  # 先移除当前的包</code></pre><pre><code>yum clean all -v     # 清除所有下载缓存的包，并显示过程</code></pre><pre><code>yum makecache        # 重新将远程服务器的包下载缓存到本地</code></pre><pre><code>yum install -y epel-release # 重新安装 epel </code></pre><p>安装完epel，再重新尝试安装插件，安装完成就可以开始申请证书了</p><pre><code>yum install python-certbot-nginx</code></pre><h4 id="web服务无法找到报错问题"><a href="#web服务无法找到报错问题" class="headerlink" title="web服务无法找到报错问题"></a>web服务无法找到报错问题</h4><p>执行<span class="tips">sudo certbot -&zwnj;-nginx</span>时，还可能会遇到 certbot 无法找到 web server 或配置文件报错，这是路径问题，可以建一个软链接到 /etc/nginx 目录下</p><pre><code>ln -s /usr/local/nginx/conf/ /etc/nginx</code></pre><p>或者在申请证书时手动指定nginx配置文件路径</p><pre><code>certbot --nginx-server-root /usr/local/nginx/conf</code></pre><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><p>证书申请成功后，相关文件会放置在<span class="tips">/etc/letsencrypt</span>目录下，一般就用得到证书和密钥文件</p><h4 id="密钥与证书"><a href="#密钥与证书" class="headerlink" title="密钥与证书"></a>密钥与证书</h4><p>证书和密钥位于 <span class="tips">/etc/letsencrypt/live/域名.xx/</span> 路径下，该路径下有如下几个文件（配置时一般只需要fullchain.pem和privkey.pem文件）：</p><ul><li><span class="strong">fullchain.pem：</span>完整的证书链文件，包含了cert.pem和chain.pem文件中的内容</li><li><span class="strong">privkey.pem：</span>证书对应的私钥</li><li>cert.pem：证书文件，需要与chain.pem文件结合使用</li><li>chain.pem：链文件，包含了浏览器解析所需的其他全部证书，比如根证书和中间证书</li><li>README：说明文件</li></ul><h4 id="通用配置文件"><a href="#通用配置文件" class="headerlink" title="通用配置文件"></a>通用配置文件</h4><p>在<span class="tips">/etc/letsencrypt</span>路径下会生成Nginx的通用配置文件<span class="tips">options-ssl-nginx.conf</span></p><div class="shell">ssl_session_cache shared:le_nginx_SSL:10m;ssl_session_timeout 1440m;<p>ssl_protocols TLSv1.2;<br>ssl_prefer_server_ciphers off;</p><p>ssl_ciphers “FCDHE-FCLSA….”;</div></p><ul><li>ssl_session_cache：会话缓存</li><li>ssl_session_timeout：用户会话缓存失效时间，如果对安全性有较高要求，可以降低此值</li><li>ssl_protocols：加密协议</li><li>ssl_prefer_server_ciphers：是否开启服务端加密算法优先</li><li>ssl_ciphers：加密算法列表</li></ul><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><p>在<span class="tips">/etc/letsencrypt</span>路径下还有一个用于密钥交换算法的Diffie-Hellman 密钥<span class="tips">ssl-dhparams.pem</span></p><h4 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h4><p><span class="tips">/etc/letsencrypt/archive</span>和<span class="tips">/etc/letsencrypt/keys</span>包含所有以前的密钥和证书，而<span class="tips">/etc/letsencrypt/live</span>目录下保存了最新的证书和密钥</p><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>默认情况下，certbot 的日志文件位于/var/log/letsencrypt 路径下。且默认情况下，一旦日志目录中有 1000 条日志，certbot 就会开始日志轮替。</p><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><div class="show">server {listen 443 ssl;<p>#配置SSL证书和密钥路径<br>ssl_certificate    /etc/letsencrypt/live/域名/fullchain.pem;<br>ssl_certificate_key    /etc/letsencrypt/live/域名/privkey.pem;</p><p>#可以将certbot生成的通用配置文件包含进去，自由选择<br>include    /etc/letsencrypt/options-ssl-nginx.conf;</p><p>#使用生成的Diffie-Hellman 密钥，自由选择<br>ssl_dhparam    /etc/letsencrypt/ssl-dhparams.pem;<br>……<br>}</div></p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>Diffie-Hellman密钥用于密钥交换</div><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="测试自动续订"><a href="#测试自动续订" class="headerlink" title="测试自动续订"></a>测试自动续订</h4><ul><li><span class="strong">sudo certbot renew -&zwnj;-dry-run</span> 测试更新证书</li></ul><p>如果测试成功，certbot会返回成功信息</p><div class="shell">- - - - -Account registered.Simulating renewal of an existing certificate for newyear110.xyz- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Congratulations, all simulated renewals succeeded:   /etc/letsencrypt/live/newyear110.xyz/fullchain.pem (success)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </div><h5 id="插件未安装报错"><a href="#插件未安装报错" class="headerlink" title="插件未安装报错"></a>插件未安装报错</h5><p>在测试续订时，如果遇到插件未安装的报错，则需要安装nginx插件</p><div class="shell">Failed to renew certificate newyear110.xyz with error: The requested nginx plugin does not appear to be installed</div><p>安装<span class="tips">letsencrypt-nginx</span>插件</p><pre><code>pip3 install -U letsencrypt-nginx</code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>更多关于插件未安装的报错，可以查看github上的Issues，上述解决方法也来源于该贴：<a href="https://github.com/certbot/certbot/issues/1736">https://github.com/certbot/certbot/issues/1736</a></div><h4 id="续订证书"><a href="#续订证书" class="headerlink" title="续订证书"></a>续订证书</h4><ul><li><span class="strong">certbot renew</span> 自动更新30天内到期的证书（推荐）</li><li><span class="strong">certbot renew -&zwnj;-force-renewal</span> 强制更新未到期的证书</li></ul><p>在初次申请证书时，certbot会记住所使用的配置和插件，并在续订时使用相同的配置和插件。如果需要更改配置（如：修改文件路径），则需要以下步骤</p><ol><li>在命令行中使用修改以后的配置进行一次测试自动续订</li><li>测试成功，说明新的配置是可以运行的，再执行一次证书更新（时间未到就使用强制更新），这将保存新的配置</li></ol><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>CA机构会限制证书颁发速度并阻止用户在短时间内多次续订同一个域名的证书，所以不要在短时间内多次执行强制更新证书操作</div><h4 id="查看证书列表"><a href="#查看证书列表" class="headerlink" title="查看证书列表"></a>查看证书列表</h4><ul><li><span class="strong">certbot certificates</span> 查看证书</li></ul><p>会返回当前所有域名的证书情况，包括证书名、 证书序列号、密钥类型、到期时间、证书路径、私钥路径信息</p><div class="show">Found the following certs:  Certificate Name: newyear110.xyz    Serial Number: 34829c6e3465f2b1b90db11c36111480280    Key Type: RSA    Domains: newyear110.xyz    Expiry Date: 2022-10-27 11:47:25+00:00 (VALID: 87 days)    Certificate Path: /etc/letsencrypt/live/newyear110.xyz/fullchain.pem    Private Key Path: /etc/letsencrypt/live/newyear110.xyz/privkey.pem</div><h4 id="吊销与删除证书"><a href="#吊销与删除证书" class="headerlink" title="吊销与删除证书"></a>吊销与删除证书</h4><p>删除与吊销证书前，应当从web服务器软件的配置文件中删除对对应证书的引用</p><ul><li><span class="strong">certbot revoke -&zwnj;-cert-name 域名.xxx</span> 吊销证书(根据域名)</li><li><span class="strong">certbot revoke -&zwnj;-cert-path /etc/letsencrypt/live/域名.xxx/cert.pem</span> 吊销证书(根据路径)</li><li><span class="strong">certbot delete -&zwnj;-cert-name 域名.xxx</span> 删除指定证书</li><li><span class="strong">certbot delete</span> 从列表中选择删除证书</li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>官方命令和文档：<a href="https://eff-certbot.readthedocs.io/en/stable/using.html">https://eff-certbot.readthedocs.io/en/stable/using.html</a></div>]]></content>
    
    
    <summary type="html">用于部署https服务，certbot官方文档中的步骤可能需要重新编译Linux内核，可以使用python包管理工具绕开</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>路由与路由守卫</title>
    <link href="https://shiwei11.github.io/blog/2022/07/16/%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/"/>
    <id>https://shiwei11.github.io/blog/2022/07/16/%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</id>
    <published>2022-07-16T04:55:14.000Z</published>
    <updated>2022-07-19T15:06:13.311Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>vue路由官方网站：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></div><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>Vue Router 是Vue的官方路由插件，用于构建单页应用</li><li>页面不刷新，配合ajax实现页面的局部更新，并响应式更新地址栏URL</li><li>在工程中，普通组件一般放在components下，而路由组件放于pages目录下</li><li>切换组件时，未调用的组件是被销毁的，调用时被挂载</li><li>整个应用由一个<span class="tips">router</span>(路由器)统一管理，通过<span class="tips">$router</span>调用</li><li>但每个路由组件都有自己的<span class="tips">$route</span>属性</li></ul><h4 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue router"></a>安装vue router</h4><p>vue2的工程使用vue-router3，vue3的工程使用vue-router4，版本需要对应，这里以安装vue-router3为例</p><p>在脚手架中执行：<br><code><pre>npm i vue-router@3</pre></code></p><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>案例：通过组件嵌套，实现功能</p><ol><li>在app单个页面中通过按钮实现Home和About页面的切换</li><li>About页面中嵌套aboutMe和aboutWeb页面</li></ol><p><span class="strong">1. 新建pages目录，存放Home.vue、About.vue、aboutMe、aboutWeb组件</span></p><p>Home.vue文件:</p><pre><code>&lt;template>  &lt;div class="home">    &lt;h2>Home页面&lt;/h2>  &lt;/div>&lt;/template>&lt;script>export default &#123;    name:'pageHome'  &#125;&lt;/script></code></pre><p>About.vue文件:</p><pre><code>&lt;template>  &lt;div class="about">    &lt;h2>About页面&lt;/h2>    &lt;div class="about-btn">    &lt;!--router-link标签路由切换按钮的两种写法，该标签最后会被解析为a标签-->    &lt;!--1. 根据路径调用组件-->    &lt;router-link to="/about/aboutWeb">关于网页&lt;/router-link>     &lt;router-link to="/about/aboutMe">关于我&lt;/router-link>     &lt;!--2. 根据路由规则中的name属性调用组件-->    &lt;router-link :to="&#123;name: 'aboutme'&#125;">关于网页&lt;/router-link>     &lt;router-link :to="&#123;name: 'aboutweb'&#125;">关于我&lt;/router-link>     &lt;/div>    &lt;div class="about-content">    &lt;!--子组件显示的位置-->    &lt;router-view>&lt;/router-view>     &lt;/div>  &lt;/div>&lt;/template> &lt;script> export default &#123;     name:'pageAbout' &#125;&lt;/script></code></pre><p>aboutWeb.vue文件 (aboutMe.vue类似)</p><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">&#123;&#123;t&#125;&#125;&lt;/li>    &lt;/ul>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:&#123;                前端:'html/css/javaScript',                后端:'java',                系统:'CentOS7',                服务器:'nginx'            &#125;        &#125;    &#125; &#125;&lt;/script></code></pre><p><span class="strong">2. 新建router目录，新建index.js文件用于创建路由器</span><br>index.js文件：</p><pre><code>// 引入vueRouter插件import VueRouter from "vue-router";//引入路由组件import Home from '../pages/pageHome'import About from '../pages/pageAbout'import aboutMe from '../pages/aboutMe'import aboutWeb from '../pages/aboutWeb'// 创建路由器export default new VueRouter(&#123;    // 创建路由规则一个&#123;&#125;内为一条路由    routes:[        &#123;            name: 'home',    //路由规则指定的组件别名            path:'/home',   //路由路径            component:Home //调用的组件        &#125;,        &#123;               name: 'about',            path:'/about',            component:About,            children:[     //组件嵌套                &#123;                       name:'aboutme',                    path:'aboutMe',                    component:aboutMe                &#125;,                &#123;                       name:'aboutweb',                    path:'aboutWeb',                    component:aboutWeb                &#125;            ]        &#125;    ] &#125;)</code></pre><p><span class="strong">3. 在main.js中引入路由器</span></p><pre><code>import Vue from 'vue'import App from './App.vue'// 引入vue-routerimport VueRouter from 'vue-router'// 使用vue-routerVue.use(VueRouter)// 引入创建的路由器import router from './router'new Vue(&#123;  render: h => h(App),  router:router   //配置路由器&#125;).$mount('#app')</code></pre><p><span class="strong">4. 在App中调用路由组件</span></p><pre><code>&lt;template>  &lt;div id="app">    &lt;div class="btn">      &lt;!-- active-class用于指定该链接按钮被选中时生效的样式-->      &lt;router-link class="link" active-class="active" to="/home">Home&lt;/router-link>      &lt;router-link class="link" active-class="active" to="/about">About&lt;/router-link>      &lt;!-- 同样，to可以写为对象形式 -->      &lt;router-link class="link" active-class="active" :to="&#123;name:'home'&#125;">Home&lt;/router-link>      &lt;router-link class="link" active-class="active" :to="&#123;name:'about'&#125;">About&lt;/router-link>    &lt;/div>    &lt;div class="content">      &lt;!-- 指定组件显示的位置 -->      &lt;router-view>&lt;/router-view>    &lt;/div>  &lt;/div>&lt;/template>&lt;script> export default &#123;  name:'App', &#125;&lt;/script></code></pre><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a>query传参</h4><p>父组件可通过向<span class="tips"> to </span>属性添加参数进行传参，类似于带参数的http请求，子路由可通过<span class="tips">$route.query.参数名</span>读取数据</p><p>案例：为aboutWeb组件添加子组件webTech，并由aboutWeb向webTech传参</p><h5 id="方法1：通过字符串传参"><a href="#方法1：通过字符串传参" class="headerlink" title="方法1：通过字符串传参"></a>方法1：通过字符串传参</h5><p>在路由路径后添加查询字符串<span class="tips"> ? </span>，并在之后以键值对的方式传参。</p><p>父组件 aboutWeb.vue</p><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">        &lt;!-- 字符串写法 -->        &lt;!-- 注意：由于to前使用了:解析js语法，因此要添加``将语句解析为字符串 -->        &lt;router-link :to="`/about/aboutWeb/webTech?name=$&#123;t.name&#125;&lang=$&#123;t.language&#125;`">&#123;&#123;t.name&#125;&#125;&lt;/router-link>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'框架',language:'vue'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125; &#125;&lt;/script></code></pre><h5 id="方法2：通过对象传参"><a href="#方法2：通过对象传参" class="headerlink" title="方法2：通过对象传参"></a>方法2：通过对象传参</h5><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">        &lt;!-- 对象写法 -->            &lt;router-link :to="&#123;            path:'/about/aboutWeb/webTech',            query:&#123;                name:t.name,                lang:t.language            &#125;            &#125;">            &#123;&#123;t.name&#125;&#125;            &lt;/router-link>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'框架',language:'vue'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125; &#125;&lt;/script></code></pre><h5 id="子路由读取参数"><a href="#子路由读取参数" class="headerlink" title="子路由读取参数"></a>子路由读取参数</h5><p>webTech.vue文件：</p><pre><code>&lt;template>  &lt;div class="show">  &lt;!-- 读取数据 -->    &lt;span class="tech-name">&#123;&#123;$route.query.name&#125;&#125;：&lt;/span>    &lt;span class="tech-lang">&#123;&#123;$route.query.lang&#125;&#125;&lt;/span>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'webTech' &#125;&lt;/script></code></pre><h4 id="params传参"><a href="#params传参" class="headerlink" title="params传参"></a>params传参</h4><h5 id="方法1：通过字符串传参-1"><a href="#方法1：通过字符串传参-1" class="headerlink" title="方法1：通过字符串传参"></a>方法1：通过字符串传参</h5><p>通过字符串传参时，必须在配置路由规则时在<span class="tips">path</span>路径中指定解析的参数</p><pre><code> &#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    path:'webTech/:name/:lang', //在路径中解析参数    conpontent:webTech  &#125;]      &#125;</code></pre><p>父组件通过附带参数的路径传输参数</p><pre><code>&lt;router-link :to="`/about/aboutWeb/webTech?name=$&#123;t.name&#125;&lang=$&#123;t.language&#125;`">&#123;&#123;t.name&#125;&#125;&lt;/router-link></code></pre><p>子组件通过<span class="tips">$route.params.参数名</span>读取参数</p><pre><code>&lt;span class="tech-name">&#123;&#123;$route.params.name&#125;&#125;&lt;/span>&lt;span class="tech-lang">&#123;&#123;$route.params.lang&#125;&#125;&lt;/span></code></pre><h5 id="方法2：通过对象传参-1"><a href="#方法2：通过对象传参-1" class="headerlink" title="方法2：通过对象传参"></a>方法2：通过对象传参</h5><p>通过对象传参时，<span class="tips">to</span>属性不能再使用<span class="tips">path</span>调用组件，而需要使用<span class="tips">name</span>属性，因此路由规则中一定需要给予组件name属性</p><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech' //必须    path:'webTech/:name/:lang', //必须    conpontent:webTech  &#125;]      &#125;</code></pre><p>传参的父组件</p><pre><code>&lt;router-link :to="&#123;            name:'webtech', //不能使用path            params:&#123;                name:t.name,                lang:t.language            &#125;&#125;">            &#123;&#123;t.name&#125;&#125;&lt;/router-link></code></pre><p>子组件通过<span class="tips">$route.params.参数名</span>读取参数，代码同上</p><h4 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h4><p>当需要大量调用参数时，频繁使用$route.query增加了代码量，可以在路由中配置<span class="tips">props</span>属性简化代码。props属性支持三种配置方法。</p><h5 id="1-对象形式，传输固定参数"><a href="#1-对象形式，传输固定参数" class="headerlink" title="1. 对象形式，传输固定参数"></a>1. 对象形式，传输固定参数</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech',    conpontent:webTech,    //对象形式，传输固定参数    props:&#123; name:'框架',            lang:'Vue'&#125;  &#125;]      &#125;</code></pre><h5 id="2-函数形式，传输指定参数-用query"><a href="#2-函数形式，传输指定参数-用query" class="headerlink" title="2. 函数形式，传输指定参数(用query)"></a>2. 函数形式，传输指定参数(用query)</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech',    conpontent:webTech,    //对象形式，传输固定参数    pros(route)&#123;      return &#123;        name: route.query.name,        lang: route.query.language      &#125;    &#125;  &#125;]      &#125;</code></pre><h5 id="3-布尔值，自动传输所有params参数"><a href="#3-布尔值，自动传输所有params参数" class="headerlink" title="3. 布尔值，自动传输所有params参数"></a>3. 布尔值，自动传输所有params参数</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech/:name/:lang', //自动传输所有参数    conpontent:webTech,    //布尔值形式    pros: true  &#125;]      &#125;</code></pre><h5 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h5><p>子组件需要通过<span class="tips">props</span>属性接收参数</p><pre><code>&lt;span>&#123;&#123;name&#125;&#125;&lt;/span> //直接调用&lt;span>&#123;&#123;lang&#125;&#125;&lt;/span>export default&#123;   name:'webTech',  pros:['name','lang'] //接收参数   &#125;</code></pre><h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h3><p>路由导航分为声明式和编程式</p><ul><li><span class="strong">声明式：</span>通过&lt;router-link&gt;配置to属性实现跳转</li><li><span class="strong">编程式：</span>通过调用push、back等API跳转组件</li></ul><h4 id="路由导航与浏览器历史记录"><a href="#路由导航与浏览器历史记录" class="headerlink" title="路由导航与浏览器历史记录"></a>路由导航与浏览器历史记录</h4><p>浏览器历史记录默认为<span class="tips">push</span>状态，组件的跳转会记录到历史记录中，通过浏览器的前进/后退按钮，或者调用<span class="tips">go</span>、<span class="tips">back</span>等API，能根据历史记录实现页面的前进、回退。当浏览器历史记录切换为<span class="tips">replace</span>状态时，浏览器会使用当前页面的记录替换掉上一条历史记录。</p><pre><code> &lt;--跳转到About页面后，About页面的历史记录会替换掉该页的历史记录，此时无法再使用浏览器的回退按钮返回该页面了-->&lt;router-link replace to="...">跳转到About页面&lt;/router-link></code></pre><h4 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h4><p>不借助&lt;router-link&gt;标签，实现路由跳转<br>API：</p><ul><li><span class="strong">push：</span>跳转到指定路由组件</li><li><span class="strong">replace：</span>跳转到指定路由组件并替换浏览器历史记录</li><li><span class="strong">back：</span>回退</li><li><span class="strong">forward：</span>前进(需要之前回退过)</li><li><span class="strong">go(值)：</span>根据值前进/回退指定次数</li></ul><p>eg：通过按钮实现(或div)实现路由跳转</p><pre><code>&lt;template>  &lt;div>   &lt;button class="link" @click="backTo">回退&lt;/button>    &lt;button class="link" @click="forwardTo">前进&lt;/button>    &lt;button class="link" @click="goTo">跳转&lt;/button>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">            &lt;button @click="pushTo(t)">push&lt;/button>            &lt;button @click="replaceTo(t)">replace&lt;/button>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125;,    methods:&#123;        backTo()&#123;      this.$router.back() //回退一次    &#125;,    forwardTo()&#123;      this.$router.forward() //前进一次    &#125;,    goTo()&#123;      this.$router.go(-2) //，回退2步，正数前进，负数后退    &#125;,        pushTo(m)&#123;    //跳转到指定组件            this.$router.push(&#123;                path:'/about/aboutWeb/webTech',                query:&#123;                name:m.name,                lang:m.language            &#125;            &#125;)        &#125;,        replaceTo(n)&#123;  //跳转到指定组件并替换上一个历史记录            this.$router.replace(&#123;                path:'/about/aboutWeb/webTech',                query:&#123;                name:n.name,                lang:n.language            &#125;            &#125;)        &#125;    &#125; &#125;&lt;/script></code></pre><h3 id="路由组件的缓存"><a href="#路由组件的缓存" class="headerlink" title="路由组件的缓存"></a>路由组件的缓存</h3><p>当组件进行切换时，原组件会被销毁，原组件中未保存的表单内容等数据同时也会被删除，此时，可以使用<span class="tips">&lt;keep-alive&gt;</span>标签阻止组件被销毁，保留数据。</p><pre><code> //缓存多组件使用 :include="['组件1','组件2',...]"&lt;keep-alive include="aboutMe">   &lt;router-view>&lt;/router-view>&lt;/keep-alive></code></pre><h3 id="路由独有生命周期"><a href="#路由独有生命周期" class="headerlink" title="路由独有生命周期"></a>路由独有生命周期</h3><ul><li><span class="strong">activated：</span>当组件被激活时(显示到页面)</li><li><span class="strong">deactivated：</span>当组件失活时<br>当组件被&lt;keep-alive&gt;时，组件不会被销毁，在切换组件时created、destory等钩子函数不会执行，此时可以使用activated、deactivated替代。</li></ul><p>eg：使某组件在激活时启用定时器，失活时关闭</p><pre><code> export default &#123;  name:'webTech',  data()&#123;.....&#125;,  activated()&#123;            let timer=setInterval(....);            &#125;,  deactivated()&#123;            clearInterval(this.timer)            &#125; &#125;</code></pre><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p> 在切换组件时，可借助路由守卫来阻止/放行组件的跳转，常用于判断用户是否有权限访问，无权限时阻止访问,也可用于在组件跳转前后执行某些功能。</p><h4 id="前置、后置路由守卫-全局"><a href="#前置、后置路由守卫-全局" class="headerlink" title="前置、后置路由守卫(全局)"></a>前置、后置路由守卫(全局)</h4><p> 该路由守卫写于路由器配置文件中</p><ul><li><span class="strong">beforeEach((to,from,next)=&gt;{ })：</span>前置路由守卫，在<span class="tips">初始化、路由跳转前</span>执行，接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行</li><li><span class="strong">beforeEach((to,from)=&gt;{ })：</span>后置路由守卫，在<span class="tips">路由跳转后</span>执行，接收to,from两个参数</li></ul><p>eg: 检查用户是否为指定用户，不是则禁止访问aboutWeb和aboutMe组件</p><pre><code> import VueRouter from "vue-router"; import Home from '../pages/pageHome' import About from '../pages/pageAbout' import aboutMe from '../pages/aboutMe' import aboutWeb from '../pages/aboutWeb' import webTech from '../pages/webTech' const router= new VueRouter(&#123;    routes:[        &#123;            name:'home',            path:'/home',               component:Home,             meta:&#123;title:'首页'&#125;//meta为自定义属性，程序员可自定义添加任何参数        &#125;,        &#123;            name:'about',            path:'/about',            component:About,            meta:&#123;title:'关于'&#125;,            children:[                &#123;                    name:'aboutme',                    path:'aboutMe',                    component:aboutMe,                    meta:&#123;isAuth:true,//标识该组件是否需要鉴别权限                          title:'关于我'&#125;//用于组件跳转后修改地址栏标题                &#125;,                &#123;                    name:'aboutweb',                    path:'aboutWeb',                    component:aboutWeb,                    meta:&#123;isAuth:true,                        title:'关于网站'&#125;,                    children:[                        &#123;                            name:'webTech',                            path:'webTech',                            component:webTech,                            meta:&#123;title:'关于本站采用的技术'&#125;                        &#125;                    ]                &#125;            ]        &#125;    ] &#125;)// 全局前置路由守卫 router.beforeEach((to,from,next)=>&#123;        if(to.meta.isAuth)&#123;//确认是否鉴权，避免对所有组件都进行鉴权消耗性能 // 当组件不多时，可以使用下面的代码通过判断路径来识别哪些组件需要权限认证        // if(to.name==='aboutme'||to.path==='/about/aboutWeb')        //只有localStorage中的user为zhoujielun才能访问            if(localStorage.getItem('user')==='zhoujielun')&#123;                next() //放行访问            &#125;            else&#123;                alert('无权限访问')            &#125;        &#125;        else&#123;            next()  //对不需要权限认证的页面直接放行        &#125;  &#125;)// 全局后置路由守卫//用于切换完毕后，修改网页地址栏的标题 router.afterEach((to)=>&#123;    document.title=to.meta.title   &#125;) export default router</code></pre><h4 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h4><p>只为某个路由组件配置的路由守卫， 同样写于路由器配置文件中<br><span class="strong">beforeEnter:(to,from,next)=&gt;{ }</span>只对针对某个组件配置守卫，同样接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行</p><p>eg: 判断用户是否为指定用户，不是则禁止访问aboutMe组件</p><pre><code>&#123;            name:'about',            path:'/about',            component:About,            meta:&#123;title:'关于'&#125;,            children:[                &#123;                    name:'aboutme',                    path:'aboutMe',                    component:aboutMe,                    meta:&#123;isAuth:true,//鉴别权限                          title:'关于我'&#125;,                          //独享路由守卫                          beforeEnter:(to,from,next)=>&#123;                                if(to.meta.isAuth)&#123;                                  //只有localStorage中的user为zhoujielun才能访问                                    if(localStorage.getItem('user')==='zhoujielun')&#123;                                        next()                                    &#125;                                    else&#123;                                        alert('无权限访问')                                    &#125;                                &#125;                                else&#123;                                    next()                                &#125;                           &#125;                &#125;,</code></pre><h4 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h4><p>无法修改路由器配置文件时，可以将路由守卫设于组件.vue的文件中。<span class="tips">组件内的路由守卫只会在通过路由规则进入组件时才会执行</span>，如果将组件标签直接添加到页面中，该组件会被调用，但此时不属于通过路由规则进入组件，不会执行下述路由守卫函数。</p><ul><li><span class="strong">beforeRouteEnter(to,from,next){ }</span>：进入组件前执行</li><li><span class="strong">beforeRouteLeave(to,from,next){ }</span>：离开组件前执行</li><li><span class="strong">beforeRouteUpdate(to,from,next){ }</span>：组件更新时执行</li></ul><pre><code>&lt;template>  &lt;div class="about">    &lt;h2>About页面&lt;/h2>    &lt;div class="about-btn">    &lt;router-link  to="/about/aboutWeb">关于网页&lt;/router-link>    &lt;router-link  to="/about/aboutMe">关于我&lt;/router-link>    &lt;/div>    &lt;div class="about-content">      &lt;keep-alive include="aboutMe">      &lt;router-view>&lt;/router-view>      &lt;/keep-alive>    &lt;/div>  &lt;/div> &lt;/template> &lt;script> export default &#123;    name:'pageAbout',    // 通过路由规则进入组件时调用    beforeRouteEnter(to,from,next)&#123;      //只有localStorage中的user为zhoujielun才能访问            if(localStorage.getItem('user')==='zhoujielun')&#123;                    next()                    &#125;            else&#123;                 alert('无权限访问')             &#125;    &#125;,     // 通过路由规则离开组件时调用    beforeRouteLeave(to,from,next)&#123;      console.log('即将离开组件')        next();//放行    &#125;&#125; &lt;/script></code></pre>]]></content>
    
    
    <summary type="html">vue构建单页应用笔记，包括路由嵌套、传参、导航、生命周期、路由守卫</summary>
    
    
    
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
    <category term="vue" scheme="https://shiwei11.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>yaml语法</title>
    <link href="https://shiwei11.github.io/blog/2022/07/14/yaml%E8%AF%AD%E6%B3%95/"/>
    <id>https://shiwei11.github.io/blog/2022/07/14/yaml%E8%AF%AD%E6%B3%95/</id>
    <published>2022-07-14T07:48:44.000Z</published>
    <updated>2022-07-16T05:55:32.969Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>YAML官方文档：<a href="https://yaml.org/spec/1.2.2/">YAML 1.2.2</a></div><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>YAML是一种数据序列化语言，可用于存储和传输数据，常用于编写配置文件、数据文件、日志文件，以及跨语言进行数据共享等环境，大多数编程语言都可以使用 YAML 进行数据序列化。</p><p>YAML文件后缀为<span class="tips">.yml</span>或<span class="tips">.yaml</span></p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><span class="strong">1. 通常使用键值对形式</span></p><ul><li>键与值通常不需要引号包裹 (这点与json不同)</li><li>值可以为：数组、对象、标量值</li><li>标量值是指：整数、浮点数、字符串、布尔值、Null、时间、日期</li></ul><p><span class="strong">2. 通过缩进或者样式流表示数据结构</span></p><ul><li>数据可以通过空格缩进来表示层级关系，但不能用制表符(Tab)</li><li>子结构相较父结构必须缩进至少一个空格，同一级数据须缩进相同空格数，即左端对齐</li><li>也可以使用花括号{&nbsp;}，中括号[&nbsp;]等样式流表示层级关系<br><span class="strong">3. 大小写敏感</span><br><span class="strong">4. 使用#号注释</span></li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>最为常用的数据类型，又称为字典、哈希、映射，以<span class="tips"> key: &nbsp;value </span>键值对的形式存储数据，<span class="tips">key: 后需要有空格!</span></p><h4 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h4><div class="show">name: JayChoualbum: 十一月的萧邦</div><p>或者使用样式流：</p><div class="show">{    name: JayChou,    album: 十一月的萧邦}</div>等同于json格式下的<div class="show">{  "name": "JayChou",  "album": "十一月的萧邦"}</div><h4 id="缩进与嵌套"><a href="#缩进与嵌套" class="headerlink" title="缩进与嵌套"></a>缩进与嵌套</h4><p>可以通过缩进至少一个空格表示层级关系，从而嵌套其他对象、数组等</p><div class="show">student:   name: aaa   age: 16   hobby:    - basketball    - swimming</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>多级嵌套时，每层嵌套都应当缩进，<span class="tips">且每个子元素左边应该缩进相等的空格数，即左端对齐</span></div>   使用样式流：   <div class="show">student: {        name: aaa,        age: 16,        hobby: [ basketball , swimming ]   }</div><h4 id="复杂对象格式"><a href="#复杂对象格式" class="headerlink" title="复杂对象格式"></a>复杂对象格式</h4><p>使用<span class="tips">?加空格</span>可以指定多个key值，使用<span class="tips">:加空格</span>指定多个value</p><div class="show">?       - key1      - key2:       - value1      - value2</div>    表示key是一个数组，值也是一个数组，样式流：    <div class="show">key1,key2: ["value1","value2"]</div><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用<span class="tips strong">-</span>开头表示数组元素</p><h4 id="数组写法"><a href="#数组写法" class="headerlink" title="数组写法"></a>数组写法</h4><div class="show">- value1- value2- value3</div>样式流：<div class="show">[value1,value2,value3]</div><h4 id="缩进与嵌套-1"><a href="#缩进与嵌套-1" class="headerlink" title="缩进与嵌套"></a>缩进与嵌套</h4><p>可以通过缩进表示层级关系，来嵌套数组、对象等</p><div class="show">- name: 周杰伦,  age: 42,  songs:    - 夜曲   - 米兰的小铁匠- name: 林肯公园,  age: 41,  songs:   - In the End   - Numb</div>样式流<div class="show">[  {    name: 周杰伦,    age: 42,    songs: [ 夜曲 , 米兰的小铁匠 ]  },  {    name: 林肯公园,    age: 41,    songs: [ In the End , Numb ]  }]</div><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>标量指最基本的，不可再分的值，这里指：整数、浮点数、字符串、布尔值、Null、时间、日期</p><p>基本使用方法：</p><div class="show">1. 整数可以为非十进制数num1: 120           #普通十进制数num2: 0b10_1011     #二进制以0b开头num3: 07100         #八进制以0开头num4: 0xf1ab        #十六进制以0x开头2. 浮点数可以使用科学计数法float1: 3.14float2: 3.1415926e+5 #科学计数法314159.26float3: -.inf        #负无穷大flota4: .nan         #不是数字3. 布尔值大小写均可bool: true值为：true、True、TRUE均可，但TRUe将被解析为字符串4. Null可用<span class="tips">~</span>表示data: ~5. 日期必须使用ISO 8601格式，即yyyy-MM-dddate: 2021-07-156. 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区time: 2021-07-15T00:42:31+08:00在JavaScript中解析为Thu Jul 15 2021 00:42:31 GMT+0800 (中国标准时间)7. 使用<span class="tips">!!数据类型 值</span>进行类型转换date: !!str 2021-01-15</div><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>一般情况下，字符串不需要添加引号，但如果字符串中间包含特殊字符，尤其是<span class="tips">冒号加空格</span>组合时，为了避免被yaml解析为键值对，需要添加引号</p><div class="show">str: 'said: meet you like wind'</div><p>给数值等标量添加引号将解析为字符串</p><div class="show">str: '99.99'</div><p>多行字符串，<span class="tips">第二行开始所有行需要缩进至少一个空格</span>，但解析时将被解析为一行字符串，且换行符会被替换为空格</p><div class="show">str: aaaa bbbb cccc 将被解析为 str: "aaaa bbbb cccc"</div><h4 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h4><p> 单引号和双引号均可以用于包裹字符串</p><ul><li><span class="strong">单引号会原样输出，将转义字符作为普通字符串输出</span></li><li><span class="strong">双引号会转义字符串，如将 \n 转义为换行</span></li></ul><div class="show">如：content: '不会\n换行'内容输出为：<span class="tips">不会\n换行</span>content: "进行\n换行"内容输出为： <span class="tips">进行  换行</span></div><h4 id="区块字符串处理"><a href="#区块字符串处理" class="headerlink" title="区块字符串处理"></a>区块字符串处理</h4><ol><li><p>多行字符串可以使用<span class="tips strong">|</span>保留所有换行符，内容从第二行开始需要缩进至少一个空格，且最后一行的换行符也会保留。</p><div class="show">lyrics: |aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd<br/></div></li><li><p>可以使用<span class="tips strong">&gt;</span>去除换行，换行符将被空格代替 (如果某一行是空行，该空行会被额外保留)</p><div class="show">lyrics: >aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbb cccc dddd</div></li><li><p>可以使用<span class="tips strong">+</span>保留文字块末尾的换行</p><div class="show">lyrics: |+aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd<br/></div></li><li><p>可以使用<span class="tips strong">-</span>去除文字块末尾的换行</p><div class="show">lyrics: |-aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd</div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>在yml文件中配置好字符串格式后，读取到html中时往往需要添加如<span class="tips">white-space: pre-line;</span>等css属性来保留换行符和空格，否则读入的数据可能会被css默认样式去除换行符，从而无法展示原生yml指定的数据格式</div></li><li><div class="tips strong">在样式流中，无法使用 | > + -</div><div class="show">如：以上数据写为样式流          {             lyrics: |-             aaaa              bbbb             cccc              dddd            }|- 将无法解析，抛出错误</div></li></ol><h3 id="添加HTML标签"><a href="#添加HTML标签" class="headerlink" title="添加HTML标签"></a>添加HTML标签</h3><p>yaml允许在值中添加HTML标签，并且标签会被正确地解析为DOM</p><div class="show">- tag: web  content: 推荐网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>  或  <div class="show">- tag: web  content: |-   推荐   网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>解析为：<div class="show">推荐网站 <a href="#">SHIWIVI</a></div>   <div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>使用时需要注意，插入的HTML标签是否会被其他语言解析为字符串，但yaml本身是可以输出为DOM元素的</div><h3 id="锚点与引用"><a href="#锚点与引用" class="headerlink" title="锚点与引用"></a>锚点与引用</h3><p>可以使用<span class="tips">&amp;</span>定义一个锚点，然后使用<span class="tips">*</span>引用锚点</p><div class="show">first: &anchor  #定义锚点 - aaa - bbbsecond:  *anchor #调用锚点</div>解析为<div class="show">first: [aaaaa,bbb]second: [aaaaa,bbb] </div><p>如果将多个键值对引用到其他地方，可以使用<span class="tips">&lt;&lt;</span>合并数据</p><div class="show">first: &data  #定义锚点   name: lol   age: 18   hobby:    - sing    - swingsecond:    <<: *data    #将数据插入此处   address: zzz</div> 解析为： <div class="show">{  "first": {      "name": "lol",      "age": 18,      "hobby": "sing  swimming"  },  "second": {      "name": "lol",      "age": 18,      "hobby": "sing  swimming",      "address": "zzz"  }}</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>如果多次定义了同名的锚点(重定义)，则先定义的锚点会被覆盖</div><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>一个完整的yml文档以<span class="tips">-&zwnj;-&zwnj;-</span>标识文档开始，以<span class="tips">…</span>标识文档结束，该标识非必须，无标识的称为<span class="tips">裸文档</span>，文件开头可以添加<span class="tips">%YAML</span>来识别文件的YAML版本</p><div class="show">%YAML 1.2# 开头注释，注明文档作者等信息---ip: 45.77.77.49port: 443...</div><p>一个yml文件中可能有多个文档</p><div class="show">---ip: 45.77.77.10port: 80...---ip: 45.77.77.11port: 443...</div>但如果在一个yml文件中写入多个文档，在某些环境下读入可能报错，需要分割为多个文件<div class="shell">err: YAMLException: expected a single document in the stream, but found more</div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>更多语法和拓展详见官方文档</div>]]></content>
    
    
    <summary type="html">YAML Ain’t Markup Language，小猫咪都会写的yaml文件</summary>
    
    
    
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
    <category term="File" scheme="https://shiwei11.github.io/blog/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Grid栅格布局</title>
    <link href="https://shiwei11.github.io/blog/2022/06/14/Grid%E5%B8%83%E5%B1%80/"/>
    <id>https://shiwei11.github.io/blog/2022/06/14/Grid%E5%B8%83%E5%B1%80/</id>
    <published>2022-06-14T07:03:12.000Z</published>
    <updated>2022-07-02T11:49:59.185Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>Grid在MDN上翻译为网格布局，在《CSS权威指南》中翻译为栅格布局，其实是同一种布局方案，本文语句主要整理自《CSS权威指南》一书</div><h3 id="1-栅格布局"><a href="#1-栅格布局" class="headerlink" title="1. 栅格布局"></a>1. 栅格布局</h3><p>Grid 是一种强大的布局方案，也是最为普适的布局方案，允许在Web上创建二维布局，通过对父元素定义不同参数的行与列垂直线，再将子元素部署于行列网格上，由此实现各类灵活的布局，如：<br><br/></p><div style="display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;"><div style="background-color:#EA2027;grid-area:a;">box1</div><div style="background-color:#fff200;grid-area:b;">box2</div><div style="background-color:#7d5fff;grid-area:c;">box3</div><div style="background-color:#32ff7e;grid-area:d;">box4</div><div style="background-color:#4b4b4b;grid-area:e;">box5</div></div><br/><p>通过标准流、float、flex也可以实现类似的布局，但这些方案往往需要更多的DOM元素，或者需要指定更多的参数，并且很多情况下无法做到自适应，此时，grid布局方案的优势就体现出来了。并且语法兼容性也很好，除了那位大爷…..</p><div class="table"><table><thead><tr><th>Chrome</th><th>Edeg</th><th>Firefox</th><th>IE</th><th>Opera</th><th>Safari</th></tr></thead><tr><td>57</td><td>16</td><td>52</td><td style="color:red;">不支持</td><td>44</td><td>10.1</td></tr></table></div><h3 id="2-栅格容器"><a href="#2-栅格容器" class="headerlink" title="2. 栅格容器"></a>2. 栅格容器</h3><p>创建栅格的第一步就是创建一个栅格容器，并将其中的内容定义为栅格布局</p><h4 id="2-1-栅格属性"><a href="#2-1-栅格属性" class="headerlink" title="2.1 栅格属性"></a>2.1 栅格属性</h4><p><span class="strong">display: grid/inline-grid;</span></p><p>指定容器布局方式为栅格布局，该属性和 block 与 inline-block 值相似</p><h4 id="2-2-定义栅格模板"><a href="#2-2-定义栅格模板" class="headerlink" title="2.2 定义栅格模板"></a>2.2 定义栅格模板</h4><p><span class="strong">grid-template-columns: 值;</span></p><p><span class="strong">grid-template-rows: 值;</span></p><p>将容器划分为行列栅格,栅格线的值可以为<span class="tips">固定值</span>、<span class="tips">百分比</span>、<span class="tips">fr关键字</span>、<span class="tips">repeat()语句</span>、<span class="tips">minmax()语句</span>、<span class="tips">calc()函数</span>等，并且参数可以混用</p><h5 id="2-2-1-固定值行列轨道宽度"><a href="#2-2-1-固定值行列轨道宽度" class="headerlink" title="2.2.1 固定值行列轨道宽度"></a>2.2.1 固定值行列轨道宽度</h5><p>将子元素宽高设为固定值，单位可以为px，也可以为em、rem等相对单位</p><div class="show">如：给父元素指定行列轨道宽度，子元素可以不设置任何参数div{    display:grid;    grid-template-columns:50px 60px 100px;    grid-template-rows:50px 60px 100px;}</div><div style="display:grid;grid-template-columns:50px 60px 100px;grid-template-rows:50px 60px 100px;text-align:center;color:#fff;width:210px;margin:0 auto;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">类似的取值可以为    grid-template-columns:5em 5em 5em;</div><h5 id="2-2-2-百分比配置宽高"><a href="#2-2-2-百分比配置宽高" class="headerlink" title="2.2.2 百分比配置宽高"></a>2.2.2 百分比配置宽高</h5><p>将元素的宽高按百分比配置，可以让网页元素自适应不同屏幕大小</p><div class="show">如：元素宽高分别为20% 20% 50% div{    display:grid;    grid-template-columns:20% 20% 50%;    grid-template-rows:20% 20% 50%;    border:1px solid black;    box-sizing: border-box;}</div><div style="display:grid;grid-template-columns:20% 20% 50%;grid-template-rows:20% 20% 50%;text-align:center;color:#fff;width:280px;height:300px;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>百分比是基于父容器的宽度和高度计算，不管子元素内容大小如何变化也不会变，因此要给与父元素宽高参数，即不能再使用子元素撑开父元素了。若子元素宽高相加不到100%，则剩余部分空置</div><h5 id="2-2-3-fr按比例配置宽高"><a href="#2-2-3-fr按比例配置宽高" class="headerlink" title="2.2.3 fr按比例配置宽高"></a>2.2.3 fr按比例配置宽高</h5><p>grid布局提供了 <span class="tips">fr</span> 关键字(fraction)用于表示比例关系</p><div class="show">如：元素宽高比为1:2:2 div{    display:grid;    grid-template-columns:1fr 2fr 2fr;    grid-template-rows:1fr 2fr 2fr;    border:1px solid black;    box-sizing: border-box;}</div><div style="display:grid;grid-template-columns:1fr 2fr 2fr;grid-template-rows:1fr 2fr 2fr;text-align:center;color:#fff;width:210px;margin:0 auto;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">配合其他值来实现弹性布局     grid-template-columns:150px 1fr 10%;     <span class="tips">第一列宽为150px，最后一列宽为10%,剩下宽度给中间一列</span></div><h5 id="2-2-4-定义栅格线名称"><a href="#2-2-4-定义栅格线名称" class="headerlink" title="2.2.4 定义栅格线名称"></a>2.2.4 定义栅格线名称</h5><p>可以使用<span class="tips">[ ]</span>为边框线起名字，并且同一条线的名称可以有无数多个，如：<span class="tips">[a1 b1]</span>为同一条线取名a1和b1</p><div class="show">如：元素宽高比为1:2:2 div{    display:grid;    grid-template-columns: [c1] 80px [c2] 80px [c3] 80px [c4];    grid-template-rows: [r1] 60px [r2] 60px [r3] 60px [r4];    border:1px solid black;    box-sizing: border-box;}box1、box4、box7左边框线相连为c1，右边框线相连为c2；box1、box2、box3上边框线相连为r1，下边框线相连为r2其他以此类推</div><div style="display:grid;grid-template-columns:[c1] 80px [c2] 80px [c3] 80px [c4];    grid-template-rows:[r1] 60px [r2] 60px [r3] 60px [r4];text-align:center;color:#fff;margin:0 auto;width:240px;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h5 id="2-2-5-repeat-重复填充"><a href="#2-2-5-repeat-重复填充" class="headerlink" title="2.2.5 repeat()重复填充"></a>2.2.5 repeat()重复填充</h5><p>对于多个宽高值相同的元素，可以使用<span class="tips">repeat()</span>语句简写</p><div class="show">如：1. 对于grid-template-columns: 5em 5em 5em;该语句可以简写为    grid-template-columns: repeat(3,5em);2. 类似地可以创建宽度有一定规律的子元素    如：创建宽度依次为20px,40px,60px,20px,40px,60px的6列元素    grid-template-columns: repeat(2, 20px 40px 60px);3. 还可以repeat()前后添加不想重复的宽高值    grid-template-columns: repeat(2,1em 5em) 2em;    这就生成了1em 5em 1em 5em 2em的网格4. 百分号和比例依旧适用    grid-template-columns: repeat(3,33.3%);5. 如果包含了栅格线名，名称也会被复制    grid-template-columns: repeat(3,[top] 5em [bottom]);    则会生成    [top] 5em [bottom top] 5em [bottom top] 5em [bottom]    即：中间的栅格线将会有两个名称，该语句等同于：    grid-template-columns: [top] 5em [bottom top] 5em [bottom top] 5em [bottom];</div><h5 id="2-2-6-minmax-限制尺寸"><a href="#2-2-6-minmax-限制尺寸" class="headerlink" title="2.2.6 minmax()限制尺寸"></a>2.2.6 minmax()限制尺寸</h5><p>当子元素溢出父容器之外时，除了使用<span class="tips">overflow: hidden;</span>外，还可以使用<span class="tips">minmax(最小值，最大值)</span>来限制宽高尺寸</p><div class="show">如：将剩余空间分配给第二列，但又要避免他被挤占得太小     grid-template-columns:5em minmax(10%,1fr) 2em;</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>注意！当minmax()中最大值小于最小值时，最大值将失效。如minmax(100px,2em)中，当2em计算值小于100px时，元素宽高将被解析为100px</div><h5 id="2-2-7-calc-计算尺寸"><a href="#2-2-7-calc-计算尺寸" class="headerlink" title="2.2.7 calc()计算尺寸"></a>2.2.7 calc()计算尺寸</h5><p>grid是支持<span class="tips">calc()</span>语句的，只是有时候不太适用</p><div class="show">如：第二列宽度通过计算得出     grid-template-columns:2em calc(100%-1.5em) 10%;</div><h5 id="2-2-8-根据内容自适应"><a href="#2-2-8-根据内容自适应" class="headerlink" title="2.2.8 根据内容自适应"></a>2.2.8 根据内容自适应</h5><p>子元素宽高还可以根据子元素内容，通过<span class="tips">max-content</span>、<span class="tips">min-content</span>、<span class="tips">fit-content</span>来实现栅格自适应</p><ul><li><span class="strong">max-content:</span>解析为尽可能大的空间，以防换行</li><li><span class="strong">min-content:</span>解析为尽可能小的空间，能够显示内容即可</li><li><span class="strong">fit-content:</span>解析为空间尽可能小，但如果超过指定空间大小就换行</li></ul><div class="show">如：尽可能容纳内容div{    display:grid;    grid-template-columns:max-content max-content max-content;    grid-template-rows:max-content max-content max-content;}可以看到，每一列的宽度由该列有最长内容的列宽决定，行类似。当父元素指定宽度时，这可能会溢出到父容器之外</div><div style="display:grid;grid-template-columns:max-content max-content max-content;grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">1</div><div style="background-color:#fff200;">22</div><div style="background-color:#7d5fff;">33333333</div><div style="background-color:#32ff7e;">44444444444</div><div style="background-color:#4b4b4b;">5</div><div style="background-color:#67e6dc;">6</div><div style="background-color:#ff9f1a;">77</div><div style="background-color:#ffb8b8;">8888</div><div style="background-color:#c56cf0;">9</div></div><div class="show">配合minmax()使用可以不破坏外部布局，但会挤压内部空间div{    display:grid;    grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);    grid-template-rows:max-content max-content max-content;}</div><div style="display:grid;grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">1</div><div style="background-color:#fff200;">22</div><div style="background-color:#7d5fff;">33333333</div><div style="background-color:#32ff7e;">44444444444</div><div style="background-color:#4b4b4b;">5</div><div style="background-color:#67e6dc;">6</div><div style="background-color:#ff9f1a;">77</div><div style="background-color:#ffb8b8;">8888</div><div style="background-color:#c56cf0;">9</div></div><div class="show"><span class="tips">fit-content</span>用于限制最大长度，类似于max-width指定三列宽均为50等宽字符，当未满50ch时按实际字符长度算，超过该值则进行换行，即最大值只能为50chdiv{    display:grid;    grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(5.0ch);}只指定宽度，高度自适应，第一第二列未满50ch时，以各自长度为列宽，第三列超过50ch，则进行换行，以50ch为列宽</div><div style="display:grid;grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(50ch);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#18dcff;">the night</div><div style="background-color:#4b4b4b;">Avicii</div><div style="background-color:#7d5fff;">He said one day you will leave this world behind So live a life you will remember</div></div><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>当父容器较小时，第一、第二列即便未满50ch也可能会进行换行，以保证不会溢出父亲容器</div><h5 id="2-2-9-auto-fill自动填充"><a href="#2-2-9-auto-fill自动填充" class="headerlink" title="2.2.9 auto-fill自动填充"></a>2.2.9 auto-fill自动填充</h5><p>当父容器宽度固定，可以使用<span class="tips">auto-fill</span>让子元素根据大小自动填充</p><div class="show">如：div{    display:grid;    width:50vh;    grid-template-columns:repeat(auto-fill,5em);    grid-template-rows:max-content max-content max-content;    }在父容器中尽量排列宽3em的元素，排列到第一行排完，如果剩下空间不足3em，则剩余子元素将进行换行</div><div style="display:grid;grid-template-columns:repeat(auto-fill,3em);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">1. 一个父容器的宽/高只能有一次自动排列，因此下述语句是不允许的grid-template-columns: repeat(auto-fill,5em) repeat(auto-fill,2em);2. 但可以固定尺寸的repeat与自动填充的repear共存，如：grid-template-columns: repeat(2,5em) repeat(auto-fill,2em);或者grid-template-columns: repeat(auto-fill,5em) repeat(3,2em);但无论语序如何，grid总会为固定尺寸的元素分配空间，因此auto-fill会被最后才被分配空间</div><h4 id="2-3栅格间距"><a href="#2-3栅格间距" class="headerlink" title="2.3栅格间距"></a>2.3栅格间距</h4><p>通过<span class="tips">row-gap</span>、<span class="tips">column-gap</span>来设置栅格见的行、列间隔。或者将两个属性合并为一个 <span class="tips">grid-gap：行间隔 列间隔;</span></p><div class="show">给父容器添加该属性div{    display:grid;    width:50vh;    height:50vh;    grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);    row-gap:10px;    column-gap:10px;    }如图所见，添加间隔可能导致栅格溢出，这两个属性可合并为 grid-gap ，如果该语句之后的值只有一个，则解析为行列间隔都为该值。    grid-gap:10px 10px;等价于    grid-gap:10px;</div><div style="display:grid;grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);row-gap:10px;    column-gap:10px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h3 id="3-栅格区域"><a href="#3-栅格区域" class="headerlink" title="3. 栅格区域"></a>3. 栅格区域</h3><p>此前都是给父容器添加属性，但如果同时给子元素添加相应属性可以做出更好的布局</p><h4 id="3-1-调用栅格线名"><a href="#3-1-调用栅格线名" class="headerlink" title="3.1 调用栅格线名"></a>3.1 调用栅格线名</h4><p>通过<span class="tips">grid-template-columns</span>、<span class="tips">grid-template-rows</span>定义栅格宽高和栅格线名后，可以通过下列语句调用栅格线名</p><ul><li><span class="strong">grid-column-start：</span>列开始的栅格线名</li><li><span class="strong">grid-column-end：</span>列结束的栅格线名</li><li><span class="strong">grid-row-start：</span>行开始的栅格线名</li><li><span class="strong">grid-row-end：</span>行结束的栅格线名</li></ul><div class="show">通过四条边来定义子元素的具体位置，当未定义栅格线名时，可以使用1，2，3...作为栅格线名.box1 {    grid-column-start:1;    grid-column-end:2;    grid-row-start:2;    grid-row-end:4;    background-color: #ff3426;//红色}.box2 {    grid-column-start:3;    grid-column-end:5;    grid-row-start:1;    grid-row-end:3;    background-color: #39f64f;//绿色}<p>.parbox {<br>    display:grid;<br>    grid-template-columns: repeat(4,50px);<br>    grid-template-rows: repeat(4,50px);<br>}<br>栅格线名可以为负数，表示从该栅格线往其反方向数</p></div><div style="display:grid;display:grid;grid-template-columns: repeat(4,50px);grid-template-rows: repeat(4,50px);text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;box-sizing: border-box;"><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #ff3426;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #ff3426;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div></div><div class="show">1. 栅格线的编号可以为<span class="tips">负值</span>，表示从倒数第n条线开始从后往前数如：不知道栅格有几列，但想从最右边的栅格线开始部署，可以使用        grid-column-start:-1;        grid-row-start:-1;(行同理)2. 如果为栅格线定义过名称，则可以使用该名称作为上述语句的值，如果变量对应的栅格线有多条，则使用<span class="strong">变量名 序号</span>来确定具体的栅格线，序号从1开始排列。如：有多条名为col-A的线，表示列从第4条col-A开始：            grid-column-start:col-A 4;3. 此外可以使用<span class="tips">span</span>语句指定子元素跨越的行列数，如：.box1 {    grid-column-start:1;    grid-column-end: span 1;    grid-row-start:2;    grid-row-end: span 2;}上述代码等同于：.box1 {    grid-column-start:1;    grid-column-end: 2;    grid-row-start:2;    grid-row-end: 4;}表示该子元素从左边框号1开始，跨越1列，从上边框号2开始，跨越2行，其中<span class="strong">span 1</span>可以直接简写为<span class="strong">span</span>(默认为1)，且span后的值不能为<span class="tips">0</span>或<span class="tips">负值</span>4. 当使用 <span class="strong">span 栅格线名 n</span> 时，表示该元素跨越了n条该名称的栅格线如：栅格部署为A、B栅格线交替命名时A 格子 B 格子 A 格子 B 格子 A 格子 B 格子此时    grid-column-start: A 1;    grid-column-end: span 2 A;表示栅格从第1条A线开始，跨越1条名为A的栅格线，在下一个A线处结束</div><h4 id="3-2-调用栅格线名的简写"><a href="#3-2-调用栅格线名的简写" class="headerlink" title="3.2 调用栅格线名的简写"></a>3.2 调用栅格线名的简写</h4><p>上一节中 grid-column-start，grid-column-end和grid-row-start，grid-row-end用于指定栅格起始和结束的位置，该属性可以简写为</p><ul><li><span class="strong">grid-column: 起始栅格线/结束栅格线</span></li><li><span class="strong">grid-row: 起始栅格线/结束栅格线</span></li></ul><div class="show">1. 元素开始和结束的栅格线名用 / 隔开 .box1 {    grid-column-start:1;    grid-column-end: 2;    grid-row-start:2;    grid-row-end: 4;}等价于.box1 {    grid-column: 1 / 2;    grid-row: 2 / 4;}也可以用跨越了多少栅格表示.box1 {    grid-column: 1 / span 1;    grid-row: 2 / span 2;}2. 如果 / 和第二个值省略，则默认起始结束的栅格线名都一致如：列栅格线中有两条名为header的线，则        grid-column: header;等价于        grid-column: header / header;即以第一条header开始，第二条header结束，无论中间跨越多少栅格</div><h4 id="3-3-grid-area"><a href="#3-3-grid-area" class="headerlink" title="3.3 grid-area"></a>3.3 grid-area</h4><p>grid-area可用于调用网格线，也可用于为子元素命名</p><h5 id="3-3-1-grid-area调用网格线"><a href="#3-3-1-grid-area调用网格线" class="headerlink" title="3.3.1 grid-area调用网格线"></a>3.3.1 grid-area调用网格线</h5><p> grid-column-start，grid-column-end和grid-row-start，grid-row-end可以直接用一个语句代替：<br> <span class="strong">grid-area：行开始/列开始/行结束/列结束</span></p><div class="show">如：.box1 {    grid-row-start:2;    grid-row-end: 4;    grid-column-start:1;    grid-column-end: 2;  }等价于.box1 {    grid-area:2/1/4/2;}同样，值可以为跨越了多少个网格.box1 {  grid-area: 2 / 1 / span 2 / span 1;}</div><h5 id="3-3-2-grid-area为子元素命名"><a href="#3-3-2-grid-area为子元素命名" class="headerlink" title="3.3.2 grid-area为子元素命名"></a>3.3.2 grid-area为子元素命名</h5><p>可以通过<span class="tips">grid-area</span>给每个栅格子元素定义名称，然后由父容器通过<span class="tips">grid-template-areas</span>定义它们的排列方法</p><div class="show">如：.box1 {    grid-area: a;}.box2 {    grid-area: b;}.box3 {    grid-area: c;}.box4 {    grid-area: d;}.box5 {    grid-area: e;}.parbox {    display:grid;    grid-template-areas: 'a a a'                        &emsp;&emsp;&emsp;&emsp;'b c d'                        &emsp;&emsp;&emsp;&emsp;'b e e';}排列方法可以写于同一行上，但需要注意'&nbsp;'号grid-template-areas: 'a a a''b c d''b e e';</div><div style="display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;"><div style="background-color:#EA2027;grid-area:a;">box1</div><div style="background-color:#fff200;grid-area:b;">box2</div><div style="background-color:#7d5fff;grid-area:c;">box3</div><div style="background-color:#32ff7e;grid-area:d;">box4</div><div style="background-color:#4b4b4b;grid-area:e;">box5</div></div><div class="show">变量名应该尽量使用有含义的单词(子元素变量名应相应改变，这里只展示父容器属性).parbox {    display:grid;    grid-template-areas: 'header header header''left content right''left footer footer';}也可以省略其中的部分变量，使用...代替.parbox {    display:grid;    grid-template-areas: 'header header header''left ... right''left footer footer';}</div><h3 id="4-栅格的对齐方式"><a href="#4-栅格的对齐方式" class="headerlink" title="4. 栅格的对齐方式"></a>4. 栅格的对齐方式</h3><p>栅格对齐方式类似于flex弹性盒里的属性</p><div class="table"><table><thead><tr><th>属性</th><th>目标</th><th>适用于</th></tr></thead><tbody><tr><td>justify-self</td><td>行(一个栅格元素)</td><td>子元素</td></tr><tr><td>justify-items</td><td>行(所有栅格元素)</td><td>父容器</td></tr><tr><td>justify-content</td><td>行(整个栅格)</td><td>父容器</td></tr><tr><td>align-self</td><td>列(一个栅格元素)</td><td>子元素</td></tr><tr><td>align-items</td><td>列(所有栅格元素)</td><td>父容器</td></tr><tr><td>align-content</td><td>列(整个栅格)</td><td>父容器</td></tr></tbody></table></div><div class="show">以行为例.box1{    justify-self:start;}.box2{    justify-self:center;}.box3{    justify-self:end;}justify-self和justify-items用来调整单个或多个元素在它们自己栅格内的位置当justify-self赋值为start、center、end时，如果子元素没有指定宽度和高度，则会自动缩为仅合适内容的大小，对齐方式同单词含义。赋值为stretch时会被拉伸，完全填充box(同剩下的box)当需要所有元素都有该对齐方式，则可以给父容器添加justify-items和对应的值</div><div style="display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;justify-self:start;">box1</div><div style="background-color:#fff200;justify-self:center;">box2</div><div style="background-color:#7d5fff;justify-self:end;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">同样以行为例.parbox{    width:260px;    height:260px;    display:grid;    grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);    justify-content:center;}justify-content则是用来调整整个grid网格在父容器中的位置</div><div style="display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);justify-content:center;text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h3 id="5-隐式栅格"><a href="#5-隐式栅格" class="headerlink" title="5. 隐式栅格"></a>5. 隐式栅格</h3><p>此前通过<span class="strong">grid-template-rows</span>定义的栅格为<span class="tips">显式栅格</span>，当一部分栅格超出了显式栅格，系统会将超出的那部分定义为<span class="tips">隐式栅格</span>。可以使用<span class="tips strong">grid-auto-rows</span>与<span class="tips strong">grid-auto-columns</span>定义隐式栅格的大小</p><div class="show">如：.grid{    display:grid;    width:200px;    height:200px;        //定义2*2的显式栅格    grid-template-columns:100px 100px;    grid-template-rows:100px 100px;        //定义隐式栅格尺寸(以行为例)    grid-auto-rows: 50px;}box1、box2、box3、box4在显式栅格内，高为100px，box5，box6超出了显式栅格，高将变为隐式栅格的高50px</div><div style="display:grid;width:200px;    height:200px;grid-template-columns:100px 100px;grid-template-rows:100px 100px;grid-auto-rows: 50px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:5px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div></div><br/><br/><br/><h3 id="6-栅格流"><a href="#6-栅格流" class="headerlink" title="6. 栅格流"></a>6. 栅格流</h3><p>栅格流主要分为优先行、优先列、密集流三种模式，由<span class="tips">grid-auto-flow</span>决定</p><div class="show">grid-auto-flow的取值有row、column、dense(密集流) .box{    display: grid;    grid-template: repeat(3,80px) / repeat(3,80px);    width: 240px;    height: 240px;     grid-auto-flow: row;    }优先行与优先列的部署模型如下</div><div style="display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: row;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div></div><br/><div style="display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: column;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div></div><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>密集流的主要作用是让元素尽量靠紧，因此有时会破坏栅格元素的顺序进行密集分布，向任何可以插入的位置安插合适的子元素</div><h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h3><p>当输入错误的代码时，部分情况下grid会帮我们修正属性，但在有些情况下会抛弃部分无法解析的值，甚至不解析整个语句</p><div class="show">1. 当栅格开始线放在结束线后    grid-row-start:5;    grid-row-end:2;grid将修正为    grid-row-start:2;    grid-row-end:5;2. 当栅格开始线和结束线都被声明为了跨度    grid-row-start: span ;    grid-row-end: span 3;结束线的值将被修改为 auto    grid-row-start: span ;    grid-row-end: auto;3. 如果栅格开始线被声明为跨越已命名的线，则该语句将被认为非法    grid-row-start: span header;</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>当栅格元素出现重叠时，可以使用 z-index 或 order 进行排序，并且栅格元素可以使用margin、position等标准流、定位等属性。并且还有其他一些更复杂的属性简写语法，本文不再展开说明，具体可以查阅MDN的文档</div>]]></content>
    
    
    <summary type="html">Grid 是一种强大的布局方案，通过行和列的排列能组合出各种灵活的布局方案，并且能很好满足PC端到移动端的自适应需求</summary>
    
    
    
    
    <category term="css" scheme="https://shiwei11.github.io/blog/tags/css/"/>
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Vux状态管理</title>
    <link href="https://shiwei11.github.io/blog/2022/06/13/Vux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>https://shiwei11.github.io/blog/2022/06/13/Vux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</id>
    <published>2022-06-13T14:04:24.000Z</published>
    <updated>2022-07-20T14:25:41.358Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>Vux官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></div><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><span class="tips">Vuex</span>是专门为Vue应用程序开发的集中式状态(数据)管理插件，可以对Vue中的组件进行统一的数据管理。</p><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p>vue2的工程使用vux3，vue3的工程需要使用vux4，版本需要对应，这里以安装vux3为例</p><p>在脚手架中执行：</p><pre><code>npm i vuex@3</code></pre><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><img data-src="/blog/images/vuex_art.jpg" src="/blog/images/vuex_art.jpg" alt="vuex工作流程"><ul><li><span class="strong">Action</span>主要用于响应Vue Conponents的消息，或者从后端接收数据，并且可以将数据在Action中进行初步处理(主要为异步处理，如：添加定时器)</li><li><span class="strong">Mutation</span>主要用于处理数据，在Mutation处理的数据才能被Devtools调试工具监测</li><li><span class="strong">State</span>主要用于集中存储数据</li></ul><p><span class="strong">工作流程：</span>Vue Conponents发送消息<span class="tips">(dispatch)</span>给Action，或者Action通过Ajax等技术从后端异步获取数据 —&gt; Actions提交<span class="tips">(commit)</span>到Mutation —&gt; 数据在Mutation中进行处理后，修改<span class="tips">(mutate)</span>State中存储的数据 —&gt; 监测到State数据发生变化，Vue重新渲染<span class="tips">(render)</span>页面</p><p>vue组件的中数据不要预处理时，也可以越过Action，直接commit到mutation中进行处理</p><p><span class="strong">关于store：</span>store是Vuex的核心库，可以理解为一个容器，Action、Mutation、state由Store统一管理，在进行消息提交、数据操作时往往需要经过store，通过<span class="tips">this.$store.dispatch</span>、<span class="tips">this.$store.commit</span>等语句来调用api</p><h3 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h3><h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><h5 id="1-配置store"><a href="#1-配置store" class="headerlink" title="1. 配置store"></a>1. 配置store</h5><p>在src目录下新建store目录，新建index.js文件</p><pre><code>import Vue from 'vue'import Vue from 'vue'//引入并应用vuximport Vuex from 'vuex'Vue.use(Vuex)//创建action、mutations、stateconst actions=&#123;....&#125;const mutations=&#123;....&#125;const state=&#123;.....&#125;//创建并暴露Storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters&#125;)</code></pre><h5 id="2-引入store配置项"><a href="#2-引入store配置项" class="headerlink" title="2. 引入store配置项"></a>2. 引入store配置项</h5><p>在main.js中引入store配置项</p><pre><code>// 全写为import store from './store/index.js'import store from './store'new Vue(&#123;  render: h => h(App),  store  &#125;).$mount('#app')</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>eg：简单求和差案例，4个按钮分别实现求和、求差、判断偶数后求和、定时器延时1s求和</p><ul><li>直接求和、求差可以直接commit到Mutation中运算</li><li>判断当前值是否为偶数，延时求和需要dispatch到Action中预处理，再commit到Mutation中运算</li><li>需要多次处理的数据可以在Action中多次dispatch，处理完毕再commit</li></ul><h5 id="1-创建组件"><a href="#1-创建组件" class="headerlink" title="1. 创建组件"></a>1. 创建组件</h5><p>在components中创建Count.vue</p><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;$store.getters.addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;$store.state.sum&#125;&#125;&lt;/h3>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="incrace">加&lt;/button>    &lt;button @click="decrace">减&lt;/button>    &lt;button @click="addOpp">偶数才加&lt;/button>    &lt;button @click="addLate">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1, //加数        &#125;    &#125;,    methods:&#123;        // 求和、求差直接commit    incrace()&#123;        this.$store.commit('JIA',this.num)    &#125;,    decrace()&#123;        this.$store.commit('JIAN',this.num)    &#125;,    //延时、判断奇偶dispatch到actions经过处理后再提交    addOpp()&#123;        this.$store.dispatch('addOpp',this.num)    &#125;,    addLate()&#123;        this.$store.dispatch('addLate',this.num)    &#125;    &#125; &#125;&lt;/script></code></pre><h5 id="2-配置store"><a href="#2-配置store" class="headerlink" title="2. 配置store"></a>2. 配置store</h5><p>新建store目录并在该目录下新建index.js</p><pre><code>import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const actions=&#123;    // actions里的方法名一般小写    //接收参数 (context,实参)    // context是一个对象，拥有store的部分属性,变量名可以为其他    addOpp(context,value)&#123;                  if(!(value%2))&#123;             //判断是否为偶数，为偶数则commit到mutations        context.commit('JIA',value)        &#125;else&#123;            console.log('非偶数，数未提交')        &#125;    &#125;,    addLate(context,value)&#123;       //数据想要多道处理时，可以在actions内多次dispatch，无限套娃        setTimeout(()=>&#123;            context.dispatch('addLate2',value);            console.log('第一次延迟处理')        &#125;,500)    &#125;,    addLate2(context,value)&#123;      //数据经过第二道处理后，再提交        setTimeout(()=>&#123;            context.commit('JIA',value);            console.log('第二次延迟处理')        &#125;,500)    &#125;&#125;// mutations里的方法名一般大写，用于和actions里的区别const mutations=&#123;    //接收参数(state,实参)    JIA(state,value)&#123;           //加        state.sum+=value    &#125;,    JIAN(state,value)&#123;          //减        state.sum-=value;    &#125;&#125;const state=&#123; //存储数据    sum:0 &#125;const getters=&#123;                //读取数据前，想要预先进行处理使用getters    addTen(state)&#123;        return state.sum+10    &#125;&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters &#125;)</code></pre><h5 id="3-引入store配置项"><a href="#3-引入store配置项" class="headerlink" title="3. 引入store配置项"></a>3. 引入store配置项</h5><p>在main.js中引入store配置</p><pre><code>import Vue from 'vue'import App from './App.vue'import store from './store'// 全写为import store from './store/index.js'Vue.config.productionTip = false new Vue(&#123;  render: h => h(App),  store &#125;).$mount('#app')</code></pre><h5 id="4-引入Count组件"><a href="#4-引入Count组件" class="headerlink" title="4. 引入Count组件"></a>4. 引入Count组件</h5><p>在App中使用Count组件</p><pre><code>&lt;template>  &lt;div id="app">    &lt;Count/>  &lt;/div>&lt;/template>&lt;script>import Count from'./components/Count.vue'export default &#123;  name:'App',  components:&#123;    Count             &#125;   &#125;&lt;/script></code></pre><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>组件从state读取数据前，如果需要对数据进行预处理，可以在getter中进行。如：读取state中的num前进行处理(完整代码位于上一个案例)</p><h4 id="1-在store中添加getter"><a href="#1-在store中添加getter" class="headerlink" title="1. 在store中添加getter"></a>1. 在store中添加getter</h4><pre><code>const actions=&#123;.....&#125;const mutations=&#123;....&#125;const state=&#123;.....&#125;const getter=&#123;     //读取state中的sum前，将值增大10     addTen(state)&#123;        return state.sum+10;     &#125;&#125;</code></pre><h4 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2. 读取数据"></a>2. 读取数据</h4><p>读取数据使用</p><pre><code>$store.getters.addTen</code></pre><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>当一个组件需要获取多个数据(状态)时，调用数据和api需要大量使用this.$store.state.number等语句，为了减小代码书写量，可以在计算属性中借助<span class="tips">mapState</span>、<span class="tips">mapGetters</span>、<span class="tips">mapMutations</span>、<span class="tips">mapActions</span>辅助函数简化代码</p><h4 id="通过对象"><a href="#通过对象" class="headerlink" title="通过对象"></a>通过对象</h4><p>当组件中的方法名、变量名与State、Mutations…中的变量名不同时，需要通过对象方式接收。并借助模板语法解析变量，以读取State中的数据为例：</p><div class="show">...mapState({组件中的变量名:'state数据',.....})</div><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum1&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name1&#125;&#125;,从state获取song为&#123;&#123;song1&#125;&#125;&lt;/h2>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    //当使用mapState等语法时，需要在写函数时传参(num)    &lt;button @click="incrace(num)">加&lt;/button>    &lt;button @click="decrace(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script>//引入mapState、mapGetters、mapMutations、mapActions import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex' export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    computed:&#123;        //模板语法        ...mapState(&#123;sum1:'sum',name1:'name',song1:'song'&#125;),        ...mapGetters(&#123;addTen:'addTen'&#125;)        // 可以简写为数组形式...mapGetters(['addTen'])，在对象中不能简写，会解析为addTen:addTen，值也解析为变量    &#125;,    methods:&#123;    //原语句    // incrace()&#123;this.$store.commit('JIA',this.num)&#125;,    // decrace()&#123;this.$store.commit('JIAN',this.num)&#125;,    // 借助mapMutations生成对应方法，该方法会自动调用commit，数组写法在另一组件中     ...mapMutations(&#123;incrace:'JIA',decrace:'JIAN'&#125;),    //原语句    // addOpp()&#123;this.$store.dispatch('addOpp',this.num)&#125;,    // addLate()&#123;this.$store.dispatch('addLate',this.num)&#125;     ...mapActions(&#123;addOpp:'addOpp',addLate:'addLate'&#125;)     &#125; &#125;&lt;/script></code></pre><h4 id="通过数组"><a href="#通过数组" class="headerlink" title="通过数组"></a>通过数组</h4><p>当组件中的方法名、变量名与State、Mutations…中的变量名相同时，可以直接使用数组</p><div class="show">...mapState(['变量名1','变量名2',....])</div><pre><code>&lt;template>  &lt;div>    &lt;h2>不同的mapstate等写法&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name&#125;&#125;,从state获取song为&#123;&#123;song&#125;&#125;&lt;/h2>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="JIA(num)">加&lt;/button>    &lt;button @click="JIAN(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script>import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex'export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    computed:&#123;        ...mapState(['sum','name','song']),        ...mapGetters(['addTen'])    &#125;,    methods:&#123;        //数组写法    ...mapMutations(['JIA','JIAN']),     ...mapActions(['addOpp','addLate'])    &#125; &#125;&lt;/script></code></pre><h3 id="模块化与命名空间"><a href="#模块化与命名空间" class="headerlink" title="模块化与命名空间"></a>模块化与命名空间</h3><p>当有多类数据需要vuex管理时，可以将他们的state、actions、mutation封装到多个js文件中，并为它们开启<span class="tips">命名空间</span></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>在store目录中创建多个store配置文件</li><li>将配置文件统一引入该目录的index.js中</li><li>将store配置引入main.js中</li><li>创建组件，需要注意辅助函数的用法，指向命名空间的方法</li><li>在app中引入组件</li></ol><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>eg: 在上个案例基础上加入添加成员的功能。现在有两个功能：求和求差、添加成员，因此store目录下需要两个store配置项。在组件中调用数据时，需要用到命名空间，从不同state中引用数据。</p><h5 id="1-配置store-1"><a href="#1-配置store-1" class="headerlink" title="1. 配置store"></a>1. 配置store</h5><p>在store目录新建 person.js文件</p><pre><code>//添加人员模块import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) const person = &#123;    namespaced:true, //开启命名空间    actions:&#123;        addPersonZhou(context,value)&#123;            if(value.name.indexOf('周')===0)&#123;                context.commit('ADD_PERSON',value)            &#125;            else&#123;                alert('只能添加姓周的名')            &#125;        &#125;,         &#125;,    mutations:&#123;        ADD_PERSON(state,personObj)&#123;            state.personList.unshift(personObj);        &#125;    &#125;,    state:&#123;        personList:[&#123;id:'001',name:'张三'&#125;]    &#125;,    getters:&#123;        getFirstName(state)&#123;            return state.personList[0].name;        &#125;    &#125; &#125; export default person</code></pre><p>在store目录新建 count.js文件</p><pre><code>//求和模块import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default &#123;    namespaced:true, //开启命名空间    actions: &#123;        addOpp(context,value)&#123;          //判断是否为偶数            if(!(value%2))&#123;            context.commit('JIA',value)            &#125;else&#123;                console.log('非偶数，数未提交')            &#125;        &#125;,        addLate(context,value)&#123;        //数据想要多道处理时，可以dispatch为actions内的其他方法，无限套娃            setTimeout(()=>&#123;                context.dispatch('addLate2',value);                console.log('第一次延迟处理')            &#125;,500)        &#125;,        addLate2(context,value)&#123;      //数据经过第二道处理后，再提交            setTimeout(()=>&#123;                context.commit('JIA',value);                console.log('第二次延迟处理')            &#125;,500)        &#125;    &#125;,    mutations:&#123;        JIA(state,value)&#123;           //加            state.sum+=value        &#125;,        JIAN(state,value)&#123;          //减            state.sum-=value;        &#125;,    &#125;,    state:&#123;        sum:0,        name:'周杰伦',        song:'夜曲',    &#125;,    getters:&#123;        addTen(state)&#123;            return state.sum+10        &#125;    &#125;&#125;</code></pre><h5 id="2-在index-js中引入"><a href="#2-在index-js中引入" class="headerlink" title="2. 在index.js中引入"></a>2. 在index.js中引入</h5><p> 在store目录下index.js中引入</p><pre><code> import Vue from 'vue' import Vuex from 'vuex'Vue.use(Vuex)//引入两个配置项import count from './count'import person from './person'// 创建并暴露storeexport default new Vuex.Store(&#123;    //引入模块    modules:&#123;        //全写count: count,        count,        person    &#125; &#125;)</code></pre><h4 id="3-在main-js中引入store"><a href="#3-在main-js中引入store" class="headerlink" title="3. 在main.js中引入store"></a>3. 在main.js中引入store</h4> <pre><code>import Vue from 'vue'import App from './App.vue'import store from './store'new Vue(&#123;  render: h => h(App),  store&#125;).$mount('#app')</code></pre><h5 id="4-书写组件"><a href="#4-书写组件" class="headerlink" title="4. 书写组件"></a>4. 书写组件</h5><p>创建count.vue组件</p><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name&#125;&#125;,从state获取song为&#123;&#123;song&#125;&#125;&lt;/h2>        &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="incrace(num)">加&lt;/button>    &lt;button @click="decrace(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>    &lt;h1>组件2共享过来的人员名单&lt;/h1>   &lt;ol class="person-list">    &lt;li v-for="person in personList" :key="person.id">&#123;&#123;person.name&#125;&#125;&lt;/li>    &lt;/ol>  &lt;/div>&lt;/template>&lt;script> import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex' export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    //使用mapState,mapGetters, mapMutations,mapActions时更简洁    computed:&#123;        // 从count组件获取数据        ...mapState('count',&#123;sum:'sum',name:'name',song:'song'&#125;),         // 从person组件获取数据        ...mapState('person',['personList']),        ...mapGetters('count',&#123;addTen:'addTen'&#125;)    &#125;,    methods:&#123;    ...mapMutations('count',&#123;incrace:'JIA',decrace:'JIAN'&#125;),    ...mapActions('count',&#123;addOpp:'addOpp',addLate:'addLate'&#125;)    &#125; &#125;&lt;/script></code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>辅助函数指向命名空间时，需要在数据和方法名前添加命名空间名，如：...mapState('命名空间',{参数})</div><p>person.vue组件</p><pre><code>&lt;template>  &lt;div>    &lt;h2>组件2：添加成员&lt;/h2>    &lt;input type="text" v-model="personName" placeholder="添加成员">    &lt;button @click="add">添加&lt;/button>    &lt;button @click="addZhou">只添加姓周的人&lt;/button>    &lt;ul>        &lt;li v-for="person in personList" :key="person.id">&#123;&#123;person.name&#125;&#125;&lt;/li>    &lt;/ul>    &lt;h2>名单第一个人为&#123;&#123;firstPersonName&#125;&#125;&lt;/h2>    &lt;h2>组件一共享的值&lt;/h2>    &lt;h3>和为：&#123;&#123;sum&#125;&#125;&lt;/h3>  &lt;/div>&lt;/template>&lt;script>import &#123; nanoid &#125; from 'nanoid'export default &#123;    name:'CountSum',    data()&#123;        return &#123;            personName:''        &#125;    &#125;,    //不使用mapState,mapGetters, mapMutations,mapActions时更新、获取数据的方法    computed:&#123;        personList()&#123;            return this.$store.state.person.personList        &#125;,        sum()&#123;            return this.$store.state.count.sum        &#125;,        //通过getters获取时，想要指定组件名与路径        firstPersonName()&#123;            return this.$store.getters['person/getFirstName']        &#125;    &#125;,    methods:&#123;     add()&#123;        const personObj=&#123;id:nanoid(),name:this.personName&#125;;        //指定为person组件下的ADD_PERSON函数        this.$store.commit('person/ADD_PERSON',personObj);        this.personName='';     &#125;,     addZhou()&#123;         const personObj=&#123;id:nanoid(),name:this.personName&#125;;         this.$store.dispatch('person/addPersonZhou',personObj);         this.personName='';     &#125;    &#125;  &#125;&lt;/script></code></pre><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>不借助mapState等辅助函数，需要使用路径来指定命名空间名称，其中读取state中的数据使用<span class="tips">this.$store.state.配置文件名.数据名</span>来指向命名空间，而<span class="tips">dispatch</span>、<span class="tips">commit</span>、<span class="tips">getter</span>等api需要使用<span class="tips">this.$store.api名['命名空间/方法名',变量名]</span>语句来指向命名空间</div><h5 id="5-App-vue引入两个组件即可"><a href="#5-App-vue引入两个组件即可" class="headerlink" title="5. App.vue引入两个组件即可"></a>5. App.vue引入两个组件即可</h5><pre><code>&lt;template>  &lt;div id="app">    &lt;Count/>    &lt;Person/>  &lt;/div>&lt;/template> &lt;script> import Count from'./components/Count.vue' import Person from'./components/Person.vue' export default &#123;  name:'App',  components:&#123;    Count,    Person  &#125; &#125;&lt;/script></code></pre>]]></content>
    
    
    <summary type="html">Vue中用于集中式状态(数据)管理插件</summary>
    
    
    
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
    <category term="vue" scheme="https://shiwei11.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一位资深数据工程师酒后的肺腑之言(转载)</title>
    <link href="https://shiwei11.github.io/blog/2022/03/15/%E4%B8%80%E4%BD%8D%E5%8D%81%E5%B9%B4IT%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/"/>
    <id>https://shiwei11.github.io/blog/2022/03/15/%E4%B8%80%E4%BD%8D%E5%8D%81%E5%B9%B4IT%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/</id>
    <published>2022-03-15T02:32:23.000Z</published>
    <updated>2022-07-16T18:05:37.105Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>原帖来源于Reddit论坛：<a href="https://www.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/">Drunk Post: Things I've learned as a Sr Engineer</a></div><p>最早我是在知乎上看到的，后来又陆陆续续在公众号、贴吧多次看到，最后追到了Reddit上，原帖作者是flipstables，这篇帖子目前已经获得了12k的点赞，写的很有意思。</p><h3 id="节选"><a href="#节选" class="headerlink" title="节选"></a>节选</h3><p><span class="strong">我喝醉了，这是我作为一名工程师在过去十年学到的一些东西，我可能会后悔说了这些话，但是…..醉都醉了，管他呢。</span></p><p>(1)    提升职业生涯的最好方法是换公司。</p><p>(2)    技术栈不重要。每个技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。</p><p>(3)    人们爱跳槽是有原因的。 如果对当前工作不满意，也许是时候离开了</p><p>(4)    工作和人际关系是两回事。在一些公司，我交到了好朋友，但是工作得并不开心；在另一些公司里，我没有与任何同事建立友谊，但是工作得很开心。</p><p>(5)    我学会了对经理诚实，总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。</p><p>(6)    如果我每个季度不止一次在凌晨2点被人叫醒，并且他们认为我是可以随叫随到的，那么肯定是出了很严重的问题(系统或人)，要么我得修正他们的看法(或者修复系统)，要么提桶跑路。</p><p>(7)<span class="strong">再倒一杯</span></p><p>(8)    优秀的经理和优秀的工程师有很多相似之处。</p><p>(9)    刚开始的时候，我也曾痴迷技术、编程、计算机，但现在已经翻篇了。</p><p>(10)    好的代码是能被初级工程师理解的代码。伟大的代码是可以被CS 专业的大一新生理解的代码。</p><p>(11)    作为一名工程师，最被忽视的能力是写文档。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。</p><p>(12)    网上的口水战(vim vs emacs ,mac vs linux)，几乎都无关紧要，别去参与，除了下一条。</p><p>(13)    年纪越大，我就越觉得动态语言更好，妈的，我就这么说了，有谁反对？</p><p>(14)    如果发现自己是公司里面最厉害的工程师，那就该离开了。</p><p>(15)    我不知道为什么全栈工程师的工资这么低。 不，真的，他们应该每年得到50万的年薪，只是基本工资。 妈的，他们必须了解前端和后端以及不同的浏览器如何工作，还得了解网络、数据库、缓存以及PC端和移动端之间的差异，天哪，还有公司使用的其他框架？ 说真的，为什么全栈工程师工资这么少</p><p>(16)    我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了，我喜欢实习生。</p><p>(17) <span class="strong">抿~</span></p><p>(18)    不要过于迷恋大牛，我花了 5000 美元参加了我所崇拜大牛的公开课。 他是一个才华横溢的人，但后来我意识到，他和我们其他人一样，在瞎编。</p><p>(19)    技术栈很重要。好吧，我刚刚说过不重要之类的话，但听我说完，如果你使用 Python 或 C++ 语言，就会忍不住想用这些语言做一些非同寻常的事情，因为这些语言确实适合干这些工作。</p><p>(20)    如果你不确定自己想做什么东西，请使用 Java。这是一门很糟糕的编程语言，但它几乎无所不能。</p><p>(21)    对于初学者来说，最赚钱的编程语言是 SQL，能干翻所有其他语言。就算你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。</p><p>(22)    测试很重要，但 TDD （测试驱动的开发）是个该死的邪教。</p><p>(23)    政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你得出卖你的灵魂去深究这些专有技术，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄多数在 50 岁以上是有原因的。</p><p>(24)    如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。</p><p>(25)    我从来没有在FAANG (Facebook、亚马逊、苹果、奈飞、谷歌)工作过，所以我不知道我错过了什么。但是我招过FAANG的工程师，他们也不知道自己在做什么。</p><p>(26)    自我价值不是和薪酬挂钩的函数，跟那东西没什么关系，用资本来确定自我价值很糟糕。</p><p>(27)    头衔大多无关紧要，随便什么公司都可以有首席工程师。</p><p>(28)    说到头衔，在职业生涯早期，头衔升级很好，因为这可以让你历练技能，学会担当责任。但到后期，头衔降级很好，这会让你增加薪水。</p><p>(29)    善待每一个人，不是因为这会有助于你的事业，而是因为向善本身就有回报。</p><p>(30)    如果上个月我没有从初级工程师或实习生那里学到点什么，那说明我没有上心。</p><p>(31)    <span class="strong">该死，没酒了</span></p><p>(32)    在课程、书籍、会议方面花点钱是值得的。</p><p>(33)    手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。</p><p>(34)    当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。</p><p>(35)    就算我心里讨厌某种技术，但如果我觉得他好的话，我还是会把它推荐给客户，比如我恨 Jenkins，但会把它推荐给客户，我不觉得做错了。</p><p>(36)    Git很糟糕，但我没有选择只能使用它，它的GUI可以见鬼去了，给我命令就行，大概只需要记住7个，其他的可以Google。</p><p>(37)    我喜欢团队里的半技术分析师， 因为懂编程但不懂软件工程，他们对我成长的帮助比最杰出的工程师要大得多。</p><p>(38) <span class="strong">糟糕，又没酒了</span></p><p>(39)    成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。</p><p>(40)    发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。</p><p>(41)    我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。</p><p>(42)    算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。</p><p>(43)    做自己喜欢的事情并不重要，不要让做讨厌的事情更重要。</p><p>(44)    越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。</p><p>(45)    即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。</p><p>(46)    不是所有好工作都在硅谷，但那里有很多。</p><p>(47) <span class="strong">哦，该死，我又找到啤酒了</span></p><p>(48)    结对编程很棒，只是需要花很多时间，而公司往往不想花那么多时间。</p><p>(49)    和聪明的工程师一起工作让我变成更好的码农，和聪明的非技术同事一起工作让我成为更好的工程师。</p><p>(50)    朝九晚五以外的时间就别花在工作上了，除非那个项目真的很棒，你状态很好。</p><p>(51)    人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那将是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。</p><p>(52)    好人写的代码也有烂的，聪明人写的代码也是，好的工程师也会写出糟糕的代码。不要让代码质量成为你衡量自我价值的因变量。</p><p>(53)    我进入这个行业是因为我喜欢技术，但现在工作已经毁了我的爱好。</p><p>(54)    我挣的钱还不错，对此我心存感激，不过还是得省着点用。</p>]]></content>
    
    
    <summary type="html">国外一位十年经验数据工程师的酒后吐槽，讲述了自己十年来对工作和技术的一些感悟，写的很有意思，在Reddit论坛上获得了上万的点赞</summary>
    
    
    
    
    <category term="life" scheme="https://shiwei11.github.io/blog/tags/life/"/>
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>VLess+TLS+WS代理服务器搭建</title>
    <link href="https://shiwei11.github.io/blog/2022/03/10/VLess-TLS%E9%AB%98%E9%98%B6%E6%90%AD%E5%BB%BA/"/>
    <id>https://shiwei11.github.io/blog/2022/03/10/VLess-TLS%E9%AB%98%E9%98%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2022-03-10T05:51:09.000Z</published>
    <updated>2022-08-27T18:04:23.522Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>本文采用 WTFPL 许可证书，转载请不要标注任何本站信息<div><a href="https://wtfpl2.com/">WTFPL © Do What the Fuck You Want to Public License</a></div></div><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>VLESS 是一种无状态的轻量级数据传输协议，使用 UUID 进行身份验，其协议不再依赖系统时间，配置灵活。但其本身协议不带加密，因此需要配合 TLS 等加密手段。</p><h3 id="前置需要"><a href="#前置需要" class="headerlink" title="前置需要"></a>前置需要</h3><h4 id="一台可用的VPS"><a href="#一台可用的VPS" class="headerlink" title="一台可用的VPS"></a>一台可用的VPS</h4><p>国内的可以使用香港、台湾地区的服务器，如GCP在台湾的节点、softshellweb，国外的推荐vultr、搬瓦工等主流厂商，支持支付宝付款并且不容易跑路。</p><p>操作系统请选择自己熟悉的发行版，并能解决防火墙策略、开放端口等问题，这里以CentOS7为例。</p><p>安装完毕后需要测试是否能Ping通，可以直接使用ping命令尝试，或者去相关网站，国内可以通过<a href="https://ping.chinaz.com/">站长Ping工具</a>检测，国外通过<a href="https://www.yougetsignal.com/">yougetsignal</a>检测。如果国内能ping通，说明该服务器可用，可以开始搭建了。如果国外能ping通，国内无法ping通，则说明被拦截了，需要换一台服务器。如果国内国外都无法ping通，则说明服务器还未部署好，需等待几分钟后再重试。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名推荐去 godaddy 购买，顶级域名为<span class="tips">.com</span>的域名一般第一年只需要59元，<span class="tips">.cn</span>域名一般35元，最便宜的诸如<span class="tips">.live</span>结尾的域名第一年不到14元</p><p>拿到域名后将其解析到所购买的VPS IP地址，域名一般需要24h才会生效(实际不用)。</p><h4 id="SSL-TLS证书"><a href="#SSL-TLS证书" class="headerlink" title="SSL/TLS证书"></a>SSL/TLS证书</h4><p>SSL/TLS证书可以从以下平台免费获取，证书有效期一般为90天，90天后需要更换</p><ul><li>zerossl：<a href="https://zerossl.com/">https://zerossl.com/</a></li><li>letsencrypt：<a href="https://letsencrypt.org/">https://letsencrypt.org/</a></li><li>FreeSSL：<a href="https://freessl.org/">https://freessl.org/</a></li><li>SSL For Free：<a href="https://www.sslforfree.com/">https://www.sslforfree.com/</a></li></ul><p>将获取的证书、密钥文件上传到服务器上，在配置文件时使用。如果不想手动更新SSL证书，可以使用脚本自动更新<br>脚本地址：<a href="https://github.com/acmesh-official/acme.sh">https://github.com/acmesh-official/acme.sh</a></p><h3 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h3><h4 id="安装V2fly"><a href="#安装V2fly" class="headerlink" title="安装V2fly"></a>安装V2fly</h4><p>Github开源地址：<a href="https://github.com/v2fly/fhs-install-v2ray">https://github.com/v2fly/fhs-install-v2ray</a></p><p>安装/更新 v2fly命令：</p><pre><code>bash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)</pre></code><p>安装完成后，配置文件放在<span class="tips">/usr/local/etc/v2ray/config.json</span>路径下</p><h4 id="Google-BBR加速算法"><a href="#Google-BBR加速算法" class="headerlink" title="Google BBR加速算法"></a>Google BBR加速算法</h4><p>TCP BBR(Bottleneck Bandwidth and Round-trip propagation time)是由Google于2016年发布的一种拥塞控制算法，可以显著地提高Linux服务器吞吐量并减少TCP连接的延迟</p><p>安装bbrplus：</p><pre><code>wget "https://github.com/cx9208/bbrplus/raw/master/ok_bbrplus_centos.sh" && chmod +x ok_bbrplus_centos.sh && ./ok_bbrplus_centos.sh</code></pre><p>安装完毕需要重启系统，重启完毕可通过<span class="tips">uname -r</span>命令查询内核，返回bbr相关值说明升级完成，通过命令<span class="tips">lsmod | grep bbr</span>查看是否载入bbr系统模块，返回bbr相关值说明已经加载。</p><p>CentOS8+系统内核自带BBR，开启方法可自行百度。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><p>使用vim在<span class="tips">/usr/local/etc/v2ray/config.json</span>配置文件中添加配置设置。</p><pre><code>&#123;  &#123;    "log": &#123;    "loglevel": "warning",    "access": "/var/log/v2ray/access.log",       "error": "/var/log/v2ray/error.log"  //日志输出路径    &#125;,    "inbounds": [&#123;    "port": 8180 ,  //监听端口    "protocol": "vless",//主传入协议    "settings": &#123;    "decryption": "none",    "clients": [    &#123;    "id": "41803377-5789-4bf5-8cb4-dd6ad659554c",//UUID    "level": 0        &#125;      ]    &#125;,    "streamSettings": &#123;    "network":"ws",  //传输协议    "security": "tls", //传输层安全    "wsSettings":&#123;    "path":"/",     //路径    "headers":&#123;&#125;    &#125;,    "tlsSettings": &#123;    "serverName": "newyear101.xyz", //域名    "certificates": [&#123;    "certificateFile": "/etc/ssl/certificate.crt",//SSL证书路径    "keyFile": "/etc/ssl/private.key" //密钥路径            &#125;]         &#125;      &#125;    &#125;],    "outbounds": [&#123;    "protocol": "freedom",//主传出协议    "settings": &#123;&#125;    &#125;,&#123;    "protocol": "blackhole",    "settings": &#123;&#125;,    "tag": "blocked"    &#125;],    "routing": &#123;    "rules": [    &#123;    "type": "field",    "ip": ["geoip:private"],    "outboundTag": "blocked"        &#125;      ]   &#125; &#125;</code></pre><ul><li>UUID作为唯一身份识别码，可通过客户端生成，或通过UUID生成网站获得，不能自行编写<h5 id="检测配置文件是否正确"><a href="#检测配置文件是否正确" class="headerlink" title="检测配置文件是否正确"></a>检测配置文件是否正确</h5>v2ray官方检测命令：<pre><code>/usr/local/bin/v2ray -test -config  /usr/local/etc/v2ray/config.json</pre></code>文件正确会返回值：<div class="shell">V2Ray 4.44.0 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.17.3 linux/amd64)A unified platform for anti-censorship.2021/02/03 21:46:12 [Info] main/jsonem: Reading config: /usr/local/etc/v2ray/config.jsonConfiguration OK.</div></li></ul><h4 id="更新防火墙规则"><a href="#更新防火墙规则" class="headerlink" title="更新防火墙规则"></a>更新防火墙规则</h4><h5 id="Centos-7-8-firewalld-放行端口"><a href="#Centos-7-8-firewalld-放行端口" class="headerlink" title="Centos 7/8 firewalld 放行端口"></a>Centos 7/8 firewalld 放行端口</h5><div class="show">// 8180改成自己的端口号firewall-cmd --permanent --add-port=8180/tcp //重启使之生效firewall-cmd --reload</div><h5 id="ubuntu系统-ufw放行端口"><a href="#ubuntu系统-ufw放行端口" class="headerlink" title="ubuntu系统 ufw放行端口"></a>ubuntu系统 ufw放行端口</h5><div class="show">//8180改成自己的端口号sudo ufw allow 8180/tcp//重启sudo ufw reload</div><h5 id="Centos-6-7-iptable放行端口"><a href="#Centos-6-7-iptable放行端口" class="headerlink" title="Centos 6/7 iptable放行端口"></a>Centos 6/7 iptable放行端口</h5><div class="show">//8180改成自己的端口号iptables -I INPUT -p tcp --dport 8180 -j ACCEPT//保存添加的规则链service iptables save</div><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端需要使用4.23.2以上内核</p><h4 id="客户端下载地址："><a href="#客户端下载地址：" class="headerlink" title="客户端下载地址："></a>客户端下载地址：</h4><ul><li><strong>Android</strong>: <a href="https://github.com/2dust/v2rayNG/releases">v2rayNG</a></li><li><strong>windows</strong>:<a href="https://github.com/2dust/v2rayN/releases">v2rayN</a></li><li><strong>MacOS</strong>:<a href="https://github.com/yanue/V2rayU/releases">V2rayU</a></li></ul><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><div class="table"><table><thead><tr><th>配置项</th><th>值</th></tr></thead><tbody><tr><td>别名</td><td>任意</td></tr><tr><td>地址</td><td>VPS的IP地址</td></tr><tr><td>端口</td><td>配置文件中的端口号</td></tr><tr><td>用户ID</td><td>UUID,需要和配置文件一致</td></tr><tr><td>传输协议</td><td>ws</td></tr><tr><td>伪装域名</td><td>解析的域名</td></tr><tr><td>路径</td><td>配置文件中的路径</td></tr><tr><td>传输层安全</td><td>tls</td></tr></tbody></table></div><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h4><p>如果已经启动v2ray服务，修改的配置文件需要重启生效</p><ul><li><strong>systemctl start v2ray</strong> 运行</li><li><strong>systemctl stop v2ray</strong> 停止</li><li><strong>systemctl restart v2ray</strong> 重启</li></ul><h4 id="常用服务命令"><a href="#常用服务命令" class="headerlink" title="常用服务命令"></a>常用服务命令</h4><h5 id="生成uuid"><a href="#生成uuid" class="headerlink" title="生成uuid"></a>生成uuid</h5><p> <span class="strong">v2ctl uuid</span> 生成一个新的uuid</p><h5 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h5><p> <span class="strong">v2ray [参数]</span></p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-version</td><td>查看当前版本</td></tr><tr><td>-test</td><td>测试配置文件有效性</td></tr><tr><td>-config</td><td>手动指定配置文件，值可以是绝对路径、相对路径、url链接、”stdin:”(从标准输入读取内容)</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">大二的时候整理的一篇笔记，在原笔记的基础上改用了后面新出的协议，并系统整理了一下可能用到的命令。</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="VPS" scheme="https://shiwei11.github.io/blog/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Nginx笔记(上)</title>
    <link href="https://shiwei11.github.io/blog/2022/03/04/nginx%E7%AC%94%E8%AE%B0/"/>
    <id>https://shiwei11.github.io/blog/2022/03/04/nginx%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T02:53:39.000Z</published>
    <updated>2023-05-02T07:19:28.085Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>nginx官方文档：<a target="_blank" href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></div><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h4><p>Nginx是一款高性能的Web服务器软件，能在高并发环境下快速响应http/https请求，同时也提供IMAP/POP3/SMTP服务,可用于反向代理服务器、虚拟主机、域名解析、负载均衡、防盗链、URL重定向、http/https、邮件代理服务器等各类场景。</p><p>根据<a href="https://news.netcraft.com/">Netcraft</a> 发布的web服务器调查报告，截至2022年1月，nginx是全球最常用的web服务器软件，占有全球32.3%的站点，另一服务器软件Apache占有23.9%的站点，很大一部分web服务器使用Nginx作为负载均衡服务器。</p><h4 id="依赖与环境"><a href="#依赖与环境" class="headerlink" title="依赖与环境"></a>依赖与环境</h4><p><strong>操作系统要求：</strong>Nginx底层使用了多进程和I/O多路复用(epoll)来提高并发能力，因此需要使用Linux2.6以上的内核以支持epoll</p><p><strong>源码包依赖：</strong></p><ul><li>GCC编译器：编译C语言</li><li>PCRE库(兼容正则表达式库)：用于支持正则表达式</li><li>zlib库：为Nginx的gzip压缩提供压缩算法</li><li>OpenSSL：提供安全通信</li></ul><h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p>master进程：主进程，以root权限运行，负责读取检测配置文件，启动和管理worker进程</p><p>worker进程：工作进程，权限由配置文件中的user决定，负责处理网络请求，进程数量由配置文件中的worker_processes决定</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="Nginx服务命令"><a href="#Nginx服务命令" class="headerlink" title="Nginx服务命令"></a>Nginx服务命令</h4><p>未配置全局环境变量的情况下，nginx命令执行路径为<span class="tips">/usr/local/nginx/sbin</span>，可以通过./nginx -h查看所有命令</p><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>./nginx</td><td>启动nginx</td></tr><tr><td>./nginx -h</td><td>-h可替换为-?,查看nginx的所有命令</td></tr><tr><td>./nginx -v</td><td>查看nginx的版本</td></tr><tr><td>./nginx -s 信号量</td><td>发送一个信号量操作nginx</td></tr><tr><td>./nginx -s stop</td><td>强制关闭nginx</td></tr><tr><td>./nginx -s quit</td><td>停止接受新请求，等待nginx处理完当前任务后关闭nginx</td></tr><tr><td>./nginx -s reload</td><td>重新加载配置文件</td></tr><tr><td>./nginx -s reopen</td><td>重新打开日志文件(可用于日志分割)</td></tr><tr><td>./nginx -t [文件路径]</td><td>检测nginx的配置文件是否书写正确</td></tr><tr><td>./nginx -T</td><td>检测nginx的配置文件是否书写正确，若正确则将内容输出到屏幕</td></tr><tr><td>./nginx -c 文件路径</td><td>手动指定nginx的配置文件后启动</td></tr></tbody></table></div><h4 id="Linux系统命令"><a href="#Linux系统命令" class="headerlink" title="Linux系统命令"></a>Linux系统命令</h4><p><span class="strong">kill -信号 master进程PID</span></p><div class="table"><table><thead><tr><th>信号</th><th>说明</th></tr></thead><tbody><tr><td>TERM/INT</td><td>强制关闭nginx</td></tr><tr><td>QUIT</td><td>停止接受新请求，处理完当前任务后关闭nginx</td></tr><tr><td>HUP</td><td>重新加载配置文件</td></tr><tr><td>USR1</td><td>重新打开日志文件(可用于日志分割)</td></tr><tr><td>USR2</td><td>不停止服务，平滑升级到最新版nginx</td></tr><tr><td>WINCH</td><td>停止接受新请求，处理完当前任务后关闭所有worker进程</td></tr></tbody></table></div><h5 id="关于平滑升级"><a href="#关于平滑升级" class="headerlink" title="关于平滑升级"></a>关于平滑升级</h5><p>执行 <span class="tips">kill -USR2 17482</span>(假设17482为master进程PID)命令进行平滑升级时，更新完ngixn后会开启一个新版本nginx对应的master进程和work进程，此时系统中将会有两个master进程，并且新版本的master进程PID会被记录在<span class="tips">/usr/loca1/nginx/logs/nginx.pid</span>文件中，而旧版本master进程PID会被记录在<span class="tips">/usr/loca1/nginx/logs/nginx.pid.oldbin</span>文件中，之后会发送QUIT信号给旧的master进程，让其处理完请求后关闭，完成升级。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件位于<span class="tips">/usr/local/nginx/conf/nginx.conf</span>路径下</p><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><div class="show">#user  nobody;          //指定nginx工作进程的用户身份，默认为nobodyworker_processes  1;   //允许生成的worker process数<p>#error_log  logs/error.log;     //日志级别与存放路径<br>#error_log  logs/error.log  notice;<br>#error_log  logs/error.log  info;</p><p>#pid        logs/nginx.pid; //master进程pid存放路径<br>……</div></p><h5 id="user配置进程权限"><a href="#user配置进程权限" class="headerlink" title="user配置进程权限"></a>user配置进程权限</h5><p><span class="strong">user 用户名 [用户组];</span></p><p>默认为nobody，配置决定了worker进程的调用用户，以及nginx对文件(一般指资源文件和目录)的读写权限，而日志文件、pid文件、配置文件等由master进程调用的文件则不受此配置影响，所有者一般为root。当配置的用户对指定文件无访问权限时，Nginx将返回403错误，此时需要授予该用户相关权限，或者更改为权限更高的用户。</p><h5 id="worker-processes配置进程数量"><a href="#worker-processes配置进程数量" class="headerlink" title="worker_processes配置进程数量"></a>worker_processes配置进程数量</h5><ul><li><span class="strong">master_process on/off;</span>用于指定是否生成worker进程，默认为on</li><li><span class="strong">worker_processes 值/auto;</span>指定worker进程生成数量，默认为1</li></ul><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>worker_processes值越大，处理并发能力越强。但需要考虑服务器的CPU核心数、内存余量等硬件资源大小</div><h5 id="daemon配置nginx为守护进程"><a href="#daemon配置nginx为守护进程" class="headerlink" title="daemon配置nginx为守护进程"></a>daemon配置nginx为守护进程</h5><p><span class="strong">daemon on/off;</span></p><p>配置nginx是否以守护进程方式启动，并在后台运行，默认为on</p><h5 id="error-log配置日志"><a href="#error-log配置日志" class="headerlink" title="error_log配置日志"></a>error_log配置日志</h5><p><span class="strong">error_log 路径 [日志级别];</span></p><p>配置日志路径和记录级别，这里指Nginx本身运行错误产生的日志，用户连接产生的日志需要在http/https块里配置，默认将notice以上级别的日志写入error.log日志文件中，日志级别有 debug、info、notice、warn、error、crit</p><h5 id="pid配置pid文件路径"><a href="#pid配置pid文件路径" class="headerlink" title="pid配置pid文件路径"></a>pid配置pid文件路径</h5><p><span class="strong">pid 路径;</span></p><p>自定义pid文件路径，默认在/usr/local/nginx/logs/nginx.pid路径下。pid文件用于存放master进程的pid，会在master进程产生时生成，进程关闭时删除。当使用nginx -s reload/reopen重新加载配置文件或日志时，nginx会到该文件中读取进程pid，如果该文件无法找到或者已经被删除，nginx将报错，常用的解决方法是使用<span class="tips">nginx -c 配置文件名</span>命令重新指定配置文件后启动nginx</p><h4 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h4><div class="show">...events {    worker_connections  1024;//每个worker允许的最大连接数}</div><h5 id="accept-mutex配置网络连接序列号"><a href="#accept-mutex配置网络连接序列号" class="headerlink" title="accept_mutex配置网络连接序列号"></a>accept_mutex配置网络连接序列号</h5><p><span class="strong">accept_mutex on/off;</span></p><p>默认为on，用于解决“惊群”问题，即将连接到nginx的网络连接进行序列化，并依次分配给worker进程，防止多个worker争抢连接。</p><h5 id="accept-mutex配置网络连接序列号-1"><a href="#accept-mutex配置网络连接序列号-1" class="headerlink" title="accept_mutex配置网络连接序列号"></a>accept_mutex配置网络连接序列号</h5><p><span class="strong">multi_accept on/off;</span></p><p>默认为off，在off状态下，一个worker进程只能接收一个新的连接请求，否则，一个worker进程将同时接收所有新连接。</p><h5 id="worker-connections配置单进程最大连接数"><a href="#worker-connections配置单进程最大连接数" class="headerlink" title="worker_connections配置单进程最大连接数"></a>worker_connections配置单进程最大连接数</h5><p><span class="strong">worker_connections 值;</span></p><p>默认为1024，用于配置每个worker允许的最大连接数，值不能超过操作系统最大文件句柄数量。</p><h5 id="use配置事件处理模型"><a href="#use配置事件处理模型" class="headerlink" title="use配置事件处理模型"></a>use配置事件处理模型</h5><p><span class="strong">use 参数;</span></p><p>可选参数有poll/select/epoll/kqueue等，Linux2.6以上内核默认使用epoll函数以优化并发连接能力。</p><h4 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h4><div class="shell">http {    include       mime.types;   //引入外部文件mime.types    default_type  application/octet-stream;    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main; //定义access连接日志的路径与内容//快速传输文件    sendfile        on;    #tcp_nopush     on;//服务器保持连接最大时间，单位为s    #keepalive_timeout  0;    keepalive_timeout  65;//传输文件前是否压缩    #gzip  on;    ....</div><h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p><span class="strong">include 文件名;</span></p><ul><li>用于引入外部文件，管理员可以定义一个外部文件书写配置，然后通过include将该文件内容引入到相应位置。</li><li>这里引入的mime.types用于标识文档、媒体文件格式和类型，该文件标识了常用的html、css、js、jpg等文件类型，用于帮助nginx识别请求的文件类型</li></ul><h5 id="default-type"><a href="#default-type" class="headerlink" title="default_type"></a>default_type</h5><p><span class="strong">default_type MIME类型;</span></p><p>默认值application/octet-stream指没有特定类型的二进制文件，MIME类型可参考MDN文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" style="word-wrap: break-word;">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></p><h5 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h5><ul><li><span class="strong">log_format 变量名 日志格式;</span></li><li><span class="strong">access_log 路径 变量名;</span></li></ul><p>二者搭配使用，第一个语句用于定义一个变量名，并将配置的日志格式赋值给该变量，变量名取值需使用<span class="tips">$</span>符。第二个语句用于根据变量名对应的日志格式，将用户访问日志书写到对应路径下。日志格式中对应的变量含义：</p><div class="table"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>remote_addr</td><td>客户端地址</td></tr><tr><td>remote_user</td><td>客户端用户名</td></tr><tr><td>time_local</td><td>访问时间和时区</td></tr><tr><td>request</td><td>请求的URL和HTTP协议</td></tr><tr><td>http_host</td><td>请求地址，即浏览器中输入的地址</td></tr><tr><td>status</td><td>http请求返回的状态码，如：301、404等</td></tr><tr><td>upstream_status</td><td>upstream状态</td></tr><tr><td>body_bytes_sent</td><td>发送给客户端的文件大小(字节)</td></tr><tr><td>http_referer</td><td>该请求是从哪个链接跳转过来</td></tr><tr><td>http_user_agent</td><td>客户端信息，如：浏览器标识等</td></tr><tr><td>ssl_protocol</td><td>SSL协议版本</td></tr><tr><td>ssl_cipher</td><td>交换数据中的算法</td></tr><tr><td>request_time</td><td>整个请求的总时间</td></tr><tr><td>upstream_addr</td><td>upstream的地址，即真正提供服务的主机地址</td></tr><tr><td>http_x_forwarded_for</td><td>记录有代理服务器时客户端地址的配置</td></tr><tr><td>upstream_response_time</td><td>请求过程中，upstream响应时间</td></tr></tbody></table></div><h5 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h5><ul><li><span class="strong">sendfile on/off;</span></li><li><span class="strong">tcp_nopush on/off;</span></li></ul><p>sendfile用于高效传输文件，在sendfile为on的状态下，开启tcp_nopush会将文件积累到一定大小后再统一发送，用于提高包传输效率</p><h5 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h5><ul><li><span class="strong">keepalive_timeout 值;</span></li><li><span class="strong">tcp_nodelay on/off;</span></li></ul><p>keepalive_timeout用于设置保持与客户端连接的最大时间，单位默认为s，超时时nginx会关闭连接并释放服务器资源，若设置为0则禁用该设置。设置的时间过大会导致大量的无效连接未断开，从而占用服务器资源，太小会导致服务未处理完，就被强制关闭连接。</p><p>在keepalive_timeout启用状态下，配置tcp_nodelay on;可以将数据即使发送。</p><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><p><span class="strong">gzip on/off;</span></p><p>gzip 用于配置传输文件前是否进行压缩以提高传输速率，压缩会占用一定系统资源</p><h4 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h4><div class="show">server {        listen      80;   //监听端口        server_name  localhost;//监听的域名或ip地址        #charset koi8-r;        #access_log  logs/host.access.log  main;//日志输出路径        location /web/ {  //路由路径            root   /test;            index  index.html index.htm;        }        location /images {            root /test;            autoindex on;//自动生成文件归档页面        }        location /.well-known/pki-validation/{        root /;        }        location /new/{        root    /;        add_header Content-Disposition "attachment;";        }//定义404页面        #error_page  404              /404.html;//定义50x页面        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }</div><h5 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h5><p><span class="strong">listen 地址/端口 [default_server];</span></p><p>配置监听地址和端口，default_server参数用于将该server设置为默认主机，无该参数则第一个server为默认主机，当没有匹配到客户端指定的端口/IP时，将连接到默认主机。地址和端口格式可以为：</p><ul><li>listen 127.0.0.1 监听该地址所有端口</li><li>listen 127.0.0.1:8080 监听该地址的8080端口</li><li>listen *:8080 监听所有地址的8080端口</li></ul><h5 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h5><p><span class="strong">server_name 域名/IP地址;</span></p><p>用于配置虚拟主机的标识名称，域名或IP地址可以写多个，使用空格隔开。当listen中配置了域名或IP地址，则server_name配置的域名和IP地址将失效，配置方法可以使用以下三种，当域名被多个server匹配到，将按精确匹配&gt;通配符在开头&gt;通配符在结尾&gt;正则匹配&gt;默认主机的优先级进行分配。</p><h6 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h6><div class="show">server {    listen 80;    server_name aaaa.com bbbbb.cn;//配置多个域名    .....}</div><h6 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h6><p>通配符只能在段首和段尾使用，不能再域名中间使用！</p><div class="show">server {    listen 80;    server_name *.aaaa.com www.aaaa.*;    .....}</div><h6 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h6><div class="show">server {    listen 80;    server_name ~正则表达式;    .....}</div><h5 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h5><p><span class="strong">charset 编码格式;</span><br>charset 用于指定字符编码格式，默认的koi8-r为俄语编码格式(nginx作者是俄罗斯人)，与utf-8类似</p><h5 id="access-log-1"><a href="#access-log-1" class="headerlink" title="access_log"></a>access_log</h5><p><span class="strong">access_log 路径 日志格式;</span></p><p>用于指定该server的连接日志，日志格式默认使用http模块中的main变量定义的格式，可用<span class="tips">log_format</span>命令自行定义。</p><h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><p><span class="strong">location 请求路径;</span></p><p>配置请求路径，可配置多个location块用于响应不同请求</p><div class="show">location  /路径{   //在test目录下匹配该路径(默认)    root /test}location = /路径{   //在test目录下精准匹配该路径    root /test}location ~* \正则表达式  {   //在test目录下正则匹配(添加*号不区分大小写)    root  /test            }~用于标识正则表达式，*表示不区分大小写，^~则表示不包含正则表达式，功能和不加~一致</div><h5 id="root-alias"><a href="#root-alias" class="headerlink" title="root/alias"></a>root/alias</h5><p><span class="strong">root/alias 路径;</span></p><p>用于指定资源查找路径，使用root语句时，客户端请求location路径，Nginx查找资源会直接前往<span class="tips">root路径+location路径</span>。alias一般在需要隐藏服务器真实路径时使用，查找资源会直接前往alias路径，location路径仅作为客户端请求的虚拟路径</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p><span class="strong">index 文件名;</span></p><p>用于设置主页，文件名可以写多个，如: index index1.html index2.html;当找不到第一个文件时，会依次往后查找。</p><h5 id="error-page"><a href="#error-page" class="headerlink" title="error_page"></a>error_page</h5><p><span class="strong">error_page 状态码 [=状态码] 路径;</span></p><p>用于设置错误处理方法，根据不同的状态码，进行相应处理，常用于配置404，50x页面，可以通过添加[=状态码]修改返回给客户端的状态码，如：error_page 404 [=200] /404.html，浏览器收到的状态码将从404修改为200。路径可以为：</p><ul><li>地址：error_page 404 http://<span></span>wrong.com</li><li>重定向:<div class="show">error_page   500 502 503 504  /50x.html;<br>location = /50x.html {<br>root   html;<br>}</div></li><li>返回信息:<div class="show">error_page 404 @goto<br>loaction @goto{<br>  default_type text/plain;<br>  return 404 ‘not found….’<br>}</div></li></ul><h3 id="Web服务器配置实例"><a href="#Web服务器配置实例" class="headerlink" title="Web服务器配置实例"></a>Web服务器配置实例</h3><p><strong>需求：</strong>在服务器8081和8082端口分别配置server1、server2两个服务，每个服务下有两个页面，根据客户端请求返回不同页面，为每个服务配置单独的访问日志。</p><h4 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h4><p>webservers目录位于服务器根目录下，conf.d目录用于存放每个服务的配置文件，web目录用于存放页面和访问日志。每个服务下的logs目录用于存放access_log日志文件，webpages目录用于存放页面。</p><div class="shell">webservers     |____conf.d     |          |_____server1.conf     |          |_____server2.conf     |____web           |____404.html           |____server1           |          |____logs——access_log           |          |____webpages           |                |____web1.html           |                |____web2.html           |____server2                      |_____logs——access_log                      |_____webpages                                 |_____web3.html                                 |_____web4.html</div><h4 id="http块配置"><a href="#http块配置" class="headerlink" title="http块配置"></a>http块配置</h4><p>定义两个变量server1和server2，用于配置日志格式，两个服务的配置文件独立存放于/webservers/conf.d路径下，使用include引入nginx.conf配置文件中。</p><div class="show">http{    ......    log_format server1 'new access =>$time_local';    log_format server2 'new access =>$time_local';    include /webservers/conf.d/*.conf;//引入两个服务的配置文件}</div><h4 id="server1配置"><a href="#server1配置" class="headerlink" title="server1配置"></a>server1配置</h4><p>访问<span class="tips"><code>http://45.77.77.10:8081</code></span>访问web1页面</p><p>访问<span class="tips"><code>http://45.77.77.10:8081/pages</code></span>访问web2页面</p><pre><code>server&#123;    listen 8081;    server_name 45.77.77.10;    access_log /webservers/web/server1/logs/access.log server1;    error_page 404 /404.html;    location /&#123;    alias /webservers/web/server1/webpages/;    index web1.html;    &#125;    location /pages&#123;    alias /webservers/web/server1/webpages/;    index web2.html;    &#125;    location =/404.html&#123;    root /webservers/web;    index 404.html;    &#125;      &#125;</code></pre><h5 id="server2配置"><a href="#server2配置" class="headerlink" title="server2配置"></a>server2配置</h5><p>访问<span class="tips"><code>http://45.77.77.10:8082/web3.html</code></span>访问web3页面</p><p>访问<span class="tips"><code>http://45.77.77.10:8082/webpages</code></span>访问web4页面</p><pre><code>server&#123;    listen 8082;    server_name 45.77.77.10;    access_log /webservers/web/server2/logs/access.log server2;    error_page 404 /404.html;    location /web3.html&#123;    root /webservers/web/server2/webpages;    index web3.html;    &#125;        location /webpages&#123;    root /webservers/web/server2;    index web4.html;    &#125;    location =/404.html&#123;    root /webservers/web;    index 404.html;    &#125;      &#125;</code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>配置https服务时，使用<span class="tips">ssl_certificatessl 路径</span>语句配置证书，使用<span class="tips">ssl_certificate_key 路径</span>配置密钥</div><h3 id="静态资源提供服务"><a href="#静态资源提供服务" class="headerlink" title="静态资源提供服务"></a>静态资源提供服务</h3><pre><code>http &#123;    .......gzip on;gzip_min_length 1;  //设置最小压缩大小，小于1字节的文件不进行压缩gzip_comp_level 3; //压缩级别(压缩比)，取值范围为1-9，值越大，压缩越多，cpu占用率越高gzip_types text/css text/javascript; //配置压缩的文件类型    server &#123;        listen      80;        server_name  45.77.78.10;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /images/ &#123;  //匹配路径        root /test;         //资源所在路径        autoindex on;  //自动生成资源归档页面         &#125;        location /images &#123;  //匹配路径        root /test;         //资源所在路径         &#125;         location /other/ &#123;  //匹配路径        alias /test/images;         //资源所在路径         &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;        .....    &#125;    ........&#125;</code></pre><p>test目录服务器根目录下，并且在/test/images路径下存放了photo.jpg照片</p><ul><li>使用第一个location配置时，当访问 http:<span></span>//45.77.78.10/images/ 时，ngxin会在自动生成的归档页面上输出/test/images/目录下的所有文件。请求只能为location后面配置的参数，若请求为 http:<span></span>//45.77.78.10/test/images/则会返回404</li><li>使用第二个location配置时，由于未使用 <span class="tips">autoindex on</span> 配置，nginx不会生成归档页面，当访问 http:<span></span>//45.77.78.10/images/ 时nginx将返回403，访问文件需指定具体文件路径，如：http:<span></span>//45.77.78.10/test/images/photo.jpg</li><li>当需要对访问者隐藏服务器实际文件路径时，可以使用<span class="tips">alias</span>进行配置，使用第三个location配置，url应当为http:<span></span>//45.77.78.10/other/photo.jpg，此时实际访问的依旧alias指定的/test/images路径下的文件</li></ul>]]></content>
    
    
    <summary type="html">Nginx是一款高性能的Web服务器软件，也可用于配置反向代理、虚拟主机、域名解析、负载均衡、邮件代理等各类服务器</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Redhat防火墙</title>
    <link href="https://shiwei11.github.io/blog/2022/02/23/Centos%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://shiwei11.github.io/blog/2022/02/23/Centos%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2022-02-23T08:18:13.000Z</published>
    <updated>2022-04-04T20:19:57.613Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>本文不涉及Debian系列操作系统使用的ufw(Uncomplicated FireWall)防火墙</div><h3 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h3><p>Firewalld支持动态更新防火墙规则，并加入了区域（zone）的概念，zone是Firewalld预先准备的几套防火墙策略模板，用户可以根据不同生产场景选择合适的策略集合，从而实现防火墙策略之间的快速切换。</p><h4 id="常用的区域"><a href="#常用的区域" class="headerlink" title="常用的区域"></a>常用的区域</h4><div class="table"><table><thead><tr><th>区域</th><th>默认策略</th></tr></thead><tbody><tr><td>trusted(信任)</td><td>允许所有数据包</td></tr><tr><td>block(阻塞)</td><td>拒绝所有数据包</td></tr><tr><td>drop(丢弃)</td><td>丢弃所有数据包，并且不回复信息</td></tr><tr><td>home(家庭)</td><td>仅接受与流出数据有关，或者与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关的数据包</td></tr><tr><td>public(公共)</td><td>仅接受与流出数据有关，或与ssh、dhcpv6-client服务相关的数据包</td></tr><tr><td>internal(内部)</td><td>仅接受与流出数据有关，或与ssh、mdns、ipp-client、dhcpv6-client服务相关的数据包</td></tr><tr><td>work(工作)</td><td>仅接受与流出的流量，或与ssh、ipp-client与dhcpv6-client服务相关的数据包</td></tr><tr><td>external(外部)</td><td>仅接受与流出流量和ssh服务相关的数据包</td></tr><tr><td>DMZ(隔离)</td><td>又称为非军事区域，内外网络之间增加的一层网络，起到缓冲作用，仅接受与流出的流量相关和ssh服务相关的数据包</td></tr></tbody></table></div><p>firewalld默认提供了9个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、 home.xml、internal.xml、public.xml、trusted.xml、work.xml，文件位于<span class="tips">/usr/lib /firewalld/zones/</span>目录下。用户对区域进行修改后，会在<span class="tips">/etc/firewalld/zones</span>目录下生成对应的(用户自定义)配置文件。</p><h4 id="防火墙开启与关闭"><a href="#防火墙开启与关闭" class="headerlink" title="防火墙开启与关闭"></a>防火墙开启与关闭</h4><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>systemctl start firewalld</td><td>开启防火墙</td></tr><tr><td>systemctl stop firewalld</td><td>关闭防火墙</td></tr><tr><td>systemctl enable firewalld</td><td>开机自启动防火墙</td></tr><tr><td>systemctl disable firewalld</td><td>禁止开机自启动</td></tr><tr><td>systemctl status firewalld</td><td>查看防火墙状态</td></tr></tbody></table></div><h4 id="命令与参数"><a href="#命令与参数" class="headerlink" title="命令与参数"></a>命令与参数</h4><p><span class="strong">firewall-cmd [参数]</span></p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-&zwnj;-state</td><td>查看防火墙是否在运行</td></tr><tr><td>-&zwnj;-get-default-zone</td><td>查看当前生效的防火墙区域</td></tr><tr><td>-&zwnj;-set-default-zone=区域名</td><td>设置生效的防火墙区域</td></tr><tr><td>-&zwnj;-get-zones</td><td>显示所有可用的区域</td></tr><tr><td>-&zwnj;-get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>-&zwnj;-zone=区域名 -&zwnj;-list-all</td><td>列出指定区域的所有配置参数</td></tr><tr><td>-&zwnj;-list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>-&zwnj;-get-services</td><td>查看当前域所有支持的服务(需要放行的服务需要自行添加)</td></tr><tr><td>-&zwnj;-list-services</td><td>查看当前区域允许放行的服务列表</td></tr><tr><td>-&zwnj;-add-service=服务名</td><td>设置当前区域允许该服务的流量通过</td></tr><tr><td>-&zwnj;-add-port=端口号/协议</td><td>设置当前区域允许该端口的流量通过</td></tr><tr><td>-&zwnj;-remove-service=服务名</td><td>设置默认区域禁止该服务的流量通过</td></tr><tr><td>-&zwnj;-remove-port=端口号/协议</td><td>设置当前区域禁止该端口的流量通过</td></tr><tr><td>-&zwnj;-add-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>-&zwnj;-remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>-&zwnj;-add-interface=网卡名</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>-&zwnj;-change-interface=网卡名</td><td>将某个网卡与区域进行关联</td></tr><tr><td>-&zwnj;-list-all</td><td>显示当前区域的网卡、资源配置，以及开放了哪些端口、服务</td></tr><tr><td>-&zwnj;-reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>-&zwnj;-panic-on</td><td>开启应急状况模式(关闭所有网络连接，包括远程ssh连接)</td></tr><tr><td>-&zwnj;-panic-off</td><td>关闭应急状况模式</td></tr></tbody></table></div><h4 id="生效模式，更新防火墙规则"><a href="#生效模式，更新防火墙规则" class="headerlink" title="生效模式，更新防火墙规则"></a>生效模式，更新防火墙规则</h4><p>默认情况下，firewalld配置的防火墙策略为当前生效模式(Runtime)，系统重启时会失效。想让配置策略永久生效，需要添加<span class="tips">-&zwnj;-permanent</span>参数使用永久模式(Permanent)，如：永久开放10800端口：firewall-cmd -&zwnj;-add-port=10800/tcp -&zwnj;-permanent ，但该模式配置的策略需要执行firewall-cmd -&zwnj;-reload命令重新加载后才会生效。</p><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>firewall-cmd -&zwnj;-reload</td><td>重新加载防火墙配置</td></tr><tr><td>firewall-cmd -&zwnj;-complete-reload</td><td>重新加载防火墙，不中断用户的连接,如远程连接（防火墙出严重故障时使用）</td></tr></tbody></table></div><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>1. 查看区域信息</strong></p><div class="shell">查看public区域的所有信息# firewall-cmd --zone=public --list-all返回值的含义：Target：default                  //目标icmp-block-inversion：yes/no    //是否允许ICMP协议类型的数据包通过防火墙Interfaces：                   //关联的网卡sources：                     //来源，可以是IP地址或mac地址services：                   //允许的服务ports：                     //允许的端口，即本地开放的端口protocols：                //允许通过的协议masquerade: yes/no        //是否允许伪装，可改写来源IP地址及mac地址 forward-ports：          //允许转发的端口 source-ports：          //允许的来源端口 icmp-blocks：         //可添加的ICMP类型，当icmp-block-inversion为no时，这些ICMP类型被拒绝；当icmp-block-inversion为yes时，这些ICMP类型被允许 rich rules： //富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。</div><p><strong>2. 放行端口</strong></p><div class="shell">永久放行10800-10805端口的tcp数据# firewall-cmd --permanent --add-port=10800-10805/tcp重新加载防火墙配置# firewall-cmd --reload</div><p><strong>3. 为网卡绑定区域</strong></p><p>一般情况下，一台主机会有多个网卡，比如一块对公网，一块对内网，因此网卡使用的防火墙策略也不一样，可以单独为某个网卡绑定某个区域。通过firewall-cmd –set-default-zone命令设置的区域会对所有网卡生效，但如果该网卡绑定了单独的区域，则单独绑定区域的优先级更高。</p><div class="shell">将网卡eth0默认区域修改为external# firewall-cmd --permanent --zone=external --change-interface=eth0</div><p><strong>4. 查询服务是否放行</strong></p><p>如：查询SSH和HTTPS协议的流量是否允许放行</p><div class="shell">查询public区域中SSH协议的流量是否被放行# firewall-cmd --zone=public --query-service=ssh查询public区域中https协议的流量是否被放行# firewall-cmd --zone=public --query-service=https</div><p><strong>5. 放行协议流量</strong></p><p>把HTTPS协议的流量设置为永久允许放行</p><div class="shell">在public区域中放行https协议的流量# firewall-cmd --permanent --zone=public --add-service=https重新加载防火墙配置# firewall-cmd --reload</div><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>端口转发命令格式如下，目标IP地址为所要访问服务器的IP地址：<br><span class="strong">firewall-cmd –permanent –zone=区域 –add-forward-port=port=源端口号:proto=协议:toport=目标端口号:toaddr=目标IP地址</span></p><div class="shell">将9000端口转发到22端口，使得用户能通过9000端口使用ssh远程连接服务# firewall-cmd --permanent --zone=public --add-forward-port=port=9000:proto=tcp:toport=22:toaddr=192.168.0.1重新加载防火墙配置# firewall-cmd --reload</div><h4 id="富规则"><a href="#富规则" class="headerlink" title="富规则"></a>富规则</h4><p>富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置，它的优先级在所有的防火墙策略中也是最高的。</p><div class="shell">拒绝192.168.0.1/24网段的所有用户访问本机的ssh服务# # firewall-cmd --permanent --zone=public --add-rich-rule="rule family="ipv4" source address="192.168.0.1/24" service name="ssh" reject"重新加载防火墙配置# firewall-cmd --reload</div><h3 id="IPTables"><a href="#IPTables" class="headerlink" title="IPTables"></a>IPTables</h3><p>早期的RHEL系列的操作系统，默认使用IPTables来配置防火墙。RHEL7之后的系统使用firewalld取代了IPTables防火墙，IPTables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。</p><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>Centos官方IPTables文档：<a target="_blank" href="https://wiki.centos.org/HowTos/Network/IPTables">https://wiki.centos.org/HowTos/Network/IPTables</a></div><h4 id="策略与规则链"><a href="#策略与规则链" class="headerlink" title="策略与规则链"></a>策略与规则链</h4><p>IPTables会根据管理员书写的策略来决定防火墙是否放行数据包通过，基本的策略规则有四种：ACCEPT、REJECT、LOG、DROP。IPTables会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后立即执行规则定义的行为(如：放行或阻止流量)，若在读取完所有的策略规则之后没有匹配项，则会执行默认的策略。</p><p>IPTables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链。<span class="tips">由于防火墙策略规则是按照从上到下的顺序匹配执行的，因此一定要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝，因此规则链最后一条往往为拒绝规则。</span></p><p>当防火墙的默认策略为拒绝时，需要添加相应的规则链来放行允许进入服务器的数据，否则服务器将拒绝所有数据包；而当防火墙的默认策略为允许时，则需要添加相应的拒绝规则链，否则防火墙就失去了它的作用。一般情况下，INPUT流量的默认策略为拒绝，OUTPUT流量默认策略为允许。</p><h4 id="数据包分类与处理方式"><a href="#数据包分类与处理方式" class="headerlink" title="数据包分类与处理方式"></a>数据包分类与处理方式</h4><p>根据数据包的不同处理位置，数据包分为</p><ul><li><span class="strong">在进行路由选择前处理数据包(PREROUTING)</strong></li><li><span class="strong">处理流入的数据包(INPUT)</strong></li><li><span class="strong">处理流出的数据包(OUTPUT)</strong></li><li><span class="strong">处理转发的数据包(FORWARD)</strong></li><li><span class="strong">在进行路由选择后处理数据包(POSTROUTING)</strong></li></ul><h5 id="数据包处理方式"><a href="#数据包处理方式" class="headerlink" title="数据包处理方式"></a>数据包处理方式</h5><div class="table"><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td>ACCEPT</td><td>允许流量通过</td></tr><tr><td>REJECT</td><td>拒绝流量通过并返回流量被丢弃的提示信息</td></tr><tr><td>LOG</td><td>记录日志信息</td></tr><tr><td>DROP</td><td>拒绝流量通过且不返回任何信息</td></tr></tbody></table></div><p>REJECT会在拒绝流量后，告知流量发送方流量已收到，但服务器拒绝响应的信息</p><p>DROP会直接丢弃流量，使流量发送方不清楚流量是被拒绝还是主机不在线，一般能更好保护主机安全。</p><h4 id="命令与参数-1"><a href="#命令与参数-1" class="headerlink" title="命令与参数"></a>命令与参数</h4><p><span class="strong">iptables [参数] [对象]</span></p><div class="table"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-L</td><td>查看当前的规则链，可以使用iptables -L –line-numbers命令显示规则链的序号</td></tr><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-A</td><td>在规则链末尾加入新规则</td></tr><tr><td>-I [序号]</td><td>在指定序号规则前加入新规则，无序号默认在规则链首加入</td></tr><tr><td>-R 序号</td><td>替换指定规则，无序号默认替换第一条规则</td></tr><tr><td>-D 序号</td><td>删除指定规则</td></tr><tr><td>-s IP/主机名</td><td>匹配来源的IP和主机，加!号表示除该IP外，子网掩码可以使用/MASK的方式表示</td></tr><tr><td>-d</td><td>匹配目标地址，类似于参数-s</td></tr><tr><td>-J</td><td>跳转到下一个处理规则，可能的值有：ACCEPT(允许数据通过), DROP(丢弃), QUEUE(进入队列), RETURN(返回上一个跳转规则)。也可以添加规则名跳转到指定规则</td></tr><tr><td>-i 网卡名</td><td>匹配从该网卡流入的数据</td></tr><tr><td>-o 网卡名</td><td>匹配从该网卡流出的数据</td></tr><tr><td>-p 协议</td><td>匹配协议，如:TCP、UDP等,all代表所有协议(一般不使用)</td></tr><tr><td>-&zwnj;-dport 端口号</td><td>匹配目标端口号</td></tr><tr><td>-&zwnj;-sport 端口号</td><td>匹配来源端口号</td></tr></tbody></table></div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>防火墙命令均需要root权限</div><div class="shell">如：查看当前规则链iptables -L返回结果：Chain INPUT (policy ACCEPT)     //INPUT数据包，默认策略为ACCEPTnum  target     prot opt source               destination         1    ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED2    ACCEPT     all  --  anywhere             anywhere            3    INPUT_direct  all  --  anywhere             anywhere            4    INPUT_ZONES_SOURCE  all  --  anywhere             anywhere            5    INPUT_ZONES  all  --  anywhere             anywhere            6    DROP       all  --  anywhere             anywhere             ctstate INVALID7    REJECT     all  --  anywhere             anywhere             reject-with icmp-host-prohibited</div><div class="show">示例：<strong>1. 修改INPUT规则链默认配置为拒绝，并允许允许ICMP流量进入(允许服务器被ping后返回信息)</strong># iptables -P INPUT DROP# iptables -I INPUT -p icmp -j ACCEPT<strong>2. 拒绝所有人访问本机10800端口</strong># iptables -I INPUT -p tcp --dport 10800 -j REJECT# iptables -I INPUT -p udp --dport 10800 -j REJECT<strong>3. 拒绝192.168.10.5主机访问本机80端口</strong>iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT<strong>4.拒绝所有主机访问本机1000～1024端口</strong># iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT<strong>5.只允许192.168.10.0主机访问本机的22端口，拒绝来自其他所有主机的流量。</strong># iptables -I INPUT -s 192.168.10.0 -p tcp --dport 22 -j ACCEPT# iptables -A INPUT -p tcp --dport 22 -j REJECT</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>如同第5条命令，由于防火墙策略规则是按照从上到下的顺序匹配的，因此需要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝</div><div class="show">网口转发,如将公网的数据包转发到内网,假设eth0连接内网，eth1连接公网iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</div><h4 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h4><p>通过命令添加的规则链，会在系统重启后失效，因此需要写入配置文件使其永久生效，可以使用命令<span class="tips">service iptables save</span>保存</p><p>ipv4默认保存位置为<span class="tips">/etc/sysconfig/iptables-config</span></p><p>ipv6默认保存位置为<span class="tips">/etc/sysconfig/ip6tables-config</span></p>]]></content>
    
    
    <summary type="html">Redhat系列系统防火墙的配置方法，包括防火墙策略配置语法，IPTable和firewalld服务的常用命令，适用于CentOS、Fedora、RHEL发行版</summary>
    
    
    
    
    <category term="CentOS" scheme="https://shiwei11.github.io/blog/tags/CentOS/"/>
    
    <category term="firewall" scheme="https://shiwei11.github.io/blog/tags/firewall/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本语言</title>
    <link href="https://shiwei11.github.io/blog/2021/12/29/Shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
    <id>https://shiwei11.github.io/blog/2021/12/29/Shell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</id>
    <published>2021-12-29T02:07:11.000Z</published>
    <updated>2024-12-02T22:46:36.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shell脚本基础"><a href="#shell脚本基础" class="headerlink" title="shell脚本基础"></a>shell脚本基础</h3><h4 id="脚本声明"><a href="#脚本声明" class="headerlink" title="脚本声明"></a>脚本声明</h4><p>shell脚本文件通常以<span class="tips">.sh</span>作为文件扩展名，扩展名仅作为文件标识，并不影响脚本执行。shell程序的第一行，往往需要一个<span class="tips">#!</span>约定标记符，用于告诉系统这个脚本需要调用哪一种Shell解释器来执行</p><div class="show">#!bin/bash  #申明shell脚本的解释器</div><h4 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h4><h6 id="1-通过文件名直接执行"><a href="#1-通过文件名直接执行" class="headerlink" title="1.通过文件名直接执行"></a>1.通过文件名直接执行</h6><p>首先需要为该脚本添加可执行权限，然后通过文件路径和文件名直接运行，操作系统会调用脚本文件第一行所指定的解释器来执行该脚本，如对于名为HelloWorld.sh脚本，执行方式为:</p><div class="show"><span class="strong">chmod 755 HelloWorld.sh</span> #或chmod +x HelloWorld.sh赋予可执行权限<span class="strong">./HelloWorld.sh</span> #在当前路径中执行HelloWorld.sh，如果直接写为HelloWorld.sh，则系统会前往PATH路径中查找该命令</div> <h6 id="2-通过shell解释器调用"><a href="#2-通过shell解释器调用" class="headerlink" title="2.通过shell解释器调用"></a>2.通过shell解释器调用</h6><p>第二种执行方式为在调用shell解释器时，将脚本作为shell程序参数传入，该方法会忽略脚本第一行所指定解释器信息，直接使用用户唤起的shell程序作为脚本解释器</p><div class="show"><span class="strong">bash HelloWorld.sh  #通过bash执行</span>或<span class="strong">/bin/sh HelloWorld.sh #通过sh执行</span></div><h4 id="全局执行脚本方式"><a href="#全局执行脚本方式" class="headerlink" title="全局执行脚本方式"></a>全局执行脚本方式</h4><p>执行脚本一般需要在赋予脚本执行权限后，使用绝对路径调用，或者进入脚本所在目录，使用相对路径调用。那些全局可用的脚本和命令，Linux是根据PATH环境变量中所存储的脚本路径自动寻找执行实现的，可通过<span class="strong">echo $PATH</span>查看当前所配置的全局路径，手动安装的服务想实现全局执行脚本，有两种实现方法：</p><ul><li><span class="strong">将脚本通过cp命令复制到PATH中的某个路径下，如:/usr/bin下</span></li><li><span class="strong">通过变量叠加的方式，将脚本路径添加到PATH变量中，格式为PATH=”$PATH”:路径</span></li></ul><p>通过变量叠加的方式添加的全局变量，在系统重启后将失效，永久生效方法是将路径添加到<span class="tips">/etc/profile</span>文件的PATH变量后</p><div class="show">如Nginx的启动脚本在/usr/local/nginx/sbin路径下，非全局启动方法为：1.相对路径： 在 /usr/local/nginx/sbin 目录下执行./nginx 2. 绝对路径：执行 /usr/local/nginx/sbin/nginx添加到全局的方法为：执行PATH="$PATH":/usr/local/nginx/sbin使调用命令永久生效的方法：在 /etc/profile 中最后一行添加PATH=$PATH:/usr/local/nginx/sbin</div><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>shell程序使用<span class="tips">#</span>开头作为注释，多行注释需要在每一行开头都添加#号，注意程序第一行的脚本声明并不是注释符</p><div class="show">#!/bin/bash#author: shiwivi#version: v0.1.0#data: 2023-09-01</div><p>对于需要多行注释的内容，可以将其写入花括号中定义成一个函数，然后不调用即可</p><h4 id="脚本格式转换"><a href="#脚本格式转换" class="headerlink" title="脚本格式转换"></a>脚本格式转换</h4><p>在Linux中，回车符识别为<span class="tips"><strong><code>$</code></strong></span>，而在windows中回车符为^M$，因此在windows中编写的sh脚本需要经过转换，才能在Linux中运行，转换命令为：<br><span class="strong">dos2unix 文件名</span><br>相反，将文件从Linux格式转为Windows格式为<br><span class="strong">unix2dos 文件名</span></p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>该功能需要自行安装dos2unix软件，red hat系列操作系统安装命令为：yum -y install dos2unix</div><h4 id="脚本退出状态码"><a href="#脚本退出状态码" class="headerlink" title="脚本退出状态码"></a>脚本退出状态码</h4><p>shell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕，这个状态码可以使用<span class="strong">$?</span>查看。同样，我们的脚本也可以使用退出状态码优雅地结束脚本执行，并返回脚本执行的状态。</p><p>退出状态码是一个0～255的整数值，默认情况下，命令成功执行时退出状态码是0，如果命令执行错误，则退出状态码就是一个正整数值。在脚本中，可通过<span class="strong">exit 状态码</span>命令指定脚本结束时的退出状态码，<span class="tips">注意！exit命令会退出脚本，exit命令之后的任何代码都将不再执行</span>。状态码应当设置在0-255区间内，否则会对其进行求模运算，如：指定状态码为300，则进行300%256运算，最后取值44，设置状态码时也可以使用变量</p><div class="show">#!/bin/bash echo "Hello world"<span class="text-blue">exit 0</span></div><p>Linux中命令执行错误时的退出状态码无标准可循，但有一些可用参考：</p><div class="table"><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>命令成功执行</td></tr><tr><td>1</td><td>一般性未知错误</td></tr><tr><td>2</td><td>不适合的shell命令</td></tr><tr><td>126</td><td>命令不可执行</td></tr><tr><td>127</td><td>没找到命令</td></tr><tr><td>128</td><td>无效的退出参数</td></tr><tr><td>128+x</td><td>与Linux信号相关的严重错误</td></tr><tr><td>130</td><td>通过Ctrl C终止的命令</td></tr><tr><td>255</td><td>正常范围之外的退出状态码</td></tr></tbody></table></div><div class="show">上述的状态码有一些常见的情况：状态码126表明用户没有权限执行该命令，即Permission denied状态码1表明命令发生了未知错误，如：为命令提供了无效参数</div><h3 id="shell中的运算"><a href="#shell中的运算" class="headerlink" title="shell中的运算"></a>shell中的运算</h3><h4 id="各种括号使用预览"><a href="#各种括号使用预览" class="headerlink" title="各种括号使用预览"></a>各种括号使用预览</h4><ul><li>()用来创建子shell执行命令组，而$()则可以用来获取命令的输出，并将其赋值给变量，其作用和 ``命令调用一致，如：today=$(date “+%D”)。如果( )中指定了多个命令，则变量获取的是最后一个命令的输出</li><li>[ ]用来进行条件判断，它是test命令的替代，可以结合if-then等条件判断语句进行数值比较、字符串比较、文件比较</li><li>$(())和$[]用来进行整形数值运算，如：num=$[11+22]</li><li>(())可以用来运算高级数学表达式，如：++、&gt;&gt;(右移位)、&amp;&amp;(逻辑与)等运算，也可以搭配if-then语句进行条件判断</li><li>双方括号[[]]命令用来进行高级字符串比较，允许使用*和?通配符，支持模式匹配，但部分shell可能不支持</li><li>大括号{ }用来进行变量引用，支持字符串拼接</li></ul><h4 id="与-命令调用"><a href="#与-命令调用" class="headerlink" title="$()与``命令调用"></a>$()与``命令调用</h4><p>shell中最有用的特性之一是可以将命令的输出赋值给变量，然后通过变量来任意调用，有两种方法可以将命令输出赋值给变量：</p><ul><li>通过<span class="strong">反引号``</span></li><li>通过<span class="strong">$( )</span></li></ul><div class="show">e.g.每天使用当前日期为文件名创建一个文件，并将bin目录信息写入其中today=`date`或today=$(date "+%D")ls /usr/bin -al &gt; log.$today</div><h4 id="与-整数运算"><a href="#与-整数运算" class="headerlink" title="$(())与$[]整数运算"></a>$(())与$[]整数运算</h4><ul><li><span class="strong">变量名=$((运算式))</span></li><li><span class="strong">变量名=$[运算式]</span></li></ul><p>$[]是一种旧的Bash算术扩展方式，现代Shell更推荐使用$(())进行算术运算</p><div class="shell">示例：[root@localhost ~]# num1=$((11+22))[root@localhost ~]# num2=$[11+22]</div><h4 id="expr表达式"><a href="#expr表达式" class="headerlink" title="expr表达式"></a>expr表达式</h4><p>expr是由Bourne shell提供的数学工具，bash shell为了保持跟Bourne shell的兼容而包含了expr命令。尽管现代脚本中大部分功能被更强大的 $(()) 算术求值或 ${} 字符串操作所取代，但 expr 在经典UNIX和早期shell脚本中仍然非常重要，expr表达式支持以下功能：</p><ul><li>整数运算：加减乘除、取模运算等</li><li>字符串操作：获取字符串长度、子串提取、模式匹配等</li><li>条件判断：执行条件判断并返回 0 或 1 表示真假</li></ul><p>expr通常搭配<span class="tips">``</span>和<span class="tips">$()</span>来获取expr表达式最后的计算值：</p><div class="show"> num=<span class="strong">`expr 2 + 2`</span>注意表达式和运算符之间要有空格，即+号前后都要有一个空格，正确形式为2 + 2，省略空格2+2会被解析为一个字符串，而不是数值运算</div><div class="shell">示例:[root@localhost ~]# a=11[root@localhost ~]# b=22[root@localhost ~]# num1=$a+$b  //字符串运算[root@localhost ~]# echo $num1  //输出11+22[root@localhost ~]# num2=$(expr $a + $b)  //数值运算[root@localhost ~]# echo $num2  //输出33</div><p>expr命令能够识别以下数学和字符串操作符，特殊字符的转义 expr 中的某些字符，如 *, &amp;, &lt;, &gt;, | 等，在 shell 中具有特殊含义，需要用反斜杠 \ 进行转义处理</p><div class="table"><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>ARG1 + ARG2</td><td>返回ARG1和ARG2的算术运算和</td></tr><tr><td>ARG1 - ARG2</td><td>返回ARG1和ARG2的算术运算差</td></tr><tr><td>ARG1 \* ARG2</td><td>返回ARG1和ARG2的算术乘积，需要将*号转义</td></tr><tr><td>ARG1 / ARG2</td><td>返回ARG1被ARG2除的算术商</td></tr><tr><td>ARG1 % ARG2</td><td>返回ARG1被ARG2除的算术余数</td></tr><tr><td>ARG1 \&lt; ARG2</td><td>如果ARG1小于ARG2，返回1；否则返回0</td></tr><tr><td>ARG1 &lt;= ARG2</td><td>如果ARG1小于或等于ARG2，返回1；否则返回0</td></tr><tr><td>ARG1 = ARG2</td><td>如果ARG1等于ARG2，返回1；否则返回0</td></tr><tr><td>ARG1 != ARG2</td><td>如果ARG1不等于ARG2，返回1；否则返回0</td></tr><tr><td>ARG1 &gt;= ARG2</td><td>如果ARG1大于或等于ARG2，返回1；否则返回0</td></tr><tr><td>ARG1 \&gt; ARG2</td><td>如果ARG1大于ARG2，返回1；否则返回0</td></tr><tr><td>A</td><td></td></tr><tr><td>ARG1 \&#124; ARG2</td><td>如果ARG1既不是null也不是零值，返回ARG1；否则返回ARG2</td></tr><tr><td>ARG1 \&amp; ARG2</td><td>如果没有参数是null或零值，返回ARG1；否则返回0</td></tr><tr><td>STRING : REGEXP</td><td>如果REGEXP匹配到了STRING中的某个模式，返回匹配的子字符串或长度</td></tr><tr><td>match STRING REGEXP</td><td>如果REGEXP匹配到了STRING中的某个模式，返回该模式匹配</td></tr><tr><td>substr STRING POS LENGTH</td><td>返回起始位置为POS（从1开始计数）、长度为LENGTH个字符的子字符串</td></tr><tr><td>index STRING CHARS</td><td>返回在STRING中找到CHARS字符串的位置；否则，返回0</td></tr><tr><td>length STRING</td><td>返回字符串STRING的数值长度</td></tr><tr><td><code>+</code> TOKEN</td><td>将TOKEN解释成字符串，即使是个关键字</td></tr><tr><td>(EXPRESSION)</td><td>返回EXPRESSION的值</td></tr></tbody></table></div><div class="show">1. 数值运算expr 3 \* 4  #输出122. 获取字符串长度expr length "hello"  # 输出：53. 截取子字符串(substr)expr substr "hello world" 1 5  # 输出：hello4. 查找字符位置(index)expr index "hello world" "o"  # 输出：55. 字符串模式匹配(返回匹配的子字符串或长度)expr "abc123" : 'abc[0-9]*'  # 输出：66. 大于、小于判断expr 4 \> 3  # 输出：1 （表示 true）expr 4 \< 5  # 输出：1 （表示 true）7. 逻辑与和或运算expr 0 \| 1 # 输出：1expr 0 \& 1 # 输出：0</div><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="shell中的变量类型"><a href="#shell中的变量类型" class="headerlink" title="shell中的变量类型"></a>shell中的变量类型</h4><p>shell程序的变量可以分为以下几种：</p><ul><li>自定义变量，即程序员自定义的变量</li><li>预定义变量：bash预定义的变量</li><li>环境变量：由操作系统或用户设置的特殊变量，用于保存操作系统环境相关的数据，以及配置 Shell 的行为和执行环境</li><li>位置参数变量：用于向脚本中传递参数和数据，变量名不能自定义</li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>可以通过 <strong>set</strong> 命令查看所有变量，包括系统预定义的变量</div><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul><li>变量名规则同C语言，允许由字母、数字、下划线组成，但不能以数字开头</li><li>bash中变量默认类型都为字符串类型</li><li>变量赋值时，若值包含空格，则需要使用单引号或双引号包裹</li><li>变量值中可以使用\进行转义</li><li>变量名通常使用下划线分隔单词，如：user_name,server_ip</li><li>自定义的环境变量名、常量的变量名一般使用大写，如：readonly MAX_VLAUE=10</li></ul><h5 id="变量定义、赋值、调用"><a href="#变量定义、赋值、调用" class="headerlink" title="变量定义、赋值、调用"></a>变量定义、赋值、调用</h5><p>定义自定义变量不需要int、var等关键字，可以直接使用<span class="tips">变量名=值</span>形式定义并赋值，默认情况下，变量通常被视为字符串。对于定义过的变量，可以使用<span class="tips">${变量名}</span>调用，花括号用于识别变量边界，可以不加，但加上花括号是个好的编程习惯</p><div class="show">1. 赋值时等号两侧避免使用空格name="Ken"2. 除了显式地直接赋值，还可以用语句给变量赋值for file in `ls /etc`3. 可以用$调用变量，使用花括号可以识别变量边界，如果有花括号，则以下变量会被识别为$nameChouecho "my name is ${name}Chou"4. 变量可以重新定义，即重新赋值，重新赋值不需要使用$name="new"</div><h5 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h5><p>使用<span class="tips">readonly</span> 命令可以将变量定义为只读变量，只读变量的值不能被改变，且只读变量不能使用unset删除</p><div class="show">myName="Ken"readonly myNamemyName="New" #执行脚本会报错myName：This variable is read only</div><h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><p>可以通过<span class="strong">unset 变量名</span>命令删除变量，但无法删除只读变量</p><div class="show">myName="Ken"unset myNameecho $myName  #无任何输出</div><h4 id="变量值检测与替换"><a href="#变量值检测与替换" class="headerlink" title="变量值检测与替换"></a>变量值检测与替换</h4><p>类似于C语言三元表达式的一种功能，即检测变量y是否存在，或者其值是否为空/非空，然后根据y的状态赋予变量x不同值</p><div class="table"><table><thead><tr>   <th>语句</th>   <th>未定义变量y</th>   <th>变量y为空</th>   <th>变量y非空</th>   <th>说明</th></tr></thead><tbody><tr>   <td>x=${y:-默认值}</td>   <td>x=默认值</td>   <td>x=默认值</td>   <td>x=$y</td>   <td>如果变量y未定义或为空，则x使用指定的默认值</td></tr><tr>   <td>x=${y:=默认值}</td>   <td>x=y=默认值</td>   <td>x=y=默认值</td>   <td>x=$y,y值不变</td>   <td>如果变量y未定义或为空，则赋予y默认值，且x也使用默认值</td></tr><tr>   <td>x=${y:+替代值}</td>   <td>x为空</td>   <td>x为空</td>   <td>x=替代值</td>   <td>如果变量y已定义且非空，则x使用替代值</td></tr><tr>   <td>x=${y:?错误消息}</td>   <td>输出消息到标准错误输出</td>   <td>输出消息到标准错误输出</td>   <td>x=$y</td>   <td>如果变量y未定义或为空，输出错误信息并退出</td></tr><tr><td colspan="5"><span class="text-red">不带<span class="text-blue">:</span>的语法只检查变量是否已定义，不检查变量是否为空值(即使y为空也视为有效)</span></td></tr><tr>   <td>x=${y-默认值} </td>   <td>x=默认值 </td>   <td>x=$y(空)</td>   <td>x=$y</td>   <td>如果y未定义，则x使用默认值</td></tr><tr>   <td>x=${y=默认值} </td>   <td>x=y=默认值</td>   <td>x=$y(空)</td>   <td>x=$y,y值不变</td>   <td>如果变量y未定义，则x和y都赋值为默认值</td></tr><tr>   <td>x=${y+替代值}</td>   <td>x为空</td>   <td>x=替代值</td>   <td>x=替代值</td>   <td>如果变量y已定义(即使为空)，则x使用替代值</td></tr><tr>   <td>x=${y?错误消息}</td>   <td>输出消息到标准错误输出</td>   <td>x=$y(空)</td>   <td>x=$y</td>   <td>如果变量y未定义，则输出错误消息并退出</td></tr></tbody></table></div><div class="show">1. 如果变量filePath未定义或路径为空，则使用默认的路径filePath=${filePath:-/usr/local/etc/myfile}2. 当变量port未定义或为空时，为newPort赋值为2000，且port也赋值为2000(虽然2000依旧会被解析为字符串而不是数值)newPort=${port:=2000}</div><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>shell中的字符串可以使用单引号声明，也可以使用双引号声明，二者的特性：</p><ul><li>单引号里的字符会原样输出，无法使用转义字符和变量，双引号里字符串的可以使用转义字符、引用变量</li><li>二者都可以用于字符串拼接</li></ul><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>可以直接在字符串前后使用<span class="tips">${变量名}</span>拼接字符串，不需要像其他语言一样添加+号等字符串拼接符</p><div class="show">text="1234"str1="aaa"${text}"bbb"  #可以直接将多个字符串拼接在一起，并拼接变量，输出aaa1234bbbstr2="aaa${text}bbb"    #可以直接在字符串中引用变量，输出aaa1234bbbstr3='aaa'${text}'bbb'  #单引号也可以拼接字符串，输出aaa1234bbbstr4='aaa${text}bbb'    #但不能在单引号声明的字符串中引用变量，会原样输出aaa${text}bbbecho str1 str2 str3 str4</div><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>可以使用<span class="tips">${#字符串变量名}</span>来获取字符串长度</p><div class="show">str="abcdecho ${#str}  #当变量为字符串时，${#str} 等价于 ${#str[0]}</div><h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>使用<span class="tips">${字符串变量名:索引1:索引2}</span>来截取从索引1到索引2的字符串，字符串索引从0开始</p><div class="show">str="He said, one day you will leave this world behind."echo ${str:1:5} #输出e sai</div><h4 id="快速删除字符串"><a href="#快速删除字符串" class="headerlink" title="快速删除字符串"></a>快速删除字符串</h4><p>shell中可以使用<span class="tips">#</span>、<span class="tips">##</span>、<span class="tips">%</span>、<span class="tips">%%</span>符快速删除匹配的部分字符串</p><ul><li><span class="strong">${字符串变量#pattern}</span>删除pattern所匹配字符串之前的最短匹配部分</li><li><span class="strong">${字符串变量##pattern}</span>删除pattern所匹配字符串之前的最长匹配部分</li><li><span class="strong">${字符串变量%pattern}</span>删除pattern所匹配字符串之后的最短匹配部分</li><li><span class="strong">${字符串变量%%pattern}</span>删除pattern所匹配字符串之后的最长匹配部分</li></ul><div class="show">str="path/to/file.txt"# 删除开头的部分echo ${str#*/}        # 输出：to/file.txt（最短匹配 "path/"）echo ${str##*/}       # 输出：file.txt（最长匹配 "path/to/"）# 删除结尾的部分echo ${str%/*}        # 输出：path/to（最短匹配 "/file.txt"）echo ${str%%/*}       # 输出：path（最长匹配 "/to/file.txt"）</div><h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><div class="show">查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)str="He said, one day you will leave this world behind."echo `expr index "${str}" io`</div><h4 id="可转义的字符串"><a href="#可转义的字符串" class="headerlink" title="可转义的字符串"></a>可转义的字符串</h4><p>Bash支持使用<span class="tips">$’字符串’</span>语法来解析字符串中ANSI C 样式的转义序列，允许在字符串中插入特殊字符，如：换行符(\n)、制表符(\t)等，这可用于将转义字符赋值给IFS(字段分隔符变量)等</p><div class="show">1.写于''或""号的转义字符不会被解析，会原样输出(以echo举例，虽然echo有支持转义的选项)echo 'AAAA\nAAAA'  #输出AAAA\nAAAAecho "AAAA\nAAAA"  #输出AAAA\nAAAAecho $'AAAA\nAAAA'输出AAAAAAAA2.可以通过IFS变量将字段分隔符修改为换行IFS.OLD=$IFS #保存原变量IFS=$'\n'</div><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><p>bash只支持一维数组，不支持多维数组，bash中的一维数组不限制数组大小，使用括号囊括数组元素，数组元素之间使用空格分隔：<span class="strong">数组名=(值1 值2 值3)</span></p><div class="show">1. 数组支持整体赋值array1=(10 20 30)2.数组元素间可以使用空格，也可以用换行符array1=(102030)3.也支持数组元素单独赋值array1[0]=10array1[1]=20array1[2]=304. 数组元素默认都被声明为字符串类型，因此以下语句也正确array1=(100 "Hello" abc)</div><h4 id="数组元素"><a href="#数组元素" class="headerlink" title="数组元素"></a>数组元素</h4><p>bash中数组使用<span class="tips">${数组名[下标]}</span>表示数组元素，与绝大多数语言一样，数组下标从0开始，可以用<span class="tips">${数组名[@]}</span>或<span class="tips">${数组名[*]}</span>表示数组中的所有元素</p><div class="show">echo ${array1[1]} #输出20echo ${array1[@]} #输出10 20 30echo ${array1[*]} #输出10 20 30</div><h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><p>获取数组长度的方法与获取字符串长度的方法类似，即在需要获取的对象前加上<span class="tips">#</span>号，该方法可以获得整个数组的长度，也可以用于获取单个数组元素的长度</p><div class="show">1. 获取数组长度echo ${#array1[@]}或echo ${#array1[*]}2. 获取单个数组元素的长度echo ${#array1[1]}3. 注意${#array1}返回的是数组第一个元素的长度(数组名代表数组首元素的起始地址)array1=(12345 "Hello" abcd)echo ${#array1} #输出字符串12345的长度5</div><h4 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h4><p>Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素，关联数组的键是唯一的<br>关联数组使用 declare 命令来声明，语法格式为：<br><span class="strong">declare -A 数组名</span><br>数组元素访问方式为：<span class="tips">${数组名[“键名”]}</span>，通过<span class="tips">${数组名[@]}</span>或<span class="tips">${数组名[*]}</span>可以获取所有元素，在此基础上，在数组名前加上<span class="tips">!</span>可以获取数组所有键，在数组名前加上<span class="tips">#</span>可以获取数组长度</p><div class="show">1.关联数组可以在定义同时赋值declare -A singer=(["周杰伦"]="手写的从前" ["陈奕迅"]="十年" ["林俊杰"]="江南")也可以先声明，再赋值declare -A singersinger["周杰伦"]="手写的从前"singer["陈奕迅"]="十年" singer["林俊杰"]="江南"2. 数组元素、键访问方式echo ${singer["周杰伦"]}         #访问单个元素echo "数组的元素有" ${singer[*]}#访问所有元素echo "数组的键有" ${!singer[*]}  #访问所有键echo "数组的元素有" ${#singer[*]}#访问数组长度</div><h3 id="位置变量与参数传递"><a href="#位置变量与参数传递" class="headerlink" title="位置变量与参数传递"></a>位置变量与参数传递</h3><h4 id="给脚本传递参数"><a href="#给脚本传递参数" class="headerlink" title="给脚本传递参数"></a>给脚本传递参数</h4><p>在使用命令执行脚本时，可以向脚本中传递参数，在脚本中可以使用一些预定义变量获取到这些参数</p><div class="table">   <table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>$n</td><td>n为数字，$0代表命令本身(包含文件路径)，$1-$9代表命令第1-9个参数，10以上用{}包裹，如:${10}</td></tr><tr><td>$*</td><td>代表命令行所有参数，$*将命令行所有参数作为一个整体进行处理，在遍历时循环只执行一次</td></tr><tr><td>$@</td><td>代表命令行所有参数，$@会将参数依次拆开</td></tr><tr><td>$#</td><td>代表传递到脚本的参数总个数</td></tr><tr><td>$?</td><td>返回上一个命令的执行状态，如果返回0则说明执行正确，返回值非0则说明上一个命令执行不正确，用于检测上一个命令是否正确执行，方便后续处理</td></tr><tr><td>$$</td><td>脚本运行当前进程的进程号(PID)</td></tr><tr><td>$!</td><td>后台运行最后一个进程的进程号(PID)</td></tr><tr><td>$-</td><td>显示shell所使用的当前设置(如：是否使用监视模式，是否只读取指令，而不实际执行)，与set命令功能相同</td></tr></tbody></table></div><div class="show">定义一个test.sh脚本<code>#! /bin/bashecho $1   #输出10echo $*   #将参数 10 20作为一个整体输出echo $@   #将参数依次处理为10和20两个参数输出echo $#   #输出参数个数</code>执行该脚本并传参chmod 755 test.sh./test.sh 10 20</div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>在使用$1、$2..调用参数之前，应当使用-n等命令测试用户是否传递了参数，如果直接调用了参数，而用户忘记传参，则脚本可能出现严重错误，示例：<div class="apiBox">if [ -n "$1" ]then   #正常执行功能else   echo "请输入参数"fi</div></div><div class="show">$*和$@的区别<code>for i in "$*";do   echo $idonefor i in "$@";do   echo $idone</code>执行 ./test.sh 1 2 3第一个语句相当于传递了1个参数，输出1 2 3第二个语句相当于传递了3个参数，输出123</div><h5 id="0参数的使用"><a href="#0参数的使用" class="headerlink" title="$0参数的使用"></a>$0参数的使用</h5><p>$0参数用于获取shell在命令行启动的脚本名，如果调用脚本时包含了路径，该参数会获取完整的脚本路径</p><div class="show">执行命令./test.sh则 $0=./test.sh执行命令 bash /home/myshell/test.sh则 $0=/home/myshell/test.sh</div><p>如果不想获取文件路径，而只需要脚本名，则可以结合<span class="tips">basename</span>命令来剥离脚本名</p><div class="show">name=$(basename $0)echo $name# 执行命令 /home/myshell/test.sh输出值为test.sh</div><p>基于该方法，可以写一个脚本，当用户输入不同的命令(不同脚本名)，实现不同功能，但它们本质上是同一个脚本</p><div class="show">e.g.执行addem 10 20命令返回10+20，执行multem 10 20返回10*20#!/bin/bash name=$(basename $0) if [ $name = "addem" ] then  total=$[ $1 + $2 ] elif [ $name = "multem" ] then  total=$[ $1 * $2 ] fi echo echo 最后计算结果为： $total# 将该文件命名为addem，然后执行ln -s addem multem为该文件创建一个软链接，执行任何一个脚本名都会执行同一个脚本，脚本随后根据$0参数识别对应的命令</div><h4 id="移动参数shift"><a href="#移动参数shift" class="headerlink" title="移动参数shift"></a>移动参数shift</h4><p>bash shell的<span class="strong">shift</span>命令能够用来操作命令行参数，在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也就是程序名，不会改变）</p><p>在不知道到底有多少参数时，可以先处理$1参数，然后用该命令依次移动参数，然后继续操作第一个参数，由此实现了对参数的遍历。但注意，如果某个参数被移出，它的值就被丢弃了，无法再恢复。shift也支持一次移动多个数据，只需要指定一个参数即可：<span class="strong">shift 参数</span>，因此，shift也常用来跳过不需要的参数</p><div class="show">#!/bin/bash echo "The original parameters: $*" shift 2 echo "Here's the new first parameter: $1"</div><h3 id="脚本选项"><a href="#脚本选项" class="headerlink" title="脚本选项"></a>脚本选项</h3><p>除了参数，绝大部分命令还会带有选项，如：ls -alh中的alh，同样，编写的shell脚本如果需要选项来加持命令的功能，则需要在脚本中对选项进行处理</p><h4 id="选项与参数分割符"><a href="#选项与参数分割符" class="headerlink" title="选项与参数分割符"></a>选项与参数分割符</h4><p>在Linux中，有些命令同时包含了参数和选项，为了方便将二者区分开来，Linux使用一个特殊标记符：双短线<span class="tips strong">-&zwnj;-</span>表示选项列表结束，参数列表开始。该符号可以用于提醒命令和脚本，-&zwnj;-符号后的都为命令(脚本)参数，该符号主要有两个使用场景：</p><ul><li>选项输入结束，参数输入开始。如：test -a -b -c -&zwnj;- value1 data2;使用-&zwnj;-可以很清晰的划分出命令选项和参数的界限</li><li>如果参数中包含-号，可能会被解析为选项，此时使用-&zwnj;-分割可以防止参数被解析错误。如：创建名为-rTest的文件，如果使用touch -rTest会将-r解析为选项，因而返回错误，而执行 touch -&zwnj;- -rTest可成功创建该文件</li></ul><h4 id="简单选项处理"><a href="#简单选项处理" class="headerlink" title="简单选项处理"></a>简单选项处理</h4><p>表面上看，命令行选项紧跟在脚本名之后，就跟命令行参数一样。因此对于简单的选项，可以像处理命令行参数一样处理命令行选项</p><div class="show">#!/bin/bash while [ -n "$1" ] do  case "$1" in  -a) echo #添加-a的脚本功能 ;;  -b) echo #添加-b的脚本功能 ;;  -c) echo #添加-c的脚本功能;;  *) echo "无 ${1} 该选项" ;;  esac  shift #移动参数，依次处理done</div><p>如果选项中同时含有选项和参数，可以使用-&zwnj;-符号分隔</p><div class="show">该方法适合类似./test.sh -c -a -b -- data1 data2 选项和参数分开的情况#!/bin/bash # extracting options and parameters echo while [ -n "$1" ] do  case "$1" in  -a) echo 这是一个选项;;  -b) echo 这是一个选项;;  -c) echo 这是一个选项;;  --) shift  break ;; #选项结束，退出循环 *) echo "$1 is not an option";;  esac  shift done # count=1 for param in $@ do  echo "Parameter #$count: $param"  count=$[ $count + 1 ] done</div><p>当选项和参数混合时，需要对选项做进一步处理</p><div class="show"> 处理./testing.sh -a data1 -b -c -d data2此类参数和选项混合的情况while [ -n "$1" ] do  case "$1" in  -a) echo "Found the -a option";;  -b) param="$2"  echo "Found the -b option, with parameter value $param"  shift ;;  -c) echo "Found the -c option";;  --) shift  break ;;  *) echo "$1 is not an option";;  esac  shift done # count=1 for param in "$@" do  echo "Parameter #$count: $param"  count=$[ $count + 1 ] done</div><h4 id="getopt与getopts命令"><a href="#getopt与getopts命令" class="headerlink" title="getopt与getopts命令"></a>getopt与getopts命令</h4><p>上述方法不太方便处理选项合并输入等情况(如：-alh)，事实上Linux提供了专门用于处理选项输入的命令——getopt，而bash也提供了更高级的内建命令——getopts</p><h5 id="getopt命令"><a href="#getopt命令" class="headerlink" title="getopt命令"></a>getopt命令</h5><p>getopt命令用于解析命令行参数和选项，其命令格式为</p><p><span class="strong">getopt [选项] 解析的选项 需要解析的参数表列</span></p><p>getopt命令的选项有：</p><ul><li>-o 单个字符：指定命令短选项的字符串(如：-v)，表示脚本支持的短选项(单个字符选项)</li><li>-&zwnj;-long 字符串1,字符串2…：指定命令长选项的字符串(如：-&zwnj;-version)，表示脚本支持的长选项(多字符选项)</li><li>-n 替代字符串：指定一个名字来代替默认命令名称”getopt”</li><li>-q：不生成错误信息(用户输入了指定选项之外的字符时)</li><li>-s chars：指定分隔选项参数的字符集，通常用于指定选项和其参数之间的分隔符，默认是空格。</li><li>-l：输出选项的字符串表示形式。</li><li>-options：将选项和非选项分开，选项在参数列表的前面，非选项在参数列表的后面</li></ul><p>指定命令解析的选项指该命令有效的选项字母，并指定选项需不需要参数值，如果需要则在选项后加上<span class="tips">:</span>号，随后getopt命令会根据指定的选项，解析getopt命令最后跟随的参数</p><div class="show">e.g.该命令的用法解析<code>getopt ab:cd  -a -b test1 -cde test2 test3</code>该命令中，getopt命令定义了四个有效选项字母：a、b、c和d。字母b后有一个冒号(:)，表示b选项需要一个参数值。当getopt命令运行时，它会检查提供的参数列表（-a -b test1 -cde test2 test3），并基于提供的optstring进行解析。注意，它会自动将-cde选项分成三个单独的选项，并插入双破折线(--)来分隔行中的选项和参数，因此，输入的参数会被解析为以下形式： -a -b 'test1' -c -d -e -- 'test2' 'test3'但由于getopt命令只指定了abcd四个有效选项，而用户输入了选项e，因此默认情况下，getopt命令会产生一条错误消息：getopt: invalid option -- e此时，可以添加为getopt命令添加-q选项来忽略错误消息： getopt -q ab:cd -a -b test1 -cde test2 test3</div><p>shell脚本中使用getopt命令，可以搭配set命令使用，set命令可以将其接收的参数按空格分割，并赋值给位置参数，可以将getopt解析出来的值作为set命令的输入参数，此后就可以使用$位置值的方式调用getopt命令解析出来的值</p><div class="show">e.g.写一个名为testGetopt.sh脚本，脚本需要支持输入选项：-a选项和-b选项(完整选项名为-aaa和-bbb)，这两个选项需要提供一个参数，选项-c、-ccc、-d不需要提供参数，可以提供任意数量的参数在脚本中调用分析： a:b:cd -&zwnj;-long aaa:,bbb:,ccc为解析的选项 $@为用户输入到该脚本中的参数，也是getopt命令需要解析的参数表列 通过-&zwnj;-分隔getopt命令的选项和参数部分，更为清晰 如果用户执行: bash getoptPra.sh -a 100 -b 200 -cd --ccc lua ajax 则该命令被getopt命令解析后，$args的值为： -a '100' -b '200' -c -d --ccc -- 'lua' 'ajax' getopt命令帮我们分割好了选项和参数，此时将该串字符串作为set命令的参数输入，set命令会以空格为分隔符，将该串字符串分割并依次存储在$1、$2、$3等位置变量中，方便后续依次判断和调用通过case命令和shift命令依次为各选项写功能，选项处理完毕，最后的剩余的参数另作处理执行</div><pre><code>#! /bin/bash# 对用户输入的选项和参数进行处理  args=$(getopt -o a:b:cd --long aaa:,bbb:,ccc -- $@)  if [ $? -ne 0 ]      then         echo"解析错误"        exit 1   fi# 查看getopt命令解析出来的选项和参数 echo "---------" echo $args echo "---------" set -- $args# 遍历所有选项，给与不同的功能 while true   do    case $1 in      -a|--aaa) echo "输入了-a或-aaa选项,参数值为$2" ; shift 2 ;;      -b|--bbb) echo "输入了-b或-bbb选项,参数值为$2" ; shift 2 ;;      -c)       echo "输入了-c选项" ; shift ;;      -d)      echo "输入了-d选项" ; shift ;;      --ccc)    echo "输入了--ccc长选项" ; shift; break ;;      --)       shift; break ;;    esac   done# 选项外的参数另作处理 echo "额外的输入参数有：$@"</code></pre><h5 id="getopts命令"><a href="#getopts命令" class="headerlink" title="getopts命令"></a>getopts命令</h5><p>getopts命令是bash shell的内建命令，为了弥补getopt命令的不足(如：不好处理带空格和引号的参数)，它提供了一些高级功能。</p><p>getopts命令与getopt命令不同，每次调用getopts命令，它只处理命令行上检测到的一个参数，因此往往需要循环调用，处理完所有的参数后，它会退出并返回一个大于0的退出状态码。getopts命令的格式与getopt命令相似：</p><div class="apiBox">getopts 解析的选项 变量</div><p>同样，解析选项中可以指定命令需要识别的有效字母选项，如果该选项需要参数，就加一个冒号。如果需要getopts命令忽略错误信息，可以在整个解析选项字符串前加个冒号，相当于getopt命令的-q选项。getopts命令会将输入的参数表列保存在指定的变量中，方便遍历。</p><div class="show">e.g.脚本支持选项abc，其中-b选项需要跟随一个参数。getopts :ab:c opt# ab:c前的:表示让getopts命令忽略错误(如：用户输入abc以外的选项)</div><p>getopts命令还预定义了两个环境变量：如果选项需要跟随一个参数值，<span class="tips">OPTARG</span>环境变量会保存该值，而变量<span class="tips">OPTIND</span>变量保存了参数列表中getopts正在处理的参数位置。</p><p>getopts命令有以下特点：</p><ul><li>该命令不直接支持长选项，但处理单字母选项很方便</li><li>解析命令行选项时该命令会移除开头的单破折线，所以在case定义中不用单破折线</li><li>该命令支持在参数值中包含空格，只需要将带空格的参数值用双引号包裹即可</li><li>可以将选项字母和参数值放在一起使用，而不用加空格，如：-abvalue，命令可以根据case定义的字符正确解析出-a和-b选项，以及value参数值</li></ul><div class="show">e.g.脚本需要支持-a、-b、-c命令，选项ab需要输入参数#!/bin/bashwhile getopts ":a:b:c" opt; do    case $opt in        a) echo "输入了选项-a，其参数值为$OPTARG" ;;        b) echo "输入了选项-b" ;;        c) echo "输入了选项-c" ;;        *) echo "未定义的选项" ;;    esacdone#使用shift命令和OPTIND变量处理剩余的参数shift $[ $OPTIND - 1 ]echo "剩余的参数："for param in $@ do    echo $paramdone</div><h4 id="选项标准化"><a href="#选项标准化" class="headerlink" title="选项标准化"></a>选项标准化</h4><p>部分选项在Linux中有一些墨守成规的用途，遵守这些规定会让脚本看起来更友好一些</p><div class="table"><table><thead><tr><th>选项</th><th>说明</th><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有对象</td><td>-n</td><td>使用非交互模式（批处理）</td></tr><tr><td>-c</td><td>生成一个计数</td><td>-o</td><td>将所有输出重定向到的指定的输出文件</td></tr><tr><td>-d</td><td>指定一个目录</td><td>-q</td><td>以安静模式运行</td></tr><tr><td>-e</td><td>扩展一个对象</td><td>-r</td><td>递归地处理目录和文件</td></tr><tr><td>-f</td><td>指定读入数据的文件</td><td>-s</td><td>以安静模式运行</td></tr><tr><td>-h</td><td>显示命令的帮助信息</td><td>-v</td><td>生成详细输出</td></tr><tr><td>-i</td><td>忽略文本大小写</td><td>-x</td><td>排除某个对象</td></tr><tr><td>-l</td><td>产生输出的长格式版本</td><td>-y</td><td>对所有问题回答yes</td></tr></tbody></table></div><h3 id="数值声明与数值运算"><a href="#数值声明与数值运算" class="headerlink" title="数值声明与数值运算"></a>数值声明与数值运算</h3><p>默认情况下，Bash中的变量会被声明为字符串类型，如：num=22，Bash会将22作为字符串处理，诸如11+22的式子也会被识别为字符串，想要进行数值运算，需要使用特殊声明语句和运算方式</p><h4 id="数值声明"><a href="#数值声明" class="headerlink" title="数值声明"></a>数值声明</h4><p>该语句用于特殊声明变量类型，使变量不再只限于字符串类型<br><span class="strong">declare [+或-] [选项] 变量名</span></p><ul><li>-&emsp;给变量设置类型属性</li><li>+&emsp;取消变量的类型属性</li><li>-i&emsp;将变量声明为整形(integer)</li><li>-x&emsp;将变量声明为环境变量</li><li>-p&emsp;查看变量的类型</li></ul><div class="show">declare -i num1=11+22</div><h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><p>进行数值运算可以使用以下几种方式：</p><h5 id="1-通过”-”或”-”运算式"><a href="#1-通过”-”或”-”运算式" class="headerlink" title="1.通过”$(())”或”$[]”运算式"></a>1.通过”$(())”或”$[]”运算式</h5><ul><li><span class="strong">变量名=$((运算式))</span></li><li><span class="strong">变量名=$[运算式]</span></li></ul><div class="shell">示例：[root@localhost ~]# num1=$((11+22))[root@localhost ~]# num2=$[11+22]</div><h5 id="2-通过declare-i声明"><a href="#2-通过declare-i声明" class="headerlink" title="2.通过declare -i声明"></a>2.通过declare -i声明</h5><p><span class="strong">declare -i 变量名</span></p><div class="shell">示例：[root@localhost ~]# declare -i num1=11+22</div><h4 id="浮点数运算的解决方案"><a href="#浮点数运算的解决方案" class="headerlink" title="浮点数运算的解决方案"></a>浮点数运算的解决方案</h4><p>z shell提供了完整的浮点数运算操作，但在bash shell中，需要借助内建的bash运算器——<span class="strong">bc</span></p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="用户输入read"><a href="#用户输入read" class="headerlink" title="用户输入read"></a>用户输入read</h4><p><span class="strong">read [选项] [变量名]</span> 从键盘(默认)读取一行数据，然后将输入的数据分解成字段，并将字段分别赋值给这些变量</p><ul><li>-p “提示信息” &emsp;输出提示信息(prompt 提示)</li><li>-t 秒数 &emsp;read命令只等待指定时间(timeout 超时)，如果超时未输入，read命令会以非零状态码退出</li><li>-n 字符数&emsp;read命令只接收指定数量字符</li><li>-s &emsp;隐藏输入的内容(silent 沉默)</li><li>-i 文本&emsp;将指定文本作为默认输入值</li><li>-a 数组名&emsp;将输入的数据赋值给数组变量</li><li>-d 字符&emsp;指定一个定界符，当入户输入该字符时，read命令将停止读取输入(delimit 划定界限)</li><li>-e&emsp;允许用户使用Readline功能，该功能允许用户使用快捷键进行快速操作(如快速跳转到本行开头)</li><li>-r&emsp;禁用转义，\不再会被解析为转义字符</li><li>-u 文件描述符&emsp;从指定的文件描述符中读取，如标准输入设备的文件描述符为0</li><li>-c&emsp;在读取输入时不需要按回车确认，即实时输入</li><li>如果在命令中不指定变量，则read读入的数据会保存在环境变量<span class="tips">REPLY</span>中</li></ul><div class="shell">示例：#!/bin/bashread -t 30 -p "input name:" name    #30s内输入姓名并赋值给nameread -s -t 30 -p "input password:" passwd    #30s内隐藏输入密码并赋值给passwd</div><p>read也支持一次输入多个数据，数据之间用空格隔开，然后赋值给多个变量。如果输入的数据个数多于变量个数，则多出来的数据连同空格会被赋值给最后一个变量。read命令也支持将多个数据直接存入数组中，如果数据间的分隔符是,或者其他符号，也可以通过<span class="tips">IFS</span>变量修改分隔符(Linux中分隔符默认为空格、制表符、换行符)，方便从文件中读入数据并作处理</p><div class="show">1. 可以一次读取多个数据read data1 data2 输入10 20 30，则data1=001，data2=20 30，空格会视为第一个数据输入完毕,多余数据赋值给最后一个变量2. 对于使用其他符号分隔的数据，可以重新定义分隔符read -p "输入数据，以逗号隔开" dataecho "当前数据" $dataIFS=','  #修改IFS变量的值，将分隔符改为,号read -a data_array <<< $dataecho "处理完的数组为：" ${data_array[@]}3. read命令可以从文件中读取数据，每次调用read命令，都将从文件中读取一行文本，当文件中没有内容时，read命令会退出并返回非零状态码。读取文件时，可以借助cat命令和管道符cat test.txt | while read content do   echo $content #内容被保存到content变量中done</div><h4 id="终端输出"><a href="#终端输出" class="headerlink" title="终端输出"></a>终端输出</h4><p><span class="strong">echo [选项] [输出内容]</span> 用于向终端输出文本信息</p><ul><li>-e&emsp;启用转义字符\，可以输出如换行符(\n)、制表符(\t)等，也可以修改输出文字的样式</li><li>-E&emsp;禁用转义字符，原样输出文本</li><li>-n&emsp;不换行输出文本，输出完毕后光标停留在同一行</li></ul><div class="show">1. echo输出字符串文本时默认情况下可以不需要引号echo Hello World2. 但如果字符串中有单引号/双引号，则字符串需要使用另外一种引号包裹(字符里有单引号，就用双引号包裹，反之亦然)echo 'he said:"One day you will leave.."' #单引号用于划定字符串，不会输出显示3. echo也可以一次性输出多个变量，变量间用空格分隔echo "当前值为：" $num1 $num2 #输出文本后输出变量num1和num2</div><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><h4 id="文件描述符与标准输入输出设备"><a href="#文件描述符与标准输入输出设备" class="headerlink" title="文件描述符与标准输入输出设备"></a>文件描述符与标准输入输出设备</h4><p>Linux系统将每个对象当作文件处理，并使用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，bash shell保留了前三个文件描述符(0、1和2)作为标准输入、标准输出、标准错误输出的文件描述符，每个进程一次最多可以有九个文件描述符。</p><div class="table"><table><thead><tr><th>设备</th><th>Linux文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>/dev/stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>/dev/stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>/dev/stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table></div><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><p>一般情况下，Linux输出信息时默认的输出位置为屏幕，可以用重定向符将命令的输出重定向到文件等地方，而不再显示到屏幕上。如果重定向位置为文件而该文件不存在，则会新建文件</p><div class="table"><table><thead><tr><th>类型</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td rowspan="2">标准输出重定向</td><td>&gt;</td><td>以覆盖方式将正确命令返回内容输出到指定文件或设备中</td></tr><tr><td>&gt;&gt;</td><td>以追加方式将正确命令返回内容输出到指定文件或设备中</td></tr><tr><td rowspan="2">标准错误输出重定向</td><td>2&gt;</td><td>以覆盖方式将错误命令返回内容输出到指定文件或设备中</td></tr><tr><td>2&gt;&gt;</td><td>以追加方式将错误命令返回内容输出到指定文件或设备中</td></tr>      <tr>      <td rowspan="5">同时输出正确和错误命令返回信息</td>      <td>&&gt;</td>      <td>以覆盖方式，把正确和错误返回信息保存到同一文件中(Bash特有简写，也可以写为&gt;&)</td>      </tr>      <tr>         <td>&&gt;&gt;</td>         <td>以追加方式，把正确和错误返回信息保存到同一文件中(Bash特有简写)</td>      </tr>      <tr>         <td>cmd&gt;file 2&gt;&1</td>         <td>以覆盖方式，把正确和错误返回信息保存到同一文件中(POSIX标准写法，兼容性强)</td>      </tr>      <tr>         <td>cmd&gt;&gt;file 2&gt;&1</td>         <td>以追加方式，把正确和错误返回信息保存到同一文件中(POSIX标准写法，兼容性强)</td>      </tr>      <tr>         <td>cmd&gt;&gt;file1 2&gt;&gt;file2</td>         <td>把正确命令返回信息追加到文件1中，错误命令返回信息追加到文件2中</td>      </tr>      <tr><td>在脚本中输出错误消息(输出到stderr)</td>      <td>&gt;&2</td>      <td>在脚本中自定义一个消息作为错误输出</td></tr>      <tr><td rowspan="2">批量重定向</td>      <td>exec 1&gt;</td>      <td>将脚本执行期间所有标准输出重定向到指定位置</td></tr>      <tr><td>exec 2&gt;</td>      <td>将脚本执行期间所有错误输出重定向到指定位置</td></tr></tr>   </tbody></table></div><h5 id="1-标准输出与标准错误输出的重定向"><a href="#1-标准输出与标准错误输出的重定向" class="headerlink" title="1.标准输出与标准错误输出的重定向"></a>1.标准输出与标准错误输出的重定向</h5><p>标准输出是指程序执行正确时，会向用户输出普通信息流(如：程序的执行结果、信息或数据等)。标准错误输出则用来显示错误信息，当程序遇到错误或异常时，它会将错误信息发送到标准错误输出流。默认情况下，标准输出和标准错误输出的输出位置都为屏幕，但可以使用重定向命令将程序的正确执行结果或错误执行结果输出到屏幕以外的地方。</p><p>单独输出正确信息时，可以在重定向符中省略文件描述符1，但如果同时重定向了标准输出和标准错误输出，则需要加上文件描述符</p><div class="show">1. 输出命令正确执行信息到文件中eg:将/usr/bin目录文件信息保存到以log.日期为文件名的日志文件中，%y%m%d表示提取日期中两位数的年月日，如：log.240522today=$(date +%y%m%d)ls /usr/bin -al <span class="text-red">&gt; log.$today </span>2. 输出命令错误执行信息到文件中e.g.文件test不存在时ls -al test.txt <span class="text-red">2&gt; fail.log</span>3. 将正确信息和错误信息输出到不同文件时，需要明确添加文件描述符ls -a test1 test2 <span class="text-red"> 1&gt;success.log 2&gt;fail.log</span>4. 将正确信息和错误信息输出到同一文件ls -a test1 test2 <span class="text-red">&&gt; message.log </span></div><h5 id="2-输出错误信息"><a href="#2-输出错误信息" class="headerlink" title="2.输出错误信息"></a>2.输出错误信息</h5><p>如果需要在脚本中输出错误信息，则可以将输出信息重定向到STDERR文件描述符，语法为：<span class="tips">输出信息 &gt;&amp;2</span>。在终端中输出语句时看起来和正常echo语句无区别，但对系统而言明确了这是一个错误输出信息</p><div class="show">e.g.在脚本中输出一个错误消息echo "程序抛出一个异常" <span class="text-red"> &gt;&2</span></div><h4 id="输入重定向-不常用"><a href="#输入重定向-不常用" class="headerlink" title="输入重定向(不常用)"></a>输入重定向(不常用)</h4><p>将文件等内容重定向到命令，下列命令省略了文件描述符0</p><div class="table"><table><thead><tr><th>类型</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>输入重定向</td><td>n&lt;</td><td>从文件描述符n输入，n默认为0，n为0时可以省略</td></tr><tr><td>标准输入重定向</td><td>&lt;</td><td>将文件或设备内容重定向到命令</td></tr><tr><td>内联输入重定向</td><td>&lt;&lt;</td><td>在命令行中指定多个文本输入内容</td></tr></tbody></table></div><p>如：使用wc命令统计文件中的字符</p><div class="show"># wc < test统计输出test文件内容的行数、单词数、字节数</div><p>内联输入重定向(inline input redirection)用于从命令行输入多行数据。在使用时，必须指定一个文本用于标记输入数据的开始和结尾，完整的语法为：</p><div class="apiBox">命令 &lt;&lt; 标记文本输入的数据...标记文本</div>可以添加选项<span class="text-red">-</span>让shell忽略所输入字符串开头的制表符<div class="show">1.输入多行文本给命令wc &lt;&lt; EOF  #指定标记文本，开始输入&gt;This is line1&gt;This is line2&gt; EOF #遇到标记文本，终止输入2.当输入文本开头有制表符时，可以添加-选项来让shell忽略制表符wc &lt;&lt;- EOF  #指定标记文本，开始输入&gt;     This is line1&gt;     This is line2&gt; EOF #遇到标记文本，终止输入</div><h4 id="批量重定向"><a href="#批量重定向" class="headerlink" title="批量重定向"></a>批量重定向</h4><p>当脚本中有大量信息需要重定向，如果为每个命令都进行一次重定向过于繁琐，此时可以搭配<span class="tips">exec</span>命令指定shell将脚本执行期间的信息都重定向到某个位置。exec会替换当前shell的执行上下文环境，将标准输出输入和错误输出重定向到指定位置</p><div class="show"><span class="strong">重定向输出</span>1. 将所有的标准输出重定向后，依旧可以指定将某个语句输出到指定位置e.g.将所有命令执行正确的信息输出到文件out.txt，而将部分指定的错误消息输出到屏幕exec 1&gt;out.txtecho "正常输出到out.txt文件"echo "将该错误输出显示到屏幕" &gt;&22. 也可以将标准输出、标准错误输出都完全重定向exec 1&gt;out.txtexec 2&gt;error.txtecho "输出到out.txt"echo "输出到error.txt" &gt;&2ls -a test.txt  #若test文件存在，输出信息到out，若不存在，输出到error<span class="strong">输入重定向</span>1. 将标准输入重定向到文件后，read等命令将从文件中读取数据exec 0&gt; test.txtwhile read datado  echo $datadone</div><h4 id="丢弃命令输出"><a href="#丢弃命令输出" class="headerlink" title="丢弃命令输出"></a>丢弃命令输出</h4><p>如果需要某个输出既不显示到屏幕上，也不保存到文件中，可以将其重定向到一个名为<span class="tips">null</span>的特殊文件中。Linux中该文件的位于<span class="tips">/dev/null</span>路径下，所有重定向到该文件中的数据都会被丢弃，该文件中无任何内容。因此也可以在输入重定向中将其作为输入文件，可以用来快速清空文件内容，将该文件变为空白文件，常用于日志文件中清除内容(也可以删除再创建)</p><div class="show">1. 丢弃信息ls -al test.txt &gt; /dev/nullls -al test.txt 2&gt; /dev/null2.快速清空文件cat /dev/null &gt; test.txt</div><h4 id="自定义重定向"><a href="#自定义重定向" class="headerlink" title="自定义重定向"></a>自定义重定向</h4><p>在shell中最多可以有9个打开的文件描述符。除了标准输入0，标准输出1和标准错误输出2，其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们</p><h5 id="创建文件描述符"><a href="#创建文件描述符" class="headerlink" title="创建文件描述符"></a>创建文件描述符</h5><p>可以直接使用<span class="tips">exec</span>命令直接给输入、输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件<br>描述符分配给一个文件，这个重定向就会一直有效，直到其被重新分配。</p><div class="show">e.g.分配一个文件描述符3，并重定向到test3文件#!/bin/bashexec 3&gt;&gt;test3 echo "正常输出到屏幕" echo "将被追加到文件test3" &gt;&3 </div><h5 id="重定向文件描述符"><a href="#重定向文件描述符" class="headerlink" title="重定向文件描述符"></a>重定向文件描述符</h5><div class="table"><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>n&gt;file</td><td>以覆盖方式，将文件描述符n重定向到文件file</td></tr><tr><td>n&gt;&gt;file</td><td>以追加方式，将文件描述符n重定向到文件file</td></tr><tr><td>n&gt;&amp;-</td><td>关闭文件描述符n</td></tr><tr><td>n&gt;&amp;m</td><td>将n的输出合并到m</td></tr><tr><td>n&gt;&amp;m-</td><td>移动文件描述符，将n重定向到m，然后关闭m</td></tr><tr><td>&lt;n</td><td>从n输入</td></tr><tr><td>m&lt;&amp;n</td><td>将n的输入与m合并</td></tr><tr><td>n&lt;&amp;m</td><td>复制文件描述符，将文件描述符m复制到n，对n读取等同于对m读取</td></tr><tr><td>n&lt;&amp;m-</td><td>移动文件描述符，将文件描述符m移动到n，随后关闭m</td></tr><tr><td>n&lt;&gt;file</td><td>允许通过n同时对文件进行读操作和写操作</td></tr></tbody></table></div><div class="show">1. 以下两个语句等价，只是标准输出和标准错误输出的写入顺序不同# 先写入标准输出信息，再先入错误信息ls &gt;&gt;file 2&gt;&gt;&1# 先写入错误信息，再先入标准输出信息ls 2&gt;&gt;file 1&gt;&gt;&22. 移动输出文件描述符# 打开文件描述符3指向 output.txtexec 3>output.txt # 将文件描述符4重定向到3，然后关闭文件描述符3，之后只能通过4来写入output.txtexec 4>&3-         </div><h5 id="恢复文件描述符的指向"><a href="#恢复文件描述符的指向" class="headerlink" title="恢复文件描述符的指向"></a>恢复文件描述符的指向</h5><p>通过exec命令重定向的文件描述符会在整个脚本运行期间指向指定的位置，如果需要将其恢复到原来的指向位置，可以创建一个文件描述符作为一个缓存变量，并在代码功能执行完后将需要恢复的文件描述符重定向到新建的文件描述符</p><div class="show">e.g.恢复标准输出的指向#!/bin/bash<span class="text-blue">exec 3&gt;&1</span><span class="text-blue">exec 1&gt;out.txt</span>echo "输出内容到out.txt"<span class="text-blue">exec 1&gt;&3</span></div><div class="show">e.g.标准输入也类似#!/bin/bash <span class="text-red">exec 6<&0 </span><span class="text-red">exec 0< testfile</span>count=1 while read line do  echo "Line #$count: $line"  count=$[ $count + 1 ] done <span class="text-red">exec 0<&6</span></div><h5 id="同时读写的文件描述符-了解"><a href="#同时读写的文件描述符-了解" class="headerlink" title="同时读写的文件描述符(了解)"></a>同时读写的文件描述符(了解)</h5><p>shell也支持打开单个文件描述符来作为输入和输出，即可以用同<br>一个文件描述符对同一个文件进行读写。shell会维护一个内部指针，指明在文件中的当前位置，任何读或写都会从文件指针上次的位置开始，因此可能出现内容被错误读写的问题，不太好用</p><div class="show">#!/bin/bash exec 3&lt;&gt; testfile read line &lt;&3 echo "Read: $line" echo "This is a test line" &gt;&3</div><h5 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h5><p>shell会在脚本退出时自动关闭文件描述符，若要手动关闭文件描述符，则需要将该文件描述符重定向到特殊符号<span class="tips">&amp;-</span>，文件描述符关闭后，如果输出数据shell将抛出错误</p><div class="show">e.g.关闭文件描述符3#!/bin/bash exec 3&gt; test.txtecho "输出数据到test文件" &gt;&3 <span class="text-red">exec 3&gt;&-</span></div><h4 id="列出打开的文件描述符"><a href="#列出打开的文件描述符" class="headerlink" title="列出打开的文件描述符"></a>列出打开的文件描述符</h4><p>lsof命令会列出整个Linux系统打开的所有文件描述符。由于该命令会向非系统管理员用户提供Linux系统的信息，因此在很多Linux发行版中隐藏了该命令。普通用户要想运行该命令，必须使用全路径来引用该命令：<span class="strong">/usr/sbin/lsof</span></p><p>管理员用户可以直接使用：</p><div class="apiBox">lsof [选项]</div><ul><li>-p PID：指定对应进程PID所打开的文件描述符</li><li>-d 值：指定需要显示的文件描述符编号</li><li>-a 对上述两个选项结果进行布尔AND运算</li></ul><div class="show">可以结合环境变量$$(当前shell的PID)来查看当前shell进程打开的文件描述符/usr/sbin/lsof -a -p $$ -d 0,1,2</div><p>该命令返回信息包括：</p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>COMMAND</td><td>正在运行的命令名的前9个字符</td></tr><tr><td>PID</td><td>进程的PID</td></tr><tr><td>USER</td><td>进程属主的登录名</td></tr><tr><td>FD</td><td>文件描述符号以及访问类型（r代表读，w代表写，u代表读写）</td></tr><tr><td>TYPE</td><td>文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）</td></tr><tr><td>DEVICE</td><td>设备的设备号（主设备号和从设备号）</td></tr><tr><td>SIZE</td><td>如果有的话，表示文件的大小</td></tr><tr><td>NODE</td><td>本地文件的节点号</td></tr><tr><td>NAME</td><td>文件名</td></tr></tbody></table></div><p>返回值结果举例</p><div class="shell">COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME bash 3344 rich 0u CHR 136,0 2 /dev/pts/0 bash 3344 rich 1u CHR 136,0 2 /dev/pts/0 bash 3344 rich 2u CHR 136,0 2 /dev/pts/0</div><p>由于STDIN、STDOUT和STDERR文件描述符都指向终端，因此其文件类型是字符型，输出文件的名称就是终端的设备名，且所有3种标准文件都支持读和写。</p><h4 id="tee同时输出到显示器和文件"><a href="#tee同时输出到显示器和文件" class="headerlink" title="tee同时输出到显示器和文件"></a>tee同时输出到显示器和文件</h4><p>Linux提供了一个特殊命令<span class="tips">tee</span>，用于将输出同时发送到标准输出(显示器)和文件，而不用重定向多次：</p><div class="apiBox">tee [选项] 文件1 文件2...</div><ul><li>默认情况下，如果指定的文件不存在，则会新建该文件，如果文件存在，tee命令会覆盖原文件内容</li><li>-a 将数据追加到文件中</li><li>-i 忽略中断信号，例如通过 Ctrl+C 触发的信号</li></ul><p>tee命令会重定向STDIN输入的数据，并同时发往两处：STDOUT和tee命令指定的文件，因此可以搭配管道符使用。</p><div class="show">e.g.将某个数据同时发送到屏幕和test文件echo "数据" | tee test</div><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>在bash shell中，if 语句的判断依据为命令的退出状态码，不能像其他语言一样直接用 if 语句判断条件语句，但bash shell提供了两个用于条件判断的方法：</p><ul><li>test 命令</li><li>[  ] 使用中括号测试条件</li></ul><h4 id="test命令与"><a href="#test命令与" class="headerlink" title="test命令与[ ]"></a>test命令与[ ]</h4><p>test命令可用于做数值比较、字符串比较和文件比较，当test命令中列出的条件成立，test命令就会正常退出并返回退出状态码0，这样if等语句就可以正常工作了。此外，test命令有一种替代形式，可以直接将条件语句写于中括号[ ]中，注意，<span class="text-red">第一个中括号后和第二个中括号前都必须加上一个空格</span>，否则将报错。如果test命令后或者中括号中不写条件语句，则它们都将视为条件不成立，二者的语法类似：</p><ul><li><span class="strong">test 条件语句</span></li><li><span class="strong">[ 条件语句 ]</span></li></ul><div class="show">e.g.检测某个变量是否存在且不为空，提示：返回值在终端上可以用$?查看<code>str=""if test $str then    echo "该变量存在" else   echo "该变量不存在"fi</code>或<code>if [ $str ] #取变量值$str前后均有空格 then    echo "该变量存在" else   echo "该变量不存在"fi</code></div><h4 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h4><p>上述两个方法用于测试文件或目录是否满足相关要求时的语法为：</p><ul><li><span class="strong">test 选项 文件/目录名</span></li><li><span class="strong">[ 选项 文件/目录名 ]</span></li></ul><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-e file</td><td>判断file是否存在</td></tr><tr><td>-d file</td><td>判断file是否存在，且是否为目录</td></tr><tr><td>-f file</td><td>判断file是否存在，且是否为为文件</td></tr><tr><td>-b file</td><td>判断file是否存在，且是否为块设备文件(如：硬盘设备文件)</td></tr><tr><td>-c file</td><td>判断file是否存在，且是否为字符设备文件(如：鼠标、键盘设备文件)</td></tr><tr><td>-O file</td><td>判断file是否存在并属于当前用户所有</td></tr><tr><td>-G file</td><td>判断file是否存在并默认组与当前用户相同</td></tr><tr><td>-L file</td><td>判断file是否存在，且是否为链接文件</td></tr><tr><td>-p file</td><td>判断file是否存在，且是否为管道文件</td></tr><tr><td>-s file</td><td>判断file是否存在，且文件大小是否大于0(非空)，非空为true</td></tr><tr><td>-S file</td><td>判断是否为套接字文件</td></tr><tr><td>-N file</td><td>判断file是否存在，且文件在上一次读取之后被修改过(mtime比atime新)，则为true</td></tr></tbody></table></div><div class="show">e.g.在使用某个文件或目录之前，先检查其是否存在是一个好的编程习惯<code>location=$HOMEfile_name="myFile"if [ -e $location ]then  if [ -e $location/$file_name ]  then      echo "文件存在"      echo "写入数据"      date &gt;&gt; $location/$file_name   else      echo "文件不存在"   fielse   echo "目录不存在"fi</code></div><h5 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h5><p>检测读(写/执行)权限时，文件所有者、所属组、其他任意拥有读(写/执行)权限都将返回true</p><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-r file</td><td>判断file是否存在，且是否拥有读权限</td></tr><tr><td>-w file</td><td>判断file是否存在，且是否拥有写权限</td></tr><tr><td>-x file</td><td>判断file是否存在，且是否拥有执行权限</td></tr><tr><td>-u file</td><td>判断file是否存在，且是否拥有SUID权限</td></tr><tr><td>-g file</td><td>判断file是否存在，且是否拥有SGID权限</td></tr><tr><td>-k file</td><td>判断file是否存在，且是否拥有SBit权限</td></tr></tbody></table></div><h5 id="两个文件比较"><a href="#两个文件比较" class="headerlink" title="两个文件比较"></a>两个文件比较</h5><p>在比较文件之前，应该确认两个文件确实存在，或用脚本验证文件是否存在并作错误处理，否则比较操作可能会返回错误的结果。</p><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>文件1 -nt 文件2</td><td>判断文件1的修改时间是否比文件2新</td></tr><tr><td>文件1 -ot 文件2</td><td>判断文件1的修改时间是否比文件2旧</td></tr><tr><td>文件1 -ef 文件2</td><td>判断文件1和文件2的i节点(Inode)是否一致，即判断是否为同一文件，常用于判断是否为硬链接</td></tr></tbody></table></div><h4 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h4><p>bash shell只支持整数进行比较，这里的整数可以是变量，也可以是正值或负值常量</p><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>整数1 -eq 整数2</td><td>判断整数1与整数2是否相等</td></tr><tr><td>整数1 -ne 整数2</td><td>判断整数1与整数2是否不相等</td></tr><tr><td>整数1 -gt 整数2</td><td>判断整数1是否大于整数2</td></tr><tr><td>整数1 -lt 整数2</td><td>判断整数1是否小于整数2</td></tr><tr><td>整数1 -ge 整数2</td><td>判断整数1是否大于等于整数2</td></tr><tr><td>整数1 -le 整数2</td><td>判断整数1是否小于等于整数2</td></tr></tbody></table></div><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><p><span class="text-red">注意！以下比较符号=、!=、\&lt;、\&gt; 前后都需要有一个空格</span></p><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-z str</td><td>字符串str长度为0，则为true(字符串为空字符串，未定义的变量也视为空)</td></tr><tr><td>-n str</td><td>判断字符串str长度是否为非0(非空)</td></tr><tr><td>str1 = str2</td><td>判断str1和str2是否相等</td></tr><tr><td>str1 !=s tr2</td><td>判断str1和str2是否不相等</td></tr><tr><td>str1 \&lt; str2</td><td>判断str1是否比str2小(根据ASCII码)</td></tr><tr><td>str1 \&gt; str2</td><td>判断str1是否比str2大(根据ASCII码)</td></tr></tbody></table></div><p>在比较字符串是否比另外一个字符串小/大时，大于号和小于号需要进行转义，否则会当做重定向符号处理。在比较时，会依次判断字母在ASCII中的出现位置，因此大写字母会小于小写字母(sort命令使用的是系统的本地化语言设置中定义的排序顺序，小写字母出现顺序位于大写字母前，与之相反)</p><div class="show">e.g. 比较字符Test和test<code>str1="Test"str2="test"if [ str1 \\&lt; str2 ]  then    echo "Test小于test"  #由于ASCII中T小于t，所以输出该语句  else    echo "Test大于test"fi</code></div><h4 id="多重判断"><a href="#多重判断" class="headerlink" title="多重判断"></a>多重判断</h4><div class="table"><table><thead><th>测试选项 </th><th>作用</th></thead><tbody><tr><td>判断1 -a 判断2</td><td>逻辑与，判断1和判断2都成立，结果为真</td></tr><tr><td>判断1 -o 判断2</td><td>逻辑或，判断1和判断2任意一个成立，结果为真</td></tr><tr><td>! 判断 </td><td>结果取反</td></tr><tr><td>[ 判断1 ] && [ 判断2 ]</td><td>判断1和判断2都成立，结果为真</td></tr><tr><td>[ 判断1 ] || [ 判断2 ]</td><td>判断1和判断2任意一个成立，结果为真</td></tr></tbody></table></div><div class="show">e.g.判断a是否有值，并且判断a是否大于20，都成立输出 true，否则输出 false<code>a=10[ -n "$a" -a "$a" -gt 20] && echo "true" || echo "false"</code></div><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>其他语言中的if语句，会判断if语句后式子的求值结果，并根据结果的true或false值进行对应处理。但bash shell中的if语句有所不同，bash会执行if语句后的命令，如果该命令的退出状态码是0，则会执行then部分的代码体，如果该命令的退出状态码是其他值，则执行else语句(没有else则不执行)，if语句的语法为：</p><div class="show"><div class="apiBox"> if 命令行   then     程序体   fi</div></div><div class="show">e.g. 查询是否存在某个用户，如果存在则输出该用户的HOME目录<code>userName=shiwiviif grep $userName /etc/passwdthen   echo "找到该用户："   ls -a /home/$userName/.b*fi</code></div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>在部分脚本中，该语句会被写成<div class="apiBox">if 命令;then   程序体fi</div>形式，即如果then和if写于同一行，需要加上;号，这样它会与其他一些语言的语法类似，如果if和then不写在同一行上，则;号可要可不要</div><p>此外，bash shell也支持if-then-else语句和if嵌套语句，但注意，嵌套的if语句中的else-if被简化为了elif</p><div class="show"><span class="text-red">if-then-else语句：</span><div class="apiBox">if 命令       then            条件成立执行      else            条件不成立时执行   fi</div><span class="text-red">多分支if语句：</span><div class="apiBox">if 命令1       then            条件成立执行   elif 命令2      then            条件成立时执行   (.....)   else         上述所有条件不成立时执行   fi</div></div><h4 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h4><p>case语句类似于其他语言中的switch…case语句，用于匹配多个同类型的条件，其语法为：</p><div class="show"><div class="apiBox">case 变量 in   值1 | 值2)         程序1 ;;   值3)         程序2 ;;   .....   *)         上述条件都不满足，执行该程序;;esac</div></div><p>case中的条件可以使用或符号同时设置多个条件，最后的星号会捕获所有与已有条件不匹配的值，相当于switch语句中的default</p><div class="show">e.g.查询多个用户<code>case $USER inJayChou | EasonChan)      echo "歌手";;KenThompson)      echo "程序员";;*)      echo "未知用户";;esac</code></div><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a>for命令</h4><p>for语句遍历时，默认使用空格分割需要遍历的值，如果值本身包含空格，则需要使用双引号将值包裹，此时for语句不会将双引号作为值的一部分</p><div class="show"><div class="apiBox">for 变量 in 值1 值2 值3.....   do       程序   done</div></div>do可以和for语句放在同一行，只需要在值列表之后加上一个分号即可。<div class="show">1. for需要遍历的数据使用空格隔开for value in data1 data2 data3do   echo "数据依次为$value"done2. 如果数据中包含单引号等特殊字符，可以使用双引号包括数据，或使用转义符#使用转义符表示\'，或使用双引号包裹"this'll"for test in I don\'t know if "this'll" work do  echo "word:$test" done3. 数据中包含空格，也需要使用双引号包裹数据for test in Nevada "New Hampshire" "New Mexico" "New York" do  echo "Now going to $test" done4. for遍历的数据，可以是一个变量，也可以是一个命令的输出file="/myData/map" for state in $(cat $file) do  echo "Visit beautiful $state" done5. for也可以用来读取目录for file in /home/user1/test/*do   if [ -d "$file"]    #将file用双引号包裹，避免文件名中含有空格时产生错误   then      echo "这是一个目录"   elif [ -f "$file" ]   then      echo "这是一个文件"   fidone</div><p>此外，bash shell还支持一种C语言风格的for语句，但需要注意：</p><ul><li>使用双括号</li><li>变量不以美元符$</li><li>迭代过程的算式不需要用expr命令格式<div class="show"><div class="apiBox">for((初始值;条件;变量变化)) do   程序 done</div></div></li></ul><div class="show">e.g.这种形式的for语句也支持遍历多个变量for (( a=1, b=10; a <= 10; a++, b-- )) do  echo "$a 与 $b" done</div><h4 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a>while命令</h4><div class="show"><div class="apiBox"> whlie 命令      do         程序      done</div></div>注意：while命令允许在while语句行定义多个测试命令，只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。<div class="show">e.g.只有最后一个命令[ $num2 -ge 0 ]的退出状态码决定while语句何时结束num1=5num2=10while echo "-------"    [ $num1 -ge 0 ]    [ $num2 -ge 0 ]do    echo 这是第${num2}次循环    echo num1为${num1}，num2为${num2}    num1=$[ $num1 - 1 ]    num2=$[ $num2 - 1 ]done</div><h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h4><p>until命令和while命令工作的方式相反，until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。即：while命令在条件满足时执行，until命令在条件满足时退出。同样，until也像while一样允许多个测试命令，但只有最后一个命令有效</p><div class="apiBox">until 命令   do     程序   done</div><h4 id="break终止循环"><a href="#break终止循环" class="headerlink" title="break终止循环"></a>break终止循环</h4><p>break的用法与其他语言类似，即可以终止当前的循环，但bash shell提供了一个更高级功能，可以通过<span class="strong">break 值</span>的方式跳出多重循环(如果不指定值，默认为1)，如：在两层for语句嵌套中，break 2 可以直接停止外层for语句的循环</p><div class="show">e.g.当b为4时，终止2个for语句的循环for (( a = 1; a < 4; a++ )) do    echo "Outer loop: $a"     (( b = 1; b < 100; b++ ))    do    if [ $b -gt 4 ]    then    break 2 #终止外部for语句的循环，如果命令为break则只能终止内部循环   fi    echo " Inner loop: $b"  done done</div><h4 id="continue跳过循环"><a href="#continue跳过循环" class="headerlink" title="continue跳过循环"></a>continue跳过循环</h4><p>continue可以跳过本次循环，continue之后的命令将不再执行而开始下一次循环，与break类似，在多层循环中，bash shell中的continue提供跳过多层循环的功能，其语法为<span class="strong">continue 值</span>，值默认为1</p><div class="show">for (( var1 = 1; var1 < 15; var1++ )) do  if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]  then  continue #如果有多层for，可以指定一个值跳过外层的循环 fi  echo "Iteration number: $var1" done</div><h4 id="处理循环的输出"><a href="#处理循环的输出" class="headerlink" title="处理循环的输出"></a>处理循环的输出</h4><p>在shell脚本中，可以在done命令后添加管道符或重定向符来处理循环的输出</p><div class="show">e.g.将循环的语句"值为xx"写入到文件test.txt中而不显示到终端上，等循环语句写入完毕在终端上显示"数据写入完毕"提示语句for (( a = 1; a < 10; a++ )) do  echo "值为 $a" done > test.txt echo "数据写入完毕"</div><h3 id="字段分隔符"><a href="#字段分隔符" class="headerlink" title="字段分隔符"></a>字段分隔符</h3><p>环境变量IFS，称为内部字段分隔符（internal field separator）,用于定义bash shell内用作字段分隔的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：</p><ul><li>空格</li><li>制表符</li><li>换行符</li></ul><p>如果bash shell在数据中看到了这些字符中的任意一个，它就会假定这表明了列表中一个新数据字段的开始。在处理可能含有空格的数据（比如文件名）时，这会非常麻烦<br>要解决这个问题，可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段分隔符的字符。一般会在修改IFS值前保存原来的默认值，使用完后再恢复它</p><div class="show">e.g.文件file每一行保存了一个数据，且数据中可能包含空格和制表符，要使用for循环遍历这些数据，则需要先将IFS修改为换行符，使bash shell忽略空格和制表符，将每一行当作一个整体处理file="data" IFS.OLD=$IFS  #保存旧的IFS值 IFS=$'\n' for data in $(cat $file) do  echo "数据：$data" done IFS=$IFS.OLD  #恢复IFS值</div>如果要指定多个IFS字符，只要将它们在赋值行串起来就行。IFS=$'\n':;" 这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用IFS字符解析数据没有任何限制。<pre><code>#!/bin/bash # 提取/etc/passwd文件每个字段的内容IFS.OLD=$IFS IFS=$'\n' for entry in $(cat /etc/passwd) do  echo "当前用户整体信息：$entry"  IFS=:  for value in $entry  do  echo " $value"  done done</code></pre><h3 id="双括号命令"><a href="#双括号命令" class="headerlink" title="(())双括号命令"></a>(())双括号命令</h3><p>双括号命令(( ))在shell中用于进行数学运算和条件判断，并提供了更灵活和方便的方式来处理数值计算和逻辑操作</p><h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><p>双括号命令除了基本的数学运算外，还支持以下运算，且双括号中还支持使用变量</p><div class="table"><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>num++、++num</td><td>前置/后置的自增</td></tr><tr><td>num–、–num</td><td>前置/后置的自减</td></tr><tr><td>!</td><td>逻辑取反</td></tr><tr><td>~</td><td>按位取反</td></tr><tr><td>**</td><td>冥运算</td></tr><tr><td>&lt;&lt;</td><td>左位移</td></tr><tr><td>&gt;&gt;</td><td>右位移</td></tr><tr><td>&amp;</td><td>位布尔和</td></tr><tr><td>&#124;</td><td>位布尔或</td></tr><tr><td>&amp;&amp;</td><td>逻辑和</td></tr><tr><td>&#124;&#124;</td><td>逻辑或</td></tr></tbody></table></div><div class="show">(( result = 5 * (3 + 2) ))echo "Result of arithmetic operation: $result"</div><h4 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h4><p>双括号命令也常用于if-then等语句的逻辑判断，双括号命令支持<span class="tips">&lt;</span>、<span class="tips">&gt;</span>、<span class="tips">&lt;=</span>、<span class="tips">&gt;=</span>、<span class="tips">==</span>、<span class="tips">!=</span>运算符</p><div class="show">if (( result > 10 )); then    echo "The result is greater than 10"else    echo "The result is not greater than 10"fi</div><h3 id="双方括号命令"><a href="#双方括号命令" class="headerlink" title="[[]]双方括号命令"></a>[[]]双方括号命令</h3><p>双方括号命令提供了针对字符串比较的高级特性，双方括号命令里的表达式支持模式匹配，可以定义正则表达式来匹配字符串，因此该命令在比较字符串时功能很强大：</p><ul><li>支持<span class="tips">&lt;</span>、<span class="tips">&gt;</span>、<span class="tips">==</span>、<span class="tips">!=</span>、<span class="tips">-gt</span>等比较符</li><li>支持<span class="tips">!</span>、<span class="tips">&amp;&amp;</span>、<span class="tips">||</span>等逻辑组合</li><li>支持<span class="tips">-f</span>等文件测试，如：检测文件是否存在，是否为目录等</li><li>支持使用<span class="tips">*</span>、<span class="tips">?</span>等通配符，并使用<span class="tips">=~</span>结合正则表达式进行匹配</li></ul><div class="show">#!/bin/bash if [[ $USER == r* ]] #r*使用模式匹配规则then  echo "Hello $USER" else  echo "未知用户" fi</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>bash shell支持双方括号命令，但部分shell可能不支持该命令</div><h3 id="脚本控制"><a href="#脚本控制" class="headerlink" title="脚本控制"></a>脚本控制</h3><p>脚本在执行时，终端可以通过kill命令或Ctrl+C等方式发起信号进行进程的暂停、终止操作，这些信号中有一些是可以通过脚本捕获并作相应处理的(如：在被终止时将数据写入文件做好保存，或者无视终止命令继续执行脚本)</p><h4 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h4><div class="apiBox">trap 捕获时执行的命令 信号1 信号2 ...</div><ul><li>信号可以是信号值或信号名，但需要是可被捕获的Linux信号</li><li>trap命令也会捕获以下特殊的伪信号</li></ul><div class="table"><table><thead><tr><th>信号名(信号值)</th><th>说明</th></tr></thead><tbody><tr><td>EXIT(0)</td><td>会在脚本退出时执行</td></tr><tr><td>DEBUG</td><td>会在每个命令后都执行一次</td></tr><tr><td>ERR</td><td>当某个命令以非零状态退出时，执行一次(非零状态来自if,while,until语句时不会执行)</td></tr></tbody></table></div><div class="show">e.g.用户执行Ctrl+C发起SIGINT信号中断脚本执行时，输出信息并继续脚本执行，下下述代码中，echo语句包含空格，所以需要使用双引号引用整个echo语句，其他命令同理。如果命令中包含空格(如：rm -f)则也需要双引号#!/bin/bashtrap "echo '无法通过Ctrl+C停止脚本执行'" SIGINTcount=1 while [ $count -le 10 ] do  echo "循环次数： $count"  sleep 1  count=$[ $count + 1 ] done</div><h4 id="修改信号捕获"><a href="#修改信号捕获" class="headerlink" title="修改信号捕获"></a>修改信号捕获</h4><p>如果需要在脚本某个阶段修改前面设置的信号捕获语句，只需要重新使用一次trap命令即可</p><div class="show">#!/bin/bash trap "echo '捕获到SIGINT信号执行功能1'" SIGINT count=1 while [ $count -le 5 ] do  echo "Loop #$count"  sleep 1  count=$[ $count + 1 ] done trap "echo '此时捕获到SIGINT信号修改为执行功能2'" SIGINT</div><h4 id="删除信号捕获"><a href="#删除信号捕获" class="headerlink" title="删除信号捕获"></a>删除信号捕获</h4><p>如果脚本在某个阶段不再需要进行信号捕获了，则可以移除信号捕获，语法为<span class="tips">trap -&zwnj;- 信号</span></p><div class="show">#!/bin/bashtrap "echo '捕获信号SIGINT'" SIGINT.. #脚本功能.trap -&zwnj;- SIGINT #移除信号捕获</div><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="创建与调用函数"><a href="#创建与调用函数" class="headerlink" title="创建与调用函数"></a>创建与调用函数</h4><p>shell脚本中创建函数的方法有两种：</p><div class="apiBox">function 函数名 {   #函数体}</div>或<div class="apiBox">函数名( ) {   #函数体}</div><p>注意，使用第一种方式定义函数时，函数名和{之间必须有一个空格，否则{可能会被当作函数名的一部分从而报错。调用函数与其他语言类似，只是不需要括号，直接执行函数名即可，同样，shell中的函数需要在调用前的代码中创建，否则抛出command not found错误。函数可以同名，后面的函数会覆盖前面的函数，函数调用方法为：<br><span class="strong">函数名 参数1 参数2 …</span></p><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>在shell中，变量也分为全局变量和局部变量</p><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>与其他语言有所不同，shell中的全局变量作用域为定义之后的整个脚本代码，即使是函数内部定义的变量，在函数外依旧有效。若无特殊声明，脚本中定义的变量默认为全局变量。</p><div class="show">e.g.函数内定义的变量，函数外也可以访问#! /bin/bashfunction test {   string="手写的从前"}testecho "函数外也可以获取全局变量：$string"</div><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>shell中的局部变量需要使用<span class="tips">local</span>关键字声明。局部变量如果在函数内部声明，则其作用域只在函数中，如果函数外部存在一个同名变量，二者互不干扰</p><div class="show">e.g.想要变量作用域为局部，需要使用local关键字声明#! /bin/bashfunction test {   local string="手写的从前"   echo "函数内可以获取到变量值：$string"}testecho "函数外无法获取该变量：$string" #为空值</div><h4 id="函数返回值与输出"><a href="#函数返回值与输出" class="headerlink" title="函数返回值与输出"></a>函数返回值与输出</h4><h5 id="默认退出状态码"><a href="#默认退出状态码" class="headerlink" title="默认退出状态码"></a>默认退出状态码</h5><p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。与其他命令一样，在函数执行结束后，可以用shell中的预定义变量<span class="tips">$?</span>来确定函数的退出状态码。默认情况下，函数的退出状态码是函数中<span class="tips">最后一条命令</span>返回的退出状态码。注意，函数的默认退出状态码只看最后一条命令的退出状态，其他命令执行正确与否无法获悉，因此该方法应用场景有限。此外，就像脚本的返回值可以使用exit修改一样，函数的返回值可以使用return语句修改</p><div class="show">e.g.函数func的退出状态码为最后一条命令ls的退出状态码，如果none.txt文件不存在，则函数的退出状态码为1，该状态码可以用$?调用#!/bin/bashfunc() {  echo "执行函数"  ls -l none.txt }funcecho "该函数的退出状态码为 $?" #none.txt文件不存在，输出值为12. 可以使用return修改该返回值，即便ls命令未正确执行#!/bin/bashfunc() {  echo "执行函数"  ls -l none.txt  return 0}funcecho "该函数的退出状态码为 $?" #此时return语句才是脚本最后一条命令，$?将输出为0</div><h5 id="return命令修改状态码"><a href="#return命令修改状态码" class="headerlink" title="return命令修改状态码"></a>return命令修改状态码</h5><p>shell支持使用<span class="tips">return</span>命令来返回指定的退出状态码，状态码支持<span class="tips">0-255</span>之间的整数值，该状态码同样可以使用<span class="tips">$?</span>获得。与exit命令指定的脚本退出状态码类似，如果return命令指定的退出状态码大于255，会输出该值被256取模后的结果</p><div class="show">e.g.如果函数返回值大于255，则会返回一个错误的值#!/bin/bashfunction getDouble {   read -p "输入一个值：" value #输入200   return $[ $value * 2]}getDoubleecho "函数的返回值为 $?" #输出值为144：400%256=144</div><h5 id="函数输出"><a href="#函数输出" class="headerlink" title="函数输出"></a>函数输出</h5><p>shell支持将命令的输出赋值给变量，同样也支持将函数的输出值赋值给变量，通过该方法我们可以将任何类型的数据作为函数输出，然后通过反引号<span class="tips">``</span>或<span class="tips">$( )</span>调用函数，并将获取的函数输出值保存到变量中，该方法相比于return语句功能更加强大。但注意，通过该方法从函数中输出的值并不会作为函数的退出状态码，也无法被<span class="tips">$?</span>捕获</p><div class="show">e.g.函数中read等命令的提示语句并不会作为函数输出一部分#!/bin/bashfunction getDouble {  read -p "输入值：" value #不输出提示语句给result变量 echo $[ $value * 2 ] #输入10}result=$(getDouble)echo "函数输出值为 $result" #输出result为20echo "函数的退出状态码为$?" #输出状态码为0</div><h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>由于bash shell会将函数当作小型脚本来对待，因此可以像命令传参一样给函数传入参数，并使用<span class="tips">$1、$2</span>等位置变量来读取传入函数的参数。</p><p>由于函数内部也使用$1、$2等变量来引用函数的参数，因此脚本中的$1、$2等位置变量无法在函数内部使用，即函数中无法直接通过位置变量来读取脚本传入的参数。要在函数中使用脚本传入的参数，则需要在调用函数时手动将它们传过去</p><div class="show">e.g.为脚本test传入两个参数，并在函数中进行求和#!/bin/bashfunction add {    if [ $# -ne 2 ] #判断函数参数数量   then    echo -1    else   echo $[ $1 + $2 ] #这是函数的位置变量$1 $2   fi}value=$(<span class="text-red">add $1 $2</span>) #这是脚本的位置变量$1 $2echo "函数计算结果为：$result"执行该脚本时./test 10 20</div><h4 id="传递数组参数"><a href="#传递数组参数" class="headerlink" title="传递数组参数"></a>传递数组参数</h4><p>shell中，给函数传递数组，不能像C语言一样直接传递数组名(数组首地址)，这样只会传递第一个值。需要使用<span class="tips">${数组名[@]}</span>将所有数组元素传递过去，然后在函数中使用<span class="tips">$@</span>获取所有的数组元素</p><p>理论上通过<span class="tips">${数组名[*]}</span>也可以传递数组元素，或用<span class="tips">$*</span>接收，但<span class="tips">$*</span>会将所有数组元素视为一个整体，在使用for-in等语句遍历时可能出现问题</p><div class="show">e.g.传递数组#! /bin/bashfunction test { echo '$@的值为'$@ for value in $@ do   echo "当前值为：$value" done}array=(10 20 30 40)test ${array[@]}e.g.如果使用$*，所有数组元素会被视为一个整体function test {<span class="text-red">#使用该语句，依旧会把元素一个一个遍历出来，这是因为即便$*使用空格作为元素分隔符，for语句会自动识别空格分隔的数据并遍历 for value in $*</span><span class="text-blue">#使用双引号包裹$*，for语句就只执行一次了for value in "$*"</span><span class="text-green">#而对于$@，无论加不加双引号，for语句都会依次遍历出数组里的元素for value in "$@"</span> do   echo "当前值为：$value" done}array=(10 20 30 40)test ${array[*]}</div><h4 id="返回数组"><a href="#返回数组" class="headerlink" title="返回数组"></a>返回数组</h4><p>从函数返回数组时，也不能直接返回数组地址，而是需要通过<span class="tips">echo</span>语句输出<span class="tips">${数组名[@]}</span>(数组元素)，然后通过<span class="tips">命令替换</span>等方式在脚本中调用函数，并在命令替换时在外层加上<span class="tips">( )</span>将其转换为一个数组</p><div class="show">e.g.传入一个数组，反序输出<code>#! /bin/bashfunction test &#123;#echo "函数开始执行----------"  local newArray  local index=$[$#-1] #获取函数接收的参数个数并-1  for value in $@   do    newArray[$index]=$value    index=$[$&#123;index&#125;-1]   doneecho $&#123;newArray[@]&#125;&#125;array=(10 20 30 40 50)<span class="text-red">result=($(test $&#123;array[@]&#125;))</span>echo "返回值result $result"</code>注意：1.bash在使用命令替换时，会将捕获的结果作为一个字符串返回。上述代码中，命令替换外层加了个小括号()，在没有括号的情况下，result存储的是一个字符串，添加小括号后，result存储的结果将被转换为数组2. bash在使用命令替换时会捕获所有命令的标准输出，如果在test函数中有除了输出数组元素以外的语句，也会被捕获，并被赋值给result。由于shell支持不同类型的数据都作为同一数组的元素，因此所有输出信息都将作为数组元素，这可能会对之后使用该数组造成影响，因此，返回数组的函数，尽量不要输出多余的信息。如：如果test函数第一行被注释的echo语句正常输出，则该语句信息将作为result的数组元素3. 命令替换会捕获所有标准输出语句，且不显示到屏幕上，因此执行result=($(test ${array[@]}))语句时，虽然函数被执行了，但不会有任何屏幕输出，这些输出信息会在使用echo输出result的结果时，才会被输出到屏幕上</div><h4 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h4><p>如果需要在多个脚本中频繁使用同一段代码，可以将这段代码封装为函数库，然后在多个脚本中调用该库文件。但在shell中，如果直接调用或执行该文件，shell会创建一个新的shell并在其中执行该库文件中的代码，而函数的作用域仅限于定义它的shell会话，因此在其他脚本中将无法调用这些函数。</p><p>shell提供了<span class="tips">source</span>命令用于解决该问题，source命令会在当前shell上下文中执行命令，这样脚本就可以使用库中的函数了。source命令有个快捷别名，称为<span class="tips">点操作符</span>，命令也可以用<span class="tips">.</span>号代替，语法格式为：<br><span class="strong">. 库文件路径</span></p><div class="show">e.g.在myfunc.sh定义了两个函数，在test.sh中调用这两个函数<span class="strong">文件路径：/myShell/myfunc.sh</span><code>#!/bin/bashfunction add &#123; if [ $# -ne 2 ]  then  echo "参数输入错误" else  echo $[$1+$2] fi&#125;function sub &#123; if [ $# -ne 2 ]  then  echo "参数输入错误" else  echo $[$1-$2] fi&#125;</code><span class="strong">文件路径：/myShell/test.sh</span><code>#!/bin/bash<span class="text-red">#注意：无论使用.号还是source，命令后都需要添加一个空格，路径用相对路径或绝对路径均可</span><span class="text-blue">. ./myfunc.sh</span><span class="text-green">source /myShell/myfunc.sh</span>echo "求和运算：$(add 10 20)"echo "求差运算：$(sub 20 10)"</code></div><h4 id="在命令行中使用函数"><a href="#在命令行中使用函数" class="headerlink" title="在命令行中使用函数"></a>在命令行中使用函数</h4><p>函数也可以在命令行中创建和调用，命令行中创建的函数可以在整个系统中被调用，直到当前shell退出。<span class="tips">注意，如果命名时函数名和shell的内建命令同名，则内建命令的功能会被函数功能覆盖！</span></p><p>在命令行中定义函数的方法有两种：</p><ol><li><p>以单行方式定义，需要在每个命令后都加上分号<span class="tips">;</span>，以便shell区分命令的起止</p><div class="show">定义：function test { pwd; ls; echo $[ $1 / $2 ]; }调用：test 100 50</div></li><li><p>以多行方式定义，定义时，bash会使用次提示符提示输入更多命令，该方式不需要在命令后添加分号，直接回车即可，最后输入花括号<span class="tips">}</span>告知shell函数输入完毕</p><div class="show">定义：function add { &gt; echo $[ $1 + $2 ] &gt; } 调用：add 2 5</div></li></ol><h4 id="在-bashrc文件中定义函数"><a href="#在-bashrc文件中定义函数" class="headerlink" title="在.bashrc文件中定义函数"></a>在.bashrc文件中定义函数</h4><p>在命令行中定义的函数，在shell退出时函数也会随之失效，如果希望某个函数在shell启动时也随之被加载进内存，方便在全局调用，则可以将该函数写入<span class="tips">$HOME/.bashrc</span>文件，一般情况下，bash以登录交互式shell启动，或以非登录交互式shell启动都会载入该文件。绝大部分Linux发行版都已经在.bashrc文件中定义了一些函数，注意小心修改，将新添加的函数写于文件末尾即可。也可以将新写的函数写于一个单独的文件中，然后在.bashrc文件中使用source命令载入。</p><p>通过该方式从.bashrc文件载入的函数，可以在命令行中全局调用，但无法在脚本中使用，这是由于脚本执行时启动的非交互式shell不会读取.bashrc文件，函数也不会从父shell中继承。如果需要某个函数在脚本中也可以被直接调用，可以用以下方法：</p><ul><li>在脚本中使用source命令引入.bashrc文件</li><li>如果不想引入.bashrc文件，则在.bashrc文件中定义完函数后，可以用<span class="tips">export -f</span>命令将函数导出为环境变量，这样执行脚本时创建的非交互式shell将能从父shell继承该函数，然后在脚本中直接调用</li></ul><div class="show">e.g.为了避免修改$HOME/.bashrc，因此将某个常用的函数定义于$HOME/myfunc文件中，然后在$HOME/.bashrc引入，然后尝试在某个脚本中直接调用。这里直接以root账户举例<span class="strong">创建文件/root/myfunc用于存放自定义函数</span><code>function myTest1 &#123; echo "函数myTest1被调用" &#125; function myTest2 &#123; echo "函数test2被调用" &#125;export -f myTest1 #导出其中一个函数</code><span class="strong">在文件/root/.bashrc末尾引入myfunc文件</span><code>if [ -f /root/myfunc ];then        . /root/myfuncfi</code><span class="strong">/myShell/test.sh</span><code>#!/bin/bashecho "脚本开始执行"myTest1 #被导出的函数可以在非交互式shell执行的脚本中直接使用myTest2 #未被导出为环境变量的函数则提示command not found</code></div><h3 id="脚本合集"><a href="#脚本合集" class="headerlink" title="脚本合集"></a>脚本合集</h3><h4 id="判断发行版"><a href="#判断发行版" class="headerlink" title="判断发行版"></a>判断发行版</h4><pre><code>#!/bin/bash  os_name="undefined"os_version="0.0"# 检查 /etc/os-release 文件是否存在  if [ -f /etc/os-release ]; then      . /etc/os-release      os_name=$NAME    os_version=$VERSION    echo "发行版: $NAME"      echo "版本: $VERSION"  else      # 作为替代，检查其他可能的文件      if [ -f /etc/lsb-release ]; then          . /etc/lsb-release      os_name=$DISTRIB_ID    os_version=$DISTRIB_RELEASE        echo "发行版: $DISTRIB_ID"          echo "版本: $DISTRIB_RELEASE"      elif [ -f /etc/debian_version ]; then          os_name="Debian"    echo "发行版：Debian"        echo "版本未知，以下为/etc/debian_version文件内容:"        cat /etc/debian_version        elif [ -f /etc/centos-release ]; then      os_name="CentOS"        echo "发行版：CentOS"          cat /etc/centos-release      elif [ -f /etc/redhat-release ]; then    os_name="redhat"        echo "发行版：redhat或centOS"    else                echo "未知发行版"      fi  fi</code></pre><h4 id="判断系统架构"><a href="#判断系统架构" class="headerlink" title="判断系统架构"></a>判断系统架构</h4><pre><code>#!/bin/bashif [[ "$(uname)" == "Linux" ]];then    case "$(uname -m)" in    'i386'|'i686')     machine='32';;    'amd64'|'x86_64')    machine='64';;        'armv5tel')        machine='arm32-v5';;      'armv6l')        machine='arm32-v6'        grep Features /proc/cpuinfo | grep -qw 'vfp' || machine='arm32-v5';;      'armv7' | 'armv7l')        machine='arm32-v7a'        grep Features /proc/cpuinfo | grep -qw 'vfp' || machine='arm32-v5';;      'armv8' | 'aarch64')        machine='arm64-v8a';;      'mips')        machine='mips32';;      'mipsle')        machine='mips32le';;      'mips64')        machine='mips64';;      'mips64le')        machine='mips64le';;      'ppc64')        machine='ppc64';;      'ppc64le')        machine='ppc64le';;      'riscv64')        machine='riscv64';;      's390x')        machine='s390x';;      *)        echo "error: The architecture is not supported."        exit 1;;    esac    fiecho $machine</code></pre>]]></content>
    
    
    <summary type="html">本文主要内容为shell脚本语法和脚本执行方法</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="shell" scheme="https://shiwei11.github.io/blog/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell介绍与使用</title>
    <link href="https://shiwei11.github.io/blog/2021/12/29/LinuxShell%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://shiwei11.github.io/blog/2021/12/29/LinuxShell%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-29T02:07:10.000Z</published>
    <updated>2024-11-01T09:50:37.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><h4 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h4><p>shell意为层壳，区别于操作系统Kernel(内核)，shell是一个命令行解释器，主要用来与用户交互，将用户的命令解释给操作系统，是用户与操作系统内核交互的桥梁，它提供文件操作、进程控制、环境变量设置、管道和重定向等各种功能，因此，Shell 也是许多脚本和自动化任务的基础。此外，shell还有一套自己的编程语法，用于编写shell脚本，shell脚本支持直接调用Linux系统命令</p><p>常见的类Unix操作系统中的Shell程序包括：</p><ul><li>sh(Bourne Shell)：是Unix系统上最早的shell，由Stephen Bourne于1977年在AT&amp;T贝尔实验室开发。尽管现在有许多更现代的shell可以使用，但许多Unix系统命令和脚本仍然使用sh作为默认解释器</li><li>Bash(Bourne-Again SHell)： bash是Bourne Shell的增强版，兼容sh的命令和脚本，并结合了ksh、csh的有用功能。作为GNU项目的一部分，它具有强大的功能和灵活性，支持命令历史、自动补全、脚本编程等功能，是许多Linux系统的默认Shell</li><li>Csh(C Shell)：csh是基于C语言语法的shell，它提供了类似于C语言的语法结构和编程特性，由Bill Joy于1978年开发</li><li>Tcsh（TC Shell）：Tcsh是C Shell的改进版本，提供了更多的功能和灵活性</li><li>Fish（Friendly Interactive Shell）：Fish是一个用户友好的交互式shell软件，具有直观的语法和自动补全功能，还提供了颜色高亮和语法提示等功能，被广泛包含于如 Debian、Ubuntu、Fedora、Gentoo、Arch 等操作系统中</li><li>Ksh(Korn Shell)：由贝尔实验室的David Korn在1983年基于Bourne shell的源码开发，它结合了Bourne Shell和C Shell的特性，并引入了许多新的功能</li><li>Zsh(Z Shell)：由普林斯顿大学的Paul Falstad开发，它包含了 bash，ksh，tcsh 等其他shell中许多优秀功能，可以作为bash的替代品，它也是macOS 10.15及新版系统的默认shell</li></ul><p>在这些众多的shell中，有一些shell软件有类似的语法和特性，由此形成了两大家族：Bourne Shell家族：通常为Linux的默认使用终端，包括sh、ksh、Bash、psh、zsh。以及C Shell家族：包括csh、tcsh，语法与C语言类似，主要用于BSD版Unix系统。</p><h4 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h4><p>查看<span class="tips">/etc/shells</span>文件可获取当前Linux支持的shell列表，绝大多数Linux发行版默认使用Bash作为命令解释器，直接输入其他shell名可进行切换，通过<span class="tips"><strong>exit</strong></span>命令返回默认的Bash终端</p><h4 id="父子shell"><a href="#父子shell" class="headerlink" title="父子shell"></a>父子shell</h4><p>默认情况下，系统会在用户登录时根据<span class="tips">/etc/passwd</span>文件第7字段的设置启动用户的默认shell，这是一个<span class="text-blue">父shell</span>，如果此时输入bash或其他shell的启动命令，会创建一个新的shell程序，这个shell程序是一个<span class="text-blue">子shell</span>。</p><p>创建子shell可以保持父子进程环境的纯洁性，创建子shell时，只有部分父进程环境会被复制到子shell中，因此子shell会在一个相对纯洁的环境中执行任务，但这也会造成父shell中的一些变量(如用户自定义的局部变量)无法被子shell中继承使用。在子shell中执行一些独立任务，或者修改一些环境也不会影响到父进程的执行。但是创建子shell成本不菲，它会显著占用一部分系统资源</p><p>以下操作会创建一个子shell：</p><ul><li>通过<span class="tips">bash</span>等命令显式调用shell解释器，会启动一个新的子shell</li><li>通过<span class="tips">bash filename.sh</span>或<span class="tips">./filename.sh</span>方式执行shell脚本时，会创建一个子shell执行该脚本。相对的，通过source filename.sh或.filename.sh方式执行脚本，会在当前shell中执行而不会创建子shell</li><li>在命令中使用管道符<span class="tips">|</span>时，shell会创建子shell，管道两边的命令都会在单独的子shell中执行。</li><li>使用反引号<span class="tips">` `</span>或<span class="tips">$()</span>执行命令替换时，命令会在子shell中执行</li><li>将命令放到<span class="tips">( )</span>中，所有括号中的命令会在子shell中执行，这是最直接创建子shell的方式，通常用来执行多个需要在同一个shell环境中执行的一组命令</li><li>使用<span class="tips">&amp;</span>将任务放到后台执行时，为了不阻塞当前shell执行其他任务，bash会在后台创建子shell执行命令</li></ul><h5 id="查看父子shell的创建关系"><a href="#查看父子shell的创建关系" class="headerlink" title="查看父子shell的创建关系"></a>查看父子shell的创建关系</h5><p>子shell也可以创建另一个子shell，产生嵌套，通过<span class="tips">ps -f</span>命令查看shell程序的PPID来查找其父进程</p><div class="shell">UID        PID  PPID  C STIME TTY          TIME CMDroot     27576 27573  0 15:11 pts/0    00:00:00 -bash #父shellroot     27602 27576  0 15:11 pts/0    00:00:00 bash  #子shell，父进程PID为27576root     27619 27602  0 15:11 pts/0    00:00:00 ps -f</div>也可以通过<span class="tips">ps -&zwnj;-forest</span>命令查看子shell的嵌套结构<div class="shell">  PID TTY          TIME CMD27576 pts/0    00:00:00 bash27602 pts/0    00:00:00  \_ bash27923 pts/0    00:00:00      \_ bash27939 pts/0    00:00:00          \_ bash28000 pts/0    00:00:00              \_ ps</div><p>也可以通过输出环境变量<span class="tips">BASH_SUBSHELL</span>来查看当前bash有没有生成子shell，如果该命令返回0，则表明没有子shell，返回1或其他更大的值，就表明有相应数量的子shell。但该命令需要在父shell环境下执行，因此一般在命令分组并形成进程列表时使用</p><div class="shell">(pwd;ls;echo $BASH_SUBSHELL)</div><p>bash shell程序可使用命令行选项修改shell启动方式，以下为bash中可用的命令行参数</p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c string</td><td>从string中读取命令并进行处理</td></tr><tr><td>-i</td><td>启动一个能够接收用户输入的交互shell</td></tr><tr><td>-l</td><td>以登录shell的形式启动</td></tr><tr><td>-r</td><td>启动一个受限shell，用户会被限制在默认目录中</td></tr><tr><td>-s</td><td>从标准输入中读取命令</td></tr></tbody></table></div><h5 id="父子shell的使用场景"><a href="#父子shell的使用场景" class="headerlink" title="父子shell的使用场景"></a>父子shell的使用场景</h5><p>如果命令或脚本需要在一个纯净的隔离环境下执行，或者希望执行某个操作但不改变当前的shell环境，创建子shell十分有用，但需要注意创建子shell带来的资源占用问题</p><div class="show">1.前往tmp目录并创建一个新文件，但不切换当前目录(cd /tmp && touch newfile) #不会切换当前父shell的工作目录2. 临时更改环境变量，使子shell在某个新的环境变量下工作，但不影响父shell(export PATH=/custom/path && test.sh)3. 通过( )创建多个子shell时，这些子shell会被依次创建，只有执行完第一个子shell中的任务，才会创建第二个如：创建文件test.sh并写入以下命令(sleep 3)  # 3 seconds(sleep 2)  # 2 seconds(sleep 1)  # 1 second使用time()函数计算脚本执行时间time(bash test.sh) #大约需要6s但通过&创建子shell，这些任务会被放入后台，子shell会并行创建并执行如：将文件test.sh修改为sleep 3 &  # 3 secondssleep 2 &  # 2 secondssleep 1 &  # 1 secondwait然后计算执行时间time(bash test.sh) #大约需要3s，取决于执行时间最长的子shell</div><h3 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>外部命令，又被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中，可以使用<span class="tips">which</span>或<span class="tips">type -a</span>命令找到命令位置。执行外部命令时，会创建一个该命令对应的子进程，相对于内建命令来说，外部命令需要花费时间和资源来设置新子进程的环境</p><div class="shell"># which ps/bin/ps</div><h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令不需要使用子进程来执行，它们已经和shell编译成了一体，在执行时速度更快，消耗的资源更少。常见的内建命令有<span class="tips">cd、echo、pwd、history、alias、continue、exit、jobs、kill</span>等</p><p>可以使用<span class="tips">type</span>命令来查看某个命令是否为内建命令</p><div class="shell"># type cdcd is a shell builtin</div><p>有些命令有多种实现方式，如：echo和pwd既有内建命令又有外部命令，默认使用内建命令，如果需要使用外部命令，则指定命令的具体路径即可。可以用<span class="tips">type -a</span>命令查看命令的不同实现</p><div class="shell"># type -a echo echo is a shell builtin echo is /bin/echo</div><h4 id="命令的执行优先级"><a href="#命令的执行优先级" class="headerlink" title="命令的执行优先级"></a>命令的执行优先级</h4><ul><li>第一顺位执行通过绝对路径或相对路径执行的命令</li><li>第二顺位执行自定义的命令别名</li><li>第三顺位执行bash内部命令</li><li>第四顺位执行$PATH环境变量定义的第一个命令</li></ul><h4 id="命令分组执行"><a href="#命令分组执行" class="headerlink" title="命令分组执行"></a>命令分组执行</h4><p>可以在一行中指定多个命令，命令之间使用分号(;)分隔，称为<span class="tips">命令列表</span>，这些命令会依次执行</p><div class="show">$ pwd ; ls ; cd /etc ; pwd ; ls</div><p>可以使用大括号或小括号将这些命令组合在一起，以便在特定情况(如在if-then语句中)一起执行，这称之为<span class="tips">命令分组</span>，主要有两种不同的命令分组：</p><ul><li><p>使用大括号{ }将多个命令组合在一起，可以在当前shell环境中执行，该方法也可用于shell脚本中if-then语句的结构控制</p><div class="show">{ pwd ; cd /etc ; ls }</div></li><li><p>如果将命令列表写在括号里，则shell会创建一个子shell执行这些命令，称为<span class="tips">进程列表</span>，这样可以使用多个子shell进行多进程处理</p><div class="show">创建1个子shell，输出值为1(pwd ; ls ; cd /etc ; pwd ; ls ; echo $BASH_SUBSHELL)括号可以嵌套，创建多个子shell进行多进程处理，创建了2个子shell(父shell创建子shell，子shell又创建了它的子shell)，输出值为2( pwd ; (echo $BASH_SUBSHELL))</div></li></ul><h4 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h4><p>shell中的协程用于在后台创建一个子shell，并在该shell中执行命令，其实就相当于使用&amp;将命令置入后台模式，但其有点在于我们可以为该协程命名，并且该协程创建时会自动创建一个匿名管道，并将子shell的输入输出重定向到这个管道，实现在 Bash 脚本中并发地执行子进程，并与该子进程进行双向数据通信的功能</p><p>协程的创建需要使用命令<span class="tips">coproc</span>，其语法为：</p><p><span class="strong">coproc 协程名 { 命令1; 命令2; }</span></p><p>如果不指定协程名，则默认为COPROC，之后命令会被置入后台模式，返回后台作业号和进程ID</p><div class="show">coproc my_process { echo "子进程开始"; sleep 2; echo "子进程执行完毕"; }# 读取子进程的输出while read -u "${my_process[0]}" output; do    echo "父进程获得子进程输出: $output"donewait # 等待后台进程结束echo "父进程执行完毕"</div><h3 id="Bash常用快捷键"><a href="#Bash常用快捷键" class="headerlink" title="Bash常用快捷键"></a>Bash常用快捷键</h3><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>GUN官方的Bash文档：<a href="https://www.gnu.org/software/bash/manual/bash.html">Bash Reference Manual</a></div><div class="table"><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>ctrl+a</td><td>将光标跳转到命令行开头</td></tr><tr><td>ctrl+e</td><td>将光标跳转到命令行末尾</td></tr><tr><td>ctrl+左箭头</td><td>光标向左(前)跳转一个单词，esc+b也可以</td></tr><tr><td>ctrl+右箭头</td><td>光标向右(后)跳转一个单词，esc+f也可以</td></tr><tr><td>ctrl+u</td><td>剪切光标到行首之间的内容(也用来快速删除一整行命令)</td></tr><tr><td>ctrl+k</td><td>剪切光标到行尾之间的内容</td></tr><tr><td>ctrl+y</td><td>粘贴剪切的内容</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>ctrl+l</td><td>清屏，同clear命令</td></tr><tr><td>exit</td><td>退出当前终端</td></tr><tr><td>ctrl+d</td><td>退出当前终端，同exit命令</td></tr><tr><td>ctrl+c</td><td>强制终止当前任务</td></tr><tr><td>ctrl+z</td><td>暂停当前任务并放入后台</td></tr><tr><td>ctrl+r</td><td>反向搜索执行过的历史命令</td></tr><tr><td>#</td><td>root用户的命令提示符</td></tr><tr><td>$</td><td>非root用户的命令提示符</td></tr><tr><td>&gt;</td><td>次提示符</td></tr><tr><td>\</td><td>延续字符</td></tr></tbody></table></div>修改快捷键参考stty命令<h3 id="Bash的内建命令"><a href="#Bash的内建命令" class="headerlink" title="Bash的内建命令"></a>Bash的内建命令</h3><h4 id="history历史命令"><a href="#history历史命令" class="headerlink" title="history历史命令"></a>history历史命令</h4><p>在bash中执行过的命令会被缓存在内存中，方便重复调用，当shell退出或用户登出时会被写到用户对应的<span class="tips">.bash_history</span>历史命令记录文件中</p><p><span class="strong">history [选项] [历史命令保存文件]</span>查看使用过的命令，可以在后面加一个值指定显示n条命令</p><ul><li>-c 清空历史命令</li><li>-w 把缓存的历史命令写入历史命令保存文件~/.bash_history中</li><li>-a 将缓存的历史命令追加到历史命令保存文件中</li><li>-d 值 删除该条历史命令记录</li><li>-s 字符串  将该字符串添加到当前会话的命令历史中，但不执行</li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>每个用户都有独立的历史命令保存文件，一般在用户家目录下，该文件默认隐藏，用户执行过的命令会先缓存在内存中，等登出账户后再写入bash_history文件中，历史命令默认保存1000条，用户可在环境变量配置文件/etc/profile中的HISTSIZE选项自行修改</div><h5 id="调用历史命令"><a href="#调用历史命令" class="headerlink" title="调用历史命令"></a>调用历史命令</h5><ul><li><span class="strong">可通过上下箭头调用之前执行的命令</span></li><li><span class="strong">!!</span>再次执行上一次执行的命令</li><li><span class="strong">!n</span>再次执行第n条历史命令(序号以history列出的序号为准)</li><li><span class="strong">!字符串</span>再次执行最后一次以该字符串开头的命令</li></ul><h4 id="alias自定义命令名"><a href="#alias自定义命令名" class="headerlink" title="alias自定义命令名"></a>alias自定义命令名</h4><p><span class="strong">alias</span>查看所有自定义的命令</p><p><span class="strong">alias 别名=’原命令’</span>自定义命令名，原命令依旧可用</p><p>使用命令定义的命令名只能临时生效，且只在当前shell中生效，系统重启后将丢失，要永久生效需将自定义的命令添加到文件<span class="tips">/用户名/.bashrc</span>中</p><p>删除自定义的命令:</p><p><span class="strong">unalias 别名</span></p><h4 id="type查询命令类型"><a href="#type查询命令类型" class="headerlink" title="type查询命令类型"></a>type查询命令类型</h4><p>查看所指定的命令是shell 内建命令、外部可执行文件，还是其他类型</p><p><span class="strong">type [选项] 命令</span></p><ul><li>-a 查看所有可能的命令类型，有的命令可能同时有shell内建、外部二进制文件、用户别名等多种类型，该选项会列出所有情况</li><li>-t 只显示命令类型，而不显示命令路径，返回类型可能有：lias(别名)、builtin(内建命令)、file(外部命令)、function(定义的函数)、keyword(shell保留的关键字)</li><li>-p 只显示命令路径，如果命令是shell内建命令或别名，使用此选项不会有输出</li><li>-P 在PATH中查找该命令，无论该命令是何种类型，都返回其路径</li><li>-f 不在shell函数中查找，即不将命令视为函数来查找</li></ul><h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p>exec命令的主要功能有两个</p><h5 id="替换当前shell进程"><a href="#替换当前shell进程" class="headerlink" title="替换当前shell进程"></a>替换当前shell进程</h5><div class="apiBox">exec [选项] 执行命令</div><ul><li>-c 清除所有环境变量(除了HOME、SHELL、PATH、TERM、MAIL、USER和LOGNAM)</li><li>-l 启动一个新shell执行对应的命令，该shell以登录shell的身份工作</li></ul><p>当使用exec命令执行命令或可执行文件时，新执行的程序会替换当前的shell进程。exec命令会将指定的命令或程序加载到当前shell进程的内存空间中，并替换 shell 进程的执行上下文，包括内存代码段、数据段、堆栈中的数据等，同时，新进程会继承原进程的大部分环境和信息，包括进程PID、环境变量、当前工作目录、打开的文件描述符、用户和用户组ID、进程优先级、以及对进程的资源限制(如内存限制、文件大小限制)等信息，这样可以在不创建新进程的情况下，执行新的功能和程序，极大程度上节省了用于创建新进程消耗的系统资源，可以有效减少进程数量并简化进程管理。</p><p>该命令可用于在不创建新进程或子shell的情况下切换shell并替换当前的shell进程，通过exec命令切换，Linux会保持shell的PID、用户和用户组ID、当前工作目录等环境不变，也不会创建子shell消耗更多的系统资源</p><div class="show">e.g.从bash切换到shexec /bin/sh</div><p>该命令也可以用其他程序替换当前的shell进程，例如，在脚本的最后一行使用 exec 来启动一个长期运行的程序，当脚本即将运行结束，shell的使命也即将完成，通过exec命令让新的程序替换shell进程，而不再需要创建新的进程，可以有效节约系统资源</p><div class="show">#!/bin/bash# 通过shell执行脚本功能# 即将运行结束，让新进程替换shell进程exec /path/to/long_running_application</div><p>此外，exec命令还被用于以下场景：</p><ul><li>当某个进程认为自己不能再为系统和用户作出任何贡献时，就可以调用exec命令让新的进程替代自己，如：一些守护进程，或用于系统初始化启动的进程，当系统完成启动，这些进程的使命已经完成，exec命令可以使新进程接管自己的初始化环境，减少进程间的通信和数据拷贝，提高系统性能</li><li>在一些特定环境中，使用exec命令可以保证某个关键任务完全接管当前进程，而不会有多余的 shell 进程存在</li><li>可以用于动态加载新程序和脚本，在其环境不变的情况下执行新脚本，而无需额外创建进程</li><li>在某些需要严格控制权限的环境中，用 exec 替换当前进程可以确保新的进程继承当前进程的所有权限和环境，使进程在受限的环境中启动并继承了相应权限</li></ul><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>注意！如果使用远程终端在登录shell中使用exec命令，如：执行 exec ls -l，ls命令会替换当前shell进程，这会导致远程shell会话终止，远程连接断开。因此如果要在远程连接时执行该命令，最好在子shell中使用，在登录shell中使用会导致ssh连接断开</div><h5 id="修改文件描述符"><a href="#修改文件描述符" class="headerlink" title="修改文件描述符"></a>修改文件描述符</h5><div class="apiBox">exec 重定向命令</div><p>exec 命令还可以用来重定向文件描述符。在这种用法中，exec 并不会替换当前的 shell 进程，而是会替换脚本的执行环境，该命令可用来重定向整个脚本的标准输入输出文件，或者关闭不需要的文件描述符</p><div class="show">e.g.将脚本的所有标准输出信息重定向到out.txt文件exec 1&gt;out.txte.g.关闭文件描述符3exec 3&gt;&-</div><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>bash shell使用环境变量(environment variable)来存储有关shell的会话和工作环境，并将这些信息存储在内存中，以便程序或shell脚本能够轻松访问到这些数据，一般情况下，环境变量均使用大写的变量名</p><h4 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h4><p>全局环境变量该shell和其创建的子shell中均有效，以下为查询全局环境变量的命令</p><ul><li><span class="strong">printenv</span>查看所有全局环境变量<blockquote><blockquote><ul><li>-0 每行输出末尾输出空字符(null)，而不是换行符，以便其他程序解析输出</li></ul></blockquote></blockquote></li><li><span class="strong">env</span>查看所有全局环境变量</li><li><span class="strong">printenv 变量名</span>查看指定环境变量</li><li><span class="strong">echo $变量名</span>查看指定环境变量</li></ul><p>定义全局环境变量需要使用export关键字</p><ul><li><span class="strong">export 变量名=值</span>&emsp;定义全局环境变量</li><li><span class="strong">unset 变量名</span>&emsp;删除变量</li></ul><p>父shell中创建的全局环境变量在子shell中也有效，且如果此时在子shell中修改该变量的值，不会影响其在父shell中的值，修改后的值只在子shell中有效</p><div class="show">e.g.定义一个普通全局变量，在子shll中修改值，然后返回父shell读取值$ my_variable="I am Global now" $ export my_variable #声明为全局变量$ bash   #切换到子shell$ echo $my_variable #子shell可以访问该变量I am Global now$ my_variable="Null"  #在子shell中修改变量值$ export my_variable  #即便用export命令也无法修改其在父shell中的值$ echo $my_variable Null  #该值在子shell中有效$ exit exit $ $ echo $my_variable #父shell中值不变I am Global now</div><div class="show">e.g.环境变量支持数组myArray=(one two three four five)echo ${myArray[2]}echo ${myArray[*]}unset myArray #删除数组</div><h4 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h4><p>局部环境变量只能在定义它们的shell中有效，父shell中的局部环境变量无法在子shell中访问到。Linux中没有只显示局部环境变量的命令，但可以通过<span class="strong">set</span>命令查看所有环境变量，包括局部变量、全局变量以及用户定义变量</p><p>定义局部环境变量的方法和定义局部自定义变量的方法一样，不需要加export关键字，只需要将变量名大写用于识别该变量是一个环境变量即可</p><div class="show">MY_PORT=2021echo $MY_PORTbash #切换到子shellecho $MY_PORT  #无法访问该变量</div><h4 id="Bash中的环境变量"><a href="#Bash中的环境变量" class="headerlink" title="Bash中的环境变量"></a>Bash中的环境变量</h4><p>以下为bash shell种已经定义好的环境变量，可以直接调用，有些环境变量的值为空，因此执行set命令时不一定会列出所有变量</p><div class="table"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>HOME</td><td>当前用户的主目录</td></tr><tr><td>UID</td><td>当前用户的真实用户ID（数字形式）</td></tr><tr><td>EUID</td><td>当前用户的有效用户ID（数字形式）</td></tr><tr><td>IFS</td><td>shell用来将文本字符串分割成字段的一系列字符</td></tr><tr><td>MAIL</td><td>当前用户收件箱的文件名</td></tr><tr><td>MAILPATH</td><td>冒号分隔的当前用户收件箱的文件名列表</td></tr><tr><td>OPTARG</td><td>getopts命令处理的最后一个选项参数值</td></tr><tr><td>OPTIND</td><td>getopts命令处理的最后一个选项参数的索引号</td></tr><tr><td>PATH</td><td>shell查找命令的目录列表，由冒号分隔</td></tr><tr><td>PS1</td><td>shell命令行界面的主提示符</td></tr><tr><td>PS2</td><td>shell命令行界面的次提示符</td></tr><tr><td>CDPATH</td><td>cd命令的搜索路径，切换路径时，cd命令会先尝试在当前目录下查找指定目录并切换过去，如果当前目录下并没有指定的目录，则cd命令会前往该变量设置的路径下查找并切换，可以指定多个路径用冒号分隔</td></tr><tr><td>BASH</td><td>当前shell实例的全路径名</td></tr><tr><td>BASH_ALIASES</td><td>含有当前已设置别名的关联数组</td></tr><tr><td>BASH_ARGC</td><td>含有传入子函数或shell脚本的参数总数的数组变量</td></tr><tr><td>BASH_ARCV</td><td>含有传入子函数或shell脚本的参数的数组变量</td></tr><tr><td>BASH_CMDS</td><td>关联数组，包含shell执行过的命令的所在位置</td></tr><tr><td>BASH_COMMAND</td><td>shell正在执行的命令或马上就执行的命令</td></tr><tr><td>BASH_ENV</td><td>设置了的话，bash脚本会在执行前读取变量中的文件，读取文件中设置的变量，并执行其中的命令</td></tr><tr><td>BASH_EXECUTION_STRING</td><td>使用bash -c选项传递过来的命令</td></tr><tr><td>BASH_LINENO</td><td>含有当前执行的shell函数的源代码行号的数组变量</td></tr><tr><td>BASH_REMATCH</td><td>只读数组，在使用正则表达式的比较运算符=~进行肯定匹配（positive match）时，包含了匹配到的模式和子模式</td></tr><tr><td>BASH_SOURCE</td><td>含有当前正在执行的shell函数所在源文件名的数组变量</td></tr><tr><td>BASH_SUBSHELL</td><td>当前子shell环境的嵌套级别（初始值是0）</td></tr><tr><td>BASH_VERSINFO</td><td>含有当前运行的bash shell的主版本号和次版本号的数组变量</td></tr><tr><td>BASH_VERSION</td><td>当前运行的bash shell的版本号</td></tr><tr><td>BASH_XTRACEFD</td><td>若设置成了有效的文件描述符（0、1、2），则’set -x’调试选项生成的跟踪输出，可被重定向。通常用来将跟踪输出到一个文件中</td></tr><tr><td>BASHOPTS</td><td>当前启用的bash shell选项的列表</td></tr><tr><td>BASHPID</td><td>当前bash进程的PID</td></tr><tr><td>COLUMNS</td><td>当前bash shell实例所用终端的宽度</td></tr><tr><td>COMP_CWORD</td><td>COMP_WORDS变量的索引值，后者含有当前光标的位置</td></tr><tr><td>COMP_LINE</td><td>当前命令行</td></tr><tr><td>COMP_POINT</td><td>当前光标位置相对于当前命令起始的索引</td></tr><tr><td>COMP_KEY</td><td>用来调用shell函数补全功能的最后一个键</td></tr><tr><td>COMP_TYPE</td><td>一个整数值，表示所尝试的补全类型，用以完成shell函数补全</td></tr><tr><td>COMP_WORDBREAKS</td><td>Readline库中用于单词补全的词分隔字符</td></tr><tr><td>COMP_WORDS</td><td>含有当前命令行所有单词的数组变量</td></tr><tr><td>COMPREPLY</td><td>含有由shell函数生成的可能填充代码的数组变量</td></tr><tr><td>COPROC</td><td>占用未命名的协进程的I/O文件描述符的数组变量</td></tr><tr><td>DIRSTACK</td><td>含有目录栈当前内容的数组变量</td></tr><tr><td>EMACS</td><td>设置为’t’时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止</td></tr><tr><td>ENV</td><td>如果设置了该环境变量，在bash shell运行之前会读取该变量指定路径中的文件，如果未设置，Bash 会默认读取用户的”HOME/.bashrc”文件以设置环境变量，该变量方便用户自定义bash启动时的环境变量(仅用于当bash shell以POSIX模式被调用时)</td></tr><tr><td>FCEDIT</td><td>供fc命令使用的默认编辑器</td></tr><tr><td>FIGNORE</td><td>在进行文件名补全时可以忽略后缀名列表，由冒号分隔</td></tr><tr><td>FUNCNAME</td><td>当前执行的shell函数的名称</td></tr><tr><td>FUNCNEST</td><td>当设置成非零值时，表示所允许的最大函数嵌套级数（一旦超出，当前命令即被终止）</td></tr><tr><td>GLOBIGNORE</td><td>冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名</td></tr><tr><td>GROUPS</td><td>含有当前用户属组列表的数组变量</td></tr><tr><td>histchars</td><td>控制历史记录扩展，最多可有3个字符</td></tr><tr><td>HISTCMD</td><td>当前命令在历史记录中的编号</td></tr><tr><td>HISTCONTROL</td><td>控制哪些命令留在历史记录列表中</td></tr><tr><td>HISTFILE</td><td>保存shell历史记录列表的文件名(默认是.bash_history)</td></tr><tr><td>HISTFILESIZE</td><td>最多在历史文件中存多少行</td></tr><tr><td>HISTTIMEFORMAT</td><td>如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳</td></tr><tr><td>HISTIGNORE</td><td>由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略</td></tr><tr><td>HISTSIZE</td><td>最多在历史文件中存多少条命令</td></tr><tr><td>HOSTFILE</td><td>shell在补全主机名时读取的文件名称</td></tr><tr><td>HOSTNAME</td><td>当前主机的名称</td></tr><tr><td>HOSTTYPE</td><td>当前运行bash shell的机器</td></tr><tr><td>IGNOREEOF</td><td>shell在退出前必须收到连续的EOF字符的数量（如果这个值不存在，默认是1）</td></tr><tr><td>INPUTRC</td><td>Readline初始化文件名（默认是.inputrc）</td></tr><tr><td>LANG</td><td>shell的语言环境类别</td></tr><tr><td>LC_ALL</td><td>定义了一个语言环境类别，能够覆盖LANG变量</td></tr><tr><td>LC_COLLATE</td><td>设置对字符串排序时用的排序规则</td></tr><tr><td>LC_CTYPE</td><td>决定如何解释出现在文件名扩展和模式匹配中的字符</td></tr><tr><td>LC_MESSAGES</td><td>在解释前面带有$的双引号字符串时，该环境变量决定了所采用的语言环境设置</td></tr><tr><td>LC_NUMERIC</td><td>决定着格式化数字时采用的语言环境设置</td></tr><tr><td>LINENO</td><td>当前执行的脚本的行号</td></tr><tr><td>LINES</td><td>定义了终端上可见的行数</td></tr><tr><td>MACHTYPE</td><td>按“CPU-公司-系统”（CPU-company-system）格式定义的系统类型</td></tr><tr><td>MAPFILE</td><td>一个数组变量，当mapfile命令未指定数组变量作为参数时，它存储了mapfile所读入的文本</td></tr><tr><td>MAILCHECK</td><td>shell查看新邮件的频率（以秒为单位，默认值是60）</td></tr><tr><td>OLDPWD</td><td>shell之前的工作目录</td></tr><tr><td>OPTERR</td><td>设置为1时，bash shell会显示getopts命令产生的错误</td></tr><tr><td>OSTYPE</td><td>定义了shell所在的操作系统</td></tr><tr><td>PIPESTATUS</td><td>含有前台进程的退出状态列表的数组变量</td></tr><tr><td>POSIXLY_CORRECT</td><td>设置了的话，bash会以POSIX模式启动</td></tr><tr><td>PPID</td><td>bash shell父进程的PID</td></tr><tr><td>PROMPT_COMMAND</td><td>设置了的话，在命令行主提示符显示之前会执行这条命令</td></tr><tr><td>PROMPT_DIRTRIM</td><td>用来定义当启用了\w或\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换</td></tr><tr><td>PS3</td><td>select命令的提示符</td></tr><tr><td>PS4</td><td>如果使用了bash的-x选项，在命令行之前显示的提示信息</td></tr><tr><td>PWD</td><td>当前工作目录</td></tr><tr><td>RANDOM</td><td>返回一个0～32767的随机数（对其的赋值可作为随机数生成器的种子）</td></tr><tr><td>READLINE_LINE</td><td>当使用bind –x命令时，存储Readline缓冲区的内容</td></tr><tr><td>READLINE_POINT</td><td>当使用bind –x命令时，表示Readline缓冲区内容插入点的当前位置</td></tr><tr><td>REPLY</td><td>read命令的默认变量</td></tr><tr><td>SECONDS</td><td>自从shell启动到现在的秒数（对其赋值将会重置计数器）</td></tr><tr><td>SHELL</td><td>bash shell的全路径名</td></tr><tr><td>SHELLOPTS</td><td>已启用bash shell选项列表，列表项之间以冒号分隔</td></tr><tr><td>SHLVL</td><td>shell的层级；每次启动一个新bash shell，该值增加1</td></tr><tr><td>TIMEFORMAT</td><td>指定了shell的时间显示格式</td></tr><tr><td>TMOUT</td><td>select和read命令在没输入的情况下等待多久（以秒为单位）。默认值为0，表示无限长</td></tr><tr><td>TMPDIR</td><td>目录名，保存bash shell创建的临时文件</td></tr></tbody></table></div><h4 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h4><p>用户登录shell时，shell程序会读取环境变量配置文件作为初始化环境，用户可以修改这些文件来指定shell启动时自动执行的任务，以及指定一些环境变量值</p><h5 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h5><p>对所有用户生效</p><ul><li><strong>/etc/profile</strong>&emsp;主要的配置文件，也是用户登录时最先读取的文件，用于保存全局环境变量和shell参数，并调用其他配置文件</li><li><strong>/etc/profile.d/.sh后缀文件</strong>&emsp;由profile调用</li><li><strong>/etc/bashrc</strong>&emsp;用于保存bash相关的全局环境变量、函数、命令别名，如PS1等bash终端的环境</li></ul><p>/etc/profile配置文件是最主要的配置文件，其中几个常见变量的作用：</p><div class="table"><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>USER</td><td>当前用户</td></tr><tr><td>LOGNAME</td><td>当前用户名，配置文件中LOGNAME=$USER，因此同USER</td></tr><tr><td>MAIL</td><td>用户邮箱</td></tr><tr><td>HOSTNAME</td><td>主机名</td></tr><tr><td>HISTSIZE</td><td>历史命令保存条数</td></tr><tr><td>umask</td><td>设置文件默认权限</td></tr></tbody></table></div><h5 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h5><p>只对单一用户生效，每个用户都有自己的配置文件，root用户位于/root下，普通用户位于/home/用户名下，默认隐藏，需要使用ls -a命令才能看见文件</p><ul><li>$HOME/.bash_profile &emsp; 用户个人的/etc/profile文件，保存用户自定义的环境变量，该文件会在用户登录时读取，且一般会在文件中调用其他配置文件(如下面的.bashrc)</li><li>$HOME/.bashrc &emsp;写有用户自定义的命令别名、函数等，该文件会在打开一个新的交互式bash时都读取一次</li><li>$HOME/.bash_logout &emsp;用户注销时执行的环境变量配置文件，可以写一些我们希望系统关机时执行的操作，如备份日志等</li><li>$HOME/.bash_history &emsp;记录用户执行过的命令</li></ul><p>部分Linux发行版还可能会提供如：$HOME/.bash_login、$HOME/.profile等文件，其作用一般和$HOME/.bash_profile一样，shell一般会优先执行$HOME/.bash_profile</p><h5 id="不重启就使配置文件生效"><a href="#不重启就使配置文件生效" class="headerlink" title="不重启就使配置文件生效"></a>不重启就使配置文件生效</h5><p>直接执行任一命令</p><ul><li><span class="strong">source 文件名</span></li><li><span class="strong">.配置文件名</span></li></ul><h4 id="不同启动方式读取的配置文件"><a href="#不同启动方式读取的配置文件" class="headerlink" title="不同启动方式读取的配置文件"></a>不同启动方式读取的配置文件</h4><p>日常使用时，启动bash一般分为3种方式，每种方式都会读取不同的配置文件</p><ol><li>登录用户账户时作为默认启动的交互式shell</li><li>通过bash等命令切换创建的非登录交互式子shell</li><li>执行脚本或任务启动的非交互式shell，如：执行脚本、使用at、cron等命令后台执行定时任务、通过脚本或()等方式启动的子shell</li></ol><p>作为默认登录shell启动时，bash会依次读取全局/etc/profile文件，以及用户的$HOME/.bash_profile文件，而绝大多数Linux发行版用户$HOME/.bash_profile文件会调用$HOME/.bashrc文件，而$HOME/.bashrc文件又会调用/etc/bashrc文件，因此一般情况下，登录shell会依次加载<span class="tips">/etc/profile、$HOME/.bash_profile、$HOME/.bashrc、/etc/bashrc</span>文件</p><p>而作为非登录shell启动时，它不会访问/etc/profile、$HOME/.bash_profile等文件，而只会依次读取<span class="tips">/etc/bashrc、$HOME/.bashrc</span>文件，$HOME/.bashrc文件虽然包含了对/etc/bashrc的调用，但依旧会首先加载/etc/bashrc文件，$HOME/.bashrc文件对/etc/bashrc的再次调用并不会引起异常。由于非登录shell是从父shell启动的，因此/etc/profile、$HOME/.bash_profile文件中的全局环境变量也会从父shell中继承下来。</p><p>作为非交互式shell启动时，bash shell会检查<span class="tips">BASH_ENV</span> 环境变量，如果该变量指定了文件，shell会执行该文件里的命令，并读取里面设置的变量。但在绝大多数Linux发行版中，这个变量一般为空，因此非交互式shell一般不会读取配置文件。但该方式启动的shell，若脚本直接将当前shell作为脚本的执行shell，则所有当前shell中已加载的局部变量和全局变量，都可以在脚本中使用。如果脚本中通过诸如进程列表等方式创建了子shell，而其父shell在其加载的/etc/profile、$HOME/.bashrc等(具体加载哪些文件取决于该父shell的启动方式)文件中使用export声明了全局变量，用于执行脚本的子shell会继承这些变量。</p><h4 id="环境变量的持久化"><a href="#环境变量的持久化" class="headerlink" title="环境变量的持久化"></a>环境变量的持久化</h4><p>通过赋值方式创建的变量保持于内存中，如果退出shell这些变量会失效，可以将这些环境变量写于配置文件中实现变量的持久化。</p><p>对于所有用户都可能用到的环境变量，尽量避免将全局的环境变量放在<span class="tips">/etc/profile</span>文件中，该文件会在系统升级时被覆盖，可以在<span class="tips">/etc/profile.d</span>目录中创建一个.sh结尾的文件，将全局环境变量放在该文件中，然后再在profile文件中加载该目录下的内容。</p><p>对于个人用户，可以将环境变量存放于<span class="tips">$HOME/.bashrc</span>文件中，但注意，如果需要在脚本中调用某些自定义环境变量，由于脚本启动的一般是非交互式shell，所以需要先检查是否设置了<span class="tips">BASH_ENV</span> 环境变量，如果有则需要将环境变量存放在对应的文件中；如果没有，则考虑在其父shell会读取的文件中将环境变量声明为export或在脚本中设置一个新的。</p><h3 id="终端控制"><a href="#终端控制" class="headerlink" title="终端控制"></a>终端控制</h3><h4 id="ANSI转义字符序列"><a href="#ANSI转义字符序列" class="headerlink" title="ANSI转义字符序列"></a>ANSI转义字符序列</h4><!-- 为了控制终端的显示和行为，ANSI 标准定义了一系列用于控制终端输出选项的字符序列，称为 ANSI 转义序列（Escape Sequences），其中包括了常见的控制字符（Control Characters）。这些控制字符通常分为 C0 控制字符和 C1 控制字符。ASCII 码表中 0 到 31 之间的字符称为 C0 控制字符，用于基本的终端控制。但原有的控制字符功能并不全面，因此，为了实现更多的终端控制功能，ASCII 码表扩展出了以 ESC 字符（\x1b）开头的控制序列，包括 C1 控制字符（ASCII 码表 128-159）。C1 控制字符被广泛应用于控制光标、屏幕和字符渲染。这部分控制序列中的常见类型称为 CSI（Control Sequence Introducer），而 Bash 也使用这些控制序列来控制终端行为 --><p>为了控制终端的显示和行为，ANSI标准定义了一系列用于控制终端输出选项的字符序列，称为ANSI转义字符序列(Escape Sequence)。这些转义字符序列中ASCII码表0到31(0x00–0x1F)之间的字符称为C0控制字符，C0字符通常用于基本的文本控制和终端操作，如：回车(CR)、换行(LF)、制表符(TAB)等。由于原有的控制字符功能不够全面，为了实现更多的终端控制功能，ASCII码表扩展出了值在128-159(0x80–0x9F)之间的C1控制字符，C1控制字符提供了更多扩展的高级控制功能，包括光标控制、颜色设置、字符集切换、设备控制等</p><h4 id="CSI序列"><a href="#CSI序列" class="headerlink" title="CSI序列"></a>CSI序列</h4><p>C1控制字符中用于控制光标、设置文本样式和颜色以及实现屏幕的清除、局部刷新等操作的控制字符称为<span class="tips">CSI</span>(Control Sequence Introducer)字符，CSI字符序列以<span class="tips">ESC</span>(\x1b)开头，并紧接一个<span class="tips">[</span>(代表CSI)，将ESC转换为ASCII码后，控制字符在代码中常写为<span class="tips">\e[</span>或<span class="tips">\x1b[</span>或<span class="tips">\033[</span>，完整的CSI控制语句为：<br><span class="text-red" style="margin:0">\e[</span><span class="text-green" style="margin:0">参数1;参数2;参数3…</span><span class="text-blue" style="margin:0">函数名</span></p><ul><li>\e[ 为转义字符引导头</li><li>中间参数部分可以由0个或多个数字组成，多个数字间用分号分隔</li><li>函数名为需要调用的CSI函数功能名称</li></ul><div class="show">如：<span class="strong">\e[0;4;34m</span># \e[ 为转义字符引导头# m为函数名# 0;4;34为函数参数，相当于 m(0,4,34)</div><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>CSI提供了很多用于光标控制、屏幕控制、字符渲染的函数</p><h5 id="光标控制"><a href="#光标控制" class="headerlink" title="光标控制"></a>光标控制</h5><div class="table"><table><thead><tr><th>函数</th><th>举例</th><th>功能</th></tr></thead><tbody><tr><td>A</td><td>\e[nA</td><td>光标上移n行(默认1)</td></tr><tr><td>B</td><td>\e[nB</td><td>光标下移n行(默认1)</td></tr><tr><td>C</td><td>\e[nC</td><td>光标左移n行(默认1)</td></tr><tr><td>D</td><td>\e[nD</td><td>光标右移n行(默认1)</td></tr><tr><td>E</td><td>\e[nE</td><td>光标下移n行(默认1)，非标准</td></tr><tr><td>F</td><td>\e[nF</td><td>光标上移n行(默认1)，非标准</td></tr><tr><td>G</td><td>\e[nG</td><td>光标移动至当前行的n列，非标准</td></tr><tr><td>H</td><td>\e[x;yH</td><td>光标移动到x行y列</td></tr><tr><td>s</td><td>\e[s</td><td>保存光标位置</td></tr><tr><td>u</td><td>\e[u</td><td>取出光标位置</td></tr><tr><td>l</td><td>\e[?25l</td><td>隐藏光标</td></tr><tr><td>h</td><td>\e[?25h</td><td>显示光标</td></tr></tbody></table></div><h5 id="屏幕控制"><a href="#屏幕控制" class="headerlink" title="屏幕控制"></a>屏幕控制</h5><div class="table"><table><thead><tr><th>函数</th><th>举例</th><th>功能</th></tr></thead><tbody><tr><td>J</td><td>\e[nJ</td><td>清除指定范围内的屏幕，0为光标位置到屏幕末尾，1为光标位置到屏幕开头，2为全屏幕</td></tr><tr><td>K</td><td>\e[nK</td><td>清除该行的指定范围，0为光标到行尾，1为光标至行头，2为整行</td></tr><tr><td>S</td><td>\e[nS</td><td>整页向上滚动n行，非标准</td></tr><tr><td>T</td><td>\e[nT</td><td>整页向下滚动n行，非标准</td></tr></tbody></table></div><h4 id="修改字体样式"><a href="#修改字体样式" class="headerlink" title="修改字体样式"></a>修改字体样式</h4><p>终端中最为常用的转义序列还是用于修改终端字体颜色、背景颜色和显示效果的函数和参数，即SGR(Set graphics mode)函数<span class="tips">m</span>，常用于配合echo语句输出不同样式的提示信息，修改终端样式的转义字符序列一般为：<br><span class="strong">\e[参数m</span></p><p>在指定多个参数时，转义字符序列通常为：<br><span class="strong">\e[<span class="text-red" style="margin:0">字体样式;</span><span class="text-green" style="margin:0">字体颜色;</span><span class="text-blue" style="margin:0">背景色</span>m</span></p><p>参数不分先后顺序，指定多个同类样式时，后面的样式将覆盖前面的样式(如：指定多个背景色，只有最后一个背景色会生效)</p><div class="show">1.输出红色字符串 "RedColor"echo -e "\e[31mRedColor \e[0m"2.输出高亮、红色字体、背景为淡黄色的字符串"aaa"echo -e "\e[1;31;103maaaa\e[0m"# 末尾的\e[0m用于删除所有设置的属性(包括颜色、加粗、闪烁等效果)使后续输出内容恢复默认属性# \e可替换为\033或\x1B</div><h5 id="恢复默认"><a href="#恢复默认" class="headerlink" title="恢复默认"></a>恢复默认</h5><p><span class="strong">\e[0m</span>表示取消所有设置的属性(包括颜色、加粗、闪烁等效果)，使后续输出内容恢复默认属性</p><h5 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h5><div class="table"><table><thead><tr><th>设置效果代码</th><th>效果</th><th>取消效果代码</th></tr></thead><tbody><tr><td>1</td><td>加粗高亮</td><td>21</td></tr><tr><td>2</td><td>变暗(未被广泛支持)</td><td></td></tr><tr><td>3</td><td>斜体(未被广泛支持)</td><td></td></tr><tr><td>4</td><td>下划线</td><td>24</td></tr><tr><td>5</td><td>缓慢闪烁,低于每分钟150次</td><td>25</td></tr><tr><td>6</td><td>快速闪烁，每分钟150次以上(未被广泛支持)</td><td></td></tr><tr><td>7</td><td>反转背景色和前景色</td><td>27</td></tr><tr><td>8</td><td>隐藏，常用于密码(未被广泛支持)</td><td>28</td></tr><tr><td>9</td><td>划掉文字(未被广泛支持)</td><td></td></tr><tr><td>10</td><td>默认字体</td><td></td></tr><tr><td>11-19</td><td>替代字体</td><td></td></tr><tr><td>20</td><td>尖角体</td><td></td></tr></tbody></table></div><h5 id="字体颜色-前景色"><a href="#字体颜色-前景色" class="headerlink" title="字体颜色(前景色)"></a>字体颜色(前景色)</h5><p>以下颜色在不同终端中被定义了不同的RGB值，且没有一个通用标准，因此不同终端中的样式可能有所不同，详情可参考：<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit">ANSI escape code</a></p><div class="table"><table><thead><tr><th>代码</th><th>颜色</th><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>39</td><td>默认颜色</td><td></td><td></td></tr><tr><td>30</td><td>黑色</td><td>90</td><td><span style="color:rgb(128,128,128)">灰色</span></td></tr><tr><td>31</td><td><span style="color:rgb(170,0,0)">红色</span></td><td>91</td><td><span style="color:rgb(255,0,0)">亮红色</span></td></tr><tr><td>32</td><td><span style="color:rgb(0,170,0)">绿色</span></td><td>92</td><td><span style="color:rgb(0,255,0)">亮绿色</span></td></tr><tr><td>33</td><td><span style="color:rgb(255,199,6)">黄色</span></td><td>93</td><td><span style="color:rgb(255,255,0)">亮黄色</span></td></tr><tr><td>34</td><td><span style="color:rgb(0,0,238)">蓝色</span></td><td>94</td><td><span style="color:rgb(59,120,255)">亮蓝色</span></td></tr><tr><td>35</td><td><span style="color:rgb(205,0,205)">品红</span></td><td>95</td><td><span style="color:rgb(255,0,255)">亮品红色</span></td></tr><tr><td>36</td><td><span style="color:rgb(0,205,205)">青色</span></td><td>96</td><td><span style="color:rgb(0,255,255)">亮青色</span></td></tr><tr><td>37</td><td><span style="color:rgb(204,204,204)">白色</span></td><td>97</td><td>亮白色</td></tr></tbody></table></div><h5 id="字体背景色"><a href="#字体背景色" class="headerlink" title="字体背景色"></a>字体背景色</h5><p>每一个颜色都和上面相同，只是他们将作为背景色使用</p><div class="table"><table><thead><tr><th>代码</th><th>颜色</th><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>49</td><td>默认颜色</td><td></td><td></td></tr><tr><td>40</td><td>黑色</td><td>100</td><td>灰色</td></tr><tr><td>41</td><td>红色</td><td>101</td><td>亮红色</td></tr><tr><td>42</td><td>绿色</td><td>102</td><td>亮绿色</td></tr><tr><td>43</td><td>黄色</td><td>103</td><td>亮黄色</td></tr><tr><td>44</td><td>蓝色</td><td>104</td><td>亮蓝色</td></tr><tr><td>45</td><td>品红</td><td>105</td><td>亮品红色</td></tr><tr><td>46</td><td>青色</td><td>106</td><td>亮青色</td></tr><tr><td>47</td><td>白色</td><td>107</td><td>亮白色</td></tr></tbody></table></div><h5 id="修改文件目录颜色"><a href="#修改文件目录颜色" class="headerlink" title="修改文件目录颜色"></a>修改文件目录颜色</h5><p>想在使用ls命令后使各种不同类型文件显示不同颜色，参考dircolors命令</p><h4 id="OSC序列"><a href="#OSC序列" class="headerlink" title="OSC序列"></a>OSC序列</h4><p>OSC(Operating System Command)是一类用于执行操作系统级别命令的控制序列，通常用来设置终端标题，或与系统剪贴板进行交互等。OSC和CSI都是ANSI转义序列的一部分，其中CSI是C1控制字符集的一部分，而OSC是独立的多字符集合，不属于C1控制字符集</p><p>与CSI字符序列语法类似，OSC序列也是以<span class="tips">ESC</span>开头，随后，OSC序列后紧接一个<span class="tips">]</span>，后接一个数字标识符，然后是一个命令或参数，最后以<span class="tips">\a</span>(BEL)或<span class="tips">\e\</span>(ESC+\)结尾，完整的OSC语法为：<br><span class="text-red" style="margin:0">\e]</span><span class="text-blue" style="margin:0">函数标识值;</span><span class="text-green" style="margin:0">参数1;参数2;参数3…</span><span class="text-red" style="margin:0">\a</span></p><ul><li>\e]是OSC控制序列的引导头</li><li>函数值功能参考下表</li><li>\a 标识控制序列结束</li></ul><h4 id="OSC函数值"><a href="#OSC函数值" class="headerlink" title="OSC函数值"></a>OSC函数值</h4><p>OSC字符序列也可以修改终端的文本颜色，背景色等样式，与CSI不同的是，OSC字符序列控制的是全局的终端样式，而CSI序列只修改跟随在CSI后的文本样式，而不会修改已经输出完毕的文本样式。但OSC在一些终端中(尤其远程终端中)只支持修改终端窗口的标题等，而不支持修改光标、文本颜色等样式</p><div class="table"><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>更改窗口标题和标签栏标题</td></tr><tr><td>1</td><td>设置终端窗口的图标名</td></tr><tr><td>2</td><td>仅更改窗口标题</td></tr><tr><td>10</td><td>更改字体颜色(前景色)</td></tr><tr><td>11</td><td>更改背景色</td></tr><tr><td>12</td><td>更改光标颜色</td></tr><tr><td>52</td><td>将文本写入剪贴板</td></tr><tr><td>104</td><td>重置所有颜色</td></tr></tbody></table></div><div class="show">以下OSC序列只会临时修改终端设置，在命令执行完毕后可能会立即恢复终端默认样式，以至于无法查看到样式变化，如果需要通过OSC长久修改终端标题等设置，请修改<span class="tips">PS1</span>变量的值1.更改窗口标题和标签栏标题echo -e "\e]0;新标题\a"2. 仅更改窗口标题echo -e "\e]2;新的窗口标题\a"3.更改字体颜色为#00ff00echo -e "\e]10;#00ff00\a"4.更改光标颜色为#ff00ffecho -e "\e]12;#ff00ff\a"</div><h4 id="修改命令提示符"><a href="#修改命令提示符" class="headerlink" title="修改命令提示符"></a>修改命令提示符</h4><p>默认情况下的命令提示符通常为<span class="tips">[用户名@主机名 当前目录]主提示符</span>(不同Linux发行版可能有所不同)，如：[root@localhost etc]#，该默认值由系统定义的变量<span class="tips">PS1</span>决定，可通过<span class="strong">echo $PS1</span>&emsp;查看当前配置，也可以通过修改PS1变量自定义命令提示符，如：</p><div class="show">PS1='[\u@\t \w]#'命令提示符将修改为：[root@15:21:13 /home/user1]#</div><p>通过修改PS1变量自定义的命令提示符，只在本次登录有效，系统重启后将失效，需要永久修改命令提示符，可以将上述语句写入配置文件<span class="tips">/etc/bashrc</span>中，若只想修改某个用户的终端，可以修改该用户家目录下的<span class="tips">.bashrc</span>配置文件中的PS1变量，修改完后可以使用<span class="tips">source 文件名</span>命令重新加载配置文件，使配置立即生效</p><h6 id="修改命令提示符文本颜色"><a href="#修改命令提示符文本颜色" class="headerlink" title="修改命令提示符文本颜色"></a>修改命令提示符文本颜色</h6><p>修改命令提示符文本颜色时，PS1变量值中的CSI语法需要使用<span class="tips">[ ]</span>进行包裹，并且”[ ]”需要使用转义字符进行转义，避免bash解析其中的语法，即语法为：</p><p><span class="strong">\[\e[颜色码m\]</span></p><div class="shell">如在/etc/bashrc文件最后一行添加语句：PS1='\[\e[0m\][\[\e[36m\]\u\[\e[34m\]@\h \[\e[36m\]\W\[\e[0m\]]\[\e[95m\]#\[\e[0m\]'终端提示符将变为：[<span style="color:#0cf8fc;">root</span><span style="color:#0c8afc;">@myLinux</span> <span style="color:#0cf8fc;">etc</span>]<span style="color:#fc0ce6;">#</span></div><p>以下是自定义命令提示符时常用的转义字符：</p><div class="table"><table><thead><tr><th>转义符</th><th>作用</th></tr></thead><tbody><tr><td>\u</td><td>显示当前用户名</td></tr><tr><td>\h</td><td>显示简写主机名(不包含域名，该值来自<span class="tips">/etc/hostname</span>文件)</td></tr><tr><td>\H</td><td>显示完整的主机名(通常包括域名)</td></tr><tr><td>\w</td><td>显示当前所在路径的完整名称</td></tr><tr><td>\W</td><td>显示当前所在目录(路径的最后一个路径段)</td></tr><tr><td>\#</td><td>显示本次会话已经执行的命令个数</td></tr><tr><td>\$</td><td>显示命令主提示符，root用户提示符为”#”，普通用户为”$”</td></tr><tr><td>\d</td><td>显示当前系统日期，格式为”星期 月 日”</td></tr><tr><td>\t</td><td>显示24小时制时间，格式为”HH:MM:SS”</td></tr><tr><td>\T</td><td>显示12小时制时间，格式为”HH:MM:SS”</td></tr><tr><td>\A</td><td>显示24小时制时间，格式为”HH:MM”</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\[ 和 \]</td><td>用于定义非打印字符的开始和结束(主要用于设置颜色，避免光标定位错误)</td></tr></tbody></table></div><h4 id="终端标题"><a href="#终端标题" class="headerlink" title="终端标题"></a>终端标题</h4><p>虽然<span class="tips">PS1</span>主要用于控制终端的命令提示符，但我们可以在PS1中嵌入OSC转义序列来控制终端的标题。与CSI类似，PS1变量值中的OSC序列也需要使用<span class="tips">[ ]</span>进行包裹，并且”[ ]”需要使用转义字符进行转义，避免bash解析其中的语法</p><div class="show">1.某个debian发行版的默认PS1值PS1="\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$"其中：\[\e]0;\u@\h: \w\a\]为OSC序列，定义终端标题${debian_chroot:+($debian_chroot)}用于在命令提示符中提示用户当前是否处于chroot环境2.修改终端标题PS1='\[\e]0;终端标题\a\]\t@debian\$'</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>PS1的字符串值请用单引号或双引号包裹，否则可能出现Bash解析错误的情况</div><h4 id="本地终端登录前的欢迎信息"><a href="#本地终端登录前的欢迎信息" class="headerlink" title="本地终端登录前的欢迎信息"></a>本地终端登录前的欢迎信息</h4><p>需要修改本地终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue</span>，配置文件中可使用的转义字符：</p><div class="table"><table><thead><tr><th>转义符</th><th>作用</th></tr></thead><tbody><tr><td>\d</td><td>显示当前系统日期</td></tr><tr><td>\t</td><td>显示当前系统时间</td></tr><tr><td>\s</td><td>显示操作系统名称</td></tr><tr><td>\l</td><td>显示登录的终端号</td></tr><tr><td>\m</td><td>显示硬件架构信息，如i386等</td></tr><tr><td>\n</td><td>显示主机名</td></tr><tr><td>\o</td><td>显示域名</td></tr><tr><td>\r</td><td>显示内核版本</td></tr><tr><td>\u</td><td>显示当前用户登录的序列号</td></tr></tbody></table></div><div class="show">最小化安装的Centos7默认配置通常为：\SKernel \r on an \m</div><h4 id="远程终端登录前的欢迎信息"><a href="#远程终端登录前的欢迎信息" class="headerlink" title="远程终端登录前的欢迎信息"></a>远程终端登录前的欢迎信息</h4><p>修改远程终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue.net</span>，该文件不支持上述本地终端登录可用的转义字符，需要显示此欢迎信息，需要在配置文件<span class="tips">/etc/ssh/sshd_config</span>中加入<span class="tips">Banner /etc/issue.net</span>配置内容(需要重启生效)</p><div class="shell">/etc/ssh/sshd_config文件添加配置位置:#UseLogin no#UsePrivilegeSeparation sandbox#PermitUserEnvironment no#Compression delayed#ClientAliveInterval 0#ClientAliveCountMax 3#ShowPatchLevel no#UseDNS yes#PidFile /var/run/sshd.pid#MaxStartups 10:30:100#PermitTunnel no#ChrootDirectory none#VersionAddendum none<p># no default banner path<br>#Banner none<br><span style="color:rgb(232, 250, 0)">Banner</span><span style="color:rgb(250, 0, 136);"> /etc/issue.net</span></p><p># Accept locale-related environment variables</div></p><h4 id="终端登录成功后的提示信息"><a href="#终端登录成功后的提示信息" class="headerlink" title="终端登录成功后的提示信息"></a>终端登录成功后的提示信息</h4><p>配置文件位于<span class="tips">/etc/motd</span>(Message of the Day文件)，用于在远程和本地终端登录成功后显示提示信息，文件通常默认为空</p><p>在ubuntu中，登录提示文本MOTD通常是动态生成的，配置文件位于<span class="tips">/etc/update-motd.d/</span>中，包含一系列脚本，这些脚本会生成系统信息（如负载、内存使用等）并在登录时显示，脚本名前的数字表示脚本执行顺序，相同数字的脚本会按照脚本名字母顺序依次执行，执行顺序也决定了这些文本的显示顺序</p><div class="show">update-motd.d目录下可能会有以下脚本文件：00-header10-help-text....91-release-upgrade98-fsck-at-reboot如果需要自定义提示信息，可以在该目录下新建一个脚本，如：1. 创建一个脚本 99-custom2. 添加需要打印的信息<code>#!/bin/shecho "欢迎使用shiwivi的 Ubuntu 服务器！"</code>3. 给脚本添加可执行权限sudo chmod +x /etc/update-motd.d/99-custom<span class="tips">如果不想显示某个脚本的内容，可以通过修改文件名（例如在文件名中添加 .disabled）来禁用特定脚本，或者修改脚本中的输出语句</span></div>]]></content>
    
    
    <summary type="html">包括Linux中父子shell的创建、bash shell的内建命令、环境变量、终端配置等</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用工具命令</title>
    <link href="https://shiwei11.github.io/blog/2021/12/29/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/"/>
    <id>https://shiwei11.github.io/blog/2021/12/29/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/</id>
    <published>2021-12-29T02:06:10.000Z</published>
    <updated>2024-10-26T08:14:31.350Z</updated>
    
    <content type="html"><![CDATA[<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><h4 id="curl介绍"><a href="#curl介绍" class="headerlink" title="curl介绍"></a>curl介绍</h4><p>curl(client url)是一个强大且开源的数据传输工具，它支持通过URL上传或下载数据，适合用来执行上传或下载文件、执行API请求、提交表单数据等任务，curl支持以下协议：DICT、FILE、FTP、FTPS、GOPHER、GOPHERS、HTTP、HTTPS、IMAP、IMAPS、LDAPS、MQTT、POP3、POP3S、RTMP、RTMPS、RTSP、SCP、SFTP、SMB、SMBS、SMTP、SMTPS、TELNET、TFTP、WS、WSS。</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>curl官方文档：<a href="https://curl.se/docs/manpage.html" target="_blank">https://curl.se/docs/manpage.html</a></div><h4 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h4><div class="apiBox">curl [选项] URL1 URL2 ...</div><ul><li><p>默认情况下，curl会将接收到的数据(如：html文件、json文件)写到stdout，即直接打印在屏幕上</p></li><li><p>如果curl接收到的数据被-o选项或重定向符输出到stdout以外的地方，则curl默认会显示一个<span class="text-blue">进度表</span>，进度表会显示传输数据量、传输速度和估计剩余时间</p></li><li><p>-#或-&zwnj;-progress-bar 显示一个<span class="text-blue">进度条</span>，使用进度条替换进度表</p></li><li><p>-s 静默模式(silent)，不显示进度和错误信息，但仍会显示HTTP响应的内容，如返回的html、json等数据</p></li><li><p>-q 完全安静模式(quiet)，完全阻止所有输出，包括进度信息、错误信息、返回的响应信息</p></li><li><p><span class="strong">-&zwnj;-retry 值：</span>设置重试次数，该值默认为0，curl默认只会在响应超时、FTP返回4xx或HTTP返回408、429、500、502、503或504时进行重试，该选项可以搭配以下选项：</p><blockquote><blockquote><ul><li>-&zwnj;-retry-all -errors：出现任何错误时均重试，包括HTTP 404等情况</li><li>-&zwnj;-retry-delay 值：每一次重试前的延迟时间，单位为秒</li><li>-&zwnj;-retry-max-time 值：最大总重试时间，单位为秒，到达该时间后，即使还有剩余重试次数，也停止重试</li></ul></blockquote></blockquote></li><li><p>如果URL中不指定协议，curl会尝试解析主机名，如果主机名不包含任何协议，则默认使用http</p></li><li><p><span class="strong"> -o /路径/文件名</span>：将接收到的数据以<span class="tips">新文件名</span>保存到指定位置，文件不存在则会新建，文件存在则会覆盖</p></li><li><p>-O 将接收到的数据在当前路径下以<span class="tips">原文件名</span>保存(不会保存路径)，文件不存在则会新建，文件存在则会覆盖</p></li><li><p>-&zwnj;-no-clobber (7.83.0版本以上支持)使用-o等选项将传输的数据保存到本地时，如果文件已经存在原文件会被覆盖。该选项可以避免覆盖已经存在的文件，如果文件已经存在，curl会在新保存的文件名后加上一个点和一个数字(如：test.1)来生成不同的文件名，这只支持生成到test.100，之后curl将不创建任何文件</p></li><li><p>-k 默认情况下，curl 建立的连接都会进行验证(如验证TLS 证书)，此选项会让curl跳过验证步骤，这可能引发安全问题</p></li><li><p>-f 当请求的URL返回4xx响应码时，http服务一般会返回一个404页面文本，该选项可以禁止curl输出该数据，而是提前返回http错误码22，这在脚本中比较有用，脚本获取一个404相关的页面数据也没什么用，可以提前抛弃掉</p></li><li><p>-&zwnj;-fail-early 在指定多个URL时，curl会依次执行这些传输任务，默认情况下，curl命令的执行结果只取决于最后一个URL是否成功传输，如果中间的某个URL返回错误代码也会被覆盖。该选项会让curl在遇到第一次传输失败时就返回一个错误，方便捕捉错误</p></li><li><p>-:或-&zwnj;-next：用来重置所有本地选项，指定多个URL时如果要为不同的URL指定不同的选项，可以使用该选项重置之前指定的选项，该选项不会重置全局选项</p></li><li><p>-I 只获取响应头</p></li><li><p>-L 跟随重定向，当curl遇到服务器返回3XX响应码时，会前往重定向的新位置重做请求</p></li><li><p><span class="strong">-x [请求方法]</span> 指定HTTP请求方法（GET、POST、PUT、DELETE 等）</p></li><li><p><span class="strong">-T [文件]</span> 上传文件到指定URL</p></li></ul><div class="show">1. 默认情况下，curl会将下载的数据打印到屏幕curl test.shiwivi.com/mobileTest.html打印的html文件：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;title&gt;shiwivi&lt;/title&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;2. curl命令自带下载进度表，用来显示传输的数据量、传输速度和估计剩余时间等，并且会默认打印到stdout，但如果下载的数据也被输出到stdout，curl会自行禁用进度表，以免进度数据和下载数据都打印到stdout造成混乱。如果使用-o选项或重定向符将数据输出到了stdout以外的位置，stdout将显示进度表curl -o index.html test.shiwivi.com/mobileTest.html进度表的显示参数：% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100   184    0   184    0     0    351      0 --:--:-- --:--:-- --:--:--   352</div><h4 id="url通配"><a href="#url通配" class="headerlink" title="url通配"></a>url通配</h4><p>curl支持允许使用<span class="tips">大括号{}</span>、<span class="tips">中括号[]</span>来指定一个URL地址范围，此时需要使用<span class="tips">双引号””</span>来包裹URL地址，避免shell等程序解析这些字符</p><div class="show">1.支持使用{ }指定多个地址curl "http://test.{one,two,three}.com"2.支持使用[ ]来指定一个域名或文件名范围"http://test.example.com/file[1-100].txt""http://test.example.com/file[a-z].txt"可以为这个范围指定步进值"http://test.example.com/file[1-100:10].txt""http://test.example.com/file[a-z:2].txt"3.括号不能嵌套，但能并列使用多次"http://{css,js,img}.example.com/file[1-20:2].txt"{ }适合用来指定多个没有任何联系的离散独立值，[ ]适合用来指定一个范围值4.如果需要为每个下载的文件都另存并指定文件名，可以使用#加数字的形式来引用正在获取的URL字符串curl "http://{css,js,img}.example.com/file[1-20:2].txt" -o "file_#1_#2"也可以依次指定-o选项curl -o a.txt example1.com -o b.txt example2.com</div><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>wget(World Wide Web Get)是一个功能强大的命令行工具，用于从网络上下载文件和数据。它可以处理HTTP、HTTPS、FTP等协议，支持断点续传、递归下载、限速等功能，相较于curl，wget更像是一种专门用来下载文件的软件</p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>GNU社区的wget文档：<a href="https://www.gnu.org/software/wget/manual/wget.html">https://www.gnu.org/software/wget/manual/wget.html</a></div><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><span class="strong">wget [选项] URL</span></p><ul><li>默认情况下，wget命令会将文件保存到当前目录。下载时，wget命令会打印文件总大小、下载速度、下载进度等信息到stdout，且wget命令会默认自动处理HTTP重定向</li><li>-q 静默模式，不输出任何信息</li><li><span class="strong">-o 文件名</span> 将下载的文件以新文件名保存到指定位置</li><li><span class="strong">-O 文件名</span> 将wget命令输出的下载信息日志保存到指定文件，而不再打印到屏幕</li><li><span class="strong">-p 目录名</span>将文件下载到指定目录</li><li>-c 启用断点续传，继续下载暂停或中断的文件</li><li>-r 递归下载网站或目录中的所有文件</li><li><span class="strong">-l 值</span>设置递归下载的深度，通常和-r选项搭配使用，如：-r -l 1表示只下载当前目录的文件</li><li>-N 仅下载比本地文件新的文件(根据时间戳判断)，适合用来同步文件</li><li>-nd 不创建目录结构，将所有下载的文件都保存到当前目录</li><li><span class="strong">-i 文件名</span>从文件中读取URL，并依次下载</li><li><span class="strong">-&zwnj;-wait=值</span>设置文件下载的时间间隔，避免对服务器造成过大负载</li><li>-&zwnj;-random-wait 设置随机等待时间，模拟更自然的用户行为</li><li><span class="strong">–tries=值</span> 设置下载失败后的重试次数，默认为20次</li></ul><div class="show">1. 正常下载文件wget http://example.com/file.zip默认情况下，wget命令会打印以下信息：--2021-08-31 00:12:34--  http://shiwivi.com/Resolving shiwivi.com (shiwivi.com)... 170.196.108.153Connecting to shiwivi.com (shiwivi.com)|170.196.108.153|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 3355 (3.3K) [text/html]Saving to: ‘index.html.1’100%[===================>] 3,355       --.-K/s   in 0.1s    2021-08-31 00:12:37 (23.3 KB/s) - ‘index.html.1’ saved [3355/3355]2. 静默模式wget -q http://example.com/file.zip</div><h3 id="mkpasswd密码生成"><a href="#mkpasswd密码生成" class="headerlink" title="mkpasswd密码生成"></a>mkpasswd密码生成</h3><p>mkpasswd有两个同名软件，一个用来生成随机密码，一个用来加密用户密码</p><h4 id="生成随机密码"><a href="#生成随机密码" class="headerlink" title="生成随机密码"></a>生成随机密码</h4><p>expect 包中mkpasswd 用来生成指定长度的随机密码，可以指定密码中数字、大小写英文字母和特殊字符的个数</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>mkpasswd 是 expect 包中的一个脚本，使用前需要安装expect包</p><ul><li>Red Hat系列操作系统<pre><code>sudo yum install expect</code></pre></li><li>Debian系列操作系统<pre><code>sudo apt-get install expect</code></pre></li></ul><h5 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h5><p><span class="strong">mkpasswd [选项]</span></p><ul><li>-l 值：指定生成的密码长度，默认值为9</li><li>-d 值：指定数字个数，默认值为2</li><li>-c 值：指定小写字母的个数，默认值为2</li><li>-C 值：指定大写字母的个数，默认值为2</li><li>-s 值：指定特殊字符的个数，默认值为1</li></ul><div class="show">1. 随机生成一个20位的密码mkpassed -l 202. 随机生成一个20位的密码，包含4位数字mkpasswd -l 20 -d 4</div><h4 id="加密用户密码"><a href="#加密用户密码" class="headerlink" title="加密用户密码"></a>加密用户密码</h4><p> whois 包中的 mkpasswd 是一个在 Linux 和 Unix 系统中生成加密密码的工具。它常用于加密用户密码，特别是在涉及到 /etc/shadow 文件或其他需要加密密码的场景下。mkpasswd 工具可以生成各种哈希算法加密的密码，如 MD5、SHA-256、SHA-512 等。</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>在一些 Linux 发行版中，mkpasswd 是 whois 包的一部分。如果系统上没有 mkpasswd，可以通过包管理器安装 whois 包：</p><ul><li><p>基于 Red Hat 的系统（如 CentOS、Fedora）</p><pre><code>sudo yum install whois</code></pre></li><li><p>基于 Debian 的系统（如 Ubuntu）</p><pre><code>sudo apt-get install whois</code></pre></li></ul><h5 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h5><p><span class="strong">mkpasswd [选项] [密码] [盐值]<br></span></p><ul><li>可以输入一个需要加密的明文密码</li><li>盐值可选，可以添加到密码中以增强哈希的安全性</li><li>默认使用MD5算法</li><li>-m 算法：指定一个加密算法，如：sha-512，sha-256，md5等</li></ul><div class="show">1. 使用 SHA-512 生成加密密码mkpasswd -m sha-512 mypassword2. 生成一个使用 SHA-512 加密的密码，并指定一个盐值mkpasswd -m sha-512 "password123" "randomsalt"</div><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>linux中的time命令通常提供了两个，一个是bash内置的time命令，用来查看目录所消耗的时间。还有一个为外部工具，命令路径为<span class="tips">/usr/bin/time</span>，功能更为强大，可以查看命令所消耗的资源，包括内存使用情况</p><p>通过type命令可以看到两个命令的来源</p><div class="shell">[root@Linux ~]# type -a timetime is a shell keywordtime is /usr/bin/time</div><h4 id="bash内建的time"><a href="#bash内建的time" class="headerlink" title="bash内建的time"></a>bash内建的time</h4><p><span class="strong">time [选项] 命令</span></p><ul><li>-o 文件名：将输出写入指定文件，如果已有该文件则覆盖</li><li>-a 配合-o使用，将命令输出追加到文件末尾，而不是覆盖</li><li>-p 以POSIX标准格式输出时间信息</li></ul><div class="show">查看ls命令所消耗的时间time ls输出值为：real    0m0.002s  #真实时间user    0m0.002s  #用户时间sys    0m0.000s      #系统时间</div><h4 id="外部time工具"><a href="#外部time工具" class="headerlink" title="外部time工具"></a>外部time工具</h4><p><span class="strong">/usr/bin/time [选项] 命令</span></p><ul><li>-o 文件名：将输出写入指定文件，如果已有该文件则覆盖</li><li>-a 配合-o使用，将命令输出追加到文件末尾，而不是覆盖</li><li>-p 以POSIX标准格式输出时间信息</li><li>-v 详细输出命令所消耗的时间、内存等信息</li></ul><div class="show">查看命令所消耗时间的输出信息与bash内置的time命令一样，但bin目录下的time工具额外提供了-v选项用来详细输出系统资源消耗/usr/bin/time ls输出值通常包括时间、最大内存使用、进程数量、页面错误、退出状态码等Command being timed: "ls"    User time (seconds): 0.00    System time (seconds): 0.00    Percent of CPU this job got: 100%    Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.00    Average shared text size (kbytes): 0    Average unshared data size (kbytes): 0    Average stack size (kbytes): 0    Average total size (kbytes): 0    Maximum resident set size (kbytes): 1116    Average resident set size (kbytes): 0    Major (requiring I/O) page faults: 0    Minor (reclaiming a frame) page faults: 336    Voluntary context switches: 1    Involuntary context switches: 1    Swaps: 0    File system inputs: 0    File system outputs: 0    Socket messages sent: 0    Socket messages received: 0    Signals delivered: 0    Page size (bytes): 4096    Exit status: 0</div>]]></content>
    
    
    <summary type="html">包含curl,wget,mkpasswd,time等命令的使用</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>sed与awk</title>
    <link href="https://shiwei11.github.io/blog/2021/12/29/LinuxSed%E4%B8%8EAwk/"/>
    <id>https://shiwei11.github.io/blog/2021/12/29/LinuxSed%E4%B8%8EAwk/</id>
    <published>2021-12-29T02:05:10.000Z</published>
    <updated>2024-12-03T05:23:31.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sed流编辑器"><a href="#sed流编辑器" class="headerlink" title="sed流编辑器"></a>sed流编辑器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>sed被称为流编辑器（stream editor），是Linux和Unix系统中一个强大的文本处理工具。它被设计用于大批量的文本处理，可以逐行读入文本，并根据命令进行字符串的查找、筛选、移动、替换、添加和删除等操作。sed非常适合对大量文本进行批处理，也适合在脚本中进行自动化文本处理。</p><p>与交互式编辑器(如vim)不同，vim等编辑器适合用来进行交互式编辑和细粒度的文本修改，而流编辑器适合用来进行大批量的非交互式文本处理，适合执行自动化文本处理任务，如进行批量文件修改、数据清洗、日志文件分析等。</p><h5 id="sed的工作流程"><a href="#sed的工作流程" class="headerlink" title="sed的工作流程"></a>sed的工作流程</h5><p>sed强调逐行处理文本，默认情况下，sed编辑器会基于换行符的位置将文本流分成行，以一行文本作为一个处理单位，sed编辑器对文本的处理会在一个名为<span class="tips">模式空间</span>(pattern space)的临时缓冲区中进行，sed编辑器在工作时会依次执行以下流程：</p><ul><li><span class="strong">读取</span>：sed首先会从文件、管道、标准输入等输入流中读取一行内容并存储到模式空间</li><li><span class="strong">执行</span>：根据用户提供的命令在行中匹配数据，并按照命令增删改查，默认情况下，所有sed操作命令会在模式空间中按顺序执行</li><li><span class="strong">打印</span>：字符串行在模式空间中被处理完后，默认会将结果输出到屏幕，然后清空模式空间，然后读取下一行文本</li></ul><p>具体执行过程为：sed首先会从输入流中(可以是来自文件、管道、标准输入设备的文本流)读取一行内容并存储到模式空间，然后按照命令顺序对满足要求的文本进行处理，不满足要求的文本也会被读入模式空间，但sed不做任何处理，随后这些文本会被发送到输出流显示给用户，sed编辑器会随之清空模式空间中的内容，然后读取下一行文本重复执行上述操作，直到文本流中的所有行被处理完毕。默认情况下，sed命令会对所有行都生效，但可以通过指定行号、模式匹配等方式指定命令只对某些行生效，sed编辑器默认会将所有文本行输出到屏幕，即便编辑器没有修改任何原文本的内容(如：指定某个命令只对第2行文本生效，但其他行的内容依旧会被sed编辑器打印到屏幕上)，且sed命令的文本处理操作都是在缓冲区中进行的，默认不会对原文件内容进行修改。sed编辑器还支持将操作命令存储于一个单独的文件(通常拓展名为<span class="tips">.sed</span>)中，然后从文件中批量加载命令。</p><h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p><span class="strong">sed [选项] ‘文本处理命令’ [处理的文件]</span></p><ul><li>-e 命令：指定多个命令</li><li>-f 文件名：从该文件中载入处理命令</li><li>-n 不打印命令的默认输出</li><li>-i 直接修改原文件，不输出到终端</li><li>-r 支持拓展的正则表达式，某些版本中为-E，具体可以man sed查看支持哪一个选项</li><li>如果不指定处理文件，sed会从标准输入STDIN读取数据</li><li>文本处理命令如果直接在命令行中指定，则需要加上一对单引号<span class="strong tips">‘ ‘</span>，这样shell就不会将其解析为shell的特殊字符或命令，并且shell会将其视为sed命令的单个参数，允许文本处理命令的长度超过一行，如果命令写于文件中不需要使用单引号。如果sed文本处理命令中需要调用外部变量，可以使用双引号<span class="tips">“”</span>(类似于在字符串中引用变量)</li></ul><h5 id="文本处理命令"><a href="#文本处理命令" class="headerlink" title="文本处理命令"></a>文本处理命令</h5><p>文本处理命令是sed命令的关键部分，告诉sed编辑器要处理哪些文本，以及如何处理文本。sed可以输入单个命令，也支持一次性指定多个命令，它会依次执行这些命令。</p><p><span class="strong">单行模式</span>下，多个命令之间使用分号<span class="tips strong">;</span>分隔即可</p><div class="show">e.g.文件test.txt包含以下内容，使用字符串"周杰伦"替换"Jay Chou"，使用"陈奕迅"替换"Eason Chan"These are my favorite singers Jay Chou and Eason ChanThese are my favorite singers Jay Chou and Eason ChanThese are my favorite singers Jay Chou and Eason Chan单行模式下指定多个命令，命令之间使用分号分隔<span class="text-red">sed 's/Jay Chou/周杰伦/; s/Eason Chan/陈奕迅/' test.txt</span>也可以使用<span class="tips">-e</span>选项，分开指定命令，使命令更具可读性和清晰度<span class="text-green">sed -e 's/Jay Chou/周杰伦/' -e 's/Eason Chan/陈奕迅/' test.txt</span></div><p><span class="strong">多行模式</span>下，命令之间的分号可以省略</p><div class="show">多行模式下指定多个命令，可以不使用分号，但单引号必须保留<span class="text-blue">sed '&gt;s/Jay Chou/周杰伦/&gt;s/Eason Chan/陈奕迅/' test.txt</span></div><p><span class="strong">从文件调用：</span>如果处理命令较多或需要反复调用，可以将这些命令写于一个命令文件中，每条命令写一行，sed编辑器会将每行都识别为一个单独的命令。存放sed命令的文件通常使用<span class="tips">.sed</span>作为文件扩展名，然后通过<span class="tips">-f</span>选项输入sed编辑器，命令之间的分号可以省略，且命令不使用单引号包裹</p><div class="show"><span class="text-red">sed -f script.sed test.txt</span><span class="strong">script.sed文件内容：</span>s/Jay Chou/周杰伦/s/Eason Chan/陈奕迅/</div><h5 id="文本输入方式"><a href="#文本输入方式" class="headerlink" title="文本输入方式"></a>文本输入方式</h5><p>不指定处理文件时，sed会从标准输入STDIN读取数据，在输入完sed命令后按下回车，sed编辑器会开始等待文本输入，每输入一行文本sed编辑器就处理一行，并实时打印处理结果，直到使用Ctrl+D结束输入，或使用Ctrl+C终止任务。</p><div class="show">e.g.将所输入字符串中的A替换为ased 's/A/a/' <span class="text-red">(回车)</span>Ajax   <span class="text-blue">#用户输入</span>ajax   <span class="text-green">#sed编辑器输出结果</span>APACHE <span class="text-blue">#用户输入</span>aPACHE <span class="text-green">#sed编辑器输出结果</span><span class="text-red">(Ctrl+D结束输入，退出sed编辑器)</span></div><p>也可以通过管道符<span class="tips">|</span>将文本输入sed编辑器</p><div class="show">如果直接在sed命令行输入文本，sed编辑器会将其识别为文件名，然后返回错误：No such file or directory因此，通过以下语句输入文本到sed编辑器中的方法都是错误的：sed 's/A/a/' Ajaxsed 's/A/a/' "Ajax"如果需要直接用sed编辑器处理单行或多行文本，可以考虑使用管道符：e.g.使用s命令将输出中的old替换为not old，s命令的功能是使用斜线后的第二个字符串替换第一个字符串echo "This is old song" | sed 's/old/not old/'</div><p>当需要处理大量文本时，可以将文本写入文件中，sed命令会以每行作为一个单位，依次读取文件内容并处理，<span class="tips">但注意：默认情况下，Sed编辑器只会将模式空间中处理完毕的数据发送到屏幕STDOUT，而不会修改原文件中的数据</span></p><div class="show">e.g.从文件test.txt读取内容并进行文本操作sed 's/A/a/' test.txt</div><h4 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h4><p>由于在sed命令中，斜线<span class="tips">/</span>被用作命令字符串的分隔符，因此如果在命令中包含了诸如文件路径等需要用到斜线的参数，需要使用转义字符<span class="tips">\</span>对其进行转义。此外，sed编辑器也支持使用其他字符作为替换命令中的字符串分隔符，如使用<span class="tips">?</span>、<span class="tips">!</span>等</p><div class="show">e.g.用C shell替换/etc/passwd文件中的bash shellsed -n 's?/bin/bash?/bin/csh?p' /etc/passwd或sed -n 's!/bin/bash!/bin/csh!p' /etc/passwd也可以使用转义字符sed -n 's/\/bin\/bash/\/bin\/csh/p' /etc/passwd</div><h4 id="在sed中调用外部变量"><a href="#在sed中调用外部变量" class="headerlink" title="在sed中调用外部变量"></a>在sed中调用外部变量</h4><p>如果在使用sed时需要调用环境变量，或者在shell脚本中，sed要调用脚本中定义的变量，需要注意以下：</p><ul><li>由于单引号中无法调用变量，因此sed的命令部分需要使用双引号<span class="tips">“”</span>来包裹，这样才能使用<span class="tips">$变量名</span>来调用变量</li><li>如果变量中包含<span class="tips">/</span>等字符，需要将sed命令的分隔符修改为其他字符</li></ul><div class="show">e.g.需要在sed命令中调用PATH变量由于PATH环境变量的值包含/，如：PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin"如果直接执行命令：sed "s/aaa/${PATH}/" config.jsonsed会将PATH值中的/解析为命令字符串分隔符，从而出错，需要将sed命令修改为：sed "s|aaa|${PATH}|" config.json</div><h4 id="通过-i选项修改文件"><a href="#通过-i选项修改文件" class="headerlink" title="通过-i选项修改文件"></a>通过-i选项修改文件</h4><p>相较于awk，sed编辑器提供了<span class="tips">-i</span>(in-place)选项可以直接修改原文件内容，完整的语法格式为：<br><span class="strong">sed -i[备份文件名] ‘文本处理命令’ 原文件</span></p><ul><li>指定-i选项后，所有sed处理完的文本流将被重定向到文件中，而不再打印到屏幕。此时即便再添加p等打印命令，也不会输出任何内容到屏幕，反而会多输出一行相同内容到文件，因此修改文件时不要使用p等打印命令，除非明确需要打印行号等信息到文件</li><li>-i选项可以接收一个字符串参数，此时sed会将原文件以<span class="tips">原文件名备份文件名</span>作为文件名，进行一次备份，然后再修改原文件</li></ul><div class="show">e.g.将原文件data.txt备份一份为data.txt.bak，然后修改data.txt文件中的aaa为bbb，sed -i.bak 's/aaa/bbb/g' data.txte.g.修改配置文件中的端口号<span class="strong">config.json文件：</span>{        "ip": "88.77.99.88"        "port": 2100,}<span class="strong">modifyPort.sh文件：</span>#!/bin/bashconfigFile="/usr/local/myServer/config.json"newPort=2200if [ -f "${configFile}" ];thensed -i[.bak] "/port/s/\([^0-9]*\)[0-9]*\(.*\)/\1${newPort}\2/" ${configFile}fi</div><h4 id="行寻址"><a href="#行寻址" class="headerlink" title="行寻址"></a>行寻址</h4><p>默认情况下，sed编辑器的命令会作用于文本数据的所有行。如果只想将命令作用于某些特定行，则可以用行寻址，行寻址的方式有两种：</p><ul><li>用数字指定行号</li><li>使用正则表达式进行模式匹配</li></ul><p>两种方式的语法都相同，直接将行地址加于命令前即可：<br><span class="strong">sed ‘<span class="text-blue" style="margin:0;">行地址</span><span class="text-green" style="margin:0;">命令</span>‘ [文件名]</span><br>如果需要为某个地址指定多个命令，可以使用大括号进行分组：<br><span class="strong">sed ‘<span class="text-blue" style="margin:0;">行地址</span>{<span class="text-green" style="margin:0;">命令1</span>;<span class="text-green" style="margin:0;">命令2</span>;…..}’ [文件名]</span></p><h5 id="使用数字指定行号"><a href="#使用数字指定行号" class="headerlink" title="使用数字指定行号"></a>使用数字指定行号</h5><p>sed编辑器会将文本的第一行的行号设定为1，随后依次递增，可以直接使用行号指定命令在哪些行生效。可以直接使用单个行号，也可以通过<span class="tips">起始行,终止行</span>的方式选定一个区间，如果不清楚某个文件到底有多少行，可以使用<span class="tips">起始行,$</span>方式选定从某行开始的所有行。</p><div class="show">e.g.替换data.txt文件中第二行的指定字符串sed '2s/AAA/替换内容/' data.txt替换2到4行的匹配字符串sed '2,4s/AAAA/替换内容/' data.txt替换第2开始的所有行中的匹配的字符串sed '2,$s/AAAA/替换内容/' data.txt</div><h5 id="使用正则表达式匹配行"><a href="#使用正则表达式匹配行" class="headerlink" title="使用正则表达式匹配行"></a>使用正则表达式匹配行</h5><p>使用行号只能选取特定位置的行，如果需要根据内容筛选出对应行，如查找包含指定内容的行，并对该行进行处理，则需要使用正则表达式筛选出指定行，其语法为：<br><span class="strong">sed ‘<span class="text-blue" style="margin:0;">/正则表达式/</span><span class="text-green" style="margin:0;">命令</span>‘</span></p><p>也可以指定一个区间：<br><span class="strong">sed ‘<span class="text-blue" style="margin:0;">/正则表达式1/,/正则表达式2/</span><span class="text-green" style="margin:0;">命令</span>‘</span></p><p>命令会在正则表达式1匹配到内容时，从该行开始执行(开启命令执行)，直到正则表达式2匹配到内容的行为止(关闭命令执行)，如果只匹配到正则表达式1(开启)，而正则表达式2无匹配的行，那么文件该行以后的所有行都将执行该命令(无关闭)</p><div class="show">e.g.选取data.txt文件中包含2222字符串的行，并替换该行中AAAA字符串为替换内容sed -n '/2222/s/AAAA/替换内容/p' data.txt</div><div class="show">e.g.文件data.txt含以下内容1111AA2222AA3333AA4444AA5555AA6666AA替换含字符串22行开始，到含字符串44行为止，中间所有行中的AA字符串为aased '/22/,/44/s/AA/aa/' data.txt输出为：1111AA2222aa3333aa4444aa5555AA6666AA如果将开始行和末尾行替换，命令将从第4行开始，一直执行到文件末sed '/44/,/22/s/AA/aa/' data.txt输出为：1111AA2222AA3333AA4444aa5555aa6666aa</div><p><span class="strong tips">命令分组：</span>如果为指定的行要执行多个命令，则可以使用大括号<span class="tips">{ }</span>将命令分组</p><div class="show">e.g.替换data.txt文件中的多个不同内容sed '2,${&gt; s/AAAA/替换内容/&gt; s/BBBB/OvO/}' data.txt</div><h4 id="打印命令p、-、l"><a href="#打印命令p、-、l" class="headerlink" title="打印命令p、=、l"></a>打印命令p、=、l</h4><p>sed提供了3个打印命令用于打印不同的信息：</p><ul><li><span class="strong">p</span>：打印文本行</li><li><span class="strong">=</span>：打印行号</li><li><span class="strong">l</span>：(小写L)打印文本和非打印字符(如制表符等)</li></ul><h5 id="打印文本"><a href="#打印文本" class="headerlink" title="打印文本"></a>打印文本</h5><p>打印命令p用于打印匹配到的字符串行。默认情况下，sed命令也会将模式空间中的内容打印到屏幕，因此通常将p命令与sed命令的-n选项搭配使用。先使用-n选项禁止sed命令的默认输出，再执行p命令打印匹配的字符串，这样终端上就只会显示我们需要的信息。</p><div class="show">e.g.打印包含指定字符串的行<span class="strong">data.txt文件内容：</span>1111AAA1112222AAA2223333333333如果直接执行命令sed '/AAA/p' data.txt则会输出显示以下内容：1111AAA111 #p命令打印1111AAA111 #sed编辑器默认打印2222AAA222 #p命令打印2222AAA222 #sed编辑器默认打印3333333333 #sed编辑器默认打印内容会被重复打印，即便文件第3行不包含字符串AAA，不满足命令执行要求，该行内容依旧会被sed编辑器读入模式空间，然后被默认打印出来，而满足执行要求的第一第二行文本则会打印两遍(p命令打印+sed默认打印)，因此，p命令通常会和-n选项搭配使用，使用-n取消sed编辑器的默认打印行为，然后使用p命令打印满足要求的字符串行：sed -n '/AAA/p' data.txt这样，sed编辑器输出值就是满足命令处理要求被筛选过的字符串行：1111AAA111 2222AAA222</div><div class="show">e.g.打印文件的某几行sed -n '2,3p' data.txt打印文件中包含某字符串的行sed -n '/AAA/p' data.txt通过p命令可以先打印字符串行被修改前的样子，再打印一次被修改后的养样子，方便比较sed -n '/AAA/{&gt;p&gt;s/AAA/aaa/p&gt;}' data.txt</div><h5 id="打印行号"><a href="#打印行号" class="headerlink" title="打印行号"></a>打印行号</h5><p>等号命令<span class="tips">=</span>会打印行在数据流中的当前行号。行号由数据流中的换行符决定。每次数据流中出现一个换行符，sed编辑器会认为一行文本结束了，行号默认从1开始。</p><div class="show">e.g.打印包含某字符串的行号，及其该行的完整内容sed -n '/AAA/{&gt;=&gt;p}' data.txt</div><h5 id="打印非打印字符"><a href="#打印非打印字符" class="headerlink" title="打印非打印字符"></a>打印非打印字符</h5><p>列出命令<span class="tips">l</span>(list)会打印数据流中的所有文本和不可打印的ASCII字符，这些非打印字符会以C语言转义字符的形式显示(如：\t水平制表符)，或显示其八进制ASCII码值，并会在前面添加反斜线。</p><div class="show">e.g.打印文件data.txt，文件内容包含\<span class="strong">data.txt文件内容：</span>1111    11112222 \  2222命令l会将制表符、\等需要转义的字符在文本中输出为转义字符形式，并使用$表示末尾换行sed 'l' data.txt输出形式为：1111\t1111$2222\\2222$</div><h4 id="替换命令s"><a href="#替换命令s" class="headerlink" title="替换命令s"></a>替换命令s</h4><p>替换命令<span class="tips">s</span>可以将文本行中的指定字符串替换为其他字符串，语法格式为：<br><span class="strong">sed ‘[行地址]s/替换前的字符串/替换后的字符串/标记符’ </span></p><h5 id="匹配数量"><a href="#匹配数量" class="headerlink" title="匹配数量"></a>匹配数量</h5><p>默认情况下，s命令只会替换每行中出现的第一个匹配字符串。要想让编辑器处理当前行中其他位置的字符串，需要使用标记符：</p><p><spa class="tips">命令/匹配字符串/替换字符串/标记符</spa></p><p>标记符可以为以下字符：</p><ul><li>数字：表示替换该行中的第几处匹配的字符串</li><li>g：表示替换该行中所有字符串</li><li>p：打印替换过的内容到屏幕</li><li>w 文件名：将修改完的字符串行另存到文件中，只会保存匹配到的行</li></ul><div class="show">e.g.假设文件data.txt中有以下内容<span class="strong">data.txt</span>111AAA111BBB111AAA222AAA222BBB222AAA333AAA333BBB333AAAso live a life you will remember1. 替换文件中每行第2个字符串AAA为替换内容sed 's/AAA/替换内容/2' data.txt2. 默认情况下，上述命令会将替换完的完整文件内容输出到屏幕，包括第4行没有AAA内容的文本，如果只想输出匹配到行，则需要搭配-n选项和p标记符sed -n 's/AAA/替换内容/2p' data.txtp标记符用于输出匹配到的字符串行，如果没有-n选项，由于sed命令本身默认就会输出完整文件内容，加上p选项输出的匹配内容，因此会输出完整文件内容+匹配内容，匹配到的部分会输出两遍，因此需要使用-n取消掉sed命令的默认输出，只输出内容被修改的部分3. 如果要先输出一行原文件内容，再输出一行被替换的内容，二者一上一下以作比较，可以使用以下命令sed -n -e 's/AAA/&/p' -e 's/AAA/替换内容/p' data.txt4. 将替换的内容另存到另外一个文件sed 's/AAA/替换内容/w result.txt' data.txt上述命令依旧会输出默认的完整文件到屏幕，但w标记符只会将替换过到的第1，2，3行保存到文件，没有AAA字符串的第4行将不被另存</div><h4 id="删除行d"><a href="#删除行d" class="headerlink" title="删除行d"></a>删除行d</h4><p>sed编辑器中的<span class="tips">d</span>(delete)命令用于删除特定的行，它会根据匹配到的信息删除对应行，并且支持寻址。注意，如果d命令没有指定任何匹配内容，则默认会删除所有行。同样，d命令不会修改原文件，只是将经过删除处理后的文本内容打印到屏幕。d命令的语法为：<br><span class="strong">sed ‘地址d’ [文件名]</span></p><div class="show">e.g.文件data.txt中包含以下内容<span class="strong">Line 1 AAAAAA</span>Line 1 AAAALine 2 BBBBLine 3 CCCCline 4 AAAAline 5 DDDDmore line1. 可以通过行号删除指定行sed '2,4d' data.txt2. 也可以根据正则表达式匹配内容删除指定行sed '/AAAA/d' data.txt3. d命令可以通过两个正则表达式来指定一个区间，然后删除区间之间的行。这是d命令的特殊用法，注意，使用该功能时，指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能sed '/Line 1/,/Line 3/d' data.txt #删除第1，2，3行如果d命令再次匹配到满足要求的行，删除功能会再次打开，<span class="text-red">如果没有匹配到关闭删除的字符串，d命令有可能会删除后续整个文件内容！</span>sed '/AAAA/,/CCCC/d' data.txt# sed会首先删除匹配到的包含AAAA到CCCC之间的行，即第1，2，3行，而后第4行再次匹配到了AAAA，于是删除功能再次打开，由于后续再无匹配到CCCC，删除功能一直继续，直到将文件内容删除完</div><h4 id="插入和附加行i-amp-amp-a"><a href="#插入和附加行i-amp-amp-a" class="headerlink" title="插入和附加行i&amp;&amp;a"></a>插入和附加行i&amp;&amp;a</h4><p>sed编辑器也支持加入新的行，两个操作分别为：</p><ul><li><span class="tips">i</span>(insert)命令会在指定行前插入一个新行</li><li><span class="tips">a</span>(append)命令会在指定行后增加一个新行<br>两个命令的语法都为：<div class="apiBox">sed '[地址] 命令\新增行的内容' [文件名]</div>也可以同时插入多行，每行内容使用反斜线分隔：<div class="apiBox">sed '[地址] 命令\&gt;新增的第一行\&gt;新增的第二行' [文件名]</div></li></ul><p>对诸如echo语句等单行命令前插入内容时，可以不指定地址。而在文件中插入新行，需要使用行号或正则表达式为其指定一个插入位置，但不支持地址区间，即只能将新增的行插入和附加到单个行前或行后，而不支持插入某个区间前后</p><div class="show">e.g.如果在单行命令中插入文本，可以不指定地址echo "这是一段文本" | sed 'i\插入的新行'在文件第一行前插入内容sed '1i\新增行内容' data.txt在文件最后一行后附加内容sed '$a\新增行内容' data.txt也可以使用正则表达式匹配包含指定内容的行，这会将内容插入所有满足要求行的前后sed '/AAAA/i\新增的行' data.txt也可以同时插入多行内容sed '3a\&gt;第一行\&gt;第二行\&gt;第三行' data.txt</div><h4 id="修改行c"><a href="#修改行c" class="headerlink" title="修改行c"></a>修改行c</h4><p>命令<span class="tips">c</span>(change)命令用来修改整行文本的内容，其语法和插入、附加命令类似：</p><div class="apiBox">sed '地址c\&gt; 修改后的第一行内容\&gt; 修改后的第二行内容' [文件名]</div><p>c命令支持使用地址区间，将该区间的行修改为指定的内容，但它只会将所有行修改为一个(单行或多行)指定内容，而不会每行修改一次，地址可以使用行号，也可以使用正则表达式匹配</p><div class="show">e.g.根据行号修改指定行内容sed '1,2c\&gt;修改的内容1\&gt;修改的内容2' data.txt根据正则表达式匹配行并修改内容sed '/AAAA/c\修改的内容' data.txt</div><h4 id="转换命令y"><a href="#转换命令y" class="headerlink" title="转换命令y"></a>转换命令y</h4><p>sed编辑器中，转换命令<span class="tips">y</span>(yank v.急速抽取,猛拉)是唯一一个可以处理单个字符的命令，其语法格式为：<br><sapn class="strong">[地址]y/转换前的字符串str1/转换后的字符串str2/</sapn></p><p>转换命令会将两个字符串一一对应，str1中的第一个字符会被转换为str2中的第一个字符，依此类推，如果两个字符长度不同，sed编辑器会抛出一条错误消息。</p><div class="show">e.g.文件data.txt包含以下内容111ABC111ABC222ABC333AAA333444BBB444555DDD555转换命令会单独解析每个字符，只要包含任意字符就会被转换并且作用于所有行，且同一行有多个匹配的字符也会被转换，而不会像s命令一样只替换第一个<span class="text-blue">sed 'y/ABC/abc/' data.txt</span>111abc111abc222abc333aaa333444bbb444555DDD555也可以用地址限定只在某行生效，以下命令只修改第一行中的ABC<span class="text-blue">sed '1y/ABC/abc/' data.txt</span>也支持使用正则表达式定位某行<span class="text-blue">sed '/22/y/ABC/abc/' data.txt</span></div><h4 id="写入文件w"><a href="#写入文件w" class="headerlink" title="写入文件w"></a>写入文件w</h4><p><span class="tips">w</span>命令会将匹配的行写入文件(另存)，如果文件不存在，则会自行创建，如果文件存在且文件中已有内容，则该内容会被覆盖，w命令语法格式为：</p><div class="apiBox">[地址]w 文件名</div><p>文件名可以包含文件的绝对路径或相对路径，但执行该命令的用户需要拥有对该文件的写权限</p><div class="show">e.g.将data文件的第1，2行写入test文件sed '1,2w test.txt' data.txt将文件包含字符串AAAA的行写入文件sed '/AAAA/w test.txt' data.txt</div><h4 id="读取文件r"><a href="#读取文件r" class="headerlink" title="读取文件r"></a>读取文件r</h4><p><span class="tips">r</span>(read)读取命令会从指定文件读取所有文本内容，并插入到指定的地址，该命令的语法格式为：</p><div class="apiBox">[地址]r 文件名</div><p>文件名可以包含文件的绝对路径或相对路径，指定地址时，只能指定一个单独的行号，而不能是一个区间，也可以是通过正则表达式匹配的行</p><div class="show">e.g.将文件test中的所有内容插入到文件data末sed '$r test.txt' data.txt该功能常用于一些模板文件，这些模板文件(如信件模板)会在文件中用一个占位符预留空间，然后从另外一份文件导入字符串替换占位符，这样模板文件可以方法使用。如：文件customer写有顾客名单，文件Invitation为顾客姓名预留了位置<span class="strong">customer.txt文件内容：</span>丹尼斯里奇,       肯汤普森詹姆斯高斯林,     林纳斯<span class="strong">Invitation.letter文件内容：</span>邀请的嘉宾：    NAME....#邀请说明内容....可以将占位符NAME删除，并在该位置填入邀请名单<span class="text-red">sed '/NAME/{&gt;r customer.txt&gt;d&gt;}' Invitation.letter</span></div><h4 id="多行文本的处理"><a href="#多行文本的处理" class="headerlink" title="多行文本的处理"></a>多行文本的处理</h4><p>默认情况下，sed编辑器会基于换行符的位置将数据分成行，以一行文本作为一个处理单位，如果处理的数据分布在两行或多行上，则sed编辑器可能返回错误的结果。</p><p>sed编辑器为了解决该问题，提供了三个命令用于处理多行文本：</p><ul><li><span class="strong">n</span>(next)：读取数据流中的下一行内容并覆盖当前模式空间中的内容</li><li><span class="strong">N</span>(next)：将数据流中的下一行追加到当前模式空间中</li><li><span class="strong">D</span>：删除多行组中的一行</li><li><span class="strong">p</span>：打印多行组中的一行</li></ul><h5 id="next命令"><a href="#next命令" class="headerlink" title="next命令"></a>next命令</h5><p>next命令分为两个，命令<span class="tips">n</span>会读入数据流中的下一行内容并覆盖当前模式空间中的内容，而命令<span class="tips">N</span>会将下一行内容追加到当前模式空间中一起处理，二者有不同的用途。</p><p>命令n可用来通过字符串定位某行后，基于此行处理之后的每一行的内容。这些字符串在文件中出现的位置(行号)可能是随机的，因此只能通过字符串来定位，然后通过命令n读入下一行的内容并做处理。</p><div class="show">e.g.找出文件data中的uuid<span class="strong">data文件内容</span>AAAAAABBBBBBuuid:a3d187a8-3b92-11ef-89d3-610452174e68CCCCCCuuid:a3d187a9-3b92-11ef-89d3-610452445a10DDDDDD输出uuid<span class="text-blue">sed -n '/uuid/{n;p}' data</span>e.g.删除文件data.txt中第一行后的空白行<span class="strong">data.txt文件内容：</span>this is first line.</br>this is second line.</br>this is last line.如果使用命令 sed '/^$/d' data.txt，文件中的所有空白行都会被删除，如果只想删除第一行后的空白行，则可以先定位到第一行，然后通过 n 命令读入下一行并覆盖第一行内容，然后通过删除命令删除该行即可，命令为：<span class="text-blue">sed '/first/{n; d}' data.txt</span>#通过first字符串定位第一行，然后通过命令n读入第一行后的空白行，再通过命令d删除该空白行</div><p>命令N会将数据流中的两个文本行合并到同一个模式空间中，文本行仍然用换行符分隔，但sed编辑器现在会将两行文本当成一行来处理。当文本信息(如一个短语)被分隔到了不同的行，需要统一处理时，则可以使用该命令。</p><div class="show">如果对一个文件执行N命令，N命令的工作方式为：先读入第一行文本，执行N命令，sed编辑器会立即读入第二行文本，并将二者作为一行文本处理，文本中的换行符\n会保留随后读入第三行文本，继续执行N命令，读入第四行文本进行合并，以此循环因此如果文件是偶数行，则所有文本都会两两作为一行进行处理如果文件是奇数行，则执行到最后一行文本时，N命令会被sed编辑器叫停，最后一行文本单独作处理e.g.文件data.txt中有以下内容：AA AAAABB BBBB执行命令<span class="text-blue">sed 'N;l' data.txt</span>，命令会打印出：AA AAAA\nBB BBBB$即模式空间中，两行内容会被当作一行保留了\n字符的单行字符串进行处理，因此，对被分割到了两行的字符串进行处理时，可以使用以下方法：e.g.替换文件data.txt中的"周杰伦"为"陈奕迅"<span class="strong">data.txt文件内容</span>1111 11 11周杰伦 22 22周杰伦 33 周杰伦44 44 44445555 55 周杰伦考虑到字符串有不同的换行可能，需要考虑所有换行情况，但如果直接执行：<span class="text-blue">sed 'N&gt;s/周杰伦/陈奕迅/&gt;s/周\n杰伦/陈\n奕迅/&gt;s/周杰\n伦/陈奕\n迅/&gt;' data.txt</span>将产生以下问题：1.N命令会将每两行合并为一行进行处理，一二行处理一次，三四行处理一次，这会导致如果字符串分散在二三行将无法匹配到2. 文件为奇数行时，最后一行执行到N命令后将会被sed叫停，因为它没有下一行可以读入，这会导致sed退出，后续命令不再执行，这将导致最后一行中的字符串无法被匹配和替换正确的命令应该为：<span class="text-blue">sed '&gt;:loop&gt;N&gt;$!bloop&gt;s/周杰伦/陈奕迅/g&gt;s/周\n杰伦/陈\n奕迅/g&gt;s/周杰\n伦/陈奕\n迅/g&gt;' data.txt</span>先将所有行合并到一行上(针对小文件)，然后进行全局替换\$!bloop表示未执行到最后一行前，均跳转回loop标签</div><div class="show">N命令可以多次调用，来实现三行、四行等多行的合并处理，但需要注意最后一行是否会被合并到之前的行中，如果最后一行被孤立，其中的内容可能会无法被正确处理<span class="strong">data.txt文件包含以下内容</span>AA AA AAAABB BB BBBBCC CC CCCCDD DD DDDD只调用一次N命令时：sed -n 'N;l' data.txt返回值为AA AA AAA\nBB BB BBB$CC CC CCC\nDD DD DDD$调用两次N命令时：sed -n 'N;N;l' data.txtsed编辑器读入第一行后，执行第一个N命令读入第二行，执行第二个N命令读入第三行，执行l命令输出，然后清空模式空间。并读入第四行，开始重新执行指定的命令，但执行到第一个N命令后，由于文件已经读取到最后一行，于是sed编辑器会叫停命令执行，于是第四行由于没有执行到l命令，所以输出中将缺少第四行：AA AA AAA\nBB BB BBB\nCC CC CCC$类似的，调用3次N命令，将使整个文件作为同一个行进行处理，输出值为：AA AA AAA\nBB BB BBB\nCC CC CCC\nDD DD DDD$</div><h4 id="多行文本的删除D"><a href="#多行文本的删除D" class="headerlink" title="多行文本的删除D"></a>多行文本的删除D</h4><p>在使用N命令时，数据流中的两行或多行文本会被当作同一行来处理，因此如果在N命令后使用d命令，将会同时删除多行文本。如果只需要删除第一行，可以使用<span class="tips">D</span>命令。它只会删除模式空间中的第一行，删除内容包括从第一行开头到换行符（含换行符）为止的所有字符，这个命令常用来删除目标数据字符串所在行的前一文本行。</p><div class="show">e.g.需要搜索的关键词被分割于两行上，需要使用N命令合并搜索，但只删除其中的第一行内容<span class="strong">data.txt文件内容：</span>1111 11 11周杰伦 22 22223333 33 周杰伦如果使用d命令，则包含字符串的两行都会被删除sed 'N;/周\n杰伦/d' data.txt输出值为：3333 33 周杰伦只删除第一行，需要使用D命令sed 'N;/周\n杰伦/D' data.txt输出值为：杰伦 22 22223333 33 周杰伦</div><h4 id="多行打印P"><a href="#多行打印P" class="headerlink" title="多行打印P"></a>多行打印P</h4><p>与多行删除类似，如果将打印命令p(小写)与N命令一起使用，则p命令会同时输出所有匹配到的多行的内容。如果只想输出多行中的第一行内容，则需要使用<span class="tips">P</span>(大写)命令。同样，该命令只会输出模式空间中第一行开始到换行符之间的内容</p><div class="show">e.g.打印上个例子中文件data.txt的指定字符串小写的命令p会输出包含该字符串的多个行sed -n 'N;/周\n杰伦/p' data.txt输出：1111 11 11周杰伦 22 2222大写的命令P只输出模式空间中的第一行sed -n 'N;/周\n杰伦/P' data.txt输出：1111 11 11周</div><h4 id="排除命令"><a href="#排除命令" class="headerlink" title="排除命令!"></a>排除命令!</h4><p>在命令前加上行地址可以指定命令只在这些行生效，而如果想命令在这些行中不生效，直接在行地址后加上<span class="tips">!</span>即可。排除命令<span class="tips">!</span>可以用来指定命令在某些行中不生效，而对文本剩下的其他行均生效。</p><div class="show">e.g.文件data.txt含以下内容1111 AA2222 AA3333 AA4444 AA输出文本内容，包含字符串2222的行除外sed -n '/2222/!p' data.txt输出值为：1111 AA3333 AA4444 AA将文本行中的AA替换为BB，2,3行除外sed '2,3!s/AA/BB/' data.txt输出值为：1111 BB2222 AA3333 AA4444 BB</div><h4 id="命令跳转b"><a href="#命令跳转b" class="headerlink" title="命令跳转b"></a>命令跳转b</h4><p>排除命令可以用来指定某个命令对哪些行不生效，当有大量的命令都要求对这些行不生效时，如果需要为每个命令都加上<span class="tips">!</span>过于繁琐。为此，sed提供了分支命令<span class="tips">b</span>(branch)，用来帮助这些匹配的行跳过一整组命令，branch命令的格式为:</p><p><span class="strong">[行地址]b [跳转位置]</span></p><p>在文本处理命令中可以使用<span class="tips">: 位置标识符</span>(位置标识符最长可以为7个字符)来指定一个branch命令跳转的位置。注意：这里的跳转位置是指在命令行中的跳转位置，而不是跳转到文本流的哪个位置。行地址参数决定了branch命令触发的条件以及branch在哪些行生效，当在匹配的行执行到branch命令时，sed编辑器会跳转到位置标识符所在命令位置，并略过branch命令与位置标识符之间的所有命令。如果没有为branch命令指定跳转位置，则branch命令会跳过所有在它之后的命令，直接结束本行文本的处理。</p><div class="show">命令的常见用法：处理某文本流时，对于包含内容AA的行只执行命令3，命令4，其他行命令1，2，3，4均执行，就可以使用branch命令<span class="text-blue">sed '<span class="text-red">/AA/b jump;</span>命令1;命令2;<span class="text-red"> :jump; </span>命令3;命令4' data.txt</span></div><div class="show">e.g.文件data.txt含以下内容1111 AA BB CC2222 AA BB CC3333 AA BB CC4444 AA BB CC1. 不指定跳转位置，文本处理命令会跳转到命令末尾<sapn class="text-red">sed '2,3b;s/AA/aa/;s/BB/bb/;s/CC/cc/' data.txt</sapn>由于没有指定命令跳转位置，对于第二，第三行，b命令会跳过后面的两个s命令，但对于其他行，b命令不生效，所有命令不跳过，输出值为：1111 aa bb cc2222 AA BB CC3333 AA BB CC4444 aa bb cc2. 指定跳转位置，文本处理命令会跳转到位置标识符开始的地方<span class="text-blue">sed '2,3b jump1&gt;s/AA/aa/&gt;s/BB/bb/&gt; :jump1&gt;s/CC/cc/' data.txt</span>定义了一个位置跳转符 jump1，文本执行到第二，第三行时，s/AA/aa;s/BB/bb/命令会被跳过，跳转到jump1开始执行，因而s/CC/cc会正常执行1111 aa bb cc2222 AA BB cc3333 AA BB cc4444 aa bb cc该命令等价于：<span class="text-blue">sed '2,3!{s/AA/aa/;s/BB/bb/};s/CC/cc/' data.txt</span></div><p>注意，命令在进行跳转时有可能形成循环，如果branch命令触发条件没写好，可能形成死循环</p><div class="show">e.g.删除文本中的所有感叹号echo "乌！蒙！山！外！连！着！山！"| sed ':jump;s/!//1p;/!/b jump';sed会依次删除感叹号，直到所有感叹号删除完毕退出循环：乌蒙！山！外！连！着！山！乌蒙山！外！连！着！山！乌蒙山外！连！着！山！乌蒙山外连！着！山！乌蒙山外连着！山！乌蒙山外连着山！乌蒙山外连着山乌蒙山外连着山</div><h4 id="测试命令t"><a href="#测试命令t" class="headerlink" title="测试命令t"></a>测试命令t</h4><p>测试命令<span class="tips">t</span>(test)也可以实现命令的跳转，其跳转的条件是t命令前的替换命令如果成功匹配并替换了一个字符串，测试命令就会跳转到指定的位置标识符，如果替换命令没有匹配到指定的模式，测试命令就不会跳转。注意，t 命令只能基于替换命令的成功与否触发跳转，而不能直接基于其他命令的结果。测试命令的语法格式与分支命令相同：</p><p><span class="strong">[行地址]t [跳转位置]</span></p><p>与分支命令类似，如果跳转条件满足而没有为t命令指定跳转位置，则sed会跳到命令结束的位置。</p><div class="show">测试命令的工作模式类似于if-then语句e.g.如果匹配到AA就替换为aa，此时由于没有指定跳转位置，t命令会跳转到命令末尾，第二个替换命令将不会执行。相反，如果第一个替换命令没有执行，则t命令不跳转，会尝试执行第二个替换命令sed 's/AA/aa/;t;s/BB/bb/' data.txte.g.去除文本中的所有感叹号echo "乌！蒙！山！外！连！着！山！"| sed '&gt;:jump&gt;s/!//1p&gt;t jump '</div><h4 id="退出命令q"><a href="#退出命令q" class="headerlink" title="退出命令q"></a>退出命令q</h4><p>退出命令<span class="tips">q</span>可以用来退出sed编辑器，注意，执行该命令后sed编辑器将直接退出而不再读取后续文本行，当然也不再执行后续命令，该命令也常用来退出由<span class="tips">b</span>命令和<span class="tips">t</span>命令形成的循环</p><div class="show">e.g.文件data.txt包含以下内容1111AA11112222AA22223333AA33334444AA44445555AA55BB6666AA6666替换文本行中的AA，直到第四行sed '4q;s/AA/aa/' data.txt执行到第四行后，命令停止执行，后续文本也不再读入1111aa11112222aa22223333aa33334444AA4444e.g.一直读入文本行，直到遇到BB字符串，并将包括带有BB字符串的行及其之前的文本行合并为一行，q命令用于终止循环sed ':start;/BB/q;N;s/\n/ /;b start' data.txt返回值为1111AA1111 2222AA2222 3333AA3333 4444AA4444 55AA55BB55</div><h4 id="保持空间"><a href="#保持空间" class="headerlink" title="保持空间"></a>保持空间</h4><p>sed对文本的操作都是在名为模式空间的缓冲区进行的，除了模式空间外，sed还有一个名为<span class="tips">保持空间</span>(hold space)的缓冲区，用来辅助模式空间工作。当模式空间中在处理文本行时，保持空间可用来临时存储一些行，有5条命令可以用来操作保持空间：</p><div class="table"><table><thead><tr><th>命令</th><th>命令来源</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>hold space</td><td>将模式空间中的内容复制到保持空间</td></tr><tr><td>H</td><td>hold space</td><td>将模式空间中的内容追加到保持空间</td></tr><tr><td>g</td><td>get from get space</td><td>将保持空间中的内容复制到模式空间</td></tr><tr><td>G</td><td>get from get space</td><td>将保持空间中的内容追加到模式空间</td></tr><tr><td>x</td><td>exchange</td><td>交换模式空间和保持空间的中内容</td></tr></tbody></table></div><p><strong>保持空间的运用</strong><br>巧妙使用保持空间可以实现一些有趣的功能，如实现文件的反序处理。默认情况下，sed编辑器会从文本流的第一行开始读取，第一行处理完毕才会载入第二行文本并作处理，但通过保持空间，我们可以将文本第一行暂存到保持空间，让sed编辑器先处理第二行，然后再从保持空间读出第一行文本进行处理，实现文本的反序处理，修改sed编辑器的默认处理流程。</p><div class="show">e.g.实现文件的反序输出，即最先输出最后一行，然后依次从后到前输出文件内容实现思路为：1. 等sed编辑器读入第一行内容到模式空间后，使用h命令将内容复制到保持空间2. 等sed编辑器读入第二行内容后，使用G命令将保持空间中的内容追加到模式空间中，此时第一行文本将排于第二行文本之后，然后再使用h命令将此时模式空间中的内容都存储到保持空间3. sed编辑器读入第三行，继续使用G命令将保持空间中的内容追加到模式空间，此时文本行顺序为：第三行、第二行、第一行。再次使用h命令将其保持到保持空间4. 重复上述步骤，直到文本行都被读取完毕，此时所有行都会反序存储于保持空间中5. 读取并打印文本行<span class="strong">文件data.txt内容：</span>1111222233334444sed编辑器会在每次执行完一次命令，都会自行读入下一行，因此只需要使用G命令将保持空间中的内容追加到模式空间即可。但刚开始模式空间读入文本流第一行时，保持空间为空，因此对于第一行，不需要将保持空间追加到其之后，可以用排除命令!解决：1!G将文本行反序后，需要将此时模式空间的内容存储到保持空间：h等到sed编辑器读取到文本最后一行，并执行完G命令，说明文本流的反序已经完成，此时打印模式空间中的内容即可：$p完整的命令为：<span class="text-red">sed -n '1!G;h;$p' data.txt</span></div><h4 id="模式引用-amp"><a href="#模式引用-amp" class="headerlink" title="模式引用&amp;"></a>模式引用&amp;</h4><p>当sed匹配到了字符串时，可以在后续的命令中使用<span class="tips">&amp;</span>引用匹配到的字符串</p><div class="show">e.g.查找文本中以at结尾的单词，并在该单词外加上双引号"" echo "The cat sleeps in his hat." | sed 's/*at/"<span class="text-red">&</span>"/g' 文本会替换为： The "cat" sleeps in his "hat".sed替换命令中，替换后的字符串不能使用*等通配符，因此上述语句改为以下命令将不会正常完成替换工作：echo "The cat sleeps in his hat." | sed 's/*at/"*at"/g'文本会被替换为：The "*at" sleeps in his "*at".</div><h4 id="部分引用"><a href="#部分引用" class="headerlink" title="部分引用"></a>部分引用</h4><p>&amp;符号会引用匹配到的整个字符串，如果只想引用字符串的一部分，需要使用一些特殊的方法：</p><p>sed编辑器可以使用<span class="tips">圆括号( )</span>在替换模式中定义子模式，然后在替换后的字符串中使用<span class="tips"> \数字 </span>的形式来引用每个子模式，数字表示子模式的位置。sed编辑器会将第一个子模式分配为\1，第二个子模式分配为\2，依此类推。注意！在使用圆括号定义子模式时，<span class="tips">需要使用转义字符将圆括号标识为分组字符</span>，否则sed编辑器会将其识别为普通的圆括号。</p><div class="show">在使用部分引用时，将字符串中需要保留的部分使用<span class="tips">\(字符串\)</span>的形式定义为子模式，然后在替换后的字符串中使用<span class="tips">\数字</span>的形式引用需要保留的部分e.g.文件data.txt含以下内容：<code>最常用的是Java语言和SpringBoot框架</code>替换Java但保留后缀"语言"，替换SpringBoot但保留后缀"框架"sed -n 's/Java\(语言\)和SpringBoot\(框架\)/JavaScript\1和Vue\2/p'输出值为：最常用的是JavaScript语言和Vue框架</div><div class="show">在使用替换命令时，由于在指定替换后的字符串时不能使用通配符，而又需要在替换后的字符串中引用部分匹配到的字符串时，就可以很方便地以子模式的形式引用e.g.文件data.txt含以下内容furry catfurry hatfurry dog在替换后的字符串中不能使用通配符时，可以用该方法引用所匹配到字符串中的一部分，相当于替换后的字符串中也使用了通配符sed 's/furry \(.at\)/pretty \1/'输出值：pretty catpretty hatfurry dog</div><h4 id="在shell脚本中使用sed"><a href="#在shell脚本中使用sed" class="headerlink" title="在shell脚本中使用sed"></a>在shell脚本中使用sed</h4><p>默认情况下，sed编辑器会将命令结果打印到屏幕上，因此在脚本中使用sed命令时，需要对其输出结果进行重定向，常用的方法是使用$()将其结果重定向到一个变量中，方便后续处理。以外是一些可能用到的sed脚本示例：</p><h5 id="格式化数值"><a href="#格式化数值" class="headerlink" title="格式化数值"></a>格式化数值</h5><div class="show">e.g.输入一个值计算其阶乘，然后将计算结果以1,000,000格式输出计算部分很简单，重点在于使用sed处理计算结果时，需要从个位开始每3位添加一个逗号，处理命令为：sed '&gt;:start&gt;s/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/&gt;t start'关键在于正则表达式部分，它定义了两个子模式：.*[0-9][0-9]{3}第一个子模式中的 .* 组合会匹配任意长度的除回车和换行符外的任意字符，[0-9]代表该子模式匹配的字符串必须以数字结尾，二者结合，该子模式会匹配任意长度以数字结尾的字符串第二个子模式会匹配三位数字此外，该sed命令每一次只会在字符串中插入一个逗号，因此使用了跳转命令t形成了一个循环，它会一直循环直到t命令前的s命令语句无法插入逗号为止当为该sed命令输入字符串12345678时<span class="strong">第一次循环：</span>正则表达式.*[0-9][0-9]{3}中的.*[0-9]需要为[0-9]{3}预留3位数字，然后*[0-9]本身匹配任意多数字结尾的字符串，所以：.*[0-9]匹配字符串：12345[0-9]{3}匹配字符串：678然后s命令会在两个子模式间插入逗号，因此第一次循环执行结果为：12345,678<span class="strong">第二次循环：</span>输入值为：12345,678如果[0-9]{3}匹配了"678"，.*[0-9]会匹配到"12345,"，不满足以数字结尾的要求。因此在字符串"12345,678"只有"12345"部分满足正则表达式要求。后面的",678"在s替换命令中作为不匹配的字符串原样保留，替换作用对其不生效因此，第二次循环，"12345"被替换为了"12,345"，再加上原字符串保留的",678"，最后的输出结果为12,345,678，这样数值会以方便阅读值的格式输出，整个脚本完整的代码如下：</div><pre><code>#!/bin/bashresult=1counter=$1while [ $counter -gt 1 ] do  result=$[ $result * counter ]  counter=$[ $counter - 1] doneoutputValue=$(echo $result | sed ':starts/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/t start')echo "计算结果为：$outputValue"</code></pre><div class="show">将上述代码保存于test.sh文件，然后执行bash test.sh 20计算20的阶乘，最后输出结果为：计算结果为：2,432,902,008,176,640,000</div><h5 id="加倍行距"><a href="#加倍行距" class="headerlink" title="加倍行距"></a>加倍行距</h5><div class="show">我们可以向文本文件的行间插入空白行，使得文本行看起来没那么密集This is the header line. </br>This is the first data line.</br>This is the second data line.</br>This is the last line.插入空白行可以从以下几点出发考虑：1.如果文件本身已经有一些空白行，如果再加入空白行每两行文本之间可能会有多个空白行，因此应该先删除原文件的空白行(除非文本本身需要刻意保留这些空白行)2.最后一行文本之后不需要空白行3.默认情况下，sed编辑器保持空间就是一个空白行，可以使用G命令将其追加到模式空间内容之后由此，加倍文件行距的命令为：<span class="text-blue">sed '/^$/d;$!G' data.txt</span>通过^$匹配文件原有空白行然后删除，通过$!G命令给除最后一行以外的行添加空白行</div><h5 id="给文本添加行号"><a href="#给文本添加行号" class="headerlink" title="给文本添加行号"></a>给文本添加行号</h5><div class="show">通过 = 命令可以打印行号，但行号会打印在文本内容上方，因此需要使用N命令合并，然后删除其中的换行符<span class="text-blue">sed '=' data.txt | sed 'N;s/\n/ /'</span>预览效果为：1 This is the header line. 2 This is the first data line. 3 This is the second data line. 4 This is the last line.</div><h5 id="查看文件末尾10行"><a href="#查看文件末尾10行" class="headerlink" title="查看文件末尾10行"></a>查看文件末尾10行</h5><p>用sed实现一个类似于tail命令的效果，读取文件最后10行，由此脚本可以任意魔改实现查看文件末尾n行</p><div class="show">由于sed会从第一行开始读取文本，而我们需要文件最后的10行，因此在使用N命令读入下一行的同时，需要不断删除模式空间最顶部的那一行，直到模式空间中保留文件的末尾10行<span class="text-blue">sed '{&gt;:start&gt;$q&gt;N&gt;11,$Db start}' data.txt</span>命令中，$q只会在读取文件最后一行时执行，q命令会退出sed编辑器，这里用来退出循环，而11,$D命令只会在读取文件第11行到最后一行之间的行时执行执行流程为：sed读入第一行，不执行$q，读入第二行，不执行11,$D读入第二行后依旧不执行$q和11,$D直到读入第11行，此时sed保持空间中已经有了11行内容，由于读入第11行内容，11,$D命令生效删除保持空间的第一行(也是文件第一行)，让保持空间中只保留10行文本之后的行类似，新加入保持空间中的行会替换掉保持空间顶部的行，保障保持空间中保留的是位于文件底部的行直到读入文件最后一行，$q生效退出sed编辑器，退出前sed会默认打印此时保持空间中的内容，即文件的最后10行可以在此基础上修改命令，任意指定查看行数，如：查看文件末尾3行：sed ':start;$q;N;4,$D;n start' data.txt</div><h5 id="删除空白行"><a href="#删除空白行" class="headerlink" title="删除空白行"></a>删除空白行</h5><h6 id="1-删除文件开头的空白行"><a href="#1-删除文件开头的空白行" class="headerlink" title="1.删除文件开头的空白行"></a>1.删除文件开头的空白行</h6><div class="show"><span class="strong">删除文件开头的空白行</span><span class="text-blue">sed '/./,$!d' 文件名</span>地址区间 /./,$ 表示从有任意字符的行开始到文件末，而/./,$!d表示地址区间的行不执行删除命令，即删除文件开头无字符的空白行</div><h6 id="2-删除文件末尾的空白行"><a href="#2-删除文件末尾的空白行" class="headerlink" title="2.删除文件末尾的空白行"></a>2.删除文件末尾的空白行</h6><div class="show"><span class="strong">删除文件末尾的空白行</span><span class="text-blue">sed ':start ; /^\n*$/{$d ; N ; b start}' data.txt</span>与打印文件末的文本行类似，删除文件末的空白行会有点麻烦，需要使用循环来判断空白行位于文本之间还是文件末。正则表达式^\n*$会匹配空行和只包含换行符的行，然后执行大括号中的命令组，$d表示如果该行位于文件最后一行则删除，此时由于文件处于最后一行，N命令不执行。如果不是最后一行，则$d不执行，N命令会读入下一行附加到模式空间中，然后命令跳转回开头重新执行。假设文件data.txt包含以下内容(为方便分析，文件末尾有两个空行)：11112222<br>4444<br><br>7777<br><br>根据命令，sed编辑器首先读入第一行，不满足/^\n*$/，编辑器不做任何操作，输出第一行然后sed载入第二行，同样不满足/^\n*$/，第二行原样输出sed载入第三行，该行为空行，满足正则表达式/^\n*$/中*为0的情况，执行{ }中的命令组，由于该行不为文件最后一行，$d不执行，N命令会读入下一行，此时保持空间中的内容为"\n4444"，然后命令跳转回开头，此时保持空间中的字符串不再满足/^\n*$/，sed输出该内容然后读取下一行sed读取的第五行也为空行，满足/^\n*$/，执行命令时同样不执行$d命令，但执行N命令，读入的第六行也为空行，此时模式空间内容为"\n\n"，命令跳转到回开头重新执行，此时模式空间中的内容依旧满足/^\n*$/，再次执行命令N，读入第七行，此时模式空间内容为"\n\n7777"，跳转命令后，不满足/^\n*$/，sed将输出该字符串sed读入第八行，该行为空白行，sed执行命令组，随后sed通过N命令读入第九行，也为空白行，此时保持空间中的字符串"\n",然后命令进行跳转，再次进行正则匹配，由于"\n"满足/^\n*$/，开始执行命令组，此时sed已经读取到文件末，所以$d执行，删除最后一行(且由于此时两个空白行被N命令合并为了一行，两个空白行会被一起删除)，执行到N命令时由于无下一行，sed会退出，此时文件末尾的所有空白行被删除完毕执行命令sed -n ':start;/^\n*$/{$d;N;l;b start}' data.txt，可以清晰看到保持空间中合并过的内容：\n4444$\n\n7777$\n$该命令只会删除文件末的空白行，不会去删除文本之间的空白行，只删除文件末的空白行时可以使用此命令</div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>在多行文本中，文本行末尾虽然隐式地在带有\n，但是是无法用正则表达式/\n/匹配的，但如果sed中使用了命令N来读入下一行文本，则当前文本和下一行文本之间会显式地写入\n，此时则可以使用/\n/来匹配。空白行同理，多个空白行虽然隐式地在末尾带有\n，但无法用正则表达式/^\n$/匹配空白行，而要使用/^$/来匹配，当使用命令N读入两个空白行时，sed编辑器保持空间中的内容将变成"\n"，此时可以使用/\n/匹配到。该例子中，/^\n*$/刚好能完美匹配空白行未被读入时/^$/的形式，也能匹配保持空间中存在多个空白行时/\n*/的形式。</div><div class="show">e.g.文件data.txt包含以下内容111122223333<br>5555<br><br>88889999未使用N命令时，无法匹配到\nsed -n '/\n/l' data.txt当使用了N命令时，\n会被显式写入文本中，因此可以被正则表达式匹配到sed -n 'N;/\n/p' data.txt会返回文件带\n的行(但由于文件是奇数行，最后一行无法执行N而导致sed退出，也就不会执行后续的p命令，无输出)111122223333<br>5555<br><br>8888通过输出命令l更能清晰看出文本行在保持空间中的具体存储方式1111\n2222$3333\n$5555\n$\n8888$</div><h6 id="3-删除文件中连续的空白行"><a href="#3-删除文件中连续的空白行" class="headerlink" title="3.删除文件中连续的空白行"></a>3.删除文件中连续的空白行</h6><div class="show"><span class="strong">删除文件中连续的空白行</span><span class="text-blue">sed '/./,/^$/!d' 文件名</span>文件中数据行之间的多个空白行会被删除，只保留一个空白行。该命令的关键在于，创建包含一个非空白行和一个空白行的地址区间，如果sed编辑器匹配到了这个区间，它不会删除行。但对于不匹配这个区间的行（两个或更多的空白行），它会删除这些行。</div><h5 id="删除HTML标签"><a href="#删除HTML标签" class="headerlink" title="删除HTML标签"></a>删除HTML标签</h5><div class="show">如果需要删除html文件或xml文件中的标签，只留下标签之间的内容，通过sed也可以轻松实现如果使用命令：sed 's/<.*>//g' index.html/&lt;.*&gt;/首先会匹配该行中最开始遇到的&lt;，此后由于.*会进行贪婪匹配，*会匹配尽可能多的字符，&gt;将匹配闭合标签中最末尾的&gt;，这会导致标签中的文本也被替换掉，如：&lt;div&gt; test &lt;/div&gt;该正则表达式会匹配高亮的两个尖括号：<span class="text-red">&lt;</span>div&gt; test &lt;/div <span class="text-red">&gt;</span>这会导致整个标签，包括标签中的内容也会被替换掉，因此，正确的删除标签的命令是：<span class="text-blue">sed 's/<[^>]*>//g' 文件名</span>正则表达式<[^>]*>表示匹配以 '&lt;' 开头，后面跟任意数量的非 '&gt;' 字符，并以 '&gt;' 结束的字符串，这正是一个HTML标签的形式。这样它会单独匹配双标签中的前半部分，由于使用了全局匹配g，标签的后半部分也会被匹配到，且对单标签也生效<span class="text-red">&lt;</span>div<span class="text-red">&gt;</span> test &lt;/div&gt;这样，标签会被依次替换删除，只留下标签中的字符串部分</div><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>awk 是一种强大的文本处理工具，广泛用于 Linux 和 Unix 系统中。它的名字来源于其三位创建者 Alfred V. Aho、Peter J. Weinberger 和 Brian W. Kernighan的首字母。相较与sed，awk提供的是一种类编程语言而不仅仅只是编辑器命令，它支持算术运算、数组运算、自定义变量、自定义函数、结构化编程语句(如：循环,判断)、模式匹配等，且awk本身提供了大量的内部函数和内部变量用于进行字符串处理、数值计算、时间处理等。与sed编辑器一样,awk会为每一行文本都执行一次指定的awk程序，不同的是，sed编辑器更注重以行为处理单位，处理列数据的能力较弱，而awk支持将行中的数据提取为字段，并提供了许多内建变量和函数用于调用和处理这些字段，处理列数据的能力远要比sed强，因此，awk被广泛用于格式化文本、运算和过滤数据，快速生成报告等领域。</p><p>Linux中主要使用的是awk的GNU版本——gawk，它是 awk 的扩展实现，由 GNU 项目开发，提供了许多扩展功能和增强特性，同时保持了与传统 awk 的兼容性。在大多数 Linux 发行版中，预装的都是gawk，awk命令通常是gawk的一个符号链接，通过awk命令和gawk命令启动的都是gawk编辑器。</p><h5 id="awk的工作流程"><a href="#awk的工作流程" class="headerlink" title="awk的工作流程"></a>awk的工作流程</h5><p>awk会依次执行以下流程：</p><ul><li>awk首先会执行BEGIN代码块中的内容，因此该代码块通常用来初始化变量、设置环境或打印初始信息</li><li>随后awk会逐行读取数据，并根据普通代码块中的模式-动作对进行匹配和处理，如果代码块中没有指定任何命令，awk会默认执行{ print $0 }，即打印当前文本行</li><li>在处理完所有数据后，awk会执行END代码块中的命令，该代码块可用于打印最终结果、清理资源</li></ul><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>awk程序的基本格式如下：</p><div class="apiBox">awk 选项 '{程序体}' 文件1 文件2 ...</div><ul><li>-F 字符：将字段分隔符修改为指定字符</li><li>-f 文件名：从指定的文件中读取程序</li><li>-v 变量名=值：定义一个awk变量并赋值，一个-v选项只能定义一个变量，但可以多次使用-v选项，通过-v选项定义的变量可以在BEGIN程序块中读取到</li><li>-mf 值：指定要处理的数据文件中的最大字段数</li><li>-mr 值：指定数据文件中的最大数据行数</li><li>-w 关键字：指定awk的兼容模式或警告等级</li><li>awk默认支持拓展正则表达式，不需要像sed一样使用额外选项</li><li>awk的程序体用一对大括号<span class="tips">{ }</span>定义，并且当程序是在命令行中指定时需要放到单引号<span class="tips">‘ ‘</span>中，这样shell会将其视为字符串，而不会去尝试解析awk程序，如果从文件中调用awk程序，则不需要单引号</li></ul></br><p>通常情况下，awk程序包含模式和命令两个部分，命令部分使用大括号包裹，模式或命令部分可以省略其中一个，但不能两个都省略。如果省略模式，则会对所有输入的行都执行命令。如果省略命令(包括大括号在内的命令部分)，则会默认打印所有与模式匹配的行。</p><div class="show">e.g.打印data.txt文件中所有包含"li"字符串的行awk '/li/{print $0}' data.txt如果省略命令，则根据awk的默认行为，同样会打印匹配的行awk '/li/' data.txt如果保留大括号，但不写命令，则awk会进行空操作，不执行任何动作(也不打印任何内容)awk '/li/{}' data.txt</div><h5 id="程序定义方式"><a href="#程序定义方式" class="headerlink" title="程序定义方式"></a>程序定义方式</h5><p>awk程序通常分为多个<span class="tips">语句块</span>，语句块使用大括号<span class="tips">{ }</span>包裹，同一个语句块允许定义多条命令，<span class="strong">单行模式</span>下，命令之间使用分号<span class="tips">;</span>分隔即可</p><div class="show">echo "java c python go" | awk '{print $1<span class="tips strong">;</span>print $2}'输出值为：javac</div><p><span class="strong">多行模式</span>下，可以不使用分号</p><div class="show">echo "java c python go" | awk '{ &gt; print $1 &gt; print $2 }' </div><p><span class="strong">从文件中调用：</span>awk也支持将程序存储于文件中，然后在命令行中通过<span class="tips">-f</span>选项调用，跟sed编辑器一样，awk程序会对文件中的每行文本都执行脚本</p><div class="show"><span class="strong">script.awk</span>{print $1; print $2}在命令行中使用<span class="tips">-f</span>选项调用echo "java c python go" | awk -f script.awk </div><p><span class="strong">awk可执行程序：</span>awk程序写于文件中也可以像shell脚本一样通过’#!’来指定文件的执行器，在赋予相应执行权限后直接通过文件路径直接执行。注意，与shell不同的是在指定awk解释器的时候，需要将选项<span class="tips">-f</span>作为参数传入awk</p><div class="show"><span class="strong">script.awk</span>#!/bin/awk -fBEGIN {print "Hello World"}然后赋给文件权限：chmod +x script.awk之后通过文件路径可以直接执行：./script.awk或/myAwk/script.awk</div><h5 id="文本输入方式-1"><a href="#文本输入方式-1" class="headerlink" title="文本输入方式"></a>文本输入方式</h5><p>与sed编辑器相同，当命令行未指定输入的文本文件时，awk默认会从STDIN读取输入，每输入一行，awk会处理一行并即时打印处理结果，直到使用<span class="tips">Ctrl+D</span>结束输入，或使用<span class="tips">Ctrl+C</span>终止程序</p><div class="show">awk '{print "输入为："$0}'10                 #用户输入输入为：10          #awk输出GNU/Linux          #用户输入输入为：GNU/Linux   #awk输出</div><p>也可以使用管道符<span class="tips">|</span>将文本输入awk程序</p><div class="show">echo "java c python go" <span class="tips">|</span> awk '{print $1;print $2}'</div><p>文本也可以从文件中大量读取</p><div class="show">文本较多时，可以写于文件中，awk可以从文件读取文本awk '{print $1;print $2}' data.txt</div><h4 id="在处理数据前-后执行脚本BEGIN与END"><a href="#在处理数据前-后执行脚本BEGIN与END" class="headerlink" title="在处理数据前/后执行脚本BEGIN与END"></a>在处理数据前/后执行脚本BEGIN与END</h4><p>awk允许数据处理前，或数据处理后执行某些特定的功能。默认情况下，awk会先从输入读入一行文本，然后对该文本执行对应脚本。如果需要在数据处理前执行某个功能(如：脚本执行前打印提示)，则可以使用<span class="tips">BEGIN</span>关键字来定义脚本，同样，awk还提供了<span class="tips">END</span>关键字用于在数据处理完毕后执行脚本，BEGIN和END是用来在读取数据流之前或之后执行命令的特殊模式。</p><div class="show">awk 'BEGIN { print "程序启动" }&gt; {print "执行程序体"}&gt; END { print "程序执行完毕"}' data.txt</div><p>使用该功能可以生成漂亮且清晰的信息报告</p><div class="show">e.g.文件script.awk中的程序BEGIN {print "当前Linux的用户列表和默认登录shell"print "用户名\t\t默认登录shell"print "--------------------"FS=":"}{print $1 "\t\t" $7}END {print "----------------"print "信息来自/etc/passwd文件"}执行命令<span class="text-red">awk -f script.awk /etc/passwd</span>生成的信息报告(只展示一部分用户信息)：<code>当前Linux的用户列表和默认登录shell用户名         默认登录shell------------------------root        &emsp; /bin/bashbin            /sbin/nologindaemon         /sbin/nologinadm            /sbin/nologinlp             /sbin/nologin-----------------------信息来自/etc/passwd文件</code></div><h4 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h4><p>与sed相似，awk支持使用模式来过滤数据，使awk程序只作用于某些满足要求的行，BEGIN与END是两个awk预定义的特殊模式</p><h5 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h5><p>awk支持基础正则表达式（BRE）和扩展正则表达式（ERE），通过正则表达式可以筛选出满足匹配的行，正则表达式之后语句块中的awk程序将只对这部分行生效</p><div class="show">e.g.找出包含字符串"AA"的行，并打印这些行的第一个字段awk '/AA/{print $1}' data.txt</div><h5 id="匹配操作符"><a href="#匹配操作符" class="headerlink" title="匹配操作符"></a>匹配操作符</h5><p>正则表达式会在每一行的所有内容中进行匹配，如果需要限定正则表达式只能在某个字段内进行匹配，可以使用匹配操作符<span class="tips">~</span>，语法为：</p><div class="apiBox">字段~正则表达式{ 程序体 }</div><div class="show">e.g.文件data.txt包含以下内容11AA 11AA22BB 22AA33CC 33AA44DD 44AA列出字段1中包含"AA"的行awk '$1~/^AA/{print $0}' data.txt输出值：11AA 11AA</div><h5 id="排除操作符"><a href="#排除操作符" class="headerlink" title="排除操作符"></a>排除操作符</h5><p>正则表达式的匹配结果可以使用<span class="tips">!</span>来进行排除，该排除操作符可以扩展为<span class="tips">!~</span>来根据字段匹配来进行排除，awk会选定除满足正则表达式外的其他所有行</p><div class="show">e.g.打印不包含"22"的行awk '!/22/{print $0}' data.txt 输出值为：11AA 11AA33CC 33AA44DD 44AA打印第一个字段不包含"AA"的行awk '$1!~/AA/{print $0}' data.txt 输出值为：22BB 22AA33CC 33AA44DD 44AA</div><h5 id="使用数学表达式"><a href="#使用数学表达式" class="headerlink" title="使用数学表达式"></a>使用数学表达式</h5><p>在进行模式匹配时支持使用数学表达式进行比较，比较类型可以是数值，也可以是字符串，awk支持以下常用的比较符：</p><div class="table"><table><thead><tr><th>表达式</th><th>示例</th></tr></thead><tbody><tr><td>==</td><td>$1==”root”</td></tr><tr><td>!=</td><td>$3!=0</td></tr><tr><td>&lt;</td><td>$1&lt;10</td></tr><tr><td>&lt;=</td><td>$1&lt;=10</td></tr><tr><td>&gt;</td><td>$1&gt;=10</td></tr><tr><td>&gt;=</td><td>$1&gt;=10</td></tr></tbody></table></div><div class="show">e.g.列出所有超级管理员(UID为0)的用户名awk -F: '$3==0{print $1}' /etc/passwd</div><h4 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h4><h5 id="字段相关内建变量"><a href="#字段相关内建变量" class="headerlink" title="字段相关内建变量"></a>字段相关内建变量</h5><div class="table"><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$n</td><td>$0代表整行文本，$n代表第n个字段</td></tr><tr><td>$NF</td><td>表示最后一个字段(可以在不知道总共有几个字段，无法使用$n表示时使用)</td></tr><tr><td>FS</td><td>输入字段分隔符</td></tr><tr><td>OFS</td><td>输出字段分隔符</td></tr><tr><td>RS</td><td>输入记录分隔符</td></tr><tr><td>ORS</td><td>输出记录分隔符</td></tr><tr><td>FIELDWIDTHS</td><td>由空格分隔的一列数字，定义了每个数据字段确切宽度</td></tr></tbody></table></div><h5 id="字段数据变量"><a href="#字段数据变量" class="headerlink" title="字段数据变量"></a>字段数据变量</h5><p>默认情况下，awk会将每一行文本使用字段分隔符划分为多个数据字段，并自动给每个字段分配一个变量，awk默认使用空白字符(如：空格、制表符)作为字段分隔符，数据字段可以使用相应的变量来引用，也可以通过修改变量来修改字段：</p><ul><li><span class="strong">$0</span>代表整个文本行</li><li><span class="strong">$n</span>代表第n个数据字段</li><li><span class="strong">$NF</span>代表最后一个字段，其中NF表示最后一个字段的索引值(也代表了该记录一共有几个字段)</li></ul><div class="show">1.可以通过字段数据变量引用和修改字段echo "java c python go " | awk '{$2="c++" ; print $0}'修改后的文本变为：java c++ python go2. 有时无法确切得知该行一共有多少个字段，$NF可以在不知道字段数量的情况下获取最后一个字段的数据，同时NF也表示该行一共有多少个字段echo "AA　BB　CC DD EE" | awk '{print NF,$NF}'输出为：5 EE</div><h5 id="输入字段分隔符FS与输出字段分隔符OFS"><a href="#输入字段分隔符FS与输出字段分隔符OFS" class="headerlink" title="输入字段分隔符FS与输出字段分隔符OFS"></a>输入字段分隔符FS与输出字段分隔符OFS</h5><p>变量FS和OFS决定了awk如何处理数据流中的数据字段。其中变量FS决定了awk根据什么字符来分割输入的数据流，默认情况下，FS的值是空白字符，因此awk默认会根据空格、制表符等字符的位置来分割数据流。而某些文件有它独特的字段分割符，如：/etc/passwd 文件默认使用<span class="tips">:</span>为字段分割符，在处理这些文件时，我们可以在将awk程序中FS的值修改为<span class="tips">：</span>，方便awk程序正确分割passwd文件的字段信息。</p><p>变量OFS决定了输出字段时，这些字段间的分隔符，在输出字段值时，print命令会自动将OFS变量的值放置在输出中的每个字段间。</p><div class="show">e.g.文件data含以下内容10,20,30,40AA,BB,CC,DDjava,c,python,go文件内容由<span class="tips">,</span>隔开，因此FS值为<span class="tips">,</span>，将字段使用----分隔后输出，注意print语句中字段变量之间的逗号只是用来指定多个变量，并不会输出到字段之间<span class="text-red">awk 'BEGIN{FS=",";OFS="----"}{print $1,$2,$3,$4}' data</span>输出信息：10----20----30----40AA----BB----CC----DDjava----c----python----go</div><h5 id="根据数据宽度分隔字段FIELDWIDTHS"><a href="#根据数据宽度分隔字段FIELDWIDTHS" class="headerlink" title="根据数据宽度分隔字段FIELDWIDTHS"></a>根据数据宽度分隔字段FIELDWIDTHS</h5><p>有时文件中的数据并没有很规律地使用某个字符分隔，甚至部分信息是粘合在一起的，此时可以使用FIELDWIDTHS变量来定义一串值，以决定每个字段的字符长度，awk程序会根据这串值将文本分割为字段。FIELDWIDTHS变量能更精确地处理每个字段的宽度，很适合用来处理那些已经严格按照固定宽度格式化的数据。FIELDWIDTHS定义字段宽度的语法为：<span class="tips">FIELDWIDTHS=”值1 值2 值3….”</span></p><div class="show">e.g.命令ls -lh列出的文件信息，文件所有者、所属组、其他用户权限是合并在一起写的，可以按字符长度将其分割出来(1)ls -lh命令输出信息为：total 24K-rw-r--r-- 1 root root  258 Jul 19 12:58 data.txt-rw-r--r-- 1 root root  185 Jul 19 13:40 script.awkdrwxr-xr-x 2 root root 4.0K Jul 16 05:40 test即首行会输出目录的总大小，可以通过sed命令'1d'删除第一行，然后将剩下信息用awk来处理，这里只分析文件的权限部分 ls -lh | sed '1d' | awk '&gt; BEGIN {&gt; print "文件类型\t用户权限\t用户组权限\t其他用户权限"&gt; print"---------\t--------\t----------\t------------"&gt; FIELDWIDTHS="1 3 3 3"&gt; }&gt; {&gt; print $1"\t\t"$2"\t\t"$3"\t\t"$4&gt; }'输出值为：<div class="table-show" style="letter-spacing:normal"><table><thead><tr><th>文件类型</th><th>用户权限</th><th>用户组权限</th><th>其他用户权限</th></tr></thead><tbody><tr><td>----</td><td>----</td><td>-----</td><td>-------</td></tr><tr><td>-</td><td>rw-</td><td>r–</td><td>r–</td></tr><tr><td>-</td><td>rw-</td><td>r–</td><td>r–</td></tr><tr><td>d</td><td>rwx</td><td>r–</td><td>r-x</td></tr></tbody></table></div></div><h5 id="记录分隔符RS与ORS"><a href="#记录分隔符RS与ORS" class="headerlink" title="记录分隔符RS与ORS"></a>记录分隔符RS与ORS</h5><p>默认情况下，awk以一行为一个处理单位，awk会对所有行都执行一次程序，因此awk会将一行视为一个独立的数据记录。但有时，一个对象的不同数据可能会分布于多行，如一个用户的用户名，账号，Email地址等数据各占一行，这些多行数据共同构成一个用户的数据记录。我们不希望awk为每一行都执行一次程序，而是需要将这些多行视为一个处理单位(一个记录)，此时就需要用RS和ORS变量来指定awk程序的记录分隔符，以便字段变量能正确分配到数据值，其中，RS为输入记录分割符，ORS为输出记录分割符，默认情况下，它们的值都是换行符</p><div class="show">e.g.文件data.txt含以下内容Riley Mullen 123 Main Street Chicago, IL 60601 (312)555-1234 <br />Frank Williams 456 Oak Street Indianapolis, IN 46201 (317)555-9876 <br />Haley Snell 4231 Elm Street Detroit, MI 48201 (313)555-4938数据中的每一组包含了一个用户的用户名，地址，电话信息，如果使用默认的FS和RS变量，awk会通过空格来分割字段，通过换行符来分割记录，导致数据被错误解析，对于该文件，一行是一个字段，数据记录通过空白行分割，因此FS变量应当是换行符，RS变量为空字符串：<span class="text-red">awk 'BEGIN{FS="\n";RS=""}{print $1,$4}' data.txt </span>输出值为：Riley Mullen  (312)555-1234 Frank Williams  (317)555-9876 Haley Snell  (313)555-4938通过ORS可以修改输出记录分隔符awk 'BEGIN{FS="\n";RS="";ORS="======"}{print $1,$4}' data.txt 输出值：Riley Mullen  (312)555-1234 ======Frank Williams  (317)555-9876 ======Haley Snell  (313)555-4938======</div><h5 id="记录计数FNR和NR"><a href="#记录计数FNR和NR" class="headerlink" title="记录计数FNR和NR"></a>记录计数FNR和NR</h5><p>awk命令允许一次输入多个文件进行处理，在处理多文件时，<span class="tips">FNR</span>变量表示当前数据文件中已处理过的记录数，<span class="tips">NR</span>变量则含有已处理过的记录总数，FNR变量每处理完一个文件就会重置一次，而NR变量则会基于上一个文件的统计值继续增加。</p><div class="show">e.g.处理两个文件,统计处理的记录数awk ' &gt; BEGIN {FS=","} &gt; {"FNR="FNR,"NR="NR}' data1.txt data2.txt FNR=1 NR=1 #开始处理data1.txtFNR=2 NR=2 FNR=3 NR=3 FNR=1 NR=4 #开始处理data2.txtFNR=2 NR=5 FNR=3 NR=6FNR=4 NR=7</div><h4 id="其他内建变量"><a href="#其他内建变量" class="headerlink" title="其他内建变量"></a>其他内建变量</h4><p>awk还提供了一些用于提取shell环境变量，命令执行参数等信息的内建变量</p><div class="table"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>ARGC</td><td>命令行参数个数(Argument Count的缩写)</td></tr><tr><td>ARGV</td><td>命令行参数的值，以数组形式存储(Argument Vector的缩写)</td></tr><tr><td>ARGIND</td><td>awk处理的当前文件在ARGV中的位置</td></tr><tr><td>CONVFMT</td><td>数字的转换格式（参见printf语句），默认值为%.6 g</td></tr><tr><td>ENVIRON</td><td>当前shell环境变量及其值组成的关联数组</td></tr><tr><td>ERRNO</td><td>当读取或关闭输入文件发生错误时的系统错误号</td></tr><tr><td>FILENAME</td><td>用作gawk输入数据的数据文件的文件名</td></tr><tr><td>FNR</td><td>当前数据文件中的数据行数</td></tr><tr><td>IGNORECASE</td><td>设成非零值时，忽略gawk命令中出现的字符串的字符大小写</td></tr><tr><td>NF</td><td>数据文件中的字段总数</td></tr><tr><td>NR</td><td>已处理的输入记录数</td></tr><tr><td>OFMT</td><td>数字的输出格式，默认值为%.6 g</td></tr><tr><td>RLENGTH</td><td>由match函数所匹配的子字符串的长度</td></tr><tr><td>RSTART</td><td>由match函数所匹配的子字符串的起始位置</td></tr></tbody></table></div><h5 id="提取命令行参数"><a href="#提取命令行参数" class="headerlink" title="提取命令行参数"></a>提取命令行参数</h5><p><span class="tips">ARGC</span>和<span class="tips">ARGV</span>变量用来从shell中获得命令行参数的个数以及参数的值，其中，ARGV是一个数组，存储了命令行中所有参数的值，其索引从0开始。注意，awk不会将awk程序当作命令行参数的一部分。awk命令也可以指定多个输入文件，awk会依次处理这些文件中的内容，而<span class="tips">ARGIND</span>变量就用来获取当前awk程序处理的文件在ARGV数组中的索引</p><div class="show">1.awk不会将程序部分视为命令行的参数  awk 'BEGIN{print ARGC,ARGV[0]}' data.txt config.json 该命令行有3个参数，ARGV数组会存储这些参数，它们的值分别是：awk，data.txt，config.json。因此该命令输出值为：3 awk2.提取的参数只包含awk命令部分，如果shell命令包含其他部分，这些变量不会获取它们，如：ls -lh | sed '1d' | awk 'BEGIN{print ARGC,ARGV[0]}'ARGC和ARGV只会提取awk命令部分的参数个数和参数值1 awk3.ARGIND变量用来获取awk程序当前处理的文件在ARGV数组中的索引awk 'BEGIN{print ARGC,ARGV[2]}{print ARGIND}' data.txt config.json 每读取一行文件内容，awk程序会执行一遍(BEGIN和END指定的除外)，因此文件data.txt和config.json有多少行，print ARGIND语句就会执行多少次，输出值为：3 config.json 11222</div><h5 id="获取shell环境变量"><a href="#获取shell环境变量" class="headerlink" title="获取shell环境变量"></a>获取shell环境变量</h5><p>awk程序中也可以获取shell的环境变量，awk提供了一个关联数组<span class="tips">ENVIRON</span>用于存储shell环境变量，我们可以通过<span class="tips">ENVIRON[“环境变量名”]</span>的方式来提取环境变量的值</p><div class="show">e.g.在awk程序中获取环境变量HOME和PATH的值awk 'BEGIN{&gt;print ENVIRON["HOME"]&gt;print ENVIRON["PATH"]}'输出为：/root/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</div><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>awk允许像shell一样自定义变量，且声明变量的方法与shell类似，直接声明<span class="tips">变量名=值</span>即可，不需要var，int等关键字，变量名可以由字母、数字、下划线组成，且不能以数字开头，严格区别大小写。在awk中调用变量值时，<span class="tips">不需要$</span></p><h5 id="在程序中声明变量"><a href="#在程序中声明变量" class="headerlink" title="在程序中声明变量"></a>在程序中声明变量</h5><p>awk在程序中声明变量时，直接像shell变量一样声明使用即可</p><div class="show">1.变量值可以是字符串，调用变量时不需要$符号awk 'BEGIN{ name="Linux"; print name }'2.变量值也可以是数值，并且支持包括加减乘除、取余(%)、冥运算(^或**)在内的数学运算awk 'BEGIN{ x=10; x=x*10+20; print x }</div><h6 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h6><p>awk程序是按顺序执行的，因此变量也将按语句生效生效，且awk程序中的大括号语句块并不会限制变量的作用域，如果在变量生效前调用该变量不会有任何输出值。</p><div class="show">1.由于BEGIN语句块是最先执行的，因此剩下的语句块都可以调用BEGIN语句块中定义的变量awk 'awk 'BEGIN{ x=2 }{ print "普通语句块："x }END{ print "END语句块:"x }' data.txt输出值为：普通语句块：2 #data文件有多少行，普通语句块就执行多少次普通语句块：2普通语句块：2END语句块:22.END语句块是最后执行的，因此END语句块中定义的变量无法在其他语句块中调用awk 'BEGIN{print "BEGIN语句块："x}{print "普通语句块："x}END{x=2}' data.txt输出值为：BEGIN语句块：普通语句块：普通语句块：普通语句块：3. 普通语句块中定义的变量，可以在END和位于该语句块之后的普通语句块中调用awk 'BEGIN{print "BEGIN语句块："x}{x=2}{print "第二个普通语句块："x}END{print "END语句块:"x}' data.txt 输出值为：BEGIN语句块：第二个普通语句块：2第二个普通语句块：2第二个普通语句块：2END语句库:24.如果后面的普通语句块中定义了变量，前面的普通语句块在第一次执行程序时无法调用变量，但从第二次开始，由于该变量在第一次执行时会被存入，因此此后该变量就可以在前面的语句块中也读取到awk 'BEGIN{print "BEGIN语句块："x}{print "第一个普通语句块："x}{x=2}END{print "END语 句块："x}' data.txt 输出值为：BEGIN语句块：第一个普通语句块：   #第一次执行x并不存在第一个普通语句块：2  #awk读入文件第二行，程序再次执行，此时x存在第一个普通语句块：2第一个普通语句块：2END语句块：2</div><h5 id="在命令行中声明变量"><a href="#在命令行中声明变量" class="headerlink" title="在命令行中声明变量"></a>在命令行中声明变量</h5><p>变量也可以在命令行中赋值，尤其是当awk程序被写于文件中时，程序变量在文件中不方便修改，此时可以在命令行中定义或修改变量，能十分方便地在每次执行命令时指定不同的值。awk使用第一个非选项参数作为awk的程序，因此定义变量时，变量要写于awk程序之后，否则将报错</p><div class="show">1.awk变量可以直接在命令行上定义，下述语句会输出data文件每行的第一个字段awk '{print $x}' x=1 data.txt2. 但通过该方式定义的变量无法在BEGIN代码块中访问到awk 'BEGIN{print "begin代码块："x};{print "普通代码块："x}' x=10 data.txt输出值为begin代码块：    #输出的x值为空普通代码块：10普通代码块：103. 通过-v选项定义的变量，则可以在BEGIN代码块访问到awk -v x=10 'BEGIN{print "begin代码块："x};{print "普通代码块："x}' data.txt输出值为：begin代码块：10    #此时x的值可以访问到普通代码块：10普通代码块：104. 不使用选项定义变量时，变量不能写于awk程序前awk x=10 'BEGIN{print x}' data.txt该语句将报错</div><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>awk中使用的数组是关联数组，在定义和使用时需要加上数组的索引值</p><h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><p>数组变量赋值语法格式为：</p><div class="apiBox">数组名[索引值]=变量值</div><div class="show">数组索引可以为数值，也可以是字符串awk 'BEGIN{&gt;myArray[0]=10&gt;myArray[1]=20&gt;myArray["name"]="awk"&gt;}{&gt;print myArray[0]+myArray[1]&gt;print myArray["name"]&gt;}' data.txt输出值为：30awk</div><h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><p>由于用户无法提前得知数组的索引值是什么，因此awk提供了一个for语句可以用来获取awk的索引，用户可以在for语句中定义一个变量，for语句会将数组的索引赋值给该变量，然后就可以使用该变量作为索引获取到数组元素值，for语句语法格式为：</p><div class="apiBox">for (变量名 in 数组名){    循环体}</div><div class="show">awk 'BEGIN {&gt;array["name"]="awk";&gt;array["age"]=18;&gt;array["system"]="GNU/Linux";&gt;for(something in array){&gt;print something     #数组索引&gt;print array[something] #数组值}&gt;}'</div><h5 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h5><p>删除数组元素的命令为：</p><div class="apiBox">delete 数组名[索引值]</div><div class="show">数组元素删除后无法再调用delete array["name"]</div><h4 id="结构化命令"><a href="#结构化命令" class="headerlink" title="结构化命令"></a>结构化命令</h4><p>awk中的条件和循环语句与shell语法差别很多，更像是C语言的语法，循环语句支持使用<span class="tips">break</span>和<span class="tips">continue</span>语句跳出或跳过循环</p><h5 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h5><p>awk中的if-else语句不需要then：</p><div class="apiBox">if(条件语句){    #程序体}else{   #程序体    }</div><div class="show">e.g.文件data包含以下内容11 11AA 11AA22 22BB 22AA33 33CC 33AA44 44DD 44AA如果字段1大于30，则输出字段2，否则输出字段3awk '{if($1>30){ print "大于30";print $2}else {print "小于30"; print $3}}' data.txt使用多行模式代码更为清晰 awk '{&gt; if($1>30)&gt; {&gt; print "大于30"&gt; print $2&gt; }else&gt; {&gt; print "小于30"&gt; print $3&gt; }}' data.txt</div><h5 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h5><div class="apiBox">while(条件语句){    # 循环体   }</div><div class="show">awk 'BEGIN{&gt;i=1&gt;total=0&gt;while(i&lt;5)&gt;{&gt;total+=$i  #求字段1,2,3,4的和&gt;i++&gt;}&gt;print total}'</div><h5 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h5><div class="apiBox">do{    # 循环体   }while(条件语句)</div><h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><p>awk支持的for语句有两种，一种是C语言风格的for循环：</p><div class="apiBox">for(变量定义; 循环条件; 迭代语句){    # 循环体}</div><p>一种是用于数组迭代的for-in循环(详见数组部分)：</p><div class="apiBox">for (变量名 in 数组名){    # 循环体}</div><div class="show">e.g.计算0-9的和&gt; awk 'BEGIN{&gt; total=0&gt; for(i=0;i&lt;10;i++)&gt; {&gt;  total+=i;&gt; }&gt; print total }' </div><h4 id="格式化打印printf"><a href="#格式化打印printf" class="headerlink" title="格式化打印printf"></a>格式化打印printf</h4><p><span class="tips">print</span>语句只能进行基本的打印工作，如果要进行格式化打印需要使用<span class="tips">printf</span>语句，awk支持像C语言一样使用格式化打印命令，只是语法有略微不同：</p><div class="apiBox">printf "格式控制语句",变量1,变量2...</div><p>与C语言一样，printf语句支持以下控制字符：</p><div class="table"><table><thead><tr><th>控制字符</th><th>说明</th></tr></thead><tbody><tr><td>%c</td><td>输出一个字符，支持将0~255内的整数输出为ASCII码对应字符</td></tr><tr><td>%s</td><td>输出字符串</td></tr><tr><td>%d或%i</td><td>输出整数</td></tr><tr><td>%f</td><td>输出浮点数</td></tr><tr><td>%e</td><td>用科学计数法(规格化指数形式)输出数值</td></tr><tr><td>%g</td><td>根据数值大小自动选择使用%f或%e形式，保证输出宽度最小，不输出无意义的0</td></tr><tr><td>%o</td><td>以八进制形式输出整型</td></tr><tr><td>%x</td><td>以十六进制(字母小写)形式输出整型</td></tr><tr><td>%X</td><td>以十六进制(字母大写)形式输出整型</td></tr></tbody></table></div><p>另外，printf也支持：</p><ul><li>指定字宽，如：”%5d”，输出宽度为5的整数</li><li>指定小数位数，如：”%6.2”，输出包括小数点在内的6位数据，只保留2位小数(如果原数据小数部分超过两位，则四舍五入)</li><li>使用<span class="tips">-</span>来指定数据左对齐(默认情况下，数据会进行右对齐)</li><li>使用\t(制表符)、\n(换行符)等转义字符</li></ul><p>awk中printf语句的用法完全可以参考C语言printf()函数用法，这里只写简单示例</p><div class="show">1.整齐输出每个字段的数据awk '{printf "数据：%s\t%s\t%s\n",$1,$2,$3}' data.txt输出值：数据：11    11AA    11AA数据：22    22BB    22AA数据：33    33CC    33AA数据：44    44DD    44AA<br />2.输出浮点数，保留两位小数awk 'BEGIN{printf "%6.2f",10.175}输出6位，因此左边会补两个空格  10.18</div><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>awk提供了一些内建函数，用于处理字符串、时间等信息，以及进行数学运算</p><h5 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h5><p>在进行数学运算时，值不能太大，awk无法处理一些过大的数据</p><div class="table"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>sin(x)</td><td>正弦函数，x为弧度值</td></tr><tr><td>cos(x)</td><td>余弦函数，x为弧度值</td></tr><tr><td>atan2(x,y)</td><td>x/y的反正切，x和y为弧度值</td></tr><tr><td>exp(x)</td><td>e<sup>x</sup></td></tr><tr><td>log(x)</td><td>以e为底的对数，即log<sub>e</sub>x或ln x</td></tr><tr><td>sqrt(x)</td><td>x的平方根，即 x<sup>1/2</sup></td></tr><tr><td>int(x)</td><td>取x的整数部分，抛弃小数，不进行四舍五入</td></tr><tr><td>rand()</td><td>生成0-1(不包括0和1)之间的随机浮点数</td></tr><tr><td>srand(x)</td><td>以x为种子值，生成随机数</td></tr></tbody></table></div><div class="show">e.g.生成0-9之间(包括0和9)的随机整数x= int (10 * rand())</div><h5 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h5><p>awk提供了一些用于处理字符串的函数，以下函数方括号中的参数是可选项，如果直接给函数输入字符串时，注意添加双引号</p><div class="table"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>index(s,t)</td><td>返回字符串t在字符串s中的索引值，如果没找到的话返回0</td></tr><tr><td>length([s])</td><td>返回字符串s的长度；如果没有指定的话，返回$0的长度</td></tr><tr><td>tolower(s)</td><td>将s中的所有大写字符转换成小写</td></tr><tr><td>toupper(s)</td><td>将s中的所有小写字符转换成大写</td></tr><tr><td>asort(s [,d])</td><td>将数组s按元素值排序，索引值会被替换成从1开始的连续数字，原索引被覆盖。如果指定数组d，则排序后的数组会被存储在数组d中，原数组s保持不变</td></tr><tr><td>asorti(s [,d])</td><td>将数组s按索引值排序，并使用索引值作为元素值，原数组元素值被覆盖，而数组的索引值会使用从1开始的连续数字替换。如果指定d，则排序后的数字存储于数组d中，原数组s保持不变</td></tr><tr><td>gsub(r, s [,t])</td><td>从$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果找到了，就全部替换成字符串s</td></tr><tr><td>gensub(regexp, replacement, how [, target])</td><td>使用正则表达式regexp匹配字符串，然后使用replacement替换匹配到的文本，replacement中可以使用”\1”,”\2”等形式引用匹配的到的字符串，how用来指定替换方式，如果为”g”表示替换所有匹配项，如果为数字表示匹配第几个，target(可选)用来指定要应用替换的字符串，如果省略，则默认为$0</td></tr><tr><td>match(s, r [,a])</td><td>返回字符串s中正则表达式r出现位置的索引。如果指定了数组a，它会存储s中匹配正则表达式的那部分</td></tr><tr><td>split(s, a [,r])</td><td>将s用FS字符或正则表达式r（如果指定了的话）分开放到数组a中，返回字段的总数</td></tr><tr><td>sprintf(format, variables)</td><td>用提供的format和variables返回一个类似于printf输出的字符串</td></tr><tr><td>sub(r, s [,t])</td><td>在变量$0或目标字符串t中查找正则表达式r的匹配。如果找到了，就用字符串s替换掉第一处匹配</td></tr><tr><td>substr(s, i [,n])</td><td>返回s中从索引值i开始的n个字符组成的子字符串。如果未提供n，则返回s剩下的部分</td></tr></tbody></table></div><div class="show">1. index(s,t)函数返回字符串t从另一字符串s的哪个位置开始，它会将字符串s的每个字符(包括空格)都视为一个占位的字符，然后返回的是子字符串t是从字符串s的第几个字符位置开始awk 'BEGIN{print index("aa bb cc dd","cc")}'输出值为：7</div><div class="show">2. length([s])函数如果不指定字符串s，则会返回$0的长度如：输出data文件每行内容的文本长度(包含字段间的空格)awk '{print length()}' data.txt</div><div class="show">3. asort(s [,d])函数会按照数组元素在ASCII中的顺序对数组元素进行排序，大致排序类型为：数值(从小到大)->首字母大写的数组元素->首字母小写的数组元素，使用该函数进行排序时注意两点：(1)如果数组元素有数值，也有字符串，数值会按其大小正常排序，而不会将其转换为字符串进行处理(2)排序完的数组使用for-in遍历会乱序输出，无法正确看到被排序后的数组结果(3)关联数组的索引会被替换为从1开始的连续数字，索引从1开始而非0如：将下述代码写于文件script.awk中#!/bin/awk -fBEGIN {arr["shell"] = "bash"arr["number1"] = 2arr["number2"]=10arr["name1"] = "Awk"arr["name2"] = "awk"arr["char"] = "2"for(some in arr){ print some"-------"arr[some]}asort(arr);print "---------------\n"#使用for-in遍历关联数组输出顺序是随机的，想要数组按顺序输出则想要从索引1开始遍历，而不能用for-infor(i=1;i&gt;6;i++){   print i"-------"arr[i]}}给与script.awk文件执行权限后，执行./script.awk命令后输出值为：char-------2     #for-in语句输出顺序随机name1-------Awkshell-------bashname2-------awknumber1-------2number2-------10---------------1-------2    #数值按其大小正常排序，而不会将其作为字符按其ASCII码排序(否则10的首字母为1应该排于2前)2-------10   3-------2    #字符串类型的2排序于数值后4-------Awk  #首字母大写排于小写前5-------awk</div><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><p>awk支持以下位运算</p><div class="table"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>and(x,y)</td><td>将x与y按位进行<span class="text-red">与</span>运算</td></tr><tr><td>or(x,y)</td><td>将x与y按位进行<span class="text-red">或</span>运算</td></tr><tr><td>xor(x,y)</td><td>将x与y按位进行<span class="text-red">异或</span>运算</td></tr><tr><td>compl(x)</td><td>对x进行补运算(按位取反)</td></tr><tr><td>lshift(x,count)</td><td>将x左移count位</td></tr><tr><td>rshift(x,count)</td><td>将x右移count位</td></tr></tbody></table></div><h5 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h5><p>awk包含一些用来处理时间的函数</p><div class="table"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>systime( )</td><td>返回当前时间的UNIX时间戳</td></tr><tr><td>mktime(“YYYY MM DD HH MM SS”)</td><td>将一个按YYYY MM DD HH MM SS格式指定的日期转换成UNIX时间戳，如果输入的日期时间无效，则返回 -1</td></tr><tr><td>strftime(“时间格式” [,time])</td><td>将时间time(如果未指定time则使用系统当前时间)以指定格式输出(格式需要为系统函数date允许的格式)</td></tr></tbody></table></div><div class="show">1.systime( )会输出系统当前时间的UNIX时间戳，即返回系统当前时间到1970年1月1日以来的秒数，awk 'BEGIN { print systime() }'输出值：15807888002.mktime()函数会将指定的时间转换为UNIX 时间戳，该函数常用来计算时间间隔awk '&gt;BEGIN {&gt;    t1 = mktime("2000 01 01 12 00 00")&gt;    t2 = mktime("2020 07 31 12 00 00")&gt;    diff = t2 - t1&gt;    print "秒数差:", diff&gt;}'3.strftime()函数用来格式化时间，常用来将时间输出为指定格式awk 'BEGIN { print strftime("%Y-%m-%d %H:%M:%S") }'输出格式为：2020-11-02 16:30:05也可以指定一个时间戳awk 'BEGIN{time=systime();print strftime("%Y/%m/%d %H:%M:%S",time)}'输出值：2020/07/31/24 20:33:20</div><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><h5 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h5><p>在awk中定义、调用函数与C语言类似，但注意，在awk中需要将函数定义于代码块外，且必须出现在所有代码块之前(包括BEGIN代码块)，且awk中的自定义函数也支持传参与返回值：</p><div class="apiBox">function 函数名(形参){    #函数体  return 值   }</div><div class="show">e.g.对文件data.txt中的字段1和字段2求和awk '&gt;function add(num1,num2){&gt;return num1+num2&gt;}&gt;BEGIN{ print "程序启动" }&gt;{&gt;    result=add($1,$2)&gt;    print result&gt;}' data.txt </div><h5 id="函数库的创建与使用"><a href="#函数库的创建与使用" class="headerlink" title="函数库的创建与使用"></a>函数库的创建与使用</h5><p>可以将多个函数写于一个库文件中，然后在awk命令中使用-f选项调用，如果awk程序也要从文件中加载，可以使用多个-f选项</p><div class="show">e.g.库文件funclib定义了多个函数function myfunc1(){    ....}function myfunc2(){    ....}使用时在加载程序之前加载库文件即可：awk -f funclib -f script.awk data.txt</div><h4 id="调用外部变量"><a href="#调用外部变量" class="headerlink" title="调用外部变量"></a>调用外部变量</h4><p>在shell脚本中使用awk时，可能需要在awk中调用变量，有以下两种方法</p><div class="show">通过-v选项定义一个awk变量，然后将shell变量值赋值给该awk变量，如：newPort=8080awk -v port="$newPort" '{gsub(8000, port); print}' config.json</div><div class="show">通过双引号与单引号的巧妙使用来获取变量<span class="text-red">awk 'BEGIN{print "'"$变量名"'"}'</span>如：awk 'BEGIN{print "'"$LANG"'"}'输出值：en_US.UTF-8<span class="strong">解析：</span>awk程序由单引号来包裹，因此需要通过一对单引号来关闭awk程序，即初始的命令形式为：awk 'BEGIN{print ' $LANG '}'该命令中，'BEGIN{print '为一部分，'}'为另一部分，$LANG左侧的'号关闭了awk程序，将控制权重新交给shell，shell解析$LANG获取到变量值en_US.UTF-8，然后$LANG右侧的'号重新开启了awk程序，此时命令相当于awk 'BEGIN{print en_US.UTF-8 }'，awk会将en_US.UTF-8视为变量，从而报错因此需要在外层加上一对双引号，将shell程序解析结果作为字符串交给awk程序，即命令修改为：awk 'BEGIN{print "' $LANG '"}'为什么不加在里面写出：awk 'BEGIN{print '"$LANG"'}'这是因为''中的为shell需要解析的部分，对于shell来说，$LANG和"$LANG"是相同的，都会获取变量，这就相当于执行echo $LANG和echo "$LANG"都一样。如果写出这种形式，shell处理完变量，awk解析的命令依旧为：awk 'BEGIN{print en_US.UTF-8 }'，依旧会由于变量en_US.UTF-8不存在而报错而双引号加在外面相当于awk执行：awk 'BEGIN{print "en_US.UTF-8"}'，它会直接输出字符串通常情况下，awk 'BEGIN{print "' $LANG '"}'也可以获取到变量值但如果变量值本身包含空格或引号，这依旧可能造成awk工作错误，因此通常会在$LANG两边再加上一对双引号，将LANG变量的值完全作为一个整体值获取，命令优化为：awk 'BEGIN{print "'"$LANG"'"}'"'"$LANG"'"中最外层的双引号用来保证awk会将值作为字符串处理，最内层的双引号保证变量值会被作为整体处理</div><h4 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h4><p>awk 没有直接提供类似sed的 -i 的选项来修改原文件内容，通常是先备份原文件，然后将awk的处理结果重定向到临时文件或原文件的方式来实现这一功能</p><div class="show">e.g.修改文件data.txt中的字符串old_text为new_text，然后将awk处理结果重定向到临时文件temp中，处理完毕后修改其文件名为data.txt进行覆盖(在此之前应该先备份好data.txt)awk '{gsub(/old_text/, "new_text"); print}' data.txt > temp && mv temp data.txt</div>]]></content>
    
    
    <summary type="html">Linux三剑客其二——sed、awk的语法</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
  </entry>
  
</feed>
