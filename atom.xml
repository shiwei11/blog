<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SHWIVI&#39;s blog</title>
  
  
  <link href="https://shiwei11.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://shiwei11.github.io/blog/"/>
  <updated>2024-04-18T16:02:55.037Z</updated>
  <id>https://shiwei11.github.io/blog/</id>
  
  <author>
    <name>SHIWIVI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言</title>
    <link href="https://shiwei11.github.io/blog/2023/10/13/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/"/>
    <id>https://shiwei11.github.io/blog/2023/10/13/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/</id>
    <published>2023-10-13T15:28:06.000Z</published>
    <updated>2024-04-18T16:02:55.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><div class="contentFolded">在计算机诞生初期，人们使用<span class="strong">机器语言</span>来编写程序，机器语言的指令由操作码和操作数组成，均使用二进制代码表示，而二进制则通过在纸带上打孔来表示0或1，程序员将编写的机器语言指令打在纸带上并通过纸带机输入计算机中，以此进行运算。机器语言虽然能被计算机直接执行，但对人类来说难以阅读和记忆，不便编写。<p>为了简化机器语言的编写，1950年代中期，<span class="strong">汇编语言</span>应运而生。它使用助记符（mnemonic）来表示机器指令，极大地提高了程序员的工作效率。即便如此，书写和调试一个程序也需要用很长时间，并且需要程序员详细了解编写代码需要的指令、寄存器和CPU知识。</p><p>为了解决这些问题，IBM公司的一个研究小组开始着手研究一门能高效运行且简单易用的编程语言。1956年，IBM公司的John Backus带领他的团队开发出了世界上第一个<span class="strong">高级语言</span><span class="tips">FORTRAN</span>(FORmula TRANslation，意为公式翻译)，在科学和工程计算领域取得了很大成功，但该语言是专门为IBM 704计算机设计的，只能在特定型号的机器上工作。</p><p>为了解决这一问题，GAMM(德国应用数学和力学学会)、IBM、Datatron等公司要求ACM评估一种能脱离机器型号限定的“通用编程语言”。1958年5月，在美国计算机科学家Alan Jay Perlis的领导下，ACM、GAMM等代表在苏黎世会议上成立了IAL算法语言委员会，制定了国际算法语言(International Algorithmic Language,IAL)的定义并发布了IAL58语言。随后，ACM推崇IAL作为编程语言的标准，该算法语言由各种不同的“关键字”和“表达式”按照一定的语法规则组成，脱离了指令系统成为更接近人类的语言系统，编写者不必懂得完整的计算机的内部结构和工作原理也可以很好编写程序。</p><p>1959年，IAL被重新命名为ALGOL(算法语言)。</p><p>1960年，ALGOL算法语言委员会发布了<span class="tips">ALGOL 60</span>，里程碑式地引入了<span class="strong">递归</span>、<span class="strong">布尔类型</span>、<span class="strong">块结构</span>等概念，ALGOL 60也成为了后来所有计算机语言语法的鼻祖，Alan Jay Perlis也因此成为了世界首届图灵奖的获得者，以表彰其在 Algol 58 和 Algol 60 的形成和改进过程中的核心和关键作用。但ALGOL 60最大的缺点就是缺乏标准的输入输出能力，ALGOL 60编写的程序无法兼容不同的计算机外部设备，因此ALGOL 60迎来了进一步的迭代。</p><p>1963年，剑桥大学基于ALGOL 60发布了<span class="tips">CPL</span>（Combined Programming Langurage）语言，该语言旨在用于工业控制、数据处理等更为广泛的领域，因此规模宏大而复杂，编译器的编写进度十分缓慢，该语言并未大规模流行。</p><p>1967年，英国剑桥大学的Matin Richards对CPL语言做了简化，推出了<span class="tips">BCPL</span>(the Basic Combined Programming Language)语言，该语言是最早使用库函数封装基本输入输出的语言之一，主要用于编写系统和编译器，但BCPL对字符串的支持很差，并且内存管理很糟糕。</p><p>1969年，美国贝尔实验室的Kenneth Lane Thompson对BCPL语言做了改进和优化，由此衍生出了<span class="tips">B语言</span>，并用于书写<span class="strong">UNIX</span>系统，该语言的名字取自BCPL中的第一个字母，但此时的B语言过于简单，功能有限。</p><p>1972年，贝尔实验室的Dennis MacAlistair Ritchie在B语言的基础上设计出了<span class="tips">C语言</span>(取BCPL的第二个字母作为该语言的名字)，C语言保留了BCPL和B语言的优点，简练而接近硬件，又克服了它们无数据类型等缺点。1973年初， C语言的主体完成，汤普森和里奇使用C语言重写了UNIX操作系统，极大地提升了UNIX操作系统的可移植性，而C语言随着UNIX的广泛使用得到了迅速推广，成为了应用最广泛的计算机语言之一。</p><p>1983年，美国国家标准化协会(ANSI)制定了C语言标准——<span class="strong">ANSI C</span>，1987年，ANSI又公布了新的标准<span class="strong">87 ANSI C</span>，该标准于1990年被国际标准化组织(Internation Standard Organization)接受成为C语言国际标准——ISO/IEC 9899,简称<span class="strong">C89/C90</span>标准，是C语言的主流标准，被广泛应用于各个领域。1999年，ISO对C语言进行了大量扩展和改进，加入了如long long等新的数据类型，发布了<span class="strong">C99</span>标准，该标准在部分领域使用广泛，但在工业等领域普及度较低。目前最新标准为2018年发布的C17标准，但尚未被广泛使用。</div></p><h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><p>C语言源文件以<span class="tips">.c</span>为文件名后缀，从高级语言转换为机器码程需要经过<span class="strong">预处理</span>、<span class="strong">编译</span>、<span class="strong">汇编</span>、<span class="strong">链接</span>四个过程</p><h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>C语言源文件首先会被预处理，以一个名为hello.c的源文件为例，<span class="tips">hello.c</span>源文件经过预处理器处理，会生成一个<span class="tips">hello.i</span>临时文件，预处理阶段会进行以下工作：</p><ul><li>删除代码中的所有注释</li><li>对宏进行代码扩展，通过<span class="strong">#define</span>等指令定义的常量或表达式，会被替换到文件中，对<span class="strong">#if</span>等条件编译指令限定的代码进行选择性编译</li><li>包含文件，通过<span class="strong">#include</span>指令包含的文件，其内容会被添加到源文件中</li></ul><h6 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h6><p>编译器会将临时文件<span class="tips">hello.i</span>编译为汇编文件<span class="tips">hello.s</span>，该阶段编译器会对代码进行语法检查，并返回源代码中存在的语法错误和警告</p><h6 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h6><p>汇编程序将<span class="tips">hello.s</span>汇编文件编译成机器码，在<span class="strong">Windows</span>环境下生成<span class="tips">hello.obj</span>对象文件，在<span class="strong">Linux</span>环境下生成<span class="tips">hello.o</span>目标文件</p><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>链接器会将多个目标文件合并为一个文件，并与库函数文件(.lib)等依赖链接，生成可执行文件，在Windows环境下生成一个可执行文件 hello.exe，在 Linux环境下中生成 hello.out文件</p><p>库函数文件由各软件公司编写并已经编译成目标文件(.obj文件)，它们将在链接阶段与源程序编译而成的目标文件(.obj文件)相链接，生成可执行文件。</p><h4 id="C语言内存模型"><a href="#C语言内存模型" class="headerlink" title="C语言内存模型"></a>C语言内存模型</h4><p>准确来讲，这是Linux的虚拟空间布局的一部分，Linux系统内核进程和用户进程所占的虚拟内存比是1：3，Windows是2：2，以32位Linux系统为例，模拟一个4GB的内存地址块沙盘，其中高地址位的1GB内存为系统内核进程占用的内核空间，低地址位的3GB内存为用于用户内进程的用户空间，内核空间由操作系统负责维护和处理，因此本文只涉及日常开发中C程序可以操控的3GB用户空间部分。</p><p>该虚拟沙盘地址通过页表(Page Table)映射到物理内存，其中，蓝色区域会被映射到物理内存的不同内存段，白色区域只用于虚拟内存地址的分析，不会映射到物理内存中，不占用内存空间</p><img src="#" alt="C语言内存" data-src="/blog/images/20240316041218.png" style="max-width:420px;max-height:470px;"><h5 id="保留区-Reserved"><a href="#保留区-Reserved" class="headerlink" title="保留区(Reserved)"></a>保留区(Reserved)</h5><p>保留区是系统预留且禁止用户进程访问的地址区域，位于虚拟地址空间的最低部分，不赋予物理地址，一般用于捕捉空指针异常等情况。在大多数操作系统中，极小的地址空间通常都是不允许访问的，如NULL、0等。因此C语言也将无效指针赋值为0，因为0地址在正常情况下是不会存放有效的可访问数据的。</p><p>在32位X86架构的Linux系统中，系统将预留128MB的保留区，因此用户进程可执行程序一般从虚拟地址空间0x08048000开始加载内存区域。</p><h5 id="代码区-Code-Text"><a href="#代码区-Code-Text" class="headerlink" title="代码区(Code/Text)"></a>代码区(Code/Text)</h5><p>用于存放二进制代码，该区域是只读的，以防止恶意程序修改代码区的数据。代码段指令中包括操作码和操作数(操作对象)，如果操作对象是立即数(具体数值)，则该数据将直接包含在代码中；如果是字符串常量、变量中的数据，则将引用该数据地址。</p><h5 id="静态区-Static"><a href="#静态区-Static" class="headerlink" title="静态区(Static)"></a>静态区(Static)</h5><p>静态区又称全局区，这部分的空间大小在编译时就已经确定，因此是静态的，静态区分为<span class="strong">只读数据段</span>(RO Data，又称为常量区)、<span class="strong">已初始化数据段</span>(又称为读写数据段，RW Data)和<span class="strong">未初始化数据段</span>(又称为BSS段，Block Started by Symbol)三部分</p><ul><li><span class="strong">只读数据段(.rodata)：</span>只读，用于存储字符串常量，以及const修饰的只读全局变量(只读局部变量存储于栈区)、只读字符串变量，只读静态变量</li><li><span class="strong">已初始化数据段(.data)：</span>可读可写，存储已初始化且初值不为0的全局变量和静态局部变量</li><li><span class="strong">未初始化数据段(.bss)：</span>可读可写，存储未初始化或初始化为零的全局变量和静态变量。这些变量在编译阶段会被收集起来放到.bss段中，并在程序初始化时自动赋值为0(对数值型变量)或空字符(对字符变量)。由于.bss段的值全为0，因此这个段只记录段长，在编译-链接生成的可执行文件中不占用物理文件空间(全是0，没必要存储)，能在一定程度上节省磁盘空间。在程序执行(初始化)时，加载器(loader)根据其段长分配相应大小的内存，并将这些内存空间全部初始化为0。因此.bss段不占用物理文件尺寸，但占用内存空间；.data段占用物理文件，也占用内存空间</li></ul><h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h5><p>由程序员分配释放，如果程序员不释放，则操作系统在程序结束时回收，通过<span class="tips">malloc</span>、<span class="tips">realloc</span>、<span class="tips">calloc</span>语句开辟空间，通过<span class="tips">free</span>释放。</p><p>堆内存的增长方向为由低地址向高地址增长，其工作方式类似于数据结构中的<span class="tips">链表</span>。在操作系统中有一个记录空闲内存地址的链表，当使用malloc()等语句开辟内存空间时，操作系统会遍历该链表，寻找第一个空间大于等于所申请空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序，此外，系统会在该空间的首地址处记录所分配的空间大小，以便free语句能正确释放空间。</p><p>由于每次分配的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中，频繁的开辟、释放空间势必会造成内存空间的不连续，从而造成大量碎片。</p><p>堆空间的大小受限于系统的有效虚拟内存，32位Linux系统中堆内存可达2.9G空间。堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。</p><h5 id="内存映射段-mmap"><a href="#内存映射段-mmap" class="headerlink" title="内存映射段(mmap)"></a>内存映射段(mmap)</h5><p>该区域用于映射可执行文件用到的动态链接库到内存中，方便更快速地读取。<br>此外，在Linux中，如果通过malloc()请求一个大的内存空间，C运行库将在该区域创建一个匿名内存映射，而不使用堆内存。</p><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>内存映射是一种强大的文件I/O技术，用于高效读写文件。它将文件映射到虚拟内存空间中，并且支持按需加载文件，然后通过内存地址来访问文件，从而避免了大量的文件读写操作，比传统的文件读写操作更加快捷方便。</div><h5 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h5><p>栈内存由<span class="tips">编译器</span>负责分配和释放，主要用于存放：</p><ul><li>函数内部定义的局部自动变量(auto类型)，包括const修饰的只读局部变量</li><li>函数参数和返回值</li><li>调用函数时的上下文环境，如函数返回地址等</li><li>暂存一些算术表达式的计算结果</li><li>alloca()函数分配的栈内内存</li></ul><p>栈内存的增长方向为由高地址向低地址增长，其工作方式与数据结构中的栈相似，即先入后出，且栈分配的内存空间是连续的，不会有碎片化现象。栈是由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多</p><p>栈空间的大小由系统预定义(通常默认2M或10M)，当栈剩余空间大于所申请空间时，系统将分配内存，否则将抛出栈溢出(stack overflow)错误</p><h5 id="各段生成时间"><a href="#各段生成时间" class="headerlink" title="各段生成时间"></a>各段生成时间</h5><p>在C语言程序编译-链接后生成的映像文件中，将只包含代码段、只读数据段(.rodata)和读写数据段(.data)，双击运行该文件后，程序在初始化时将动态生成未初始化数据段(.bss)，程序的运行过程，将动态生成堆(Heap)和栈(Stack)</p><div class="show">char str[]="hello"; //数组末尾会添加'\0'代表存储结束char * str="hello";如果它们都是局部变量，则字符数组会在栈区申请空间，并将字符存储在数组空间中；而指针变量，字符串存储在全局区的只读数据段，栈中的指针变量存储的是其字符串在全局区中的地址如果它们声明为全局变量，则字符数组声明在全局const 声明的全局变量存储于静态区const 声明的局部变量存储于栈const 声明的字符串常量存储于静态区只读区 const char* str="hello"</div><h3 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h3><p>预处理命令是C语言源程序中用于改进程序设计环境、提高编程效率的特殊命令，不属于C语言的组成部分，无法进行编译，只会对其在预处理阶段作出相应处理。预处理命令以<span class="tips strong">#</span>开头，且不以分号结尾，以便与一般的C语言语句区分</p><h4 id="include文件包含"><a href="#include文件包含" class="headerlink" title="#include文件包含"></a>#include文件包含</h4><p><span class="strong">文件包含</span>处理指将一个源文件中的内容包含到另一个源文件中，被包含的文件称为<span class="strong">头文件</span>(或标题文件)，文件名常以<span class="tips">.h</span>作为后缀，也可以以<span class="tips">.c</span>作为后缀甚至没有后缀。在编译的预处理阶段，头文件中的内容会被复制到主文件中，替换掉 #include &lt;xxx.h&gt;语句，得到一个新的源文件，再对该文件进行编译。</p><ul><li><span class="strong">#include &lt;文件名&gt;</span>一般用于包含系统库函数头文件</li><li><span class="strong">#include “文件名”</span>一般用于包含用户自己编写的头文件</li></ul><div class="show">eg:C语言中常用的标准输入输出函数头文件#include &lt;stdio.h&gt;// std：standard(标准)，i为input，o为output，将包含标准输入/输出函数的头文件stdio.h包含到源文件中</div><p>注意事项：</p><ul><li>一个#include语句只能包含一个文件，如果要包含多个文件，则只能使用多个语句</li><li>使用<span class="tips">&lt;文件名&gt;</span>包含文件时，系统会到存放C语言库函数头文件的路径下寻找该文件，，使用<span class="tips">“文件名”</span>包含文件时，系统会首先在用户当前目录中寻找文件，如果没有，再去C语言库函数路径下</li><li>如果A文件包含了B文件，而B文件需要使用C文件中的内容，则可以在A文件中使用两个#include命令同时包含文件B和C，且包含C文件的指令需要出现在包含B文件的指令前。也可以嵌套包含，即B文件包含C文件，A文件包含B文件</li><li>A文件包含B文件后，B文件中的内容会在预处理阶段被复制到A文件中，因此B文件中的全局静态变量在A文件中有效，不需要extern声明语句</li><li>#include通常用于包含.h头文件，也可以包含其他文本文件，如：源代码文件(.c)、c++的头文件(.hpp或.hxx)、库文件(.lib、.dll、.a等)，甚至可以为.txt文本文件</li></ul><h4 id="define-宏定义"><a href="#define-宏定义" class="headerlink" title="#define 宏定义"></a>#define 宏定义</h4><p>用一个指定的标识符代表一个字符串，在编译预处理阶段，预处理器会对源代码中的宏名进行<span class="strong">宏展开</span>，即将宏名替换成对应的字符串</p><ul><li><span class="strong">#define 标识符 字符串</span> 定义无参宏定义</li><li><span class="strong">#undef 标识符</span> 终止宏定义</li><li><span class="strong">#define 标识符(参数表列) 字符串</span> 定义带参数的宏定义</li></ul><p>注意事项： </p><ol><li>宏名一般使用<span class="strong">大写字母</span>表示，以便与普通变量名区分</li><li>宏定义只用作字符串替换，与定义普通变量不同，不分配内存空间</li><li>宏定义可以嵌套定义</li><li>宏定义用于定义符号常量，定义完毕后不能再赋值，也不能被修改</li><li>宏定义语句写于函数外，作用范围为宏定义语句之后到本源文件结束，或者到<span class="tips">#undef 宏名</span>行终止</li><li>预处理阶段只对宏名进行字符串替换，不作语法准确性检查。如果宏定义中有错误，只有在宏名被宏展开后的编译阶段，编译器对源程序进行语法检查时才会发现宏定义中存在的错误</li></ol><div class="show"> //无参数宏定义#include &lt;stdio.h>#define PI 3.1415926#define R 4.0#define L 2*PI*R //嵌套定义宏int main(){    float l=L;    printf("%f",l);    return 0;}#undef R  //终止R的作用范围void f1(){....}</div><div class="show"> //带参宏定义#include &lt;stdio.h>#define L(r,s) r+s //带多个参数的宏定义#define M(r) 3*r*r #define N(r) 3*(r)*(r)int main(void){ int a=1,b=2,result; result=L(a,b); //展开为result=a+b; result=M(a+b); //展开为result=3*a+b*a+b<span class="tips">注意宏定义时参数不带()可能会被展开为错误形式</span> result=N(a+b); //展开为result=3*(a+b)*(a+b); return 0;}</div><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p><span class="strong">条件编译</span>指预处理器根据条件编译指令，选择性将源代码中的部分代码送到编译器进行编译</p><h6 id="ifdef宏定义判断"><a href="#ifdef宏定义判断" class="headerlink" title="#ifdef宏定义判断"></a>#ifdef宏定义判断</h6><p><span class="strong">#ifdef 标识符<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span><br>如果指定的标识符已经被#define定义过，则编译程序1，否则编译程序2，程序1和程序2既可以是C语句，也可以是预处理命令，类似于if…else…语句，#else可以不使用</p><div class="show">#include &lt;stdio.h>#define TEST //TEST定义甚至可以为空，也视为被定义过#ifdef TEST    #define SIZE 32 //TEST被定义过，所以执行该语句#else    #define SIZE 64#endif....</div><h6 id="ifndef无宏定义判断"><a href="#ifndef无宏定义判断" class="headerlink" title="#ifndef无宏定义判断"></a>#ifndef无宏定义判断</h6><p>逻辑与#ifdef相反，如果指定的标识符未被#define定义，则编译程序1，否则编译程序2<br><span class="strong">#ifndef 标识符<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span></p><h6 id="if表达式判断"><a href="#if表达式判断" class="headerlink" title="#if表达式判断"></a>#if表达式判断</h6><p>如果表达式值为真，编译程序1，否则编译程序2<br><span class="strong">#if 表达式<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span></p><div class="show">#include &lt;stdio.h>#define LINUX 1 //可以快速设置编译的目标平台，缩减源代码长度int main(void){    #if LINUX        printf("linux专用代码");    #else        printf("非linux用代码");    #endif    .....    return 0;}</div><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>C语言中变量的声明方式如下：<br><span class="strong"><span class="text-green">存储类型</span><span class="text-blue">数据类型 </span> 变量名;</span></p><ul><li>存储类型代表编译器为变量分配内存的方式，如：自动变量内存分配于动态存储器，静态变量和外部变量内存分配于静态存储区，寄存器变量存储位置分配于CPU中的寄存器</li><li>存储类型和作用域(变量定义的位置)决定了变量的生存期</li><li>数据类型指该变量存储的数据类型</li><li>变量名需要满足标识符命名规则</li></ul><h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p><span class="strong">标识符</span>即C语言中的变量名、符号常量名、函数名、数组名等用来给数据对象命名的字符序列，标识符需要满足以下规则：</p><ul><li>只能由英文字母、数字、下划线组成</li><li>不能以数字开头</li><li>不能使用关键字</li><li>严格区分大小写</li></ul><h4 id="变量的作用域和生存期"><a href="#变量的作用域和生存期" class="headerlink" title="变量的作用域和生存期"></a>变量的作用域和生存期</h4><p>变量从其作用域区分，分为局部变量和全局变量：</p><p><span class="strong">局部变量</span>：定义在函数内部或{ }包裹的代码块内部，只在本函数或代码块内生效，分为静态局部变量和动态局部变量。默认情况下，局部变量的存储类型为auto(动态局部变量)，变量内存位于动态存储区，代码块内的语句执行完毕变量就会被销毁，释放其内存。可以将局部变量的存储类型定义为static(静态局部变量)，此时变量内存位于静态存储区，整个程序运行期间其内存不会被释放</p><p><span class="strong">全局变量</span>：定义在函数的外部，默认存储类型为extern，有效作用域为变量定义位置开始到本源文件结束，其作用域可以通过extern声明进行拓展。全局变量在程序的整个执行过程都占用内存单元。<span class="tips">习惯上，全局变量的首字母用大写表示</span>，当全局变量名和局部变量名相同时，局部变量有效</p><p>变量的生存期是指变量从生成(分配内存)到被销毁(释放内存)的时间段。对于存储在静态存储区中的变量，其内存在编译时就已经确定，是静态的，内存空间在整个程序运行期间不会被释放，变量与程序共存亡。而对于存储在动态存储区中的变量，其内存由操作系统根据程序运行动态分配。变量的存储类型直接决定了变量的生存期。</p><div class="show">#include&lt;stdio.h>int Number=0;   //全局变量首字母大写int main(void){    void test();    int num=10;    int Number=10; //局部变量生效，全局变量被"屏蔽"    test();    return 0;}void test(){    Number=100; //全局变量可以被任意函数访问和修改，会降低程序清晰性}</div><h4 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h4><p>C语言提供的存储类型主要有以下几种：</p><ul><li>自动变量 auto</li><li>静态变量 static</li><li>外部变量 extern</li><li>寄存器变量 register</li></ul><h5 id="auto自动变量"><a href="#auto自动变量" class="headerlink" title="auto自动变量"></a>auto自动变量</h5><p>又称动态局部变量或局部作用域变量，定义于函数内部，是C语言中极为常用的变量类型，因此C语言把它设计为缺省类型(默认类型)，即auto可以省略不写，反之，如果没有指定局部变量的存储类型，则默认为auto，因此以下两个语句等价</p><div class="show"><code>&#123;int num=10;auto int num=10;&#125;</code></div><p>自动变量数据存储在<span class="text-blue">动态存储区</span>中，操作系统会在代码执行到变量定义语句时为其分配内存，退出所属语句块时释放内存。函数形参和函数内定义的变量(未明确声明为static)都属于该类变量。自动变量有以下特点：</p><ul><li>自动变量在定义时不会自动初始化。所以除非程序员显式指定初值，否则自动变量的值是随机的垃圾值</li><li>自动变量在退出函数(语句块)后，其分配的内存立即被释放，再次进入该语句块，该变量被重新分配内存，所以不会保存上一次退出时的值</li></ul><h5 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h5><p>静态变量分为静态局部变量和静态外部变量，二者用于不同的场景。静态变量在<span class="text-blue">静态存储区</span>分配内存，在整个程序运行期间不会被释放，与程序共存亡。对于已经初始化的静态变量，其内存空间位于静态存储区的.data段，在编译时赋予内存。对于未初始化的静态变量，其内存空间位于静态存储区的.bss段，并在程序初始化时，给变量赋值0(对数值型变量)或空字符(对字符变量)。</p><h6 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h6><p>自动变量的内存会在代码退出函数块后被释放，其值也不会被保留，下次进入该函数块，该变量会被分配新的内存，如果希望变量的值在退出函数语句块后依旧被保留，其占用的存储单元不释放，方便函数基于上一次的运算结果进一步进行计算，此时可以使用static关键字将局部变量定义为静态局部变量。</p><div class="show">eg:计算n的阶乘<code>int main(void)&#123;    int i,n;    scanf("%d",&n);    for(i=1;i&lt;=n;i++)&#123;        Func(i);    &#125;    return 0;&#125;long Func(int n)&#123;    static long p=1;    return p*n;&#125;</code></div><p>静态局部变量，有以下特点：</p><ul><li>如果定义静态局部变量时不赋初值，编译器会自动赋为0(对数值型变量)或空字符(对字符变量)</li><li>自动变量(动态局部变量)占据的内存在函数调用结束后会被释放，每次调用都需要重新初始化。而静态局部变量仅在第一次调用函数时被初始化一次，其占据的内存在退出函数后不会被释放，再次调用该函数其值上次退出函数时的值</li><li>虽然静态局部变量在函数调用结束时仍然存在，但其他函数是无法引用它的</li></ul><h6 id="静态外部变量"><a href="#静态外部变量" class="headerlink" title="静态外部变量"></a>静态外部变量</h6><p>外部变量默认存储类型为extern，可以被其他文件使用extern声明后引用，如果希望外部变量只限于被本文件使用，而不能被其他文件引用，则可以在声明外部变量时添加static声明，将其声明为静态外部变量，该类变量可以应用于以下场景：</p><ul><li>多人开发时，可以在不同文件中声明同名外部变量而互不干扰</li><li>权限控制，避免其他文件引用或修改外部变量的值</li></ul><div class="show"><code>static int Number;</code></div><h5 id="extern外部变量"><a href="#extern外部变量" class="headerlink" title="extern外部变量"></a>extern外部变量</h5><p>如果定义在函数之外的变量没有指定其他存储类别，那么它就是一个外部变量，外部变量是全局变量，作用域是从它的定义点到本文件末尾。但如果要在定义点之前或在其他文件中使用它，那就需要使用关键字extern对其进行声明(注意不是定义，编译器不为其分配内存)<br>声明语句为:<br><span class="strong">extern 类型名 变量名;</span><br>其中类型名可以省略，因此以下语句等价</p><div class="show"><code>extern int Num1;extern Num1;</code>注意！在定义外部变量时，直接在函数外定义 int Num1;  即可int Num1;  是“定义性声明”语句，会给变量分配内存空间，extern int Num1;  为“引用性声明”语句，用于拓展外部变量作用域，不会分配内存，不能用来定义一个未初始化的外部变量但如果在定义时进行初始化，根据右结合原则，会当作定义了变量，并进行了extern作用域拓展处理extern int Num1=200;//既是定义语句，也是extern声明语句</div><h6 id="在一个文件内声明外部变量"><a href="#在一个文件内声明外部变量" class="headerlink" title="在一个文件内声明外部变量"></a>在一个文件内声明外部变量</h6><p>如果外部变量不在文件开头定义，那么它的作用域就是从它的定义点到本文件末尾。如果在定义点之前想要引用该变量，则需要在引用之前对使用extern对其进行外部变量声明，声明后就可以从声明之处起，合法使用该外部变量</p><div class="show"><code>int main(void)&#123;    int getMax(int ,int);    <span class="text-blue">extern Num1,Num2;</span>//外部变量声明(仅作声明，不分配内存)    printf("max is:%d", getMax(Num1,Num2);)//在定义前引用变量&#125;int Num1=10,Num2=20;//定义外部变量int getMax(int x,int y)&#123;    return x>y?x:y;&#125;</code></div><h6 id="在多文件中声明外部变量"><a href="#在多文件中声明外部变量" class="headerlink" title="在多文件中声明外部变量"></a>在多文件中声明外部变量</h6><p>C语言程序也可以由多个源文件组成，如果多个文件都需要用到同一个外部变量，不能在多个文件中都同时定义该变量，否则程序在链接阶段会出现“重复定义”错误。正确做法是：在某一个文件中定义外部变量，其他文件中用extern对该变量作“外部变量声明”，将变量的作用域拓展到这些文件中，然后在这些文件中合法引用外部变量。</p><div class="show">eg:文件file1.c中输入变量Num的值，文件file2.c对Num扩大10倍后返回结果file1.c文件:<code>#include&lt;stdio.h&gt;<span class="text-blue">int Num;</span>//定义外部变量int main(void)&#123;    int getValue(int);    printf("Input the value of Num:");    scanf("%d",&Num);    printf("%d",getValue(10));    return 0;&#125;</code>file2.c文件:<code><span class="text-red">extern Num;</span>//声明A为其他文件已经定义的外部变量int getValue(int n)&#123;    return Num*n;&#125;</code></div><h5 id="register寄存器变量"><a href="#register寄存器变量" class="headerlink" title="register寄存器变量"></a>register寄存器变量</h5><p>对于使用频率较高的变量，可以将其声明为寄存器变量，减少CPU对内存的频繁数据访问，使得程序更小，执行速度更快</p><div class="show"><code>int main(void)&#123;    int n;    long countNum(int);    scanf("%d",&n);    countNum(n);    return 0;&#125;long countNum(int n)&#123;    register long i,f=1;    for(i=1;i&lt;n;i++)&#123;          f=f*i;    &#125;    return f;&#125;</code></div><p>寄存器变量有以下特点：</p><ul><li>只有局部自动变量和形参可以作为寄存器变量</li><li>CPU中的寄存器数量有限，不能定义太多的寄存器变量</li><li>有的系统把寄存器变量当作自动变量处理，在内存中分配存储空间，并非放到寄存器中</li></ul><p>现代编译器能自动优化程序，自动把普通变量优化为寄存器变量，并且可以忽略用户定义的寄存器变量，因此一般无需特别声明变量为register，仅作了解。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="数据类型总览"><a href="#数据类型总览" class="headerlink" title="数据类型总览"></a>数据类型总览</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><div class="table"><table>        <thead>            <tr>                <th colspan="2">分类</th>                <th>关键字</th>                <th>长度(Bytes)</th>                <th>示例</th>            </tr>        </thead>        <tbody>            <tr>                <td rowspan="5">整型</td>                <td>短整型</td>                <td>short</td>                <td>2</td>                <td>short a;或                    short int a;                </td>            </tr>            <tr>                <td>整型</td>                <td>int</td>                <td>4</td>                <td>int a;</td>            </tr>            <tr>                <td>长整型</td>                <td>long</td>                <td>4</td>                <td>long a;或                    long int a;                </td>            </tr>            <tr>                <td>长长整型</td>                <td>long long</td>                <td>8</td>                <td>long long a;或                    long long int a;                </td>            </tr>            <tr>                <td>无符号整型</td>                <td>unsigned</td>                <td>8</td>                <td><div>unsigned int a;</div>                     unsigned long  a;                </td>            </tr>            <tr>                <td rowspan="3">浮点型(实型)</td>                <td>单精度</td>                <td>float</td>                <td>4</td>                <td>float a;</td>            </tr>            <tr>                <td>双精度</td>                <td>double</td>                <td>8</td>                <td>double a;</td>            </tr>            <tr>                <td>长双精度</td>                <td>long double</td>                <td>12或8</td>                <td>long double a;</td>            </tr>            <tr>                <td colspan="2">字符型</td>                <td>char</td>                <td>1</td>                <td>char a;</td>            </tr>            <tr>                <td colspan="2">枚举型</td>                <td>enum</td>                <td>-</td>                <td>enum res{yes,no,none};</td>            </tr>        </tbody>    </table></div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>long long,unsigned long long,long double是C99标准新增的，部分编译器默认使用C89标准，需要手动指定使用C99标准编译才支持以上数据类型。此外，ANSI C标准对于数据类型所占内存的字节数并无明确定义，因此不同编译器中各数据类型的字节数可能不同</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>C语言中没有string类型，处理字符串一般使用字符数组或指针，也没有bool类型，不能使用true和false逻辑常量</div><h5 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h5><div class="table"><table><thead><tr><th>构造类型</th><th>关键字</th><th>示例</th></tr></thead><tbody><tr><td>数组</td><td>-</td><td>int num[10];</td></tr><tr><td>结构体</td><td>struct</td><td></td></tr><tr><td>共用体</td><td>union</td><td>union{int num;char name[5];}man</td></tr></tbody></table></div><h5 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h5><div class="table"><table><thead><tr><th>数据类型</th><th>关键字</th><th>示例</th></tr></thead><tbody><tr><td>指针</td><td>-</td><td>int * p;</td></tr><tr><td>无类型</td><td>void</td><td>void f1(){…}</td></tr></tbody></table></div><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型从符号位的归属可分为<span class="strong">有符号整型(signed)</span>和<span class="strong">无符号整型(unsigned)</span>。有符号整型最高位为符号位，0表示该值为正数，1表示该值为负数，而无符号整型的最高位不表示正负，依旧用于储存数值，因此无符号整型只能表示0和正整数，但无符号整型可存储的数值范围要比同位数的有符号整型大2倍，如：signed int数值范围为-32768-32767，而unsigned int 数值范围为0-65535。如果一个整型不声明为unsigned或signed，则默认隐含为signed，因而signed可以省略不写。</p><p>对于短整型和长整型，int也可以省略不写(以下[]内的均可省略不写)</p><div class="table"><table><thead><tr><th>类型</th><th>比特位数</th><th>取值范围</th></tr></thead><tbody><tr><td>[signed] short [int]</td><td>16</td><td>-2<sup>15</sup>~(2<sup>15</sup>-1)</td></tr><tr><td>unsigned short [int]</td><td>16</td><td>0~(2<sup>16</sup>-1)</td></tr><tr><td>[signed] long [int]</td><td>32</td><td>-2<sup>31</sup>~(2<sup>31</sup>-1)</td></tr><tr><td>unsigned long [int]</td><td>32</td><td>0~(2<sup>32</sup>-1)</td></tr></tbody></table></div><p>对于整型常量，通常在其数值后加上相应符号表示其具体类型，如：加上<span class="tips">U或u</span>表示无符号整型，加上<span class="tips">L或者l</span>表示长整型</p><div class="show">233u或233U为无符号整型-1024l或-1024L为长整型203lu为无符号长整型</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>如果使用u标识一个负整数,如-12345u，则将取-12345补码对应的无符号整数53191按无符号数存储</div><div class="show">-12345原码：1011 0000 0011 1001反码：1100 1111 1100 0110补码：1100 1111 1100 0111 --->对应无符号数值为53191</div><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点数有两种表示方式：</p><ul><li>十进制小数形式，如：0.5,1.3,.95(省略0)</li><li>指数形式，以e或E为底数(其中e代表10)，e的左边为数值部分，e的右边为指数部分(必须为整数)，如：12.3可以表示为1.23e1、0.123e2、123e-1等形式，如果e左边的数值部分，小数点左边有且只有一位非零的数字，则该表示方法称为<span class="tips">“规范化的指数形式”</span>，如：1.23e1为规范化的指数形式，而0.123e2、123e-1不是</li></ul><p>C语言默认将浮点型常量作为<span class="tips">双精度(double)</span>类型进行处理，如果在常量后加上<span class="tips">f或F</span>将作为float型处理，加上<span class="tips">l或L</span>则作为long double型处理，eg:1.25e-2f，1.25L</p><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符常量使用<span class="tips">单引号’’</span>包裹，一个字符占用一个字节(中文字符需要两个字节)。字符在内存中以ASCII码形式存储，因此字符型数据和整型数据是通用且可以用于计算的(仅限于0-255之间的整数)，常见的应用为<span class="tips">大写字符+32转换为小写字符</span></p><div class="show">char a=97;int  asciiA=a-32;printf("%c\n",asciiA)//输出Aprintf("%d",asciiA)//输出65</div><p>此外，C语言中还有一些特殊的转义字符，作用如下</p><div class="table"><table><thead><tr><th>字符</th><th>含义</th><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行</td><td>\a</td><td>响铃报警提示音</td></tr><tr><td>\r</td><td>回车(不换行)，将光标位置移到当前行开头</td><td>\“</td><td>双引号</td></tr><tr><td>\0</td><td>空操作字符，常用作字符串结束标志</td><td>\‘</td><td>单引号</td></tr><tr><td>\t</td><td>水平制表，跳到下一个Tab位置</td><td>\\</td><td>反斜线</td></tr><tr><td>\v</td><td>垂直制表</td><td>\?</td><td>问号</td></tr><tr><td>\b</td><td>光标位置退一格</td><td>\ddd</td><td>1到3位八进制ASCII码代表的字符</td></tr><tr><td>\f</td><td>换页</td><td>\xhh</td><td>1到2位十六进制ASCII码代表的字符</td></tr></tbody></table></div><div class="show">1. \ddd和\xhh是用一个八进制或者十六进制的ASCII码表示一个字符，如："\101"和"\x41"转换为十进制为65，表示ASCII码值为65的字符A2.注意\r和\b的使用，会覆盖掉\r、\b之前的字符printf("abcdefg\r1234");//输出1234 fg，光标回到本行开头，1234\0替换掉abcde(字符串末尾会添加\0，因此\0替换e并输出空白字符)printf("abcdefg\b\b\b\b123");//输出abc 123printf("abcdefg\b\b\b\b\b\b\b123");//输出123 efgprintf("abcdefg\b\b\b\b\b\b\b123\n");//输出123defg</div><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串常量使用<span class="tips">双引号””</span>包裹，字符串末尾会被加上<span class="tips">‘\0’</span>作为字符串结束的标志。C语言中没有专门的关键字用来声明字符串变量，因此需要使用字符数组或者指针来存储和处理字符串</p><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>字符串可以存储于字符数组中，但字符数组中存储的并不一定是字符串，这取决于字符数组最后一个元素是否是字符串结束标志’\0’，’\0’也占用一个字节内存，但它不计入字符串的实际长度，只计入数组长度。注意，如果字符数组最后没有’\0’，系统将无法将该数组当作字符串来处理(如：无法正确被printf(“%s”,xx)输出)</p><div class="show">对于字符数组，可以像其他数组一样用同样的方式初始化，如：<code>char str[6]=&#123;'H','e','l','l','o','\0'&#125;;</code>如果省略对数组长度的声明，则必须人为在初始化列表中添加'\0'，否则系统将无法将str当作字符串来处理<code>char str[]=&#123;'H','e','l','l','o'&#125;;//长度为5的普通字符数组char str[]=&#123;'H','e','l','l','o','\0'&#125;;//长度为6的字符串</code>用printf("%s",str)语句输出上述变量时，第一个变量由于缺少'\0'，输出语句会在输出完Hello后继续输出乱码，直到遇见'\0'，而第二个变量会被正常输出<p>也可以用字符串常量初始化字符数组，这样可以不指定数组大小，且由于字符串常量”Hello”末尾自带’\0’，可以不必人为添加’\0’<br><code>char str[6]=&#123;"Hello"&#125;;<br>char str[]=&#123;"Hello"&#125;;//数组长度可省略<br>char str[]="Hello";//大括号可省略</code><br><span class="text-red">但只允许在定义时整体赋值，不允许在赋值语句中整体赋值</span><br><code>char str[6];<br>str[]=&#123;"Hello"&#125;;//不允许先定义，定义完在赋值语句中整体赋值,Visual Studio报错：不允许使用不完整的类型</code><br>无论用哪种方式初始化字符数组，如果指定数组长度，都要保证预留足够空间以便存储字符串结束标志，即：字符数组大小一定要比字符串的实际字符数大1<br>可以使用数组下标访问字符串的单个字符，如：<br>str[1]代表字符’e’</div></p><div class="show">一个字符串可以用一维字符数组存储，多个字符串可以用二维字符数组存储。数组的第一维长度代表要存储的字符串个数，可以省略；第二维长度不能省略，应当设定为最长那个字符串长度+1，eg:<code>char weekday[][10]=&#123;"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"&#125;;</code>其中最长的字符串"Wendesday"长度为9，因此第二维长度应当为10，对于长度小于10的字符串，其剩余的内存单元会被'\0'填充如果字符串太长，可以拆分为几个小片段写在不同行，其中空格也将占用数组长度和空间<code>char longString[]="One day you will leave this world behind""so live a life you will remember"</code></div><h4 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h4><p>字符指针是指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一确定的地址，因此只要将字符串首地址赋值给指针变量，就可以让字符指针指向一个字符串。对于字符串常量，C语言按字符数组处理，在内存中开辟一个字符数组存储该字符串，字符串常量本身就代表存放它的常量存储区的首地址。</p><div class="show">1. 以下两个初始化语句等价，均表示将字符串常量在常量存储区中"Hello"的首地址赋值给ptr<code>char * ptr="Hello";</code>等价于<code>char * ptr;ptr="Hello";</code>2. 由于字符串常量存储于只读的常量存储区中，因此只可以修改指针变量的指向，不能修改ptr所指向存储单元的内容*ptr='a';//错误！写入权限异常，不能修改所指向存储空间的内容ptr="another";//允许修改指针的指向3. 通过指针也可以访问单个字符，如：*(ptr+1)代表字符'e'也可以修改指针指向位置，使其从所指位置开始输出，直至遇到'\0'，以此输出字符串的部分内容，如：<code>char * sentence="Meet you like the wind";sentence=sentence+14;printf("%s",sentence);//输出the wind</code></div><h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><p>字符串的输出支持以下三种方法：</p><div class="show">1. 依次输出单个字符<code>for(int i=0;i&lt;6;i++)&#123;    printf("%c",str[i]);&#125;</code>由于字符串长度并不等于字符数组大小，且上述方法无法灵活输出不同长度字符串，因此一般会借助字符串结束标志'\0'来结束字符串输出，如：<code>for(int i=0;str[i]!='\0';i++)&#123;    printf("%c",str[i]);&#125;</code>2. 用格式符s，将字符串作为一个整体输出，同样输出到字符串结束标志为止<code><span class="text-red">printf("%s",str)</span></code>3. 使用<span class="text-blue">puts()</span>函数(&lt;stdio.h>库函数)，puts()函数用于从括号内的参数给出的地址开始，依次输出存储单元中的字符，直到遇到第一个'\0'时输出结束，并自动输出一个换行符，缺点是该函数无法如printf()函数一样添加其他字符信息并控制输出格式<code><span class="text-red">puts(str)</span></code></div><p>字符串指针变量可以指向一个格式字符串，可以替代printf()函数中的格式，作为一种可变格式的字符串输出</p><div class="show"><code>char * format;format="a=%d,b=%f\n";printf(format,a,b);也可以用字符数组实现char format[]="a=%d,b=%f\n";printf(format,a,b);</code></div><h4 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h4><p>与输出相似，字符串的输入支持以下三种方法：</p><div class="show">1. 依次输入单个字符<code>for(int i=0;i&lt;6;i++)&#123;    scanf("%c",&str[i]);&#125;</code>2. 用格式符s，将字符串作为一个整体输入，直至遇到<span class="tips">空白字符、空格、回车符、制表符</span>为止，注意！<span class="text-blue">由于字符数组名str本身已经代表字符串的首地址，因此str前不能再加上取地址符&</span>，此外，用scanf()不能输入带空格、制表符的字符串，空格、制表符、回车符及其之后的字符会被留在输入缓冲区<code><span class="text-red">scanf("%s",str);</span></code>3. 使用<span class="text-blue">gets()</span>函数(&lt;stdio.h>库函数)，gets()函数以回车符作为输入终止符，同时将回车符从输入缓冲区读走，但不作为字符串的一部分，因此该函数可用于输入带空格的字符串<code><span class="text-red">gets(str);</span></code><p>以上方法都有一定的安全隐患，如果输入字符数超过了定义的字符数组大小，多出的字符可能引起缓冲区溢出，带来安全隐患，因此可以使用能限制输入字符串长度的函数<br><span class="text-blue">fgets(str,sizeof(str),stdin)</span><br>该语句表示从标准输入stdin中读取一行长度为sizeof(str)的字符串存储到str为首地址的存储区中，多余的字符舍弃</div></p><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>注意！如果使用字符指针输入字符串，必须保证字符指针事先已经指向一个字符数组地址或确定的存储单元，否则可能导致非法内存访问错误！</div><div class="show">使用字符指针输入字符串需要注意以下情况<code>char * ptr;//ptr未被初始化scanf("%s",ptr);</code>上述代码，编译时给指针变量ptr分配了内存单元，但ptr中的值是一个不可预料的垃圾值，该指针指向一个未确定的存储单元，可能指向空白存储区，也可能指向已经存放指令或数据的内存段，在现代编译器中会报错使用了未初始化的局部变量“ptr”，然而在低版本编译器中可能顺利通过编译，带来潜在安全隐患因此，推荐使用字符数组输入字符串<code>char str[10];scanf("%s",str);</code>如果使用字符指针输入字符串，则保证该指针指向了确定的地址<code> char str[10];<span class="text-red">char * ptr=str;</span> gets(ptr);</code></div><h3 id="构造类型-1"><a href="#构造类型-1" class="headerlink" title="构造类型"></a>构造类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>定义方式： </p><div class="apiBox">类型 数组名[数组长度]</div><p>数组名的命名规则遵守标识符命名规范，数组长度需要使用常量表达式，<span class="tips">不能包含变量</span>，一维数组的初始化可以使用以下方法：</p><ul><li>在定义时赋予全部初值，如：int nums[5]={0,1,2,3,4};</li><li>也可以只给一部分元素赋值，其余元素会被赋0(char类型赋’\0’)，如：int nums[5]={0,1};</li><li>如果全部元素相同，可以只写一个值，如:int nums[5]={0};</li><li>如果对全部元素赋予初值，由数据个数已经确定，可以不指定数组长度，如：int nums[]={0,1,2,3,4};</li></ul><div class="show">1. 数组在定义时可以被整体初始化赋值<code>int nums[5]=&#123;11,22,33,44,55&#125;;</code><span class="text-red">但不允许在赋值语句中被整体赋值</span><code>int nums[5];nums[]=&#123;11,22,33,44,55&#125;;//错误</code>这是由于数组在定义时，编译系统就会为其分配连续的内存单元，其内存空间大小就已确定，后续的整体赋值语句如果执行，可能会导致内存覆盖或溢出等不可预期的行为，所以需要注意用数组和指针操作字符串时的不同情况<code>char str[6];str[]=&#123;"Hello"&#125;;//错误char * ptr;ptr="Hello";//正确</code>2. <span class="text-blue">数组名代表数组首元素的内存地址，即数组的起始地址，是一个地址常量，不能像修改指针变量一样对数组名进行++或--等操作</span><code>int a[10];int *p;p=a;p++;//允许，指针指向a[1]a++;//不允许，a是数组首地址，无法修改</code>3. C语言数组无length属性，获取数组长度可借助sizeof()函数<code>int nums[] = &#123;1,2,3,4,5&#125;;printf("%d", sizeof(nums)/sizeof(nums[0]));</code></div><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>定义方式： </p><div class="apiBox">类型 数组名[数组长度][数组长度]</div><p>对数组名和数组长度的要求同一维数组，二维数组的初始化可以使用以下方法：</p><ul><li>分行赋值，如：<code>int nums[3][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;</code></li><li>也可以一次性统一赋值，但不如第一种赋值方法清晰，如：<code>int nums[3][2]=&#123;1,2,3,4,5,6&#125;</code></li><li>可以只给部分元素赋值，同样其余元素会被赋0(char类型赋’\0’)，如：<code>int nums[3][2]=&#123;&#123;1&#125;,&#123;&#125;,&#123;0,6&#125;&#125;</code></li><li>如果对所有元素赋初值，可以不指定第一维的长度，但<span class="tips">第二维的长度声明永远不能省略</span></li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>对于复杂数据对象，仅仅使用几种基本数据类型无法准确反映它们之间的内在联系，也无法做统一处理，于是衍生出了允许用户自定义的数据类型，C语言中称之为构造数据类型(复合数据类型)，结构体就是构造数据类型的典型代表</p><p>结构体模板的声明格式如下：</p><div class="apiBox">struct 结构体名{    结构体成员};</div><p>结构体模板只是声明了一种数据类型，并未声明结构体类型的变量，编译器不为其分配内存，需要再使用以下语句声明结构体变量，编译器才会为结构体变量分配内存：<br><span class="strong">struct 结构体名 结构体变量名;</span></p><ul><li>结构体的名字又称为结构体标签，用于标记用户自定义的结构体类型，struct+结构体名 共同构成一个数据类型，如：下述例子中的struct student是一个类型名，作用同系统提供的标准类型(如int、char等)，因此不为其分配内存</li><li>结构体成员的命名遵从变量的命名规则</li><li>结构体成员也可以为一个结构体，即结构体可以嵌套</li><li>结构体成员名可以与程序其他位置的变量名相同，二者互不干扰</li></ul><div class="show">eg:先声明结构体模板，再声明结构体变量<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;;//声明结构体模板，末尾;不可省略struct student stu1,stu2;//声明结构体变量</code></div><p>也可以在声明结构体模板时，定义结构体变量：</p><div class="apiBox">struct 结构体名{    结构体成员}变量名1,变量名2...;</div><div class="show">eg:声明结构体模板同时声明结构体变量<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;stu1,stu2;</code>eg:当结构体模板与结构体变量一起声明时，结构体名是可以省略的，但该方法由于未指定结构体名，无法在程序其他地方再定义结构体变量，因此并不常用<code>struct//无结构体名&#123;    long studentID;    char studentName[10];    int score[4];&#125;stu1,stu2;</code></div><p>关键字<span class="strong">typedef</span>用于为已有数据类型定义一个别名，数据类型别名通常大写，便于区分已有数据类型。定义结构体时可用typedef定义一个结构体别名，便于使用更简洁的形式定义结构体变量</p><div class="show">为结构体定义别名时，以下两个别名定义形式等价：<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;;<span class="text-blue">typedef struct student STUDENT;</span>与<span class="text-blue">typedef</span> struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;<span class="text-blue">STUDENT</span>;</code>二者都为struct student类型定义了一个新名字STUDENT，因此以下两条定义结构变量的语句等价：<code>STUDENT stu1,stu2;//简洁形式struct student stu1,stu2;</code></div><h4 id="结构体变量初始化与成员引用"><a href="#结构体变量初始化与成员引用" class="headerlink" title="结构体变量初始化与成员引用"></a>结构体变量初始化与成员引用</h4><p>结构体变量的成员可以通过将成员初值置于花括号内进行初始化</p><div class="show">eg:在定义结构体变量时初始化<code>STUDENT stu1=&#123;114604,"SHIWIVI",&#123;111,222,333,444&#125;&#125;</code>也可以在定义结构体模板和变量同时初始化<code>struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125;stu1=&#123;114604,"SHIWIVI",&#123;111,222,333,444&#125;&#125;</code></div><p>访问结构体变量的成员必须使用<span class="tipe">成员选择运算符</span>(圆点运算符)，访问格式为：<br><span class="apiBox">结构体变量名.成员名</span></p><ul><li>C语言规定，不能将结构体变量作为一个整体输入、输出，如：printf(“%d%s..”,stu1)为非法语句</li><li>只能通过用圆点运算符访问结构体成员的方式来输入输出，如：printf(“%s”,stu1.studentName)</li><li>成员运算符<span class="tips">.</span>在所有运算符中优先级最高，因此通常可以将stu1.studentName当成一个整体看待</li><li>结构体嵌套时，必须以级联方式访问结构体成员，如：stu1.birthday.year</li><li>结构体成员可以像普通变量一样进行各种运算，如：stu1.birthday.year++</li><li>C语言允许对具有相同结构体类型的变量进行整体赋值，如：stu1初始化后，可以通过stu2=stu1对stu2进行初始化，结构体成员会进行逐一顺序赋值</li><li>也可以使用=号对结构体成员进行分开赋值，但注意，当结构体成员为字符数组时，由于<span class="text-red">字符数组名是该数组的首地址，是一个地址常量，不能作为赋值表达式左值</span>，因此对字符数组类型的结构体成员进行赋值时，必须使用字符串处理函数<span class="text-blue">strcpy()</span></li><li>结构体变量的地址是其所占存储空间的首地址，而结构体成员的地址与该成员在结构体中的所处位置和所占内存字节数有关，可以单独访问成员地址，如：&amp;su1.studentID</li></ul><div class="show"><code>#include&lt;stdio.h&gt;typedef struct date&#123;    int year;    int month;    int day;&#125;<span class="strong">DATE</span>;typedef struct student&#123;    long studentID;    char studentName[10];    <span class="strong">DATE</span> birthday;    int score[4];&#125;int main(void)&#123;    STUDENT stu1=&#123;114604,"SHIWIVI",&#123;1998,10,1&#125;,&#123;111,222,333,444&#125;&#125;;    STUDENT stu2;    <span class="text-blue">stu2=stu1;//整体赋值</span>    //也可以对结构体成员分开赋值，整体赋值等价于下述赋值语句    stu2.studentID=stu1.studentID;    <span class="text-blue">strcpy(stu2.studentName,stu1.studentName);</span>    stu2.birthday.year=stu1.birthday.year;    ...    stu2.score[0]=stu1.score[0];    ...    //通过键盘输入成员值时，单独访问成员变量地址    scanf("ld%",&su1.studentID);    scanf("%s",stu1.studentName);    scanf("%d",&stu1.birthday.year);    for(int i=0;i&lt;4;i++)&#123;        scanf("%d",&stu1.score[i]);    &#125;    return 0;&#125;</code></div><h4 id="结构体所占内存字节数"><a href="#结构体所占内存字节数" class="headerlink" title="结构体所占内存字节数"></a>结构体所占内存字节数</h4><p>系统为结构体变量分配内存大小时，结构体类型所占字节数，并非是所有成员所占内存字节数的总和，这是因为许多计算机系统为了提高寻址效率，处理器体系为特定的数据类型引入了<span class="strong">内存对齐</span>需求，编译器为了满足处理器的对齐要求，会在较小的成员后加入补位，从而导致结构体实际所占内存字节数会比预计的多出一些字节。<br>如：32位计算机体系结构，short型数据从偶数地址开始存放，int型数据则被对齐在4字节地址边界，这样就保证了一个int型数据通过一次内存操作就能被访问到，而读取存储在没有对齐地址处的32位整数，则需要两次读取操作，再从两次读取到的64位数据中提取该32位整数相关的数据，这样会导致系统性能下降</p><p>因此计算结构体类型大小时一定要使用<span class="text-red">sizeof()</span>运算符，不能想当然直接对各成员所占内存进行简单求和。</p><div class="show"><code>#include&lt;stdio.h>typedef struct sample &#123;    char c1;    int num;    char c2;&#125;SAMPLE;int main(void) &#123;    SAMPLE s = &#123; 'a',10,'b' &#125;;    printf("%d", sizeof(s));//12而非6    return 0;&#125;</code>根据内存对齐需求，如下图所示，c1和c2后会被增补3个字节补位，以达到与成员变量num内存地址对齐的要求，因此结构体变量s将占用12个字节的存储单元而非6个字节。如果将int类型改为short，则c1和c2将以short(2字节)为基准，后补1个字节空闲存储单元，s将占用6个字节内存<p><canvas width="200" height="110" id="canvasStruct" style="display:block;width:200px;height:110px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>const canvasStruct=document.getElementById("canvasStruct");const ctxSt=canvasStruct.getContext('2d');ctxSt.strokeRect(50, 10, 120, 90);ctxSt.moveTo(50,40);ctxSt.lineTo(170,40);ctxSt.strokeRect(80, 10, 30, 30);ctxSt.strokeRect(110, 10, 30, 30);ctxSt.moveTo(50,70);ctxSt.lineTo(170,70);ctxSt.strokeRect(80, 70, 30, 30);ctxSt.strokeRect(110, 70, 30, 30);ctxSt.stroke();ctxSt.font="600 13px Serif";ctxSt.fillText("成员1", 10, 30);ctxSt.fillText("c1", 60, 30);ctxSt.fillText("成员2", 10, 60);ctxSt.fillText("num", 100, 60);ctxSt.fillText("成员3", 10, 90);ctxSt.fillText("c2", 60, 90);</script></div><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>与普通数组类似，结构体数组也可以在定义时统一初始化</p><div class="show">eg:在结构体数组定义时初始化数组，如果只初始化部分数组元素，则其余数组元素会被自动赋为0值<code>STUDENT stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;//数组长度可以省略不写或struct student&#123;    long studentID;    char studentName[10];    int score[4];&#125; stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;访问数组元素的方法与普通数组一样printf("%ld",stu[1].studentID);</code></div><h4 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h4><p>可以使用一个指针变量p指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址，随后，就可以使用<span class="text-red">指向运算符</span>(箭头运算符)访问结构体的成员，以下三种访问结构体成员变量的方式等价：</p><ul><li><span class="strong">结构体变量.成员名</span></li><li><span class="strong">(*p).成员名</span></li><li><span class="strong">p-&gt;成员名</span><div class="show"><code>struct student stu1=&#123;1101,"LiLin",11,22,33,44&#125;;<span class="text-blue">struct student * p=&stu1;</span>printf("%ld"，<span class="text-red">stu1.studentID</span>);printf("%ld"，<span class="text-red">(*p).studentID</span>);printf("%ld"，<span class="text-red">p->studentID</span>);</code></div></li></ul><p>指针也可以指向结构体数组，操作同指向普通数组类似，对指针进行的++操作会使指针指向下一个结构体数组元素</p><div class="show"><code>STUDENT stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;struct student * p=stu;for(;p&lt;stu+3;p++)&#123;    printf("%s\n",p->studentName);&#125;//p被定义为是指向struct student类型的指针，如果需要将其指向其他类型，可以使用强制类型转换p=(struct student *)stu[0].studentName;printf("%s",p);//输出stu[0]的studentName//但此时p仍然保持原来的类型，p+1将指向stu[1]的studentNameprintf("%s",p+1);</code></div><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体(也称为联合,Union)是将不同类型的数据存放在一起，占用同一段内存的一种构造数据类型，共用体的声明形式与结构体类似：</p><div class="apiBox">union 共用体名{    共用体成员};</div><ul><li>共用体类型所占内存大小取决于其成员中所占内存空间最大的成员变量</li><li>共用体同一内存段可以用来存放不同类型的数据，但在同一时间只能存放其中一种类型的成员，也就是说，同一时刻只能有一个成员起作用</li><li>共用体变量中起作用的成员是最后一个被赋值的成员，在存入一个新的成员值后，原有的成员值会被覆盖</li><li>共用体的成员一般单独赋值、调用</li><li>共用体变量的地址和其各成员的地址都是同一个地址</li><li>共用体不能进行比较操作</li><li>共用体不能作为函数参数，也不能作为函数返回值，但可以使用指向共用体变量的指针</li><li>不能只引用共用体变量，需要引用共用体的具体成员</li></ul><div class="show"><code>union sample&#123;    short i;    char ch;    float f;&#125;;union sample a;//共用体a中i,ch,f共占一段内存空间，因此a的大小由成员最大数据类型float决定，占用4个字节a.i=10;//可以给共用体成员单独赋值a.ch='R';a.f=11.11;//完成上述3个赋值运算后，只有a.f有效，a.i和a.ch将被覆盖失效//如果在定义时初始化共用体的成员初值，C89规定只能对共用体的第一个成员进行初始化，但c99无该限制，允许按以下形式按名设置成员初值<span class="text-blue">union sample b=&#123;.i=10,.ch='b',.f=22.22&#125;;</span>//但也只有f会生效</code></div><p>共用体可以用来存储程序中逻辑相关但情形互斥的变量，共享内存空间可以节省内存，也避免了操作失误引起的逻辑冲突。如：职工管理系统中，职工的个人婚姻状况只能有三种情况：未婚、已婚、离婚。且这三种情况应当是互斥的，此时可以用共用体来存储该数据</p><div class="show">eg:未婚标识为0，已婚则记录结婚日期、配偶姓名，离婚则记录离婚日期<code>struct date&#123;    int year;    int month;    int day;&#125;;struct marriedState //已婚信息&#123;    struct date marryDate;//记录结婚日期    char spouseName[20];//记录配偶姓名&#125;;struct divorceState //离婚信息&#123;    struct date divorceDay;//记录离婚日期&#125;;<span class="text-blue">union maritalState</span> //共用体，存储婚姻状况&#123;    int single;//未婚    struct marriedState married;//已婚    struct divorceState divorce;//离婚&#125;;struct person&#123;    char name[20];    char sex;    int age;    union maritalState marital;    int marryFlag; //共用体无法直接看出是哪个成员生效，因此使用一个变量标记婚姻状态&#125;;</code></div><p>共用体也可以用来构造混合数据结构，高效使用存储空间，如：需要存储的数据是int和float型数据的混合，可以定义如下共用体：</p><div class="show"><code>typedef union&#123;    int i;    float f;&#125;NUMBER;NUMBER array[20];//既可以存储int数据，也可以存储float数据</code></div><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>当一个变量只有几种固定的值时，就可以使用枚举表示，枚举类型的定义方法与结构体类似，需要使用enum关键字：</p><div class="apiBox">enum 枚举标签名{    枚举常量}枚举变量名;</div><ul><li><span class="strong">枚举常量都是整型常量</span>，除非特别指定，否则其值按顺序为0，1，2….</li><li>允许在定义时明确指定枚举常量的值，如：enum response {no=1,yes=1,none=0}，也可以只指定前几个值，其后的值会自动递增，如：enum month{Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec};</li><li>程序员在花括号内定义的枚举常量只作为标识符使用，并不代表什么含义，其值本质仍是整型常量，不是字符串</li><li>枚举常量可以作为整型值进行比较、输出操作</li><li>可以定义枚举型数组，如：enum response answers[10];</li></ul><div class="show"><code>enum response&#123;no,yes,none&#125;;enum response res1,res2;或enum response&#123;no,yes,none&#125; res1,res2;或enum &#123;no,yes,none&#125; res1,res2;//枚举类型和枚举变量一起定义时，枚举标签可省略</code></div><div class="show"><code>1. 枚举变量的赋值只能从枚举常量中选取enum response&#123;no,yes,none&#125; res1,res2;res1=yes;//只能赋值no、yes、none中的其中一个2. 枚举变量可以用于条件语句，比较规则是按其定义时的整型值进行比较，默认情况下为：no=0,yes=1,none=2if(res1==yes)if(res1>none)3. 枚举常量的值是整型常量，因此只能作为整型值处理，而不能作为字符串来使用printf("%d",res1);//正确，输出res1为1printf("%s",res1);//错误！不能作为字符串使用，无法输出yes4. 虽然枚举常量都表示为整型常量，但不能直接将整型常量赋值给枚举变量，因为它们属于不同类型res1=2; //错误可以进行强制类型转换，相当于将值为2的none赋给res1，2也可以替换为表达式res1=(enum response)2;</code></div><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h4><div class="table"><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>int * p</td><td>指向整型数据的指针变量</td></tr><tr><td>int *p[n]</td><td>指针数组，数组中含n个指针</td></tr><tr><td>int (*p)[n]</td><td>二维数组的行指针，p指向含n个元素的一维数组</td></tr><tr><td>int * p()</td><td>p为返回指针的函数，该指针指向整型值</td></tr><tr><td>int (*p)()</td><td>p为指向函数的指针，该函数返回整型值</td></tr><tr><td>int **p</td><td>p为指向指针的指针，p指向的指针指向整型数据</td></tr></tbody></table></div><ul><li><span class="strong">指针</span>：一个变量的地址称为该变量的”指针”，反之亦然，变量的指针即变量的地址</li><li><span class="strong">指针变量</span>：专门用于存放地址的变量</li><li><span class="strong">&amp;</span>：取地址运算符</li><li><span class="strong">*</span>：指针运算符，取出指针变量指向的内容，又称为间接寻址运算符<br>指针的定义：<div class="apiBox">数据类型 * 变量名</div></li></ul><div class="show"><code>int a=10;int * p;//定义int *类型的变量p，p只能用于存储地址，*只是表明该变量是指针变量p=&a;//取出变量a的地址并存储到p中printf("%d",* p);//*p表示取出变量p中地址指向的内容，等价于printf("%d",a)printf("%p",&a);//输出变量a在内存中所占存储空间的首地址，等价于printf("%p",p)</code></div><p>使用指针的注意事项：</p><ul><li><span class="text-red">不要使用未初始化的指针变量</span>，未决定指针指向时，可以使指针变量初始化为<span class="text-blue">NULL</span>(stdio.h中定义为零值的宏)</li><li>要永远清楚指针指向哪里，指针必须指向一块有意义的内存</li><li>要永远清楚每个指针指向的对象内容是什么</li></ul><h4 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h4><p>使用指针操作数组可以有效提高运行速度，减小内存占用。数组在定义时，编译系统就会为其分配连续的内存单元，相应地，内存首地址也确定了。C语言中，数组名代表数组首元素的内存地址(数组名作形参时除外，此时数组名不占据内存单元)，因此可以直接将数组名赋值给指针变量</p><div class="show">由于<ul><li>数组变量名代表数组起始内存地址</li><li>数组首元素地址也是数组起始内存地址</li></ul>因此指针初始化一般可以用两个赋值方法，两个赋值语句等价:int a[10]; int * p;<span class="text-red">p=a;</span>或<span class="text-red">p=&a[0];</span></div><p>而后，就可以使用指针引用数组元素。对于指针变量p，p+1将指向数组的下一个元素，即地址跳到<span class="text-green">1*sizeof(基类型)</span>个字节以后，而非对p中的地址进行简单加1，如：如果p指向int类型的数组，p+1会将p中的地址值增加4个字节对应的地址值，使其指向4个字节以后的空间。使用指针引用数组元素有以下特点：</p><div class="apiBox">p+i和a+i均是a[i]的地址*(p+i)和*(a+i)均是a[i]的值</div><p>实际上，读取数组元素a[i]就是通过*(a+i)处理，即在数组首元素地址的基础上加上地址偏移量得到要找元素的地址，然后取出该地址中的数据，由此可得，<span class="tips">[ ]实际上是变址运算符</span>，指向数组的指针变量也可以使用该变址运算符，如：p[i]等价于*(p+i)等价于i[p]</p><div class="show">数组元素a[i]的表示方法有：<span class="strong">a[i]</span>、<span class="strong">i[a]</span>、<span class="strong">p[i]</span>、<span class="strong">i[p]</span>、<span class="strong">*(a+i)</span>、<span class="strong">*(p+i)</span></div><h5 id="常用的指针变量运算"><a href="#常用的指针变量运算" class="headerlink" title="常用的指针变量运算"></a>常用的指针变量运算</h5><ul><li><span class="strong">*p++</span> 右结合，解析为*(p++)，先获得*p的值，再使p+1=&gt;p</li><li><span class="strong">*(++p)</span> 先对p加1，使其指向下一个元素，再获得此时*p的值</li><li><span class="strong">(*p)++</span> 获得*p的值，并对该值加1</li><li><span class="strong">*(p--)，*(--p)，(*p)--</span> 与上类似</li></ul><h5 id="数组元素的遍历"><a href="#数组元素的遍历" class="headerlink" title="数组元素的遍历"></a>数组元素的遍历</h5><p>在遍历数组元素时，通过数组下标或通过数组元素地址遍历，二者执行效率是相同的，C编译系统对nums[i]的处理也是将其转换为*(nums+i)来作处理的，即根据首元素地址重新计算元素偏移地址，再访问该地址</p><p>而通过指针变量遍历时，指针变量通过有规律地改变地址值(p++)，直接指向元素，不必每次都重新计算地址，极大提高了执行效率</p><div class="show">遍历数组的三种方法：int nums[5]={11,22,33,44,55};//1.利用数组下标for(int i=0;i&lt;5;i++){    printf("%d",nums[i])}//2.通过求出数组元素地址，获得值for(int i=0;i&lt;5;i++){    printf("%d",*(nums+i))}<span class="strong">//3.通过指针变量for(int *p=nums;p&lt;(nums+5);p++){    printf("%d",*p)}</span>注意：p++和p+1本质是两个不同的操作，特别对于指针变量而言，p++有赋值操作，会修改p的值从而使p指向下一个元素，而p+1并不改变当前指针的指向<p><span class="text-red">数组名nums代表数组元素首地址，是一个指针常量，它的值是固定不变的，因此只能像*(nums+i)一样基于此地址进行计算,不能使用nums++改变该地址值</span><br>for(int *p=nums;nums&lt;(p+5);nums++){//错误代码<br>    printf(“%d”,*a)<br>}</div></p><h4 id="指针与函数传参"><a href="#指针与函数传参" class="headerlink" title="指针与函数传参"></a>指针与函数传参</h4><p>使用指针作为函数参数时，不再是简单的<span class="tips">值传递</span>，而是<span class="tips">地址传递</span>，可以直接修改原参数的值</p><div class="show">eg:将一个数组中的值反序存放并输出<code>#include&lt;stdio.h>int main(void) &#123;    void inv(int*, int);    int nums[10] = &#123; 0,11,22,33,44,55,66,77,88,99 &#125;;    printf("original array：");    for (int* p = nums; p < nums + 10; p++) &#123;        printf("%d ", *p);    &#125;    <span class="text-red">inv(nums, 10);</span>    printf("\ninverted array：");    for (int* p = nums; p < nums + 10; p++) &#123;        printf("%d ", *p);    &#125;    return 0;&#125;void inv(<span class="text-red">int * p,int n</span>) &#123;//n为数组长度    int temp;    for (int i = 0; i < n / 2; i++) &#123;        temp = *(p+i);        *(p + i) = *(p + n - 1 - i);        *(p + n - 1 - i) = temp;    &#125;&#125;</code>在函数中修改数组值，实参与形参的对应关系一般有以下4中1. 形参和实参都用数组名，形参接收实参的数组首地址，因此形参和实参数组共用一段内存空间。定义形参a[]时，可以不指定数组长度，因为编译器实际上是将形参数组名作为指针变量来处理，并不会真的开辟一个数组空间void inv(int a[],int n)             inv(nums,10)2. 实参用数组名，形参用指针变量。形参的指针初始指向数组元素首地址void inv(int *p,int n)              inv(nums,10)3. 实参和形参都用指针变量。实参n先指向数组首地址，再将该地址值传递给形参p，初始时两个指针指向同一个地址void inv(int *p,int n)              int *n=nums; inv(n,10)4. 实参为指针变量，形参为数组名。编译时，编译系统会将形参数组名作为a作为指针变量来处理，同样，初始时两个指针指向同一个地址void inv(int a[],int n)             int *n=nums; inv(n,10)</div><h4 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a>二维数组与指针</h4><p>一维数组可以拓展到二维数组、三维数组等等，以二维数组为例，一个二维数组可以视为是由多个一维数组构成的，即二维数组的数组元素也是一个数组。</p><div class="show">设一个3行4列的二维数组<code>int a[3][4]={{0,0,0,0},{11,11,11,11},{22,22,22,22}};</code>对于该数组，可以视为数组a中包含3个元素：a[0],a[1],a[2]，而这3个元素每个都是一维数组:<span class="strong">a[0]</span>==> a[0][0]、a[0][1]、a[0][2]、a[0][3]<span class="strong">a[1]</span>==> a[1][0]、a[0][1]、a[0][2]、a[0][3]<span class="strong">a[2]</span>==> a[2][0]、a[0][1]、a[0][2]、a[0][3]暂且忽略a[0],a[1],a[2]内部包含的内容，将它们当作普通的数组元素，由此：数组a是包含a[0]、a[1]、a[2]三个数组元素的一维数组，其中：a是数组首元素a[0]的地址(即&a[0])，a+1是a[1]的地址(&a[1])，a+2是a[2]的地址(&a[2])，所以：<span class="strong">a=&a[0]，a+1=&a[1]，a+2=&a[2]</span>;<span class="text-red">*(a+0)=a[0]，*(a+1)=a[1]，*(a+2)=a[2]</span>;<p>此时将a[0]、a[1]、a[2]展开，这三个元素每个都是一维数组，在这三个数组内部，a[0]、a[1]、a[2]分别是它们内部一维数组的数组名，又因为C语言中数组名代表数组首元素地址，因此：<br>a[0]即为a[0][0]的地址，即&amp;a[0][0]，a[0]+1则为a[0][1]的地址 &amp;a[0][1]……<br>即：<br><span class="strong">a[0]+0=&amp;a[0][0]，a[0]+1=&amp;a[0][1]，a[0]+2=&amp;a[0][2]，a[0]+3=&amp;a[0][3]</span><br><span class="text-red">*(a[0]+0)=a[0][0]，*(a[0]+1)=a[0][1]，*(a[0]+2)=a[0][2]，*(a[0]+3)=a[0][3]</span>;</p><p>由于<span class="text-red">a[0]和*a</span>等价，因此<br>a[0]+0与*(a+0)均是a[0][0]的地址，a[0]+1与*(a+0)+1均是a[0][1]的地址，其他同理，由此可得：<br><span class="text-blue">*(a[0])=*(*(a+0)+0)=**a=a[0][0]，*(a[0]+1)=*(*(a+0)+1)=*(*a+1)=a[0][1]</span><br><span class="text-blue">*(a[1]+2)=*(*(a+1)+2)=a[1][2]，*(a[2]+3)=*(*(a+2)+3)=a[2][3]</span><br><span class="text-blue">其他以此类推</span></p><p><span class="text-red">注意！<br>对于一维数组，a[i]代表一个数组元素，占据内存单元，拥有物理地址，但在二维数组中，a[i]代表一维数组名，只是一个地址(如同一维数组中的数组名只是一个指针常量一样)，务必记住，a[i]和*(a+i)是等价的</span></p></div><p>由上，总结：</p><p>表示a[i][j]<span class="text-blue">地址</span>的方法：</p><ul><li><span class="text-blue">a[i]+j</span></li><li><span class="text-blue">*(a+i)+j</span></li><li><span class="text-blue">&amp;a[i][j]</span></li></ul><p>表示a[i][j]<span class="text-red">值</span>的方法：</p><ul><li><span class="text-red">*(a[i]+j)</span></li><li><span class="text-red">*(*(a+i)+j)</span></li><li><span class="text-red">(*(a+i))[j]</span></li><li><span class="text-red">a[i][j]</span></li></ul><h6 id="二维数组的行指针与列指针"><a href="#二维数组的行指针与列指针" class="headerlink" title="二维数组的行指针与列指针"></a>二维数组的行指针与列指针</h6><div class="show">对于二维数组，其地址也可以分为行地址和列地址，如图所示：<div class="table"><table><thead><tr><th colspan="5">二维数组存储</th></tr></thead><tbody><tr style="color:#fb5b33;"><td style="color:#056efb;">行/列地址</td><td>a[i]+1</td><td>a[i]+2</td><td>a[i]+3</td><td>a[i]+4</td></tr><tr><td style="color:#25ccf7;">a+0</td><td>a[0][0]</td><td>a[0][1]</td><td>a[0][2]</td><td>a[0][3]</td></tr><tr><td style="color:#25ccf7;">a+1</td><td>a[1][0]</td><td>a[1][1]</td><td>a[1][2]</td><td>a[1][3]</td></tr><tr><td style="color:#25ccf7;">a+2</td><td>a[2][0]</td><td>a[2][1]</td><td>a[2][2]</td><td>a[2][3]</td></tr></tbody></table></div><p>其中，二维数组名a是指向行地址的，因此a+1中的"1"代表一个含有4个整型元素的一维数组所占存储单元的字节数，即<span class="text-green">4*sizeof(int)</span>，a+1将指向下一行</p><p>一维数组名a[0]、a[1]、a[2]是指向列元素的，a[0]+1中的1代表一个整型元素所占存储单元的字节数，a[0]+1将指向下一个列元素</p><p>在指向行的指针前加一个*，就转换为指向列的指针，如：指针a和a+1是指向行的，而*a和*(a+1)则是指向列的，它们拓展为*(a+0)+0和*(a+1)+0，分别指向第0行0列元素和第1行第0列。反之，在指向列的指针前加上&，该指针就变成了指向行的指针，如：列指针a[0]指向第0行第0列的元素，而&a[0]等价于&*(a+0)，而&*a等价于a，因此&a[0]是指向第0行的行指针。注意，&a[i]不能理解为a[i]的物理地址，因为二维数组中并不存在a[i]元素，它只是一个地址计算方法，能得到第i行的起始地址。</p>练习：a、a+0、&a[0]代表第0行首地址*a、*(a+0),a[0],a[0]+0代表第0行第0列的地址&a[0][0]代表第0行第0列元素地址a[0][0]、**a代表第0行第0列元素值a+i、&a[i]代表第i行地址a[i]+j、\*(a+i)+j,&a[i][j]代表第i行第j列地址a[i][j]、\*(\*(a+i)+j)代表第i行第j列元素值</div><h5 id="二维数组元素的引用-指针变量"><a href="#二维数组元素的引用-指针变量" class="headerlink" title="二维数组元素的引用(指针变量)"></a>二维数组元素的引用(指针变量)</h5><h6 id="通过二维数组的列指针变量引用"><a href="#通过二维数组的列指针变量引用" class="headerlink" title="通过二维数组的列指针变量引用"></a>通过二维数组的列指针变量引用</h6><p>由于列指针指向数组的具体元素，因此定义列指针与定义同类型普通指针相同：<br><span class="strong">int * p</span><br>可以用以下三种等价方法对其进行初始化：</p><ul><li><span class="strong">p=a[0]</span></li><li><span class="strong">p=*a</span></li><li><span class="strong">p=&amp;a[0][0]</span></li></ul><p>此时，由于需要使用列指针对二维数组元素进行引用，因此可以将二维数组看成一个由m行*n列个元素组成的一维数组，获取第i行j列的元素，则其在一维数组中的索引为i*n+j，因此a[i][j]元素的地址为<span class="text-blue">p+i*n+j</span>，其值表示方法为<span class="text-red">*(p+i*n+j)</span>或<span class="text-red">p[i*n+j]</span></p><p>注意，此时不能用p[i][j]来表示数组元素，因为给p赋初值时将其赋为了列指针，即是将二维数组作为一维数组来进行处理的，p++将使指针依次指向下一个数组元素。正因如此，在定义二维数组的列指针时，无须指定它所指向的二维数组的列数。因此二维数组的列指针也常常用作函数参数，以实现二维数组的行列数需要动态指定的场合。</p><div class="show">eg:使用二维数组列指针引用数组元素<code>#include&lt;stdio.h>int main(void) &#123;    void outputArray(int *,int);    int a[3][4] = &#123; &#123;11,11,11,11&#125;,&#123;22,22,22,22&#125;,&#123;33,33,33,33&#125; &#125;;    <span class="text-red">outputArray(a[0], 12);//列指针初始化int *p=a[0]</span>    <span class="text-blue">outputArray(*a, 12);//列指针初始化int *p=*a</span>    <span class="text-green">outputArray(&a[0][0], 12);//列指针初始化int *p=&a[0][0]</span>    return 0;&#125;void outputArray(int* p, int length) &#123;    for (int* index = p; index < p + length; index++) &#123;        printf("%d,", *index);    &#125;    printf("\n");&#125;</code></div><h6 id="通过二维数组的行指针变量引用"><a href="#通过二维数组的行指针变量引用" class="headerlink" title="通过二维数组的行指针变量引用"></a>通过二维数组的行指针变量引用</h6><p>由于行指针不再指向数组元素，而是指向一维数组，因此行指针变量比较特殊：<br><span class="strong">int (*p)[4]</span><br>可以用以下方法对其进行初始化：</p><ul><li><span class="strong">p=a</span></li><li><span class="strong">p=&amp;a[0]</span></li></ul><p>说明：定义了一个可指向含有4个元素一维整型数组的指针变量，[4]表示所指一维数组的长度，<span class="tips">在声明变量时必须显式指定，不可省略!</span>该指针可以作为一个指向二维数组的行指针，且它所指向的二维数组的每一行有4个元素。注意：定义该行指针变量时( )也不可省略，因为[ ]优先级高于*，p会优先与[ ]结合，int *p[4]是指针数组的定义方式。<br>可以用以下四种等价形式引用a[i][j]的值:</p><ul><li><span class="strong">p[i][j]</span></li><li><span class="strong">*(p[i]+j)</span></li><li><span class="strong">*(*(p+i)+j)</span></li><li><span class="strong">(*(p+i))[j]</span></li></ul><p>对于行指针变量，p++将指向二维数组的下一行，即移动4*sizeof(int)字节，因此需要显式指定所指一维数组的长度int (*p)[4]，否则无法计算指针移动的字节数。</p><div class="show">eg:使用行指针读入、输出二维数组元素<code>#include&lt;stdio.h>#define N 3int main(void) &#123;    <span class="text-red">//用普通的二维数组方式操作数组    void inputArray(int p[][N], int,int);    void outputArray(int p[][N], int,int);</span>    <span class="text-blue">//只使用行指针操作数组元素    void inputArray(int(*p)[N], int, int);    void outputArray(int(*p)[N], int, int);</span>    int a[2][3];    printf("Input 2*3 numbers:\n");    inputArray(a, 2,3);//把数组行数和列数也传参    outputArray(a, 2,3);    return 0;&#125;<span class="text-red">void inputArray(int p[][N], int rows,int columns) &#123;</span><span class="text-blue">void inputArray(int (*p)[N], int rows, int columns) &#123;</span>    printf("Input numbers:\n");    for (int i = 0; i < rows; i++) &#123;        for (int j = 0; j < columns; j++)        &#123;            <span class="text-red">scanf_s("%d", &p[i][j]);</span>            <span class="text-blue">scanf_s("%d", *(p+i)+j);</span>        &#125;    &#125;&#125;<span class="text-red">void outputArray(int p[][N], int rows, int columns) &#123;</span><span class="text-blue">void outputArray(int (*p)[N], int rows, int columns) &#123;</span>    printf("Output numbers:\n");    for (int i = 0; i < rows; i++) &#123;        for (int j = 0; j < columns; j++)        &#123;            <span class="text-red">printf("%d,", p[i][j]);</span>            <span class="text-blue">printf("%d,", *(*(p+i)+j));</span>        &#125;    &#125;&#125;</code></div><h4 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h4><p>一个函数在编译时被分配一个入口地址，与数组类似，函数名代表该函数的入口地址，函数的入口地址就称为该函数的指针，可以用一个指针变量指向函数，然后通过该指针变量调用该函数，指向函数的指针变量的定义形式为：<br><span class="strong">函数返回值类型 (* 指针变量名)(函数参数)</span></p><ul><li>定义举例：int (*p)(int,int)，表示定义一个指向函数的指针变量p，它可以任意指向同类型的不同函数(该函数应是int类型且有两个int参数)，并非固定指向一个函数</li><li>*p两侧的括号不能省略，p先与*结合表明是指针变量，再与后面的( )结合表明该指针变量指向函数</li><li>对指向函数的指针变量进行p++、p+n等操作是无意义的</li></ul><div class="show">eg:<code>int main(void)&#123;    int getMax(int,int);    <span class="text-blue">int (*p)(int,int);</span>//定义指向函数的指针    int a=10,b=20;    <span class="text-blue">p=getMax;</span>//将函数地址赋给p，不涉及实参和形参问题，因此不需要写任何参数    int result=<span class="text-blue">(*p)(a,b)</span>;//使用指针调用函数，只需用(*p)替代函数名即可    return 0;&#125;int getMax(int a,int b)&#123;    return a>b?a:b;&#125;</code></div><p>函数指针变量的用途之一是将函数作为参数传递到其他函数，即实现函数入口地址的传递，常见用法是：调用同一个函数时，在不同情况下实现不同的功能</p><div class="show">eg:多次调用process函数，依次实现求最大值、求和、求积功能<code>#include&lt;stdio.h>int main(void) &#123;    int getMax(int, int);    int add(int, int);    int multiply(int, int);    <span class="text-blue">void process(int, int, int (* fun)(int, int));</span>    int a = 10, b = 20;    <span class="text-blue">process(a, b, getMax);    process(a, b, add);    process(a, b, multiply);</span>    return 0;&#125;void process(int a,int b,int (* fun)(int,int)) &#123;    int result =<span class="text-blue">(*fun)(a, b)</span>;//fun指向不同函数地址，实现不同功能    printf("%d\n", result);&#125;int getMax(int a, int b) &#123;    return a > b ? a : b;&#125;int add(int a, int b) &#123;    return a + b;&#125;int multiply(int a, int b) &#123;    return a * b;&#125;</code></div><h4 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h4><p>函数除了可以返回整型值、字符值等，也可以返回一个指针(返回一个地址)，这种返回指针的函数，定义形式为:<br><span class="strong">类型 * 函数名(参数)</span></p><ul><li>函数定义举例：int * fun(int,int)，定义一个函数fun，该函数返回类型为int *，即返回一个指针，该指针指向int类型的数据，函数名fun和*两侧没有( )，fun先与(int,int)结合表明fun()是个函数</li><li>通过返回指针，C语言就可以实现返回数组、字符串等数据</li></ul><div class="show">eg:拼接两个字符串，返回一个新的字符串<code>#include&lt;stdio.h>int main(void) &#123;    char* str1 = "aaa", * str2 = "111";    char result[20];//存储拼接后的字符串，空间要足够大    <span class="text-blue">char* strCat(char*, char*,char *);</span>    printf("%s", strCat(result, str1, str2));    return 0;&#125;char* strCat(char * result,char* str1, char* str2) &#123;    char* p = result;    while (*str1 != '\0') &#123;        *p = *str1;        str1++;        p++;    &#125;    while (*str2 != '\0') &#123;        *p = *str2;        str2++;        p++;    &#125;    *p = '\0';//拼接后的字符串末尾加上字符串结束标志符    return result;//返回result数组的初始起始地址&#125;</code></div><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>一个数组，若其元素均为指针，则该数组为指针数组，一维指针数组的定义形式为：<br><span class="strong">类型名 * 数组名[数组长度]</span></p><ul><li>如：int *p[4]，p先与[4]结合，形成p[4]，表明这是一个数组，再与*结合，表明该数组是指针类型</li><li>注意区分于int (*p)[4]，这是指向一维数组的指针变量，即指向二维数组指针变量中的行指针</li><li>指针数组可用于指向不等长字符串、不等长数组等场景</li></ul><div class="show">指针数组可以指向若干不等长的字符串，如果用二维数组存储字符串，需要指定第二维的长度(一般为最长字符串的长度+1)，相较于二维数组，指针数组更为灵活快捷eg:将若干字符串按字母顺序排序<code>#include&lt;stdio.h>#include&lt;string.h>int main(void) &#123;    void sort(char* ptr[], int length);    <span class="text-blue">char* ptr[]</span>= &#123; "Document","ASCII","Java","CPP" &#125;;     sort(ptr, 4);     for (int i = 0; i < 4; i++) &#123;         printf("%s\n", ptr[i]);     &#125;    return 0;&#125;void sort(char* ptr[], int length) &#123;    char* temp;    int i, j, k;    for (i = 0; i < length-1; i++) &#123;        k = i;        for (j = i + 1; j < length; j++) &#123;//内循环找出全部字符串中字符顺序最小的字符串            if (strcmp(ptr[k], ptr[j]) > 0) &#123;//strcmp()函数，ptr[k]中的字母在ASCII中位置大于ptr[j]，则返回值大于0                k = j;            &#125;        &#125;        if (k != i) &#123;//如果找到的字符串不是i，调换顺序            temp = ptr[i]; ptr[i] = ptr[k]; ptr[k] = temp;        &#125;    &#125;&#125;</code></div><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>指针变量也可以指向一个另一个指针，指向指针的指针变量定义形式为：<br><span class="strong">类型 *** 变量名</span></p><ul><li>如：char **p，指针变量p指向另一个指针变量，被p指向的指针变量指向一个字符型数据</li><li>结合上一节的指针数组，就可以用指向指针的指针操作指针数组中的指针所指向的数据</li><li>理论上指向指针的指针可以无限套娃，如：int *****p，但多层指针嵌套容易混乱，难以理解</li></ul><div class="show">1. eg:用指向指针的指针输出指针数组指向的内容<code>#include&lt;stdio.h>int main(void)&#123;    char* ptr[]= &#123; "Document","ASCII","Java","CPP" &#125;;    <span class="text-blue"> char **p;</span>    for(int i=0;i&lt;4;i++)&#123;        p=ptr+i;        printf("%s\n",<span class="text-blue">*p</span>);    &#125;&#125;</code>2. eg:注意输出字符串、数组数据与整型等其他普通类型数据时，指针运算符(间接寻址运算符)需要取到哪一层值(取出的值是地址值还是变量本身的值)<code>#include&lt;stdio.h>int main(void)&#123;    int a = 11, b = 22;    int c = a + b;    int d = a + b + c;    int* nums[] = &#123; &a,&b,&c,&d &#125;;    <span class="text-blue">int** p=nums;</span>    for (int i = 0; i < 4; i++,p++) &#123;         printf("%d\n",<span class="text-blue">**p</span>);    &#125;    return 0;&#125;</code></div><h4 id="void-无类型指针"><a href="#void-无类型指针" class="headerlink" title="void * 无类型指针"></a>void * 无类型指针</h4><p>void *称为通用指针或无类型指针，用于声明基类型未知的指针变量，即声明了一个指针变量，但未指定它指向哪一种基类型的数据。它可以指向任意类型的数据，只需要在将它的值赋给其他类型的指针变量时，进行强制类型转换即可。ANSI标准要求动态分配内存的函数(malloc、calloc等)返回类型为void *无类型指针，方便将其转换为其他任意类型的指针变量。</p><p>注意区别于<span class="tips">空指针(NULL)</span>，空指针未指向任何有效内存(指向低地址保留区)，而<span class="tips">void *</span>当值不为NULL时，它指向了有效内存空间，只是尚未指定它指向的基类型。</p><div class="show">void *和其他类型的指针可以相互转换<code>char *str;void *p;str=(char *)p;或p=(void *)str;</code>动态分配内存函数返回值根据指向数据类型需要转换为其他类型<code>int * p=(int *)malloc(10*sizeof(int));</code></div><h4 id="指针数组与main函数的形参"><a href="#指针数组与main函数的形参" class="headerlink" title="指针数组与main函数的形参"></a>指针数组与main函数的形参</h4><p>一般情况下，main函数一般会写为空参数形式：int main(void)，实际上main函数可以带有参数，如：<br><span class="strong">int main(int argc,char * argv[])</span><br>Java语言中的main默认就为上述形式，argc和argv就是main函数的形参。main函数由操作系统调用，在main所在的.c文件被编译后，会生成可执行文件(windows下后缀为.exe)，在系统命令终端下(如：Linux的shell、windows的cmd)，输入<span class="strong">文件路径/可执行文件名 参数1 参数2…</span>即可调用该可执行文件并将参数传递给main函数</p><div class="show">假设main函数写于文件file.c文件中，编译后生成file.out文件在该文件所属路径下执行命令：<span class="strong">file.out data1 data2</span>对于main函数原型<span class="strong">int main(int argc,char * argv[])</span>argc指命令行中的参数个数，argv[]是存储参数字符串首地址的指针数组它收到3个命令行参数：file.out，data1，data2 //file.out也算一个参数所以argc=3，"file.out"、"data1"、"data2"字符串的首地址构成一个指针数组，存储于argv中：argv[0]--->"file.out\0"argv[1]--->"data1\0"argv[2]--->"data2\0"由于并不清楚输入的参数会多长，使用指针数组就可以巧妙解决这个问题可以写一个main函数输出执行时传入的参数内容：<code>int main(int argc,char * argv[])&#123;    while(argc&gt;1)&#123;         ++argv;        printf("%s\n",*argv);        --argc;    &#125;&#125;</code></div><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h4><div class="table"><table><thead><tr><th>优先级</th><th>运算符</th><th>名称</th><th>使用</th><th>说明</th><th>结合方式</th></tr></thead><tbody><tr><td rowspan="4">1</td><td>[&nbsp;]</td><td>数组下标</td><td>数组名[]</td><td rowspan="4"></td><td rowspan="4">从左到右</td></tr><tr><td>(&nbsp;)</td><td>圆括号</td><td>(表达式)</td></tr></tr><td>.</td><td>成员选择（对象）</td><td>对象.成员名</td></tr></tr><td>-&gt;</td><td>成员选择（指针）</td><td>对象指针->成员名</td></tr><tr><td rowspan="9">2</td><td>-</td><td>负号</td><td>-表达式</td><td rowspan="9">单目运算符</td><td rowspan="9"><span class="tips">从右到左</span></td></tr><tr><td>(类型)</td><td>类型转换</td><td>(数据类型)表达式</td></tr><tr><td>sizeof(&nbsp;)</td><td>长度运算符</td><td>sizeof(表达式)</td></tr><tr><td>！</td><td>逻辑非</td><td>!表达式</td></tr><tr><td>~</td><td>按位取反</td><td>~表达式</td></tr><tr><td>*</td><td>取值</td><td>*指针变量</td></tr><tr><td>&</td><td>取地址运算符</td><td>&变量名</td></tr><tr><td>++</td><td>自增</td><td>++变量名或变量名++</td></tr><tr><td>--</td><td>自减</td><td>--变量名或变量名--</td></tr><tr><td rowspan="3">3</td><td>*</td><td>乘</td><td>表达式*表达式</td><td rowspan="3">双目运算符</td><td rowspan="3">从左到右</td></tr><tr><td>/</td><td>除</td><td>表达式/表达式</td></tr><tr><td>%</td><td>求余</td><td>表达式%表达式</td></tr><tr><td rowspan="2">4</td><td>+</td><td>加</td><td>表达式+表达式</td><td rowspan="2">双目运算符</td><td rowspan="2">从左到右</td></tr><tr><td>-</td><td>减</td><td>a-b</td></tr><tr><td rowspan="2">5</td><td>&lt;&lt;</td><td>左移</td><td>变量&lt;&lt;表达式</td><td rowspan="2">双目运算符</td><td rowspan="2">从左到右</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td></tr><tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=</td><td>关系运算(大于，大于等于，小于，小于等于)</td><td>a&lt;b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>7</td><td>==、!=</td><td>是否等于</td><td>if(a==b)</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>8</td><td>&</td><td>按位与</td><td>a&b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>9</td><td>^</td><td>按位异或</td><td>a^b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>10</td><td>|</td><td>按位或</td><td>a|b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>11</td><td>&&</td><td>逻辑与</td><td>a&&b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>12</td><td>||</td><td>逻辑或</td><td>a||b</td><td>双目运算符</td><td>从左到右</td></tr><tr><td>13</td><td>?&nbsp;:</td><td>条件运算</td><td>a>b?true:false</td><td>三目运算符</td><td><span class="tips">从右到左</span></td></tr><tr><td rowspan="2">14</td><td>=</td><td>赋值运算</td><td>a=10</td><td rowspan="2">双目运算符</td><td rowspan="2"><span class="tips">从右到左</span></td></tr><tr><td>+=、-=、*=、/=、%=、>>=、<<=、&=、^=、|=</td><td>运算后赋值</td><td>a+=10</td></tr><tr><td>15</td><td>,</td><td>逗号运算符(按顺序求值)</td><td>a,b,c</td><td></td><td>从左到右</td></tr></tbody></table></div><h4 id="赋值与复合赋值"><a href="#赋值与复合赋值" class="headerlink" title="赋值与复合赋值"></a>赋值与复合赋值</h4><p>静态变量和全局变量的赋值在编译阶段进行，而局部自动变量的赋值在程序运行到该语句时进行。赋值语句遵循<span class="tips">右结合</span>原则(从右向左运算)</p><div class="show">1. 赋值遵循右结合int a,b,c;a=b=c=0;执行过程为a=(b=(c=0))2. 复合赋值n*=m+1;等价于n=n*(m+1)3. 复合赋值会即时修改变量值int a=3;a+=a-=a*a;//执行完a=-12a+=a-=a*=a;//执行完a=0</div><p>赋值语句需要注意：将字节数长的数据赋值给字节数短的变量，会截取部分数据，也可能造成整个数据错误</p><ul><li>浮点型(float、double)数据赋值给整型变量，将舍弃小数部分</li><li>将double数据赋值给float变量，将截取前7位有效数字</li><li>将int、short、long型数据赋值给char变量，只截取该数据的低8位到char变量中</li><li>将unsigned 数据赋值给有符号整型时，进行高位补0即可，但如果该unsigned 数据的数值超出了有符号整型最大值范围时，会产生数据错误!</li></ul><p>将字节数短的数据赋值给字节数长的变量，一般需要进行位拓展</p><ul><li>将整型数据赋值给浮点型变量，数值不变，拓展小数部分为0以浮点数形式进行存储</li><li>将float数据赋值给double，数值不变，拓展有效位数</li><li>将char数据赋值给整型变量，将char的1个字节数据存储到低8位，如果该整型变量为无符号整型(unsigned)，则高8位补0。如果该整型变量为有符号整型，且该char字符最高位为0，则高8位补0，若char字符最高位为1，则高8位补1，以保证char对应的数值不变</li><li>将带符号的int赋值给long型变量，将int的值存入long的低16位，如果int为正整数(最高位为0)，则long的高16位补0，反之补1</li></ul><h4 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减"></a>自增与自减</h4><p>用于对变量进行加1或减1操作，自增和自减运算符都属于一元运算符，只需要一个操作数，且<span class="tips">操作数必须是变量，不能是常量或表达式</span>。自增与自减运算符分为前缀(如++i)和后缀(i++)形式。区别在于前缀是先对变量进行加1操作，再使用变量。后缀形式是先使用变量的当前值，再进行加1操作，自减运算符同理。</p><div class="show">-i++;//应当解析为-(i++)，而非(-i)++，因为自增运算符操作数不能为表达式-i，(-i)++是非法语句i+++j;//应当解析为(i++)+j，C编译系统会从左至右尽可能多地将若干个字符组成一个运算符</div><h4 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h4><p><span class="strong">表达式1,表达式2,…表达式n</span><br>用于串联多个表达式，表达式从左至右顺序运算，<span class="tips">整个逗号表达式的值是最后一个表达式的值</span><span class="tips"></span>。多数情况下，逗号表达式仅用来顺序求值，并不一定用到整个逗号表达式的最终值。常见的情况是用于for语句进行多个变量的顺序运算，<span class="tips">逗号表达式的运算优先级是所有运算种最低的</span>。</p><div class="show">a=2*5,a*4;//逗号表达式运算优先级最低，所以a=10，整个逗号表达式值等于40b=(a=2*5,a*4);//正确获得逗号表达式值的方法，运算结果：a=10,b=40(a=3*5,a*4),a+5;//逗号表达式也可以嵌套到其他的逗号表达式中，运算结果：a=15，逗号表达式=20for(i=0,j=0;i&lt;array.length,j&lt;i;i++,j++);//逗号表达式常用于for语句多变量运算printf("%d,%d,%d",a,b,c);//逗号用于间隔函数参数,并不是逗号表达式printf("%d,%d,%d",(a,b,c),b,c);//(a,b,c)是逗号表达式，输出值为c的值</div><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>位运算是直接对二进制位进行运算，<span class="tips">只能用于整型或字符型数据</span>，不能用于浮点型，位运算符常用于编写系统软件。对于需要两个操作数的位运算，如果给的两个操作数长度不同，则系统将给较短的操作数高位补0或1，以保证两个操作数长度相同。如果该数是无符号数或者正数，则高位补0，如果为负数则高位补1。</p><h6 id="取反"><a href="#取反" class="headerlink" title="取反~"></a>取反~</h6><p>取反运算为单目运算符，用于将二进制数按位取反,eg:~12=-13</p><h6 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与&amp;"></a>按位与&amp;</h6><p>对两个数的二进制码进行按位与，该运算有一些特殊用途：</p><ul><li>数据清零，使之与0相与即可将所有二进制位置为0</li><li>保留或截取一个数中的某些指定位</li></ul><div class="show">1. 正数取原码相与，负数取其补码相与3&5=1   0000 0011   0000 0101 ------------   0000 0001  2. 若要保留一个数的低4位，将其与0000 1111相与  1100 1011  0000 1111 -----------  0000 1011 </div><h6 id="按位或"><a href="#按位或" class="headerlink" title="按位或|"></a>按位或|</h6><p>可用于将指定的二进制位置为1</p><h6 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或^"></a>按位异或^</h6><ul><li>使指定二进制位翻转</li><li>交换两个值，不使用临时变量</li><li>一个数与0相^，保留原值</li><li>一个数同本身相^，结果为0</li></ul><div class="show">1.使0100 1011的低四位翻转，可以与0000 1111相异或0100 10110000 1111----------0100 01002. 异或可以交换两个值，且不使用临时变量eg:a=3,b=4;交换a与b的值，可以使用：a=a^b;b=b^a;a=a^b;解析：由上述语句1,2可得：b=b^a=b^(a^b)=a^b^b=a^0=a;即b获得了a的值由语句3可得：a=(a^b)^(a^b^b)=a^a^b^b^b=b;</div><h6 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符&lt;&lt;"></a>左移运算符&lt;&lt;</h6><p>将一个数的二进制位左移若干位，高位溢出部分舍弃，低位补0。一个数左移n位，如果左边被舍弃的部分全为0，则该数相当于乘以2<sup>n</sup></p><div class="show">int result = 30&lt;&lt;2;//result=120</div><h6 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符&gt;&gt;"></a>右移运算符&gt;&gt;</h6><p>将一个数的二进制位右移若干位，低位溢出部分舍弃，高位补的值取决于该数值本身。如果是无符号数，或者该数符号位为0(该数为正)，则高位补0，如果该数为负数，高位补0还是补1取决于编译器，补0称为”逻辑右移”，补1称为”算术右移”。</p><p>同理，如果右边移除部分均为0，则右移n位相当于该数除以2<sup>n</sup></p><h6 id="位运算赋值运算符"><a href="#位运算赋值运算符" class="headerlink" title="位运算赋值运算符"></a>位运算赋值运算符</h6><p>位运算和赋值运算可以组成复合赋值运算符，如：&amp;=、|=、&lt;&lt;=、&gt;&gt;=、^=等</p><div class="show">a&lt;&lt;=2等价于a=a&lt;&lt;2</div><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>注意，关系运算符的优先级<span class="tips">低于</span>算术运算符，<span class="tips">高于</span>赋值运算符，且关系运算符中<span class="tips">&lt;</span>、<span class="tips">&lt;=</span>、<span class="tips">&gt;</span>、<span class="tips">&gt;=</span>的优先级是高于<span class="tips">==</span>、<span class="tips">!=</span>的</p><div class="show">c&lt;a+b等价于c&lt;(a+b)a=b&gt;c等价于a=(b&gt;c)a==b&lt;c应当等价于a==(a&lt;c)</div><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>逻辑运算符中优先级顺序为<span class="tips">!高于&amp;&amp;高于||</span>，且&amp;&amp;和||有<span class="tips">短路特性</span></p><p>C语言中没有逻辑常量true和false，编译器在表示逻辑时使用1代表真，0代表假，在表示数值时，以非0代表真，0代表假</p><div class="show">优先计算!，再计算&&，最后计算||!a&&b||x>y&&c</div><h4 id="条件运算-三元表达式"><a href="#条件运算-三元表达式" class="headerlink" title="条件运算(三元表达式)"></a>条件运算(三元表达式)</h4><p><span class="strong">条件判断语句?表达式1:表达式2</span><br>先求解条件判断语句，若为真则执行表达式1，整个条件表达式的值<br>为表达式1的值，否则执行表达式2并作为条件表达式的值</p><div class="show">1. 条件运算符优先级高于赋值max=a>b?a:b;等价于max=(a>b?a:b);2. 条件运算符结合方向为从右至左a>b?c:d>e?f:g;等价于a>b?c:(d>e?f:g)</div><h3 id="选择与循环控制"><a href="#选择与循环控制" class="headerlink" title="选择与循环控制"></a>选择与循环控制</h3><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><p><span class="tips">if()..else</span>、<span class="tips">while()</span>、<span class="tips">do…while()</span>、<span class="tips">for</span></p><h5 id="switch多分支选择"><a href="#switch多分支选择" class="headerlink" title="switch多分支选择"></a>switch多分支选择</h5><div class="apiBox">switch(表达式)  {    case 常量表达式:语句1    case 常量表达式:语句2    ....    default:       语句n}</div><ul><li>case语句只起语句标号的作用，并不是在该处进行条件判断</li><li>switch语句表达式的值找到匹配的case入口标号后，会一直执行下去，不再进行判断，直到执行完或遇到break语句</li></ul><div class="show">1.满足匹配条件后，将依次执行后面的所有case语句，所以需要及时break。并且由于是依次执行，所以case后面是多个语句也不需要使用{ }括起来switch(num)  {    case 1:printf("get 1");//如果num=1，则将输出get1、get2    case 2:printf("get 2");break;    case 3:{printf("get 3");break;}//可以不使用{ }    default:printf("error\n");}2. 多个分支可以共用一个执行语句switch(num)  {    case 1:    case 2:    case 3:printf("down");break;    default:printf("error\n");}</div><h5 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h5><p>break用于终止循环和跳出switch，只能用于循环语句和switch语句。continue用于结束本次循环，代码将继续下一次循环判定。使用goto语句的形成的循环体不能使用这两个语句跳出循环。</p><div class="show">while(i&lt;10){    if(i==5) break;    .....    i++;}while(i&lt;10){     i++;    if(i==5) continue;    .....}</div><h5 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h5><p>goto语句为无条件转向语句，语法为：</p><div class="apiBox">goto 语句标号;</div><p>语句标号用标识符表示，命名规则同变量，常用于组成循环，或者从循环内部跳出循环，但会导致程序可读性差，结构混乱，应当谨慎使用。</p><div class="show">int i,sum;i=sum=0;loop:if(i&lt;10){    sum+=i;    i++;    goto loop;}</div><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>谭浩强书的主函数一般写为void man()，但C语言标准(C99)定义的标准main函数写法为</p><div class="apiBox">int main(void){    .....return 0; }或者int main(int argc,char argv[]){.....return 0;}</div><div class="show">在C语言中int main()表示主函数可以传入任意个数的参数，而int main(void)表示该函数参数为空，不能传入任何参数在C++中，int main()和int main(void)等效</div><h4 id="标准输入输出函数"><a href="#标准输入输出函数" class="headerlink" title="标准输入输出函数"></a>标准输入输出函数</h4><p>C语言本身不提供输入输出语句，输入输出操作由C函数库中的函数提供支持。这是因为输入输出涉及到硬件操作，没有输入输出语句可以让C语言编译器避免在编译阶段处理硬件有关的问题，可以极大地简化编译系统，并提高其通用性和可移植性。</p><p>C函数库由各软件公司编写，并已经编译成目标文件(.obj文件)，源程序中的printf()等语句在编译阶段并不会被编译为目标指令，而是等待链接阶段源程序和库函数链接后，在执行阶段直接调用库函数目标文件(.obj文件)中的printf()函数。不同函数库提供的函数名、功能完全不同，但有一些通用的”标准输入输出函数”，调用这些函数需要引入头文件<span class="tips">#inculde&lt;stdio.h&gt;</span></p><h5 id="printf输出函数"><a href="#printf输出函数" class="headerlink" title="printf输出函数"></a>printf输出函数</h5><p>标准输出语句格式为：</p><div class="apiBox">printf("格式控制",输出表列)</div><p>输出表列即需要输出的数据，多个输出的数据使用<span class="tips">,</span>分隔，可以为表达式；格式控制需要使用双引号括起来，可以包括两种信息</p><ul><li>普通字符：printf会原样输出普通字符，包括空格、换行符等</li><li>格式字符：由%和格式字符组成，用于指定输出数据的格式</li></ul><div class="show">用于输出整型、浮点型、指数的格式字符:1.<span class="tips">%d或%i</span>，用于输出int类型(-32768~32767之间)的十进制整数2.<span class="tips">%ld</span>，输出长整型。%hd输出short类型，%I64d输出long long类型3.<span class="tips">%md</span>,m用于指定宽度，若数据位数大于m则将原数据正常输出，小于m则左补空格<code>eg: a=12345,b=123printf("%4d,%4d",a,b);//输出12345, 123(123前补个空格)</code>4.<span class="tips">%o,%x,%X</span>，以八进制、十六进制(字母小写)、十六进制(字母大写)形式输出整型(不输出前导符0和0x)，该输出方式会将符号位也作为八进制和十六进制的数值位输出，因此无法输出负数，输出时支持指定输出位数。同样,八进制和十六进制支持用<span class="tips">l</span>(long)、<span class="tips">h</span>(short)、<span class="tips">m</span>(输出位宽)修饰5.<span class="tips">%u</span>，输出无符号(unsigned)整型，%lu输出unsigned long类型6.<span class="tips">%c</span>，输出一个字符，支持将0~255内的整数输出为ASCII码对应字符，也支持将这些字符输出为整数7.<span class="tips">%s</span>，输出字符串<ul style="white-space: normal;"><li><span class="strong">%ms</span>，指定输出的字符个数，若字符串串长大于m则原样输出字符串，若小于m则左补空格</li><li><span class="strong">%-ms</span>，同上，但是右补空格</li><li><span class="strong">%m.ns</span>，输出m个字符，但只取字符串左端n个字符，右对齐，左补空格</li><li><span class="strong">%-m.ns</span>，同上，但左对齐，右补空格</li></ul><code>eg：printf("%5.2s","china");//输出   ch(左补3个空格)printf("%4.2s","china");//输出  ch(右补2个空格)printf("%-5.2s","china");//输出ch   (右补3个空格)</code>8.<span class="tips">%f</span>，输出浮点数(包括单、双精度)，输出全部整数部分，并输出6位小数。单精度浮点数有效位数一般为7位，双精度浮点数有效位数一般为16位，给出小数6位。<ul style="white-space: normal;"><li><span class="strong">%m.nf</span>，输出m列(小数点算一列)，其中保留有n位小数(四舍五入)，左补空格</li><li><span class="strong">%-m.nf</span>，同上，但左对齐，右补空格</li><li><span class="strong">%.nf</span>，省略m，即输出所有整数部分，保留n位小数</li></ul><code>eg：float a=123.456printf("%f",a);//输出123.456001，输出6位小数，有一定存储误差printf("%8.2f",a);//输出  123.46，左补2个空格，保留2位小数，小数四舍五入printf("%-8.2f",a);//输出123.46  ，右补2个空格printf("%.2f",a);//输出123.46，整数部分全部输出，小数部分保留2位 float x,y;x=111111.111,y=222222.222;printf("%f",x+y);//输出333333.328125，只有前7位有效</code>9. <span class="tips">%e或%E</span>，以规格化指数形式输出小数，e和E分别表示指数e的大小写形式，可以使用<span class="tips">%m.ne或%m.nE</span>形式指定输出位数和数字部分的小数位数，一般默认数字部分的小数数位为6位，指数部分为5位(如：e+002)<code>printf("%e",123.456);printf("%e",123.456);//输出1.234560e+002，默认数字部分6位小数printf("%10.2E",123.456);//输出 1.23E+002，左补1个空格，数字部分的小数保留2位，注意：小数点、e、+等字符均占用一个位置</code>10.<span class="tips">%g或%G</span>，根据数值大小自动选择使用%f或%e形式，保证输出宽度最小，不输出无意义的011.<span class="tips">%%</span>，输出%12.<span class="tips">%p</span>，以十六进制无符号整数形式输出变量或指针变量的地址<code>int num = 10;int* p;p = &num ;printf("%p\n", &num);//输出结果参考:001DFB0Cprintf("%p\n", p);</code>理解：1. &*p等价于&a2. *&a等价于a3. (*p)++等价于a++，由于++和*同优先级且右结合，因此不能写为*p++，否则会被解析为*(p++)</div><h5 id="scanf输入函数"><a href="#scanf输入函数" class="headerlink" title="scanf输入函数"></a>scanf输入函数</h5><p>标准输入语句格式为：</p><div class="apiBox">scanf("格式控制",地址表列)</div><p>格式控制与printf()函数的格式控制类似，如果格式控制中有格式说明以外的字符，则输入数据时需要在对应位置输入相同的字符；地址表列可以为变量地址、字符串首地址，通常需要用取地址符<span class="tips">&amp;</span>加以引导，多个地址参数使用<span class="tips">,</span>分隔。</p><div class="table"><table><thead><tr><th>格式输入符</th><th>说明</th></tr></thead><tbody><tr><td>%d或%i</td><td>输入有符号十进制整数</td></tr><tr><td>%I64d</td><td>输入long long类型整数</td></tr><tr><td>%u</td><td>输入无符号十进制整数</td></tr><tr><td>%o</td><td>输入无符号八进制整数</td></tr><tr><td>%x或%X</td><td>输入无符号十六进制整数</td></tr><tr><td>%c</td><td>输入一个字符，空白字符、回车、制表符也视为有效字符</td></tr><tr><td>%s</td><td>输入字符串，输入空白字符、回车、制表符会被认为输入结束，但开头输入空白字符会被系统跳过</td></tr><tr><td>%f</td><td>输入小数，可以用小数形式或指数形式</td></tr><tr><td>%e,%E,%g,%G</td><td>与%f相同，大小写作用相同</td></tr><tr><td>%%</td><td>输入一个%</td></tr></tbody></table></div><div class="table"><table><thead><tr><th>格式修饰符</th><th>说明</th></tr></thead><tbody><tr><td>l</td><td>用于输入长整型数据(%ld,%lo,%lx,%lu)和double型数据(%lf,%le)</td></tr><tr><td>h</td><td>用于输入短整型数据(%hd,%ho,%hx)</td></tr><tr><td>域宽m(正整数)</td><td>指定输入数据的宽度(列数)，系统根据此宽度自动截取数据</td></tr><tr><td>*</td><td>忽略输入修饰符，表示对应的输入项在读入后不赋给相应变量</td></tr></tbody></table></div><p>用scanf()输入数据时，遇到以下情况会被认为数据输入结束：</p><ul><li>遇到空格符、回车符、制表符(Tab)</li><li>达到输入域宽</li><li>遇到非法字符输入</li></ul><div class="show">1. 格式控制中有普通字符，则输入数据时也要输入对应字符(包括空格)scanf("a=%d,b=%d",&a,&b);//输入形式必须为a=10,b=202. 可以指定输入数据所占的列宽，系统会自动截取scanf("%3d%3d",&a,&b);//输入123456a1，则123赋值给a，456赋值给b，多余部分a1抛弃3. 可以用*跳过指定列数scanf("%d%*c%d",&a,&b);//输入123 456，则123赋值给a，456赋值给b，中间的空格符根据%*c跳过scanf("%2d%*3d%2d",&a,&b);//输入1234567，则12赋值给a，345被忽略，67赋值给b4. scanf()函数的返回值一般为正确读入数据的个数scanf("%2d%2d",&a,&b);//输入1234返回值为2scanf("%2d%2d",&a,&b);//输入12a,只给a读入了正确值，返回值为1scanf("%2d%2d",&a,&b);//输入a，返回值为0</div><h5 id="putchar-与getchar"><a href="#putchar-与getchar" class="headerlink" title="putchar()与getchar()"></a>putchar()与getchar()</h5><p>用于输入或输出一个字符，只能用于处理字符</p><ul><li><span class="strong">getchar() 输入一个字符，无参数</span></li><li><span class="strong">putchar(参数) 输出一个字符，参数可以为字符变量、整型变量，也可以为一个字符常量或转义字符</span></li></ul><div class="show">char a;a=getchar();putchar(a);putchar('a');putchar('\n');</div><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>自定义函数的定义语法为：</p><div class="apiBox">返回值类型 函数名(类型 形参1,....){        /*函数体*/}</div><ul><li>函数返回值只能有一个，返回值类型可以是除数组外的任何类型</li><li>函数无返回值时，返回值类型需要声明为<span class="strong">void</span>，可以不需要return语句，但通常会以 <span class="tips">return;</span>作为程序结束语句，表示程序正常执行结束且返回值为空，这是一种良好的编程习惯</li><li>如果函数返回值和函数定义时声明的返回值类型不同，则将以函数类型为准，系统自动进行数据转换</li><li>在定义函数时如果不指定返回值类型，系统会隐含指定为int型</li><li>函数名的命名规则与变量相同</li><li>形参(形式参数)必须指定类型，但变量名任意</li><li>形参在函数调用前，不占用存储单元，函数调用时才被分配内存，并在执行完后会被回收</li></ul><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>函数调用语法：</p><div class="apiBox">函数名(实参1,....)</div><ul><li>实参(实际参数)可以为常量，或者有确定值的变量或表达式</li><li>实参和形参的数据类型应该相同，或者<span class="tips">赋值兼容</span>(参考赋值一节的赋值规则，如字符型和整型相互通用)，但应该尽量避免使用赋值兼容</li></ul><div class="show"><code>#include&lt;stdio.h>//函数定义时不指定返回值类型，隐含为int类型//用Visual Studio编译这段代码时，会有提示warning C4013: “getMax”未定义；假设外部返回 intgetMax(int a, int b) &#123;    return a > b ? a : b;&#125;int main(void) &#123;    printf("%d", getMax(10, 20));    return 0;&#125;</code></div><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>又称<span class="strong">函数原型</span>(Function Prototype)声明，其作用是将函数名、函数类型、形参类型、个数和顺序通知编译系统，以便调用该函数时系统按此进行对照检查。函数声明语法：</p><div class="apiBox">函数类型 函数名(形参1,....)</div><ul><li>如果被调用的函数定义在主调函数之前，可以不加声明，编译器会根据函数定义时首部提供的信息对函数调用作准确性检查</li><li>如果被调用函数类型为整型，也可以不加声明</li><li>函数声明可以在文件开头(所有函数前)，也可以在主调函数中</li><li>对于形参，编译器只检查形参类型和个数，不检查参数名，因此参数名任意，也可以省略</li></ul><div class="show"><code>#include&lt;stdio.h>int main(void) &#123;    int  getMax(int, int);//原型声明    printf("%d", getMax(10, 20));    return 0;&#125;int getMax(int a, int b) &#123;    return a > b ? a : b;&#125;</code></div><h4 id="内部函数与外部函数"><a href="#内部函数与外部函数" class="headerlink" title="内部函数与外部函数"></a>内部函数与外部函数</h4><p><span class="strong">外部函数：</span>定义函数时，可以在函数返回值类型前加上<span class="text-blue">extern</span>将其定义为外部函数，extern可以省略，因此如果函数未特意声明为内部函数，则默认隐含为外部函数，即<span class="tips">C语言中，函数默认为外部函数</span>，外部函数可以被其他文件调用，只需要在要调用此函数的文件中，用extern作函数原型声明即可，其中函数原型声明前的extern也可以省略</p><p><span class="strong">内部函数：</span>又称静态函数，定义函数时在函数首部添加<span class="text-blue">static</span>修饰即可定义内部函数，内部函数作用域仅限于本文件，不能被其他文件调用，不同的文件可以有同名的内部函数，互不干扰</p><div class="show">eg:文件file1.c调用文件file2.c中的函数file1.c<code>#include&lt;stdio.h&gt;int main(void)&#123;    <span class="text-blue"> extern void getStrings(char str[]);</span>//extern可以省略，写为void getString(char str[])    <span class="text-red">static void test();</span>//调用内部函数需要static声明    char str[50];    getStrings(str);    printf("%s\n", str);    test();//调用本文件中的test()函数    return 0;&#125;<span class="text-red">static void test()</span>//内部函数，仅供本文件调用&#123;    printf("file1.c");    return;&#125;</code>file2.c<code>#include&lt;stdio.h&gt;<span class="text-blue">extern void getStrings(char str[])</span>//extern 可以省略&#123;    gets(str);&#125;<span class="text-red">static void test()</span>//内部函数，可以与file1.c中的test()函数同名&#123;    printf("file2.c");    return;&#125;</code></div><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>由此可见，声明函数原型的作用除了在调用时作准确性检查，还可以拓展函数作用域到定义本函数的文件之外，只要在所有调用该函数的文件中作一个函数原型声明即可。如：各种库提供的头文件中，就包含了大量函数及其函数原型声明，我们只需要使用#include命令将其包含到我们的c文件中，就可以不需要了解其函数和函数原型，就直接使用该函数。原型声明时extern可以省略，但我们自己编写头文件中的原型声明时应当保留extern关键字来保证代码清晰性。</div><h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><p>C语言中，类型限定符用于指定数据的访问属性。常见的类型限定符包括<span class="tips">const</span>(常量)、<span class="tips">volatile</span>(易变的)、<span class="tips">restrict</span>(限定)和<span class="tips">_Atomic</span>(原子)</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><h5 id="const修饰变量"><a href="#const修饰变量" class="headerlink" title="const修饰变量"></a>const修饰变量</h5><p>const用于限定变量的值不能被修改，表明变量中存储的值是一个常量，这类变量本质是变量，但又有常量属性，因此又称为”常变量”，const修饰的常变量必须在定义的同时赋值，而后其值就不能再改变，任何赋值行为都将引发错误。定义常变量时，const和变量类型位置可以互换，因此以下两个语句等价：</p><div class="show"><code>const int num=100;int const num=100;</code></div><p>全局常变量存储于静态存储区的.rodata段，而局部常变量存储于栈内存中。对于局部常变量，由于栈内存本身是可读写的，所以即便编译器会对const修饰的局部变量进行内存保护，防止该变量的值被修改，但我们依然可以用其他方法修改该变量的值：</p><div class="show"><code>const int num=100;int *p=&num ;*p=0;printf("%d",num);//num值被修改为0</code></div>这种通过指针来间接操作访问和操作指针所指对象值的方法称为指针解引用(dereference)，C语言标准明确指出，通过指针解引用的方式去修改一个const修饰的变量，其行为是未定义的，因此对于局部常变量，我们不应该通过该方法修改其值。对于全局常变量，数据存储于.rodata段，该段内存只有读权限，通过任何方法修改数据都会抛出写入访问权限冲突异常，在某些嵌入式系统中，全局常变量和代码会被一起存入ROM存储介质中无法修改。<h5 id="const修饰数组"><a href="#const修饰数组" class="headerlink" title="const修饰数组"></a>const修饰数组</h5><p>对于数组，由于数组名本身就代表数组起始地址，是一个地址常量，不能被任何限定符修饰，因此const修饰数组时，将用于修饰数组元素，即const修饰数组时，数组元素为常量无法修改</p><div class="show"><code>const int nums[] = &#123; 10,20,30,40,50 &#125;;<span class="text-red">nums[2] *= 10;//错误！无法修改</span></code></div><h5 id="const修饰复合类型"><a href="#const修饰复合类型" class="headerlink" title="const修饰复合类型"></a>const修饰复合类型</h5><p>const修饰结构体、枚举等复合类型时，表示该类型中的所有成员值不能被修改</p><div class="show"><code>struct test &#123;        int a;        int b;    &#125;;    const struct test num = &#123; 10,20 &#125;;或    const struct test &#123;        int a;        int b;    &#125; num = &#123;10,20&#125;;或struct test &#123;        int a;        int b;    &#125; const num = &#123;10,20&#125;;初始化完毕成员变量值不能再被修改<span class="text-red">num.a=100;//错误！不能修改成员值</span></code></div><h5 id="指针与const类型限定符"><a href="#指针与const类型限定符" class="headerlink" title="指针与const类型限定符"></a>指针与const类型限定符</h5><p>指针常用来在函数间传递数据，方便调用者直接对数据进行操作，但有时我们只希望将数据传到函数内部，而不希望它们在函数内被修改，此时，我们可以使用<span class="tips">const</span>对参数进行限定</p><div class="show">const位于声明语句的不同位置，将表示不同的含义，以int类型为例：<code>int a,b;</code>1. const放在类型关键字前面<span class="text-blue">const int * p=&a;</span>按从右到左解析为：p是一个指针变量，可指向一个整型常量，*p是一个常量，而p不是。即*p的值是不可修改的，无法用*p=10;等方式重新赋值，但指针变量p的指向是可以被修改的，即p=&b是允许的2. const位于类型关键字后*变量名前<span class="text-blue">int const *p=&a;</span>按从右到左解析为：p是一个指针常量，可以指向一个常量整数，同样*p是一个常量，而p不是，不能用指针变量p去修改这个"为常量的整数"，与第一种情况作用相同3. const位于*后，变量名前<span class="text-blue">int * const p=&a;</span>按从右到左解析为：p是一个指针常量，可以指向一个整型数据，它表明p是一个常量，而*p不是。由于p是常量指针，因此不能修改p的指向，p=&b操作是非法的，但*p=20是合法的4. 两个const修饰，一个位于类型关键字前，一个位于*后<span class="text-blue">const int * const p=&a;</span>按从右到左解析为：p是一个指针常量，可指向一个整型常量，它表明p和*p都是常量，是只读的，*p=20和p=&b操作都是非法的上述四种用法中，第一种用法较为常用，C语言很多库函数都使用该方法，只允许函数访问该指针指向的内容，不允许修改其内容，如：<code>int puts(const char * str);int printf(const char * format , ...);</code></div><p>对于被const限制的指针变量，不能将普通指针变量赋值给被限制的指针变量，但反过来可以，如：<span class="tips">const char *</span>和<span class="tips">char *</span>是不同的类型，const char *指向的数据只有读取权限，而char *指向的数据有读写权限，因此不能将const char *赋值给char *，但可以将char *类型的数据赋值给const char *类型的变量</p><div class="show">C语言函数库中很多函数参数都被const限制了，但我们仍然可以将非const类型的数据传递给const类型的形参，如对于函数原型int puts(const char * str);可以直接传递非const类型的数据char * str="Hello";puts(str);</div><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile用于声明变量的值是易变的，每次用到该变量的值时都需要去内存中重新读取这个变量的值，而不是读取其在寄存器中的备份。在多线程环境下，volatile 表示变量可能会被多个同时执行的线程修改，存取时无需额外的内存保护，并且防止优化编译器把变量从内存装入寄存器中，因为如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，造成程序的错误执行，volatile的声明方式为：</p><div class="show"><code>volatile int counter;</code></div><h4 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h4><p>restrict是C99标准新增的限定符，该限定符只能用于指针变量，其作用是程序员通过该限定符告知编译器，restrict修饰的指针独占其所指向的内存，所有对该内存的操作都将基于该指针，而不再会有其他任何变量或指针操作该内存，以便让编译器进行一些针对性的优化。这种优化是针对特殊使用场景的，因此可能出现没有任何优化的情况，并且由于restrict指针独占是由程序员来判断并加以限定的，可能会出现误判的情况，因此，restrict一般用于非常需要性能优化，并且已经确认两个指针不会指向同一内存的场景，其定义语法为：</p><div class="show"><code>int * restrict a;</code>eg:业务上明确得知，某个malloc开辟的空间，只会通过mySpace指针变量进行操作，则可以使用restrict限定符告知编译器，由其进行优化<code>int * restrict mySpace=(int *)malloc(10*sizeof(int));</code></div><h4 id="Atomic"><a href="#Atomic" class="headerlink" title="_Atomic"></a>_Atomic</h4><p>_Atomic是C11标准引入的限定符，用于指定原子类型，提供原子性操作。原子操作是指对原子对象的操作是不可被打断的，该操作一旦执行，不会被其他线程或者事件中断，直到操作执行完毕。默认的声明方式为：</p><div class="show"><code>_Atomic int x=0;</code></div><p>但在实际使用时，应该使用<span class="text-blue">&lt;stdatomic.h&gt;</span>头文件中已经定义好的原子类型，该头文件还定义了相关的原子操作函数</p><div class="show">一些stdatomic.h头文件定义的原子类型和原子操作举例<code>typedef _Atomic int atomic_int;typedef _Atomic char atomic_char;...atomic_init(volatile A* obj, C desired )初始化原子类型变量....</code>eg:定义一个原子类型变量并初始化<code>#include &lt;stdio.h>#include &lt;stdatomic.h>int main(void)&#123;    atomic_int a;    atomic_init(&a,10);    return 0;&#125;</code></div><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>动态内存分配函数在堆上分配内存，使用前需要包含<span class="tips">&lt;stdlib.h&gt;</span>头文件</p><h4 id="内存空间申请与释放"><a href="#内存空间申请与释放" class="headerlink" title="内存空间申请与释放"></a>内存空间申请与释放</h4><ul><li><span class="strong">void *malloc(unsigned int size);</span></li></ul><p>分配长为size字节的内存空间，返回该内存首地址，若无足够内存单元，则返回空指针NULL</p><div class="show"><code>int *p=(int *)malloc(4*sizeof(int))</code></div><ul><li><span class="strong">void *calloc(unsigned int num,unsigned int size);</span></li></ul><p>用于给同一类型的数据分配连续的内存空间并赋值为0(数值型)或空(字符型)。它相对于声明了一个一维数组，并且会初始化该数组值为0或空，参数num为所需申请的内存空间数量，相对于数组长度，参数size为每个内存空间的字节数，相对于数组基类型的字节长度。若申请成功，返回该内存空间的首地址，否则返回空指针NULL</p><div class="show"><code>int * p=(int *)calloc(10,sizeof(int));相对于int * p=(int *)malloc(10*sizeof(int));但calloc()会将分配的内存自动初始化为0或空，更为安全</code></div><ul><li><span class="strong">void *realloc(void *p,unsigned int size);</span></li></ul><p>用于改变原来分配的内存，将p所指向的存储空间大小改为size个字节，返回值是新分配的内存空间首地址，与原来分配的首地址不一定相同</p><ul><li> <span class="strong">void free(void *p);</span></li></ul><p>用于释放所申请的内存空间，即p所指向的空间，其中p只能是由malloc()和calloc()申请的内存地址</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="二进制文件与文本文件"><a href="#二进制文件与文本文件" class="headerlink" title="二进制文件与文本文件"></a>二进制文件与文本文件</h4><p>C语言文件有两种类型：<span class="text-blue">文本文件</span>(也称ASCII码文件)和<span class="text-blue">二进制文件</span>。二者的区别在于存储数值型数据的方式不同。二进制文件中，数值型数据是将整个数值转码为二进制形式存储；而在文本文件中，数值型数据的每一位数字作为一个字符以其ASCII码形式存储，每个数字都单独占用一个字节的存储空间。如：对于short int n=123，二进制文件中，变量n为short类型仅占用2个字节存储空间，而在文本文件中占用3个字节存储空间。</p><p>二进制文件和文本文件各有优缺点。文本文件可以很方便被其他程序读取，包括文本编辑器、Office办公软件等，且输出内容与字符一一对应，一个字节表示一个字符，便于对字符逐个处理，便于输出字符，但一般占用的存储空间较大，且ASCII码和字符转换需要花费一定时间。二进制文件可以节省空间和转换时间，但不方便其他程序读取，不能直接输出其字符形式。</p><p>无论文件内容是什么形式，C语言一律将数据看成由字节构成的序列，即<span class="text-blue">字节流</span>，对文件的存取也是以字节为单位进行的，输入、输出的数据仅受程序控制而不受物理符号(如回车换行符)控制，因此，C语言文件又称为流式文件。</p><p>C语言文件系统分为<span class="text-blue">缓冲型</span>和<span class="text-blue">非缓冲型</span>，缓冲型文件系统是指系统自动为每一个正在使用的文件在内存中开辟一个输入/输出文件缓冲区，作为程序和文件之间数据交换的缓冲区域。在读文件时，数据先从磁盘送到缓冲区，再传给C语言程序；在写文件时，数据从C语言程序送到缓冲区，装满缓冲区后再输出到磁盘。缓冲文件系统利用<span class="text-red">文件指针</span>标识文件，不同版本的C语言缓冲区大小不一样，一般为512字节。而非缓冲文件系统不会自动数值文件缓冲区，缓冲区必须由程序员自己设定，它使用称为文件号的整数来标识文件。</p><p>在UNIX系统中，缓冲文件系统用来处理文本文件，用非缓冲文件系统来处理二进制文件。用缓冲文件系统进行输入输出的操作又称为高级文件操作，用非缓冲文件系统来处理输入输出的操作又称为低级输入输出操作。ANSI C标准规定只采用缓冲文件系统，即既用缓冲文件系统处理文本文件，也用它处理二进制文件，因此下文主要为高级文件操作函数。</p><h4 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h4><p>缓冲文件系统中，系统为每个正在使用的文件在内存中开辟了一个缓冲区，用来存放文件的有关信息(如：文件名、文件句柄、文件状态、文件路径等)，这些信息保存在一个结构体变量中，该结构体类型由系统定义，名为<span class="text-red">FILE</span>，stdio.h文件中有该文件类型声明：</p><div class="show"><code>typedef struct&#123;   short level;    //缓冲区"满"或"空"的程度    unsigned flags;//文件状态标志    char fd;      //文件描述符    unsigned char hold;//如果无缓冲区不读取字符    short bsize;//缓冲区大小    unsigned char *buffer;//数据缓冲区位置    unsigned ar *curp;//指针当前指向    unsigned istemp;//临时文件指示器    short token;//用于有效性检查&#125;FILE;</code></div><p>由此，我们可以定义一个文件类型的指针变量：<span class="text-red">FILE *fp</span>，然后将该指针指向一个文件的结构体变量，从而通过该指针访问该结构体变量中的文件信息，并通过这些信息访问该文件。</p><h4 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h4><h5 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h5><p>函数fopen()用于打开文件，其函数原型如下：</p><div class="apiBox">FILE * fopen(const char * filename,const char * mode)</div><p>该函数返回一个文件类型的指针，如果文件打开失败，则返回一个空指针NULL(NULL在stdio.h文件中被定义为0)。fopen()有两个形参，第一个形参filename表示文件名，可以包含<span class="strong">文件路径和文件名</span>两部分，第二个形参mode表示文件的打开方式，取值如下所示：</p><div class="table"><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>以<span class="text-yellow">只读方式</span>打开<span class="text-blue">文本文件</span>，只能读出而不能写入数据，若文件不存在，则报错</td></tr><tr><td>w</td><td>以<span class="text-yellow">只写方式</span>(新建形式)，创建并打开<span class="text-blue">文本文件</span>，无论文件是否存在，都会创建一个新的文本文件，只能写入数据，已经存在的文件将被覆盖</td></tr><tr><td>a</td><td>以<span class="text-yellow">只写方式</span>(追加形式)，打开<span class="text-blue">文本文件</span>，位置指针移到文件末尾，向文件尾部添加新数据，若文件不存在，则会新建一个文件</td></tr><tr><td>b</td><td>与上面的字符串组合，表示打开二进制文件</td></tr><tr><td>rb</td><td>以<span class="text-yellow">只读方式</span>打开<span class="text-red">二进制文件</span></td></tr><tr><td>wb</td><td>以<span class="text-yellow">只写方式</span>打开<span class="text-red">二进制文件</span></td></tr><tr><td>ab</td><td>以<span class="text-yellow">只写方式</span>向<span class="text-red">二进制文件</span>末尾添加数据</td></tr><tr><td>+</td><td>与上面的字符串组合，表示以读写方式打开文本文件，既可以向文件中写入数据，也可以从文件中读取数据</td></tr><tr><td>r+</td><td>以<span class="text-green">可读可写</span>的方式打开<span class="text-blue">文本文件</span></td></tr><tr><td>w+</td><td>以<span class="text-green">可读可写</span>方式创建一个新的<span class="text-blue">文本文件</span></td></tr><tr><td>a+</td><td>以<span class="text-green">可读可写</span>方式向<span class="text-blue">文本文件</span>末尾追加数据</td></tr><tr><td>rb+</td><td>以<span class="text-green">可读可写</span>的方式打开<span class="text-red">二进制文件</span></td></tr><tr><td>wb+</td><td>以<span class="text-green">可读可写</span>方式创建一个新的<span class="text-red">二进制文件</span></td></tr><tr><td>ab+</td><td>以<span class="text-green">可读可写</span>方式向<span class="text-red">二进制文件</span>末尾追加数据</td></tr></tbody></table></div><p>注意：</p><ul><li>有的C语言编译系统可能不完全提供上述功能，如：有的C语言编译器不支持r+、w+、a+</li><li>输入文本文件时，内容中的回车换行符会被转换为一个换行符，在输出时，则会将换行符转换为回车和换行两个字符。而在输入输出二进制文件时，不会进行这种转换，文件中的数据与内存中的数据完全一致，一一对应</li></ul><h5 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose()函数"></a>fclose()函数</h5><p>函数fclose()用来关闭一个由函数fopen()打开的文件，其函数原型如下：</p><div class="apiBox">int fclose(FILE *fp);</div><p>函数返回一个整型值，当文件成功关闭时，返回0值，否则返回一个非0值(一般为EOF -1)，可用于判断文件是否关闭成功。当使用fclose()关闭文件后，指针fp将不再指向该文件。</p><p>由于操作系统对于同时打开的文件数目是有限制的，所以文件使用结束后必须关闭文件。此外，不建议使用读写方式打开文件，因为读写共用一个缓冲区，每次读写都会改变文件位置指针，很容易写乱，破坏文件内容，并且需要调用文件定位函数才能在读写之间切换。</p><div class="show"><code>FILE * fp;fp=fopen("D:\\demo.text","a+");fclose(fp);</code></div><h4 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h4><h5 id="按字符读写"><a href="#按字符读写" class="headerlink" title="按字符读写"></a>按字符读写</h5><ul><li><span class="strong">int fgetc(FILE *fp)</span> 从fp所指向文件读取一个字符，并使位置指针指向下一个字符。如果读取成功，则返回该字符，若读取到文件末尾，则返回EOF(stdio定义为-1)</li><li><span class="strong">int fputc(int c,FILE *fp)</span> 将字符c(尽管c定义为int型，但只写入低字节)写到文件指针fp所指向的文件中。若写入错误，则返回EOF，否则返回字符c</li></ul><div class="show">在读入文本文件时，可通过fgetc()函数的返回值来判断是否读取到了文件末尾(文件是否读取完毕)，当读入的字符值等于-1(即EOF)时，说明文件已经读取完毕。但在读入二进制文件时，读入的数据可能刚好为-1(EOF)，此时就需要使用feof()函数判断当前文件是否读取完毕。如果文件结束，则feof(fp)的值为1(真)，否则为0(假)eg:从键盘输入字符，并将这些字符存储到磁盘文件中，直到输入"#"为止<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123;    FILE *fp;    char ch,filename[10];    scanf("%s",filename);//输入文件名    if((fp=fopen(filename,"w"))==NULL)&#123;        printf("文件打开失败\n");        exit(0);    &#125;    ch=getchar();//接收执行scanf语句时输入的回车符    ch=getchar();    while(ch!='#')    &#123;        <span class="text-blue">fputc(ch,fp);</span>        ch=getchar();    &#125;    fclose(fp);        return 0;&#125;</code>eg:从当前路径文件夹下读取名为"myTest.txt"的文件，并将内容输出到控制台<code>int main(void) &#123;    FILE* fp;    char ch;    if ((fp = fopen("myTest.txt", "r")) == NULL) &#123;        printf("文件打开失败！\n");        exit(0);    &#125;    while (<span class="text-red">!feof(fp)</span>) &#123;        ch = fgetc(fp);        putchar(ch);    &#125;    return 0;&#125;</code></div><h5 id="按字符串读写"><a href="#按字符串读写" class="headerlink" title="按字符串读写"></a>按字符串读写</h5><ul><li><span class="strong">char * fgets(char *s,int n,FILE *fp)</span> 从fp所指向文件中读取最多含n-1个字符的字符串，并在字符串末尾添加’\0’，然后存入s。当读取到回车换行符、到达文件末尾或者读满n-1个字符时，函数返回该字符串的首地址，即指针s的值；读取失败时返回空指针NULL</li><li><span class="strong">int fputs(const char *s,FILE * fp)</span> 将字符串s写入文件fp，若写入错误，则返回EOF(-1)，否则返回一个非负数</li></ul><div class="show">eg:从键盘输入一个字符串，追加到文件末尾<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123;    FILE * fp;    char str[20];    if((fp=fopen("demo.txt","a"))==NULL)&#123;        printf("Failure to open file!\n");        exit(0);    &#125;    gets(str);    fputs(str,fp);    fclose(fp);    if((fp=fopen("demo.txt","r"))==NULL)&#123;        printf("Failure to open file!\n");        exit(0);    &#125;    fgets(str,20,fp);    puts(str);    fclose(fp);    return 0;&#125;</code></div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>这两个函数与puts()和gets()类似，区别在于，gets()函数从输入缓冲区读取字符串时，会将回车符也从缓冲区读走，但不作为字符串的一部分，而fgets()函数读到换行符时会将换行符作为字符串的一部分读到字符串中来。输出时，puts()函数在向终端输出字符串时，会在字符串输出结束后，自动输出一个换行符，而fputs()函数不会在字符串末尾加上换行符。</div><h5 id="按格式读写文件"><a href="#按格式读写文件" class="headerlink" title="按格式读写文件"></a>按格式读写文件</h5><ul><li><span class="strong">int fscanf(FILE *fp,格式字符串,输入表列地址)</span>从指定文件按格式读取数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为输入变量的地址表列</li><li><span class="strong">int fprintf(FILE *fp,格式字符串,输出表列)</span>按指定格式向文件写入数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为要写入的变量</li></ul><p>用函数fscanf()和fprintf()进行文件的格式化读写，读写方便，容易理解，但输入时要将ASCII字符转换为二进制数，输出时要将二进制数转换为ASCII字符，耗时较多。因此，内存和磁盘进行频繁数据交换时，应当尽量避免使用这两个函数，而用fread()和fwrite()函数</p><div class="show"><code>int i=10;float j=4.5;fprintf(fp,"%d,%6.2f",i,j);//保存为10,  4.50fscanf(fp,"%d,%f",&i,&j);//假设文件内容为10,4.5，则i赋值为10，j赋值为4.5</code></div><h5 id="按数据块读写文件"><a href="#按数据块读写文件" class="headerlink" title="按数据块读写文件"></a>按数据块读写文件</h5><ul><li><span class="strong">unsigned int fread(void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 从fp所指的文件读取数据块并存储到buffer所指向的内存。buffer是待存入数据块的起始地址，可以是数组起始地址、结构体变量起始地址等，size是每个数据块的大小，count是最多允许读取的数据块个数，函数返回的是实际读取到的数据块个数</li><li><span class="strong">unsigned int fwrite(const void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 将buffer所指内存中的数据块写入fp所指的文件。同样，buffer是待读出数据块的起始地址，size是每个数据块的大小，count是最多允许写入的数据块个数，函数返回的是实际写入的数据块个数<br>块数据读写允许用户以数组、结构体等数据类型整块读写，不再局限于一次只读写一个字符或字符串，可以指定想要读写的内存块大小，最小为1字节，最大可以为整个文件</li></ul><div class="show">eg:整块读写数组内容<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void) &#123;    int nums[] = &#123; 11,22,33,44,55,66,77,88,99 &#125;;    int numsRead[9];    FILE* fp;    if ((fp = fopen("data.txt", "w")) == NULL) &#123;        printf("文件打开失败!");        exit(0);    &#125;    <span class="text-blue">fwrite(nums, 4, sizeof(nums)/4, fp);</span>//将数组nums到文件fp中，数组为int类型，数据块为4Bytes，需要写入9个数据块    fclose(fp);    if ((fp = fopen("data.txt", "r")) == NULL) &#123;        printf("文件打开失败!");        exit(0);    &#125;    <span class="text-red">fread(numsRead, 4, 9, fp);</span>//从fp文件中读取9个4Bytes的数据块，并存储到numsRead数组中    for (int i = 0; i < 9; i++) &#123;        printf("%4d", numsRead[i]);    &#125;    fclose(fp);    return 0;&#125;</code></div><p>eg:按块文件读写结构体变量，输入每个学生的信息并保存到studentData.txt文件中，并添加从该文件中读出学生信息并打印到控制台的功能</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10typedef struct student &#123;    char name[10];    long studentID;    int age;    int classID;&#125;STUDENT;int main(void) &#123;    void writeToFile(STUDENT[], int);    int readFromFile(STUDENT[]);    void printToScreen(STUDENT[], int);    STUDENT stu[MAXSIZE];    int studentNum;    printf("请输入学生数量：\n");    scanf("%d", &studentNum);    printf("请输入学生信息：\n");    for (int i = 0; i &lt;studentNum; i++) &#123;        scanf("%s %ld %d %d", stu[i].name, &stu[i].studentID, &stu[i].age, &stu[i].classID);    &#125;    writeToFile(stu, studentNum);    studentNum = readFromFile(stu);    printToScreen(stu, studentNum);    return 0;&#125;void writeToFile(STUDENT stu[], int n) &#123;    FILE* fp;    if ((fp = fopen("studentData.txt", "w")) == NULL) &#123;        printf("文件打开失败！");        exit(0);    &#125;    fwrite(stu, sizeof(STUDENT), n, fp);    fclose(fp);&#125;int readFromFile(STUDENT stu[]) &#123;    FILE* fp;    int i;    if ((fp = fopen("studentData.txt", "r")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    for (i = 0; !feof(fp); i++) &#123;        fread(&stu[i], sizeof(STUDENT), 1, fp);    &#125;    fclose(fp);    return i - 1;&#125;void printToScreen(STUDENT stu[], int num) &#123;    printf("----------------------\n");    for (int i = 0; i &lt; num; i++) &#123;        printf("%6s%10ld%4d%4d\n", stu[i].name, stu[i].studentID, stu[i].age, stu[i].classID);    &#125;&#125;</code></pre><h5 id="数字读写putw-和getw"><a href="#数字读写putw-和getw" class="headerlink" title="数字读写putw()和getw()"></a>数字读写putw()和getw()</h5><p>putw()和getw()不是ANSI C标准定义的函数，但很多编译器提供这两个函数，有的编译器将其命名为_putw()和_getw()函数(Visual Studio 2019(编译器版本主要支持ANSI C89标准，但其中包含几个Microsoft扩展支持ISO C99的一部分函数)只能用这两个函数名)，因此这两个函数的在不同编译器中函数名可能不同，函数名中的<span class="tips">w</span>是指<span class="tips">word(字)</span></p><ul><li><span class="strong"> int getw(FILE *fp)</span> 从fp读取一个整数，如果读取成功，返回该整数，读取失败或文件结束，返回-1</li><li><span class="strong">int putw(int w, FILE *fp)</span> 将一个字符或字输出到文件fp，返回值为输出的整数</li></ul><div class="show">eg:存储0-9整数到文件test.txt中，读出后输出到控制台<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void) &#123;    FILE* fp;    int getNum;    if ((fp = fopen("test.txt", "w")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    for (int i = 0; i < 10; i++) &#123;        <span class="text-blue">_putw(i, fp);</span>    &#125;    fclose(fp);    if ((fp = fopen("test.txt", "r")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    for (int i = 0; i < 10; i++) &#123;        <span class="text-blue">getNum = _getw(fp);</span>        printf("%4d", getNum);    &#125;    fclose(fp);    return 0;&#125;</code></div><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><p>之前的示例执行的都是顺序文件处理，数据项是依次进行读写的，如果需要读取第5个数据项，按顺序文件处理方法必须先读取前4个数据项。如果要读写指定位置的数据项，则需要使用文件的随机访问，允许在文件中随机定位，并在文件任意位置读写数据。</p><p>为了实现文件的定位，每一个打开的文件中，都有一个<span class="text-blue">文件位置指针</span>，用来指向当前文件读写位置。当对文件进行顺序读写时，每读完一个字节，位置指针就会自动指向下一个字节。当需要随机读写时，需要我们人为指定位置指针的指向，C语言提供了几个关于位置指针的函数</p><h5 id="重置位置指针rewind"><a href="#重置位置指针rewind" class="headerlink" title="重置位置指针rewind()"></a>重置位置指针rewind()</h5><p><span class="strong">void rewind(FILE *fp)</span> 使fp文件的位置指针指向文件首字节，即重置位置指针到文件开头</p><div class="show">eg:打印file1文件内容到控制台，并将其复制到file2，两个任务分开执行。第一次打印完file1文件，文件位置指针位于文件末尾，使用rewind()函数将file1文件位置指针重置到文件开头，执行其他任务<code>FILE *fp1=fopen("file1.txt","r");FILE *fp2=fopen("file2.txt","r");//应当有文件打开失败的错误处理，这里省略while(!feof(fp1))&#123;    putchar(getc(fp1));&#125;<span class="text-blue">rewind(fp1);</span>while(!feof(fp1))&#123;   putc(getc(fp1),fp2);&#125;fclose(fp1);fclose(fp2);</code></div><h5 id="指定指针位置fseek"><a href="#指定指针位置fseek" class="headerlink" title="指定指针位置fseek()"></a>指定指针位置fseek()</h5><p><span class="strong">int fseek(FILE *fp,long offset,int fromwhere);</span>将fp的位置指针从fromwhere移动offset个字节</p><p>offset是一个偏移量，告诉文件指针跳过多少个字节，ANSI C要求offset是<span class="tips">long</span>类型的(其常量值后面要加L)，这样当文件长度大于64kb时不至于出问题。当offset为正时，位置指针向后移动，为负时向前移动。由于需要指定具体字节数，因此该参数往往需要<span class="tips">sizeof(数据类型)</span>函数来获取相应类型的字节数。</p><p>fromwhere用于确定偏移量计算的起始位置，可以取以下三个值：</p><div class="table"><table><thead><tr><th>起始点</th><th>别名</th><th>值</th></tr></thead><tbody><tr><td>文件开始</td><td>SEEK_SET</td><td>0</td></tr><tr><td>文件当前位置</td><td>SEEK_CUR</td><td>1</td></tr><tr><td>文件末尾</td><td>SEEK_END</td><td>2</td></tr></tbody></table></div><div class="show">eg:读取studentData.txt中的第k条数据并打印到控制台，k由用户输入<code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 10typedef struct student &#123;    char name[10];    long studentID;    int age;    int classID;&#125;STUDENT;int main(void) &#123;    void searchData(char fileName[],long k);    long k;    printf("Input the searching record number:");    scanf("%ld",&k);    searchData("studentData.txt",k);    return 0;&#125;void searchData(char fileName[],long k)&#123;    FILE* fp;    STUDENT stu;    if ((fp = fopen(filename, "r")) == NULL) &#123;        printf("文件打开失败!\n");        exit(0);    &#125;    <span class="text-blue">fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);</span>    <span class="text-red">fread(&stu, sizeof(STUDENT), 1, fp);</span>    printf("%8s%8ld%4d%4d", stu.name, stu.studentID, stu.age, stu.classID);    fclose(fp);&#125;</code></div><h5 id="返回指针位置ftell"><a href="#返回指针位置ftell" class="headerlink" title="返回指针位置ftell()"></a>返回指针位置ftell()</h5><p><span class="strong">long ftell(FILE *fp)</span>返回当前位置指针相对于文件开头的位移量(字节数)，若函数调用失败则返回-1L</p><div class="show">eg:ftell()返回的文件位置是用字节偏移量表示的，如果要获取记录号(第几条数据)则还要除以sizeof(STUDENT)<code>fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);//执行完指针跳转，不确定指针指向哪里，可以用ftell()返回指针位置long num=ftell(fp);//指针相对于文件头的偏移字节数int k=num/sizeof(STUDENT);//指针指向的数据序号</code></div><h4 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h4><ul><li><span class="strong">int feof(FILE *fp)</span>检查fp所指向文件是否已经读到文件末尾。当文件位置指针指向文件结束符时，返回非0值，否则返回0值</li><li><span class="strong">int ferror(FILE *fp)</span>检查对文件的输入输出操作是否出错，如果出错返回非零值，如果未出错，返回0。对同一个文件，每调用一次输入输出函数，ferror()函数的值都会更新</li><li><span class="strong">void clearerr(FILE *fp)</span>将fp所指向文件的文件错误标志和文件结束标志置为0</li><li><span class="strong">void perror(const char *str)</span>向标准错误输出字符串str，并随后附上冒号以及全局变量errno代表的错误消息的文字说明，无返回值</li><li><span class="strong">int rename(const char *old,const char *new)</span>将文件名old所指的文件改为new，成功返回0，出错返回1<h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4>在从终端设备输入输出时，系统会自动打开三个标准文件：标准输入、标准输出、标准出错输出。系统为其定义了三个文件指针：stdin、stdout和stderr，分别指向终端输入、终端输出和标准出错输出(也从终端输出)。在默认情况下，标准输入设备是键盘，标准输出设备是屏幕，我们从终端输入、输出时不需要手动打开终端文件，系统会自动打开，同样，如果程序指定从stdin所指的文件输入数据，其实就是指从终端键盘输入数据。</li></ul><p>文件读写操作中的很多函数是标准输入输出函数的文件操作版，如：fprintf()是printf()的文件操作版，二者差别在于fprintf()多了一个文件指针类型的参数(FILE * fp)，如果给该参数传递的值是stdout，那么fprintf()就和printf()完全一样了，同理，以下语句是两两等价的：</p><div class="show"><code>putchar(c)等价于fputc(c,stdout)puts(str)等价于fputs(str,stdout)getchar()等价于fgetc(stdin)以下函数，fgets()比gets()还多了一个参数sizechar *fgets(char *str,int size,FILE *fp);char *gets(char *str);参数size用于限制输入字符串的长度，说明fgets()函数输入缓冲区大小，使读入的字符数不能超过限定的缓冲区大小，从而达到防止缓冲区溢出攻击的目的，因此，以下语句，后者安全性更高gets(str);fgets(str,sizeof(str),stdin);</code></div><p>虽然系统隐含的标准I/O文件是指终端文件，但标准输入和标准输出是可以重定向的，操作系统可以把它们重定向到其他文件或具有文件属性的设备，只有标准错误输出不能进行一般的输出重定向，如：把标准输出重定向到打印机，把标准输入重定向到U盘文件等。使用<span class="strong">“&lt;”</span>表示输入重定向，用<span class="strong">“&gt;”</span>表示输出重定向。如：file.exe是可执行文件，执行该程序时需要从键盘输入数据，如果现在要求从文件file.in读取所需要输入的数据，那么只需在DOS命令提示符下，输入以下命令即可：</p><div class="shell">c:\file.exe &lt; file.in</div>这样file.exe的标准输入就被"&lt;"重定向到了file.in文件，此时程序只会从文件file.in读取数据，而不再理会任何键盘输入。同样，以下命令可以将标准输出重定向到文件file.out：<div class="shell">c:\file.exe &gt; file.out</div><h3 id="C语言中的随机数"><a href="#C语言中的随机数" class="headerlink" title="C语言中的随机数"></a>C语言中的随机数</h3><p>C语言标准库在&lt;stdlib.h&gt;头文件中提供了用于生成随机数的函数<span class="text-red">rand()</span>，其函数原型为：<span class="strong">int rand(void)</span>，该函数可以生成<span class="text-blue">0~32767</span>范围内的随机数，但该函数生成的数是伪随机数，每次调用该函数都会重复生成以下值：</p><div class="show"><code>    printf("%d\n", rand());//41    printf("%d\n", rand());//18467    printf("%d\n", rand());//6334    printf("%d\n", rand());//26500    printf("%d\n", rand());//19169    ......</code></div><p>这是由于，各编程语言获取随机数实际上都是基于递推公式计算出一组数值，当序列足够长，这组数值可以近似满足均匀分布。在计算随机数时，这些随机函数都是基于一种名为”种子”的基准值进行运算，当种子值不变，生成的随机数也将固定。C语言中,rand()函数的种子值默认为1，可以通过<span class="text-red">srand()</span>函数来修改该种子值，其函数原型为:<br><span class="strong">void srand(unsigned int seed);</span></p><div class="show"><code>    srand(6);    printf("%d\n", rand());//58    printf("%d\n", rand());//6673    printf("%d\n", rand());//30119    printf("%d\n", rand());//15745    printf("%d\n", rand());//5206</code></div><p>如果将种子值设为当前时间，由于时间是每时每刻都不一样的，此时就可以真正生成一个随机数，C语言提供了获取当前时间戳的函数：<br><span class="strong">time_t time(time_t *timer);</span></p><p>该函数会当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，其返回值类型为time_t(但本质上为64位整型)，在用作生成随机数时，传入的参数一般为空指针NULL(或0)</p><div class="show"><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main()&#123;   <span class="text-red">srand((unsigned int)time(NULL));</span>    printf("%d\n", rand());    printf("%d\n", rand());    return 0;&#125;</code></div><p>如果需要指定生成随机数的范围，则还需要一些额外的运算</p><div class="show">以下操作建立在设置了随机数种子的前提下<code>srand((unsigned int)time(NULL));</code>1. 通过取模运算来限制随机数范围<code>int randomNum = rand() % 100;//生成0-99之间的随机整数int randomNum = rand()%100+1;//生成1-100之间的随机整数该语句解析为：int randomNum = rand()%(101-1)+1;//生成1-101(不包括101)之间的整数</code>生成min-max(不包括max)之间的随机整数<span class="text-blue">rand()%(max-min)+min</span>2. 将随机整数除以RAND_MAX宏常量来获取随机小数：stdlib.h定义了rand()函数能返回伪随机数的最大值RAND_MAX，其值一般为32767，我们将获得的随机整数除以该常量值，就获得了一个0.0-1.0之间的随机小数<code>double random_double = (double)rand()/(double)RAND_MAX;</code>类似地可以限定该随机小数的范围为a-b：<span class="text-blue">(double)rand() / RAND_MAX * (b - a) + a;</span></div><h3 id="常用函数和头文件"><a href="#常用函数和头文件" class="headerlink" title="常用函数和头文件"></a>常用函数和头文件</h3><p>列出了一些常用的函数及其头文件，这些头文件中还有很多其他函数，可以参考文档：<a href="https://cplusplus.com/reference/">https://cplusplus.com/reference/</a>，里面罗列了很多C语言和C++的头文件和函数，二者文件名和函数形参可能有所不同但能类似套用</p><h4 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h4><p>以下是对部分字符的定义</p><div class="table"><table><thead><tr><th>字符类</th><th>说明</th></tr></thead><tbody><tr><td>标点符号字符</td><td>!@”#$%^&amp;’(),*+-./:&lt;=&gt;;[]\_{</td></tr><tr><td>图形字符</td><td>包括字母、数字、标点符号</td></tr><tr><td>空白字符</td><td>空格符、水平制表符\t、换行符\n、垂直制表符\v、换页符\f、回车符\r</td></tr><tr><td>控制字符</td><td>在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）</td></tr><tr><td>可打印字符</td><td>包括字母、数字、标点符号和空格字符</td></tr></tbody></table></div><p>以下函数用于测试和映射字符，需要包含字符串<span class="text-red">&lt;ctype.h&gt;</span>，除了最后的大小写转换函数，其余函数如果参数 c 满足描述的条件，则这些函数返回非零值(true)，一般返回值为1，否则返回零(false)</p><div class="table"><table><thead><tr><th>函数名</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>isalnum</td><td>int isalnum(int c)</td><td>检查字符c是否是字母和数字</td></tr><tr><td>isalpha</td><td>int isalpha(int c)</td><td>检查字符c是否是字母</td></tr><tr><td>iscntrl</td><td>int iscntrl(int c)</td><td>检查字符c是否是控制字符</td></tr><tr><td>isprint</td><td>int isprint(int c)</td><td>检查字符c是否是可打印的</td></tr><tr><td>isdigit</td><td>int isdigit(int c)</td><td>检查字符c是否是十进制数字</td></tr><tr><td>isxdigit</td><td>int isxdigit(int c)</td><td>检查字符c是否是十六进制数字</td></tr><tr><td>isgraph</td><td>int isgraph(int c)</td><td>检查字符c是否有图形表示法，有图形表示法的字符是指除了空白字符以外的所有可打印的字符</td></tr><tr><td>islower</td><td>int islower(int c)</td><td>检查字符c是否是小写字母</td></tr><tr><td>isupper</td><td>int isupper(int c)</td><td>检查字符c是否是大写字母</td></tr><tr><td>ispunct</td><td>int ispunct(int c)</td><td>检查字符c是否是标点符号字符</td></tr><tr><td>isspace</td><td>int isspace(int c)</td><td>检查字符c是否是空白字符</td></tr><tr><td>tolower</td><td>int tolower(int c)</td><td>把给定的字符c转换为小写字母，如果已经是小写字母则c不变</td></tr><tr><td>toupper</td><td>int toupper(int c)</td><td>把给定的字符c转换为大写字母，如果已经是大写字母则c不变</td></tr></tbody></table></div><p>以下函数用于处理字符串，需要包含头文件<span class="text-red">&lt;string.h&gt;</span></p><div class="table"><table><thead><tr><th>函数名</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>strlen</td><td>unsigned int strlen( const char *str);</td><td>返回字符串str中实际字符的个数(不包括终止符’\0’)</td></tr><tr><td>strcat</td><td>char *strcat(char *str1,const char *str2)</td><td>把字符串str2拼接到str1后面,并在拼接好的str1串末尾添加一个’\0’,原str1末尾的’\0’将被覆盖。因无边界检查,调用时应保证str1的空间足够大,能存放原始str1和str2两个串的内容。函数返回指向str1的指针</td></tr><tr><td>strncat</td><td>char * strncat( char * strl, constchar * str2, unsigned int count);</td><td>把字符串str2中不多于count个字符拼接到str1后面,并添加\0’,原str1末尾的’\0’将覆盖，函数指向返回str1的指针</td></tr><tr><td>strcpy</td><td>char * strcpy( char * strl, constchar *str2);</td><td>把str2指向的字符串复制到str1中，str2必须是终止符为’\0’的字符串指针，函数返回指向str1的指针</td></tr><tr><td>strncpy</td><td>char *strncpy(char * strl, constchar *str2,unsigned int count);</td><td>把str2指向的字符串中的count个字符复制到st1中，str2必须是终止符为’\0’的字符串指针。如果str2指向的字符串少于 count个字符，则将’\0’加到str1的尾部,直到满足coun个字符为止。如果str2指向的字符串长度大于count个字符，则结果串str1不用’\0’结尾，函数返回指向strl的指针</td></tr><tr><td>strcmp</td><td>int strcmp(const char * strl,const char * str2);</td><td>按字典顺序比较两个字符串str1和str2。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数</td></tr><tr><td>strcnmp</td><td>int strcnmp( const char * strl,const char*str2,unsigned intcount);</td><td>按字典顺序比较两个字符串str1和str2的不多于count个字符。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数</td></tr><tr><td>strtr</td><td>char * strstr(char * strl, char *str2);</td><td>找出str2字符串在str1字符串中第一次出现的位置(不包括str2的串结束符)。函数返回该位置的指针。若找不到则返回空指针</td></tr></tbody></table></div><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>使用以下函数，源文件需要包含<span class="tips">&lt;math.h&gt;</span>头文件，以下函数这里只写出了返回值和形参为double类型的函数原型，它们中的绝大多数还有一个返回值和形参为float或long double类型的函数原型，因此可以类似地套用</p><div class="table"><table><thead><tr><th>函数名</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>fabs</td><td>double fabs( double x);</td><td>计算x的绝对值，返回浮点数</td></tr><tr><td>abs</td><td>double abs (double x);</td><td>在c++中该函数声明于cmath头文件，可以用于计算double、float、long double的绝对值，在c语言中声明于stdlib.h文件，用于计算int的绝对值</td></tr><tr><td>ceil</td><td>double ceil (double x);</td><td>向上取整</td></tr><tr><td>floor</td><td>double floor( double x);</td><td>向下取整，计算不大于x的最大整数</td></tr><tr><td>round</td><td>double round  (double x);</td><td>四舍五入取整</td></tr><tr><td>pow</td><td>double pow( double base, doubleexp);</td><td>返回base为底的exp次幂,即base<sup>exp</sup>,返回计算结果。当base等于0而exp小于0时或者base小于0而exp不为整数时,出现结果错误。该函数要求参数base和exp以及函数的返回值为double类型,否则有可能出现数值溢出问题</td></tr><tr><td>sqrt</td><td>double sqrt(double x)</td><td>计算√x(根号下x)的值，注意x&gt;=0</td></tr><tr><td>exp</td><td>double exp( double x);</td><td>计算e<sup>x</sup>的值</td></tr><tr><td>fmod</td><td>double fmod ( double x, double y);</td><td>计算整除x/y的余数</td></tr><tr><td>log</td><td>double log( double x );</td><td>计算log<sub>e</sub>x,即lnx,返回计算结果。注意,x&gt;0</td></tr><tr><td>log10</td><td>double log10( double x);</td><td>计算 log<sub>10</sub>x,返回计算结果。注意,x&gt;0</td></tr><tr><td>sin</td><td>double sin(double x)</td><td>计算sinx的值，x为弧度值</td></tr><tr><td>cos</td><td>double cos(double x)</td><td>计算cos(x)的值，x为弧度值</td></tr><tr><td>tan</td><td>double tan(double x);</td><td>计算tanx的值</td></tr><tr><td>asin</td><td>double asin(double x)</td><td>计算cos<sup>-1</sup>(x)的值，注意，x应为-1到1范围</td></tr><tr><td>acos</td><td>double acos(double x)</td><td>计算sin<sup>-1</sup>(x)的值，注意，x应为-1到1范围</td></tr><tr><td>atan</td><td>double atan(double x)</td><td>计算tan<sup>-1</sup>(x)的值</td></tr><tr><td>atan2</td><td>double atan2(double x,double y)</td><td>计算tan<sup>-1</sup>(x/y)的值</td></tr><tr><td>sinh</td><td>double sinh(double x)</td><td>计算x的双曲正弦函数sinh(x)的值</td></tr><tr><td>cosh</td><td>double cosh(double x)</td><td>计算x的双曲余弦 cosh(x)的值</td></tr><tr><td>tanh</td><td>double tanh(double x)</td><td>计算x的双曲正切函数tanh(x)的值</td></tr><tr><td>frexp</td><td>double frexp(double val,int*eptr);</td><td>把双精度数val分解为小数部分(尾数)x和以2为底的指数n(阶码),即val=x*2 <sup>n</sup>,n存放在eptr指向的变量中,函数返回小数部分x,0.5≤x&lt;1</td></tr><tr><td>modf</td><td>double modf( double val, double *iptr);</td><td>把双精度数val分解为整数部分和小数部分,把整数部分存到iptr指向的单元。返回val的小数部分</td></tr></tbody></table></div><h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><div class="table"><table><thead><tr><th>函数名</th><th>头文件</th><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>atof</td><td>stdlib.h</td><td>double atof(const char * str);</td><td>把str指向的字符串转换成双精度浮点值,串中必须含合法的浮点数,否则返回值无定义。函数返回转换后的双精度浮点值</td></tr><tr><td>atoi</td><td>stdlib.h</td><td>int atoi(const char *str);</td><td>把str指向的字符串转换成整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的整型值</td></tr><tr><td>alol</td><td>stdlib.h</td><td>long int atol(const char * str);</td><td>把str指向的字符串转换成长整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的长整型值</td></tr><tr><td>exit</td><td>stdlib.h</td><td>void exit(int code);</td><td>使程序立即终止,清空和关闭任何打开的文件。程序正常退出状态由code等于0或EXITSUCCESS表示，如exit(0)，非0值或EXIT_FAILURE表明定义实现错误。函数无返回值</td></tr><tr><td>rand</td><td>stdlib.h</td><td>int rand(void);</td><td>产生伪随机数序列。函数返回0到RAND_MAX之间的随机整数,RAND_MAX至少是32767</td></tr><tr><td>srand</td><td>stdlib.h</td><td>void srand(unsigned int seed );</td><td>为函数rand()生成的伪随机数序列设置起点种子值，函数无返回值</td></tr><tr><td>time</td><td>time.h</td><td>time_t time(time_t *timer)</td><td>如果传入的参数为空指针NULL，则该函数返回当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，返回值类型为time_t(但本质上为64位整型)。如果参数为time_t类型指针变量timer，则该时间差值也将放于timer所指向的内存中</td></tr><tr><td>clock</td><td>time.h</td><td>clock_t clock(void);</td><td>clock_t是long类型，该函数返回硬件的时钟节拍数，需要换成秒或者毫秒，通常需要除以CLK_TCK或者CLOCKS_PER_SEC。例如,在VC6.0下,这两个量的值都是1000,表示硬件1秒钟的时钟节拍数为1000，该函数常用于测量从程序开始运行到clock()被调用时所消耗的时间，或用于实现计时器功能，如：计算一个进程的时间需要用clock()除以1000。注意:本函数仅能返回ms级的计时精度</td></tr><tr><td>Sleep</td><td>stdlih.h</td><td>Sleep(unsigned long second);</td><td>在标准C中和Linux下是函数的首字母不大写。但在VC和Code::blocks环境下首字母要大写。Sleep()函数的功能是将进程挂起一段时间,即起到延时的作用。参数的单是毫秒</td></tr><tr><td>system</td><td>stdlib.h</td><td>int system(char * command);</td><td>发出一个DOS命令。例如,system(“CLS”)可以实现清屏操作</td></tr><tr><td>kbhit</td><td>conio.h</td><td>int kbhit(void);</td><td>检查当前是否有键盘输人,若有则返回一个非0值,否则回 0</td></tr><tr><td>getch</td><td>conio.h</td><td>int getch(void);</td><td>无需用户按回车键即可得到入户输入，只要用户按下一个键，立刻返回用户输入字符的ASCII码值，但输入的字符不会显示在屏幕上，出错时返回-1，该函数在游戏中比较常用</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">写C语言没有对象，我学Java去了</summary>
    
    
    
    
    <category term="C" scheme="https://shiwei11.github.io/blog/tags/C/"/>
    
    <category term="note" scheme="https://shiwei11.github.io/blog/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的各种尺寸</title>
    <link href="https://shiwei11.github.io/blog/2023/09/07/JavaScript%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B0%BA%E5%AF%B8/"/>
    <id>https://shiwei11.github.io/blog/2023/09/07/JavaScript%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B0%BA%E5%AF%B8/</id>
    <published>2023-09-06T16:35:30.000Z</published>
    <updated>2023-10-15T15:53:11.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局尺寸"><a href="#全局尺寸" class="headerlink" title="全局尺寸"></a>全局尺寸</h3><h4 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h4><ul><li><span class="strong">window.screen.height</span>返回整个屏幕的高度</li><li><span class="strong">window.screen.width</span>返回整个屏幕的宽度</li><li><span class="strong">window.screen.availHeight</span>返回屏幕可用高度(去掉任务栏高度)</li><li><span class="strong">window.screen.availWidth</span>返回屏幕可用宽度(去掉任务栏宽度)</li><li><span class="strong">window.screenTop/window.sceenY</span>返回浏览器左边界到屏幕左边缘的距离</li><li><span class="strong">window.screenLeft/window.screenX</span>返回浏览器的上边界到屏幕上边缘的距离</li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>availHeight和availWidth主要用于PC端，一般情况下，任务栏位于屏幕底部占用了屏幕高度，所以window.screen.availHeight的值是window.screen.height减去任务栏高度后得出的值，如果任务栏隐藏，screen.availHeight的值将等于screen.height。同理，当任务栏在屏幕左侧或右侧时，可以用availWidth获得当前屏幕可用宽度。</div><h4 id="浏览器尺寸"><a href="#浏览器尺寸" class="headerlink" title="浏览器尺寸"></a>浏览器尺寸</h4><ul><li><span class="strong">window.outerHeight</span>返回整个浏览器窗口的高度，包括地址栏、标签栏、收藏栏和显示网页的布局视口高度</li><li><span class="strong">window.outerWidth</span>返回整个浏览器窗口的宽度</li><li><span class="strong">window.innerHeight</span>返回浏览器显示网页用的布局视口(layout viewport)高度，包含滚动条(如果有)，不包含地址栏、标签栏、收藏栏的高度</li><li><span class="strong">window.innerWidth</span>返回浏览器视口宽度，包含滚动条(如果有)</li></ul><p>任何窗口对象window、frame、frameset都支持window.innerHeight属性，outerHeight和innerHeight区别如下(图片来源于MDN文档)</p><img data-src="/blog/images/innervsouterheight.png" src="#" alt="innerHeight"><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>在Android端浏览器中，上述4个属性的返回值可能不可靠，如可能出现innerHeight值大于outerHeight等情况，不同Android系统版本返回值不同，因此在移动端中请慎用，Stack Overflow上有一篇讨论这一问题的帖子：<a href="https://stackoverflow.com/questions/10610743/android-browsers-screen-width-screen-height-window-innerwidth-window-inner" target="_blank">Android browser's screen.width, screen.height & window.innerWidth & window.innerHeight are unreliable</a></div><h4 id="鼠标位置"><a href="#鼠标位置" class="headerlink" title="鼠标位置"></a>鼠标位置</h4><p>鼠标事件触发时，与鼠标位置有关的坐标</p><ul><li><span class="strong">event.screenY</span>返回触发事件时，鼠标在屏幕中的Y坐标值</li><li><span class="strong">event.screenX</span>返回触发事件时，鼠标在屏幕中的X坐标值</li><li><span class="strong">event.pageY</span>返回触发事件时，鼠标相对于整个document的Y坐标值，其值会受文档滚动影响</li><li><span class="strong">event.pageX</span>返回触发事件时，鼠标相对于整个document的X坐标值，其值会受文档滚动影响</li><li><span class="strong">event.clientY</span>返回触发事件时，鼠标相对于浏览器当前网页视口的Y坐标值，其值不受滚动影响</li><li><span class="strong">event.clientX</span>返回触发事件时，鼠标相对于浏览器当前网页视口的X坐标值，其值不受滚动影响</li><li><span class="strong">event.offsetY</span>返回触发事件时，鼠标相对于事件触发源Dom上边界的Y坐标值，其值会受该Dom滚动的影响</li><li><span class="strong">event.offsetX</span>返回触发事件时，鼠标相对于事件触发源Dom左边界的X坐标值，其值会受该Dom滚动的影响</li><li>event.movementY 返回当前事件和上一个mousemove事件之间，鼠标在竖直方向上的移动值</li><li>event.movementX 返回当前事件和上一个mousemove事件之间，鼠标在水平方向上的移动值</li><li>event.x 即event.clientX的别名，实验性属性，兼容性较差</li><li>event.y 即event.clientY的别名，实验性属性，兼容性较差</li></ul><p><canvas width="300" height="400" id="canvasMouseEvent"        style="display:block;width:300px;height:400px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>        const canvasMouseEvent = document.getElementById('canvasMouseEvent');        const ctxME = canvasMouseEvent.getContext('2d');        ctxME.beginPath();        ctxME.lineWidth = 2;        ctxME.strokeRect(10, 150, 280, 200);        ctxME.lineWidth = 1;        ctxME.strokeRect(60, 200, 180, 100);        ctxME.arc(160,250,3,0,Math.PI*2);        ctxME.stroke();        ctxME.closePath();        ctxME.beginPath();        ctxME.lineWidth = 1;        ctxME.strokeStyle = "#f00";        ctxME.moveTo(160, 200);        ctxME.lineTo(160, 250);        ctxME.moveTo(155, 205);        ctxME.lineTo(160, 200);        ctxME.lineTo(165, 205);        ctxME.moveTo(160, 250);        ctxME.lineTo(60, 250);        ctxME.moveTo(65, 255);        ctxME.lineTo(60, 250);        ctxME.lineTo(65, 245);        ctxME.font = "16px Serif";        ctxME.fillStyle = "#f00";        ctxME.fillText('offsetY', 160, 230)        ctxME.fillText('offsetX', 80, 245)        ctxME.stroke();        ctxME.closePath();        ctxME.beginPath();        ctxME.strokeStyle = "#00f";        ctxME.moveTo(190, 10);        ctxME.lineTo(190, 250);        ctxME.moveTo(185, 25);        ctxME.lineTo(190, 10);        ctxME.lineTo(195, 25);        ctxME.moveTo(10, 280);        ctxME.lineTo(160, 280);        ctxME.moveTo(20, 275);        ctxME.lineTo(10, 280);        ctxME.lineTo(20, 285);        ctxME.fillStyle = "#00f";        ctxME.fillText('pageY', 200, 80)        ctxME.fillText('pageX', 80, 295)        ctxME.stroke();        ctxME.closePath();        ctxME.beginPath();        ctxME.strokeStyle = "#05fe05";        ctxME.moveTo(170, 152);        ctxME.lineTo(170, 250);        ctxME.moveTo(165, 167);        ctxME.lineTo(170, 152);        ctxME.lineTo(175, 167);        ctxME.moveTo(10, 260);        ctxME.lineTo(160, 260);        ctxME.moveTo(25, 265);        ctxME.lineTo(10, 260);        ctxME.lineTo(25, 255);        ctxME.stroke();        ctxME.font = "16px Serif";        ctxME.fillStyle = "#05fe05";        ctxME.fillText('clientY', 170, 190);        ctxME.fillText('clientX', 70, 275);        ctxME.closePath();        ctxME.fillStyle = "#000";        ctxME.fillText('浏览器可视区', 15, 170)        ctxME.fillText('document溢出部分', 15, 30)        ctxME.fillText('dom', 65, 215)        ctxME.fillText('鼠标事件', 165, 265)        ctxME.beginPath();        ctxME.strokeStyle = "#000";        ctxME.setLineDash([10, 5]);        ctxME.strokeRect(10, 10, 280, 380);        ctxME.closePath();</script><div class="show">pageY、pageX、offsetY、offsetX的值会受到文档/Dom滚动的影响，即在鼠标位置不变的情况下，文档和Dom滚动前后，鼠标事件触发获得的返回值不一样，因为鼠标相对于整个文档/Dom的位置改变了。而clientX、clientY的返回值始终是以当前网页视口左上角为基准进行计算的，与文档、Dom滚动无关box.addEventListener('click',e=>{            e.stopPropagation();            console.log('offsetX:'+e.offsetX+'px;\noffsetY:'+e.offsetY+'px;\n');            console.log('pageX:'+e.pageX+'px;\npageY'+e.pageY+'px;\n');        })</div><h3 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h3><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><ul><li><span class="strong">Element.clientHeight</span>元素内部的高度，包含padding值，但不包含border，margin和滚动条带来的高度</li><li><span class="strong">Element.clientWidth</span>元素内部的宽度，同上</li><li><span class="strong">Element.clientTop</span>返回元素顶部边框的宽度，即border–top-width的值，表示元素内容(content)到元素顶部的距离</li><li><span class="strong">Element.clientLeft</span>返回元素左边框的宽度，即border-left-width的值，表示元素内容到元素左侧的距离。如果元素左边有垂直滚动条，则该属性包括滚动条的宽度</li></ul><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><ul><li><span class="strong">Element.offsetHeight</span>元素高度，包含padding，border和滚动条，不包含:before 或:after 等伪类元素的高度</li><li><span class="strong">Element.offsetWidth</span>元素的宽度，同上</li><li><span class="strong">Element.offsetTop</span>返回当前元素相对于最近的祖先定位元素的顶部距离，一般是top值+子元素的margin-top值</li><li><span class="strong">Element.offsetLeft</span>返回当前元素相对于最近的祖先定位元素的左侧距离，一般是left值+子元素的margin-left值</li></ul><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><ul><li><p><span class="strong">Element.scrollHeight</span> 返回包括溢出部分的元素高度，包括padding值、伪元素的高度，但不包括border、margin和滚动条的值，如果元素不溢出，则该值等于clientHeight</p></li><li><p><span class="strong">Element.scrollWidth</span>返回包括溢出部分的元素宽度，内容同上</p></li><li><p><span class="strong">Element.scrollTop</span>可以设置和获取，代表元素的内容顶部到它的视口可见内容顶部的距离</p></li><li><p><span class="strong">Element.scrollTop</span>可以设置和获取，代表元素的内容左边界到它的视口可见内容左边界的距离</p></li></ul><p><canvas width="300" height="500" id="canvasScroll" style="display:block;width:300px;height:500px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>      const canvasScroll = document.getElementById('canvasScroll');        const ctxScroll = canvasScroll.getContext('2d');        ctxScroll.beginPath();        ctxScroll.lineWidth = 5;        ctxScroll.strokeRect(10, 150, 280, 200);        ctxScroll.closePath();        ctxScroll.beginPath();        ctxScroll.lineWidth = 1;        ctxScroll.strokeStyle = "#f00";        ctxScroll.moveTo(40, 10);        ctxScroll.lineTo(40, 490);        ctxScroll.moveTo(35, 25);        ctxScroll.lineTo(40, 10);        ctxScroll.lineTo(45, 25);        ctxScroll.moveTo(35, 475);        ctxScroll.lineTo(40, 490);        ctxScroll.lineTo(45, 475);        ctxScroll.font = "20px Serif";        ctxScroll.fillStyle = "#f00";        ctxScroll.fillText('scrollHeight', 40, 250)        ctxScroll.stroke();        ctxScroll.closePath();        ctxScroll.beginPath();        ctxScroll.strokeStyle = "#00f";        ctxScroll.moveTo(190, 10);        ctxScroll.lineTo(190, 150);        ctxScroll.moveTo(185, 25);        ctxScroll.lineTo(190, 10);        ctxScroll.lineTo(195, 25);        ctxScroll.moveTo(185, 135);        ctxScroll.lineTo(190, 150);        ctxScroll.lineTo(195, 135);        ctxScroll.fillStyle = "#00f";        ctxScroll.fillText('scrollTop', 190, 80)        ctxScroll.stroke();        ctxScroll.closePath();        ctxScroll.beginPath();        ctxScroll.strokeStyle = "#05fe05";        ctxScroll.moveTo(170, 152);        ctxScroll.lineTo(170, 348);        ctxScroll.moveTo(165, 167);        ctxScroll.lineTo(170, 152);        ctxScroll.lineTo(175, 167);        ctxScroll.moveTo(165, 333);        ctxScroll.lineTo(170, 348);        ctxScroll.lineTo(175, 333);        ctxScroll.stroke();        ctxScroll.font = "20px Serif";        ctxScroll.fillStyle = "#05fe05";        ctxScroll.fillText('clientHeight', 170, 250)        ctxScroll.closePath();        ctxScroll.fillStyle = "#000";        ctxScroll.fillText('元素显示部分', 45, 180)        ctxScroll.fillText('元素溢出部分', 45, 30)        ctxScroll.beginPath();        ctxScroll.strokeStyle = "#000";        ctxScroll.setLineDash([10, 5]);        ctxScroll.strokeRect(20, 10, 260, 480);        ctxScroll.closePath();</script><div class="show">判断元素是否已经滚到底部，以及判定用户是否已经阅读完文本的解决方案：判断是否满足scrollHeight-scrollTop=clientHeight，由于scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的整数，因此判断三个值的差值小于某个阈值即可Math.abs(ele.scrollHeight - ele.clientHeight - ele.scrollTop)&lt;3</div><h3 id="DOMRect对象"><a href="#DOMRect对象" class="headerlink" title="DOMRect对象"></a>DOMRect对象</h3><p>上述属性返回值一般为四舍五入的整数值，通过DOMRect对象可以获得更为精确的浮点数坐标值</p><h4 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h4><p>该方法会返回一个DOMRect对象，该对象提供了几个描述该Dom位置和大小的属性，这些属性都是基于网页可视窗口的左上角作为坐标原点进行计算的</p><ul><li><span class="strong">width</span>返回Dom的宽度，包含padding值和border-width值</li><li><span class="strong">height</span>返回Dom的高度，包含padding值和border-width值</li><li><span class="strong">x/left</span>返回Dom左边界到网页可视窗口左边界的距离</li><li><span class="strong">y/top</span>返回Dom上边界到网页可视窗口上边界的距离</li><li><span class="strong">right</span>返回Dom右边界到网页可视窗口左边界的距离</li><li><span class="strong">bottom</span>返回Dom下边界到网页可视窗口左边界的距离</li></ul><p><canvas width="300" height="300" id="canvasDomRect"        style="display:block;width:300px;height:300px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>        const canvasDomRect = document.getElementById('canvasDomRect');        const ctxDR = canvasDomRect.getContext('2d');        ctxDR.beginPath();        ctxDR.lineWidth = 2;        ctxDR.strokeRect(10, 10, 280, 280);        ctxDR.lineWidth = 1;        ctxDR.strokeRect(70, 70, 150, 150);        ctxDR.stroke();        ctxDR.closePath();        ctxDR.beginPath();        ctxDR.font = "16px Serif";        ctxDR.strokeStyle = "#f00";        ctxDR.moveTo(70,200);        ctxDR.lineTo(220,200);        ctxDR.moveTo(85,195);        ctxDR.lineTo(70,200);        ctxDR.lineTo(85,205);        ctxDR.moveTo(205,195);        ctxDR.lineTo(220,200);        ctxDR.lineTo(205,205);        ctxDR.fillStyle = "#f00";        ctxDR.fillText('width', 130, 190)        ctxDR.fillText('height', 165, 150);        ctxDR.moveTo(200,70);        ctxDR.lineTo(200,220);        ctxDR.moveTo(195,85);        ctxDR.lineTo(200,70);        ctxDR.lineTo(205,85);        ctxDR.moveTo(195,205);        ctxDR.lineTo(200,220);        ctxDR.lineTo(205,205);        ctxDR.stroke();        ctxDR.closePath();        ctxDR.beginPath();        ctxDR.strokeStyle = "#00f";        ctxDR.moveTo(100, 10);        ctxDR.lineTo(100, 70);        ctxDR.moveTo(95, 25);        ctxDR.lineTo(100, 10);        ctxDR.lineTo(105, 25);        ctxDR.moveTo(10, 100);        ctxDR.lineTo(70, 100);        ctxDR.moveTo(25, 95);        ctxDR.lineTo(10, 100);        ctxDR.lineTo(25, 105);        ctxDR.fillStyle = "#00f";        ctxDR.fillText('y/top', 110, 45)        ctxDR.fillText('x/left', 15, 90)        ctxDR.stroke();        ctxDR.closePath();        ctxDR.beginPath();        ctxDR.strokeStyle = "#05fe05";        ctxDR.moveTo(240, 10);        ctxDR.lineTo(240, 220);        ctxDR.moveTo(235, 25);        ctxDR.lineTo(240, 10);        ctxDR.lineTo(245, 25);        ctxDR.moveTo(10, 240);        ctxDR.lineTo(220, 240);        ctxDR.moveTo(25, 245);        ctxDR.lineTo(10, 240);        ctxDR.lineTo(25, 235);        ctxDR.stroke();        ctxDR.setLineDash([5,2]);        ctxDR.moveTo(260,220);        ctxDR.lineTo(220, 220);        ctxDR.lineTo(220, 260);        ctxDR.stroke();        ctxDR.fillStyle = "#05fe05";        ctxDR.fillText('bottom', 230, 140);        ctxDR.fillText('right', 100, 255);        ctxDR.closePath();        ctxDR.fillStyle = "#000";        ctxDR.fillText('viewPort', 15, 30);        ctxDR.fillText('Element', 125, 85);    </script><div class="show">使用前，使用css清除浏览器默认的padding和margin值，避免浏览器默认值带来的影响*{            margin: 0;            padding: 0;        }但返回值还是会有一些底层渲染和二进制转化带来的误差  const box=document.querySelector('.box');  const boxRect=box.getBoundingClientRect();  console.log(boxRect.width);//eg: 309.6000061035156  console.log(boxRect.left);</div>]]></content>
    
    
    <summary type="html">整理了javaScript中经常用到的计算各种尺寸的API，包括计算屏幕尺寸、浏览器尺寸、鼠标位置、DOM位置和DOMRect对象的常用API</summary>
    
    
    
    
    <category term="javaScript" scheme="https://shiwei11.github.io/blog/tags/javaScript/"/>
    
    <category term="html" scheme="https://shiwei11.github.io/blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>xml</title>
    <link href="https://shiwei11.github.io/blog/2023/05/25/xml/"/>
    <id>https://shiwei11.github.io/blog/2023/05/25/xml/</id>
    <published>2023-05-25T07:27:27.000Z</published>
    <updated>2023-11-06T20:06:18.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>XML 指可扩展标记语言(EXtensible Markup Language)，其文件以<span class="tips">.xml</span>为后缀名，主要用于数据存储、数据传输、编写配置文件，语法格式与HTML相似，二者主要差异有：</p><ul><li>XML标签没有被预定义，需要自行定义标签；HTML虽然支持自定义标签，但主要使用预定义标签</li><li>XML主要用于传输和存储数据，HTML主要用于显示数据</li><li>XML语法要求比HTML严格</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>xml文档基本由以下模块组成</p><ul><li>标签(元素)：文档主要部分，将被解析为XML DOM</li><li>标签属性：提供关于标签的信息</li><li>转义字符(实体)：XML中预用字符的实体引用</li><li>PCDATA(Parsed Character Data)：需要由解析器解析的文本</li><li>CDATA(Character Data)：解析器不会解析的文本，内容将视为字符串</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="xml标签定义规范"><a href="#xml标签定义规范" class="headerlink" title="xml标签定义规范"></a>xml标签定义规范</h4><p>xml中的标签需要自定义，标签名需要遵循以下规范</p><ul><li>可以包含字母、数字和其他符号，包括连字符(-)、下划线(_)和点号(.)</li><li>不能以数字或者标点符号开始</li><li>不能以xml、 XML、Xml开始</li><li>不能包含空格</li><li>尽量避免使用<span class="tips">-</span>和<span class="tips">.</span>字符，该类字符在某些XML解析器中中可能会被错误解析</li><li>避免使用<span class="tips">:</span>，该字符用于命名空间</li></ul><h4 id="xml基本语法格式"><a href="#xml基本语法格式" class="headerlink" title="xml基本语法格式"></a>xml基本语法格式</h4><div class="code">&lt;?xml version="1.0" encoding="utf-8"?>&lt;web> &lt;author>SHIWIVI&lt;/author>&lt;license>CC BY-NC&lt;/license>&lt;heading>&lt;type>Document&lt;/type>&lt;/heading>&lt;body>Meet you like the wind&lt;/body>&lt;/web></div><ul><li>首行进行xml文档声明，version属性定义版本，encoding声明编码格式</li><li>必须包含一个根标签，标签名自定义</li><li>XML标签大小写敏感</li><li>所有XML标签都必须闭合，自闭合标签禁止省略<span class="tips strong">/</span></li><li>XML的属性值须加引号，即便属性值是数值，单双引号均可用</li><li>XML标签禁止交叉嵌套</li><li>XML中多个连续空格也会被保留，HTML中会被合并</li><li>XML 以 LF 存储换行</li></ul><div class="show">xml正确嵌套：&lt;a>&lt;b>content&lt;/b>&lt;/a>严禁交叉嵌套：&lt;a>&lt;b>content&lt;/a>&lt;/b></div><h5 id="空标签"><a href="#空标签" class="headerlink" title="空标签"></a>空标签</h5><p>xml允许空标签，即标签中无内容</p><div class="show">&lt;element>&lt;/element>空标签可以使用自闭合，但禁止省略 /&lt;element /></div><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>以下字符在XML中被预定义，使用时需要转义</p><div class="table"><table><thead><tr><th>字符</th><th>转义</th><th>字符</th><th>转义</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp;lt;</td><td>&apos;</td><td>&amp;apos;</td></tr><tr><td>&gt;</td><td>&amp;gt;</td><td>&quot;</td><td>&amp;quot;</td></tr><tr><td>&amp;</td><td>&amp;amp;</td><td></td><td></td></tr></tbody></table></div><h4 id="CDATA字符数据"><a href="#CDATA字符数据" class="headerlink" title="CDATA字符数据"></a>CDATA字符数据</h4><p>CDATA(character data)指不被xml解析器解析的文本数据，当文档中出现需要大量转义的字符时，可以直接使用CDATA进行引用，这样，这些字符将不会被xml解析器解析，</p><p>CDATA 部分由<span class="strong tips">&lt;![CDATA[</span>开始，<span class="strong tips">]]&gt;</span>结束</p><div class="show">&lt;root>&lt;title>标题&lt;/title>&lt;![CDATA[    if(a&lt;b&&b&lt;c){    ....        }    ]]&gt;&lt;/root></div><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>由于xml中标签是自定义的，多个xml文档同时使用可能出现标签名相同导致命名冲突的情况，此时需要使用命名空间来解决标签名冲突问题</p><div class="show">&lt;person>&lt;name>周杰伦&lt;/name>&lt;song>米兰的小铁匠&lt;/song>&lt;/person></div><div class="show">&lt;person>&lt;name>东野圭吾&lt;/name>&lt;writing>解忧杂货店&lt;/writing>&lt;/person></div><h4 id="添加前缀"><a href="#添加前缀" class="headerlink" title="添加前缀"></a>添加前缀</h4><p>在标签名前添加前缀，来定义不同的标签，从而对不同文档的同名标签加以区分</p><div class="show">&lt;j:person>&lt;j:name>周杰伦&lt;/j:name>&lt;j:song>米兰的小铁匠&lt;/j:song>&lt;/j:person>&lt;h:person>&lt;h:name>东野圭吾&lt;/h:name>&lt;h:writing>解忧杂货店&lt;/h:writing>&lt;/h:person></div><h4 id="添加XML-Namespace-xmlns-属性"><a href="#添加XML-Namespace-xmlns-属性" class="headerlink" title="添加XML Namespace(xmlns)属性"></a>添加XML Namespace(xmlns)属性</h4><p>可以在父标签中添加命名空间属性，以此定义一个命名空间，之后带有相同前缀的子标签都将同属于该命名空间<br><span class="strong">xmlns:命名前缀=”namespaceURI”</span></p><div class="show">&lt;j:person xmlns:j="Jay Chou">&lt;j:name>周杰伦&lt;/j:name>&lt;j:song>米兰的小铁匠&lt;/j:song>&lt;/j:person>&lt;h:person xmlns:h="Higashino Keigo">&lt;h:name>东野圭吾&lt;/h:name>&lt;h:writing>解忧杂货店&lt;/h:writing>&lt;/h:person></div><h4 id="使用默认的命名空间"><a href="#使用默认的命名空间" class="headerlink" title="使用默认的命名空间"></a>使用默认的命名空间</h4><p>当父元素定义默认的命名空间时，我们可以省略子元素中的前缀<br><span class="strong">xmlns=”namespaceURI”</span></p><div class="show">&lt;person xmlns="Jay Chou">&lt;name>周杰伦&lt;/name>&lt;song>米兰的小铁匠&lt;/song>&lt;/person>&lt;person xmlns="Higashino Keigo">&lt;name>东野圭吾&lt;/name>&lt;writing>解忧杂货店&lt;/writing>&lt;/person></div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>URI指统一资源标识符(Uniform Resource Identifier)，用于标识因特网资源，最常用的 URI 是用来标示因特网域名地址的统一资源定位器(URL)，另一个不那么常用的 URI 是统一资源命名(URN)，在使用命名空间时，很多xml文档会将名称写为一个链接形式，但该链接仅作为该命名空间的字符串名称，并不是要”链接”到某个地址，不会引入任何资源</div><h3 id="DTD验证"><a href="#DTD验证" class="headerlink" title="DTD验证"></a>DTD验证</h3><p>DTD(Document Type Definition):文档类型定义，是一套为了进行程序间的数据交换而建立的关于标记符的语法规则</p><p>xml的标签是可以自由定义的，每个人写的xml将完全不同。但在一个团队内部，我们往往希望拥有一个统一的文件格式来进行数据交换。此时，我们可以使用DTD来对xml文件进行约束，使用一个标准的 DTD 来交换数据</p><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>使用IntelliJ IDEA写xml文件可以即时校验文档内容是否满足DTD验证</div><h4 id="标签声明"><a href="#标签声明" class="headerlink" title="标签声明"></a>标签声明</h4><p>限制标签内可以写入哪些内容</p><ul><li><span class="strong">&lt;!ELEMENT 标签名 (child1,child2…)&gt; 标签中可以包含的子标签</span><br>父标签中按顺序声明其中可以包含的子标签，子标签必须以相同的顺序出现在xml文档中，并且所有子标签也要声明其中可以写入的内容，子标签可以嵌套地拥有子标签</li><li><span class="strong">&lt;!ELEMENT 标签名 (child1,(child2|child3)…)&gt; 标签中可以包含的子标签并可选</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (#PCDATA)&gt; 标签中仅包含需要解析的字符数据(可以为空)</span></li><li><span class="strong">&lt;!ELEMENT 标签名 EMPTY&gt; 声明为空标签</span></li><li><span class="strong">&lt;!ELEMENT 标签名 ANY&gt; 标签中可包含任何内容 </span></li><li><span class="strong">&lt;!ELEMENT 标签名 (#PCDATA|child1|child2|…)*&gt; 标签中可包含PCDATA数据，也可以包含指定子标签<span class="tips">必须添加*号</span></span></li></ul><h5 id="限制子标签的数量"><a href="#限制子标签的数量" class="headerlink" title="限制子标签的数量"></a>限制子标签的数量</h5><ul><li><span class="strong">&lt;!ELEMENT 标签名 (child)&gt; 子标签必须出现一次，且只能出现一次</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (child+)&gt; 子元素至少出现一次</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (child*)&gt; 子元素出现零次或多次</span></li><li><span class="strong">&lt;!ELEMENT 标签名 (child?)&gt; 子元素出现零次或一次</span></li></ul><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [        &lt;!ELEMENT web (author,license,(body|content))>        &lt;!ELEMENT author     (#PCDATA)>        &lt;!ELEMENT license    (#PCDATA)>        &lt;!ELEMENT heading    (#PCDATA|type)*>        &lt;!ELEMENT type       (#PCDATA)>        &lt;!ELEMENT body       (#PCDATA)>        &lt;!ELEMENT content    (#PCDATA)>]>&lt;web>     &lt;author>SHIWIVI&lt;/author>    &lt;license>lol&lt;/license>    &lt;heading>&lt;type>Document&lt;/type>&lt;/heading>    &lt;body>Meet you like the wind&lt;/body>&lt;/web>1. !DOCTYPE web -  声明文档的根标签是web2. !ELEMENT web -  声明web元素必须包含元素：author,license标签，body和content标签可二选一3. !ELEMENT author - 声明author标签内容为 "#PCDATA"(其余语句同理)4. !ELEMENT heading  - 声明author标签内容为 "#PCDATA"或type标签，由于标签内容受限，需添加*号表示可出现零次或多次</div><h5 id="声明实体"><a href="#声明实体" class="headerlink" title="声明实体"></a>声明实体</h5><p><span class="strong">&lt;!ENTITY 实体引用名称 “实体实际代表含义”&gt; 定义一个实体</span><br>引用实体需要添加<span class="tips">&amp;</span>和<span class="tips">;</span></p><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [        &lt;!ELEMENT web (author,license)>        &lt;!ELEMENT author (#PCDATA)>        &lt;!ELEMENT license (#PCDATA)>        &lt;!ENTITY sm "shiwivi.com">//实体声明        &lt;!ENTITY license "License CC BY-NC 4.0">        ]>&lt;web>    &lt;author>&amp;sm;&lt;/author>//将解析为&lt;author>shiwivi.com&lt;/author>    &lt;license>&amp;license;&lt;/license>&lt;/web></div><h4 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h4><p>限制标签可添加的属性以及属性值，语法格式为：<br><span class="strong">&lt;!ATTLIST 标签名 属性名 属性类型 属性值&gt;</span></p><div class="table"><table><thead><tr><th>属性类型</th><th>说明</th><th>属性类型</th><th>说明</th></tr></thead><tbody><tr><td>CDATA</td><td>字符</td><td>NMTOKEN</td><td>该值是有效的XML名称</td></tr><tr><td>(v1|v2|..)</td><td>值只能为指定内容(枚举)</td><td>NMTOKENS</td><td>该值是有效XML名称的列表</td></tr><tr><td>ID</td><td>值为唯一ID</td><td>ENTITY</td><td>值是一个实体</td></tr><tr><td>IDREF</td><td>值是另一个元素的id</td><td>ENTITIES</td><td>值是实体列表</td></tr><tr><td>IDREFS</td><td>该值是其他ID的列表</td><td>xml:</td><td>该值是预定义的xml值</td></tr></tbody></table></div><div class="table"><table><thead><tr><th>属性值</th><th>说明</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>字符串</td><td>属性默认值</td><td>#REQUIRED</td><td>属性是必需的</td></tr><tr><td>#IMPLIED</td><td>属性是可选的</td><td>#FIXED 值</td><td>属性值是固定的</td></tr></tbody></table></div><div class="show">1. 限制为test标签添加的属性只能为code，如果开发者不指定属性值，则默认值为java&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [        &lt;!ELEMENT web (test)>        &lt;!ELEMENT test EMPTY>        &lt;!ATTLIST test code "java">//属性声明        ]>&lt;web>    &lt;test code="javaScript"/>&lt;/web>2. 该标签必须添加code属性，并且不指定默认值&lt;!ATTLIST test code CDATA #REQUIRED>3. 该标签不强制要求添加code属性，也不指定默认值&lt;!ATTLIST test code CDATA #IMPLIED>4. 该标签强制拥有code属性并指定属性值为java，且不允许修改&lt;!ATTLIST test code CDATA #FIXED "java"></div><h4 id="DTD文件引入"><a href="#DTD文件引入" class="headerlink" title="DTD文件引入"></a>DTD文件引入</h4><h5 id="内部DTD"><a href="#内部DTD" class="headerlink" title="内部DTD"></a>内部DTD</h5><p>如果DTD被包含在xml文件中，需要被包装于<span class="tips">DOCTYPE</span>声明中<br><span class="strong">&lt;!DOCTYPE 根标签 [标签声明内容]&gt;</span></p><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web [     &lt;!ELEMENT web (author,license)>     &lt;!ELEMENT author (#PCDATA)>     &lt;!ELEMENT license (#PCDATA)>]&gt;&lt;web>     .....&lt;/web></div><h5 id="外部私有DTD"><a href="#外部私有DTD" class="headerlink" title="外部私有DTD"></a>外部私有DTD</h5><p>可以将DTD声明为一个外部文件，然后引用到xml文档中<br><span class="strong">&lt;!DOCTYPE 根标签 SYSTEM “DTD的URL”&gt;</span></p><div class="show">&lt;?xml version="1.0" encoding="utf-8"?>&lt;!DOCTYPE web SYSTEM "./check.dtd">&lt;web>     ....&lt;/web></div><div class="code">&lt;!--check.dtd文件-->&lt;!ELEMENT web (author,license)>     &lt;!ELEMENT author (#PCDATA)>     &lt;!ELEMENT license (#PCDATA)></div><h5 id="外部公用DTD"><a href="#外部公用DTD" class="headerlink" title="外部公用DTD"></a>外部公用DTD</h5><p>也可以使用一些标准化组织或权威机构提供的DTD<br><span class="strong">&lt;!DOCTYPE 根标签 PUBLIC “DTD公共名称” “DTD的URL”&gt;</span></p><p>DTD公共名称格式为：<span class="strong">“是(否)ISO注册//注册组织//DTD所描述的文件的信息//语言”</span></p><ul><li>是否由国际标准化组织(ISO)注册，+表示是，-表示不是</li><li>注册组织或个人</li><li>该DTD所验证文件的描述性信息，经常还会添加版本号</li><li>语言标识，如：ZH为中文，EN为英文<div class="show">lt;!DOCTYPE web PUBLIC "-//shiwivi//blog config//CN" "http://www.shiwivi.com/blog/check.dtd"></div></li></ul>]]></content>
    
    
    <summary type="html">XML文件的语法规则，以及对xml文件进行DTD验证的方法</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="Serve" scheme="https://shiwei11.github.io/blog/tags/Serve/"/>
    
  </entry>
  
  <entry>
    <title>SVG矢量图</title>
    <link href="https://shiwei11.github.io/blog/2023/05/19/SVG%E7%9F%A2%E9%87%8F%E5%9B%BE/"/>
    <id>https://shiwei11.github.io/blog/2023/05/19/SVG%E7%9F%A2%E9%87%8F%E5%9B%BE/</id>
    <published>2023-05-19T08:42:15.000Z</published>
    <updated>2023-10-19T08:12:21.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><span class="strong">SVG</span>(Scalable Vector Graphics)全称为可缩放矢量图形，是一种用 XML 标记语言描述二维矢量图形的技术，它有以下特点：</p><ul><li>使用XML语法文本定义图形，因此SVG图形可以被索引、搜索、选中，很适合制作地图</li><li>SVG提供的是矢量图，可以被无限放大且不会失真，也可以在任何分辨率下被高质量地打印</li><li>SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在HTML中使用SVG，可以直接在文档中直接创建SVG标签，也可以先创建svg文件或者xml文件，再引入到HTML中</p><h4 id="svg文件"><a href="#svg文件" class="headerlink" title="svg文件"></a>svg文件</h4><p>SVG文件通常以<span class="tips">.svg</span>作为文件后缀，使用<span class="tips">gzip</span>压缩的SVG文件以<span class="tips">.svgz</span>为后缀名</p><div class="show">&lt;svg version="1.1"     baseProfile="full"     width="300" height="200"     viewBox="0 0 100 100"     xmlns="http://www.w3.org/2000/svg">&lt;/svg></div><ul><li>version属性用于验证识别SVG版本，SVG 2之后的版本不再推荐使用该属性值</li><li>baseProfile 属性用于描述作者认为正确呈现内容所必需的最小SVG语言配置文件，当用户修改内容超出所指定的基准概述范围时，编辑工具会发出警告，一般可以不指定，即使用默认值none，可取值：<blockquote><ul><li>none(默认)，代表作者无观点，使用最小的 SVG 语言配置</li><li>full(正常)，适用于PC</li><li>basic(轻量级)，适用于平板电脑等PDA</li><li>tiny(更轻量级)，适用于手机</li></ul></blockquote></li><li>width和height属性用于指定画布大小，单位会自行解析为px而无需指定，默认大小为300px*150px</li><li>viewBox属性用于指定显示区域，上述参数解析为仅显示从(0,0)坐标开始，长宽均为100px的矩形区域内的图形</li><li>xmlns属性用于声明命名空间，这里的URL只做该命名空间的字符串名称，并不是要”链接”到某个地址。命名空间用于多个文档声明了相同的标签时，帮助XML内容的使用者区别该标签属于哪一个命名空间</li><li>拥有命名空间后意味着该&lt;svg&gt; 标签和它的子节点都属于该命名空间</li></ul><h5 id="svg写入xml文件"><a href="#svg写入xml文件" class="headerlink" title="svg写入xml文件"></a>svg写入xml文件</h5><div class="show">&lt;?xml version="1.0" ?>&lt;svg version="1.1"     baseProfile="full"     width="300" height="200"     xmlns="http://www.w3.org/2000/svg">     &lt;circle cx="150" cy="100" r="80" fill="green" />&lt;/svg></div><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><h5 id="直接插入-lt-svg-gt-标签"><a href="#直接插入-lt-svg-gt-标签" class="headerlink" title="直接插入&lt;svg&gt;标签"></a>直接插入&lt;svg&gt;标签</h5><p>可以直接在HTML所需位置插入&lt;svg&gt;标签</p><div class="show">&lt;body>     &lt;svg width="400" height="300">          &lt;!--svg内容-->     &lt;/svg>&lt;/body>     </div><h5 id="通过img标签引入"><a href="#通过img标签引入" class="headerlink" title="通过img标签引入"></a>通过img标签引入</h5><p>可以将svg定义为一个单独文件，然后通过img标签引入图片</p><div class="show">&lt;img src="./index.svg" alt="未加载SVG"></div><h5 id="CSS引入"><a href="#CSS引入" class="headerlink" title="CSS引入"></a>CSS引入</h5><p>在CSS样式中将svg作为背景图引入</p><div class="show">.svgPic{         width: 400px;         height: 300px;         background-image: url(./index.svg);         background-repeat: no-repeat;     }</div><h5 id="object标签引入"><a href="#object标签引入" class="headerlink" title="object标签引入"></a>object标签引入</h5><p>object标签可用于包含音视频及图形对象，并且支持<span class="tips">.svg</span>和<span class="tips">.xml</span>格式的文件</p><div class="show">&lt;object data="./index.svg" type="image/svg+xml" width="400" height="300">未加载SVG&lt;/object></div><div class="show">&lt;object data="./index.xml" type="image/svg+xml" width="400" height="300">未加载SVG&lt;/object></div><h5 id="iframe标签引入"><a href="#iframe标签引入" class="headerlink" title="iframe标签引入"></a>iframe标签引入</h5><p>使用内联框架引入svg数据，该标签也同时支持<span class="tips">.svg</span>和<span class="tips">.xml</span>文件</p><div class="show">&lt;iframe src="./index.svg"  width="400" height="300">浏览器不支持iframe标签&lt;/iframe></div><div class="show">&lt;iframe src="./index.xml"  width="400" height="300">浏览器不支持iframe标签&lt;/iframe></div><h3 id="基本图形"><a href="#基本图形" class="headerlink" title="基本图形"></a>基本图形</h3><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p><span class="strong">rect标签</span></p><div class="show">&lt;rect x="10" y="10" rx="20" ry="40" width="200" height="200" >&lt;/rect></div><ul><li>(x,y)为矩形左上角坐标</li><li>width,height为矩形长和高，不能为负值！(与canvas不同)</li><li>rx为矩形与x轴平行的两条边的圆角半径，默认为0</li><li>ry为矩形与y轴平行的两条边的圆角半径，默认为0</li></ul><h4 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h4><p><span class="strong">circle标签</span></p><div class="show">&lt;circle cx="100" cy="100" r="50">&lt;/circle></div><ul><li>(cx,cy)为圆心坐标</li><li>r为圆的半径</li></ul><h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><p><span class="strong">ellipse标签</span></p><div class="show">&lt;ellipse cx="200" cy="200" rx="100" ry="50">&lt;/ellipse></div><ul><li>(cx,cy)为椭圆中心的坐标</li><li>rx为椭圆的 x 半径，ry为椭圆的 y 半径</li></ul><h4 id="线段line"><a href="#线段line" class="headerlink" title="线段line"></a>线段line</h4><div class="show">&lt;line x1="150" y1="300" x2="300" y2="350"stroke="#fff" stroke-width="5">&lt;/line></div><ul><li>(x1,y1)为线段起始坐标</li><li>(x2,y2)为线段终点坐标</li><li>stroke指定线段绘制颜色</li></ul><h4 id="折线polyline"><a href="#折线polyline" class="headerlink" title="折线polyline"></a>折线polyline</h4><div class="show">&lt;polyline points="0 0,10 10,20 0,30 10" style="stroke:#fff;" /></div><ul><li>points属性指定折线折点，每个折点必须指定x,y坐标</li><li>坐标之间可以用空白符、逗号、或者可附带空格的换行符分隔开</li></ul><div class="show">以下写法均可以表示(0,0)、(10,10)、(20,0)、(30,10)四个坐标点，也可以用换行替代points="0 0 10 10 20 0 30 10"points="0 0,10 10,20 0,30 10"points="0,0 10,10 20,0 30,10"</div><h4 id="多边形polygon"><a href="#多边形polygon" class="headerlink" title="多边形polygon"></a>多边形polygon</h4><div class="show">&lt;polygon points="10 10,60 30,120 10" style="stroke:#fff;" /></div><ul><li>points属性与polyline类似</li><li>坐标最后一个点会和第一个点闭合</li></ul><h3 id="path路径"><a href="#path路径" class="headerlink" title="path路径"></a>path路径</h3><p>通过描述路径坐标理论上可绘制任意图形，路径坐标的表示方法与上述points属性坐标表示方法相同，可以用空白符、逗号、或者可附带空格的换行符进行分隔</p><h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><div class="show">&lt;path d="M250 150 L150 350 L350 350 Z" /></div><ul><li>d属性通过”命令+坐标参数”的组合来描述路径</li><li>命令为<span class="tips">大写字母</span>时表示<span class="strong">绝对定位</span>，即相对于svg左上角坐标原点的坐标，命令为<span class="tips">小写字母</span>时表示<span class="strong">相对定位</span>，即相对于上一个命令终点的相对位移</li></ul><p> 命令包括以下：</p><ul><li>M = moveto，移动画笔</li><li>L = lineto，绘制直线</li><li>H = horizontal lineto，绘制水平直线，只需要x一个参数</li><li>V = vertical lineto，绘制垂直直线，只需要y一个参数</li><li>C = curveto，绘制三次贝塞尔曲线</li><li>S = smooth curveto，可衔接的三次贝塞尔曲线</li><li>Q = quadratic Belzier curve，绘制二次贝塞尔曲线</li><li>T = smooth quadratic Belzier curveto，绘制可衔接的二次贝塞尔曲线</li><li>A = elliptical Arc，绘制弧线</li><li>Z = closepath，闭合路径，一般用于路径最后</li></ul><h4 id="二阶贝塞尔曲线"><a href="#二阶贝塞尔曲线" class="headerlink" title="二阶贝塞尔曲线"></a>二阶贝塞尔曲线</h4><p>通过给定一个控制点坐标和曲线终点坐标绘制贝塞尔曲线<br><span class="strong">Q x1 y1, x y</span></p><ul><li>只需要一个控制点(x1,y1)</li><li>(x,y)为终点坐标</li></ul><h5 id="延长的平滑二阶贝塞尔曲线"><a href="#延长的平滑二阶贝塞尔曲线" class="headerlink" title="延长的平滑二阶贝塞尔曲线"></a>延长的平滑二阶贝塞尔曲线</h5><p>可以将多个贝塞尔曲线衔接起来，形成一条更长的曲线<br><span class="strong">T x y</span></p><ul><li>只需要指定曲线终点坐标(x,y)</li><li>如果该命令前为另一个Q命令或T命令，该命令会把上一个命令控制点关于曲线终点的中心对称点作为其控制点</li><li>如果该命令单独使用，则会认为控制点和终点为同一点，绘制一条直线<div class="show">&lt;path d="M 10 80 Q 50 200 100 100 T 200 120"/></div><svg width="220" height="200" style="display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;"> <circle cx="10" cy="80" r="4" style="fill:#f00;"/><circle cx="50" cy="196" r="4" style="fill:#f00;"/><circle cx="100" cy="100" r="4" style="fill:#f00;"/><polyline points="10 80, 50 196,100 100" style="stroke:f00;" /><circle cx="150" cy="4" r="4" style="fill:#00f;"/><circle cx="200" cy="120" r="4" style="fill:#00f;"/><polyline points="100 100, 150 4,200 120" style="stroke:#00f;" /><path d="M 10 80 Q 50 200 100 100 T 200 120"/></svg></li></ul><h4 id="三阶贝塞尔曲线"><a href="#三阶贝塞尔曲线" class="headerlink" title="三阶贝塞尔曲线"></a>三阶贝塞尔曲线</h4><p>通过指定两个控制点，一个终点坐标绘制曲线<br><span class="strong">C x1 y1, x2 y2, x y</span></p><ul><li>(x1,y1)(x2,y2)为控制点坐标</li><li>(x,y)为曲线终点坐标</li><li>c小写时(x,y)应当为上一个路径终点的相对坐标(dx,dy)<div class="show">&lt;path d="M 10 10 C 0 200, 150 20, 300 300 "/></div></li></ul><p>同理，可以将多个三阶贝塞尔曲线衔接起来，形成一条更长的曲线<br><span class="strong">S x2 y2, x y</span></p><ul><li>(x2,y2)为控制点坐标</li><li>(x,y)为终点坐标</li><li>如果该命令跟在一个 C 或 S 命令后面，则该曲线的第一个控制点会被设置为前一个曲线第二个控制点关于曲线终点的中心对称点(以此保持斜率不变来保证曲线可以平滑衔接)<div class="show">&lt;path d="M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 "/></div><svg width="400" height="200" style="display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;"><circle cx="10" cy="10" r="4" style="fill:#f00;"/><circle cx="10" cy="150" r="4" style="fill:#f00;"/><circle cx="150" cy="20" r="4" style="fill:#f00;"/><circle cx="200" cy="50" r="4" style="fill:#f00;"/><line x1="10" y1="10" x2="10" y2="150" style="stroke:#f00;" /><line x1="150" y1="20" x2="200" y2="50" style="stroke:#f00;" /><circle cx="250" cy="80" r="4" style="fill:#00f;"/><circle cx="160" cy="150" r="4" style="fill:#00f;"/><circle cx="396" cy="100" r="4" style="fill:#00f;"/><line x1="200" y1="50" x2="250" y2="80" style="stroke:#00f;" /><line x1="160" y1="150" x2="396" y2="100" style="stroke:#00f;" /><path d="M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 "/></svg></li></ul><h3 id="颜色与样式"><a href="#颜色与样式" class="headerlink" title="颜色与样式"></a>颜色与样式</h3><h4 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h4><p>默认情况下，创建路径后不会进行描边，需要使用<span class="stroke">stroke</span>属性指定描边颜色</p><ul><li><span class="strong">stroke=”颜色” 指定描边颜色，取值同CSS</span></li><li><span class="strong">stroke-opacity=”值” 单独指定不透明度</span></li><li><span class="strong">stroke-width=”值” 指定描边线宽度</span></li></ul><h4 id="描边终点与折点样式"><a href="#描边终点与折点样式" class="headerlink" title="描边终点与折点样式"></a>描边终点与折点样式</h4><ul><li><span class="strong">stroke-linecap=”butt/round/square”  描边终点为正常(平头截断)/圆形线帽/矩形线帽</span></li><li><span class="strong">stroke-linejoin=”miter/round/bevel” 描边折点为尖角/圆角/切角</span></li><li><span class="strong">stroke-miterlimit=”值” 设置折点斜切面的限制长度</span></li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>具体样式区别可以参考这篇博文：<a href="http://localhost:4000/blog/2023/05/03/canvas/#%E7%BA%BF%E6%AE%B5%E6%8A%98%E7%82%B9" target="_blank">canvas绘制线段-实线部分</a></div><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p>默认情况下，闭合图形或路径的填充色为黑色，可以通过<span class="tips">fill</span>属性修改</p><ul><li><span class="strong">fill=”颜色” 指定填充颜色，取值同CSS</span></li><li><span class="strong">fill-opacity=”值” 单独指定填充不透明度</span></li></ul><h4 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h4><ul><li><span class="strong">stroke-dasharray=”值,值…” 设置虚线线段和间隙的长度</span></li><li><span class="strong">stroke-dashoffset=”值” 设置虚线偏移值</span></li></ul><h4 id="使用CSS定义样式"><a href="#使用CSS定义样式" class="headerlink" title="使用CSS定义样式"></a>使用CSS定义样式</h4><p>svg的属性除了能在标签属性中定义外，也能在CSS中直接声明，但仅适用于部分属性</p><ul><li>stroke</li><li>fill</li></ul><h3 id="特殊标签"><a href="#特殊标签" class="headerlink" title="特殊标签"></a>特殊标签</h3><h4 id="defs标签"><a href="#defs标签" class="headerlink" title="defs标签"></a>defs标签</h4><p>defs标签用于定义需要重复使用的图形元素，该标签中定义的图形元素不会直接呈现，只供后续调用</p><h4 id="g标签"><a href="#g标签" class="headerlink" title="g标签"></a>g标签</h4><p>容器标签，用于包含一组标签，然后将该组标签的共同样式属性添加到g标签上，这样该属性值会对所有子标签继承。注意：g标签不支持使用x,y属性来进行定位，需要修改位置时，可以使用transform属性或CSS修改</p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><p>在<span class="tips">&lt;defs&gt;</span>标签内创建一个<span class="tips">&lt;linearGradient&gt;</span>标签，在该标签内定义线性渐变，并通过<span class="tips">&lt;stop/&gt;</span>标签的属性定义颜色、渐变位置、不透明度，然后在需要调用的图形中，用<span class="tips">fill</span>属性或<span class="tips">stroke</span>属性调用<span class="tips">url</span>引用<span class="tips">&lt;linearGradient&gt;</span>标签的<span class="tips">ID</span>值(调用类名无效)</p><p><span class="strong">&lt;linearGradient x1=”0” x2=”1” y1=”0” y2=”0”&gt;&lt;/linearGradient&gt;</span></p><ul><li>x1,x2,y1,y2通过确定两个点来定义渐变路径走向，一般取值0-1间的小数，取大于1的值将导致渐变超出图形范围(溢出的渐变部分不可见)</li><li>默认从左往右，即x1=”0” x2=”1” y1=”0” y2=”0”</li><li>x1=”0” x2=”0” y1=”0” y2=”1”即调整为从上到下</li></ul><p><span class="strong">&lt;stop offset=”50%” stop-color=”#00f” /&gt;</span></p><ul><li>offset属性定义颜色渐变(偏移)位置，可以取0%-100%，也可以取0-1间的小数</li><li>stop-color定义颜色，取值同CSS</li><li>stop-opacity定义不透明度</li></ul><div class="show">&lt;defs>     &lt;linearGradient id="G1">          &lt;stop offset="0%" stop-color="red"/>          &lt;stop offset="50%" stop-color="yellow"/>          &lt;stop offset="100%" stop-color="blue"/>     &lt;/linearGradient>&lt;/defs>&lt;rect x="0" y="0" rx="10" ry="10" width="300" height="300" fill="url(#G1)"/></div><h4 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h4><p>与线性渐变类似，径向渐变需要在<span class="tips">&lt;defs&gt;</span>标签内创建一个<span class="tips">&lt;radialGradient&gt;</span>标签，然后通过<span class="tips">&lt;stop/&gt;</span>标签的属性定义颜色、渐变位置、不透明度</p><p><span class="strong">&lt;radialGradient cx=”.5” cy=”.5” r=”.5” fx=”.2” fy=”.2”&gt;&lt;radialGradient&gt;</span></p><ul><li>cx,cy定义渐变结束所围绕的圆环，取值0-1</li><li>r定义渐变圆在当前图形中的占用半径，一般取值0-1，大于1将导致渐变溢出图形</li><li>fx,fy定义渐变开始的位置</li></ul><div class="show">&lt;defs>     &lt;radialGradient cx=".5" cy=".5" r=".5" fx=".2" fy=".2"  id="R1">          &lt;stop offset="0%" stop-color="red"/>          &lt;stop offset="25%" stop-color="yellow"/>          &lt;stop offset="50%" stop-color="blue"/>          &lt;stop offset="75%" stop-color="green"/>          &lt;stop offset="100%" stop-color="purple"/>     &lt;/radialGradient>&lt;/defs>&lt;rect class="fillRect" x="0" y="0"  width="200" height="200" fill="url(#R1)"/>1. 渐变开始位置为矩形图20%,20%位置2. 渐变结束所形成的圆环：圆心位于矩形50%,50%点处，半径为矩形长的50%</div><svg width="200" height="200" xmlns="radialGradientSVG" style="display:block;margin:0 auto;"><defs><radialGradient cx=".5" cy=".5" r=".5" fx=".2" fy=".2"  id="R1"><stop offset="0%" stop-color="red"/><stop offset="25%" stop-color="yellow"/><stop offset="50%" stop-color="blue"/><stop offset="75%" stop-color="green"/><stop offset="100%" stop-color="purple"/></radialGradient></defs><rect class="fillRect" x="0" y="0"  width="200" height="200" fill="url(#R1)"/></svg><h4 id="spreadMethod属性"><a href="#spreadMethod属性" class="headerlink" title="spreadMethod属性"></a>spreadMethod属性</h4><p>spreadMethod属性用于指定渐变到达终点的行为，默认情况下，offset为100%时的颜色会填充剩余部分，该属性对线性渐变和径向渐变均生效</p><ul><li>pad(默认)，渐变结束后使用终点颜色填充剩下区域</li><li>reflect，渐变结束后按反向颜色顺序填充剩下区域</li><li>repeat，渐变结束后从头开始填充剩下区域</li></ul><div class="show">&lt;linearGradient  id="g2" x1="0" x2=".5" y1="0" y2="0" spreadMethod="pad">//            &lt;stop offset="0%" stop-color="red"/>            &lt;stop offset="33%" stop-color="yellow"/>            &lt;stop offset="66%" stop-color="blue"/>            &lt;stop offset="100%" stop-color="green"/>&lt;/linearGradient>1. x2=".5"指定了颜色渐变填充到矩形的50%位置2. pad值会用终点颜色填充剩下区域3. reflect值会按绿，蓝，黄，红顺序(与原顺序相反)填充剩下区域3. repeat值会按颜色顺序(从头开始)填充剩下区域</div><svg style="display:block;margin:0 auto;" width="340" height="200" xmlns="spreadMethodSVG"><defs><linearGradient  id="g2" x1="0" x2=".5" y1="0" y2="0" spreadMethod="pad">            <stop offset="0%" stop-color="red"/>            <stop offset="33%" stop-color="yellow"/>            <stop offset="66%" stop-color="blue"/>            <stop offset="100%" stop-color="green"/>        </linearGradient>        <linearGradient  id="g3" x1="0" x2=".5" y1="0" y2="0" spreadMethod="reflect">            <stop offset="0%" stop-color="red"/>            <stop offset="33%" stop-color="yellow"/>            <stop offset="66%" stop-color="blue"/>            <stop offset="100%" stop-color="green"/>        </linearGradient>        <linearGradient  id="g4" x1="0" x2=".5" y1="0" y2="0" spreadMethod="repeat">            <stop offset="0%" stop-color="red"/>            <stop offset="33%" stop-color="yellow"/>            <stop offset="66%" stop-color="blue"/>            <stop offset="100%" stop-color="green"/>        </linearGradient></defs>        <rect  x="0" y="0" width="100" height="130" fill="url(#g2)"/>        <rect  x="110" y="0" width="100" height="130" fill="url(#g3)"/>        <rect  x="220" y="0" width="100" height="130" fill="url(#g4)"/></svg><h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>与canvas相同，svg也有一个模板对象，常用于定义需要重复填充的背景图等。与渐变一样，&lt;pattern&gt; 也需要定义在的 &lt;defs&gt; 内部，然后使用其他图形引用Patterns的ID<br><span class="strong">&lt;pattern x=”0” y=”0” width=”.25” height=”.25”&gt;&lt;/pattern&gt;</span></p><ul><li>x,y定义Pattern图形的开始位置</li><li>width,height决定该Pattern图形会在x轴和y轴上重复几次，0.25意味着将在横轴和纵轴方向上均重复4次</li></ul><div class="show">&lt;svg width="200" height="200">        &lt;defs>&lt;pattern id="Pattern" x="0" y="0" width=".25" height=".25">&lt;rect x="0" y="0" width="50" height="50" fill="skyblue"/>&lt;circle cx="25" cy="25" r="20" fill="yellow" fill-opacity="0.5"/>    &lt;/pattern>        &lt;/defs>&lt;rect fill="url(#Pattern)" stroke="black" x="0" y="0" width="200" height="200"/>    &lt;/svg></div><p><svg width="200" height="200" xmlns="pattern" style="display:block;margin:0 auto;"><defs><pattern id="pattern" x="0" y="0" width=".25" height=".25"><rect x="0" y="0" width="50" height="50" fill="skyblue" stroke="#000"/><circle cx="25" cy="25" r="20" fill="yellow" fill-opacity="0.5"/></pattern></defs><rect fill="url(#pattern)" x="0" y="0" width="200" height="200"/><br></svg></p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="text标签"><a href="#text标签" class="headerlink" title="text标签"></a>text标签</h4><p><span class="strong">&lt;text x=”0” y=”0”&gt;&lt;/text&gt;</span></p><ul><li>x,y定义文字左下角在SVG中的开始位置(y值)</li><li>通过fill属性和stroke属性指定文字填充/描边颜色</li><li>text-anchor属性决定文本开始方向，可取值：start、middle、end、inherit(该属性一般用于阿拉伯语等从右到左阅读的语言)</li><li>以下属性定义文字大小、字间距等，可以直接定义在标签中，也可以定义在CSS中，取值和CSS大致相同：<span class="tips">font-family</span>、<span class="tips">font-style</span>、<span class="tips">font-weight</span>、<span class="tips">font-size</span>、<span class="tips">letter-spacing</span>、<span class="tips">word-spacing</span>、<span class="tips">text-decoration</span>、<span class="tips">font-variant</span>、<span class="tips">font-size-adjust</span>等，注意，文字的填充和描边需要使用<span class="tip">fill</span>和<span class="tips">stroke</span>属性指定颜色</li></ul><div class="show">&lt;style> #svgText{            text-anchor:start;            fill: red;            font-size: 20px;            font-weight: 900;        }&lt;/style>&lt;svg width="600" height="600"  xmlns="http://www.w3.org/2000/svg">&lt;text id="svgText" x="10" y="30">手写的从前&lt;/text>&lt;/svg></div><h4 id="tspan标签"><a href="#tspan标签" class="headerlink" title="tspan标签"></a>tspan标签</h4><p>tspan标签常用于标记出一段文本中的特殊部分，如将某句话的关键词加粗标识，该标签必须包含于<span class="tips">text</span>标签或<span class="tips">tspan</span>标签中<br><span class="strong">&lt;tspan&gt;文本内容&lt;/tspan&gt;</span></p><ul><li>该标签需要置于父级text标签或tspan标签内，且文本在svg的位置跟随父级标签</li><li>x,y属性可以为该标签设置一个新的位置坐标，该坐标是相对于svg的坐标原点，无视父级坐标</li><li>dx,dy属性可以在父级坐标的基础上，进行偏移</li><li>rotate属性可以将文字 进行旋转</li><li>上述属性都允许赋值一个数列，表示为tspan标签中的每个字符设置单独的坐标/旋转值</li></ul><div class="show">1. x和y属性是相对于SVG的坐标，可能导致tspan标签内容覆盖到父级文本之上&lt;text y="20" fill="#fff">父级标签&lt;tspan x="20" fill="red">x属性&lt;/tspan>父级标签&lt;/text>2. dx,dy属性是在父级坐标基础上进行位移&lt;text y="20" fill="#fff">父级标签&lt;tspan dx="20" fill="red">dx属性&lt;/tspan>父级标签&lt;/text>3. x,y,dx,dy的属性值可以为一组数列值，依次指定标签中每个字符的坐标&lt;text y="20" fill="#fff">父级标签&lt;tspan dx="20,25,30,35" fill="red">dx属性赋值数列&lt;/tspan>父级标签&lt;/text>4. rotate属性值也可以是单个，或者为一组数列，对字符进行旋转&lt;text y="20" fill="#fff">父级标签&lt;tspan rotate="20,30,40,50,60,70,80" fill="red">dx属性赋值数列&lt;/tspan>父级标签&lt;/text></div><p><svg width="400" height="180" xmlns="tspan" style="display:block;margin:0 auto;font-size:18px;"><rect x="0" y="0" width="400" height="400" fill="skyblue" /><text x="0" y="20" fill="#fff">1.父级标签<tspan x="20" fill="red">x属性</tspan>父级标签</text><text x="0" y="60" fill="#fff">2.父级标签<tspan  dx="20" fill="red">dx属性</tspan>父级标签</text><text x="0" y="100" fill="#fff">3.父级标签<tspan  dx="20,25,30,35,40" fill="red">dx属性赋值数列</tspan>父级标签</text><text x="0" y="140" fill="#fff">4.父级标签<tspan  rotate="20,30,40,50,60,70,80" fill="red">rotate属性赋值数列</tspan>父级标签</text><br></svg></p><h4 id="textPath标签"><a href="#textPath标签" class="headerlink" title="textPath标签"></a>textPath标签</h4><p>textPath可创建出跟随路径排列的文本，需要通过<span class="tips">xlink:href</span>属性引用路径ID</p><div class="show">&lt;path d="M 10 80 Q 50 200 100 100 T 200 120" id="my_path" fill="none" stroke="red"/>&lt;text fill="skyblue" font-size="20">&lt;textPath  xlink:href="#my_path">So live a life you will remember&lt;/textPath>&lt;/text></div><p><svg width="300" height="150" xmlns="textPath" style="display:block;margin:0 auto;"><path d="M 10 80 Q 50 200 100 100 T 200 120" id="my_path" fill="none" stroke="red"/><text fill="skyblue" font-size="20"> <textPath  xlink:href="#my_path">So live a life you will remember</textPath><br></svg></p><h3 id="变形、剪切、遮罩、图片"><a href="#变形、剪切、遮罩、图片" class="headerlink" title="变形、剪切、遮罩、图片"></a>变形、剪切、遮罩、图片</h3><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><ul><li><span class="strong">transform=”translate(x,y)” 平移</span>(如果只指定一个值，则默认第二个值为0)</li><li><span class="strong">transform=”rotate(角度值)” 沿着图形左上角顺时针(正值)旋转</span></li><li><span class="strong">transform=”skewX(角度值)或skewY(角度值)” 在x/y轴方向上斜切</span></li><li><span class="strong">transform=”scale(x缩放,y缩放)” 在x/y轴进行缩放</span>(如果只指定一个值，则默认第二个值等于第一个值)</li><li>多个属性值可以写到一个transform中，用空格隔开</li></ul><div class="show"> &lt;rect x="0" y="0" width="200" height="200" fill="red" transform="translate(50,10) scale(.2,1.2) rotate(60)"/></div><h4 id="clipPath剪切"><a href="#clipPath剪切" class="headerlink" title="clipPath剪切"></a>clipPath剪切</h4><p>定义一个<span class="tips">clipPath</span>标签并指定路径或图形，然后在需要裁剪的目标元素上使用<span class="tips">clip-path</span>属性调用<span class="tips">clipPath</span>标签的ID值进行裁剪，剪裁会保留二者相同部分，对其余部分进行裁剪。该标签一般定义于<span class="tips">defs</span>标签中</p><div class="show">&lt;defs>        &lt;clipPath id="cut">            &lt;rect x="200" y="200" width="200" height="100"/>        &lt;/clipPath>    &lt;/defs> &lt;circle cx="300" cy="300" r="100" fill="yellow" clip-path="url(#cut)"/></div><h4 id="mask遮罩"><a href="#mask遮罩" class="headerlink" title="mask遮罩"></a>mask遮罩</h4><p> 遮罩常用于制作淡出淡入效果，<span class="tips">mask</span>标签定义于defs标签中，然后在需要添加遮罩的标签中使用<span class="tips">mask</span>属性引用遮罩ID</p> <div class="show">&lt;defs>    &lt;linearGradient id="Gradient">      &lt;stop offset="0" stop-color="white" stop-opacity="0"/>      &lt;stop offset="1" stop-color="white" stop-opacity="1"/>    &lt;/linearGradient>    &lt;mask id="Mask">      &lt;rect x="0" y="0" width="200" height="200" fill="url(#Gradient)"/>    &lt;/mask>&lt;/defs><p>  &lt;rect x=”0” y=”0” width=”200” height=”200” fill=”green”/&gt;<br>  &lt;rect x=”0” y=”0” width=”200” height=”200” fill=”red” mask=”url(#Mask)” /&gt;</div></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>SVG使用<span class="tips">image</span>标签插入图片，并且可以在图像上使用剪切、变形、遮罩等SVG提供的功能<br><span class="strong">&lt;image xlink:href=””/&gt;</span></p><ul><li>可以使用x,y属性指定图片位置</li><li>可以使用width,height属性指定图片宽高</li><li>xlink:href属性用于指定图片地址<div class="show">&lt;image x="50" y="50" width="300" height="300"  xlink:href="../dog.jpg"/></div></li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>SVG中还有链接、动画、滤镜等标签，详见MDN文档:<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element</a></div>]]></content>
    
    
    <summary type="html">svg标签的使用方法，包括基本图形的绘制，贝塞尔曲线的绘制，颜色样式的设置，渐变、变形、剪切、遮罩的添加，以及文字和图片的绘制</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="html" scheme="https://shiwei11.github.io/blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Canvas</title>
    <link href="https://shiwei11.github.io/blog/2023/05/03/canvas/"/>
    <id>https://shiwei11.github.io/blog/2023/05/03/canvas/</id>
    <published>2023-05-03T00:59:30.000Z</published>
    <updated>2023-10-19T08:06:26.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p><span class="tips">canvas</span>是HTML5新增的标签，用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面，canvas不支持IE8及IE8以下浏览器</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>具体的兼容性可以参考MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas</a></div><h4 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h4><h5 id="通过HTML标签"><a href="#通过HTML标签" class="headerlink" title="通过HTML标签"></a>通过HTML标签</h5><p>可以通过直接添加HTML标签的方式创建canvas，并设置画布的宽高，然后通过<span class="tips">getContext()</span>方法获得画布的 2D 渲染上下文对象，需要为该方法提供<span class="tips">‘2d’</span>作为参数，该对象提供了用于在画布上绘图的方法和属性</p><pre><code>&lt;body>    &lt;canvas width="600" height="400" id="canvas">&lt/canvas>    &ltscript>        const canvas=document.getElementById('canvas');        const context = canvas.getContext('2d');    &lt;/script>&lt;/body></code></pre><h5 id="通过JavaScript动态创建"><a href="#通过JavaScript动态创建" class="headerlink" title="通过JavaScript动态创建"></a>通过JavaScript动态创建</h5><p>也可以通过JavaScript动态添加canvas并指定宽高，tips:通过JavaScript创建的canvas在写代码时IDE会有代码补全提示</p><pre><code> const canvas=document.createElement("canvas");    canvas.width=600;    canvas.height=400;    document.body.appendChild(canvas); const context = canvas.getContext('2d');</code></pre><h5 id="画布尺寸的说明"><a href="#画布尺寸的说明" class="headerlink" title="画布尺寸的说明"></a>画布尺寸的说明</h5><ul><li>canvas需要通过属性来设置宽度、高度，且不需要单位</li><li>通过CSS设置canvas的width和height属性，仅用于缩放图像，无法改变画布尺寸，当CSS指定的宽高与画布的宽高比例不一致时，图像会出现扭曲</li><li>默认画布大小为300px * 150px，宽高比为2:1，如果不指定画布的宽高，或者设置了无效值(如负数)，则会使用默认值</li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>通过CSS设置的Canvas宽高样式只会修改浏览器渲染后所显示图像的宽高，不会修改画布本身及其图像本身的宽高。浏览器会在渲染期间根据CSS对源图像进行伸缩，以适应指定的CSS样式大小。如果 CSS 的指定的宽高尺寸与画布的宽高比例不一致，图像有可能出现扭曲。而通过属性修改的画布宽度和高度，实际会修改Canvas DOM对象的属性值，即画布本身的宽度和高度，并将该DOM对象传递给canvas内部的2d渲染上下文环境对象(CanvasRenderingContext2D)</div><h4 id="兼容性检查"><a href="#兼容性检查" class="headerlink" title="兼容性检查"></a>兼容性检查</h4><p>IE9之前的浏览器不支持Canvas，如果不兼容canvas，canvas 标签会被浏览器解析为自定义标签，显示标签内的提示信息</p><div class="show">&lt;canvas id="canvas">抱歉，您的浏览器不支持 canvas 标签&lt;/canvas></div>    同时要做好JavaScript兼容性检查<div class="show">const canvas = document.getElementById('canvas');        if (canvas.getContext){          const ctx = canvas.getContext('2d');        }</div><h1 id="Canvas-2D渲染API"><a href="#Canvas-2D渲染API" class="headerlink" title="Canvas 2D渲染API"></a>Canvas 2D渲染API</h1><p>所有API都是基于canvas的2d渲染上下文对象，文中以context或ctx为对象名</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><ul><li><p><span class="strong">moveTo(x,y) 移动画笔到指定坐标</span><br>指定画笔最先开始绘制的点，此后Canvas的绘制方法都是基于上一次的路径终点进行的，仍可以使用moveTo(x,y)修改画笔的坐标到路径终点以外</p></li><li><p><span class="strong">context.beginPath() 创建一个新路径</span></p></li></ul><p>在同一个画布中绘制多个独立的图像，应当为每个图像创建不同的子路径，如:为不同的线段设置不同的颜色、线宽等样式，应当为每个线段创建独立的子路径，每个路径内部的样式、属性单独声明，否则后声明的样式会覆盖前面的样式，并且应当为每个独立的路径指定画笔初始点，执行绘制方法</p><div class="show">const canvasPath=document.getElementById("canvasPath");   const ctxPath = canvasPath.getContext('2d');        ctxPath.lineWidth=5;        ctxPath.beginPath();        ctxPath.strokeStyle="red";        ctxPath.moveTo(150,50);        ctxPath.lineTo(50,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="blue";        ctxPath.moveTo(50,200);        ctxPath.lineTo(250,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="yellow";        ctxPath.moveTo(250,200);        ctxPath.lineTo(150,50);        ctxPath.stroke();</div><canvas width="300" height="300" id="canvasPath" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas><script>   const canvasPath=document.getElementById("canvasPath");   const ctxPath = canvasPath.getContext('2d');        ctxPath.lineWidth=5;        ctxPath.beginPath();        ctxPath.strokeStyle="red";        ctxPath.moveTo(150,50);        ctxPath.lineTo(50,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="blue";        ctxPath.moveTo(50,200);        ctxPath.lineTo(250,200);        ctxPath.stroke();        ctxPath.beginPath();        ctxPath.strokeStyle="yellow";        ctxPath.moveTo(250,200);        ctxPath.lineTo(150,50);        ctxPath.stroke();</script><p>在使用循环定时器创建动画时，往往需要在每次定时器执行时创建一个新路径，避免上次的路径影响到本次路径的绘制</p><div class="show">const canvas=document.createElement("canvas");        canvas.width=300;        canvas.height=300;        document.body.appendChild(canvas);        const ctx = canvas.getContext('2d');        let cpx=10;        let timer=setInterval(()=>{        ctx.beginPath();//每次计时器开始时，开始新路径        ctx.clearRect(0,0,300,300);//清空画布        ctx.moveTo(50,50);        ctx.quadraticCurveTo(cpx+=10,100,50,250);//动态绘制贝塞尔曲线        ctx.stroke();        if(cpx>=250){            clearInterval(timer)        }        },50)</div><ul><li><span class="strong">context.closePath(); 闭合当前子路径</span><br>将画笔坐标移回到当前子路径起始点，该方法会尝试从当前点到起始点绘制一条直线，如果图形已经是封闭的或者只有一个点，该方法不会做任何操作，可用于闭合图形</li></ul><div class="show">const canvasLine=document.getElementById("canvasLine");        const ctxLine = canvasLine.getContext('2d');        ctxLine.lineWidth=3;        ctxLine.moveTo(150,50);        ctxLine.lineTo(100,150);        ctxLine.lineTo(200,150);        ctxLine.closePath();        ctxLine.stroke();</div><h4 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h4><ul><li><span class="strong">context.stroke() 绘制当前路径</span></li><li><span class="strong">context.lineWidth=值; 修改描边线条的宽度</span></li><li><span class="strong">context.strokeStyle=”颜色/渐变对象/Pattern对象”; 设置描边样式</span></li></ul><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><ul><li><span class="strong">context.fill() 填充已闭合的路径</span></li><li><span class="strong">context.fillStyle=”颜色/渐变对象/Pattern对象”; 设置填充的样式</span></li></ul><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><p><span class="strong">context.clip() 根据当前路径进行裁剪</span><br>沿着路径进行裁剪，裁剪路径外的图形将不再显示在Canvas中</p><h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><p><span class="strong">context.clearRect(x,y,width,height) 清除指定区域内的画布内容</span></p><div class="show">context.clearRect(0,0,canvas.width,canvas.height)//清空整个画布</div><h4 id="封装路径-Path2D对象"><a href="#封装路径-Path2D对象" class="headerlink" title="封装路径-Path2D对象"></a>封装路径-Path2D对象</h4><p> <span class="strong">let myPath2D=new Path2D();</span><br>返回一个Path2D对象，之后可以将路径添加到该对象中，并直接重用对象中的所有路径，stroke()、fill()、clip()均接收该对象作为参数</p><div class="show">const canvas=document.getElementById("canvas");        const context = canvas.getContext('2d');        let myDesign=new Path2D();        //将路径封装到Path2D对象中而非context对象上        myDesign.moveTo(50,50);        myDesign.lineTo(100,50);        myDesign.lineTo(100,100);        myDesign.lineTo(50,100);        myDesign.lineTo(50,50);        //之后可以直接重用封装好的路径        context.stroke(myDesign);//描边        context.fill(myDesign);//填充        context.clip(myDesign);//裁剪</div><h4 id="位置判断"><a href="#位置判断" class="headerlink" title="位置判断"></a>位置判断</h4><ul><li><span class="strong">context.isPointInStroke(x, y) 返回boolean值，判断(x,y)点是否在当前路径上</span></li><li><span class="strong">context.isPointInStroke(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径上</span></li><li><span class="strong">context.isPointInPath(x, y) 返回boolean值，判断(x,y)点是否在当前路径内</span></li><li><span class="strong">context.isPointInPath(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径内</span></li></ul><h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><h4 id="实线线段"><a href="#实线线段" class="headerlink" title="实线线段"></a>实线线段</h4><h5 id="线段路径"><a href="#线段路径" class="headerlink" title="线段路径"></a>线段路径</h5><p><span class="strong">context.lineTo(x,y) 连接直线路径到指定坐标</span></p><h5 id="线段折点"><a href="#线段折点" class="headerlink" title="线段折点"></a>线段折点</h5><p><span class="strong">context.lineJoin=”miter/round/bevel”; </span></p><p>设置或返回两条线交汇时，线段折线处的样式</p><ul><li><strong>miter</strong> 尖锐折线(默认)</li><li><strong>round</strong> 圆角折线</li><li><strong>bevel</strong> 切角折线</li></ul><p><span class="strong">ctx.miterLimit = value; </span><br>设置或返回边角斜切面的限制长度(默认为10)，下图为miterLimit=2(左)以及miterLimit=10(右)的区别<br><canvas width="300" height="150" id="canvasLimit" style="display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasLimit=document.getElementById("canvasLimit");        const ctxLimit = canvasLimit.getContext('2d');        ctxLimit.lineWidth=20;        ctxLimit.lineJoin="miter";        ctxLimit.beginPath();        ctxLimit.miterLimit=2;        ctxLimit.moveTo(40,20);        ctxLimit.lineTo(70,100);        ctxLimit.lineTo(100,20);        ctxLimit.stroke();        ctxLimit.beginPath();        ctxLimit.miterLimit=10;        ctxLimit.moveTo(190,20);        ctxLimit.lineTo(220,100);        ctxLimit.lineTo(250,20);        ctxLimit.stroke();       </script><h5 id="线段末端"><a href="#线段末端" class="headerlink" title="线段末端"></a>线段末端</h5><p><span class="strong">context.lineCap=”butt/round/square;”</span></p><p>设置或返回线段末端线帽的样式，”round” 和 “square” 值会使线条略微变长</p><ul><li><strong>butt</strong> 末端以方形结束(默认)</li><li><strong>round</strong>末端添加圆形线帽</li><li><strong>square</strong>末端添加一个宽度相同，长度为宽度一半的矩形线帽</li></ul><p><canvas width="400" height="150" id="canvasLine" style="display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasLine=document.getElementById("canvasLine");        const ctxLine = canvasLine.getContext('2d');        ctxLine.lineWidth=10;        ctxLine.beginPath();        ctxLine.lineCap="butt";        ctxLine.lineJoin="miter";        ctxLine.moveTo(90,50);        ctxLine.lineTo(150,50);        ctxLine.lineTo(190,10);        ctxLine.lineTo(230,50);        ctxLine.lineTo(290,50);        ctxLine.stroke();        ctxLine.beginPath();        ctxLine.lineCap="round";        ctxLine.lineJoin="round";        ctxLine.moveTo(90,100);        ctxLine.lineTo(150,100);        ctxLine.lineTo(190,60);        ctxLine.lineTo(230,100);        ctxLine.lineTo(290,100);        ctxLine.stroke();        ctxLine.beginPath();        ctxLine.lineCap="square";        ctxLine.lineJoin="bevel";        ctxLine.moveTo(90,140);        ctxLine.lineTo(150,140);        ctxLine.lineTo(190,100);        ctxLine.lineTo(230,140);        ctxLine.lineTo(290,140);        ctxLine.stroke();        ctxLine.beginPath();        ctxLine.setLineDash([5,10]);        ctxLine.lineWidth=1;        ctxLine.strokeStyle="red";        ctxLine.moveTo(90,0)        ctxLine.lineTo(90,200)        ctxLine.moveTo(290,0)        ctxLine.lineTo(290,200)        ctxLine.stroke();</script><h4 id="虚线线段"><a href="#虚线线段" class="headerlink" title="虚线线段"></a>虚线线段</h4><ul><li><span class="strong">context.setLineDash([数组]);</span> 传递一个数组来指定虚线线段和间隙的交替长度，空数组将设置为实线</li><li><span class="strong">context.getLineDash();</span> 返回一个数组，获取当前线段的样式</li></ul><div class="show">context.setLineDash([2,10,5,10])context.moveTo(0,0)context.lineTo(100,200);context.stroke();</div><p><span class="strong">context.lineDashOffset = value;</span><br>设置虚线偏移值，可实现蚂蚁线效果</p><div class="show">const canvasDash=document.getElementById("canvasDash");   const ctxDash = canvasDash.getContext('2d');   let offset=0;   ctxDash.lineWidth=5;   ctxDash.setLineDash([30,20])   ctxDash.setLineDash([30,20])   ctxDash.moveTo(0,100)   ctxDash.lineTo(300,100);   function render(){       offset++;    if(offset>50){        offset=0    }    ctxDash.clearRect(0,0,300,300)    ctxDash.lineDashOffset=offset;    ctxDash.stroke();    requestAnimationFrame(render)    }    render();</div><canvas width="300" height="300" id="canvasDash" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas><script>  const canvasDash=document.getElementById("canvasDash");   const ctxDash = canvasDash.getContext('2d');   let offset=0;   ctxDash.lineWidth=5;   ctxDash.setLineDash([30,20])   ctxDash.setLineDash([30,20])   ctxDash.moveTo(0,100)   ctxDash.lineTo(300,100);   function render(){       offset++;    if(offset>50){        offset=0    }    ctxDash.clearRect(0,0,300,300)    ctxDash.lineDashOffset=offset;    ctxDash.stroke();    requestAnimationFrame(render)    }    render();</script><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><h5 id="矩形路径"><a href="#矩形路径" class="headerlink" title="矩形路径"></a>矩形路径</h5><p><span class="strong">context.rect(x,y,width,height) 创建矩形路径</span></p><ul><li>x, y为矩形坐标</li><li>width为矩形的宽度，正值矩形位于x坐标右侧，负值则位于左侧</li><li>height为矩形的高度，正值矩形位于y坐标下方，负值则在上方</li></ul><p>仅创建矩形路径，不会显示在画布中，可以使用stroke()方法或fill()方法进行描边绘制或者填充绘制</p><h5 id="描边矩形"><a href="#描边矩形" class="headerlink" title="描边矩形"></a>描边矩形</h5><p><span class="strong">context.strokeRect(x, y, width, height) 绘制描边矩形</span></p><p>创建矩形路径并描边，参数同上，相当于rect()方法和stroke()方法同时执行，可以使用<span class="tips">lineWidth</span>修改线宽，使用<span class="tips">strokeStyle</span>修改线条样式</p><h5 id="填充矩形"><a href="#填充矩形" class="headerlink" title="填充矩形"></a>填充矩形</h5><p><span class="strong">context.fillRect(x, y, width, height) 填充一个矩形</span></p><p>创建矩形路径并填充，参数同上，相当于rect()方法和fill()方法同时执行，可以使用<span class="tips">fillStyle</span>修改填充样式</p><h3 id="渐变对象"><a href="#渐变对象" class="headerlink" title="渐变对象"></a>渐变对象</h3><h4 id="添加渐变色"><a href="#添加渐变色" class="headerlink" title="添加渐变色"></a>添加渐变色</h4><p><span class="strong">渐变对象名.addColorStop(偏移量,”颜色”)</span></p><ul><li>对象名为以下三种渐变对象创建的实例</li><li>偏移量为0~1之间的值，代表渐变开始到渐变终止的位置，等同于CSS中的百分比位置</li><li>颜色取值同CSS</li></ul><h4 id="线性渐变对象"><a href="#线性渐变对象" class="headerlink" title="线性渐变对象"></a>线性渐变对象</h4><p><span class="strong">context.createLinearGradient(x1,y1,x2,y2)</span><br>在(x1,y1)到(x2,y2)矢量方向上创建径向渐变对象，并返回该对象</p><div class="show">const ctx = canvas.getContext('2d');const gradient=ctx.createLinearGradient(0,0,600,400);        gradient.addColorStop(0,"red");        gradient.addColorStop(.3,"#df0");        gradient.addColorStop(1,"blue");        ctx.strokeStyle=gradient;</div><h4 id="径向渐变对象"><a href="#径向渐变对象" class="headerlink" title="径向渐变对象"></a>径向渐变对象</h4><p><span class="strong">context.createRadialGradient(x0, y0, r0, x1, y1, r1);</span><br>以(x0,y0)为圆心，r0为半径确定一圆，以(x1,y1)为圆心，r1为半径确定另一圆，</p><p>根据参数确定两个圆的坐标，绘制放射性渐变的方法</p><div class="show">const canvas1=document.getElementById("canvas1");    const ctx1 = canvas1.getContext('2d');    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);    radial.addColorStop(0,"red");    radial.addColorStop(.25,"yellow");    radial.addColorStop(.5,"green");    radial.addColorStop(.75,"#ff00fb");    radial.addColorStop(1,"blue");    ctx1.fillStyle=radial;    ctx1.fillRect(0,0,300,300)</div><p><canvas width="300" height="300" id="canvas1" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;"></canvas></p><script>    const canvas1=document.getElementById("canvas1");    const ctx1 = canvas1.getContext('2d');    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);    radial.addColorStop(0,"red");    radial.addColorStop(.25,"yellow");    radial.addColorStop(.5,"green");    radial.addColorStop(.75,"#ff00fb");    radial.addColorStop(1,"blue");    ctx1.fillStyle=radial;    ctx1.fillRect(0,0,300,300)     ctx1.moveTo(0,0);    ctx1.lineTo(50,50);    ctx1.stroke();    ctx1.moveTo(250,250);    ctx1.lineTo(300,300);    ctx1.stroke();</script><h4 id="锥形渐变对象"><a href="#锥形渐变对象" class="headerlink" title="锥形渐变对象"></a>锥形渐变对象</h4><p><span class="strong">context.createConicGradient(弧度值,x,y)</span><br>以(x,y)为锥形中心创建锥形渐变对象，弧度值角度为渐变开始的位置，角度通过<span class="tips">Math.PI*角度/180</span>运算为弧度值，值可正可负</p><div class="show">const canvas=document.getElementById("canvas");   const ctx = canvas.getContext('2d');    const cg=ctx.createConicGradient(Math.PI*45/180,150,150);    cg.addColorStop(0,"red");    cg.addColorStop(.25,"yellow");    cg.addColorStop(.5,"green");    cg.addColorStop(.75,"#ff00fb");    cg.addColorStop(1,"blue");    ctx.fillStyle=cg;    ctx.fillRect(0,0,300,300);</div><p><canvas width="300" height="300" id="canvasCG" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasCG=document.getElementById("canvasCG");   const ctxCG = canvasCG.getContext('2d');   try{     const cg=ctxCG.createConicGradient(Math.PI*45/180,150,150);      cg.addColorStop(0,"red");    cg.addColorStop(.25,"yellow");    cg.addColorStop(.5,"green");    cg.addColorStop(.75,"#ff00fb");    cg.addColorStop(1,"blue");    ctxCG.fillStyle=cg;    ctxCG.fillRect(0,0,300,300);   }   catch(error){    ctxCG.font=" 800 58px Serif"    ctxCG.fillText("浏览器不支", 0, 100);    ctxCG.fillText("持锥形渐变", 0, 150);    console.warn("浏览器不支持锥形渐变createConicGradient()方法")}   </script><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>锥形渐变兼容性远比线性渐变、径向渐变差，对浏览器内核版本要求较高，详见MDN文档：<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient" style="display:block;word-break: break-all;">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient</a></div><h3 id="Pattern对象"><a href="#Pattern对象" class="headerlink" title="Pattern对象"></a>Pattern对象</h3><p>创建模板对象，</p><p><span class="strong">createPattern(image,重复模式)</span><br>image为图像源，可以是<span class="tips">&lt;img&gt;图像</span>、<span class="tips">&lt;video&gt;视频</span>、<span class="tips">&lt;canvas&gt;另外一个canvas对象</span>、<span class="tips">canvas的2d上下文对象(CanvasRenderingContext2D)</span>等</p><p>图像的重复模式可以为<span class="tips">repeat</span>、<span class="tips">repeat-x</span>、<span class="tips">repeat-y</span>、<span class="tips">no-repeat</span>，用法同CSS</p><div class="show"> const canvas=document.createElement("canvas");        canvas.width=1000;        canvas.height=1000;        document.body.appendChild(canvas);        const ctx=canvas.getContext("2d");        let img=new Image();        img.src="./dog.jpg";        img.onload=function(){            const p=ctx.createPattern(img,'repeat-y')            ctx.fillStyle=p;            ctx.fillRect(0,0,1000,1000)        }</div><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="圆与圆弧线绘制"><a href="#圆与圆弧线绘制" class="headerlink" title="圆与圆弧线绘制"></a>圆与圆弧线绘制</h4><p><span class="strong">context.arc(x,y,r,startAngle, endAngle, anticlockwise)</span></p><ul><li>x,y为圆弧中心</li><li>r为圆弧半径</li><li>startAngle, endAngle为圆弧起始点和终点角度，弧度表示，角度为css坐标x轴与y轴夹角</li><li>anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制<div class="show">const canvasArc=document.getElementById("canvasArc"); const ctxArc = canvasArc.getContext('2d'); ctxArc.lineWidth=5; ctxArc.arc(150,150,100,0,90/180*Math.PI,true); ctxArc.stroke();</div></li></ul><p><canvas width="300" height="300" id="canvasArc" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasArc=document.getElementById("canvasArc");   const ctxArc = canvasArc.getContext('2d');   ctxArc.lineWidth=5;   ctxArc.arc(150,150,100,0,90/180*Math.PI,true);   ctxArc.stroke();</script><h4 id="圆弧线绘制方法2"><a href="#圆弧线绘制方法2" class="headerlink" title="圆弧线绘制方法2"></a>圆弧线绘制方法2</h4><p><span class="strong">context.arcTo(x1, y1, x2, y2, radius)</span></p><ul><li>x1, y1为第一个控制点坐标</li><li>x2, y2为第二个控制点坐标</li><li>radius 为圆弧半径</li></ul><p>将当前路径终点与控制点 1 连接的直线，和控制点 1 与控制点 2 连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径</p><div class="show"> const canvasArcTo=document.getElementById("canvasArcTo");   const ctxArcTo = canvasArcTo.getContext('2d');    ctxArcTo.beginPath();    ctxArcTo.moveTo(100,50)    ctxArcTo.strokeStyle="#000";    ctxArcTo.lineWidth=5;    ctxArcTo.arcTo(250,50,250,250,150);    ctxArcTo.stroke()    ctxArcTo.beginPath();    ctxArcTo.moveTo(50,50)    ctxArcTo.setLineDash([5,10]);    ctxArcTo.lineWidth=5;    ctxArcTo.strokeStyle="blue";    ctxArcTo.lineTo(250,50)    ctxArcTo.lineTo(250,250)    ctxArcTo.stroke()</div><p><canvas width="300" height="300" id="canvasArcTo" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasArcTo=document.getElementById("canvasArcTo");   const ctxArcTo = canvasArcTo.getContext('2d');    ctxArcTo.beginPath();    ctxArcTo.moveTo(100,50)    ctxArcTo.strokeStyle="#000";    ctxArcTo.lineWidth=5;    ctxArcTo.arcTo(250,50,250,250,150);    ctxArcTo.stroke()    ctxArcTo.beginPath();    ctxArcTo.moveTo(50,50)    ctxArcTo.setLineDash([5,10]);    ctxArcTo.lineWidth=5;    ctxArcTo.strokeStyle="blue";    ctxArcTo.lineTo(250,50)    ctxArcTo.lineTo(250,250)    ctxArcTo.stroke()</script><h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><p><span class="strong">context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);</span></p><ul><li>x,y为椭圆圆心的坐标</li><li>radiusX 为椭圆长轴的半径，radiusY 为椭圆短轴半径</li><li>rotation 为椭圆的旋转角度，以弧度表示</li><li>startAngle, endAngle为椭圆圆弧起始点和终点角度，弧度表示</li><li>anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制</li></ul><div class="show"> const canvasEllipse=document.getElementById("canvasEllipse");   const ctxEll = canvasEllipse.getContext('2d');   ctxEll.lineWidth=5;   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)   ctxEll.stroke();</div><p><canvas width="300" height="300" id="canvasEllipse" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasEllipse=document.getElementById("canvasEllipse");   const ctxEll = canvasEllipse.getContext('2d');   ctxEll.lineWidth=5;   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)   ctxEll.stroke();</script><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><h5 id="二阶贝塞尔曲线"><a href="#二阶贝塞尔曲线" class="headerlink" title="二阶贝塞尔曲线"></a>二阶贝塞尔曲线</h5><p><span class="strong"> context.quadraticCurveTo(cpx, cpy, x, y)</span></p><ul><li>cpx, cpy为控制点的坐标</li><li>x, y为曲线终点坐标</li><li>起始点坐标为当前路径所在终点，或者可以使用moveTo()控制</li></ul><div class="show"> const canvasBC=document.getElementById("canvasBezierCurve");   const ctxBC = canvasBC.getContext('2d');   ctxBC.lineWidth=2;   ctxBC.moveTo(50,50);        let cpx=50;        let timerBC=setInterval(()=>{        //想绘制为动画还需再添加beginPath()和clearRect()方法        ctxBC.moveTo(50,50)        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)        ctxBC.stroke()        if(cpx>=350){            clearInterval(timerBC)        }        },100)</div><canvas width="300" height="300" id="canvasBezierCurve" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas><script>   const canvasBC=document.getElementById("canvasBezierCurve");   const ctxBC = canvasBC.getContext('2d');   ctxBC.lineWidth=2;   ctxBC.moveTo(50,50);        let cpx=50;        let timerBC=setInterval(()=>{        ctxBC.moveTo(50,50)        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)        ctxBC.stroke()        if(cpx>=350){            clearInterval(timerBC)        }        },100)</script><h5 id="三阶贝塞尔曲线"><a href="#三阶贝塞尔曲线" class="headerlink" title="三阶贝塞尔曲线"></a>三阶贝塞尔曲线</h5><p><span class="strong"> context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</span></p><ul><li>cp1x, cp1y为第一个控制点的坐标</li><li>cp2x, cp2y为第二个控制点的坐标</li><li>x, y为曲线终点坐标</li><li>起始点坐标为当前路径所在终点，或者可以使用moveTo()控制</li></ul><div class="show"> const canvasBC2=document.getElementById("canvasBezierCurve2");   const ctxBC2 = canvasBC2.getContext('2d');   ctxBC2.lineWidth=2;   ctxBC2.moveTo(50,50);    ctxBC2.bezierCurveTo(300, 50, 50, 300,250, 290);    ctx2BC.stroke()</div><p><canvas width="300" height="300" id="canvasBezierCurve2" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p><script>   const canvasBC2=document.getElementById("canvasBezierCurve2");   const ctxBC2 = canvasBC2.getContext('2d');   ctxBC2.lineWidth=2;   ctxBC2.moveTo(50,50);   ctxBC2.bezierCurveTo(250, 50, 50, 250,250, 290);   ctxBC2.stroke()  </script><h3 id="文字绘制"><a href="#文字绘制" class="headerlink" title="文字绘制"></a>文字绘制</h3><h4 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h4><p><span class="strong">context.fillText(text, x, y, [maxWidth]); 对文字进行填充</span></p><p><span class="strong">context.strokeText(text, x, y, [maxWidth]); 对文字进行描边</span></p><ul><li>text指定文本内容</li><li>x, y为文本左下角在画布中开始绘制的坐标(因此坐标不应该为0,0)</li><li>maxWidth(可选)，指定绘制的最大宽度，会对文本进行水平缩放</li></ul><h4 id="获取文本宽度"><a href="#获取文本宽度" class="headerlink" title="获取文本宽度"></a>获取文本宽度</h4><p><span class="strong">context.measureText(“文本”);</span></p><p>返回文本的TextMetrics 对象，一般会从该对象中获得文本宽度，以判断文字是否需要在Canva中进行换行</p><div class="show">&lt;canvas width="300" height="700" id="canvasText">&lt;/canvas>&lt;script>const canvasText=document.getElementById("canvasText");const ctxText = canvasText.getContext('2d');let string="微风需要竹林，溪流需要蜻蜓，乡愁般的离开，需要片片浮萍，青春属于表白，阳光属于窗台，而我想我属于一个，拥有你的未来";ctxText.font=" 30px Serif";let rowNum=1;//行号let lastIndex=0;//上一行文字的截取索引位置let rowWidth=0;//每一行的文本长度    for(let i=0;i&lt;string.length;i++){    rowWidth+=ctxText.measureText(string[i]).width;        if(rowWidth>canvasText.width){            ctxText.fillText(string.substring(lastIndex,i),0,50*rowNum)            lastIndex=i--;//substring()截左不截右            rowNum++;            rowWidth=0;        }        if(i==string.length-1){            ctxText.fillText(string.substring(lastIndex,i+1),0,50*rowNum)        }}&lt;/script></div><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><span class="strong">context.font = “value”;</span><br>指定文本属性，默认为 10px sans-serif，value为CSS中的font简写属性，可以按顺序设置<span class="tips">[font-style]&emsp; [font-variant]&emsp;[font-weight]&emsp; font-size[/line-height] &emsp;font-family</span></p><ul><li>必须包含font-size和font-family</li><li>font-style：字体样式，常用取值normal(正常)、italic(斜体)、oblique(倾斜)</li><li>font-variant：设置小型大写字母，将字母写为大写，但除首字母外的文本将缩小字号，默认为normal，可以修改为small-caps(小型大写字母)</li><li>font-weight：设置文本的粗细，常用值：normal(正常)，bold(粗体)，bolder(再加粗)，lighter(细体)，以及100-900的整百数值</li><li>font-size必须，line-height为非必须，有line-height时要写为如：16px/20px 的形式</li><li>font-family：字体族，5个通用字体：Serif(衬线字体)、Sans-serif(无衬线字体)、Monospace(等宽字体)、Cursive(草书字体)、Fantasy(幻想字体)</li></ul><div class="show">const canvasText=document.getElementById("canvasText");const ctxText = canvasText.getContext('2d');ctxText.font=" 60px Serif";ctxText.fillText("hello world",50,60) //对文字进行填充ctxText.strokeText("hello world",50,180)//对文字进行描边</div><canvas width="400" height="200" id="canvasText" style="display:block;width:340px;height:160px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas>    <script>       const canvasText=document.getElementById("canvasText");       const ctxText = canvasText.getContext('2d');       ctxText.font=" 60px Serif";       ctxText.fillText("hello world",50,60)       ctxText.strokeText("hello world",50,180)    </script><h4 id="文本方向"><a href="#文本方向" class="headerlink" title="文本方向"></a>文本方向</h4><p><span class="strong">context.direction =”ltr/rtl/inherit”; 设置当前文本方向</span> </p><ul><li>ltr ,从左往右</li><li>rtl ,从右往左(部分国家读写习惯)</li><li>inherit(默认)，从父元素继承</li></ul><p><span class="strong">context.textAlign = “left/right/center/start/end”; 定义文本水平方向上的对齐方式</span> </p><ul><li>center以绘制文本时的x坐标为基准，一半位于x左边，一半位于右边</li><li>start与end属性以direction定义的文本方向为基准</li></ul><p><span class="strong">context.textBaseline = “tophanging/middle/alphabetic/ideographic/bottom”; 定义文本垂直方向上的对齐方式</span></p><ul><li>与CSS相同，以文本基线为基准，详见MDN文档</li></ul><h3 id="图像与视频绘制"><a href="#图像与视频绘制" class="headerlink" title="图像与视频绘制"></a>图像与视频绘制</h3><ul><li><p><span class="strong">drawImage(image, dx, dy)</span></p></li><li><p><span class="strong">drawImage(image, dx, dy, dWidth, dHeight)  </span></p></li><li><p><span class="strong">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) </span></p><ul><li>image为图像源，可以是图片、SVG矢量图、视频、canvas等</li><li>dx, dy为图片左上角在画布中开始绘制的位置</li><li>dWidth, dHeight为图像在画布上绘制出来的尺寸，会对其进行缩 放、拉抻</li><li>sx, sy为裁剪时，距离图像左上角的开始裁剪的位置</li><li>sWidth, sHeight为裁剪的宽度和高度，省略该参数则默认裁剪到&gt;右下角，sHeight为负值将从sy反向裁剪</li></ul></li></ul><div class="show">const canvasImg=document.getElementById("canvasImg");       const ctxImg = canvasImg.getContext('2d');       let img=new Image();       img.src="./dog.jpg";       img.onload=function(){        //仅指定图片在画布中的位置        ctxImg.drawImage(img, 50, 50);        //指定图片在画布中的位置及缩放尺寸        ctxImg.drawImage(img, 50, 50,300,200);        //裁剪图片，并指定图片在画布中的位置及缩放尺寸        ctxImg.drawImage(img, 50, 50,300,200,0,0,300,300);       }</div><h3 id="移动、旋转、缩放"><a href="#移动、旋转、缩放" class="headerlink" title="移动、旋转、缩放"></a>移动、旋转、缩放</h3><p><span class="strong">context.translate(x, y); 进行水平和垂直位移</span><br>  修改坐标系的原点，默认原点位于(0,0)，由此移动图像在Canvas中的相对位置，可以在上一次translate(x, y)的基础上再次移动坐标系，多次修改坐标原点</p><p><span class="strong">context.rotate(弧度值); 进行旋转变换</span><br>  修改坐标系的旋转角度，参数为弧度值</p><p><span class="strong">context.scale(x, y); 进行水平和垂直缩放</span><br>  对坐标系x轴和y轴进行伸缩，0-1进行缩小，大于1进行放大，负值则进行水平/垂直翻转后进行缩放</p><div class="show">const canvas=document.createElement('canvas');        canvas.width=600;        canvas.height=600;        document.body.append(canvas);        const ctx=canvas.getContext('2d');        ctx.translate(50,50);        ctx.fillRect(0,0,50,100)        ctx.translate(100,100);        ctx.scale(1,-2)        ctx.rotate(180*Math.PI/180)        ctx.fillRect(0,0,50,100)</div><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>类似于CSS的阴影效果，注意，阴影应当设置在图形绘画之前，如果设置阴影效果之前已经有图形和文字存在，则阴影不会对这些图形和文字生效</p><ul><li><span class="strong">context.shadowOffsetX = value; 阴影的水平偏移距离</span></li><li><span class="strong">context.shadowOffsetY = value; 阴影的垂直偏移距离</span></li><li><span class="strong">context.shadowBlur = value;  阴影的模糊值</span></li><li><span class="strong">context.shadowColor = “颜色”; 阴影颜色</span><div class="show">const ctx=canvas.getContext('2d');ctx.shadowOffsetX=16;ctx.shadowOffsetY=8;ctx.shadowBlur=5;ctx.shadowColor="#575656";ctx.moveTo(50,50);ctx.bezierCurveTo(300, 50, 50, 300,250, 290);ctx.stroke()</div></li></ul><h3 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h3><p>类似于CSS3中的效果<br><span class="strong">context.filter = “一个或多个值”</span></p><ul><li>blur(值px)：高斯模糊</li><li>brightness(百分比)：亮度</li><li>contrast(百分比)：对比度</li><li>grayscale(百分比)：灰度滤镜</li><li>hue-rotate(角度deg)：对图像进行色彩旋转的处理</li><li>invert(百分比)：反色(呈现出照片底片的效果)</li><li>opacity(百分比)：不透明度</li><li>sepia(百分比)：褐色处理(怀旧风格)</li><li>drop-shadow(x, y, 模糊值, 阴影扩张/收缩, 阴影色)：阴影效果</li></ul><h3 id="图像合成模式"><a href="#图像合成模式" class="headerlink" title="图像合成模式"></a>图像合成模式</h3><p><span class="strong">context.globalCompositeOperation = “type”;</span></p><ul><li><span class="strong">source-over</span> 图像叠加显示(默认)</li><li><span class="strong">source-in</span> 只显示图像重叠部分</li><li><span class="strong">source-out</span> 只显示图像不重叠的部分</li><li><span class="strong">source-atop</span> 后叠加的图像只显示与原图像重叠的部分</li><li><span class="strong">destination-over</span> 将后叠加的图像置于原图像之下</li><li><span class="strong">destination-in</span> 只显示图像重叠部分，并且只显示原图像部分</li><li><span class="strong">destination-out</span> 将原图像抠去与后图像叠加部分显示，并且后图像不显示</li><li><span class="strong">destination-atop</span>将后图像重叠部分替换为原图像并显示</li><li><span class="strong">lighter</span>两图像重叠部分进行颜色相加</li><li><span class="strong">copy</span>去除原图像，只显示新图像</li><li><span class="strong">xor</span>重叠部分透明，其他正常显示</li><li><span class="strong">multiply</span>将重叠部分的顶层像素与底层像素相乘，重叠部分显示为暗黑色</li><li><span class="strong">screen</span>将重叠部分像素倒转，相乘，再倒转，重叠部分显示为亮色</li><li><span class="strong">overlay</span>multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮</li><li><span class="strong">darken</span>保留两个图层中最暗的像素</li><li><span class="strong">lighten</span>保留两个图层中最亮的像素</li><li><span class="strong">color-dodge</span>将底层除以顶层的反置</li><li><span class="strong">color-burn</span>将反置的底层除以顶层，然后将结果反过来</li><li><span class="strong">hard-light</span>类似于叠加，上下图层互换</li><li><span class="strong">soft-light</span>用顶层减去底层或者相反来得到一个正值</li><li><span class="strong">difference</span>一个柔和版本的强光(hard-light),纯黑或纯白不会导致纯黑或纯白</li><li><span class="strong">exclusion</span>和 difference 相似，但对比度较低</li><li><span class="strong">hue</span>保留底层的亮度和色度，同时采用顶层的色调</li><li><span class="strong">saturation</span>保留底层的亮度和色调，同时采用顶层的色度</li><li><span class="strong">color</span>保留了底层的亮度，同时采用了顶层的色调和色度</li><li><span class="strong">luminosity</span>保持底层的色调和色度，同时采用顶层的亮度</li></ul><h3 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h3><ul><li><span class="strong">context.save() 将当前状态推入栈中</span></li><li><span class="strong">context.restore() 读取栈顶的状态</span></li></ul><p>将保存当前的裁剪区域、虚线列表、以及各属性值压入栈中，之后可以直接依次读取栈顶存储的状态并直接绘制，会保存的属性值包括：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled</p><div class="show">const canvas=document.getElementById("canvas");const ctx=canvas.getContext('2d');ctx.fillStyle="red";ctx.save(); //依次压栈ctx.fillStyle="yellow";ctx.save(); //依次压栈ctx.fillStyle="green";ctx.restore(); //弹栈ctx.fillRect(50,50,100,100);//将绘制为黄色而非绿色</div><h3 id="像素操作-ImageData对象"><a href="#像素操作-ImageData对象" class="headerlink" title="像素操作-ImageData对象"></a>像素操作-ImageData对象</h3><p>ImageData对象保存了Canvas图像的底层实际像素，可以直接进行读取和写入。其中，像素被保存在Uint8ClampedArray类型的一维数组中，每个数组元素为0-255之间的数据，每4个数组元素为一组代表了一个像素点的RGBA值。如：索引为0-3的数组元素，存储了第一个像素点的红、绿、蓝、不透明度对应的0-255十进制数值，以此类推</p><p><span class="strong">context.getImageData(x,y,width,height)</span><br>返回ImageData对象，获取(x,y)坐标开始，width为宽，height为高的矩形区域中的像素。返回的对象中包含width、height、data数组(Uint8ClampedArray类型)三个属性</p><p> <span class="strong">context.putImageData(imagedata对象, dx偏移, dy偏移)</span></p><p>getImageData()方法可以从(x,y)坐标开始获取一个矩形区域内的像素数据，将该部分数据修改后，可以通过putImageData()方法将数据绘制到canvas中。其中，dx，dy为在(x,y)的基础上进行的偏移量，之前获取到的(x,y)到(x+width,y+height)矩形区域内的图形，修改像素数据后将被绘制到(x+dx,y+dy)开始的同大小矩形区域内</p><p> <span class="strong">context.putImageData(imagedata对象,dx偏移, dy偏移, dirtyX, dirtyY,dirtyWidth, dirtyHeight)</span></p><ul><li>dx偏移, dy偏移作用同上</li><li>(dirtyX, dirtyY)为进行修改像素操作开始的位置坐标</li><li>dirtyWidth, dirtyHeight为将进行修改像素操作的矩形区域的长宽</li></ul><div class="show">&lt;canvas width="300" height="300" id="canvas">&lt;/canvas>    &lt;script>       const canvas=document.getElementById("canvas");       const ctx = canvas.getContext('2d');       let img=new Image();       img.src="./dog.jpg";       img.onload=function(){        ctx.drawImage(img,0,0,300,300);        let imageDate=ctx.getImageData(0, 0, 100, 100);        //每4个索引为一组，代表一个像素的RGBA值        for(let i=0;i&lt;imageDate.data.length;i+=4){            //计算每个像素点的灰度值            let avg=(imageDate.data[i]+imageDate.data[i+1]+imageDate.data[i+2])/3;            imageDate.data[i]=avg; //修改像素点的R            imageDate.data[i+1]=avg;//修改像素点的G            imageDate.data[i+2]=avg;//修改像素点的B            imageDate.data[i+3]=255;//修改像素点不透明度A为1        }        // 将(10,10)开始，长200，宽200的区域内的像素调为灰色        ctxImg.putImageData(imageDate,0,0,10,10,200,200)       }    &lt;/script></div><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>使用图像合成模式的<span class="strong">“destination-out”</span>属性值制作刮刮卡</p><div class="ticketContainer" style="position:relative;width:100%;"><div class="scratchTicket" style="width: 300px;height: 150px;font-size: 24px;color: red;text-align: center;line-height: 150px;margin:0 auto;letter-spacing: 8px;background-color: #ffffff;pointer-events: none;user-select: none;">再刮一次</div><canvas width="300" height="150" id="canvasTicket" style="position:absolute;top:0;left:50%;transform:translateX(-50%);"></canvas><div class="tryAgain" onclick="tryAgain()" style="width: 100px;height: 35px;line-height: 35px;text-align: center;background-color: aqua;border-radius: 5px;cursor: pointer;user-select: none;margin:10px auto;">再刮一次</div></div><script>       const ticketContainer=document.querySelector(".ticketContainer");       const canvasTicket=document.getElementById("canvasTicket");       const contextTicket=canvasTicket.getContext('2d');       const p=contextTicket.createPattern(cover(),"repeat");        contextTicket.fillStyle=p;        tryAgain();        function tryAgain(){            document.querySelector(".scratchTicket").innerText=Math.random()>.6?"恭喜中奖":"再刮一次";            contextTicket.clearRect(0,0,300,150);            contextTicket.globalCompositeOperation="copy";            contextTicket.fillRect(0,0,300,150);        }        function cover(){            const canvasCover=document.createElement('canvas');            const coverCtx=canvasCover.getContext('2d');            canvasCover.width=60;            canvasCover.height=50;            coverCtx.fillStyle="#6f6d6d"            coverCtx.fillRect(0,0,60,50)            coverCtx.rotate(45*Math.PI/180);            coverCtx.font="300 15px Serif";            coverCtx.fillStyle="#333333"            coverCtx.fillText("发大财",20,0)            return canvasCover;        }        let allowedDraw=false;        canvasTicket.addEventListener('mousedown',function(){            allowedDraw=true;        })         canvasTicket.addEventListener('mouseup',function(){            allowedDraw=false;        })        canvasTicket.addEventListener('mousemove',function(event){            var event = event || window.event;            if(allowedDraw){             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器              var  x = event.offsetX;              var y = event.offsetY;            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器              var x = event.layerX;              var y = event.layerY;            }            contextTicket.globalCompositeOperation="destination-out";            contextTicket.beginPath();            contextTicket.arc(x,y,20,0,2*Math.PI);            contextTicket.fill();            }})            canvasTicket.addEventListener('touchstart',function(){            let canvasTicketRect=canvasTicket.getBoundingClientRect();            canvasTicket.addEventListener('touchmove',function(e){                e.preventDefault();            var x=e.targetTouches[0].pageX-canvasTicketRect.left;            var y=e.targetTouches[0].pageY-canvasTicketRect.top;            contextTicket.globalCompositeOperation="destination-out";            contextTicket.beginPath();            contextTicket.arc(x,y,20,0,2*Math.PI);            contextTicket.fill();            },{passive:false})            },{passive:false})    </script><pre><code>&lt;div class="card">&lt;/div>//底层卡片，显示是否中奖&lt;canvas width="300" height="150" id="canvas1">&lt;/canvas>//刮刮乐灰色图层，监听刮开区域&lt;div class="tryAgain" onclick="tryAgain()">再刮一次&lt;/div>//重新开始按钮&lt;/div>&lt;script>       const canvas=document.getElementById("canvas1");       const context=canvas.getContext('2d');       const p=context.createPattern(cover(),"repeat");//创建模板对象，设置图像重复模式        context.fillStyle=p;        function tryAgain()&#123;            document.querySelector(".card").innerText=Math.random()>.8?"恭喜中奖":"再刮一次";            context.clearRect(0,0,300,150);            context.globalCompositeOperation="copy";            context.fillRect(0,0,300,150);        &#125;        tryAgain();        /*        *制作刮刮乐封面，返回canvas DOM        */        function cover()&#123;            const canvasCover=document.createElement('canvas');            const coverCtx=canvasCover.getContext('2d');            canvasCover.width=60;            canvasCover.height=50;            coverCtx.fillStyle="#6f6d6d"            coverCtx.fillRect(0,0,60,50)            coverCtx.rotate(45*Math.PI/180);            coverCtx.font="300 15px Serif";            coverCtx.fillStyle="#333333"            coverCtx.fillText("发大财",20,0)            return canvasCover;        &#125;        let allowedDraw=false;        canvas.addEventListener('mousedown',function()&#123;            allowedDraw=true;        &#125;)         canvas.addEventListener('mouseup',function()&#123;            allowedDraw=false;        &#125;)        canvas.addEventListener('mousemove',function(event)&#123;            var event = event || window.event;            if(allowedDraw)&#123;             if (event.offsetX || event.offsetY) &#123;  //非Mozilla浏览器              var  x = event.offsetX;              var y = event.offsetY;            &#125; else if (event.layerX || event.layerY) &#123;  //兼容Mozilla浏览器              var x = event.layerX;              var y = event.layerY;            &#125;            context.globalCompositeOperation="destination-out";            context.beginPath();            context.arc(x,y,20,0,2*Math.PI);            context.fill();            &#125;&#125;)            //移动端            canvas.addEventListener('touchstart',function()&#123;            let canvasRect=canvas.getBoundingClientRect();            canvas.addEventListener('touchmove',function(e)&#123;                e.preventDefault();            var x=e.targetTouches[0].pageX-canvasRect.left;            var y=e.targetTouches[0].pageY-canvasRect.top;            context.globalCompositeOperation="destination-out";            context.beginPath();            context.arc(x,y,20,0,2*Math.PI);            context.fill();            &#125;,&#123;passive:false&#125;)            &#125;,&#123;passive:false&#125;)    &lt;/script></code></pre>]]></content>
    
    
    <summary type="html">只涉及Canvas Context2D对象提供的API，包括基本图形、弧线、贝塞尔曲线的绘制，渐变、阴影、滤镜、文字的添加，以及对图像合成模式和像素的操作</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="javaScript" scheme="https://shiwei11.github.io/blog/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>Web的发展旅程</title>
    <link href="https://shiwei11.github.io/blog/2022/09/18/History-of-browser/"/>
    <id>https://shiwei11.github.io/blog/2022/09/18/History-of-browser/</id>
    <published>2022-09-18T07:46:45.000Z</published>
    <updated>2023-09-20T18:53:51.448Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>了解这些历史解开了此前我心中的一些疑惑，比如：UA标识里为什么同时会有好几个内核的标识？CSS为什么需要写浏览器前缀来做兼容性？</div><h3 id="世界线的开端"><a href="#世界线的开端" class="headerlink" title="世界线的开端"></a>世界线的开端</h3><h4 id="超文本-Hyper-Text"><a href="#超文本-Hyper-Text" class="headerlink" title="超文本(Hyper Text )"></a>超文本(Hyper Text )</h4><p><span class="strong">超文本:</span>是指利用链接将非线性分布的节点上的信息联结，把各种不同空间的文字信息组织在一起形成的超级文本。它使得原先的线性文本变成可以通向四面八方的非线性文本，读者查阅文本时可以在任何一个关节点上停下来，进入其他文本，然后再点击、再进入另一文本，理论上，这个过程是可以无限重复的。从而，原先单一的文本变成了无限延伸、扩展的超级文本。</p><p>1945年，美国工程师Vannevar Bush(曼哈顿计划的主要组织者、雷神公司创始人之一)提出了一种基于静态缩微胶片页面的memex(memory extender)设备,人们可以在该设备中压缩和存储书籍、文件、通信记录及其索引，并以极快的速度对其进行检索查询。这意味着，人们不用再根据特定的程序，一步一步寻找信息，利用文本间的交叉引用链接,人们可以用非线性的方式查阅信息，由于条件所限，Vannevar Bush的思想在当时并没有变成现实，但这一开创性的信息组织方法，奠定了超文本的基础。</p><p>1960年，Ted Nelson在哈弗大学参加计算机编程课时，考虑编写一个文档系统来索引和管理他收藏的笔记，他在进入哈弗大学前曾担任电影制片人，因此他准备将电影镜头引入了该系统的设计中。所有信息都可以通过其他任何地方的链接访问，信息导航是非线性的，这取决于每个访问信息的人，人们可以从一个信息跳转到另外一则信息，就像从一个镜头切换到另外一个镜头。基于这个想法，1963年，Ted Nelson 首次提出了“超文本”的概念。</p><p>1968年，美国科学家Doug Engelbart在美国秋季联合计算机会议上展示了第一个超文本系统NLS(oN-Line System)，并首次展示了鼠标、第一个图形用户界面。</p><h4 id="万维网的诞生"><a href="#万维网的诞生" class="headerlink" title="万维网的诞生"></a>万维网的诞生</h4><p>1989年，工作于CERN(欧洲核子研究所)的Tim Berners Lee为查找存储在不同计算机上的信息而苦恼，不兼容的网络、磁盘、数据格式和字符编码使得人们查找信息十分困难且低效。于是，他向CERN的领导层提交了一个超文本项目提案，该提案提出建立一个用于CERN研究人员之间交流信息的系统，用以帮助处于不同网络、计算机系统、国家的研究人员共享信息和交流问题。</p><p>1990年，Tim Berners Lee开发出了构建Web所需要的三个基本技术：</p><ul><li><span class="strong">统一资源定位符(URL)</span></li><li><span class="strong">超文本标记语言(HTML)</span></li><li><span class="strong">超文本传输协议(HTTP)</span></li></ul><p>同年，在同事Robert Cailliau的帮助下，Tim Berners Lee发起建立了一个名为World Wide Web (万维网)的超文本项目。1990年12月，Tim Berners Lee和他的团队开发出了世界上第一个Web浏览器(WorldWideWeb，与万维网同名)，第一个Web服务器(CERN httpd)，并发布了世界上第一个网站：<a href="http://info.cern.ch/">http://info.cern.ch/</a>，万维网就此诞生！</p><p>1994年，W3C联盟(万维网联盟)正式成立，由Tim Berners-Lee 担任W3C联盟主任，这是一个非营利性技术组织，旨在对 web 技术进行标准化，以协调服务提供商、内容供应商、实验室等各方协同工作，致力在万维网发展方向上达成共识，并起草发布<span class="strong">W3C标准</span>，主要包括HTML、XHTML、CSS、DOM、ECMAScript标准的规划制定。</p><h4 id="浏览器的发展"><a href="#浏览器的发展" class="headerlink" title="浏览器的发展"></a>浏览器的发展</h4><p>WorldWideWeb浏览器最初只能在NeXTSTEP操作系统上使用(next公司老板是大名鼎鼎的乔布斯，后来next被苹果收购，NeXTSTEP系统和OpenStep结合，衍生出了MacOS)，为了解决这个问题，Tim Berners Lee的团队使用C语言重写了WorldWideWeb的许多组件，从而创建了libwww API。</p><p>1992年4月，在Robert Cailliau的指导下，赫尔辛基理工大学的4名硕士生小组联合开发出了第一个可运行于Unix的浏览器Erwise，该项目在学生毕业后被搁置了，Tim Berners Lee前往芬兰鼓励该小组毕业后继续开发该项目，但后期由于缺少资金该项目再次被搁置。</p><p>1992年，加州大学伯克利分校学生魏培源使用Viola语言将WWW浏览器的组件组合了起来，发布了第二个可以运行于Unix系统中的浏览器ViolaWWW，这是第一个支持添加扩展功能的浏览器，该浏览器得到了CERN的推崇，成为了第一个流行于万维网中的浏览器。</p><p>1993年，美国国家超级计算应用中心(NCSA)的俩名员工Marc Andreessen和Eric Bina在接触了ViolaWWW后，为Unix的X窗口系统设计出了Mosaic浏览器，这是第一款可以显示图形界面和图片的浏览器，设计之初就考虑到了非技术用户的使用体验，由此引发了Web网络的爆炸式发展，Web在短短几个月内从鲜为人知变成了无处不在，该浏览器也很快被移植到Amiga、Apple Macintosh和Windows等平台。</p><h3 id="内核的发展"><a href="#内核的发展" class="headerlink" title="内核的发展"></a>内核的发展</h3><h4 id="开拓者-网景导航者"><a href="#开拓者-网景导航者" class="headerlink" title="开拓者 网景导航者"></a>开拓者 网景导航者</h4><p>1994年4月，Mosaic浏览器的核心开发人员Marc Andreessen离开了NCSA，与几何图形发生器的发明人Jim Clark共同创办了网景公司（Netscape Communications Corporation），网景大量聘用了原有的Mosaic浏览器工程师，但由于Mosaic的版权在NCSA，于是开发团队重写了浏览器代码。</p><p>1994年11月，网景发布了大名鼎鼎的<span class="strong">网景导航者（Netscape Navigator）</span>浏览器1.0版本，这是全球第一款商业浏览器，由于公司目标是替代NCSA Mosaic成为全球第一的浏览器，因此将其内部代号定为了”Mozilla”，意为Mosaic杀手。1995年，网景开发出了<span class="strong">HTTP cookie、</span><span class="strong">Frame框架、</span><span class="strong">SSL</span>等一系列技术，并创建了<span class="strong">JavaScript</span>语言，网景导航者由于其功能更新迅速，又有新技术的加持，市场份额一度达到了86%。</p><p>意气风发的网景将目光转向了操作系统的开发，网景希望开发出一款基于浏览器的操作系统，类似于如今的Chrome OS。这引起了微软的警觉，这一跨越浏览器界限的作业系统，被微软视为是对Windows的直接威胁，微软担心网景抢占他们在操作系统和应用软件方面的市场份额。</p><h4 id="泥石流-IE"><a href="#泥石流-IE" class="headerlink" title="泥石流 IE"></a>泥石流 IE</h4><p>1995年，为了对抗网景导航者，微软从Spyglass公司(Spyglass是NCSA创建的商业化公司)购买了Mosaic浏览器的源代码和许可，同年8月，微软推出了基于此开发的<span class="strong">Internet Explorer</span>浏览器1.0版本。IE浏览器的发布引发了“浏览器大战”，网景和微软竭力为各自的产品推陈出新，以求占据更大的市场份额。</p><p>1996年，微软推出了IE3,这是第一款支持<span class="strong">CSS</span>的商用浏览器。</p><p>1997年9月，微软发布了<span class="strong">Trident</span>内核，并推出了第一个以该内核作为引擎的浏览器 IE4。事态开始逐渐失控，微软的团队制作了一个巨大的字母”E”模型并将它放在了网景总部的草坪上。网景的团队不甘示弱，推倒了模型并放上了Mozilla的恐龙吉祥物，并写上标语”Netscape 72，Microsoft 18”以嘲讽微软IE浏览器的市场份额比网景低。</p><p>随后，微软开始不讲武德，将IE集成到了Windows中进行捆绑发行，并投给了苹果1.5亿美元，让苹果撤销之前对微软的侵权指控，附加条件是让苹果在其Macintosh上内置IE浏览器。此外，微软在授权条款中，要求主机厂商们在桌面上展示IE的图标，并不得加入Netscape，否则以涨价方式作为处罚。</p><p>微软的垄断式发行卓有成效，当人们看到打开操作系统就有开箱即用的浏览器时，很少会有人再想到网景导航者了，更何况IE是免费的而网景导航者需要付费。微软的一系列操作让IE浏览器的市场份额很快暴涨，直至2002年，IE浏览器的市场份额达到恐怖的96%，比网景的峰值还高。</p><p>过高的市场占有率开始使微软养尊处优，没有了网景这一竞争对手的压力，微软放慢了对内核的更新进程，并开始奉行一套自己的Web标准，在IE浏览器中加入了VBScript，DHTML等不遵循W3C公开标准的专属技术，以巩固自己的霸主地位，IE浏览器开始变得臃肿而笨重。由于IE浏览器垄断了市场，不少网页开发者只能迎合微软的Web标准，公开的W3C标准反而不被关注，从而衍生出了一大堆只和IE专属技术契合的网站，使得一些网站只能使用IE浏览器打开。</p><p>此外，IE由于市场占有率高，已然成为了蠕虫病毒的主要攻击目标，IE浏览器一旦被发现安全漏洞，蠕虫病毒会由于IE的普及高速传播。IE的泥石流行径为web的发展带来了难以根治的后遗症，而微软的不正当竞争行径也使之背负了多年的反垄断指控。</p><h4 id="网景的继承-Mozilla火狐"><a href="#网景的继承-Mozilla火狐" class="headerlink" title="网景的继承 Mozilla火狐"></a>网景的继承 Mozilla火狐</h4><p>除了微软的垄断式打压，网景后期对浏览器的错误定位也成为了网景覆灭的导火索之一。网景在与微软的“浏览器大战”中过分追求为浏览器增加特色功能，将电子邮件、新闻组件、文件编辑等功能塞入了浏览器中，并将其更名为了 Netscape Communicator4.0（网景通讯家）。过多的组件造成整个软件渲染缓慢，臃肿不堪。并且其新增的“特色”功能并没有革命性的创新，反而逐渐脱离了W3C的标准，期间曾一度创造了臭名昭著的<span class="tips">&lt;blink&gt;</span>标签。欠缺的使用体验，再加上微软的流氓式打压，网景浏览器的市场份额一落千丈。</p><p>1998年1月，在与微软的“浏览器大战”中失利后，为了挽回市场，网景宣布旗下所有软件对公众免费，并开源了Netscape Communicator4.0的源代码。与此同时，网景发布了一个全新的开源项目Mozilla，其中包含了全新的排版引擎<span class="strong">Gecko</span>，并建立了非正式组织Mozilla，以支持后续的Netscape Communicator开发。</p><p>1998年10月，网景宣布Netscape Communicator5.0将使用全新的Gecko引擎，这引起了Netscape开发人员的不满，因为在此之前他们对旧引擎<span class="strong">Mariner</span>进行了长达六个月的改进工作，而此举意味着他们此前的努力将付诸东流。网景的盈利主要依靠网景导航者及其衍生产品的收益，主要支柱遭受巨大打击，此时的网景已经摇摇欲坠，内部进行了大量人员裁剪。诸多原因直接导致Netscape Communicator5.0的发布被极大地推迟了，而此前微软发布的IE4比旧版本的网景通讯家拥有更好的性能，包括对HTML4、CSS、DOM和ECMAScript等W3C标准的支持，市场的天平进一步向微软倾斜。</p><p>1998年11月，AOL(美国在线)公司以42亿美元、免税换股的方式收购了网景通讯公司。AOL在证实微软因滥用垄断能力而败诉后(此前微软因垄断问题在和苹果等公司打官司)，AOL向微软提出了索偿诉讼，指控微软在与网景的竞争中滥用垄断能力。2003年5月，微软和AOL达成和解协议，微软将向网景支付7.5亿美元，而AOL允许微软在7年无限制的使用和散布IE浏览器，AOL的这一举动带领网景走向了覆灭。</p><p>2000年11月，在推迟将近两年后，网景跳过了Netscape Communicator5.0，发布了基于Gecko引擎的Netscape 6，但此时已是IE5的天下。</p><p>2003年7月15日，AOL解散了网景公司，解雇了Gecko的开发人员，并将Gecko及其相关产品的知识产权交给了Mozilla组织，Mozilla组织接收了大量Gecko的开发人员。同一天，Mozilla基金会正式成立，其目的是保证Mozilla组织可以在没有网景以后能继续生存下去。</p><p>2004年11月，Mozilla发布了Firefox(火狐)1.0版本，起初，Firefox被命名为Phoenix，寓意网景导航者的欲火重生，但由于与一家科技公司重名而改为了Firebird，该名称又和一个数据库软件重名，最后Mozilla 将名称确定为了Firefox。</p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>Mozilla还负责运行维护MDN开发者平台，该平台提供了大量关于HTML、CSS、JavaScript和Web API的免费文档资料，是最好的Web开发资源平台之一。</div><h4 id="勤劳的蜜蜂-苹果safari"><a href="#勤劳的蜜蜂-苹果safari" class="headerlink" title="勤劳的蜜蜂 苹果safari"></a>勤劳的蜜蜂 苹果safari</h4><p>在safari之前，苹果Macintosh系列计算机所使用的默认浏览器为网景导航者、Cyberdog（苹果自行开发的浏览器，由于苹果经营不善该项目被裁掉）和IE。</p><p>2001年6月，苹果fork了由KDE社区(一个崇尚开源自由的软件社区)开发的开源渲染引擎KHTML和JS引擎KJS，然后利用适配器库将其移植到了苹果的Mac OS X系统上，并重命名为WebCore和JavaScriptCore。经过苹果二次开发的KHTML和KJS拥有了更为严谨的代码结构和更快的渲染速度，苹果将其命名为<span class="strong">Webkit</span>引擎。</p><p>2003年1月，苹果发布了首个以此为内核的<span class="strong">safari</span>浏览器</p><p>2005年6月，苹果开源了Webkit源代码，同年12月，添加了对SVG(矢量图)的支持</p><p>2007年，苹果开始对CSS进行拓展，使得CSS开始支持动画、过渡、2D和3D变换，并于2009年将其以草案的方式发布给了网维网联盟进行标准化，辛勤的苹果为CSS标准库提供了大量的草案和建议。</p><h4 id="新的引领-谷歌chrome"><a href="#新的引领-谷歌chrome" class="headerlink" title="新的引领 谷歌chrome"></a>新的引领 谷歌chrome</h4><p>Webkit的高效和稳定引来了谷歌的青睐，2008年9月，谷歌发布了以Webkit为引擎的<span class="strong">Chrome</span>浏览器,实际上，Chrome还使用了Mozilla等组织的诸多开源组件来增强性能。</p><p>2010年苹果发布了Webkit2，由于Webkit2使用的进程隔离技术与谷歌的沙箱设计存在冲突，谷歌决定在WebKit的基础上自行开发引擎。谷歌的工程师们fork了WebKit的Webcore渲染引擎，并对源代码作了大量的精简和修改，而JS引擎将谷歌自行开发。</p><p>2013年4月，谷歌发布并开源了全新的浏览器内核<span class="strong">Blink</span>，其名字来源于网景创建的臭名昭著的<span class="tips">&lt;blink&gt;</span>标签，谷歌的工程师戏虐的表示：”我们永远不会支持blink标签”。此外，谷歌还开发出了强悍的JavaScript解释器——V8引擎(基于Strongtalk)，大大加快了chrome的JS解析速度。</p><p>随着Blink的发布，Opera等浏览器厂商纷纷宣布将转向使用Blink引擎。2015年3月，微软宣布放弃IE浏览器的开发，转而使用Microsoft Edge取代IE。2020年，微软宣布Microsoft Edge浏览器将弃用EdgeHTML转而使用Blink内核。</p><h4 id="兢兢业业的Opear"><a href="#兢兢业业的Opear" class="headerlink" title="兢兢业业的Opear"></a>兢兢业业的Opear</h4><p>1994年，挪威电信公司Telenor的两名员工Jon Stephenson von Tetzchner和Geir Ivarsøy开始开发Opear浏览器，后来，他们离开了Telenor并创立了Opear Software，并于1995年4月发布了Opear浏览器</p><p>2003年1月，欧朋发布就基于<span class="strong">Presto</span>内核的Opera 7</p><p>2010年，欧朋首创了选项卡堆叠、鼠标手势等功能，这些功能后来也被其他浏览器大量应用</p><p>2013年2月，欧朋宣布放弃presto转而使用Webkit，2013年4月，欧朋跟随谷歌转而使用Blink引擎。</p><p>2016年2月，欧朋被360公司和昆仑万维收购</p><p>欧朋浏览器自发布以来严格遵守W3C标准，老老实实地开发使用符合W3C规范的技术拓展，然而“浏览器大战”与IE的横行造就了一大堆不符合W3C标准的网页，由于Opear不支持非标准的技术栈，这些网页在Opear上往往会解析错误，Opear的兢兢业业反而为其带来了负面的用户口碑，因为用户只会将页面的不解析归咎于浏览器的问题。</p><p>2001年10月，随着WindowsXP的发布，微软对MSN通讯软件进行了重大更新，随后就有用户反馈无法使用Opear浏览器进入MSN主页。微软随即甩锅解释是因为Opear浏览器不支持W3C的XHTML技术规范导致。Opear公司反驳表示，Opear浏览器比微软更能满足W3C标准，并给出了W3C验证服务结果：微软的MSN主页使用了非标准的编码。Opear公司还制作了一份标准XHTML的页面进行还击，经过测试，网景6、Opear 等浏览器能正确访问该页面，而IE 6则无法正常显示。随后，微软开始排挤Opear用户，谷歌在发布Chrome后也曾排挤Opear，直至Opear改用Blink引擎后才有所好转。</p><p>Opear在不断遭受排挤后开始考虑支持非标准拓展，Opear公司为浏览器添加了伪装功能，允许用户将Opear伪装为IE、Firefox等浏览器以解决某些网站排挤Opear的问题，兢兢业业的欧朋由于遵守W3C标准反而吃了不少亏，这不是欺负老实人吗!!（胡万腔）</p><h4 id="国产浏览器"><a href="#国产浏览器" class="headerlink" title="国产浏览器"></a>国产浏览器</h4><p>中国互联网发展最快的时间刚好遇上了IE浏览器霸榜的时代，由于IE的Trident内核市场占有率较高，许多网页设计者不得不将以IE的标准作为优先考量，直接导致许多政府机构、高校、企业、银行的网站只能在IE浏览器上正常访问，而在更支持W3C标准的safari、chrome、Firefox等浏览器反而会出现加载或解析错误的情况。为此，国内的浏览器厂商们整合了IE的Trident内核与苹果的Webkit内核，美其名曰双内核并以此作为宣传浏览器的噱头(其实都是别人家的内核)。兼容模式下，浏览器会启用Trident内核以适应脱离w3c标准的垃圾网页。</p><h3 id="浏览器UA标识"><a href="#浏览器UA标识" class="headerlink" title="浏览器UA标识"></a>浏览器UA标识</h3><p>UA为User Agent的简写，指浏览器等软件在网络协议中工作时，会向服务器等对等方提交一个特征字符串，方便对方识别应用类型、操作系统、软件版本号等信息。例如：由于手机屏幕和电脑屏幕尺寸相差巨大，网站设计者一般会为手机端和电脑端设计两个不同大小的网页(或者响应式网页)，当我们访问网站时，服务器会通过UA标识(或者屏幕大小)检测到我们使用的设备是手机还是电脑，从而返回相应的网页。浏览器UA的语法格式通常为：</p><div class="show"><span class="strong">&lt;product> /&lt;version> (&lt;system-information>) &lt;platform> (&lt;platform-details>) &lt;extensions></span></div><p>UA也起源于著名的“浏览器之战”，当时，由于网景首先开创使用了JavaScript、Frames框架等技术，使得网景导航者浏览器的使用体验一骑绝尘，当时的网景导航者支持图片嵌入、网页嵌入等技术，而Mosaic、Samba等一些比较旧的浏览器只支持显示简单的HTML文档。为了提高网站的使用体验，网站设计者们往往希望网页拥有比较前沿的技术设计，但用户的浏览器却不一定支持网站的新颖技术。解决这一问题，UA嗅探技术诞生了。通过UA，网站会动态识别访问用户的浏览器，如：如果是网景导航者，则返回带有Frames框架技术的高级网页内容，如果为Mosaic，则只需返回简单的HTML文档即可。</p><p>起初，网景的UA长这样：</p><div class="show"><code>Mozilla/1.0 (win3.1)</code></div><p>后来，IE浏览器诞生，IE及其他浏览器逐步追上了网景的脚步，并开始支持网景的特色功能，但由于它们起步较晚，绝大多数网站仍只支持为带有Mozilla标识的浏览器返回高级网页。于是乎，微软等公司的在UA中添加了Mozilla的标识来“欺骗”Web服务器，于是，IE浏览器的标识写为了：</p><div class="show"><code>Mozilla/1.22 (compatible;MSIE 2.0;Windows 95)</code></div><p>后来，网景飞升，留下了遗孤Mozilla ，Mozilla 打造 Gecko并发布了Firefox，Firefox的UA写为了</p><div class="show"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0</code></div><p>再后来，KDE社区开发出了KHTML引擎，并发布了嵌入式浏览器 Konqueror，但网页不给他们分发高级内容，他们很烦，于是他们也伪装成了Mozilla，并且表示KHTML跟Gecko一样好~</p><div class="show"><code>Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)</code></div><p>后来，苹果基于KHTML开发出了WebKit，他们又在KHTML的UA上套了一层娃</p><div class="show"><code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5</code></div><p>再再后来，谷歌又在WebKit基础上开发出了blink，他们也想套娃</p><div class="show"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13</code></div><p>于是，人人都是网景Mozilla</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>参考：<a href="https://webaim.org/blog/user-agent-string-history/">user-agent-string-history</a></div><h3 id="代码兼容性"><a href="#代码兼容性" class="headerlink" title="代码兼容性"></a>代码兼容性</h3><h4 id="CSS浏览器前缀"><a href="#CSS浏览器前缀" class="headerlink" title="CSS浏览器前缀"></a>CSS浏览器前缀</h4><p>为了兼容旧版本的浏览器，对于比较新颖的CSS样式我们需要添加浏览器前缀</p><div class="table"><table><thead><tr><th>浏览器</th><th>内核</th><th>前缀</th></tr></thead><tbody><tr><td>IE</td><td>Trident</td><td>-ms-</td></tr><tr><td>Firefox</td><td>Gecko</td><td>-moz-</td></tr><tr><td>Opera</td><td>Presto</td><td>-o-</td></tr><tr><td>Safari</td><td>WebKit</td><td>-webkit-</td></tr><tr><td>Chrome</td><td>WebKit</td><td>-webkit-</td></tr></tbody></table></div><h4 id="渲染内核"><a href="#渲染内核" class="headerlink" title="渲染内核"></a>渲染内核</h4><h5 id="双核浏览器"><a href="#双核浏览器" class="headerlink" title="双核浏览器"></a>双核浏览器</h5><p>对于双核浏览器，我们可以使用<span class="tips">meta</span>标签指定内核渲染网页，国内的双核浏览器一般是Trident内核和webkit内核，因此选其一。</p><div class="show">使用webkit渲染网页，用于提高渲染速度&lt;meta name="renderer" content="webkit"> 使用IE兼容内核，用于兼容为低版本IE浏览器&lt;meta name="renderer" content="ie-comp">使用IE标准内核，用于网站用了IE专属技术&lt;meta name="renderer" content="ie-stand"></div><h5 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h5><p><span class="tips">X-UA-Compatible</span>是IE8的一个专有<meta>属性，它用来指示IE8以上浏览器采用何种IE版本去渲染网页</p><p>常用值有：</p><div class="show">使用最高版本的IE内核渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;启用谷歌内嵌框架Chrome Frame(谷歌推出的IE插件)进行渲染，没有则使用最高版本的IE内核渲染（推荐使用）&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" /></div><p>其他还支持</p><div class="show">使用IE7内核渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=7" />值可并列，该值表示IE8降级使用IE7内核渲染，若有IE9则使用IE9&lt;meta http-equiv="X-UA-Compatible" content="IE=7;IE=9" /></div>]]></content>
    
    
    <summary type="html">了解Web发展的历史，本文包括超文本的由来、内核的发展、UA标识的语法组成，以及如何指定渲染引擎</summary>
    
    
    
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>基于certbot获取TLS证书</title>
    <link href="https://shiwei11.github.io/blog/2022/07/29/lets-encrypt/"/>
    <id>https://shiwei11.github.io/blog/2022/07/29/lets-encrypt/</id>
    <published>2022-07-29T06:58:33.000Z</published>
    <updated>2023-11-06T20:06:18.076Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>Let’s Encrypt 官网：<a href="https://letsencrypt.org/">https://letsencrypt.org/</a></div><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><h4 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title="Let’s Encrypt"></a>Let’s Encrypt</h4><p>Let’s Encrypt 是由 ISRG (Internet Security Research Group)推出的免费安全证书计划，我们可以利用Let’s Encrypt 提供的TLS证书，在我们的网站上部署HTTPS 服务。</p><h4 id="ISRG"><a href="#ISRG" class="headerlink" title="ISRG"></a>ISRG</h4><p>ISRG（Internet Security Research Group ，互联网安全研究小组）是一个公益性的组织，该公益组织旨在减少资金、技术、教育障碍，以保护互联网上的通信，推动全球网站的HTTPS化。ISRG成立于2013 年 5 月，起初由Mozilla、电子前沿基金会(EFF)、密歇根大学、思科和 Akamai共同建立，后来又得了谷歌、亚马逊、讯飞、IBM、RedHat、Linux基金会等大厂商的赞助，所以他们的技术和证书安全是可以保障的。</p><h4 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h4><p>Certbot 是由电子前沿基金会 (EFF)制作的免费开源软件工具，用于在网站上申请、管理、使用由Let’s Encrypt颁发的证书，证书每60天更新一次。</p><h3 id="前置需要"><a href="#前置需要" class="headerlink" title="前置需要"></a>前置需要</h3><ul><li>一台可用的服务器，并拥有<span class="tips">root</span>权限</li><li>安装了Web服务，以<span class="tips">Nginx</span>为例</li><li>一个可用的域名，并解析到了该服务器上</li></ul><h3 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h3><h4 id="官方安装"><a href="#官方安装" class="headerlink" title="官方安装"></a>官方安装</h4><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>certbot官方文档：<a href="https://certbot.eff.org/">https://certbot.eff.org/</a></div><p>官网文档里给出了不同系统的详细安装方法，但在安装过程中会遇到不少问题，有些甚至涉及到需要重新编译Linux内核，这在已经部署业务的服务器上往往是无法实现的。</p><p>以CentOS7为例，根据官方的文档，安装Certbot需要先添加EPEL存储库，然后从中安装snapd软件包，但安装snapd需要解决诸多依赖问题：</p><ul><li>安装snapd需要Linux内核支持 SquashFS 文件系统</li><li>手动编译安装的SquashFS 文件系统，yum可能无法识别</li><li>内核编译时需要启用CONFIG_DEVPTS_MULTIPLE_INSTANCES 选项，如果没有需要重新编译内核</li></ul><h4 id="通过pip3安装"><a href="#通过pip3安装" class="headerlink" title="通过pip3安装"></a>通过pip3安装</h4><p>如果无法安装snapd，那只能绕过它，通过其他包管理工具安装，以pip（python包管理工具）为例</p><p>安装python并通过pip安装certbot</p><pre><code>yum install -y python3 && pip3 install certbot</code></pre><h5 id="pip3版本较低报错问题"><a href="#pip3版本较低报错问题" class="headerlink" title="pip3版本较低报错问题"></a>pip3版本较低报错问题</h5><p>在安装certbot时，如果yum源中的pip3版本较低，可能会导致模块导入失败，从而报错</p><div class="shell">Complete output from command python setup.py egg_info:            =============================DEBUG ASSISTANCE==========================            If you are seeing an error here please try the following to            successfully install cryptography:            Upgrade to the latest pip and try again. This will fix errors for most            users. See: https://pip.pypa.io/en/stable/installing/#upgrading-pip            =============================DEBUG ASSISTANCE==========================    Traceback (most recent call last):      File "&lt;string>", line 1, in &lt;module>      File "/tmp/pip-build-2bwzqu_0/cryptography/setup.py", line 14, in &lt;module>        from setuptools_rust import RustExtension    ModuleNotFoundError: No module named 'setuptools_rust'    ----------------------------------------Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-2bwzqu_0/cryptography/</div><p>此时根据报错提示，升级pip3到最新版本即可</p><pre><code>sudo pip3 install --upgrade pip</code></pre><p>升级完毕再安装certbot</p><pre><code>pip3 install certbot</code></pre><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><h4 id="验证域名"><a href="#验证域名" class="headerlink" title="验证域名"></a>验证域名</h4><p>申请证书前，Let’s Encrypt需要先验证域名，以确认用户拥有对域名的控制权。验证通过后，certbot会立马进入申请流程，因此下述命令会同时验证域名和申请证书。certbot针对不同的web服务器和需求，有多种不同的验证方式：</p><h5 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1. Nginx"></a>1. Nginx</h5><p>如果部署了Nginx，可以直接执行（但要确保安装了certbot-nginx插件）</p><pre><code>sudo certbot --nginx</code></pre><p>certbot将自动获取域名，并在进入证书申请流程时让你确认域名，也可以在执行上述命令时通过添加<span class="tips">-d</span>参数来指定域名，如：</p><div class="show"><code>sudo certbot -&zwnj;-nginx -d  shiwivi.com -d  www.shiwivi.com</code></div><p>可以通过<span class="tips">-&zwnj;-email</span>来添加邮箱，Let’s Encrypt会在证书即将到期时发邮件通知你更新证书。</p><div class="show"><code>sudo certbot -&zwnj;-nginx --email xxxx@gmail.com -d  shiwivi.com -d  www.shiwivi.com</code></div><p>如果不添加上述参数，certbot会在验证通过后要求你添加，邮箱一般只需要在首次验证证书或者更改邮箱时添加。</p><h5 id="2-Apache"><a href="#2-Apache" class="headerlink" title="2. Apache"></a>2. Apache</h5><p>Apache中的验证方法与上类似</p><pre><code>sudo certbot --apache</code></pre><h5 id="3-Webroot模式"><a href="#3-Webroot模式" class="headerlink" title="3. Webroot模式"></a>3. Webroot模式</h5><p>上述方法会重启我们的web服务以重新加载配置文件，如果我们希望在颁发证书时，不重启web服务，则可以使用webroot模式。webroot模式下，certbot 会利用已经部署的 web 服务，在其 web 服务根目录下创建名为<span class="tips">/.well-known/acme-challenge</span>的隐藏文件，然后由 Let’s Encrypt 服务端通过域名来访问该隐藏文件，从而完成验证。</p><p>因此，在执行命令时，我们需要添加<span class="tips">-w</span>参数来引导certbot找到web服务的根目录</p><pre><code>certbot certonly --webroot -w 网站根目录 -d 域名</code></pre><p>如：Nginx默认放置网页的根目录为：<span class="tips">/usr/local/nginx/html</span>，则对应命令为</p><div class="show"><code>certbot certonly --webroot -w /usr/local/nginx/html -d shiwivi.com</code></div><h5 id="3-Standalone模式"><a href="#3-Standalone模式" class="headerlink" title="3. Standalone模式"></a>3. Standalone模式</h5><p>如果服务器上没有部署任何web服务，或者不想使用已部署的服务，则可以使用Standalone模式，该模式下，certbot 会自动运行一个 web server 来进行验证。该服务需要占用<span class="tips">80</span>端口，如果我们自己的服务器上已经有 web server 正在运行 （如 Nginx 或 Apache ）并且占用了80端口，则使用Standalone前应该关闭相关服务或修改端口。</p><pre><code>certbot certonly --standalone -d 域名</code></pre><p>可以在命令中指定验证的端口和协议</p><div class="show"><code>certbot certonly --standalone --&lt;challenge-type>-address  -d 域名</code></div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>更多验证方法详见官方文档：<a href="https://eff-certbot.readthedocs.io/en/stable/">https://eff-certbot.readthedocs.io/en/stable/</a></div><h4 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h4><p>certbot完成认证后会开始进入申请流程，初次申请证书，可能需要经历以下流程：</p><ul><li>certbot会提示你阅读并同意使用者条款</li><li>让你输入一个email地址以推送消息，在证书快到期时，lets encrypt会发邮件提醒你及时更新证书</li><li>询问是否愿意将该邮箱提供给EFF，他们会推送有关lets encrypt 的资讯</li></ul><p>邮箱的添加可以在一开始使用<span class="tips"></span></p><p>证书申请成功后，certbot会返回如下提示信息，其中较为重要的信息包括证书与密钥路径，证书到期时间</p><div class="shell">IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at:   /etc/letsencrypt/live/newyear1234.xyz/fullchain.pem   Your key file has been saved at:   /etc/letsencrypt/live/newyear1234.xyz/privkey.pem   Your certificate will expire on 2022-10-27. To obtain a new or   tweaked version of this certificate in the future, simply run   certbot again. To non-interactively renew *all* of your   certificates, run "certbot renew" - If you like Certbot, please consider supporting our work by:<p>   Donating to ISRG / Let’s Encrypt:   <a href="https://letsencrypt.org/donate">https://letsencrypt.org/donate</a><br>   Donating to EFF:                    <a href="https://eff.org/donate-le">https://eff.org/donate-le</a></div></p><h4 id="插件未安装报错问题"><a href="#插件未安装报错问题" class="headerlink" title="插件未安装报错问题"></a>插件未安装报错问题</h4><p>以nginx为例，执行<span class="tips">sudo certbot -&zwnj;-nginx</span>时，可能会有nginx插件未被正确安装报错</p><div class="shell">The requested nginx plugin does not appear to be installed</div><p>安装nginx插件</p><pre><code>yum install python-certbot-nginx</code></pre><p>问题叠问题，如果源中没有该插件包，又可能会遇到报错提示无有效的包</p><div class="shell">No package python-certbot-nginx available.Error: Nothing to do</div><p>此时需要更换一下repo 源，更换前记得先将自己的源的备份</p><pre><code>yum remove -y epel-release  # 先移除当前的包</code></pre><pre><code>yum clean all -v     # 清除所有下载缓存的包，并显示过程</code></pre><pre><code>yum makecache        # 重新将远程服务器的包下载缓存到本地</code></pre><pre><code>yum install -y epel-release # 重新安装 epel </code></pre><p>安装完epel，再重新尝试安装插件，安装完成就可以开始申请证书了</p><pre><code>yum install python-certbot-nginx</code></pre><h4 id="web服务无法找到报错问题"><a href="#web服务无法找到报错问题" class="headerlink" title="web服务无法找到报错问题"></a>web服务无法找到报错问题</h4><p>执行<span class="tips">sudo certbot -&zwnj;-nginx</span>时，还可能会遇到 certbot 无法找到 web server 或配置文件报错，这是路径问题，可以建一个软链接到 /etc/nginx 目录下</p><pre><code>ln -s /usr/local/nginx/conf/ /etc/nginx</code></pre><p>或者在申请证书时手动指定nginx配置文件路径</p><pre><code>certbot --nginx-server-root /usr/local/nginx/conf</code></pre><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><p>证书申请成功后，相关文件会放置在<span class="tips">/etc/letsencrypt</span>目录下，一般就用得到证书和密钥文件</p><h4 id="密钥与证书"><a href="#密钥与证书" class="headerlink" title="密钥与证书"></a>密钥与证书</h4><p>证书和密钥位于 <span class="tips">/etc/letsencrypt/live/域名.xx/</span> 路径下，该路径下有如下几个文件（配置时一般只需要fullchain.pem和privkey.pem文件）：</p><ul><li><span class="strong">fullchain.pem：</span>完整的证书链文件，包含了cert.pem和chain.pem文件中的内容</li><li><span class="strong">privkey.pem：</span>证书对应的私钥</li><li>cert.pem：证书文件，需要与chain.pem文件结合使用</li><li>chain.pem：链文件，包含了浏览器解析所需的其他全部证书，比如根证书和中间证书</li><li>README：说明文件</li></ul><h4 id="通用配置文件"><a href="#通用配置文件" class="headerlink" title="通用配置文件"></a>通用配置文件</h4><p>在<span class="tips">/etc/letsencrypt</span>路径下会生成Nginx的通用配置文件<span class="tips">options-ssl-nginx.conf</span></p><div class="shell">ssl_session_cache shared:le_nginx_SSL:10m;ssl_session_timeout 1440m;<p>ssl_protocols TLSv1.2;<br>ssl_prefer_server_ciphers off;</p><p>ssl_ciphers “FCDHE-FCLSA….”;</div></p><ul><li>ssl_session_cache：会话缓存</li><li>ssl_session_timeout：用户会话缓存失效时间，如果对安全性有较高要求，可以降低此值</li><li>ssl_protocols：加密协议</li><li>ssl_prefer_server_ciphers：是否开启服务端加密算法优先</li><li>ssl_ciphers：加密算法列表</li></ul><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><p>在<span class="tips">/etc/letsencrypt</span>路径下还有一个用于密钥交换算法的Diffie-Hellman 密钥<span class="tips">ssl-dhparams.pem</span></p><h4 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h4><p><span class="tips">/etc/letsencrypt/archive</span>和<span class="tips">/etc/letsencrypt/keys</span>包含所有以前的密钥和证书，而<span class="tips">/etc/letsencrypt/live</span>目录下保存了最新的证书和密钥</p><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>默认情况下，certbot 的日志文件位于/var/log/letsencrypt 路径下。且默认情况下，一旦日志目录中有 1000 条日志，certbot 就会开始日志轮替。</p><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><div class="show">server {listen 443 ssl;<p>#配置SSL证书和密钥路径<br>ssl_certificate    /etc/letsencrypt/live/域名/fullchain.pem;<br>ssl_certificate_key    /etc/letsencrypt/live/域名/privkey.pem;</p><p>#可以将certbot生成的通用配置文件包含进去，自由选择<br>include    /etc/letsencrypt/options-ssl-nginx.conf;</p><p>#使用生成的Diffie-Hellman 密钥，自由选择<br>ssl_dhparam    /etc/letsencrypt/ssl-dhparams.pem;<br>……<br>}</div></p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>Diffie-Hellman密钥用于密钥交换</div><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="测试自动续订"><a href="#测试自动续订" class="headerlink" title="测试自动续订"></a>测试自动续订</h4><ul><li><span class="strong">sudo certbot renew -&zwnj;-dry-run</span> 测试更新证书</li></ul><p>如果测试成功，certbot会返回成功信息</p><div class="shell">- - - - -Account registered.Simulating renewal of an existing certificate for newyear110.xyz- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Congratulations, all simulated renewals succeeded:   /etc/letsencrypt/live/newyear110.xyz/fullchain.pem (success)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </div><h5 id="插件未安装报错"><a href="#插件未安装报错" class="headerlink" title="插件未安装报错"></a>插件未安装报错</h5><p>在测试续订时，如果遇到插件未安装的报错，则需要安装nginx插件</p><div class="shell">Failed to renew certificate newyear110.xyz with error: The requested nginx plugin does not appear to be installed</div><p>安装<span class="tips">letsencrypt-nginx</span>插件</p><pre><code>pip3 install -U letsencrypt-nginx</code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>更多关于插件未安装的报错，可以查看github上的Issues，上述解决方法也来源于该贴：<a href="https://github.com/certbot/certbot/issues/1736">https://github.com/certbot/certbot/issues/1736</a></div><h4 id="续订证书"><a href="#续订证书" class="headerlink" title="续订证书"></a>续订证书</h4><ul><li><span class="strong">certbot renew</span> 自动更新30天内到期的证书（推荐）</li><li><span class="strong">certbot renew -&zwnj;-force-renewal</span> 强制更新未到期的证书</li></ul><p>在初次申请证书时，certbot会记住所使用的配置和插件，并在续订时使用相同的配置和插件。如果需要更改配置（如：修改文件路径），则需要以下步骤</p><ol><li>在命令行中使用修改以后的配置进行一次测试自动续订</li><li>测试成功，说明新的配置是可以运行的，再执行一次证书更新（时间未到就使用强制更新），这将保存新的配置</li></ol><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>CA机构会限制证书颁发速度并阻止用户在短时间内多次续订同一个域名的证书，所以不要在短时间内多次执行强制更新证书操作</div><h4 id="查看证书列表"><a href="#查看证书列表" class="headerlink" title="查看证书列表"></a>查看证书列表</h4><ul><li><span class="strong">certbot certificates</span> 查看证书</li></ul><p>会返回当前所有域名的证书情况，包括证书名、 证书序列号、密钥类型、到期时间、证书路径、私钥路径信息</p><div class="show">Found the following certs:  Certificate Name: newyear110.xyz    Serial Number: 34829c6e3465f2b1b90db11c36111480280    Key Type: RSA    Domains: newyear110.xyz    Expiry Date: 2022-10-27 11:47:25+00:00 (VALID: 87 days)    Certificate Path: /etc/letsencrypt/live/newyear110.xyz/fullchain.pem    Private Key Path: /etc/letsencrypt/live/newyear110.xyz/privkey.pem</div><h4 id="吊销与删除证书"><a href="#吊销与删除证书" class="headerlink" title="吊销与删除证书"></a>吊销与删除证书</h4><p>删除与吊销证书前，应当从web服务器软件的配置文件中删除对对应证书的引用</p><ul><li><span class="strong">certbot revoke -&zwnj;-cert-name 域名.xxx</span> 吊销证书(根据域名)</li><li><span class="strong">certbot revoke -&zwnj;-cert-path /etc/letsencrypt/live/域名.xxx/cert.pem</span> 吊销证书(根据路径)</li><li><span class="strong">certbot delete -&zwnj;-cert-name 域名.xxx</span> 删除指定证书</li><li><span class="strong">certbot delete</span> 从列表中选择删除证书</li></ul><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>官方命令和文档：<a href="https://eff-certbot.readthedocs.io/en/stable/using.html">https://eff-certbot.readthedocs.io/en/stable/using.html</a></div>]]></content>
    
    
    <summary type="html">用于部署https服务，certbot官方文档中的步骤可能需要重新编译Linux内核，可以使用python包管理工具绕开</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>路由与路由守卫</title>
    <link href="https://shiwei11.github.io/blog/2022/07/16/%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/"/>
    <id>https://shiwei11.github.io/blog/2022/07/16/%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</id>
    <published>2022-07-16T04:55:14.000Z</published>
    <updated>2022-07-19T15:06:13.311Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>vue路由官方网站：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></div><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>Vue Router 是Vue的官方路由插件，用于构建单页应用</li><li>页面不刷新，配合ajax实现页面的局部更新，并响应式更新地址栏URL</li><li>在工程中，普通组件一般放在components下，而路由组件放于pages目录下</li><li>切换组件时，未调用的组件是被销毁的，调用时被挂载</li><li>整个应用由一个<span class="tips">router</span>(路由器)统一管理，通过<span class="tips">$router</span>调用</li><li>但每个路由组件都有自己的<span class="tips">$route</span>属性</li></ul><h4 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue router"></a>安装vue router</h4><p>vue2的工程使用vue-router3，vue3的工程使用vue-router4，版本需要对应，这里以安装vue-router3为例</p><p>在脚手架中执行：<br><code><pre>npm i vue-router@3</pre></code></p><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p>案例：通过组件嵌套，实现功能</p><ol><li>在app单个页面中通过按钮实现Home和About页面的切换</li><li>About页面中嵌套aboutMe和aboutWeb页面</li></ol><p><span class="strong">1. 新建pages目录，存放Home.vue、About.vue、aboutMe、aboutWeb组件</span></p><p>Home.vue文件:</p><pre><code>&lt;template>  &lt;div class="home">    &lt;h2>Home页面&lt;/h2>  &lt;/div>&lt;/template>&lt;script>export default &#123;    name:'pageHome'  &#125;&lt;/script></code></pre><p>About.vue文件:</p><pre><code>&lt;template>  &lt;div class="about">    &lt;h2>About页面&lt;/h2>    &lt;div class="about-btn">    &lt;!--router-link标签路由切换按钮的两种写法，该标签最后会被解析为a标签-->    &lt;!--1. 根据路径调用组件-->    &lt;router-link to="/about/aboutWeb">关于网页&lt;/router-link>     &lt;router-link to="/about/aboutMe">关于我&lt;/router-link>     &lt;!--2. 根据路由规则中的name属性调用组件-->    &lt;router-link :to="&#123;name: 'aboutme'&#125;">关于网页&lt;/router-link>     &lt;router-link :to="&#123;name: 'aboutweb'&#125;">关于我&lt;/router-link>     &lt;/div>    &lt;div class="about-content">    &lt;!--子组件显示的位置-->    &lt;router-view>&lt;/router-view>     &lt;/div>  &lt;/div>&lt;/template> &lt;script> export default &#123;     name:'pageAbout' &#125;&lt;/script></code></pre><p>aboutWeb.vue文件 (aboutMe.vue类似)</p><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">&#123;&#123;t&#125;&#125;&lt;/li>    &lt;/ul>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:&#123;                前端:'html/css/javaScript',                后端:'java',                系统:'CentOS7',                服务器:'nginx'            &#125;        &#125;    &#125; &#125;&lt;/script></code></pre><p><span class="strong">2. 新建router目录，新建index.js文件用于创建路由器</span><br>index.js文件：</p><pre><code>// 引入vueRouter插件import VueRouter from "vue-router";//引入路由组件import Home from '../pages/pageHome'import About from '../pages/pageAbout'import aboutMe from '../pages/aboutMe'import aboutWeb from '../pages/aboutWeb'// 创建路由器export default new VueRouter(&#123;    // 创建路由规则一个&#123;&#125;内为一条路由    routes:[        &#123;            name: 'home',    //路由规则指定的组件别名            path:'/home',   //路由路径            component:Home //调用的组件        &#125;,        &#123;               name: 'about',            path:'/about',            component:About,            children:[     //组件嵌套                &#123;                       name:'aboutme',                    path:'aboutMe',                    component:aboutMe                &#125;,                &#123;                       name:'aboutweb',                    path:'aboutWeb',                    component:aboutWeb                &#125;            ]        &#125;    ] &#125;)</code></pre><p><span class="strong">3. 在main.js中引入路由器</span></p><pre><code>import Vue from 'vue'import App from './App.vue'// 引入vue-routerimport VueRouter from 'vue-router'// 使用vue-routerVue.use(VueRouter)// 引入创建的路由器import router from './router'new Vue(&#123;  render: h => h(App),  router:router   //配置路由器&#125;).$mount('#app')</code></pre><p><span class="strong">4. 在App中调用路由组件</span></p><pre><code>&lt;template>  &lt;div id="app">    &lt;div class="btn">      &lt;!-- active-class用于指定该链接按钮被选中时生效的样式-->      &lt;router-link class="link" active-class="active" to="/home">Home&lt;/router-link>      &lt;router-link class="link" active-class="active" to="/about">About&lt;/router-link>      &lt;!-- 同样，to可以写为对象形式 -->      &lt;router-link class="link" active-class="active" :to="&#123;name:'home'&#125;">Home&lt;/router-link>      &lt;router-link class="link" active-class="active" :to="&#123;name:'about'&#125;">About&lt;/router-link>    &lt;/div>    &lt;div class="content">      &lt;!-- 指定组件显示的位置 -->      &lt;router-view>&lt;/router-view>    &lt;/div>  &lt;/div>&lt;/template>&lt;script> export default &#123;  name:'App', &#125;&lt;/script></code></pre><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a>query传参</h4><p>父组件可通过向<span class="tips"> to </span>属性添加参数进行传参，类似于带参数的http请求，子路由可通过<span class="tips">$route.query.参数名</span>读取数据</p><p>案例：为aboutWeb组件添加子组件webTech，并由aboutWeb向webTech传参</p><h5 id="方法1：通过字符串传参"><a href="#方法1：通过字符串传参" class="headerlink" title="方法1：通过字符串传参"></a>方法1：通过字符串传参</h5><p>在路由路径后添加查询字符串<span class="tips"> ? </span>，并在之后以键值对的方式传参。</p><p>父组件 aboutWeb.vue</p><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">        &lt;!-- 字符串写法 -->        &lt;!-- 注意：由于to前使用了:解析js语法，因此要添加``将语句解析为字符串 -->        &lt;router-link :to="`/about/aboutWeb/webTech?name=$&#123;t.name&#125;&lang=$&#123;t.language&#125;`">&#123;&#123;t.name&#125;&#125;&lt;/router-link>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'框架',language:'vue'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125; &#125;&lt;/script></code></pre><h5 id="方法2：通过对象传参"><a href="#方法2：通过对象传参" class="headerlink" title="方法2：通过对象传参"></a>方法2：通过对象传参</h5><pre><code>&lt;template>  &lt;div>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">        &lt;!-- 对象写法 -->            &lt;router-link :to="&#123;            path:'/about/aboutWeb/webTech',            query:&#123;                name:t.name,                lang:t.language            &#125;            &#125;">            &#123;&#123;t.name&#125;&#125;            &lt;/router-link>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'框架',language:'vue'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125; &#125;&lt;/script></code></pre><h5 id="子路由读取参数"><a href="#子路由读取参数" class="headerlink" title="子路由读取参数"></a>子路由读取参数</h5><p>webTech.vue文件：</p><pre><code>&lt;template>  &lt;div class="show">  &lt;!-- 读取数据 -->    &lt;span class="tech-name">&#123;&#123;$route.query.name&#125;&#125;：&lt;/span>    &lt;span class="tech-lang">&#123;&#123;$route.query.lang&#125;&#125;&lt;/span>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'webTech' &#125;&lt;/script></code></pre><h4 id="params传参"><a href="#params传参" class="headerlink" title="params传参"></a>params传参</h4><h5 id="方法1：通过字符串传参-1"><a href="#方法1：通过字符串传参-1" class="headerlink" title="方法1：通过字符串传参"></a>方法1：通过字符串传参</h5><p>通过字符串传参时，必须在配置路由规则时在<span class="tips">path</span>路径中指定解析的参数</p><pre><code> &#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    path:'webTech/:name/:lang', //在路径中解析参数    conpontent:webTech  &#125;]      &#125;</code></pre><p>父组件通过附带参数的路径传输参数</p><pre><code>&lt;router-link :to="`/about/aboutWeb/webTech?name=$&#123;t.name&#125;&lang=$&#123;t.language&#125;`">&#123;&#123;t.name&#125;&#125;&lt;/router-link></code></pre><p>子组件通过<span class="tips">$route.params.参数名</span>读取参数</p><pre><code>&lt;span class="tech-name">&#123;&#123;$route.params.name&#125;&#125;&lt;/span>&lt;span class="tech-lang">&#123;&#123;$route.params.lang&#125;&#125;&lt;/span></code></pre><h5 id="方法2：通过对象传参-1"><a href="#方法2：通过对象传参-1" class="headerlink" title="方法2：通过对象传参"></a>方法2：通过对象传参</h5><p>通过对象传参时，<span class="tips">to</span>属性不能再使用<span class="tips">path</span>调用组件，而需要使用<span class="tips">name</span>属性，因此路由规则中一定需要给予组件name属性</p><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech' //必须    path:'webTech/:name/:lang', //必须    conpontent:webTech  &#125;]      &#125;</code></pre><p>传参的父组件</p><pre><code>&lt;router-link :to="&#123;            name:'webtech', //不能使用path            params:&#123;                name:t.name,                lang:t.language            &#125;&#125;">            &#123;&#123;t.name&#125;&#125;&lt;/router-link></code></pre><p>子组件通过<span class="tips">$route.params.参数名</span>读取参数，代码同上</p><h4 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h4><p>当需要大量调用参数时，频繁使用$route.query增加了代码量，可以在路由中配置<span class="tips">props</span>属性简化代码。props属性支持三种配置方法。</p><h5 id="1-对象形式，传输固定参数"><a href="#1-对象形式，传输固定参数" class="headerlink" title="1. 对象形式，传输固定参数"></a>1. 对象形式，传输固定参数</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech',    conpontent:webTech,    //对象形式，传输固定参数    props:&#123; name:'框架',            lang:'Vue'&#125;  &#125;]      &#125;</code></pre><h5 id="2-函数形式，传输指定参数-用query"><a href="#2-函数形式，传输指定参数-用query" class="headerlink" title="2. 函数形式，传输指定参数(用query)"></a>2. 函数形式，传输指定参数(用query)</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech',    conpontent:webTech,    //对象形式，传输固定参数    pros(route)&#123;      return &#123;        name: route.query.name,        lang: route.query.language      &#125;    &#125;  &#125;]      &#125;</code></pre><h5 id="3-布尔值，自动传输所有params参数"><a href="#3-布尔值，自动传输所有params参数" class="headerlink" title="3. 布尔值，自动传输所有params参数"></a>3. 布尔值，自动传输所有params参数</h5><pre><code>&#123;     name:'aboutweb',  path:'aboutWeb',  component:aboutWeb,  children:[&#123;    name:'webtech'     path:'webTech/:name/:lang', //自动传输所有参数    conpontent:webTech,    //布尔值形式    pros: true  &#125;]      &#125;</code></pre><h5 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h5><p>子组件需要通过<span class="tips">props</span>属性接收参数</p><pre><code>&lt;span>&#123;&#123;name&#125;&#125;&lt;/span> //直接调用&lt;span>&#123;&#123;lang&#125;&#125;&lt;/span>export default&#123;   name:'webTech',  pros:['name','lang'] //接收参数   &#125;</code></pre><h3 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h3><p>路由导航分为声明式和编程式</p><ul><li><span class="strong">声明式：</span>通过&lt;router-link&gt;配置to属性实现跳转</li><li><span class="strong">编程式：</span>通过调用push、back等API跳转组件</li></ul><h4 id="路由导航与浏览器历史记录"><a href="#路由导航与浏览器历史记录" class="headerlink" title="路由导航与浏览器历史记录"></a>路由导航与浏览器历史记录</h4><p>浏览器历史记录默认为<span class="tips">push</span>状态，组件的跳转会记录到历史记录中，通过浏览器的前进/后退按钮，或者调用<span class="tips">go</span>、<span class="tips">back</span>等API，能根据历史记录实现页面的前进、回退。当浏览器历史记录切换为<span class="tips">replace</span>状态时，浏览器会使用当前页面的记录替换掉上一条历史记录。</p><pre><code> &lt;--跳转到About页面后，About页面的历史记录会替换掉该页的历史记录，此时无法再使用浏览器的回退按钮返回该页面了-->&lt;router-link replace to="...">跳转到About页面&lt;/router-link></code></pre><h4 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h4><p>不借助&lt;router-link&gt;标签，实现路由跳转<br>API：</p><ul><li><span class="strong">push：</span>跳转到指定路由组件</li><li><span class="strong">replace：</span>跳转到指定路由组件并替换浏览器历史记录</li><li><span class="strong">back：</span>回退</li><li><span class="strong">forward：</span>前进(需要之前回退过)</li><li><span class="strong">go(值)：</span>根据值前进/回退指定次数</li></ul><p>eg：通过按钮实现(或div)实现路由跳转</p><pre><code>&lt;template>  &lt;div>   &lt;button class="link" @click="backTo">回退&lt;/button>    &lt;button class="link" @click="forwardTo">前进&lt;/button>    &lt;button class="link" @click="goTo">跳转&lt;/button>    &lt;ul>        &lt;li v-for="(t,index) in tech" :key="index">            &lt;button @click="pushTo(t)">push&lt;/button>            &lt;button @click="replaceTo(t)">replace&lt;/button>        &lt;/li>    &lt;/ul>    &lt;router-view>&lt;/router-view>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'aboutWeb',    data()&#123;        return&#123;            tech:[                &#123;name:'前端',language:'html/css/javaScript'&#125;,                &#123;name:'后端',language:'java'&#125;,                &#123;name:'系统',language:'CentOS7'&#125;,                &#123;name:'服务器',language:'nginx'&#125;,                ]            &#125;        &#125;,    methods:&#123;        backTo()&#123;      this.$router.back() //回退一次    &#125;,    forwardTo()&#123;      this.$router.forward() //前进一次    &#125;,    goTo()&#123;      this.$router.go(-2) //，回退2步，正数前进，负数后退    &#125;,        pushTo(m)&#123;    //跳转到指定组件            this.$router.push(&#123;                path:'/about/aboutWeb/webTech',                query:&#123;                name:m.name,                lang:m.language            &#125;            &#125;)        &#125;,        replaceTo(n)&#123;  //跳转到指定组件并替换上一个历史记录            this.$router.replace(&#123;                path:'/about/aboutWeb/webTech',                query:&#123;                name:n.name,                lang:n.language            &#125;            &#125;)        &#125;    &#125; &#125;&lt;/script></code></pre><h3 id="路由组件的缓存"><a href="#路由组件的缓存" class="headerlink" title="路由组件的缓存"></a>路由组件的缓存</h3><p>当组件进行切换时，原组件会被销毁，原组件中未保存的表单内容等数据同时也会被删除，此时，可以使用<span class="tips">&lt;keep-alive&gt;</span>标签阻止组件被销毁，保留数据。</p><pre><code> //缓存多组件使用 :include="['组件1','组件2',...]"&lt;keep-alive include="aboutMe">   &lt;router-view>&lt;/router-view>&lt;/keep-alive></code></pre><h3 id="路由独有生命周期"><a href="#路由独有生命周期" class="headerlink" title="路由独有生命周期"></a>路由独有生命周期</h3><ul><li><span class="strong">activated：</span>当组件被激活时(显示到页面)</li><li><span class="strong">deactivated：</span>当组件失活时<br>当组件被&lt;keep-alive&gt;时，组件不会被销毁，在切换组件时created、destory等钩子函数不会执行，此时可以使用activated、deactivated替代。</li></ul><p>eg：使某组件在激活时启用定时器，失活时关闭</p><pre><code> export default &#123;  name:'webTech',  data()&#123;.....&#125;,  activated()&#123;            let timer=setInterval(....);            &#125;,  deactivated()&#123;            clearInterval(this.timer)            &#125; &#125;</code></pre><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p> 在切换组件时，可借助路由守卫来阻止/放行组件的跳转，常用于判断用户是否有权限访问，无权限时阻止访问,也可用于在组件跳转前后执行某些功能。</p><h4 id="前置、后置路由守卫-全局"><a href="#前置、后置路由守卫-全局" class="headerlink" title="前置、后置路由守卫(全局)"></a>前置、后置路由守卫(全局)</h4><p> 该路由守卫写于路由器配置文件中</p><ul><li><span class="strong">beforeEach((to,from,next)=&gt;{ })：</span>前置路由守卫，在<span class="tips">初始化、路由跳转前</span>执行，接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行</li><li><span class="strong">beforeEach((to,from)=&gt;{ })：</span>后置路由守卫，在<span class="tips">路由跳转后</span>执行，接收to,from两个参数</li></ul><p>eg: 检查用户是否为指定用户，不是则禁止访问aboutWeb和aboutMe组件</p><pre><code> import VueRouter from "vue-router"; import Home from '../pages/pageHome' import About from '../pages/pageAbout' import aboutMe from '../pages/aboutMe' import aboutWeb from '../pages/aboutWeb' import webTech from '../pages/webTech' const router= new VueRouter(&#123;    routes:[        &#123;            name:'home',            path:'/home',               component:Home,             meta:&#123;title:'首页'&#125;//meta为自定义属性，程序员可自定义添加任何参数        &#125;,        &#123;            name:'about',            path:'/about',            component:About,            meta:&#123;title:'关于'&#125;,            children:[                &#123;                    name:'aboutme',                    path:'aboutMe',                    component:aboutMe,                    meta:&#123;isAuth:true,//标识该组件是否需要鉴别权限                          title:'关于我'&#125;//用于组件跳转后修改地址栏标题                &#125;,                &#123;                    name:'aboutweb',                    path:'aboutWeb',                    component:aboutWeb,                    meta:&#123;isAuth:true,                        title:'关于网站'&#125;,                    children:[                        &#123;                            name:'webTech',                            path:'webTech',                            component:webTech,                            meta:&#123;title:'关于本站采用的技术'&#125;                        &#125;                    ]                &#125;            ]        &#125;    ] &#125;)// 全局前置路由守卫 router.beforeEach((to,from,next)=>&#123;        if(to.meta.isAuth)&#123;//确认是否鉴权，避免对所有组件都进行鉴权消耗性能 // 当组件不多时，可以使用下面的代码通过判断路径来识别哪些组件需要权限认证        // if(to.name==='aboutme'||to.path==='/about/aboutWeb')        //只有localStorage中的user为zhoujielun才能访问            if(localStorage.getItem('user')==='zhoujielun')&#123;                next() //放行访问            &#125;            else&#123;                alert('无权限访问')            &#125;        &#125;        else&#123;            next()  //对不需要权限认证的页面直接放行        &#125;  &#125;)// 全局后置路由守卫//用于切换完毕后，修改网页地址栏的标题 router.afterEach((to)=>&#123;    document.title=to.meta.title   &#125;) export default router</code></pre><h4 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h4><p>只为某个路由组件配置的路由守卫， 同样写于路由器配置文件中<br><span class="strong">beforeEnter:(to,from,next)=&gt;{ }</span>只对针对某个组件配置守卫，同样接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行</p><p>eg: 判断用户是否为指定用户，不是则禁止访问aboutMe组件</p><pre><code>&#123;            name:'about',            path:'/about',            component:About,            meta:&#123;title:'关于'&#125;,            children:[                &#123;                    name:'aboutme',                    path:'aboutMe',                    component:aboutMe,                    meta:&#123;isAuth:true,//鉴别权限                          title:'关于我'&#125;,                          //独享路由守卫                          beforeEnter:(to,from,next)=>&#123;                                if(to.meta.isAuth)&#123;                                  //只有localStorage中的user为zhoujielun才能访问                                    if(localStorage.getItem('user')==='zhoujielun')&#123;                                        next()                                    &#125;                                    else&#123;                                        alert('无权限访问')                                    &#125;                                &#125;                                else&#123;                                    next()                                &#125;                           &#125;                &#125;,</code></pre><h4 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h4><p>无法修改路由器配置文件时，可以将路由守卫设于组件.vue的文件中。<span class="tips">组件内的路由守卫只会在通过路由规则进入组件时才会执行</span>，如果将组件标签直接添加到页面中，该组件会被调用，但此时不属于通过路由规则进入组件，不会执行下述路由守卫函数。</p><ul><li><span class="strong">beforeRouteEnter(to,from,next){ }</span>：进入组件前执行</li><li><span class="strong">beforeRouteLeave(to,from,next){ }</span>：离开组件前执行</li><li><span class="strong">beforeRouteUpdate(to,from,next){ }</span>：组件更新时执行</li></ul><pre><code>&lt;template>  &lt;div class="about">    &lt;h2>About页面&lt;/h2>    &lt;div class="about-btn">    &lt;router-link  to="/about/aboutWeb">关于网页&lt;/router-link>    &lt;router-link  to="/about/aboutMe">关于我&lt;/router-link>    &lt;/div>    &lt;div class="about-content">      &lt;keep-alive include="aboutMe">      &lt;router-view>&lt;/router-view>      &lt;/keep-alive>    &lt;/div>  &lt;/div> &lt;/template> &lt;script> export default &#123;    name:'pageAbout',    // 通过路由规则进入组件时调用    beforeRouteEnter(to,from,next)&#123;      //只有localStorage中的user为zhoujielun才能访问            if(localStorage.getItem('user')==='zhoujielun')&#123;                    next()                    &#125;            else&#123;                 alert('无权限访问')             &#125;    &#125;,     // 通过路由规则离开组件时调用    beforeRouteLeave(to,from,next)&#123;      console.log('即将离开组件')        next();//放行    &#125;&#125; &lt;/script></code></pre>]]></content>
    
    
    <summary type="html">vue构建单页应用笔记，包括路由嵌套、传参、导航、生命周期、路由守卫</summary>
    
    
    
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
    <category term="vue" scheme="https://shiwei11.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>yaml语法</title>
    <link href="https://shiwei11.github.io/blog/2022/07/14/yaml%E8%AF%AD%E6%B3%95/"/>
    <id>https://shiwei11.github.io/blog/2022/07/14/yaml%E8%AF%AD%E6%B3%95/</id>
    <published>2022-07-14T07:48:44.000Z</published>
    <updated>2022-07-16T05:55:32.969Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>YAML官方文档：<a href="https://yaml.org/spec/1.2.2/">YAML 1.2.2</a></div><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>YAML是一种数据序列化语言，可用于存储和传输数据，常用于编写配置文件、数据文件、日志文件，以及跨语言进行数据共享等环境，大多数编程语言都可以使用 YAML 进行数据序列化。</p><p>YAML文件后缀为<span class="tips">.yml</span>或<span class="tips">.yaml</span></p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><span class="strong">1. 通常使用键值对形式</span></p><ul><li>键与值通常不需要引号包裹 (这点与json不同)</li><li>值可以为：数组、对象、标量值</li><li>标量值是指：整数、浮点数、字符串、布尔值、Null、时间、日期</li></ul><p><span class="strong">2. 通过缩进或者样式流表示数据结构</span></p><ul><li>数据可以通过空格缩进来表示层级关系，但不能用制表符(Tab)</li><li>子结构相较父结构必须缩进至少一个空格，同一级数据须缩进相同空格数，即左端对齐</li><li>也可以使用花括号{&nbsp;}，中括号[&nbsp;]等样式流表示层级关系<br><span class="strong">3. 大小写敏感</span><br><span class="strong">4. 使用#号注释</span></li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>最为常用的数据类型，又称为字典、哈希、映射，以<span class="tips"> key: &nbsp;value </span>键值对的形式存储数据，<span class="tips">key: 后需要有空格!</span></p><h4 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h4><div class="show">name: JayChoualbum: 十一月的萧邦</div><p>或者使用样式流：</p><div class="show">{    name: JayChou,    album: 十一月的萧邦}</div>等同于json格式下的<div class="show">{  "name": "JayChou",  "album": "十一月的萧邦"}</div><h4 id="缩进与嵌套"><a href="#缩进与嵌套" class="headerlink" title="缩进与嵌套"></a>缩进与嵌套</h4><p>可以通过缩进至少一个空格表示层级关系，从而嵌套其他对象、数组等</p><div class="show">student:   name: aaa   age: 16   hobby:    - basketball    - swimming</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>多级嵌套时，每层嵌套都应当缩进，<span class="tips">且每个子元素左边应该缩进相等的空格数，即左端对齐</span></div>   使用样式流：   <div class="show">student: {        name: aaa,        age: 16,        hobby: [ basketball , swimming ]   }</div><h4 id="复杂对象格式"><a href="#复杂对象格式" class="headerlink" title="复杂对象格式"></a>复杂对象格式</h4><p>使用<span class="tips">?加空格</span>可以指定多个key值，使用<span class="tips">:加空格</span>指定多个value</p><div class="show">?       - key1      - key2:       - value1      - value2</div>    表示key是一个数组，值也是一个数组，样式流：    <div class="show">key1,key2: ["value1","value2"]</div><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用<span class="tips strong">-</span>开头表示数组元素</p><h4 id="数组写法"><a href="#数组写法" class="headerlink" title="数组写法"></a>数组写法</h4><div class="show">- value1- value2- value3</div>样式流：<div class="show">[value1,value2,value3]</div><h4 id="缩进与嵌套-1"><a href="#缩进与嵌套-1" class="headerlink" title="缩进与嵌套"></a>缩进与嵌套</h4><p>可以通过缩进表示层级关系，来嵌套数组、对象等</p><div class="show">- name: 周杰伦,  age: 42,  songs:    - 夜曲   - 米兰的小铁匠- name: 林肯公园,  age: 41,  songs:   - In the End   - Numb</div>样式流<div class="show">[  {    name: 周杰伦,    age: 42,    songs: [ 夜曲 , 米兰的小铁匠 ]  },  {    name: 林肯公园,    age: 41,    songs: [ In the End , Numb ]  }]</div><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>标量指最基本的，不可再分的值，这里指：整数、浮点数、字符串、布尔值、Null、时间、日期</p><p>基本使用方法：</p><div class="show">1. 整数可以为非十进制数num1: 120           #普通十进制数num2: 0b10_1011     #二进制以0b开头num3: 07100         #八进制以0开头num4: 0xf1ab        #十六进制以0x开头2. 浮点数可以使用科学计数法float1: 3.14float2: 3.1415926e+5 #科学计数法314159.26float3: -.inf        #负无穷大flota4: .nan         #不是数字3. 布尔值大小写均可bool: true值为：true、True、TRUE均可，但TRUe将被解析为字符串4. Null可用<span class="tips">~</span>表示data: ~5. 日期必须使用ISO 8601格式，即yyyy-MM-dddate: 2021-07-156. 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区time: 2021-07-15T00:42:31+08:00在JavaScript中解析为Thu Jul 15 2021 00:42:31 GMT+0800 (中国标准时间)7. 使用<span class="tips">!!数据类型 值</span>进行类型转换date: !!str 2021-01-15</div><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>一般情况下，字符串不需要添加引号，但如果字符串中间包含特殊字符，尤其是<span class="tips">冒号加空格</span>组合时，为了避免被yaml解析为键值对，需要添加引号</p><div class="show">str: 'said: meet you like wind'</div><p>给数值等标量添加引号将解析为字符串</p><div class="show">str: '99.99'</div><p>多行字符串，<span class="tips">第二行开始所有行需要缩进至少一个空格</span>，但解析时将被解析为一行字符串，且换行符会被替换为空格</p><div class="show">str: aaaa bbbb cccc 将被解析为 str: "aaaa bbbb cccc"</div><h4 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h4><p> 单引号和双引号均可以用于包裹字符串</p><ul><li><span class="strong">单引号会原样输出，将转义字符作为普通字符串输出</span></li><li><span class="strong">双引号会转义字符串，如将 \n 转义为换行</span></li></ul><div class="show">如：content: '不会\n换行'内容输出为：<span class="tips">不会\n换行</span>content: "进行\n换行"内容输出为： <span class="tips">进行  换行</span></div><h4 id="区块字符串处理"><a href="#区块字符串处理" class="headerlink" title="区块字符串处理"></a>区块字符串处理</h4><ol><li><p>多行字符串可以使用<span class="tips strong">|</span>保留所有换行符，内容从第二行开始需要缩进至少一个空格，且最后一行的换行符也会保留。</p><div class="show">lyrics: |aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd<br/></div></li><li><p>可以使用<span class="tips strong">&gt;</span>去除换行，换行符将被空格代替 (如果某一行是空行，该空行会被额外保留)</p><div class="show">lyrics: >aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbb cccc dddd</div></li><li><p>可以使用<span class="tips strong">+</span>保留文字块末尾的换行</p><div class="show">lyrics: |+aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd<br/></div></li><li><p>可以使用<span class="tips strong">-</span>去除文字块末尾的换行</p><div class="show">lyrics: |-aaaa bbbbcccc dddd</div>输出为：<div class="show">aaaa bbbbcccc dddd</div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>在yml文件中配置好字符串格式后，读取到html中时往往需要添加如<span class="tips">white-space: pre-line;</span>等css属性来保留换行符和空格，否则读入的数据可能会被css默认样式去除换行符，从而无法展示原生yml指定的数据格式</div></li><li><div class="tips strong">在样式流中，无法使用 | > + -</div><div class="show">如：以上数据写为样式流          {             lyrics: |-             aaaa              bbbb             cccc              dddd            }|- 将无法解析，抛出错误</div></li></ol><h3 id="添加HTML标签"><a href="#添加HTML标签" class="headerlink" title="添加HTML标签"></a>添加HTML标签</h3><p>yaml允许在值中添加HTML标签，并且标签会被正确地解析为DOM</p><div class="show">- tag: web  content: 推荐网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>  或  <div class="show">- tag: web  content: |-   推荐   网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>解析为：<div class="show">推荐网站 <a href="#">SHIWIVI</a></div>   <div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>使用时需要注意，插入的HTML标签是否会被其他语言解析为字符串，但yaml本身是可以输出为DOM元素的</div><h3 id="锚点与引用"><a href="#锚点与引用" class="headerlink" title="锚点与引用"></a>锚点与引用</h3><p>可以使用<span class="tips">&amp;</span>定义一个锚点，然后使用<span class="tips">*</span>引用锚点</p><div class="show">first: &anchor  #定义锚点 - aaa - bbbsecond:  *anchor #调用锚点</div>解析为<div class="show">first: [aaaaa,bbb]second: [aaaaa,bbb] </div><p>如果将多个键值对引用到其他地方，可以使用<span class="tips">&lt;&lt;</span>合并数据</p><div class="show">first: &data  #定义锚点   name: lol   age: 18   hobby:    - sing    - swingsecond:    <<: *data    #将数据插入此处   address: zzz</div> 解析为： <div class="show">{  "first": {      "name": "lol",      "age": 18,      "hobby": "sing  swimming"  },  "second": {      "name": "lol",      "age": 18,      "hobby": "sing  swimming",      "address": "zzz"  }}</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>如果多次定义了同名的锚点(重定义)，则先定义的锚点会被覆盖</div><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>一个完整的yml文档以<span class="tips">-&zwnj;-&zwnj;-</span>标识文档开始，以<span class="tips">…</span>标识文档结束，该标识非必须，无标识的称为<span class="tips">裸文档</span>，文件开头可以添加<span class="tips">%YAML</span>来识别文件的YAML版本</p><div class="show">%YAML 1.2# 开头注释，注明文档作者等信息---ip: 45.77.77.49port: 443...</div><p>一个yml文件中可能有多个文档</p><div class="show">---ip: 45.77.77.10port: 80...---ip: 45.77.77.11port: 443...</div>但如果在一个yml文件中写入多个文档，在某些环境下读入可能报错，需要分割为多个文件<div class="shell">err: YAMLException: expected a single document in the stream, but found more</div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>更多语法和拓展详见官方文档</div>]]></content>
    
    
    <summary type="html">YAML Ain’t Markup Language，小猫咪都会写的yaml文件</summary>
    
    
    
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
    <category term="File" scheme="https://shiwei11.github.io/blog/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Grid栅格布局</title>
    <link href="https://shiwei11.github.io/blog/2022/06/14/Grid%E5%B8%83%E5%B1%80/"/>
    <id>https://shiwei11.github.io/blog/2022/06/14/Grid%E5%B8%83%E5%B1%80/</id>
    <published>2022-06-14T07:03:12.000Z</published>
    <updated>2022-07-02T11:49:59.185Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>Grid在MDN上翻译为网格布局，在《CSS权威指南》中翻译为栅格布局，其实是同一种布局方案，本文语句主要整理自《CSS权威指南》一书</div><h3 id="1-栅格布局"><a href="#1-栅格布局" class="headerlink" title="1. 栅格布局"></a>1. 栅格布局</h3><p>Grid 是一种强大的布局方案，也是最为普适的布局方案，允许在Web上创建二维布局，通过对父元素定义不同参数的行与列垂直线，再将子元素部署于行列网格上，由此实现各类灵活的布局，如：<br><br/></p><div style="display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;"><div style="background-color:#EA2027;grid-area:a;">box1</div><div style="background-color:#fff200;grid-area:b;">box2</div><div style="background-color:#7d5fff;grid-area:c;">box3</div><div style="background-color:#32ff7e;grid-area:d;">box4</div><div style="background-color:#4b4b4b;grid-area:e;">box5</div></div><br/><p>通过标准流、float、flex也可以实现类似的布局，但这些方案往往需要更多的DOM元素，或者需要指定更多的参数，并且很多情况下无法做到自适应，此时，grid布局方案的优势就体现出来了。并且语法兼容性也很好，除了那位大爷…..</p><div class="table"><table><thead><tr><th>Chrome</th><th>Edeg</th><th>Firefox</th><th>IE</th><th>Opera</th><th>Safari</th></tr></thead><tr><td>57</td><td>16</td><td>52</td><td style="color:red;">不支持</td><td>44</td><td>10.1</td></tr></table></div><h3 id="2-栅格容器"><a href="#2-栅格容器" class="headerlink" title="2. 栅格容器"></a>2. 栅格容器</h3><p>创建栅格的第一步就是创建一个栅格容器，并将其中的内容定义为栅格布局</p><h4 id="2-1-栅格属性"><a href="#2-1-栅格属性" class="headerlink" title="2.1 栅格属性"></a>2.1 栅格属性</h4><p><span class="strong">display: grid/inline-grid;</span></p><p>指定容器布局方式为栅格布局，该属性和 block 与 inline-block 值相似</p><h4 id="2-2-定义栅格模板"><a href="#2-2-定义栅格模板" class="headerlink" title="2.2 定义栅格模板"></a>2.2 定义栅格模板</h4><p><span class="strong">grid-template-columns: 值;</span></p><p><span class="strong">grid-template-rows: 值;</span></p><p>将容器划分为行列栅格,栅格线的值可以为<span class="tips">固定值</span>、<span class="tips">百分比</span>、<span class="tips">fr关键字</span>、<span class="tips">repeat()语句</span>、<span class="tips">minmax()语句</span>、<span class="tips">calc()函数</span>等，并且参数可以混用</p><h5 id="2-2-1-固定值行列轨道宽度"><a href="#2-2-1-固定值行列轨道宽度" class="headerlink" title="2.2.1 固定值行列轨道宽度"></a>2.2.1 固定值行列轨道宽度</h5><p>将子元素宽高设为固定值，单位可以为px，也可以为em、rem等相对单位</p><div class="show">如：给父元素指定行列轨道宽度，子元素可以不设置任何参数div{    display:grid;    grid-template-columns:50px 60px 100px;    grid-template-rows:50px 60px 100px;}</div><div style="display:grid;grid-template-columns:50px 60px 100px;grid-template-rows:50px 60px 100px;text-align:center;color:#fff;width:210px;margin:0 auto;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">类似的取值可以为    grid-template-columns:5em 5em 5em;</div><h5 id="2-2-2-百分比配置宽高"><a href="#2-2-2-百分比配置宽高" class="headerlink" title="2.2.2 百分比配置宽高"></a>2.2.2 百分比配置宽高</h5><p>将元素的宽高按百分比配置，可以让网页元素自适应不同屏幕大小</p><div class="show">如：元素宽高分别为20% 20% 50% div{    display:grid;    grid-template-columns:20% 20% 50%;    grid-template-rows:20% 20% 50%;    border:1px solid black;    box-sizing: border-box;}</div><div style="display:grid;grid-template-columns:20% 20% 50%;grid-template-rows:20% 20% 50%;text-align:center;color:#fff;width:280px;height:300px;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>百分比是基于父容器的宽度和高度计算，不管子元素内容大小如何变化也不会变，因此要给与父元素宽高参数，即不能再使用子元素撑开父元素了。若子元素宽高相加不到100%，则剩余部分空置</div><h5 id="2-2-3-fr按比例配置宽高"><a href="#2-2-3-fr按比例配置宽高" class="headerlink" title="2.2.3 fr按比例配置宽高"></a>2.2.3 fr按比例配置宽高</h5><p>grid布局提供了 <span class="tips">fr</span> 关键字(fraction)用于表示比例关系</p><div class="show">如：元素宽高比为1:2:2 div{    display:grid;    grid-template-columns:1fr 2fr 2fr;    grid-template-rows:1fr 2fr 2fr;    border:1px solid black;    box-sizing: border-box;}</div><div style="display:grid;grid-template-columns:1fr 2fr 2fr;grid-template-rows:1fr 2fr 2fr;text-align:center;color:#fff;width:210px;margin:0 auto;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">配合其他值来实现弹性布局     grid-template-columns:150px 1fr 10%;     <span class="tips">第一列宽为150px，最后一列宽为10%,剩下宽度给中间一列</span></div><h5 id="2-2-4-定义栅格线名称"><a href="#2-2-4-定义栅格线名称" class="headerlink" title="2.2.4 定义栅格线名称"></a>2.2.4 定义栅格线名称</h5><p>可以使用<span class="tips">[ ]</span>为边框线起名字，并且同一条线的名称可以有无数多个，如：<span class="tips">[a1 b1]</span>为同一条线取名a1和b1</p><div class="show">如：元素宽高比为1:2:2 div{    display:grid;    grid-template-columns: [c1] 80px [c2] 80px [c3] 80px [c4];    grid-template-rows: [r1] 60px [r2] 60px [r3] 60px [r4];    border:1px solid black;    box-sizing: border-box;}box1、box4、box7左边框线相连为c1，右边框线相连为c2；box1、box2、box3上边框线相连为r1，下边框线相连为r2其他以此类推</div><div style="display:grid;grid-template-columns:[c1] 80px [c2] 80px [c3] 80px [c4];    grid-template-rows:[r1] 60px [r2] 60px [r3] 60px [r4];text-align:center;color:#fff;margin:0 auto;width:240px;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h5 id="2-2-5-repeat-重复填充"><a href="#2-2-5-repeat-重复填充" class="headerlink" title="2.2.5 repeat()重复填充"></a>2.2.5 repeat()重复填充</h5><p>对于多个宽高值相同的元素，可以使用<span class="tips">repeat()</span>语句简写</p><div class="show">如：1. 对于grid-template-columns: 5em 5em 5em;该语句可以简写为    grid-template-columns: repeat(3,5em);2. 类似地可以创建宽度有一定规律的子元素    如：创建宽度依次为20px,40px,60px,20px,40px,60px的6列元素    grid-template-columns: repeat(2, 20px 40px 60px);3. 还可以repeat()前后添加不想重复的宽高值    grid-template-columns: repeat(2,1em 5em) 2em;    这就生成了1em 5em 1em 5em 2em的网格4. 百分号和比例依旧适用    grid-template-columns: repeat(3,33.3%);5. 如果包含了栅格线名，名称也会被复制    grid-template-columns: repeat(3,[top] 5em [bottom]);    则会生成    [top] 5em [bottom top] 5em [bottom top] 5em [bottom]    即：中间的栅格线将会有两个名称，该语句等同于：    grid-template-columns: [top] 5em [bottom top] 5em [bottom top] 5em [bottom];</div><h5 id="2-2-6-minmax-限制尺寸"><a href="#2-2-6-minmax-限制尺寸" class="headerlink" title="2.2.6 minmax()限制尺寸"></a>2.2.6 minmax()限制尺寸</h5><p>当子元素溢出父容器之外时，除了使用<span class="tips">overflow: hidden;</span>外，还可以使用<span class="tips">minmax(最小值，最大值)</span>来限制宽高尺寸</p><div class="show">如：将剩余空间分配给第二列，但又要避免他被挤占得太小     grid-template-columns:5em minmax(10%,1fr) 2em;</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>注意！当minmax()中最大值小于最小值时，最大值将失效。如minmax(100px,2em)中，当2em计算值小于100px时，元素宽高将被解析为100px</div><h5 id="2-2-7-calc-计算尺寸"><a href="#2-2-7-calc-计算尺寸" class="headerlink" title="2.2.7 calc()计算尺寸"></a>2.2.7 calc()计算尺寸</h5><p>grid是支持<span class="tips">calc()</span>语句的，只是有时候不太适用</p><div class="show">如：第二列宽度通过计算得出     grid-template-columns:2em calc(100%-1.5em) 10%;</div><h5 id="2-2-8-根据内容自适应"><a href="#2-2-8-根据内容自适应" class="headerlink" title="2.2.8 根据内容自适应"></a>2.2.8 根据内容自适应</h5><p>子元素宽高还可以根据子元素内容，通过<span class="tips">max-content</span>、<span class="tips">min-content</span>、<span class="tips">fit-content</span>来实现栅格自适应</p><ul><li><span class="strong">max-content:</span>解析为尽可能大的空间，以防换行</li><li><span class="strong">min-content:</span>解析为尽可能小的空间，能够显示内容即可</li><li><span class="strong">fit-content:</span>解析为空间尽可能小，但如果超过指定空间大小就换行</li></ul><div class="show">如：尽可能容纳内容div{    display:grid;    grid-template-columns:max-content max-content max-content;    grid-template-rows:max-content max-content max-content;}可以看到，每一列的宽度由该列有最长内容的列宽决定，行类似。当父元素指定宽度时，这可能会溢出到父容器之外</div><div style="display:grid;grid-template-columns:max-content max-content max-content;grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">1</div><div style="background-color:#fff200;">22</div><div style="background-color:#7d5fff;">33333333</div><div style="background-color:#32ff7e;">44444444444</div><div style="background-color:#4b4b4b;">5</div><div style="background-color:#67e6dc;">6</div><div style="background-color:#ff9f1a;">77</div><div style="background-color:#ffb8b8;">8888</div><div style="background-color:#c56cf0;">9</div></div><div class="show">配合minmax()使用可以不破坏外部布局，但会挤压内部空间div{    display:grid;    grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);    grid-template-rows:max-content max-content max-content;}</div><div style="display:grid;grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">1</div><div style="background-color:#fff200;">22</div><div style="background-color:#7d5fff;">33333333</div><div style="background-color:#32ff7e;">44444444444</div><div style="background-color:#4b4b4b;">5</div><div style="background-color:#67e6dc;">6</div><div style="background-color:#ff9f1a;">77</div><div style="background-color:#ffb8b8;">8888</div><div style="background-color:#c56cf0;">9</div></div><div class="show"><span class="tips">fit-content</span>用于限制最大长度，类似于max-width指定三列宽均为50等宽字符，当未满50ch时按实际字符长度算，超过该值则进行换行，即最大值只能为50chdiv{    display:grid;    grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(5.0ch);}只指定宽度，高度自适应，第一第二列未满50ch时，以各自长度为列宽，第三列超过50ch，则进行换行，以50ch为列宽</div><div style="display:grid;grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(50ch);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#18dcff;">the night</div><div style="background-color:#4b4b4b;">Avicii</div><div style="background-color:#7d5fff;">He said one day you will leave this world behind So live a life you will remember</div></div><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>当父容器较小时，第一、第二列即便未满50ch也可能会进行换行，以保证不会溢出父亲容器</div><h5 id="2-2-9-auto-fill自动填充"><a href="#2-2-9-auto-fill自动填充" class="headerlink" title="2.2.9 auto-fill自动填充"></a>2.2.9 auto-fill自动填充</h5><p>当父容器宽度固定，可以使用<span class="tips">auto-fill</span>让子元素根据大小自动填充</p><div class="show">如：div{    display:grid;    width:50vh;    grid-template-columns:repeat(auto-fill,5em);    grid-template-rows:max-content max-content max-content;    }在父容器中尽量排列宽3em的元素，排列到第一行排完，如果剩下空间不足3em，则剩余子元素将进行换行</div><div style="display:grid;grid-template-columns:repeat(auto-fill,3em);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">1. 一个父容器的宽/高只能有一次自动排列，因此下述语句是不允许的grid-template-columns: repeat(auto-fill,5em) repeat(auto-fill,2em);2. 但可以固定尺寸的repeat与自动填充的repear共存，如：grid-template-columns: repeat(2,5em) repeat(auto-fill,2em);或者grid-template-columns: repeat(auto-fill,5em) repeat(3,2em);但无论语序如何，grid总会为固定尺寸的元素分配空间，因此auto-fill会被最后才被分配空间</div><h4 id="2-3栅格间距"><a href="#2-3栅格间距" class="headerlink" title="2.3栅格间距"></a>2.3栅格间距</h4><p>通过<span class="tips">row-gap</span>、<span class="tips">column-gap</span>来设置栅格见的行、列间隔。或者将两个属性合并为一个 <span class="tips">grid-gap：行间隔 列间隔;</span></p><div class="show">给父容器添加该属性div{    display:grid;    width:50vh;    height:50vh;    grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);    row-gap:10px;    column-gap:10px;    }如图所见，添加间隔可能导致栅格溢出，这两个属性可合并为 grid-gap ，如果该语句之后的值只有一个，则解析为行列间隔都为该值。    grid-gap:10px 10px;等价于    grid-gap:10px;</div><div style="display:grid;grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);row-gap:10px;    column-gap:10px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h3 id="3-栅格区域"><a href="#3-栅格区域" class="headerlink" title="3. 栅格区域"></a>3. 栅格区域</h3><p>此前都是给父容器添加属性，但如果同时给子元素添加相应属性可以做出更好的布局</p><h4 id="3-1-调用栅格线名"><a href="#3-1-调用栅格线名" class="headerlink" title="3.1 调用栅格线名"></a>3.1 调用栅格线名</h4><p>通过<span class="tips">grid-template-columns</span>、<span class="tips">grid-template-rows</span>定义栅格宽高和栅格线名后，可以通过下列语句调用栅格线名</p><ul><li><span class="strong">grid-column-start：</span>列开始的栅格线名</li><li><span class="strong">grid-column-end：</span>列结束的栅格线名</li><li><span class="strong">grid-row-start：</span>行开始的栅格线名</li><li><span class="strong">grid-row-end：</span>行结束的栅格线名</li></ul><div class="show">通过四条边来定义子元素的具体位置，当未定义栅格线名时，可以使用1，2，3...作为栅格线名.box1 {    grid-column-start:1;    grid-column-end:2;    grid-row-start:2;    grid-row-end:4;    background-color: #ff3426;//红色}.box2 {    grid-column-start:3;    grid-column-end:5;    grid-row-start:1;    grid-row-end:3;    background-color: #39f64f;//绿色}<p>.parbox {<br>    display:grid;<br>    grid-template-columns: repeat(4,50px);<br>    grid-template-rows: repeat(4,50px);<br>}<br>栅格线名可以为负数，表示从该栅格线往其反方向数</p></div><div style="display:grid;display:grid;grid-template-columns: repeat(4,50px);grid-template-rows: repeat(4,50px);text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;box-sizing: border-box;"><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #ff3426;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #39f64f;"></div><div style="border:1px solid #474747;background-color: #ff3426;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div><div style="border:1px solid #474747;"></div></div><div class="show">1. 栅格线的编号可以为<span class="tips">负值</span>，表示从倒数第n条线开始从后往前数如：不知道栅格有几列，但想从最右边的栅格线开始部署，可以使用        grid-column-start:-1;        grid-row-start:-1;(行同理)2. 如果为栅格线定义过名称，则可以使用该名称作为上述语句的值，如果变量对应的栅格线有多条，则使用<span class="strong">变量名 序号</span>来确定具体的栅格线，序号从1开始排列。如：有多条名为col-A的线，表示列从第4条col-A开始：            grid-column-start:col-A 4;3. 此外可以使用<span class="tips">span</span>语句指定子元素跨越的行列数，如：.box1 {    grid-column-start:1;    grid-column-end: span 1;    grid-row-start:2;    grid-row-end: span 2;}上述代码等同于：.box1 {    grid-column-start:1;    grid-column-end: 2;    grid-row-start:2;    grid-row-end: 4;}表示该子元素从左边框号1开始，跨越1列，从上边框号2开始，跨越2行，其中<span class="strong">span 1</span>可以直接简写为<span class="strong">span</span>(默认为1)，且span后的值不能为<span class="tips">0</span>或<span class="tips">负值</span>4. 当使用 <span class="strong">span 栅格线名 n</span> 时，表示该元素跨越了n条该名称的栅格线如：栅格部署为A、B栅格线交替命名时A 格子 B 格子 A 格子 B 格子 A 格子 B 格子此时    grid-column-start: A 1;    grid-column-end: span 2 A;表示栅格从第1条A线开始，跨越1条名为A的栅格线，在下一个A线处结束</div><h4 id="3-2-调用栅格线名的简写"><a href="#3-2-调用栅格线名的简写" class="headerlink" title="3.2 调用栅格线名的简写"></a>3.2 调用栅格线名的简写</h4><p>上一节中 grid-column-start，grid-column-end和grid-row-start，grid-row-end用于指定栅格起始和结束的位置，该属性可以简写为</p><ul><li><span class="strong">grid-column: 起始栅格线/结束栅格线</span></li><li><span class="strong">grid-row: 起始栅格线/结束栅格线</span></li></ul><div class="show">1. 元素开始和结束的栅格线名用 / 隔开 .box1 {    grid-column-start:1;    grid-column-end: 2;    grid-row-start:2;    grid-row-end: 4;}等价于.box1 {    grid-column: 1 / 2;    grid-row: 2 / 4;}也可以用跨越了多少栅格表示.box1 {    grid-column: 1 / span 1;    grid-row: 2 / span 2;}2. 如果 / 和第二个值省略，则默认起始结束的栅格线名都一致如：列栅格线中有两条名为header的线，则        grid-column: header;等价于        grid-column: header / header;即以第一条header开始，第二条header结束，无论中间跨越多少栅格</div><h4 id="3-3-grid-area"><a href="#3-3-grid-area" class="headerlink" title="3.3 grid-area"></a>3.3 grid-area</h4><p>grid-area可用于调用网格线，也可用于为子元素命名</p><h5 id="3-3-1-grid-area调用网格线"><a href="#3-3-1-grid-area调用网格线" class="headerlink" title="3.3.1 grid-area调用网格线"></a>3.3.1 grid-area调用网格线</h5><p> grid-column-start，grid-column-end和grid-row-start，grid-row-end可以直接用一个语句代替：<br> <span class="strong">grid-area：行开始/列开始/行结束/列结束</span></p><div class="show">如：.box1 {    grid-row-start:2;    grid-row-end: 4;    grid-column-start:1;    grid-column-end: 2;  }等价于.box1 {    grid-area:2/1/4/2;}同样，值可以为跨越了多少个网格.box1 {  grid-area: 2 / 1 / span 2 / span 1;}</div><h5 id="3-3-2-grid-area为子元素命名"><a href="#3-3-2-grid-area为子元素命名" class="headerlink" title="3.3.2 grid-area为子元素命名"></a>3.3.2 grid-area为子元素命名</h5><p>可以通过<span class="tips">grid-area</span>给每个栅格子元素定义名称，然后由父容器通过<span class="tips">grid-template-areas</span>定义它们的排列方法</p><div class="show">如：.box1 {    grid-area: a;}.box2 {    grid-area: b;}.box3 {    grid-area: c;}.box4 {    grid-area: d;}.box5 {    grid-area: e;}.parbox {    display:grid;    grid-template-areas: 'a a a'                        &emsp;&emsp;&emsp;&emsp;'b c d'                        &emsp;&emsp;&emsp;&emsp;'b e e';}排列方法可以写于同一行上，但需要注意'&nbsp;'号grid-template-areas: 'a a a''b c d''b e e';</div><div style="display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;"><div style="background-color:#EA2027;grid-area:a;">box1</div><div style="background-color:#fff200;grid-area:b;">box2</div><div style="background-color:#7d5fff;grid-area:c;">box3</div><div style="background-color:#32ff7e;grid-area:d;">box4</div><div style="background-color:#4b4b4b;grid-area:e;">box5</div></div><div class="show">变量名应该尽量使用有含义的单词(子元素变量名应相应改变，这里只展示父容器属性).parbox {    display:grid;    grid-template-areas: 'header header header''left content right''left footer footer';}也可以省略其中的部分变量，使用...代替.parbox {    display:grid;    grid-template-areas: 'header header header''left ... right''left footer footer';}</div><h3 id="4-栅格的对齐方式"><a href="#4-栅格的对齐方式" class="headerlink" title="4. 栅格的对齐方式"></a>4. 栅格的对齐方式</h3><p>栅格对齐方式类似于flex弹性盒里的属性</p><div class="table"><table><thead><tr><th>属性</th><th>目标</th><th>适用于</th></tr></thead><tbody><tr><td>justify-self</td><td>行(一个栅格元素)</td><td>子元素</td></tr><tr><td>justify-items</td><td>行(所有栅格元素)</td><td>父容器</td></tr><tr><td>justify-content</td><td>行(整个栅格)</td><td>父容器</td></tr><tr><td>align-self</td><td>列(一个栅格元素)</td><td>子元素</td></tr><tr><td>align-items</td><td>列(所有栅格元素)</td><td>父容器</td></tr><tr><td>align-content</td><td>列(整个栅格)</td><td>父容器</td></tr></tbody></table></div><div class="show">以行为例.box1{    justify-self:start;}.box2{    justify-self:center;}.box3{    justify-self:end;}justify-self和justify-items用来调整单个或多个元素在它们自己栅格内的位置当justify-self赋值为start、center、end时，如果子元素没有指定宽度和高度，则会自动缩为仅合适内容的大小，对齐方式同单词含义。赋值为stretch时会被拉伸，完全填充box(同剩下的box)当需要所有元素都有该对齐方式，则可以给父容器添加justify-items和对应的值</div><div style="display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;justify-self:start;">box1</div><div style="background-color:#fff200;justify-self:center;">box2</div><div style="background-color:#7d5fff;justify-self:end;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><div class="show">同样以行为例.parbox{    width:260px;    height:260px;    display:grid;    grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);    justify-content:center;}justify-content则是用来调整整个grid网格在父容器中的位置</div><div style="display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);justify-content:center;text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div><div style="background-color:#ff9f1a;">box7</div><div style="background-color:#ffb8b8;">box8</div><div style="background-color:#c56cf0;">box9</div></div><h3 id="5-隐式栅格"><a href="#5-隐式栅格" class="headerlink" title="5. 隐式栅格"></a>5. 隐式栅格</h3><p>此前通过<span class="strong">grid-template-rows</span>定义的栅格为<span class="tips">显式栅格</span>，当一部分栅格超出了显式栅格，系统会将超出的那部分定义为<span class="tips">隐式栅格</span>。可以使用<span class="tips strong">grid-auto-rows</span>与<span class="tips strong">grid-auto-columns</span>定义隐式栅格的大小</p><div class="show">如：.grid{    display:grid;    width:200px;    height:200px;        //定义2*2的显式栅格    grid-template-columns:100px 100px;    grid-template-rows:100px 100px;        //定义隐式栅格尺寸(以行为例)    grid-auto-rows: 50px;}box1、box2、box3、box4在显式栅格内，高为100px，box5，box6超出了显式栅格，高将变为隐式栅格的高50px</div><div style="display:grid;width:200px;    height:200px;grid-template-columns:100px 100px;grid-template-rows:100px 100px;grid-auto-rows: 50px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:5px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div><div style="background-color:#67e6dc;">box6</div></div><br/><br/><br/><h3 id="6-栅格流"><a href="#6-栅格流" class="headerlink" title="6. 栅格流"></a>6. 栅格流</h3><p>栅格流主要分为优先行、优先列、密集流三种模式，由<span class="tips">grid-auto-flow</span>决定</p><div class="show">grid-auto-flow的取值有row、column、dense(密集流) .box{    display: grid;    grid-template: repeat(3,80px) / repeat(3,80px);    width: 240px;    height: 240px;     grid-auto-flow: row;    }优先行与优先列的部署模型如下</div><div style="display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: row;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div></div><br/><div style="display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: column;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;"><div style="background-color:#EA2027;">box1</div><div style="background-color:#fff200;">box2</div><div style="background-color:#7d5fff;">box3</div><div style="background-color:#32ff7e;">box4</div><div style="background-color:#4b4b4b;">box5</div></div><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>密集流的主要作用是让元素尽量靠紧，因此有时会破坏栅格元素的顺序进行密集分布，向任何可以插入的位置安插合适的子元素</div><h3 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h3><p>当输入错误的代码时，部分情况下grid会帮我们修正属性，但在有些情况下会抛弃部分无法解析的值，甚至不解析整个语句</p><div class="show">1. 当栅格开始线放在结束线后    grid-row-start:5;    grid-row-end:2;grid将修正为    grid-row-start:2;    grid-row-end:5;2. 当栅格开始线和结束线都被声明为了跨度    grid-row-start: span ;    grid-row-end: span 3;结束线的值将被修改为 auto    grid-row-start: span ;    grid-row-end: auto;3. 如果栅格开始线被声明为跨越已命名的线，则该语句将被认为非法    grid-row-start: span header;</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>当栅格元素出现重叠时，可以使用 z-index 或 order 进行排序，并且栅格元素可以使用margin、position等标准流、定位等属性。并且还有其他一些更复杂的属性简写语法，本文不再展开说明，具体可以查阅MDN的文档</div>]]></content>
    
    
    <summary type="html">Grid 是一种强大的布局方案，通过行和列的排列能组合出各种灵活的布局方案，并且能很好满足PC端到移动端的自适应需求</summary>
    
    
    
    
    <category term="css" scheme="https://shiwei11.github.io/blog/tags/css/"/>
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Vux状态管理</title>
    <link href="https://shiwei11.github.io/blog/2022/06/13/Vux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>https://shiwei11.github.io/blog/2022/06/13/Vux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</id>
    <published>2022-06-13T14:04:24.000Z</published>
    <updated>2022-07-20T14:25:41.358Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>Vux官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></div><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><span class="tips">Vuex</span>是专门为Vue应用程序开发的集中式状态(数据)管理插件，可以对Vue中的组件进行统一的数据管理。</p><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p>vue2的工程使用vux3，vue3的工程需要使用vux4，版本需要对应，这里以安装vux3为例</p><p>在脚手架中执行：</p><pre><code>npm i vuex@3</code></pre><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><img data-src="/blog/images/vuex_art.jpg" src="/blog/images/vuex_art.jpg" alt="vuex工作流程"><ul><li><span class="strong">Action</span>主要用于响应Vue Conponents的消息，或者从后端接收数据，并且可以将数据在Action中进行初步处理(主要为异步处理，如：添加定时器)</li><li><span class="strong">Mutation</span>主要用于处理数据，在Mutation处理的数据才能被Devtools调试工具监测</li><li><span class="strong">State</span>主要用于集中存储数据</li></ul><p><span class="strong">工作流程：</span>Vue Conponents发送消息<span class="tips">(dispatch)</span>给Action，或者Action通过Ajax等技术从后端异步获取数据 —&gt; Actions提交<span class="tips">(commit)</span>到Mutation —&gt; 数据在Mutation中进行处理后，修改<span class="tips">(mutate)</span>State中存储的数据 —&gt; 监测到State数据发生变化，Vue重新渲染<span class="tips">(render)</span>页面</p><p>vue组件的中数据不要预处理时，也可以越过Action，直接commit到mutation中进行处理</p><p><span class="strong">关于store：</span>store是Vuex的核心库，可以理解为一个容器，Action、Mutation、state由Store统一管理，在进行消息提交、数据操作时往往需要经过store，通过<span class="tips">this.$store.dispatch</span>、<span class="tips">this.$store.commit</span>等语句来调用api</p><h3 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h3><h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><h5 id="1-配置store"><a href="#1-配置store" class="headerlink" title="1. 配置store"></a>1. 配置store</h5><p>在src目录下新建store目录，新建index.js文件</p><pre><code>import Vue from 'vue'import Vue from 'vue'//引入并应用vuximport Vuex from 'vuex'Vue.use(Vuex)//创建action、mutations、stateconst actions=&#123;....&#125;const mutations=&#123;....&#125;const state=&#123;.....&#125;//创建并暴露Storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters&#125;)</code></pre><h5 id="2-引入store配置项"><a href="#2-引入store配置项" class="headerlink" title="2. 引入store配置项"></a>2. 引入store配置项</h5><p>在main.js中引入store配置项</p><pre><code>// 全写为import store from './store/index.js'import store from './store'new Vue(&#123;  render: h => h(App),  store  &#125;).$mount('#app')</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>eg：简单求和差案例，4个按钮分别实现求和、求差、判断偶数后求和、定时器延时1s求和</p><ul><li>直接求和、求差可以直接commit到Mutation中运算</li><li>判断当前值是否为偶数，延时求和需要dispatch到Action中预处理，再commit到Mutation中运算</li><li>需要多次处理的数据可以在Action中多次dispatch，处理完毕再commit</li></ul><h5 id="1-创建组件"><a href="#1-创建组件" class="headerlink" title="1. 创建组件"></a>1. 创建组件</h5><p>在components中创建Count.vue</p><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;$store.getters.addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;$store.state.sum&#125;&#125;&lt;/h3>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="incrace">加&lt;/button>    &lt;button @click="decrace">减&lt;/button>    &lt;button @click="addOpp">偶数才加&lt;/button>    &lt;button @click="addLate">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script> export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1, //加数        &#125;    &#125;,    methods:&#123;        // 求和、求差直接commit    incrace()&#123;        this.$store.commit('JIA',this.num)    &#125;,    decrace()&#123;        this.$store.commit('JIAN',this.num)    &#125;,    //延时、判断奇偶dispatch到actions经过处理后再提交    addOpp()&#123;        this.$store.dispatch('addOpp',this.num)    &#125;,    addLate()&#123;        this.$store.dispatch('addLate',this.num)    &#125;    &#125; &#125;&lt;/script></code></pre><h5 id="2-配置store"><a href="#2-配置store" class="headerlink" title="2. 配置store"></a>2. 配置store</h5><p>新建store目录并在该目录下新建index.js</p><pre><code>import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const actions=&#123;    // actions里的方法名一般小写    //接收参数 (context,实参)    // context是一个对象，拥有store的部分属性,变量名可以为其他    addOpp(context,value)&#123;                  if(!(value%2))&#123;             //判断是否为偶数，为偶数则commit到mutations        context.commit('JIA',value)        &#125;else&#123;            console.log('非偶数，数未提交')        &#125;    &#125;,    addLate(context,value)&#123;       //数据想要多道处理时，可以在actions内多次dispatch，无限套娃        setTimeout(()=>&#123;            context.dispatch('addLate2',value);            console.log('第一次延迟处理')        &#125;,500)    &#125;,    addLate2(context,value)&#123;      //数据经过第二道处理后，再提交        setTimeout(()=>&#123;            context.commit('JIA',value);            console.log('第二次延迟处理')        &#125;,500)    &#125;&#125;// mutations里的方法名一般大写，用于和actions里的区别const mutations=&#123;    //接收参数(state,实参)    JIA(state,value)&#123;           //加        state.sum+=value    &#125;,    JIAN(state,value)&#123;          //减        state.sum-=value;    &#125;&#125;const state=&#123; //存储数据    sum:0 &#125;const getters=&#123;                //读取数据前，想要预先进行处理使用getters    addTen(state)&#123;        return state.sum+10    &#125;&#125;// 创建并暴露storeexport default new Vuex.Store(&#123;    actions,    mutations,    state,    getters &#125;)</code></pre><h5 id="3-引入store配置项"><a href="#3-引入store配置项" class="headerlink" title="3. 引入store配置项"></a>3. 引入store配置项</h5><p>在main.js中引入store配置</p><pre><code>import Vue from 'vue'import App from './App.vue'import store from './store'// 全写为import store from './store/index.js'Vue.config.productionTip = false new Vue(&#123;  render: h => h(App),  store &#125;).$mount('#app')</code></pre><h5 id="4-引入Count组件"><a href="#4-引入Count组件" class="headerlink" title="4. 引入Count组件"></a>4. 引入Count组件</h5><p>在App中使用Count组件</p><pre><code>&lt;template>  &lt;div id="app">    &lt;Count/>  &lt;/div>&lt;/template>&lt;script>import Count from'./components/Count.vue'export default &#123;  name:'App',  components:&#123;    Count             &#125;   &#125;&lt;/script></code></pre><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>组件从state读取数据前，如果需要对数据进行预处理，可以在getter中进行。如：读取state中的num前进行处理(完整代码位于上一个案例)</p><h4 id="1-在store中添加getter"><a href="#1-在store中添加getter" class="headerlink" title="1. 在store中添加getter"></a>1. 在store中添加getter</h4><pre><code>const actions=&#123;.....&#125;const mutations=&#123;....&#125;const state=&#123;.....&#125;const getter=&#123;     //读取state中的sum前，将值增大10     addTen(state)&#123;        return state.sum+10;     &#125;&#125;</code></pre><h4 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2. 读取数据"></a>2. 读取数据</h4><p>读取数据使用</p><pre><code>$store.getters.addTen</code></pre><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>当一个组件需要获取多个数据(状态)时，调用数据和api需要大量使用this.$store.state.number等语句，为了减小代码书写量，可以在计算属性中借助<span class="tips">mapState</span>、<span class="tips">mapGetters</span>、<span class="tips">mapMutations</span>、<span class="tips">mapActions</span>辅助函数简化代码</p><h4 id="通过对象"><a href="#通过对象" class="headerlink" title="通过对象"></a>通过对象</h4><p>当组件中的方法名、变量名与State、Mutations…中的变量名不同时，需要通过对象方式接收。并借助模板语法解析变量，以读取State中的数据为例：</p><div class="show">...mapState({组件中的变量名:'state数据',.....})</div><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum1&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name1&#125;&#125;,从state获取song为&#123;&#123;song1&#125;&#125;&lt;/h2>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    //当使用mapState等语法时，需要在写函数时传参(num)    &lt;button @click="incrace(num)">加&lt;/button>    &lt;button @click="decrace(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script>//引入mapState、mapGetters、mapMutations、mapActions import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex' export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    computed:&#123;        //模板语法        ...mapState(&#123;sum1:'sum',name1:'name',song1:'song'&#125;),        ...mapGetters(&#123;addTen:'addTen'&#125;)        // 可以简写为数组形式...mapGetters(['addTen'])，在对象中不能简写，会解析为addTen:addTen，值也解析为变量    &#125;,    methods:&#123;    //原语句    // incrace()&#123;this.$store.commit('JIA',this.num)&#125;,    // decrace()&#123;this.$store.commit('JIAN',this.num)&#125;,    // 借助mapMutations生成对应方法，该方法会自动调用commit，数组写法在另一组件中     ...mapMutations(&#123;incrace:'JIA',decrace:'JIAN'&#125;),    //原语句    // addOpp()&#123;this.$store.dispatch('addOpp',this.num)&#125;,    // addLate()&#123;this.$store.dispatch('addLate',this.num)&#125;     ...mapActions(&#123;addOpp:'addOpp',addLate:'addLate'&#125;)     &#125; &#125;&lt;/script></code></pre><h4 id="通过数组"><a href="#通过数组" class="headerlink" title="通过数组"></a>通过数组</h4><p>当组件中的方法名、变量名与State、Mutations…中的变量名相同时，可以直接使用数组</p><div class="show">...mapState(['变量名1','变量名2',....])</div><pre><code>&lt;template>  &lt;div>    &lt;h2>不同的mapstate等写法&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name&#125;&#125;,从state获取song为&#123;&#123;song&#125;&#125;&lt;/h2>    &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="JIA(num)">加&lt;/button>    &lt;button @click="JIAN(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>  &lt;/div>&lt;/template>&lt;script>import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex'export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    computed:&#123;        ...mapState(['sum','name','song']),        ...mapGetters(['addTen'])    &#125;,    methods:&#123;        //数组写法    ...mapMutations(['JIA','JIAN']),     ...mapActions(['addOpp','addLate'])    &#125; &#125;&lt;/script></code></pre><h3 id="模块化与命名空间"><a href="#模块化与命名空间" class="headerlink" title="模块化与命名空间"></a>模块化与命名空间</h3><p>当有多类数据需要vuex管理时，可以将他们的state、actions、mutation封装到多个js文件中，并为它们开启<span class="tips">命名空间</span></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>在store目录中创建多个store配置文件</li><li>将配置文件统一引入该目录的index.js中</li><li>将store配置引入main.js中</li><li>创建组件，需要注意辅助函数的用法，指向命名空间的方法</li><li>在app中引入组件</li></ol><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>eg: 在上个案例基础上加入添加成员的功能。现在有两个功能：求和求差、添加成员，因此store目录下需要两个store配置项。在组件中调用数据时，需要用到命名空间，从不同state中引用数据。</p><h5 id="1-配置store-1"><a href="#1-配置store-1" class="headerlink" title="1. 配置store"></a>1. 配置store</h5><p>在store目录新建 person.js文件</p><pre><code>//添加人员模块import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) const person = &#123;    namespaced:true, //开启命名空间    actions:&#123;        addPersonZhou(context,value)&#123;            if(value.name.indexOf('周')===0)&#123;                context.commit('ADD_PERSON',value)            &#125;            else&#123;                alert('只能添加姓周的名')            &#125;        &#125;,         &#125;,    mutations:&#123;        ADD_PERSON(state,personObj)&#123;            state.personList.unshift(personObj);        &#125;    &#125;,    state:&#123;        personList:[&#123;id:'001',name:'张三'&#125;]    &#125;,    getters:&#123;        getFirstName(state)&#123;            return state.personList[0].name;        &#125;    &#125; &#125; export default person</code></pre><p>在store目录新建 count.js文件</p><pre><code>//求和模块import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default &#123;    namespaced:true, //开启命名空间    actions: &#123;        addOpp(context,value)&#123;          //判断是否为偶数            if(!(value%2))&#123;            context.commit('JIA',value)            &#125;else&#123;                console.log('非偶数，数未提交')            &#125;        &#125;,        addLate(context,value)&#123;        //数据想要多道处理时，可以dispatch为actions内的其他方法，无限套娃            setTimeout(()=>&#123;                context.dispatch('addLate2',value);                console.log('第一次延迟处理')            &#125;,500)        &#125;,        addLate2(context,value)&#123;      //数据经过第二道处理后，再提交            setTimeout(()=>&#123;                context.commit('JIA',value);                console.log('第二次延迟处理')            &#125;,500)        &#125;    &#125;,    mutations:&#123;        JIA(state,value)&#123;           //加            state.sum+=value        &#125;,        JIAN(state,value)&#123;          //减            state.sum-=value;        &#125;,    &#125;,    state:&#123;        sum:0,        name:'周杰伦',        song:'夜曲',    &#125;,    getters:&#123;        addTen(state)&#123;            return state.sum+10        &#125;    &#125;&#125;</code></pre><h5 id="2-在index-js中引入"><a href="#2-在index-js中引入" class="headerlink" title="2. 在index.js中引入"></a>2. 在index.js中引入</h5><p> 在store目录下index.js中引入</p><pre><code> import Vue from 'vue' import Vuex from 'vuex'Vue.use(Vuex)//引入两个配置项import count from './count'import person from './person'// 创建并暴露storeexport default new Vuex.Store(&#123;    //引入模块    modules:&#123;        //全写count: count,        count,        person    &#125; &#125;)</code></pre><h4 id="3-在main-js中引入store"><a href="#3-在main-js中引入store" class="headerlink" title="3. 在main.js中引入store"></a>3. 在main.js中引入store</h4> <pre><code>import Vue from 'vue'import App from './App.vue'import store from './store'new Vue(&#123;  render: h => h(App),  store&#125;).$mount('#app')</code></pre><h5 id="4-书写组件"><a href="#4-书写组件" class="headerlink" title="4. 书写组件"></a>4. 书写组件</h5><p>创建count.vue组件</p><pre><code>&lt;template>  &lt;div>    &lt;h2>求和案例&lt;/h2>    &lt;h2>sum经过getters预处理后&#123;&#123;addTen&#125;&#125;&lt;/h2>    &lt;h3>当前值为&#123;&#123;sum&#125;&#125;&lt;/h3>    &lt;h2>从state获取name为&#123;&#123;name&#125;&#125;,从state获取song为&#123;&#123;song&#125;&#125;&lt;/h2>        &lt;select v-model.number="num">        &lt;option value="1">1&lt;/option>        &lt;option value="2">2&lt;/option>        &lt;option value="3">3&lt;/option>        &lt;option value="4">4&lt;/option>    &lt;/select>    &lt;button @click="incrace(num)">加&lt;/button>    &lt;button @click="decrace(num)">减&lt;/button>    &lt;button @click="addOpp(num)">偶数才加&lt;/button>    &lt;button @click="addLate(num)">延迟3s加&lt;/button>    &lt;h1>组件2共享过来的人员名单&lt;/h1>   &lt;ol class="person-list">    &lt;li v-for="person in personList" :key="person.id">&#123;&#123;person.name&#125;&#125;&lt;/li>    &lt;/ol>  &lt;/div>&lt;/template>&lt;script> import &#123;mapState,mapGetters, mapMutations,mapActions&#125; from 'vuex' export default &#123;    name:'CountSum',    data()&#123;        return &#123;            num:1,        &#125;    &#125;,    //使用mapState,mapGetters, mapMutations,mapActions时更简洁    computed:&#123;        // 从count组件获取数据        ...mapState('count',&#123;sum:'sum',name:'name',song:'song'&#125;),         // 从person组件获取数据        ...mapState('person',['personList']),        ...mapGetters('count',&#123;addTen:'addTen'&#125;)    &#125;,    methods:&#123;    ...mapMutations('count',&#123;incrace:'JIA',decrace:'JIAN'&#125;),    ...mapActions('count',&#123;addOpp:'addOpp',addLate:'addLate'&#125;)    &#125; &#125;&lt;/script></code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>辅助函数指向命名空间时，需要在数据和方法名前添加命名空间名，如：...mapState('命名空间',{参数})</div><p>person.vue组件</p><pre><code>&lt;template>  &lt;div>    &lt;h2>组件2：添加成员&lt;/h2>    &lt;input type="text" v-model="personName" placeholder="添加成员">    &lt;button @click="add">添加&lt;/button>    &lt;button @click="addZhou">只添加姓周的人&lt;/button>    &lt;ul>        &lt;li v-for="person in personList" :key="person.id">&#123;&#123;person.name&#125;&#125;&lt;/li>    &lt;/ul>    &lt;h2>名单第一个人为&#123;&#123;firstPersonName&#125;&#125;&lt;/h2>    &lt;h2>组件一共享的值&lt;/h2>    &lt;h3>和为：&#123;&#123;sum&#125;&#125;&lt;/h3>  &lt;/div>&lt;/template>&lt;script>import &#123; nanoid &#125; from 'nanoid'export default &#123;    name:'CountSum',    data()&#123;        return &#123;            personName:''        &#125;    &#125;,    //不使用mapState,mapGetters, mapMutations,mapActions时更新、获取数据的方法    computed:&#123;        personList()&#123;            return this.$store.state.person.personList        &#125;,        sum()&#123;            return this.$store.state.count.sum        &#125;,        //通过getters获取时，想要指定组件名与路径        firstPersonName()&#123;            return this.$store.getters['person/getFirstName']        &#125;    &#125;,    methods:&#123;     add()&#123;        const personObj=&#123;id:nanoid(),name:this.personName&#125;;        //指定为person组件下的ADD_PERSON函数        this.$store.commit('person/ADD_PERSON',personObj);        this.personName='';     &#125;,     addZhou()&#123;         const personObj=&#123;id:nanoid(),name:this.personName&#125;;         this.$store.dispatch('person/addPersonZhou',personObj);         this.personName='';     &#125;    &#125;  &#125;&lt;/script></code></pre><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>不借助mapState等辅助函数，需要使用路径来指定命名空间名称，其中读取state中的数据使用<span class="tips">this.$store.state.配置文件名.数据名</span>来指向命名空间，而<span class="tips">dispatch</span>、<span class="tips">commit</span>、<span class="tips">getter</span>等api需要使用<span class="tips">this.$store.api名['命名空间/方法名',变量名]</span>语句来指向命名空间</div><h5 id="5-App-vue引入两个组件即可"><a href="#5-App-vue引入两个组件即可" class="headerlink" title="5. App.vue引入两个组件即可"></a>5. App.vue引入两个组件即可</h5><pre><code>&lt;template>  &lt;div id="app">    &lt;Count/>    &lt;Person/>  &lt;/div>&lt;/template> &lt;script> import Count from'./components/Count.vue' import Person from'./components/Person.vue' export default &#123;  name:'App',  components:&#123;    Count,    Person  &#125; &#125;&lt;/script></code></pre>]]></content>
    
    
    <summary type="html">Vue中用于集中式状态(数据)管理插件</summary>
    
    
    
    
    <category term="web" scheme="https://shiwei11.github.io/blog/tags/web/"/>
    
    <category term="vue" scheme="https://shiwei11.github.io/blog/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一位资深数据工程师酒后的肺腑之言(转载)</title>
    <link href="https://shiwei11.github.io/blog/2022/03/15/%E4%B8%80%E4%BD%8D%E5%8D%81%E5%B9%B4IT%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/"/>
    <id>https://shiwei11.github.io/blog/2022/03/15/%E4%B8%80%E4%BD%8D%E5%8D%81%E5%B9%B4IT%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%85%92%E5%90%8E%E7%9C%9F%E8%A8%80/</id>
    <published>2022-03-15T02:32:23.000Z</published>
    <updated>2022-07-16T18:05:37.105Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>原帖来源于Reddit论坛：<a href="https://www.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/">Drunk Post: Things I've learned as a Sr Engineer</a></div><p>最早我是在知乎上看到的，后来又陆陆续续在公众号、贴吧多次看到，最后追到了Reddit上，原帖作者是flipstables，这篇帖子目前已经获得了12k的点赞，写的很有意思。</p><h3 id="节选"><a href="#节选" class="headerlink" title="节选"></a>节选</h3><p><span class="strong">我喝醉了，这是我作为一名工程师在过去十年学到的一些东西，我可能会后悔说了这些话，但是…..醉都醉了，管他呢。</span></p><p>(1)    提升职业生涯的最好方法是换公司。</p><p>(2)    技术栈不重要。每个技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。</p><p>(3)    人们爱跳槽是有原因的。 如果对当前工作不满意，也许是时候离开了</p><p>(4)    工作和人际关系是两回事。在一些公司，我交到了好朋友，但是工作得并不开心；在另一些公司里，我没有与任何同事建立友谊，但是工作得很开心。</p><p>(5)    我学会了对经理诚实，总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。</p><p>(6)    如果我每个季度不止一次在凌晨2点被人叫醒，并且他们认为我是可以随叫随到的，那么肯定是出了很严重的问题(系统或人)，要么我得修正他们的看法(或者修复系统)，要么提桶跑路。</p><p>(7)<span class="strong">再倒一杯</span></p><p>(8)    优秀的经理和优秀的工程师有很多相似之处。</p><p>(9)    刚开始的时候，我也曾痴迷技术、编程、计算机，但现在已经翻篇了。</p><p>(10)    好的代码是能被初级工程师理解的代码。伟大的代码是可以被CS 专业的大一新生理解的代码。</p><p>(11)    作为一名工程师，最被忽视的能力是写文档。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。</p><p>(12)    网上的口水战(vim vs emacs ,mac vs linux)，几乎都无关紧要，别去参与，除了下一条。</p><p>(13)    年纪越大，我就越觉得动态语言更好，妈的，我就这么说了，有谁反对？</p><p>(14)    如果发现自己是公司里面最厉害的工程师，那就该离开了。</p><p>(15)    我不知道为什么全栈工程师的工资这么低。 不，真的，他们应该每年得到50万的年薪，只是基本工资。 妈的，他们必须了解前端和后端以及不同的浏览器如何工作，还得了解网络、数据库、缓存以及PC端和移动端之间的差异，天哪，还有公司使用的其他框架？ 说真的，为什么全栈工程师工资这么少</p><p>(16)    我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了，我喜欢实习生。</p><p>(17) <span class="strong">抿~</span></p><p>(18)    不要过于迷恋大牛，我花了 5000 美元参加了我所崇拜大牛的公开课。 他是一个才华横溢的人，但后来我意识到，他和我们其他人一样，在瞎编。</p><p>(19)    技术栈很重要。好吧，我刚刚说过不重要之类的话，但听我说完，如果你使用 Python 或 C++ 语言，就会忍不住想用这些语言做一些非同寻常的事情，因为这些语言确实适合干这些工作。</p><p>(20)    如果你不确定自己想做什么东西，请使用 Java。这是一门很糟糕的编程语言，但它几乎无所不能。</p><p>(21)    对于初学者来说，最赚钱的编程语言是 SQL，能干翻所有其他语言。就算你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。</p><p>(22)    测试很重要，但 TDD （测试驱动的开发）是个该死的邪教。</p><p>(23)    政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你得出卖你的灵魂去深究这些专有技术，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄多数在 50 岁以上是有原因的。</p><p>(24)    如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。</p><p>(25)    我从来没有在FAANG (Facebook、亚马逊、苹果、奈飞、谷歌)工作过，所以我不知道我错过了什么。但是我招过FAANG的工程师，他们也不知道自己在做什么。</p><p>(26)    自我价值不是和薪酬挂钩的函数，跟那东西没什么关系，用资本来确定自我价值很糟糕。</p><p>(27)    头衔大多无关紧要，随便什么公司都可以有首席工程师。</p><p>(28)    说到头衔，在职业生涯早期，头衔升级很好，因为这可以让你历练技能，学会担当责任。但到后期，头衔降级很好，这会让你增加薪水。</p><p>(29)    善待每一个人，不是因为这会有助于你的事业，而是因为向善本身就有回报。</p><p>(30)    如果上个月我没有从初级工程师或实习生那里学到点什么，那说明我没有上心。</p><p>(31)    <span class="strong">该死，没酒了</span></p><p>(32)    在课程、书籍、会议方面花点钱是值得的。</p><p>(33)    手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。</p><p>(34)    当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。</p><p>(35)    就算我心里讨厌某种技术，但如果我觉得他好的话，我还是会把它推荐给客户，比如我恨 Jenkins，但会把它推荐给客户，我不觉得做错了。</p><p>(36)    Git很糟糕，但我没有选择只能使用它，它的GUI可以见鬼去了，给我命令就行，大概只需要记住7个，其他的可以Google。</p><p>(37)    我喜欢团队里的半技术分析师， 因为懂编程但不懂软件工程，他们对我成长的帮助比最杰出的工程师要大得多。</p><p>(38) <span class="strong">糟糕，又没酒了</span></p><p>(39)    成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。</p><p>(40)    发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。</p><p>(41)    我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。</p><p>(42)    算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。</p><p>(43)    做自己喜欢的事情并不重要，不要让做讨厌的事情更重要。</p><p>(44)    越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。</p><p>(45)    即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。</p><p>(46)    不是所有好工作都在硅谷，但那里有很多。</p><p>(47) <span class="strong">哦，该死，我又找到啤酒了</span></p><p>(48)    结对编程很棒，只是需要花很多时间，而公司往往不想花那么多时间。</p><p>(49)    和聪明的工程师一起工作让我变成更好的码农，和聪明的非技术同事一起工作让我成为更好的工程师。</p><p>(50)    朝九晚五以外的时间就别花在工作上了，除非那个项目真的很棒，你状态很好。</p><p>(51)    人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那将是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。</p><p>(52)    好人写的代码也有烂的，聪明人写的代码也是，好的工程师也会写出糟糕的代码。不要让代码质量成为你衡量自我价值的因变量。</p><p>(53)    我进入这个行业是因为我喜欢技术，但现在工作已经毁了我的爱好。</p><p>(54)    我挣的钱还不错，对此我心存感激，不过还是得省着点用。</p>]]></content>
    
    
    <summary type="html">国外一位十年经验数据工程师的酒后吐槽，讲述了自己十年来对工作和技术的一些感悟，写的很有意思，在Reddit论坛上获得了上万的点赞</summary>
    
    
    
    
    <category term="life" scheme="https://shiwei11.github.io/blog/tags/life/"/>
    
    <category term="CS" scheme="https://shiwei11.github.io/blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>VLess+TLS+WS代理服务器搭建</title>
    <link href="https://shiwei11.github.io/blog/2022/03/10/VLess-TLS%E9%AB%98%E9%98%B6%E6%90%AD%E5%BB%BA/"/>
    <id>https://shiwei11.github.io/blog/2022/03/10/VLess-TLS%E9%AB%98%E9%98%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2022-03-10T05:51:09.000Z</published>
    <updated>2022-08-27T18:04:23.522Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>本文采用 WTFPL 许可证书，转载请不要标注任何本站信息<div><a href="https://wtfpl2.com/">WTFPL © Do What the Fuck You Want to Public License</a></div></div><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>VLESS 是一种无状态的轻量级数据传输协议，使用 UUID 进行身份验，其协议不再依赖系统时间，配置灵活。但其本身协议不带加密，因此需要配合 TLS 等加密手段。</p><h3 id="前置需要"><a href="#前置需要" class="headerlink" title="前置需要"></a>前置需要</h3><h4 id="一台可用的VPS"><a href="#一台可用的VPS" class="headerlink" title="一台可用的VPS"></a>一台可用的VPS</h4><p>国内的可以使用香港、台湾地区的服务器，如GCP在台湾的节点、softshellweb，国外的推荐vultr、搬瓦工等主流厂商，支持支付宝付款并且不容易跑路。</p><p>操作系统请选择自己熟悉的发行版，并能解决防火墙策略、开放端口等问题，这里以CentOS7为例。</p><p>安装完毕后需要测试是否能Ping通，可以直接使用ping命令尝试，或者去相关网站，国内可以通过<a href="https://ping.chinaz.com/">站长Ping工具</a>检测，国外通过<a href="https://www.yougetsignal.com/">yougetsignal</a>检测。如果国内能ping通，说明该服务器可用，可以开始搭建了。如果国外能ping通，国内无法ping通，则说明被拦截了，需要换一台服务器。如果国内国外都无法ping通，则说明服务器还未部署好，需等待几分钟后再重试。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名推荐去 godaddy 购买，顶级域名为<span class="tips">.com</span>的域名一般第一年只需要59元，<span class="tips">.cn</span>域名一般35元，最便宜的诸如<span class="tips">.live</span>结尾的域名第一年不到14元</p><p>拿到域名后将其解析到所购买的VPS IP地址，域名一般需要24h才会生效(实际不用)。</p><h4 id="SSL-TLS证书"><a href="#SSL-TLS证书" class="headerlink" title="SSL/TLS证书"></a>SSL/TLS证书</h4><p>SSL/TLS证书可以从以下平台免费获取，证书有效期一般为90天，90天后需要更换</p><ul><li>zerossl：<a href="https://zerossl.com/">https://zerossl.com/</a></li><li>letsencrypt：<a href="https://letsencrypt.org/">https://letsencrypt.org/</a></li><li>FreeSSL：<a href="https://freessl.org/">https://freessl.org/</a></li><li>SSL For Free：<a href="https://www.sslforfree.com/">https://www.sslforfree.com/</a></li></ul><p>将获取的证书、密钥文件上传到服务器上，在配置文件时使用。如果不想手动更新SSL证书，可以使用脚本自动更新<br>脚本地址：<a href="https://github.com/acmesh-official/acme.sh">https://github.com/acmesh-official/acme.sh</a></p><h3 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h3><h4 id="安装V2fly"><a href="#安装V2fly" class="headerlink" title="安装V2fly"></a>安装V2fly</h4><p>Github开源地址：<a href="https://github.com/v2fly/fhs-install-v2ray">https://github.com/v2fly/fhs-install-v2ray</a></p><p>安装/更新 v2fly命令：</p><pre><code>bash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)</pre></code><p>安装完成后，配置文件放在<span class="tips">/usr/local/etc/v2ray/config.json</span>路径下</p><h4 id="Google-BBR加速算法"><a href="#Google-BBR加速算法" class="headerlink" title="Google BBR加速算法"></a>Google BBR加速算法</h4><p>TCP BBR(Bottleneck Bandwidth and Round-trip propagation time)是由Google于2016年发布的一种拥塞控制算法，可以显著地提高Linux服务器吞吐量并减少TCP连接的延迟</p><p>安装bbrplus：</p><pre><code>wget "https://github.com/cx9208/bbrplus/raw/master/ok_bbrplus_centos.sh" && chmod +x ok_bbrplus_centos.sh && ./ok_bbrplus_centos.sh</code></pre><p>安装完毕需要重启系统，重启完毕可通过<span class="tips">uname -r</span>命令查询内核，返回bbr相关值说明升级完成，通过命令<span class="tips">lsmod | grep bbr</span>查看是否载入bbr系统模块，返回bbr相关值说明已经加载。</p><p>CentOS8+系统内核自带BBR，开启方法可自行百度。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><p>使用vim在<span class="tips">/usr/local/etc/v2ray/config.json</span>配置文件中添加配置设置。</p><pre><code>&#123;  &#123;    "log": &#123;    "loglevel": "warning",    "access": "/var/log/v2ray/access.log",       "error": "/var/log/v2ray/error.log"  //日志输出路径    &#125;,    "inbounds": [&#123;    "port": 8180 ,  //监听端口    "protocol": "vless",//主传入协议    "settings": &#123;    "decryption": "none",    "clients": [    &#123;    "id": "41803377-5789-4bf5-8cb4-dd6ad659554c",//UUID    "level": 0        &#125;      ]    &#125;,    "streamSettings": &#123;    "network":"ws",  //传输协议    "security": "tls", //传输层安全    "wsSettings":&#123;    "path":"/",     //路径    "headers":&#123;&#125;    &#125;,    "tlsSettings": &#123;    "serverName": "newyear101.xyz", //域名    "certificates": [&#123;    "certificateFile": "/etc/ssl/certificate.crt",//SSL证书路径    "keyFile": "/etc/ssl/private.key" //密钥路径            &#125;]         &#125;      &#125;    &#125;],    "outbounds": [&#123;    "protocol": "freedom",//主传出协议    "settings": &#123;&#125;    &#125;,&#123;    "protocol": "blackhole",    "settings": &#123;&#125;,    "tag": "blocked"    &#125;],    "routing": &#123;    "rules": [    &#123;    "type": "field",    "ip": ["geoip:private"],    "outboundTag": "blocked"        &#125;      ]   &#125; &#125;</code></pre><ul><li>UUID作为唯一身份识别码，可通过客户端生成，或通过UUID生成网站获得，不能自行编写<h5 id="检测配置文件是否正确"><a href="#检测配置文件是否正确" class="headerlink" title="检测配置文件是否正确"></a>检测配置文件是否正确</h5>v2ray官方检测命令：<pre><code>/usr/local/bin/v2ray -test -config  /usr/local/etc/v2ray/config.json</pre></code>文件正确会返回值：<div class="shell">V2Ray 4.44.0 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.17.3 linux/amd64)A unified platform for anti-censorship.2021/02/03 21:46:12 [Info] main/jsonem: Reading config: /usr/local/etc/v2ray/config.jsonConfiguration OK.</div></li></ul><h4 id="更新防火墙规则"><a href="#更新防火墙规则" class="headerlink" title="更新防火墙规则"></a>更新防火墙规则</h4><h5 id="Centos-7-8-firewalld-放行端口"><a href="#Centos-7-8-firewalld-放行端口" class="headerlink" title="Centos 7/8 firewalld 放行端口"></a>Centos 7/8 firewalld 放行端口</h5><div class="show">// 8180改成自己的端口号firewall-cmd --permanent --add-port=8180/tcp //重启使之生效firewall-cmd --reload</div><h5 id="ubuntu系统-ufw放行端口"><a href="#ubuntu系统-ufw放行端口" class="headerlink" title="ubuntu系统 ufw放行端口"></a>ubuntu系统 ufw放行端口</h5><div class="show">//8180改成自己的端口号sudo ufw allow 8180/tcp//重启sudo ufw reload</div><h5 id="Centos-6-7-iptable放行端口"><a href="#Centos-6-7-iptable放行端口" class="headerlink" title="Centos 6/7 iptable放行端口"></a>Centos 6/7 iptable放行端口</h5><div class="show">//8180改成自己的端口号iptables -I INPUT -p tcp --dport 8180 -j ACCEPT//保存添加的规则链service iptables save</div><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端需要使用4.23.2以上内核</p><h4 id="客户端下载地址："><a href="#客户端下载地址：" class="headerlink" title="客户端下载地址："></a>客户端下载地址：</h4><ul><li><strong>Android</strong>: <a href="https://github.com/2dust/v2rayNG/releases">v2rayNG</a></li><li><strong>windows</strong>:<a href="https://github.com/2dust/v2rayN/releases">v2rayN</a></li><li><strong>MacOS</strong>:<a href="https://github.com/yanue/V2rayU/releases">V2rayU</a></li></ul><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><div class="table"><table><thead><tr><th>配置项</th><th>值</th></tr></thead><tbody><tr><td>别名</td><td>任意</td></tr><tr><td>地址</td><td>VPS的IP地址</td></tr><tr><td>端口</td><td>配置文件中的端口号</td></tr><tr><td>用户ID</td><td>UUID,需要和配置文件一致</td></tr><tr><td>传输协议</td><td>ws</td></tr><tr><td>伪装域名</td><td>解析的域名</td></tr><tr><td>路径</td><td>配置文件中的路径</td></tr><tr><td>传输层安全</td><td>tls</td></tr></tbody></table></div><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h4><p>如果已经启动v2ray服务，修改的配置文件需要重启生效</p><ul><li><strong>systemctl start v2ray</strong> 运行</li><li><strong>systemctl stop v2ray</strong> 停止</li><li><strong>systemctl restart v2ray</strong> 重启</li></ul><h4 id="常用服务命令"><a href="#常用服务命令" class="headerlink" title="常用服务命令"></a>常用服务命令</h4><h5 id="生成uuid"><a href="#生成uuid" class="headerlink" title="生成uuid"></a>生成uuid</h5><p> <span class="strong">v2ctl uuid</span> 生成一个新的uuid</p><h5 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h5><p> <span class="strong">v2ray [参数]</span></p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-version</td><td>查看当前版本</td></tr><tr><td>-test</td><td>测试配置文件有效性</td></tr><tr><td>-config</td><td>手动指定配置文件，值可以是绝对路径、相对路径、url链接、”stdin:”(从标准输入读取内容)</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">大二的时候整理的一篇笔记，在原笔记的基础上改用了后面新出的协议，并系统整理了一下可能用到的命令。</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="VPS" scheme="https://shiwei11.github.io/blog/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Nginx笔记(上)</title>
    <link href="https://shiwei11.github.io/blog/2022/03/04/nginx%E7%AC%94%E8%AE%B0/"/>
    <id>https://shiwei11.github.io/blog/2022/03/04/nginx%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T02:53:39.000Z</published>
    <updated>2023-05-02T07:19:28.085Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>nginx官方文档：<a target="_blank" href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></div><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h4><p>Nginx是一款高性能的Web服务器软件，能在高并发环境下快速响应http/https请求，同时也提供IMAP/POP3/SMTP服务,可用于反向代理服务器、虚拟主机、域名解析、负载均衡、防盗链、URL重定向、http/https、邮件代理服务器等各类场景。</p><p>根据<a href="https://news.netcraft.com/">Netcraft</a> 发布的web服务器调查报告，截至2022年1月，nginx是全球最常用的web服务器软件，占有全球32.3%的站点，另一服务器软件Apache占有23.9%的站点，很大一部分web服务器使用Nginx作为负载均衡服务器。</p><h4 id="依赖与环境"><a href="#依赖与环境" class="headerlink" title="依赖与环境"></a>依赖与环境</h4><p><strong>操作系统要求：</strong>Nginx底层使用了多进程和I/O多路复用(epoll)来提高并发能力，因此需要使用Linux2.6以上的内核以支持epoll</p><p><strong>源码包依赖：</strong></p><ul><li>GCC编译器：编译C语言</li><li>PCRE库(兼容正则表达式库)：用于支持正则表达式</li><li>zlib库：为Nginx的gzip压缩提供压缩算法</li><li>OpenSSL：提供安全通信</li></ul><h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p>master进程：主进程，以root权限运行，负责读取检测配置文件，启动和管理worker进程</p><p>worker进程：工作进程，权限由配置文件中的user决定，负责处理网络请求，进程数量由配置文件中的worker_processes决定</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="Nginx服务命令"><a href="#Nginx服务命令" class="headerlink" title="Nginx服务命令"></a>Nginx服务命令</h4><p>未配置全局环境变量的情况下，nginx命令执行路径为<span class="tips">/usr/local/nginx/sbin</span>，可以通过./nginx -h查看所有命令</p><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>./nginx</td><td>启动nginx</td></tr><tr><td>./nginx -h</td><td>-h可替换为-?,查看nginx的所有命令</td></tr><tr><td>./nginx -v</td><td>查看nginx的版本</td></tr><tr><td>./nginx -s 信号量</td><td>发送一个信号量操作nginx</td></tr><tr><td>./nginx -s stop</td><td>强制关闭nginx</td></tr><tr><td>./nginx -s quit</td><td>停止接受新请求，等待nginx处理完当前任务后关闭nginx</td></tr><tr><td>./nginx -s reload</td><td>重新加载配置文件</td></tr><tr><td>./nginx -s reopen</td><td>重新打开日志文件(可用于日志分割)</td></tr><tr><td>./nginx -t [文件路径]</td><td>检测nginx的配置文件是否书写正确</td></tr><tr><td>./nginx -T</td><td>检测nginx的配置文件是否书写正确，若正确则将内容输出到屏幕</td></tr><tr><td>./nginx -c 文件路径</td><td>手动指定nginx的配置文件后启动</td></tr></tbody></table></div><h4 id="Linux系统命令"><a href="#Linux系统命令" class="headerlink" title="Linux系统命令"></a>Linux系统命令</h4><p><span class="strong">kill -信号 master进程PID</span></p><div class="table"><table><thead><tr><th>信号</th><th>说明</th></tr></thead><tbody><tr><td>TERM/INT</td><td>强制关闭nginx</td></tr><tr><td>QUIT</td><td>停止接受新请求，处理完当前任务后关闭nginx</td></tr><tr><td>HUP</td><td>重新加载配置文件</td></tr><tr><td>USR1</td><td>重新打开日志文件(可用于日志分割)</td></tr><tr><td>USR2</td><td>不停止服务，平滑升级到最新版nginx</td></tr><tr><td>WINCH</td><td>停止接受新请求，处理完当前任务后关闭所有worker进程</td></tr></tbody></table></div><h5 id="关于平滑升级"><a href="#关于平滑升级" class="headerlink" title="关于平滑升级"></a>关于平滑升级</h5><p>执行 <span class="tips">kill -USR2 17482</span>(假设17482为master进程PID)命令进行平滑升级时，更新完ngixn后会开启一个新版本nginx对应的master进程和work进程，此时系统中将会有两个master进程，并且新版本的master进程PID会被记录在<span class="tips">/usr/loca1/nginx/logs/nginx.pid</span>文件中，而旧版本master进程PID会被记录在<span class="tips">/usr/loca1/nginx/logs/nginx.pid.oldbin</span>文件中，之后会发送QUIT信号给旧的master进程，让其处理完请求后关闭，完成升级。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件位于<span class="tips">/usr/local/nginx/conf/nginx.conf</span>路径下</p><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><div class="show">#user  nobody;          //指定nginx工作进程的用户身份，默认为nobodyworker_processes  1;   //允许生成的worker process数<p>#error_log  logs/error.log;     //日志级别与存放路径<br>#error_log  logs/error.log  notice;<br>#error_log  logs/error.log  info;</p><p>#pid        logs/nginx.pid; //master进程pid存放路径<br>……</div></p><h5 id="user配置进程权限"><a href="#user配置进程权限" class="headerlink" title="user配置进程权限"></a>user配置进程权限</h5><p><span class="strong">user 用户名 [用户组];</span></p><p>默认为nobody，配置决定了worker进程的调用用户，以及nginx对文件(一般指资源文件和目录)的读写权限，而日志文件、pid文件、配置文件等由master进程调用的文件则不受此配置影响，所有者一般为root。当配置的用户对指定文件无访问权限时，Nginx将返回403错误，此时需要授予该用户相关权限，或者更改为权限更高的用户。</p><h5 id="worker-processes配置进程数量"><a href="#worker-processes配置进程数量" class="headerlink" title="worker_processes配置进程数量"></a>worker_processes配置进程数量</h5><ul><li><span class="strong">master_process on/off;</span>用于指定是否生成worker进程，默认为on</li><li><span class="strong">worker_processes 值/auto;</span>指定worker进程生成数量，默认为1</li></ul><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>worker_processes值越大，处理并发能力越强。但需要考虑服务器的CPU核心数、内存余量等硬件资源大小</div><h5 id="daemon配置nginx为守护进程"><a href="#daemon配置nginx为守护进程" class="headerlink" title="daemon配置nginx为守护进程"></a>daemon配置nginx为守护进程</h5><p><span class="strong">daemon on/off;</span></p><p>配置nginx是否以守护进程方式启动，并在后台运行，默认为on</p><h5 id="error-log配置日志"><a href="#error-log配置日志" class="headerlink" title="error_log配置日志"></a>error_log配置日志</h5><p><span class="strong">error_log 路径 [日志级别];</span></p><p>配置日志路径和记录级别，这里指Nginx本身运行错误产生的日志，用户连接产生的日志需要在http/https块里配置，默认将notice以上级别的日志写入error.log日志文件中，日志级别有 debug、info、notice、warn、error、crit</p><h5 id="pid配置pid文件路径"><a href="#pid配置pid文件路径" class="headerlink" title="pid配置pid文件路径"></a>pid配置pid文件路径</h5><p><span class="strong">pid 路径;</span></p><p>自定义pid文件路径，默认在/usr/local/nginx/logs/nginx.pid路径下。pid文件用于存放master进程的pid，会在master进程产生时生成，进程关闭时删除。当使用nginx -s reload/reopen重新加载配置文件或日志时，nginx会到该文件中读取进程pid，如果该文件无法找到或者已经被删除，nginx将报错，常用的解决方法是使用<span class="tips">nginx -c 配置文件名</span>命令重新指定配置文件后启动nginx</p><h4 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h4><div class="show">...events {    worker_connections  1024;//每个worker允许的最大连接数}</div><h5 id="accept-mutex配置网络连接序列号"><a href="#accept-mutex配置网络连接序列号" class="headerlink" title="accept_mutex配置网络连接序列号"></a>accept_mutex配置网络连接序列号</h5><p><span class="strong">accept_mutex on/off;</span></p><p>默认为on，用于解决“惊群”问题，即将连接到nginx的网络连接进行序列化，并依次分配给worker进程，防止多个worker争抢连接。</p><h5 id="accept-mutex配置网络连接序列号-1"><a href="#accept-mutex配置网络连接序列号-1" class="headerlink" title="accept_mutex配置网络连接序列号"></a>accept_mutex配置网络连接序列号</h5><p><span class="strong">multi_accept on/off;</span></p><p>默认为off，在off状态下，一个worker进程只能接收一个新的连接请求，否则，一个worker进程将同时接收所有新连接。</p><h5 id="worker-connections配置单进程最大连接数"><a href="#worker-connections配置单进程最大连接数" class="headerlink" title="worker_connections配置单进程最大连接数"></a>worker_connections配置单进程最大连接数</h5><p><span class="strong">worker_connections 值;</span></p><p>默认为1024，用于配置每个worker允许的最大连接数，值不能超过操作系统最大文件句柄数量。</p><h5 id="use配置事件处理模型"><a href="#use配置事件处理模型" class="headerlink" title="use配置事件处理模型"></a>use配置事件处理模型</h5><p><span class="strong">use 参数;</span></p><p>可选参数有poll/select/epoll/kqueue等，Linux2.6以上内核默认使用epoll函数以优化并发连接能力。</p><h4 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h4><div class="shell">http {    include       mime.types;   //引入外部文件mime.types    default_type  application/octet-stream;    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main; //定义access连接日志的路径与内容//快速传输文件    sendfile        on;    #tcp_nopush     on;//服务器保持连接最大时间，单位为s    #keepalive_timeout  0;    keepalive_timeout  65;//传输文件前是否压缩    #gzip  on;    ....</div><h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p><span class="strong">include 文件名;</span></p><ul><li>用于引入外部文件，管理员可以定义一个外部文件书写配置，然后通过include将该文件内容引入到相应位置。</li><li>这里引入的mime.types用于标识文档、媒体文件格式和类型，该文件标识了常用的html、css、js、jpg等文件类型，用于帮助nginx识别请求的文件类型</li></ul><h5 id="default-type"><a href="#default-type" class="headerlink" title="default_type"></a>default_type</h5><p><span class="strong">default_type MIME类型;</span></p><p>默认值application/octet-stream指没有特定类型的二进制文件，MIME类型可参考MDN文档：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" style="word-wrap: break-word;">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></p><h5 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h5><ul><li><span class="strong">log_format 变量名 日志格式;</span></li><li><span class="strong">access_log 路径 变量名;</span></li></ul><p>二者搭配使用，第一个语句用于定义一个变量名，并将配置的日志格式赋值给该变量，变量名取值需使用<span class="tips">$</span>符。第二个语句用于根据变量名对应的日志格式，将用户访问日志书写到对应路径下。日志格式中对应的变量含义：</p><div class="table"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>remote_addr</td><td>客户端地址</td></tr><tr><td>remote_user</td><td>客户端用户名</td></tr><tr><td>time_local</td><td>访问时间和时区</td></tr><tr><td>request</td><td>请求的URL和HTTP协议</td></tr><tr><td>http_host</td><td>请求地址，即浏览器中输入的地址</td></tr><tr><td>status</td><td>http请求返回的状态码，如：301、404等</td></tr><tr><td>upstream_status</td><td>upstream状态</td></tr><tr><td>body_bytes_sent</td><td>发送给客户端的文件大小(字节)</td></tr><tr><td>http_referer</td><td>该请求是从哪个链接跳转过来</td></tr><tr><td>http_user_agent</td><td>客户端信息，如：浏览器标识等</td></tr><tr><td>ssl_protocol</td><td>SSL协议版本</td></tr><tr><td>ssl_cipher</td><td>交换数据中的算法</td></tr><tr><td>request_time</td><td>整个请求的总时间</td></tr><tr><td>upstream_addr</td><td>upstream的地址，即真正提供服务的主机地址</td></tr><tr><td>http_x_forwarded_for</td><td>记录有代理服务器时客户端地址的配置</td></tr><tr><td>upstream_response_time</td><td>请求过程中，upstream响应时间</td></tr></tbody></table></div><h5 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h5><ul><li><span class="strong">sendfile on/off;</span></li><li><span class="strong">tcp_nopush on/off;</span></li></ul><p>sendfile用于高效传输文件，在sendfile为on的状态下，开启tcp_nopush会将文件积累到一定大小后再统一发送，用于提高包传输效率</p><h5 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h5><ul><li><span class="strong">keepalive_timeout 值;</span></li><li><span class="strong">tcp_nodelay on/off;</span></li></ul><p>keepalive_timeout用于设置保持与客户端连接的最大时间，单位默认为s，超时时nginx会关闭连接并释放服务器资源，若设置为0则禁用该设置。设置的时间过大会导致大量的无效连接未断开，从而占用服务器资源，太小会导致服务未处理完，就被强制关闭连接。</p><p>在keepalive_timeout启用状态下，配置tcp_nodelay on;可以将数据即使发送。</p><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><p><span class="strong">gzip on/off;</span></p><p>gzip 用于配置传输文件前是否进行压缩以提高传输速率，压缩会占用一定系统资源</p><h4 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h4><div class="show">server {        listen      80;   //监听端口        server_name  localhost;//监听的域名或ip地址        #charset koi8-r;        #access_log  logs/host.access.log  main;//日志输出路径        location /web/ {  //路由路径            root   /test;            index  index.html index.htm;        }        location /images {            root /test;            autoindex on;//自动生成文件归档页面        }        location /.well-known/pki-validation/{        root /;        }        location /new/{        root    /;        add_header Content-Disposition "attachment;";        }//定义404页面        #error_page  404              /404.html;//定义50x页面        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }</div><h5 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h5><p><span class="strong">listen 地址/端口 [default_server];</span></p><p>配置监听地址和端口，default_server参数用于将该server设置为默认主机，无该参数则第一个server为默认主机，当没有匹配到客户端指定的端口/IP时，将连接到默认主机。地址和端口格式可以为：</p><ul><li>listen 127.0.0.1 监听该地址所有端口</li><li>listen 127.0.0.1:8080 监听该地址的8080端口</li><li>listen *:8080 监听所有地址的8080端口</li></ul><h5 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h5><p><span class="strong">server_name 域名/IP地址;</span></p><p>用于配置虚拟主机的标识名称，域名或IP地址可以写多个，使用空格隔开。当listen中配置了域名或IP地址，则server_name配置的域名和IP地址将失效，配置方法可以使用以下三种，当域名被多个server匹配到，将按精确匹配&gt;通配符在开头&gt;通配符在结尾&gt;正则匹配&gt;默认主机的优先级进行分配。</p><h6 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h6><div class="show">server {    listen 80;    server_name aaaa.com bbbbb.cn;//配置多个域名    .....}</div><h6 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h6><p>通配符只能在段首和段尾使用，不能再域名中间使用！</p><div class="show">server {    listen 80;    server_name *.aaaa.com www.aaaa.*;    .....}</div><h6 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h6><div class="show">server {    listen 80;    server_name ~正则表达式;    .....}</div><h5 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h5><p><span class="strong">charset 编码格式;</span><br>charset 用于指定字符编码格式，默认的koi8-r为俄语编码格式(nginx作者是俄罗斯人)，与utf-8类似</p><h5 id="access-log-1"><a href="#access-log-1" class="headerlink" title="access_log"></a>access_log</h5><p><span class="strong">access_log 路径 日志格式;</span></p><p>用于指定该server的连接日志，日志格式默认使用http模块中的main变量定义的格式，可用<span class="tips">log_format</span>命令自行定义。</p><h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><p><span class="strong">location 请求路径;</span></p><p>配置请求路径，可配置多个location块用于响应不同请求</p><div class="show">location  /路径{   //在test目录下匹配该路径(默认)    root /test}location = /路径{   //在test目录下精准匹配该路径    root /test}location ~* \正则表达式  {   //在test目录下正则匹配(添加*号不区分大小写)    root  /test            }~用于标识正则表达式，*表示不区分大小写，^~则表示不包含正则表达式，功能和不加~一致</div><h5 id="root-alias"><a href="#root-alias" class="headerlink" title="root/alias"></a>root/alias</h5><p><span class="strong">root/alias 路径;</span></p><p>用于指定资源查找路径，使用root语句时，客户端请求location路径，Nginx查找资源会直接前往<span class="tips">root路径+location路径</span>。alias一般在需要隐藏服务器真实路径时使用，查找资源会直接前往alias路径，location路径仅作为客户端请求的虚拟路径</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p><span class="strong">index 文件名;</span></p><p>用于设置主页，文件名可以写多个，如: index index1.html index2.html;当找不到第一个文件时，会依次往后查找。</p><h5 id="error-page"><a href="#error-page" class="headerlink" title="error_page"></a>error_page</h5><p><span class="strong">error_page 状态码 [=状态码] 路径;</span></p><p>用于设置错误处理方法，根据不同的状态码，进行相应处理，常用于配置404，50x页面，可以通过添加[=状态码]修改返回给客户端的状态码，如：error_page 404 [=200] /404.html，浏览器收到的状态码将从404修改为200。路径可以为：</p><ul><li>地址：error_page 404 http://<span></span>wrong.com</li><li>重定向:<div class="show">error_page   500 502 503 504  /50x.html;<br>location = /50x.html {<br>root   html;<br>}</div></li><li>返回信息:<div class="show">error_page 404 @goto<br>loaction @goto{<br>  default_type text/plain;<br>  return 404 ‘not found….’<br>}</div></li></ul><h3 id="Web服务器配置实例"><a href="#Web服务器配置实例" class="headerlink" title="Web服务器配置实例"></a>Web服务器配置实例</h3><p><strong>需求：</strong>在服务器8081和8082端口分别配置server1、server2两个服务，每个服务下有两个页面，根据客户端请求返回不同页面，为每个服务配置单独的访问日志。</p><h4 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h4><p>webservers目录位于服务器根目录下，conf.d目录用于存放每个服务的配置文件，web目录用于存放页面和访问日志。每个服务下的logs目录用于存放access_log日志文件，webpages目录用于存放页面。</p><div class="shell">webservers     |____conf.d     |          |_____server1.conf     |          |_____server2.conf     |____web           |____404.html           |____server1           |          |____logs——access_log           |          |____webpages           |                |____web1.html           |                |____web2.html           |____server2                      |_____logs——access_log                      |_____webpages                                 |_____web3.html                                 |_____web4.html</div><h4 id="http块配置"><a href="#http块配置" class="headerlink" title="http块配置"></a>http块配置</h4><p>定义两个变量server1和server2，用于配置日志格式，两个服务的配置文件独立存放于/webservers/conf.d路径下，使用include引入nginx.conf配置文件中。</p><div class="show">http{    ......    log_format server1 'new access =>$time_local';    log_format server2 'new access =>$time_local';    include /webservers/conf.d/*.conf;//引入两个服务的配置文件}</div><h4 id="server1配置"><a href="#server1配置" class="headerlink" title="server1配置"></a>server1配置</h4><p>访问<span class="tips"><code>http://45.77.77.10:8081</code></span>访问web1页面</p><p>访问<span class="tips"><code>http://45.77.77.10:8081/pages</code></span>访问web2页面</p><pre><code>server&#123;    listen 8081;    server_name 45.77.77.10;    access_log /webservers/web/server1/logs/access.log server1;    error_page 404 /404.html;    location /&#123;    alias /webservers/web/server1/webpages/;    index web1.html;    &#125;    location /pages&#123;    alias /webservers/web/server1/webpages/;    index web2.html;    &#125;    location =/404.html&#123;    root /webservers/web;    index 404.html;    &#125;      &#125;</code></pre><h5 id="server2配置"><a href="#server2配置" class="headerlink" title="server2配置"></a>server2配置</h5><p>访问<span class="tips"><code>http://45.77.77.10:8082/web3.html</code></span>访问web3页面</p><p>访问<span class="tips"><code>http://45.77.77.10:8082/webpages</code></span>访问web4页面</p><pre><code>server&#123;    listen 8082;    server_name 45.77.77.10;    access_log /webservers/web/server2/logs/access.log server2;    error_page 404 /404.html;    location /web3.html&#123;    root /webservers/web/server2/webpages;    index web3.html;    &#125;        location /webpages&#123;    root /webservers/web/server2;    index web4.html;    &#125;    location =/404.html&#123;    root /webservers/web;    index 404.html;    &#125;      &#125;</code></pre><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>配置https服务时，使用<span class="tips">ssl_certificatessl 路径</span>语句配置证书，使用<span class="tips">ssl_certificate_key 路径</span>配置密钥</div><h3 id="静态资源提供服务"><a href="#静态资源提供服务" class="headerlink" title="静态资源提供服务"></a>静态资源提供服务</h3><pre><code>http &#123;    .......gzip on;gzip_min_length 1;  //设置最小压缩大小，小于1字节的文件不进行压缩gzip_comp_level 3; //压缩级别(压缩比)，取值范围为1-9，值越大，压缩越多，cpu占用率越高gzip_types text/css text/javascript; //配置压缩的文件类型    server &#123;        listen      80;        server_name  45.77.78.10;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /images/ &#123;  //匹配路径        root /test;         //资源所在路径        autoindex on;  //自动生成资源归档页面         &#125;        location /images &#123;  //匹配路径        root /test;         //资源所在路径         &#125;         location /other/ &#123;  //匹配路径        alias /test/images;         //资源所在路径         &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;        .....    &#125;    ........&#125;</code></pre><p>test目录服务器根目录下，并且在/test/images路径下存放了photo.jpg照片</p><ul><li>使用第一个location配置时，当访问 http:<span></span>//45.77.78.10/images/ 时，ngxin会在自动生成的归档页面上输出/test/images/目录下的所有文件。请求只能为location后面配置的参数，若请求为 http:<span></span>//45.77.78.10/test/images/则会返回404</li><li>使用第二个location配置时，由于未使用 <span class="tips">autoindex on</span> 配置，nginx不会生成归档页面，当访问 http:<span></span>//45.77.78.10/images/ 时nginx将返回403，访问文件需指定具体文件路径，如：http:<span></span>//45.77.78.10/test/images/photo.jpg</li><li>当需要对访问者隐藏服务器实际文件路径时，可以使用<span class="tips">alias</span>进行配置，使用第三个location配置，url应当为http:<span></span>//45.77.78.10/other/photo.jpg，此时实际访问的依旧alias指定的/test/images路径下的文件</li></ul>]]></content>
    
    
    <summary type="html">Nginx是一款高性能的Web服务器软件，也可用于配置反向代理、虚拟主机、域名解析、负载均衡、邮件代理等各类服务器</summary>
    
    
    
    
    <category term="Server" scheme="https://shiwei11.github.io/blog/tags/Server/"/>
    
    <category term="Web" scheme="https://shiwei11.github.io/blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Redhat防火墙</title>
    <link href="https://shiwei11.github.io/blog/2022/02/23/Centos%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://shiwei11.github.io/blog/2022/02/23/Centos%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2022-02-23T08:18:13.000Z</published>
    <updated>2022-04-04T20:19:57.613Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>本文不涉及Debian系列操作系统使用的ufw(Uncomplicated FireWall)防火墙</div><h3 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h3><p>Firewalld支持动态更新防火墙规则，并加入了区域（zone）的概念，zone是Firewalld预先准备的几套防火墙策略模板，用户可以根据不同生产场景选择合适的策略集合，从而实现防火墙策略之间的快速切换。</p><h4 id="常用的区域"><a href="#常用的区域" class="headerlink" title="常用的区域"></a>常用的区域</h4><div class="table"><table><thead><tr><th>区域</th><th>默认策略</th></tr></thead><tbody><tr><td>trusted(信任)</td><td>允许所有数据包</td></tr><tr><td>block(阻塞)</td><td>拒绝所有数据包</td></tr><tr><td>drop(丢弃)</td><td>丢弃所有数据包，并且不回复信息</td></tr><tr><td>home(家庭)</td><td>仅接受与流出数据有关，或者与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关的数据包</td></tr><tr><td>public(公共)</td><td>仅接受与流出数据有关，或与ssh、dhcpv6-client服务相关的数据包</td></tr><tr><td>internal(内部)</td><td>仅接受与流出数据有关，或与ssh、mdns、ipp-client、dhcpv6-client服务相关的数据包</td></tr><tr><td>work(工作)</td><td>仅接受与流出的流量，或与ssh、ipp-client与dhcpv6-client服务相关的数据包</td></tr><tr><td>external(外部)</td><td>仅接受与流出流量和ssh服务相关的数据包</td></tr><tr><td>DMZ(隔离)</td><td>又称为非军事区域，内外网络之间增加的一层网络，起到缓冲作用，仅接受与流出的流量相关和ssh服务相关的数据包</td></tr></tbody></table></div><p>firewalld默认提供了9个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、 home.xml、internal.xml、public.xml、trusted.xml、work.xml，文件位于<span class="tips">/usr/lib /firewalld/zones/</span>目录下。用户对区域进行修改后，会在<span class="tips">/etc/firewalld/zones</span>目录下生成对应的(用户自定义)配置文件。</p><h4 id="防火墙开启与关闭"><a href="#防火墙开启与关闭" class="headerlink" title="防火墙开启与关闭"></a>防火墙开启与关闭</h4><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>systemctl start firewalld</td><td>开启防火墙</td></tr><tr><td>systemctl stop firewalld</td><td>关闭防火墙</td></tr><tr><td>systemctl enable firewalld</td><td>开机自启动防火墙</td></tr><tr><td>systemctl disable firewalld</td><td>禁止开机自启动</td></tr><tr><td>systemctl status firewalld</td><td>查看防火墙状态</td></tr></tbody></table></div><h4 id="命令与参数"><a href="#命令与参数" class="headerlink" title="命令与参数"></a>命令与参数</h4><p><span class="strong">firewall-cmd [参数]</span></p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-&zwnj;-state</td><td>查看防火墙是否在运行</td></tr><tr><td>-&zwnj;-get-default-zone</td><td>查看当前生效的防火墙区域</td></tr><tr><td>-&zwnj;-set-default-zone=区域名</td><td>设置生效的防火墙区域</td></tr><tr><td>-&zwnj;-get-zones</td><td>显示所有可用的区域</td></tr><tr><td>-&zwnj;-get-active-zones</td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td>-&zwnj;-zone=区域名 -&zwnj;-list-all</td><td>列出指定区域的所有配置参数</td></tr><tr><td>-&zwnj;-list-all-zones</td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td>-&zwnj;-get-services</td><td>查看当前域所有支持的服务(需要放行的服务需要自行添加)</td></tr><tr><td>-&zwnj;-list-services</td><td>查看当前区域允许放行的服务列表</td></tr><tr><td>-&zwnj;-add-service=服务名</td><td>设置当前区域允许该服务的流量通过</td></tr><tr><td>-&zwnj;-add-port=端口号/协议</td><td>设置当前区域允许该端口的流量通过</td></tr><tr><td>-&zwnj;-remove-service=服务名</td><td>设置默认区域禁止该服务的流量通过</td></tr><tr><td>-&zwnj;-remove-port=端口号/协议</td><td>设置当前区域禁止该端口的流量通过</td></tr><tr><td>-&zwnj;-add-source=</td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td>-&zwnj;-remove-source=</td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td>-&zwnj;-add-interface=网卡名</td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td>-&zwnj;-change-interface=网卡名</td><td>将某个网卡与区域进行关联</td></tr><tr><td>-&zwnj;-list-all</td><td>显示当前区域的网卡、资源配置，以及开放了哪些端口、服务</td></tr><tr><td>-&zwnj;-reload</td><td>让“永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td>-&zwnj;-panic-on</td><td>开启应急状况模式(关闭所有网络连接，包括远程ssh连接)</td></tr><tr><td>-&zwnj;-panic-off</td><td>关闭应急状况模式</td></tr></tbody></table></div><h4 id="生效模式，更新防火墙规则"><a href="#生效模式，更新防火墙规则" class="headerlink" title="生效模式，更新防火墙规则"></a>生效模式，更新防火墙规则</h4><p>默认情况下，firewalld配置的防火墙策略为当前生效模式(Runtime)，系统重启时会失效。想让配置策略永久生效，需要添加<span class="tips">-&zwnj;-permanent</span>参数使用永久模式(Permanent)，如：永久开放10800端口：firewall-cmd -&zwnj;-add-port=10800/tcp -&zwnj;-permanent ，但该模式配置的策略需要执行firewall-cmd -&zwnj;-reload命令重新加载后才会生效。</p><div class="table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>firewall-cmd -&zwnj;-reload</td><td>重新加载防火墙配置</td></tr><tr><td>firewall-cmd -&zwnj;-complete-reload</td><td>重新加载防火墙，不中断用户的连接,如远程连接（防火墙出严重故障时使用）</td></tr></tbody></table></div><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>1. 查看区域信息</strong></p><div class="shell">查看public区域的所有信息# firewall-cmd --zone=public --list-all返回值的含义：Target：default                  //目标icmp-block-inversion：yes/no    //是否允许ICMP协议类型的数据包通过防火墙Interfaces：                   //关联的网卡sources：                     //来源，可以是IP地址或mac地址services：                   //允许的服务ports：                     //允许的端口，即本地开放的端口protocols：                //允许通过的协议masquerade: yes/no        //是否允许伪装，可改写来源IP地址及mac地址 forward-ports：          //允许转发的端口 source-ports：          //允许的来源端口 icmp-blocks：         //可添加的ICMP类型，当icmp-block-inversion为no时，这些ICMP类型被拒绝；当icmp-block-inversion为yes时，这些ICMP类型被允许 rich rules： //富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。</div><p><strong>2. 放行端口</strong></p><div class="shell">永久放行10800-10805端口的tcp数据# firewall-cmd --permanent --add-port=10800-10805/tcp重新加载防火墙配置# firewall-cmd --reload</div><p><strong>3. 为网卡绑定区域</strong></p><p>一般情况下，一台主机会有多个网卡，比如一块对公网，一块对内网，因此网卡使用的防火墙策略也不一样，可以单独为某个网卡绑定某个区域。通过firewall-cmd –set-default-zone命令设置的区域会对所有网卡生效，但如果该网卡绑定了单独的区域，则单独绑定区域的优先级更高。</p><div class="shell">将网卡eth0默认区域修改为external# firewall-cmd --permanent --zone=external --change-interface=eth0</div><p><strong>4. 查询服务是否放行</strong></p><p>如：查询SSH和HTTPS协议的流量是否允许放行</p><div class="shell">查询public区域中SSH协议的流量是否被放行# firewall-cmd --zone=public --query-service=ssh查询public区域中https协议的流量是否被放行# firewall-cmd --zone=public --query-service=https</div><p><strong>5. 放行协议流量</strong></p><p>把HTTPS协议的流量设置为永久允许放行</p><div class="shell">在public区域中放行https协议的流量# firewall-cmd --permanent --zone=public --add-service=https重新加载防火墙配置# firewall-cmd --reload</div><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>端口转发命令格式如下，目标IP地址为所要访问服务器的IP地址：<br><span class="strong">firewall-cmd –permanent –zone=区域 –add-forward-port=port=源端口号:proto=协议:toport=目标端口号:toaddr=目标IP地址</span></p><div class="shell">将9000端口转发到22端口，使得用户能通过9000端口使用ssh远程连接服务# firewall-cmd --permanent --zone=public --add-forward-port=port=9000:proto=tcp:toport=22:toaddr=192.168.0.1重新加载防火墙配置# firewall-cmd --reload</div><h4 id="富规则"><a href="#富规则" class="headerlink" title="富规则"></a>富规则</h4><p>富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置，它的优先级在所有的防火墙策略中也是最高的。</p><div class="shell">拒绝192.168.0.1/24网段的所有用户访问本机的ssh服务# # firewall-cmd --permanent --zone=public --add-rich-rule="rule family="ipv4" source address="192.168.0.1/24" service name="ssh" reject"重新加载防火墙配置# firewall-cmd --reload</div><h3 id="IPTables"><a href="#IPTables" class="headerlink" title="IPTables"></a>IPTables</h3><p>早期的RHEL系列的操作系统，默认使用IPTables来配置防火墙。RHEL7之后的系统使用firewalld取代了IPTables防火墙，IPTables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。</p><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>Centos官方IPTables文档：<a target="_blank" href="https://wiki.centos.org/HowTos/Network/IPTables">https://wiki.centos.org/HowTos/Network/IPTables</a></div><h4 id="策略与规则链"><a href="#策略与规则链" class="headerlink" title="策略与规则链"></a>策略与规则链</h4><p>IPTables会根据管理员书写的策略来决定防火墙是否放行数据包通过，基本的策略规则有四种：ACCEPT、REJECT、LOG、DROP。IPTables会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后立即执行规则定义的行为(如：放行或阻止流量)，若在读取完所有的策略规则之后没有匹配项，则会执行默认的策略。</p><p>IPTables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链。<span class="tips">由于防火墙策略规则是按照从上到下的顺序匹配执行的，因此一定要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝，因此规则链最后一条往往为拒绝规则。</span></p><p>当防火墙的默认策略为拒绝时，需要添加相应的规则链来放行允许进入服务器的数据，否则服务器将拒绝所有数据包；而当防火墙的默认策略为允许时，则需要添加相应的拒绝规则链，否则防火墙就失去了它的作用。一般情况下，INPUT流量的默认策略为拒绝，OUTPUT流量默认策略为允许。</p><h4 id="数据包分类与处理方式"><a href="#数据包分类与处理方式" class="headerlink" title="数据包分类与处理方式"></a>数据包分类与处理方式</h4><p>根据数据包的不同处理位置，数据包分为</p><ul><li><span class="strong">在进行路由选择前处理数据包(PREROUTING)</strong></li><li><span class="strong">处理流入的数据包(INPUT)</strong></li><li><span class="strong">处理流出的数据包(OUTPUT)</strong></li><li><span class="strong">处理转发的数据包(FORWARD)</strong></li><li><span class="strong">在进行路由选择后处理数据包(POSTROUTING)</strong></li></ul><h5 id="数据包处理方式"><a href="#数据包处理方式" class="headerlink" title="数据包处理方式"></a>数据包处理方式</h5><div class="table"><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td>ACCEPT</td><td>允许流量通过</td></tr><tr><td>REJECT</td><td>拒绝流量通过并返回流量被丢弃的提示信息</td></tr><tr><td>LOG</td><td>记录日志信息</td></tr><tr><td>DROP</td><td>拒绝流量通过且不返回任何信息</td></tr></tbody></table></div><p>REJECT会在拒绝流量后，告知流量发送方流量已收到，但服务器拒绝响应的信息</p><p>DROP会直接丢弃流量，使流量发送方不清楚流量是被拒绝还是主机不在线，一般能更好保护主机安全。</p><h4 id="命令与参数-1"><a href="#命令与参数-1" class="headerlink" title="命令与参数"></a>命令与参数</h4><p><span class="strong">iptables [参数] [对象]</span></p><div class="table"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-L</td><td>查看当前的规则链，可以使用iptables -L –line-numbers命令显示规则链的序号</td></tr><tr><td>-P</td><td>设置默认策略</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-A</td><td>在规则链末尾加入新规则</td></tr><tr><td>-I [序号]</td><td>在指定序号规则前加入新规则，无序号默认在规则链首加入</td></tr><tr><td>-R 序号</td><td>替换指定规则，无序号默认替换第一条规则</td></tr><tr><td>-D 序号</td><td>删除指定规则</td></tr><tr><td>-s IP/主机名</td><td>匹配来源的IP和主机，加!号表示除该IP外，子网掩码可以使用/MASK的方式表示</td></tr><tr><td>-d</td><td>匹配目标地址，类似于参数-s</td></tr><tr><td>-J</td><td>跳转到下一个处理规则，可能的值有：ACCEPT(允许数据通过), DROP(丢弃), QUEUE(进入队列), RETURN(返回上一个跳转规则)。也可以添加规则名跳转到指定规则</td></tr><tr><td>-i 网卡名</td><td>匹配从该网卡流入的数据</td></tr><tr><td>-o 网卡名</td><td>匹配从该网卡流出的数据</td></tr><tr><td>-p 协议</td><td>匹配协议，如:TCP、UDP等,all代表所有协议(一般不使用)</td></tr><tr><td>-&zwnj;-dport 端口号</td><td>匹配目标端口号</td></tr><tr><td>-&zwnj;-sport 端口号</td><td>匹配来源端口号</td></tr></tbody></table></div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>防火墙命令均需要root权限</div><div class="shell">如：查看当前规则链iptables -L返回结果：Chain INPUT (policy ACCEPT)     //INPUT数据包，默认策略为ACCEPTnum  target     prot opt source               destination         1    ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED2    ACCEPT     all  --  anywhere             anywhere            3    INPUT_direct  all  --  anywhere             anywhere            4    INPUT_ZONES_SOURCE  all  --  anywhere             anywhere            5    INPUT_ZONES  all  --  anywhere             anywhere            6    DROP       all  --  anywhere             anywhere             ctstate INVALID7    REJECT     all  --  anywhere             anywhere             reject-with icmp-host-prohibited</div><div class="show">示例：<strong>1. 修改INPUT规则链默认配置为拒绝，并允许允许ICMP流量进入(允许服务器被ping后返回信息)</strong># iptables -P INPUT DROP# iptables -I INPUT -p icmp -j ACCEPT<strong>2. 拒绝所有人访问本机10800端口</strong># iptables -I INPUT -p tcp --dport 10800 -j REJECT# iptables -I INPUT -p udp --dport 10800 -j REJECT<strong>3. 拒绝192.168.10.5主机访问本机80端口</strong>iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT<strong>4.拒绝所有主机访问本机1000～1024端口</strong># iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT<strong>5.只允许192.168.10.0主机访问本机的22端口，拒绝来自其他所有主机的流量。</strong># iptables -I INPUT -s 192.168.10.0 -p tcp --dport 22 -j ACCEPT# iptables -A INPUT -p tcp --dport 22 -j REJECT</div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>如同第5条命令，由于防火墙策略规则是按照从上到下的顺序匹配的，因此需要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝</div><div class="show">网口转发,如将公网的数据包转发到内网,假设eth0连接内网，eth1连接公网iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</div><h4 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h4><p>通过命令添加的规则链，会在系统重启后失效，因此需要写入配置文件使其永久生效，可以使用命令<span class="tips">service iptables save</span>保存</p><p>ipv4默认保存位置为<span class="tips">/etc/sysconfig/iptables-config</span></p><p>ipv6默认保存位置为<span class="tips">/etc/sysconfig/ip6tables-config</span></p>]]></content>
    
    
    <summary type="html">Redhat系列系统防火墙的配置方法，包括防火墙策略配置语法，IPTable和firewalld服务的常用命令，适用于CentOS、Fedora、RHEL发行版</summary>
    
    
    
    
    <category term="CentOS" scheme="https://shiwei11.github.io/blog/tags/CentOS/"/>
    
    <category term="firewall" scheme="https://shiwei11.github.io/blog/tags/firewall/"/>
    
  </entry>
  
  <entry>
    <title>Bash与shell脚本</title>
    <link href="https://shiwei11.github.io/blog/2022/02/10/Bash%E4%B8%8Eshell/"/>
    <id>https://shiwei11.github.io/blog/2022/02/10/Bash%E4%B8%8Eshell/</id>
    <published>2022-02-10T10:38:49.000Z</published>
    <updated>2022-04-03T16:05:29.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bash命令"><a href="#Bash命令" class="headerlink" title="Bash命令"></a>Bash命令</h3><h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><p><span class="strong">history [选项] [历史命令保存文件]</span></p><ul><li>-c&emsp;清空历史命令</li><li>-w&emsp;把缓存的历史命令写入历史命令保存文件~/.bash_history中</li></ul><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>每个用户都有独立的历史命令保存文件，一般在用户家目录下，该文件默认隐藏，用户执行过的命令会先缓存在内存中，等登出账户后再写入bash_history文件中，历史命令默认保存1000条，用户可在环境变量配置文件/etc/profile中的HISTSIZE选项自行修改</div><h4 id="调用历史命令"><a href="#调用历史命令" class="headerlink" title="调用历史命令"></a>调用历史命令</h4><ul><li><span class="strong">可通过上下箭头调用之前执行的命令</span></li><li><span class="strong">!!</span>再次执行上一次执行的命令</li><li><span class="strong">!n</span>再次执行第n条历史命令(序号以history列出的序号为准)</li><li><span class="strong">!字符串</span>再次执行最后一次以该字符串开头的命令</li></ul><h4 id="自定义命令名"><a href="#自定义命令名" class="headerlink" title="自定义命令名"></a>自定义命令名</h4><p><span class="strong">alias</span>查看所有自定义的命令</p><p><span class="strong">alias 别名=’原命令’</span>自定义命令名，原命令依旧可用</p><p>使用命令定义的命令名只能临时生效，系统重启后将丢失，要永久生效需将自定义的命令添加到文件<span class="tips">/用户名/.bashrc</span>中</p><p>删除自定义的命令:</p><p><span class="strong">unalias 别名</span></p><h4 id="命令的执行优先级"><a href="#命令的执行优先级" class="headerlink" title="命令的执行优先级"></a>命令的执行优先级</h4><ul><li>第一顺位执行通过绝对路径或相对路径执行的命令</li><li>第二顺位执行自定义的命令别名</li><li>第三顺位执行bash内部命令</li><li>第四顺位执行$PATH环境变量定义的第一个命令</li></ul><h4 id="bash常用快捷键"><a href="#bash常用快捷键" class="headerlink" title="bash常用快捷键"></a>bash常用快捷键</h4><div class="table"><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>ctrl+c</td><td>强制终止当前目录</td></tr><tr><td>ctrl+l</td><td>清屏，同clear命令</td></tr><tr><td>ctrl+u</td><td>剪切光标之前的命令</td></tr><tr><td>ctrl+k</td><td>剪切光标之后的内容</td></tr><tr><td>ctrl+y</td><td>粘贴剪切的内容</td></tr><tr><td>ctrl+r</td><td>搜索执行过的历史命令</td></tr><tr><td>ctrl+d</td><td>退出当前终端</td></tr><tr><td>ctrl+z</td><td>暂停工作并放入后台</td></tr><tr><td>ctrl+a</td><td>将光标移动到命令行开头</td></tr></tbody></table></div><p>相关命令</p><ul><li><span class="strong">stty -a</span>&emsp;查看所有快捷键</li><li><span class="strong">stty 关键字 快捷键</span>&emsp;更改快捷键</li></ul><h3 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h3><h4 id="shell的不同家族"><a href="#shell的不同家族" class="headerlink" title="shell的不同家族"></a>shell的不同家族</h4><p>Bourne Shell：包括sh、ksh、Bash、psh、zsh，Linux默认使用Bash</p><p>C Shell：包括csh、tcsh，语法与C语言类似，主要用于BSD版Unix系统</p><h4 id="Linux支持的shell"><a href="#Linux支持的shell" class="headerlink" title="Linux支持的shell"></a>Linux支持的shell</h4><p>查看<span class="tips">/etc/shells</span>文件可获取当前Linux支持的shell列表，Linux默认使用Bash作为命令解释器，直接输入其他shell名可进行切换，通过<span class="tips"><strong>exit</strong></span>命令返回默认的Bash终端</p><h4 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h4><h5 id="通过路径直接运行脚本"><a href="#通过路径直接运行脚本" class="headerlink" title="通过路径直接运行脚本"></a>通过路径直接运行脚本</h5><p>赋予脚本执行权限，然后运行,如对于名为HelloWorld.sh脚本，执行方式为:<br><span class="strong">chmod 755 HelloWorld.sh</span></p><p> <span class="strong">./HelloWorld.sh</span></p><h5 id="通过bash调用"><a href="#通过bash调用" class="headerlink" title="通过bash调用"></a>通过bash调用</h5><p>bash HelloWorld.sh</p><h4 id="脚本格式转换"><a href="#脚本格式转换" class="headerlink" title="脚本格式转换"></a>脚本格式转换</h4><p>在Linux中，回车符识别为<span class="tips"><strong><code>$</code></strong></span>，而在windows中回车符为^M$，因此在windows中编写的sh脚本需要经过转换，才能在Linux中运行，转换命令为：<br><span class="strong">dos2unix 文件名</span><br>相反，将文件从Linux格式转为Windows格式为<br><span class="strong">unix2dos 文件名</span></p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>该功能需要自行安装，yum -y install dos2unix</div><h3 id="shell基础语法"><a href="#shell基础语法" class="headerlink" title="shell基础语法"></a>shell基础语法</h3><h4 id="脚本声明"><a href="#脚本声明" class="headerlink" title="脚本声明"></a>脚本声明</h4><div class="show">#!bin/bash  //申明shell脚本</div><h4 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h4><p><span class="strong">echo [选项] [输出内容]</span></p><ul><li>-e&emsp;支持使用\进行字符转换</li></ul><h4 id="修改字体颜色"><a href="#修改字体颜色" class="headerlink" title="修改字体颜色"></a>修改字体颜色</h4><p>通过转义序列，可以修改终端的字体、背景的颜色和显示效果。转义序列语法为：</p><p><span class="strong">[代码m</span></p><p>转义序列语法前需要使用<span class="tips">\e或\033 或\x1B</span>来引导非常规字符序列</p><div class="show">如：输出红色字符串 "RedColor"# echo -e "\e[31mRedColor \e[0m"末尾的\e[0m用于删除所有设置的属性(包括颜色、加粗、闪烁等效果)使后续输出内容恢复默认属性</div><h5 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h5><div class="table"><table><thead><tr><th>设置效果代码</th><th>效果</th><th>取消效果代码</th></tr></thead><tbody><tr><td>1</td><td>加粗高亮</td><td>21</td></tr><tr><td>2</td><td>变暗</td><td>22</td></tr><tr><td>4</td><td>下划线</td><td>24</td></tr><tr><td>5</td><td>闪烁</td><td>25</td></tr><tr><td>7</td><td>反转背景色和前景色</td><td>27</td></tr><tr><td>8</td><td>隐藏(常用于密码)</td><td>28</td></tr></tbody></table></div><h5 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h5><div class="table"><table><thead><tr><th>代码</th><th>颜色</th><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>39</td><td>默认颜色</td><td></td><td></td></tr><tr><td>30</td><td>黑色</td><td>90</td><td>深灰</td></tr><tr><td>31</td><td>红色</td><td>91</td><td>红色</td></tr><tr><td>32</td><td>绿色</td><td>92</td><td>浅绿色</td></tr><tr><td>33</td><td>黄色</td><td>93</td><td>淡黄色</td></tr><tr><td>34</td><td>蓝色</td><td>94</td><td>浅蓝</td></tr><tr><td>35</td><td>品红</td><td>95</td><td>浅洋红色</td></tr><tr><td>36</td><td>青色</td><td>96</td><td>浅青色</td></tr><tr><td>37</td><td>浅灰</td><td>97</td><td>白色</td></tr></tbody></table></div><h5 id="字体背景色"><a href="#字体背景色" class="headerlink" title="字体背景色"></a>字体背景色</h5><div class="table"><table><thead><tr><th>代码</th><th>颜色</th><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>49</td><td>默认颜色</td><td></td><td></td></tr><tr><td>40</td><td>黑色</td><td>100</td><td>深灰</td></tr><tr><td>41</td><td>红色</td><td>101</td><td>红色</td></tr><tr><td>42</td><td>绿色</td><td>102</td><td>浅绿色</td></tr><tr><td>43</td><td>黄色</td><td>103</td><td>淡黄色</td></tr><tr><td>44</td><td>蓝色</td><td>104</td><td>浅蓝</td></tr><tr><td>45</td><td>品红</td><td>105</td><td>浅洋红色</td></tr><tr><td>46</td><td>青色</td><td>106</td><td>浅青色</td></tr><tr><td>47</td><td>浅灰</td><td>107</td><td>白色</td></tr></tbody></table></div><h5 id="修改文件目录颜色"><a href="#修改文件目录颜色" class="headerlink" title="修改文件目录颜色"></a>修改文件目录颜色</h5><p>想在使用ls命令后使各种不同类型文件显示不同颜色，可以修改<span class="tips">/etc/DIR_COLORS</span>文件中的颜色配置，修改完成后使用<span class="tips">eval `dircolors /etc/DIR_COLORS`</span>命令使之生效</p><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><h5 id="1-标准输入输出设备"><a href="#1-标准输入输出设备" class="headerlink" title="1. 标准输入输出设备"></a>1. 标准输入输出设备</h5><div class="table"><table><thead><tr><th>设备</th><th>Linux文件名</th><th>文件描述符</th><th>类型</th></tr></thead><tbody><tr><td>键盘</td><td>/dev/stdin</td><td>0</td><td>标准输入</td></tr><tr><td>显示器</td><td>/dev/stdout</td><td>1</td><td>标准输出</td></tr><tr><td>显示器</td><td>/dev/stderr</td><td>2</td><td>标准错误输出</td></tr></tbody></table></div><h5 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2. 输出重定向"></a>2. 输出重定向</h5><div class="table"><table><thead><tr><th>类型</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td rowspan="2">标准输出重定向</td><td>&gt;</td><td>以覆盖方式将正确命令返回内容输出到指定文件或设备中</td></tr><tr><td>&gt;&gt;</td><td>以追加方式将正确命令返回内容输出到指定文件或设备中</td></tr><tr><td rowspan="2">标准错误输出重定向</td><td>2&gt;</td><td>以覆盖方式将错误命令返回内容输出到指定文件或设</td></tr><tr><td>2&gt;&gt;</td><td>以追加方式将错误命令返回内容输出到指定文件或设备中</td></tr>      <tr>      <td rowspan="5">同时输出正确和错误命令返回信息</td>      <td>命令&&gt;文件</td>      <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&&gt;&gt;文件</td>         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&&gt;文件 2&gt;&1</td>         <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&&gt;&gt;文件 2&gt;&1</td>         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>      </tr>      <tr>         <td>命令&gt;&gt;文件1 2&gt;&gt;文件2</td>         <td>把正确命令返回信息追加到文件1中，错误命令返回信息追加到文件2中</td>      </tr>   </tbody></table></div><h5 id="3-输入重定向-不常用"><a href="#3-输入重定向-不常用" class="headerlink" title="3. 输入重定向(不常用)"></a>3. 输入重定向(不常用)</h5><p><span class="strong">wc [选项] [文件名]</span></p><ul><li>-c &emsp;统计字节数</li><li>-w &emsp;统计单词数</li><li>-l &emsp;统计行数</li></ul><div class="show"># wc < test计算test文件字符数等</div><h5 id="4-多命令执行"><a href="#4-多命令执行" class="headerlink" title="4. 多命令执行"></a>4. 多命令执行</h5><div class="table"><table><thead><tr><th>多命令执行</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td>;</td><td>命令1;命令2</td><td>顺序执行，若前一命令执行错误，则跳过继续执行</td></tr><tr><td>&amp;&amp;</td><td>命令1&amp;&amp;命令2</td><td>当命令1正确执行，才继续执行命令2</td></tr><tr><td>||</td><td>命令1||命令2</td><td>当命令1正确执行，停止执行命令2，命令1错误才继续执行命令2</td></tr></tbody></table></div><div class="show"># 命令 && echo true || echo false   类似于三目运算符，执行命令，执行正确输出true，执行错误输出false</div><h5 id="5-管道符"><a href="#5-管道符" class="headerlink" title="5. 管道符"></a>5. 管道符</h5><p><span class="strong">命令1 | 命令2</span>将命令1的输出作为命令2的输入</p><h4 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h4><div class="table"><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>‘’</td><td>单引号中的所有特殊字符仅作为普通字符，无特殊含义，</td></tr><tr><td>“”</td><td>双引号中的所有特殊字符，除了$、`、\外，其他仅作为普通字符。命令行中的字符串之间有空格时，需要通过引号包裹</td></tr><tr><td>``</td><td>反引号，引入系统命令</td></tr><tr><td>$()</td><td>同``，引入系统命令</td></tr><tr><td>#</td><td>注释</td></tr><tr><td>$</td><td>调用变量值</td></tr><tr><td>\</td><td>转义符，输出$等字符可使用$使其无特殊含义</td></tr></tbody></table></div><h5 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h5><div class="table"><table><thead><tr><th>字符转换</th><th>作用</th></tr></thead><tbody><tr><td>\\</td><td>输出\</td></tr><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>退格，删除一个字符</td></tr><tr><td>\c</td><td>取消行末的换行符,同-n选项</td></tr><tr><td>\e</td><td>ESC键</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车键</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\0nnn</td><td>按照八进制ASCII码表输出字符，如:\x106</td></tr><tr><td>\xhh</td><td>按照十六进制ASCII码表输出字符，如:\xff</td></tr></tbody></table></div><h4 id="根据关键字搜索grep"><a href="#根据关键字搜索grep" class="headerlink" title="根据关键字搜索grep"></a>根据关键字搜索grep</h4><p><span class="strong">grep [选项] 搜索内容</span></p><ul><li>-i&emsp;忽略大小写</li><li>-n&emsp;输出行号</li><li>-v&emsp;反向查找</li><li>-&zwnj;-color=auto;&emsp;搜索到的关键字用颜色高亮显示(默认)</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li>自定义变量</li><li>环境变量：保存和操作系统环境相关的数据</li><li>位置参数变量：用于向脚本中传递参数和数据，变量名不能自定义</li><li>预定义变量：bash预定义的变量</li></ul><h5 id="查看所有变量"><a href="#查看所有变量" class="headerlink" title="查看所有变量"></a>查看所有变量</h5><p><span class="strong">set</span>&emsp;查看所有变量(包括系统自定义的变量)</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul><li>变量名规则同C语言，允许由字母、数字、下划线组成，但不能以数字开头</li><li>bash中变量默认类型都为字符串类型</li><li>变量赋值时，若值包含空格，则需要使用单引号或双引号包裹</li><li>变量值中可以使用\进行转义</li><li>环境变量名一般使用大写</li></ul><p><span class="tips">自定义变量不需要int、var等关键字，直接写<strong> 变量名=值</strong> 即可</span>，如：name=”South West”</p><h5 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h5><ul><li><span class="strong">unset 变量名</span>&emsp;删除变量</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul><li><span class="strong">export 变量名=值</span>&emsp;定义环境变量</li><li><span class="strong">env</span>&emsp;查询环境变量</li><li><span class="strong">unset 变量名</span>&emsp;删除变量</li></ul><p>用户自定义的变量只在当前shell终端中有效，如果需要该变量在所有shell中生效，则需要把该变量写入环境变量的配置文件中</p><h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><div class="table">   <table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>$n</td><td>n为数字，$0代表命令本身，$1-$9代表命令第1-9个参数，10以上用{}包裹，如:${10}</td></tr><tr><td>$*</td><td>代表命令行所有参数，$*将命令行所有参数作为一个整体进行处理，在遍历时循环只执行一次</td></tr><tr><td>$@</td><td>代表命令行所有参数，$@将区分每一个参数</td></tr><tr><td>$#</td><td>代表命令行所有参数个数</td></tr></tbody></table></div><div class="show">定义一个test.sh脚本#! /bin/bashnum1=$1num2=$2sum=$(($num1+$num2))echo "sum is: $sum"执行该脚本并传参chmod 755 test.sh./test.sh 10 20输出参数和 30</div><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><div class="table">   <table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>$?</td><td>返回上一个命令的执行状态，如果返回0则说明执行正确，返回值非0则说明上一个命令执行不正确</td></tr><tr><td>$$</td><td>当前进程的进程号(PID)</td></tr><tr><td>$!</td><td>后台运行最后一个进程的进程号(PID)</td></tr></tbody></table></div><h4 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h4><p><span class="strong">read [选项] [变量名]</span></p><ul><li>-p “提示信息” &emsp;输出提示信息</li><li>-t 秒数 &emsp;read命令只等待指定时间</li><li>-n 字符数&emsp;read命令只接收指定数量字符</li><li>-s &emsp;隐藏输入的内容</li></ul><div class="shell">示例：#!/bin/bashread -t 30 -p "input name:" name    //30s内输入姓名并赋值给nameread -s -t 30 -p "input password:" passwd  //30s内隐藏输入密码并赋值给passwdecho "Name is $name"                //输出姓名echo -e "\n"                        //输出换行符</div><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><h4 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h4><p><span class="strong">declare [+或-] [选项] 变量名</span></p><ul><li>-&emsp;给变量设置类型属性</li><li>+&emsp;取消变量的类型属性</li><li>-i&emsp;将变量声明为整形(integer)</li><li>-x&emsp;将变量声明为环境变量</li><li>-p&emsp;查看变量的类型</li></ul><h4 id="数值运算-1"><a href="#数值运算-1" class="headerlink" title="数值运算"></a>数值运算</h4><h5 id="1-通过”-”或”-”运算式"><a href="#1-通过”-”或”-”运算式" class="headerlink" title="1.通过”$(())”或”$[]”运算式"></a>1.通过”$(())”或”$[]”运算式</h5><ul><li><span class="strong">变量名=$((运算式))</span></li><li><span class="strong">变量名=$[运算式]</span></li></ul><div class="shell">示例：[root@localhost ~]# num1=$((11+22))[root@localhost ~]# num2=$[11+22]</div><h5 id="2-通过declare-i声明"><a href="#2-通过declare-i声明" class="headerlink" title="2.通过declare -i声明"></a>2.通过declare -i声明</h5><p><span class="strong">declare -i 变量名</span></p><div class="shell">示例：[root@localhost ~]# declare -i num1=11+22</div><h5 id="3-通过expr或let转换为数值"><a href="#3-通过expr或let转换为数值" class="headerlink" title="3.通过expr或let转换为数值"></a>3.通过expr或let转换为数值</h5><p><span class="strong">变量名=$(expr $变量1 + $变量2)</span></p><div class="shell">示例:[root@localhost ~]# a=11[root@localhost ~]# b=22[root@localhost ~]# num1=$a+$b[root@localhost ~]# echo $num1  //输出11+22[root@localhost ~]# num2=$(expr $a + $b)  //严格遵守expr后空格，+号两边空格[root@localhost ~]# echo $num2  //输出33</div><h4 id="变量测试与内容替换"><a href="#变量测试与内容替换" class="headerlink" title="变量测试与内容替换"></a>变量测试与内容替换</h4><div class="table"><table><thead><tr><th>语句</th><th>未定义变量y</th><th>变量y为空</th><th>变量y有值</th></tr></thead><tbody><tr><td>x=${y-新值}</td><td>x=新值</td><td>x为空</td><td>x=$y</td></tr><tr><td>x=${y:-新值}</td><td>x=新值</td><td>x=新值</td><td>x=$y</td></tr><tr><td>x=${y+新值}</td><td>x为空</td><td>x=新值</td><td>x=新值</td></tr><tr><td>x=${y:+新值}</td><td>x为空</td><td>x为空</td><td>x=新值</td></tr><tr><td>x=${y=新值}</td><td>x=y=新值</td><td>x为空，y值不变</td><td>x=$y,y值不变</td></tr><tr><td>x=${y:=新值}</td><td>x=y=新值</td><td>x=y=新值</td><td>x=$y,y值不变</td></tr><tr><td>x=${y?新值}</td><td>新值输出到标准错误输出</td><td>x为空</td><td>x=$y</td></tr><tr><td>x=${y:?新值}</td><td>新值输出到标准错误输出</td><td>新值输出到标准错误输出</td><td>x=$y</td></tr></tbody></table></div><div class="shell">示例：[root@localhost ~]# x=${y-new}    //new值可任意[root@localhost ~]# echo $x      //未定义y，x值也为new[root@localhost ~]# y=""         //定义y，赋为空[root@localhost ~]# x=${y-new}   //此时x为空</div><h3 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h4><h5 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h5><p>对所有用户生效</p><ul><li><strong>/etc/profile</strong>&emsp;主要的配置文件，也是用户登录时最先读取的文件</li><li><strong>/etc/profile.d/.sh后缀文件</strong>&emsp;由profile调用</li><li><strong>/etc/bashrc</strong>&emsp;定义PS1等bash终端的环境</li></ul><h5 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h5><p>只对单一用户生效，每个用户都有自己的配置文件，root用户位于/root下，普通用户位于/home/用户名下，默认隐藏，需要使用ls -a命令才能看见文件</p><ul><li>~/.bash_profile &emsp; 用户个人的/etc/profile文件 </li><li>~/.bashrc &emsp;写有用户自定义的命令别名等</li><li>~/.bash_logout &emsp;用户注销时执行的环境变量配置文件，可以写一些我们希望系统关机时执行的操作，如备份日志等</li><li>~/.bash_history &emsp;记录用户执行过的命令</li></ul><h5 id="不重启就使配置文件生效"><a href="#不重启就使配置文件生效" class="headerlink" title="不重启就使配置文件生效"></a>不重启就使配置文件生效</h5><p>直接执行任一命令</p><ul><li><span class="strong">source 文件名</span></li><li><span class="strong">.配置文件名</span></li></ul><h4 id="etc-profile配置文件"><a href="#etc-profile配置文件" class="headerlink" title="/etc/profile配置文件"></a>/etc/profile配置文件</h4><p>配置文件中变量的主要作用</p><div class="table"><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>USER</td><td>当前用户</td></tr><tr><td>LOGNAME</td><td>当前用户名，配置文件中LOGNAME=$USER，因此同USER</td></tr><tr><td>MAIL</td><td>用户邮箱</td></tr><tr><td>HOSTNAME</td><td>主机名</td></tr><tr><td>HISTSIZE</td><td>历史命令保存条数</td></tr><tr><td>umask</td><td>设置文件默认权限</td></tr></tbody></table></div><h4 id="全局执行脚本方式"><a href="#全局执行脚本方式" class="headerlink" title="全局执行脚本方式"></a>全局执行脚本方式</h4><p>执行脚本一般需要在赋予脚本执行权限后，使用绝对路径调用，或者进入脚本所在目录，使用相对路径调用。全局使用的脚本和命令，Linux是根据PATH寻找相应路径自动执行实现的，可通过<span class="strong">echo $PATH</span>查看当前配置的全局路径，手动安装的服务想实现全局执行脚本，有两种实现方法：</p><ul><li><span class="strong">将脚本cp复制到PATH中的某个路径下，如:/usr/bin下</span></li><li><span class="strong">通过变量叠加的方式，将脚本路径添加到PATH变量中，格式为PATH=”$PATH”:路径</span></li></ul><p>通过变量叠加的方式添加的全局变量，在系统重启后将失效，永久生效方法是将路径添加到<span class="tips">/etc/profile</span>文件的PATH变量后</p><div class="show">如Nginx的启动脚本在/usr/local/nginx/sbin路径下，非全局启动方法为：1.相对路径： 在 /usr/local/nginx/sbin 路径下执行./nginx 2. 绝对路径：执行 /usr/local/nginx/sbin/nginx添加到全局的方法为：执行PATH="$PATH":/usr/local/nginx/sbin使调用命令永久生效的方法：在 /etc/profile 中最后一行添加PATH=$PATH:/usr/local/nginx/sbin</div><h4 id="修改命令提示符"><a href="#修改命令提示符" class="headerlink" title="修改命令提示符"></a>修改命令提示符</h4><p>默认情况下的命令提示符为<span class="tips">[用户名@主机名 当前目录]提示符</span>，如：[root@localhost ~]#，该默认值由系统定义的变量<span class="tips">PS1</span>决定，可通过<span class="strong">echo $PS1</span>&emsp;查看当前配置，也可以通过修改PS1变量自定义命令提示符，如：</p><div class="show">PS1='[\u@\t \w]#'命令提示符将修改为：[root@15:21:13 /home/user1]#</div>但通过修改变量自定义的命令提示符，只在本次登录有效，系统重启后将失效，需要永久修改命令提示符，可以将上述语句写入配置文件<span class="tips">/etc/bashrc</span>中，自定义命令提示符常用的转义符有：<div class="table"><table><thead><tr><th>转义符</th><th>作用</th></tr></thead><tbody><tr><td>\d</td><td>显示当前系统日期，格式为”星期 月 日”</td></tr><tr><td>\h</td><td>显示简写主机名</td></tr><tr><td>\t</td><td>显示24小时制时间，格式为”HH:MM:SS”</td></tr><tr><td>\T</td><td>显示12小时制时间，格式为”HH:MM:SS”</td></tr><tr><td>\A</td><td>显示24小时制时间，格式为”HH:MM”</td></tr><tr><td>\u</td><td>显示当前用户名</td></tr><tr><td>\w</td><td>显示当前所在目录完整名称</td></tr><tr><td>\W</td><td>显示所在目录最后一个目录</td></tr><tr><td>\#</td><td>显示执行的第几个命令</td></tr><tr><td>$</td><td>提示符，root用户提示符为”#”，普通用户为”$”</td></tr></tbody></table></div><h5 id="修改bash终端颜色"><a href="#修改bash终端颜色" class="headerlink" title="修改bash终端颜色"></a>修改bash终端颜色</h5><p>永久修改Bash终端的默认配色，可以修改<span class="tips">/etc/bashrc</span>配置文件中的PS1变量，若只想修改某个用户的终端，可以修改该用户家目录下的<span class="tips">.bashrc</span>配置文件中的PS1变量。</p><p>配置文件中修改颜色的语句需要用”[]”包裹，并且”[]”前需要使用转义符，并使用\e获取颜色设置字符，即语法为：</p><p><span class="strong">\[\e[颜色码m\]</span></p><p>修改完使用<span class="tips">source 文件名</span>使之生效</p><div class="shell">如在/etc/bashrc文件最后一行添加语句：PS1='\[\e[0m\][\[\e[36m\]\u\[\e[34m\]@\h \[\e[36m\]\W\[\e[0m\]]\[\e[95m\]#\[\e[0m\]'终端提示符将变为：[<span style="color:#0cf8fc;">root</span><span style="color:#0c8afc;">@myLinux</span> <span style="color:#0cf8fc;">etc</span>]<span style="color:#fc0ce6;">#</span></div><h4 id="本地终端登录欢迎信息"><a href="#本地终端登录欢迎信息" class="headerlink" title="本地终端登录欢迎信息"></a>本地终端登录欢迎信息</h4><p>需要修改本地终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue</span>，配置文件中可使用的转义字符：</p><div class="table"><table><thead><tr><th>转义符</th><th>作用</th></tr></thead><tbody><tr><td>\d</td><td>显示当前系统日期</td></tr><tr><td>\t</td><td>显示当前系统时间</td></tr><tr><td>\s</td><td>显示操作系统名称</td></tr><tr><td>\l</td><td>显示登录的终端号</td></tr><tr><td>\m</td><td>显示硬件架构信息，如i386等</td></tr><tr><td>\n</td><td>显示主机名</td></tr><tr><td>\o</td><td>显示域名</td></tr><tr><td>\r</td><td>显示内核版本</td></tr><tr><td>\u</td><td>显示当前用户登录的序列号</td></tr></tbody></table></div><div class="show">最小化安装的Centos7默认配置为：\SKernel \r on an \m</div><h4 id="远程终端登录欢迎信息"><a href="#远程终端登录欢迎信息" class="headerlink" title="远程终端登录欢迎信息"></a>远程终端登录欢迎信息</h4><p>修改远程终端登录时显示的信息，可修改配置文件<span class="tips">/etc/issue.net</span>，该文件不支持上述本地终端登录可用的转义字符，需要显示此欢迎信息，需要在配置文件<span class="tips">/etc/ssh/sshd_config</span>中加入<span class="tips">Banner /etc/issue.net</span>配置内容(需要重启生效)</p><div class="shell">/etc/ssh/sshd_config文件添加配置位置:#UseLogin no#UsePrivilegeSeparation sandbox#PermitUserEnvironment no#Compression delayed#ClientAliveInterval 0#ClientAliveCountMax 3#ShowPatchLevel no#UseDNS yes#PidFile /var/run/sshd.pid#MaxStartups 10:30:100#PermitTunnel no#ChrootDirectory none#VersionAddendum none<p># no default banner path<br>#Banner none<br><span style="color:rgb(232, 250, 0)">Banner</span><span style="color:rgb(250, 0, 136);"> /etc/issue.net</span></p><p># Accept locale-related environment variables</div></p><h4 id="配置终端登录成功后的提示信息"><a href="#配置终端登录成功后的提示信息" class="headerlink" title="配置终端登录成功后的提示信息"></a>配置终端登录成功后的提示信息</h4><p>配置文件位于<span class="tips">/etc/motd</span>，用于在远程和本地终端登录成功后显示提示信息，文件默认为空</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="cut字段提取"><a href="#cut字段提取" class="headerlink" title="cut字段提取"></a>cut字段提取</h4><p><span class="strong">cut [选项] 文件名</span></p><ul><li>-f 列号 &emsp;提取第几列</li><li>-d 分隔符&emsp;按照分隔符识别目标内容中的列(可以识别制表符和其他特殊符号，但不能识别空格)</li></ul><p>从文本或命令输出中提取列内容，grep为提取行内容，因此二者搭配可根据行列精确提取对应内容。cut无法识别以空格为分隔符的内容。</p><div class="shell">如 /etc/passwd 文件中保存了Linux用户信息user1:x:1001:1001::/home/user1:/bin/bashuser2:x:1002:1002::/home/user2:/bin/bashuser3:x:1003:1003::/home/user3:/bin/bash从中提取普通用户的用户名与UIDcat /etc/passwd | grep /bin/bash | grep -v root | cut -d ":" -f 1,31. 普通用户默认使用/bin/bash，通过grep /bin/bash识别2. 通过grep -v root去除root用户,3. 文件使用:为分隔符，使用-d 识别分隔符4. 截取1，3列即用户名和UID</div><h4 id="printf格式化输出"><a href="#printf格式化输出" class="headerlink" title="printf格式化输出"></a>printf格式化输出</h4><p><span class="strong">printf ‘输出类型输出格式’ 输出内容</span></p><p>输出类型</p><ul><li>%ns:&emsp;输出字符串，n指定输出个数</li><li>%ni:&emsp;输出整数，n指定输出个数</li><li>%m.nf:&emsp;输出浮点数，m为总位数，n为小数位数</li></ul><p>输出格式</p><div class="table"><table><thead><tr><th>字符</th><th>作用</th></tr></thead><tbody><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>输出退格键</td></tr><tr><td>\f</td><td>清除屏幕</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平输出制表符</td></tr><tr><td>\v</td><td>垂直输出制表符</td></tr></tbody></table></div><div class="show">示例：# printf '%s\t %s\t %s\t' 6 6 6  //格式输出6 6 6# printf '%s' $(cat test.txt)   //无任何格式输出test.txt文件内容</div><h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p><span class="strong">awk ‘条件1{操作1}&emsp;条件2{操作2} …..’ [文件名]</span></p><p>提取列内容，满足条件1，执行操作1，以此类推。C语言中的大部分数学表达式都可作为条件<br>awk支持printf和print命令，其中print命令会在每行自动添加换行符后再输出，printf需要手动输入\n。</p><div class="show">示例：df -h 命令可以查看当前磁盘使用情况Filesystem      Size  Used Avail Use% Mounted ondevtmpfs        229M     0  229M   0% /devtmpfs           241M     0  241M   0% /dev/shmtmpfs           241M   29M  212M  12% /runtmpfs           241M     0  241M   0% /sys/fs/cgroup/dev/vda1       9.4G  2.6G  6.3G  30% /需求：检测根目录 / 文件占用百分比df -h | grep /dev/vda1 | awk '{print $5}'    //$5代表第5列内容</div><div class="show">示例：文件test.txt中有内容name ID     Gradestu1 1001    65stu2 1002    60stu3 1003    55找出Grade小于60并列出姓名cat test.txt | grep -v name |awk '$3<60 {print $1 "\n"}'1. grep -v name去除第一行内容2. awk '$3<60 {print $1 "\n"}'找出列3小于60的值并返回列1</div><h5 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h5><p>BEGIN作为awk的一种条件，用于在最开始执行操作，如在读取数据之前执行某操作</p><div class="show">示例：awk 'BEGIN{print "first printf"} {print $4 "\t" $5}' test.txt在读取test.txt文件前先输出 first printf ，再输出该文件第4和第5列</div><h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>类似于BEGIN，在最后执行操作</p><div class="show">示例：awk 'BEGIN{print "first printf"}END{print "END!"} {print $4 "\t" $5}' test.txt在读取test.txt文件前先输出 first printf ，再输出该文件第4和第5列,最后输出END!</div><h5 id="常用的内置变量"><a href="#常用的内置变量" class="headerlink" title="常用的内置变量"></a>常用的内置变量</h5><p>awk有自己内置的特殊变量集合，常用变量有：</p><div class="table"><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>当前输入文件名</td></tr><tr><td>$数值</td><td>$0为当前整行，$1表示第1个字段，$2表示第2个字段，以此类推</td></tr><tr><td>NR</td><td>当前输入行号，多文件记录递增</td></tr><tr><td>FNR</td><td>与NR类似，多文件记录不递增，每个文件都从1开始</td></tr><tr><td>NF</td><td>当前输入行的字段编号</td></tr><tr><td>FS</td><td>输入字段分隔符</td></tr><tr><td>OFS</td><td>输出字段分隔符，默认为空格</td></tr><tr><td>RS</td><td>输入记录分隔符</td></tr><tr><td>ORS</td><td>输出记录分隔符，默认为换行符</td></tr></tbody></table></div><div class="shell">例：同cut语句的例子，提取所有非root用户用户名和UID可用#cat /etc/passwd | grep "/bin/bash" | awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}' 使用内置变量FS指定输入字段的分隔符，使用BEGIN在读取文件前进行分隔符设置</div><div class="shell">例：如一个通信记录文件liudehua:13212345678:ldh@mail.comwuyanzu:13112345678:wyz@mail.com可以将每一行看作是一个记录，一个记录包含三个字段，由此awk 'BEGIN{FS=":";RS="\n";OFS="\t";ORS="**\n"}{print $1,$2,$3}' awktest.txt 将换行符识别为记录分隔符，并用**\n代替；将：识别为字段分隔符，并用制表符代替。字段必须写为$1,$2,$3格式，否则OFS将不生效ldh   13212345678   ldh@mail.com**wyz    13112345678   wyz@mail.com**    </div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>自定义分隔符必须要写条件BEGIN，使之在读取数据前生效</div><h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p><span class="strong">sed [选项] ‘[操作]’ [文件名]</span><br>进行数据的选取、替换、删除、新增</p><p><strong>常用选项</strong></p><ul><li>-n&emsp;只显示sed处理的行到屏幕上，默认情况下sed会显示所有数据</li><li>-e&emsp;允许使用多条Sed命令处理输入数据</li><li>-i&emsp;sed处理结果应用到文件，不再输出到屏幕</li></ul><p><strong>常用操作</strong></p><ul><li>a&emsp;追加，在当前行之后添加一行或多行，添加多行内容时，在输入一行内容后添加\，并在下一行添加第2行内容，以此类推</li><li>c&emsp;替换，使用c之后的内容替换原数据行，替换多行同上</li><li>i&emsp;插入，在当前行之前插入一行或多行，插入多行同上</li><li>d&emsp;删除指定行</li><li>p&emsp;输出指定行到屏幕</li><li>s&emsp;字符串替换，格式为”行号s/旧字符/新字符/g”</li></ul><div class="show">示例：文件test.txt中有内容name ID     Gradestu1 1001    65stu2 1002    60stu3 1003    55命令sed -n '2p' test.txt显示第2行内容到屏幕，-n只显示sed处理的行，'2'指定行号，'p'输出指定行到屏幕sed '3i stu5 1005 58 \> stu6 1006 66' test.txt在第3行之前插入两行内容，新的test.txt内容为name ID     Gradestu1 1001    65stu5 1005    58stu6 1006    66stu2 1002    60stu3 1003    55以上命令只修改输出到屏幕的内容，修改文件内容需添加-i参数，如：sed -i '3s/58/66/g' test.txt替换第3行内容中的58为66，并将修改应用到文件不添加行号会修改文件中所有匹配到的内容，修改内容可为空，如：sed -i 's/58//g' test.txt</div><h4 id="sort排序处理"><a href="#sort排序处理" class="headerlink" title="sort排序处理"></a>sort排序处理</h4><p><span class="strong">sort [选项] [文件名]</span></p><p>将文件或命令结果进行排序，默认以每行第一个字母为依据，按字母顺序排序</p><ul><li>-f&emsp;忽略大小写</li><li>-n&emsp;按数值大小进行排序</li><li>-r&emsp;反向排序</li><li>-t&emsp;指定分隔符为分段依据</li><li>-k n[,m]&emsp;指定字段为排序依据，不指定m则判断依据为以n字段开始到本行末</li></ul><div class="show">示例：sort /etc/passwd按passwd文件每行首字母进行排序显示sort -n -t ":" -k 3,3 etc/passwd指定字段以:分隔，按第3字段(UID)值大小进行排序显示</div><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="检测文件类型"><a href="#检测文件类型" class="headerlink" title="检测文件类型"></a>检测文件类型</h4><ul><li><span class="strong">test 选项 文件名</span></li><li><span class="strong">[选项 文件名 ]</span><br>返回值在终端上需要用$?查看</li></ul><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-e</td><td>判断文件是否存在</td></tr><tr><td>-d</td><td>判断文件是否存在，且是否为目录文件</td></tr><tr><td>-f</td><td>判断文件是否存在，且是否为为普通文件</td></tr><tr><td>-b</td><td>判断文件是否存在，且是否为块设备文件(如：硬盘设备文件)</td></tr><tr><td>-c</td><td>判断文件是否存在，且是否为字符设备文件(如：鼠标、键盘设备文件)</td></tr><tr><td>-L</td><td>判断文件是否存在，且是否为链接文件</td></tr><tr><td>-p</td><td>判断文件是否存在，且是否为管道文件</td></tr><tr><td>-s</td><td>判断文件是否存在，且是否非空，非空为true</td></tr><tr><td>-S</td><td>判断是否为套接字文件</td></tr></tbody></table></div><h4 id="检测文件权限"><a href="#检测文件权限" class="headerlink" title="检测文件权限"></a>检测文件权限</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-r</td><td>判断文件是否存在，且是否拥有读权限</td></tr><tr><td>-w</td><td>判断文件是否存在，且是否拥有写权限</td></tr><tr><td>-x</td><td>判断文件是否存在，且是否拥有执行权限</td></tr><tr><td>-u</td><td>判断文件是否存在，且是否拥有SUID权限</td></tr><tr><td>-g</td><td>判断文件是否存在，且是否拥有SGID权限</td></tr><tr><td>-k</td><td>判断文件是否存在，且是否拥有SBit权限</td></tr></tbody></table></div><p>检测读(写/执行)权限时，文件所有者、所属组、其他任意拥有读(写/执行)权限都将返回true</p><h4 id="两个文件间的比较"><a href="#两个文件间的比较" class="headerlink" title="两个文件间的比较"></a>两个文件间的比较</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>文件1 -nt 文件2</td><td>判断文件1的修改时间是否比文件2新</td></tr><tr><td>文件1 -ot 文件2</td><td>判断文件1的修改时间是否比文件2旧</td></tr><tr><td>文件1 -et 文件2</td><td>判断文件1和文件2的i节点(Inode)是否一致，即判断是否为同一文件，常用于判断是否为硬链接</td></tr></tbody></table></div><h4 id="两个整数的比较"><a href="#两个整数的比较" class="headerlink" title="两个整数的比较"></a>两个整数的比较</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>整数1 -eq 整数2</td><td>判断整数1与整数2是否相等</td></tr><tr><td>整数1 -ne 整数2</td><td>判断整数1与整数2是否不相等</td></tr><tr><td>整数1 -gt 整数2</td><td>判断整数1是否大于整数2</td></tr><tr><td>整数1 -lt 整数2</td><td>判断整数1是否小于整数2</td></tr><tr><td>整数1 -ge 整数2</td><td>判断整数1是否大于等于整数2</td></tr><tr><td>整数1 -le 整数2</td><td>判断整数1是否小于等于整数2</td></tr></tbody></table></div><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-z 字符串</td><td>判断字符串是否为空</td></tr><tr><td>-z 字符串</td><td>判断字符串是否为非空</td></tr><tr><td>字符串1==字符串2</td><td>判断字符串1和字符串2是否相等</td></tr><tr><td>字符串1!=字符串2</td><td>判断字符串1和字符串2是否不相等</td></tr></tbody></table></div><p>字符串可以使用 $变量名 取值</p><h4 id="多重判断"><a href="#多重判断" class="headerlink" title="多重判断"></a>多重判断</h4><div class="table"><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>判断1 -a 判断2</td><td>逻辑与，判断1和判断2都成立，结果为真</td></tr><tr><td>判断1 -o 判断2</td><td>逻辑或，判断1和判断2任意一个成立，结果为真</td></tr><tr><td>! 判断</td><td>结果取反</td></tr></tbody></table></div><div class="show">示例：a=10[ -n "$a" -a "$a" -gt 20] && echo "true" || echo "false"判断a是否有值，并且判断a是否大于20，都成立输出 true，否则输出 false</div><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><div class="show"><span class="strong">if语句的格式为:</span>   if [条件判断] ;         //;可省略   then     程序体   fi   <span class="tips">或</span>    if [条件判断]       then            条件成立执行      else            条件不成立时执行   fi   <span class="tips">多分支if语句</span>   if [条件判断]       then            条件成立执行   elif [条件判断]      then            条件成立时执行   (.....)   else         上述所有条件不成立时执行   fi</div><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><div class="show"><strong>case语句格式为：</strong>case $变量 in   "值1")            程序1      ;;   "值2")            程序2      ;;     .....     *)         上述条件都不满足，执行该程序     ;; esac</div><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><div class="show"><strong>for语句格式：</strong> for 变量 in 值1 值2 值3.....   do       程序   done</div><pre><code> #! /bin/bash cd /lamp ls *.tar.gz>ls.log for i in $(cat ls.log)   do      tar -zxf $i &>/dev/null   done rm -rf /lamp/ls.log # 功能：将lamp目录下的所有压缩包文件名写入ls.log文件中，再遍历ls.log文件依次解压所有包 </code></pre><div class="show"><strong>for语句格式2：(类似于c语言，注意双括号)</strong>  for((初始值;条件;变量变化))   do     程序   done</div><h4 id="whlie与until循环"><a href="#whlie与until循环" class="headerlink" title="whlie与until循环"></a>whlie与until循环</h4><div class="show"><strong>whlie语法结构:</strong>   whlie [判断语句]      do         程序      done</div><div class="show"><strong>until语法结构：</strong>  until [条件判断]   do     程序   done</div>]]></content>
    
    
    <summary type="html">本文包括Bash历史命令与自定义命令，终端自定义，环境变量配置，shell基本语法，cut、awk、sed命令使用方法</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="shell" scheme="https://shiwei11.github.io/blog/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件与权限</title>
    <link href="https://shiwei11.github.io/blog/2022/01/22/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90/"/>
    <id>https://shiwei11.github.io/blog/2022/01/22/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9D%83%E9%99%90/</id>
    <published>2022-01-22T08:26:39.000Z</published>
    <updated>2022-07-14T08:00:31.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><h4 id="常见的文件类型"><a href="#常见的文件类型" class="headerlink" title="常见的文件类型"></a>常见的文件类型</h4><ol><li><span class="tips"><strong>普通文件：</strong></span>最为常见的文件类型，包括纯文本文件(ASCII)，二进制文件(binary)，数据文件(data)等</li><li><span class="tips"><strong>目录：</strong></span>即文件夹，用于包含更多目录和文件</li><li><span class="tips"><strong>块设备文件：</strong></span>将硬盘、光盘等存储设备以文件形式供用户操作</li><li><span class="tips"><strong>字符设备文件：</strong></span>将串行端口的接口设备，如键盘、鼠标等以文件形式供用户操作</li><li><span class="tips"><strong>套接字文件：</strong></span>又称为数据接口文件，用于网络数据连接</li><li><span class="tips"><strong>管道文件：</strong></span>用于解决多个程序同时存取一个文件所造成的错误</li><li><span class="tips"><strong>链接文件：</strong></span>分为硬链接和软链接，类似于快捷方式</li></ol><h4 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h4><h5 id="1-查看目录-list-信息"><a href="#1-查看目录-list-信息" class="headerlink" title="1. 查看目录(list)信息"></a>1. 查看目录(list)信息</h5><p><span class="strong">ls [可选参数] [文件或目录]</span></p><ul><li>-a &emsp;显示所有文件，包括隐藏文件</li><li>-l &emsp;显示详细信息，默认情况下文件大小只以byte显示，命令可以直接写为 ll</li><li>-d &emsp;查看目录信息而非展示目录所含文件</li><li>-h &emsp;常与l参数一起使用，文件大小会被换算为KB、MB等单位</li><li>-i &emsp;查看文件i节点</li></ul><p>如果不指定文件或目录名，操作对象为当前目录</p><div class="show">示例：# ls列出当前目录所含非隐藏文件或文件夹# ll (同ls -l)列出当前目录所含非隐藏文件或文件夹详细信息# ls -ld列出当前目录的详细信息#ls -ldh tmp列出tmp目录的详细信息，并且文件大小会被换算为KB等方便阅读的单位</div><h5 id="2-文件信息详解"><a href="#2-文件信息详解" class="headerlink" title="2. 文件信息详解"></a>2. 文件信息详解</h5><p>使用<span class="tips">ls -l</span>等命令列出文件详细信息，文件信息格式类似于</p><div style="text-align:center;"><span class="tips">&emsp;drwxr-xr-x.  &nbsp;6&nbsp; root&nbsp; root&nbsp; 4.0K &nbsp;Feb&nbsp;  9&nbsp; 11:53&nbsp; home&emsp;</span></div><h5 id="字段一"><a href="#字段一" class="headerlink" title="字段一"></a>字段一</h5><h6 id="第1位"><a href="#第1位" class="headerlink" title="第1位"></a>第1位</h6><p>第1位表示文件类型</p><ul><li>-为普通文件</li><li>d为目录</li><li>l为链接文件</li><li>c为字符设备文件，如：鼠标、键盘设备文件</li><li>b为块设备文件，如：硬盘设备文件</li><li>s为套接字文件，一般用于数据连接，常见于 /var/run目录</li><li>p为管道文件(FIFO)，用于解决多个程序同时存取一个文件所造成的错误</li></ul><h6 id="第2-10位"><a href="#第2-10位" class="headerlink" title="第2-10位"></a>第2-10位</h6><p>3位为一组，分别为文件所有者、所属组、其他用户的读、写、执行权限</p><ul><li>r为可读</li><li>w为可写</li><li>x为可执行</li><li>-为无权限</li></ul><h6 id="第11位-号"><a href="#第11位-号" class="headerlink" title="第11位 .号"></a>第11位 .号</h6><p>.号为安装有SElinux的系统特有，这个点表示该文件带有“SELinux的安全上下文”</p><h5 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h5><p>之后的字段分别表示</p><ul><li>该文件被硬链接调用过的次数</li><li>文件所属用户</li><li>文件所属组</li><li>文件大小</li><li>文件最后一次修改时间，无修改则为创建时间</li><li>文件名</li></ul><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><h5 id="1-创建目录-make-directory"><a href="#1-创建目录-make-directory" class="headerlink" title="1.创建目录(make directory)"></a>1.创建目录(make directory)</h5><p><span class="strong">mkdir [-p] 目录名</span></p><ul><li>使用-p 可以递归创建目录，在不存在的目录下创建新目录</li><li>目录名可以写多个来同时创建多个目录</li></ul><div class="show">示例：# mkdir tmp/test/newdir如果tmp目录下没有test目录，将提示无test目录，此时可以用-p参数# mkdir -p tmp/test/newdir将在tmp下新建test，再在test下新建newdir目录# mkdir newdir1 newdir2 newdir3在当前路径下新建三个目录</div><h5 id="2-切换目录-change-directory"><a href="#2-切换目录-change-directory" class="headerlink" title="2.切换目录(change directory)"></a>2.切换目录(change directory)</h5><p><span class="strong">cd 目录名</span></p><ul><li>目录名可以用<span class="tips"> Tab键 </span>补全</li><li>Linux中使用<span class="tips"> . </span>表示当前目录，<span class="tips"> .. </span>表示上一级目录，可以使用<span class="tips">cd .. </span>返回上一级目录</li></ul><h5 id="3-查看当前路径-print-working-directory"><a href="#3-查看当前路径-print-working-directory" class="headerlink" title="3.查看当前路径(print working directory)"></a>3.查看当前路径(print working directory)</h5><p><span class="strong"> pwd </span><br>显示工作目录的路径</p><h5 id="4-删除空目录-remove-empty-directory"><a href="#4-删除空目录-remove-empty-directory" class="headerlink" title="4.删除空目录(remove empty directory)"></a>4.删除空目录(remove empty directory)</h5><p><span class="strong"> rmdir 目录名 </span><br>系统不允许使用该命令删除有内容的目录</p><h5 id="5-删除文件与目录-remove"><a href="#5-删除文件与目录-remove" class="headerlink" title="5.删除文件与目录(remove)"></a>5.删除文件与目录(remove)</h5><p><span class="strong"> rm [-rf] 文件或目录名</span></p><ul><li>-r&emsp;删除目录需要使用该参数</li><li>-f&emsp;强制删除，不再询问用户确认</li></ul><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>Linux无回收站功能，文件会被直接删除</div><h5 id="5-复制文件或目录-copy"><a href="#5-复制文件或目录-copy" class="headerlink" title="5.复制文件或目录(copy)"></a>5.复制文件或目录(copy)</h5><p><span class="strong"> cp [可选参数] [源文件或目录] [目标目录]</span></p><ul><li>-r &emsp;复制目录</li><li>-p &emsp;保留文件属性，如文件修改时间</li><li>复制文件不需要任何参数，复制目录使用-r</li><li>源文件或目录可以有多个来同时复制多个文件</li><li>复制文件的同时可以将新文件改名<div class="show">示例：# cp /file/test1 /file/test2 /newdir复制文件test1和test2到newdir目录中# cp -p install.log /tem复制install.log文件到tem目录中并保留install.log文件信息(不使用-p参数则文件最后修改时间为执行复制操作的当前时间)# cp -r /usr/dir /tem/newdir复制目录dir到tem目录下并命名为newdir</div></li></ul><h5 id="6-移动文件和修改文件名-move"><a href="#6-移动文件和修改文件名-move" class="headerlink" title="6.移动文件和修改文件名(move)"></a>6.移动文件和修改文件名(move)</h5><p><span class="strong"> mv [源文件或目录] [目标目录]</span></p><ul><li>如果目标目录没有对应名字，则为修改文件名操作</li><li>源文件或目录可以有多个来同时移动多个文件</li></ul><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="1-创建空文件"><a href="#1-创建空文件" class="headerlink" title="1. 创建空文件"></a>1. 创建空文件</h5><p><span class="strong"> touch [文件名]</span></p><ul><li>可以同时创建多个文件，文件名之间用空格隔开</li><li>如果文件名中有空格符，需要使用””<div class="show">示例：# touch file1 file2创建两个文件file1、file2# touch "fi le"创建一个名为fi le的文件</div></li></ul><h5 id="2-查看文件内容"><a href="#2-查看文件内容" class="headerlink" title="2. 查看文件内容"></a>2. 查看文件内容</h5><h6 id="2-1-查看短文件"><a href="#2-1-查看短文件" class="headerlink" title="2.1 查看短文件"></a>2.1 查看短文件</h6><p><span class="strong"> cat [-n] [文件名]</span></p><ul><li>-n &emsp;显示行号<br>从头到尾正常显示文件</li></ul><p><span class="strong"> tac [-n] [文件名]</span><br>cat反写，从尾到头显示文件(文件末行为第一行)</p><h6 id="2-2-查看长文件"><a href="#2-2-查看长文件" class="headerlink" title="2.2 查看长文件"></a>2.2 查看长文件</h6><p><span class="strong"> more [文件名]</span><br>分页显示文件，一般用于查看长文件</p><ul><li>空格或f &emsp;向下翻页</li><li>b     &emsp;&emsp; &emsp;&nbsp;向上翻页</li><li>Enter  &emsp;&emsp;换行</li><li>q或Q &emsp;&emsp;退出</li></ul><p><span class="strong"> less [文件名]</span><br>分页显示文件，一般用于查看长文件，支持关键字搜索</p><ul><li> 空格或f或PageDown&emsp;向下翻页</li><li>b或PageUp&emsp;&emsp;&emsp;&emsp;&emsp;向上翻页</li><li>上下方向键&emsp;&emsp;&emsp;&emsp;&emsp;逐行翻动</li><li>可以使用<span class="tips"> /关键字 </span>进行关键字搜索，使用<span class="tips"> n </span>跳转到下一个高亮显示的关键字</li><li>q或Q &emsp;&emsp;退出</li></ul><h6 id="2-3-仅查看前几行或后几行"><a href="#2-3-仅查看前几行或后几行" class="headerlink" title="2.3 仅查看前几行或后几行"></a>2.3 仅查看前几行或后几行</h6><p><span class="strong"> head [-n 行号] 文件名</span><br>仅仅查看文件前几行，不使用 -n 指定行号，默认显示前10行</p><p><span class="strong"> tail [可选参数] 文件名</span></p><ul><li>-n 行号 &emsp; 仅仅查看文件末几行，不使用 -n 指定行号，默认显示后10行</li><li>-f &emsp;&emsp;&emsp;动态显示文件末尾，常用于查看日志文件实时变更</li></ul><h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><p>软链接：类似于Windows的快捷方式，读取、执行等操作依旧基于源文件，当源文件删除，软链接文件也将失效</p><p>硬链接：相当于复制了一份文件，并且当源文件发生改动，硬链接文件会同步更新，源文件删除，硬链接文件依旧有效</p><p><span class="strong">ln [-s] 源文件 目标文件</span><br> -s 为生成生成软链接，无该参数为生成硬链接</p><div class="show">示例:# ln /etc/issue /tmp/issue.hard为/etc/issue创建硬链接# ln -s /etc/issue /tmp/issue.soft为/etc/issue创建软链接</div><p>二者区别:</p><ul><li>生成的软链接权限都为 rwxrwxrwx，实际权限取决于源文件权限</li><li>硬链接文件 i 节点与源文件相同，软链接不同</li><li>硬链接指向不能跨分区，软链接可以</li><li>不能给目录生成硬链接，软链接可以</li></ul><h3 id="文件与目录权限管理"><a href="#文件与目录权限管理" class="headerlink" title="文件与目录权限管理"></a>文件与目录权限管理</h3><h4 id="权限管理中的参数"><a href="#权限管理中的参数" class="headerlink" title="权限管理中的参数"></a>权限管理中的参数</h4><div class="table"><table><thead><tr><th>符号</th><th>含义</th><th>对文件</th><th>对目录</th></tr></thead><tbody><tr><td>r</td><td>读权限</td><td>可以查看文件内容</td><td>可以列出目录中的内容</td></tr><tr><td>w</td><td>写权限</td><td>可以修改文件内容</td><td>可以在目录中创建、删除文件</td></tr><tr><td>x</td><td>执行权限</td><td>可以执行文件</td><td>可以进入目录</td></tr><tr><td>-</td><td>无权限</td><td>无权限</td><td>无权限</td></tr></tbody></table></div><p><span class="tips">删除某个文件需要对包含该文件的母目录拥有w权限，对文件拥有w权限只能修改文件内容而不能进行删除</span></p><h4 id="更改权限-change-the-permissions-mode-of-a-file"><a href="#更改权限-change-the-permissions-mode-of-a-file" class="headerlink" title="更改权限(change the permissions mode of a file)"></a>更改权限(change the permissions mode of a file)</h4><p><span class="strong">chmod [-R] [{ugoa}{+-=}{rwx}] [文件名或目录名]</span><br>只有root用户与文件所有者才能修改文件的权限</p><ul><li><p>-R&emsp;递归修改，修改目录及其所有子文件的权限</p></li><li><p>u为文件所有者，g为文件所属组，o为其他用户，a为所有用户</p></li><li><p>+为添加权限，-为取消权限，=为修改权限为等号所指</p></li><li><p>同时修改ugoa中的多个可以使用 , 号分隔</p><div class="show">示例：# chmod g+w,o-r file添加文件所属组写权限，取消文件其他用户的读权限# chmod a=rwx file将所有人权限都修改为 rwx</div>可以将rwx写为mode值之和<p><span class="strong">chmod [mode] [文件名或目录名]</span></p></li><li><p>r 值为4</p></li><li><p>w 值为2</p></li><li><p>x 值为1</p></li><li><p>rwx值为7，rw-值为6，r-x值为5依此类推</p><div class="show">示例：# chmod 640 index.html修改权限为rw-r-----</div></li></ul><h4 id="更改文件所有者-change-file-ownership"><a href="#更改文件所有者-change-file-ownership" class="headerlink" title="更改文件所有者(change file ownership)"></a>更改文件所有者(change file ownership)</h4><p><span class="strong">chown [用户] [文件名或目录名]</span></p><p><span class="tips">只有root用户才能更改文件所有者</span></p><h4 id="更改文件所属组-change-file-group-ownership"><a href="#更改文件所属组-change-file-group-ownership" class="headerlink" title="更改文件所属组(change file group ownership)"></a>更改文件所属组(change file group ownership)</h4><p><span class="strong">chgrp [用户组] [文件名或目录名]</span></p><p><span class="tips">只有root用户才能更改文件所属组</span></p><h4 id="更改新建文件时的默认权限设置-the-user-file-creation-mask"><a href="#更改新建文件时的默认权限设置-the-user-file-creation-mask" class="headerlink" title="更改新建文件时的默认权限设置(the user file-creation mask)"></a>更改新建文件时的默认权限设置(the user file-creation mask)</h4><ul><li><span class="strong">umask -S</span>&emsp;显示新建目录时权限的默认设置</li><li><span class="strong">umask</span>&emsp;显示默认权限值</li><li><span class="strong">umask  权限值</span>&emsp;修改默认权限</li></ul><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>新建的文件相较于新建的目录所有用户会少一个x权限，这是因为Linux会取消新建文件的可执行权限以防止危害系统的可执行程序运行</div><div class="show">root执行umask显示默认权限值一般为0022(普通用户为0002)，第一位0代表特殊权限，022为默认的权限与777权限异或后的权限值    777 rwx rwx rwx    022 --- -w- -w-  ===============    755 rwx r-x r-x(默认权限)因此需要修改默认权限时，需要先异或操作计算出权限值，如想把默认权限改为rwx --- ---，则先计算权限值    777 rwx rwx rwx    700 rwx --- ---  =================    077 --- rwx rwx然后执行umask 077即可，同样，如果创建的是一个文件，Linux会在默认权限基础上取消所有用户的x权限</div><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><h4 id="文件查找-1"><a href="#文件查找-1" class="headerlink" title="文件查找"></a>文件查找</h4><p>文件查找会占用大量的系统资源，尽量避免在系统使用高峰期使用文件查找命令，文件查找范围应该尽可能小。</p><h5 id="1-根据文件名查找"><a href="#1-根据文件名查找" class="headerlink" title="1. 根据文件名查找"></a>1. 根据文件名查找</h5><p><span class="strong">find [查找路径] [参数] [文件名]</span></p><ul><li>-name&emsp;根据文件名查找</li><li>-iname&emsp;根据文件名查找(文件名不区分大小写)</li><li>搜索范围应尽可能小，尽量避免在根目录下搜索</li><li>只使用文件名为精确搜索，可以使用通配符(*匹配任意数量字符，一个?匹配一个字符)来模糊查找<div class="show">示例:# find /etc -name init在/etc目录下查找init文件# find /etc -name *init*在/etc目录下查找所有文件名带init的文件# find /etc -name init???在/etc目录下查找所有文件名init开头，后面跟3个字符的文件</div></li></ul><h5 id="2-根据文件大小查找"><a href="#2-根据文件大小查找" class="headerlink" title="2. 根据文件大小查找"></a>2. 根据文件大小查找</h5><p><span class="strong">find [查找路径] [参数] [文件大小]</span></p><ul><li>-size &emsp;根据文件大小查找</li><li>文件大小中，可以使用+表示大于，-表示小于，直接写数值表示等于<div class="show">示例:# find / -size +100M查找服务器中大于100MB的文件</div></li></ul><h5 id="3-根据文件所有者、所属组查找"><a href="#3-根据文件所有者、所属组查找" class="headerlink" title="3. 根据文件所有者、所属组查找"></a>3. 根据文件所有者、所属组查找</h5><p><span class="strong">find [查找路径] [参数] [用户名或组名]</span></p><ul><li>-user &emsp;根据根据文件所属用户查找</li><li>-group&emsp;根据文件所属组查找<div class="show">示例:# find /home -user shw查找/home目录下属于shw用户的文件</div></li></ul><h5 id="4-根据时间属性查找"><a href="#4-根据时间属性查找" class="headerlink" title="4. 根据时间属性查找"></a>4. 根据时间属性查找</h5><p><span class="strong">find [查找路径] [参数] [时间]</span></p><ul><li>-amin &emsp;根据根据文件访问时间</li><li>-cmin &emsp;根据文件属性被修改时间</li><li>-mmin &emsp;根据文件内容被修改时间</li><li>时间参数中，使用+表示超过该时间范围，-表示小于该时间内，直接写数值表示等于<div class="show">示例:# find /etc -amin -5查找/etc目录下5分钟内被访问过的所有文件</div></li></ul><h5 id="5-根据文件类型查找"><a href="#5-根据文件类型查找" class="headerlink" title="5. 根据文件类型查找"></a>5. 根据文件类型查找</h5><p><span class="strong">find -type [文件类型]</span></p><ul><li>f &emsp;文件</li><li>d &emsp;目录</li><li>l &emsp;链接文件<div class="show">示例:# find /etc -type f查找/etc目录下的所有普通文件</div></li></ul><h5 id="6-多个条件同时查找"><a href="#6-多个条件同时查找" class="headerlink" title="6. 多个条件同时查找"></a>6. 多个条件同时查找</h5><p>如果需要查找同时满足多个条件的文件，可以添加下面的参数</p><ul><li>-a &emsp;两个条件同时满足</li><li>-o &emsp;两个条件任意满足一个<div class="show">示例:# find /etc -size +100MB -a -size -200MB查找大于100MB而小于200MB的文件</div></li></ul><h5 id="7-对找到文件的执行其他命令"><a href="#7-对找到文件的执行其他命令" class="headerlink" title="7. 对找到文件的执行其他命令"></a>7. 对找到文件的执行其他命令</h5><p>如果在找到文件后需要对其进行相应操作，可以添加下述命令</p><ul><li>-exec 命令 {}; &emsp;找到文件后直接执行命令</li><li>-ok 命令 {}; &emsp;找到文件后会每个文件逐一询问是否执行命令<div class="show">示例:# find /etc -name init* -a -type f -exec ls -l {} \;找到/etc目录下所有init开头的文件并列出具体文件信息# find /home -size +100MB -a -user shw -ok rm {} \;找到/home目录下属于shw用户且大于100MB的文件，然后依次询问是否删除找到的文件</div></li></ul><h5 id="根据i节点查找"><a href="#根据i节点查找" class="headerlink" title="根据i节点查找"></a>根据i节点查找</h5><p><span class="strong">find [查找路径] -inum i节点值</span><br>在知道某文件i节点值的情况下根据i节点查找，如：用于查找某个文件的硬链接(文件i节点值与文件硬链接i节点值相同)</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>locate为一个文件查找工具，可以从yum源安装<br>find命令为在指定目录下遍历查找，会占用大量系统资源，而且查找速度较慢，locate会建立文件资料库，然后在资料库中查找，反应速度快。<br><span class="strong">locate [-i] 文件名</span></p><ul><li>-i&emsp;不区分大小写</li><li>locate会定期更新资料库，但实时新建的文件可能会找不到，可以在root下使用 updatedb 命令手动更新资料库</li><li>locate 不会将/tmp等临时缓存文件收录到资料库中，因此临时文件使用locate找不到</li></ul><h3 id="查找命令所在路径"><a href="#查找命令所在路径" class="headerlink" title="查找命令所在路径"></a>查找命令所在路径</h3><ul><li><span class="strong">which 命令</span>&emsp;查找命令所在路径，同时可以查看命令的别名</li><li><span class="strong">whereis 命令</span>&emsp;查找命令所在路径，同时可以查看命令帮助文档所在路径<div class="show">示例:# which rmLinux返回:alias rm='rm -i'   /usr/bin/rm查看rm命令所在路径，rm -i为rm命令全写#whereis rmLinux返回:rm: /usr/bin/rm /usr/share/man/man1/rm.1.gz返回信息为rm命令所在路径和rm命令帮助文档所在路径</div></li></ul><h3 id="查找文件中的某个内容"><a href="#查找文件中的某个内容" class="headerlink" title="查找文件中的某个内容"></a>查找文件中的某个内容</h3><p><span class="strong">grep [参数] [搜索的字符串] [文件]</span></p><ul><li>-i &emsp;不区分大小写</li><li>-v &emsp;排除指定字符串<br>找到或排除字符串所在行，然后输出内容<div class="show">示例:# grep man /etc/file找到/etc/file文件中含有man的行并输出# grep -v ^# /etc/inittab显示/etc/inittab中除了#开头的所有行内容(#开头的内容为被注释了的内容，不想看注释)</div></li></ul><h3 id="查看帮助-manual"><a href="#查看帮助-manual" class="headerlink" title="查看帮助 (manual)"></a>查看帮助 (manual)</h3><h4 id="1-查看完整帮助man"><a href="#1-查看完整帮助man" class="headerlink" title="1. 查看完整帮助man"></a>1. 查看完整帮助man</h4><p><span class="strong">man [命令或配置文件]</span></p><ul><li>查看配置文件的帮助时，直接写文件名，不能加上文件路径，使用文件路径会直接显示文件内容而不是该配置文件的使用说明</li><li>对于命令，man 有帮助级别(通常为0-9)，可以使用 <span class="tips">whereis 命令</span>查看该命令在man目录下有几个级别，如果有级别，可以使用<span class="tips">man [级别] [命令]</span>来查看对应帮助。如：1为通常为命令的帮助，5通常为命令对应说明文档的帮助。即：使用<span class="tips">man 命令</span>和<span class="tips">man 1 命令</span>为查看命令的帮助，<span class="tips">man 5 命令</span>为查看目录说明文档的帮助(具体级别视命令而定)</li></ul><h4 id="2-查看简短帮助"><a href="#2-查看简短帮助" class="headerlink" title="2. 查看简短帮助"></a>2. 查看简短帮助</h4><ul><li><span class="strong">what 命令</span>&emsp;只显示命令帮助文档中NAME部分的内容</li><li><span class="strong">apropos 配置文件</span>&emsp;简短查看配置文件作用</li></ul><h4 id="3-查看命令的可选参数选项"><a href="#3-查看命令的可选参数选项" class="headerlink" title="3. 查看命令的可选参数选项"></a>3. 查看命令的可选参数选项</h4><p>只查看命令的可选参数选项，不需要查看命令完整帮助信息</p><p><span class="strong">命令 --help</span></p><h4 id="4-查看shell内置命令"><a href="#4-查看shell内置命令" class="headerlink" title="4. 查看shell内置命令"></a>4. 查看shell内置命令</h4><p>有些命令是bash(shell)内置命令而不是Linux的命令，使用上述命令查看不到帮助，可以使用</p><p><span class="strong">help 命令</span></p><h3 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h3><h4 id="文件的压缩与解压-gz格式"><a href="#文件的压缩与解压-gz格式" class="headerlink" title="文件的压缩与解压(.gz格式)"></a>文件的压缩与解压(.gz格式)</h4><p>压缩格式为<span class="tips">.gz</span>，与windows不同，下述命令只能压缩与解压缩文件，不能处理文件夹，并且压缩完只保留压缩文件，不保留原文件</p><ul><li><span class="strong">gzip 文件名</span>&emsp;压缩(GUN zip)</li><li><span class="strong">gunzip 文件名</span>&emsp;解压缩(GUN unzip)</li></ul><h4 id="文件夹的打包、压缩与解压-tar-gz格式"><a href="#文件夹的打包、压缩与解压-tar-gz格式" class="headerlink" title="文件夹的打包、压缩与解压(.tar.gz格式)"></a>文件夹的打包、压缩与解压(.tar.gz格式)</h4><h5 id="打包与压缩"><a href="#打包与压缩" class="headerlink" title="打包与压缩"></a>打包与压缩</h5><p><span class="strong">tar [参数] [压缩后文件名] [压缩目录]</span></p><p>打包是将多个文件打包为一个文件，文件总大小不变，打包后的文件格式为<span class="tips">.tar</span>，对包可以用<span class="strong">gzip</span>命令压缩，生成<span class="tips">.tar.gz</span>格式的压缩包文件，而<span class="strong">tar</span>命令可以将打包压缩同时处理，打包压缩后的文件名可以不写.tar.gz等后缀，但不方便用户识别。</p><ul><li>-c &emsp;打包</li><li>-v &emsp;显示详细信息</li><li>-f &emsp;指定文件名(该参数必须)</li><li>-z &emsp;打包后压缩(需要和c参数一起使用)<div class="show">示例:# tar -cvf test1.tar test1打包test1文件夹中文件为test1.tar文件，并显示详细信息# tar -zcf test.tar.gz test1打包并压缩test1文件夹为test.tar.gz</div></li></ul><h5 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h5><p><span class="strong">tar [参数] [解压缩的文件]</span></p><ul><li>-x &emsp;解包</li><li>-v &emsp;显示详细信息</li><li>-f &emsp;指定解压缩的文件(该参数必须)</li><li>-z &emsp;解包后解压缩(需要和x参数一起使用)<p>最常用的是解压一个.tar.gz文件，因此大多数情况下-zxf为必用参数</p><div class="show">示例:# tar -zxvf test.tar.gz 解压缩test.tar.gz文件，并显示详细信息</div></li></ul><h4 id="zip格式的压缩与解压"><a href="#zip格式的压缩与解压" class="headerlink" title=".zip格式的压缩与解压"></a>.zip格式的压缩与解压</h4><p><span class="strong">zip [选项] [-r] [压缩后文件名] [压缩文件或目录]</span></p><ul><li>-r&emsp;压缩目录<p>.zip格式为Linux和windows通用格式，zip命令会保留原文件，并且一个命令就可以处理文件与文件夹</p></li></ul><p><span class="strong">unzip [解压的文件名]</span></p><p>解压文件</p><h4 id="bz2、-tar-bz2格式的压缩与解压"><a href="#bz2、-tar-bz2格式的压缩与解压" class="headerlink" title=".bz2、.tar.bz2格式的压缩与解压"></a>.bz2、.tar.bz2格式的压缩与解压</h4><h5 id="1-压缩"><a href="#1-压缩" class="headerlink" title="1. 压缩"></a>1. 压缩</h5><h6 id="对文件-格式为-bz2"><a href="#对文件-格式为-bz2" class="headerlink" title="对文件(格式为.bz2)"></a>对文件(格式为.bz2)</h6><p><span class="strong">bzip2 [参数] [-k][文件]</span></p><ul><li>-k &emsp;压缩后保留原文件</li></ul><h6 id="对文件夹-格式为-tar-bz2"><a href="#对文件夹-格式为-tar-bz2" class="headerlink" title="对文件夹(格式为.tar.bz2)"></a>对文件夹(格式为.tar.bz2)</h6><p><span class="strong">tar -jcf [压缩后文件名] [压缩目录]</span></p><p>即将tar中的z参数改为j参数就是压缩为.tar.bz2格式</p><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h5><h6 id="对文件-格式为-bz2-1"><a href="#对文件-格式为-bz2-1" class="headerlink" title="对文件(格式为.bz2)"></a>对文件(格式为.bz2)</h6><p><span class="strong">bunzip2 [-k] [解压文件]</span></p><ul><li>-k &emsp;解压缩后保留原文件</li></ul><h6 id="对文件夹-格式为-tar-bz2-1"><a href="#对文件夹-格式为-tar-bz2-1" class="headerlink" title="对文件夹(格式为.tar.bz2)"></a>对文件夹(格式为.tar.bz2)</h6><p><span class="strong">tar -jxf [解压文件]</span></p><p>同样将tar中的z参数改为j参数就是解压.tar.bz2格式</p><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><p>ACL权限用于给文件所有者(u)、所属组(g)、其他用户(o)以外的用户提供权限</p><h4 id="查看ACL权限"><a href="#查看ACL权限" class="headerlink" title="查看ACL权限"></a>查看ACL权限</h4><p><span class="strong">getfacl 文件名</span></p><div class="show">设置了ACL权限的文件，使用 ls -l 命令查看文件时权限标识后带有+号，如：-rw-r-xr--+ 1 root root  174 Jan 23 18:55 index.html使用 getfacl 命令查看具体ACL权限，会多一组拥有ACL权限的 user或group 并标明用户名或组名，如：# file: index.html# owner: root# group: rootuser::rw-user:sw:r-x     //sw用户拥有ACL权限r-xgroup::r--mask::r-xother::r--</div><h4 id="设置mask权限"><a href="#设置mask权限" class="headerlink" title="设置mask权限"></a>设置mask权限</h4><p>mask权限用于指定最大的权限，防止给与用户ACL权限时权限过大。用户最终得到的权限是ACL权限于mask权限相与以后得到的权限。<br><span class="strong">setfacl -m m:组名:权限 文件名</span></p><h4 id="设置ACL权限"><a href="#设置ACL权限" class="headerlink" title="设置ACL权限"></a>设置ACL权限</h4><p><span class="strong">setfacl 参数 文件名</span></p><ul><li>-m &emsp;设定ACL权限</li><li>-x &emsp;删除指定ACL权限</li><li>-b &emsp;删除文件所有ACL权限</li><li>-d &emsp;设定默认ACL权限</li><li>-k &emsp;删除默认ACL权限</li><li>-R &emsp;递归设置ACL权限</li></ul><h5 id="1-设置ACL权限"><a href="#1-设置ACL权限" class="headerlink" title="1. 设置ACL权限"></a>1. 设置ACL权限</h5><ul><li><span class="strong">setfacl -m u:用户名:权限 文件名</span>给用户设置ACL权限</li><li><span class="strong">setfacl -m u:用户名:权限 -R 文件名</span>递归设置，给用户设置目录下所有子文件的ACL权限</li><li><span class="strong">setfacl -m g:组名:权限 文件名</span>给组设置ACL权限</li><li><span class="strong">setfacl -m g:组名:权限 -R 文件名</span>递归设置，给组设置目录下所有子文件的ACL权限<div class="show">示例：setfacl -m u:lm:r-x index.html给与用户lm对index.html的读和执行权限</div></li></ul><h5 id="2-删除ACL权限"><a href="#2-删除ACL权限" class="headerlink" title="2. 删除ACL权限"></a>2. 删除ACL权限</h5><p><span class="strong">setfacl -x [u或g]:[用户名或组名] 文件名</span></p><p>删除对应用户或组的ACL权限</p><p><span class="strong">setfacl -b 文件名</span></p><p>删除对应文件所有ACL权限</p><h5 id="3-设置默认ACL权限"><a href="#3-设置默认ACL权限" class="headerlink" title="3. 设置默认ACL权限"></a>3. 设置默认ACL权限</h5><p>设置默认ACL权限的作用是给父目录设置ACL权限后，父目录中创建的所有子文件都会继承父目录的ACL权限，但执行命令前的文件不会拥有权限。与递归设置的区别是，递归设置的ACL权限只会给当前已经存在的子目录给与ACL权限，新建的后来文件不会拥有权限。</p><ul><li><span class="strong">setfacl -m d:u:用户名:权限 文件名</span>设置默认ACL权限</li><li><span class="strong">setfacl -m k:u:用户名:权限 文件名</span> 删除默认ACL权限设置</li></ul><p>可以添加-R参数递归给子目录的子文件也设置默认ACL权限，但执行命令前创建的文件依旧不会有ACL权限。</p><p><span class="strong">setfacl -m d:u:用户名:权限 -R 文件名</span></p><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><h4 id="1-SetUID权限"><a href="#1-SetUID权限" class="headerlink" title="1. SetUID权限"></a>1. SetUID权限</h4><p>用于执行某个程序时赋予该用户文件所有者身份，程序运行完毕收回所有者身份。如：普通用户对 /etc/shadow 文件的权限为 0 ，即无法查看无法修改，但通过执行passwd命令，普通用户会获得临时的所有者即root权限，可以修改密码，</p><ul><li><span class="tips">只有可执行的二进制程序才能设置SUID权限</span></li><li><span class="tips">要求命令执行者要对该程序拥有x(执行)权限</span></li><li>命令执行者在运行该程序时会临时获得文件所有者身份</li><li>SUID权限只在该程序执行时有效，程序执行完毕权限失效</li></ul><h5 id="设置SUID权限"><a href="#设置SUID权限" class="headerlink" title="设置SUID权限"></a>设置SUID权限</h5><p>4代表SUID</p><ul><li><span class="strong">chmod 4755 文件名</span>&emsp;755为权限值可任意，但要保证用户有x权限</li><li><span class="strong">chmod u+s 文件名</span></li></ul><h5 id="取消SUID权限"><a href="#取消SUID权限" class="headerlink" title="取消SUID权限"></a>取消SUID权限</h5><p><span class="strong">chmod 755 文件名</span></p><p><span class="strong">chmod u-s 文件名</span></p><div class="show">说明：当设置SUID权限后，该文件权限标识中所有者的可执行权限x会被修改为s-rwsr--r--  1 root root 174 Jan 23 18:56 file如果该标识为大写S，则说明文件设置了SUID权限，但用户没有x权限，SUID权限无法生效，权限报错</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>该命令容易造成权限滥用，Linux中默认只有/usr/bin/passwd 等少数文件有SUID权限，禁止为 vi 等命令设置该权限，否则所有用户在使用 vi 命令时都将获得 root 权限。应定时检查系统中是否有除默认以外的文件设置了SUID权限</div><h4 id="2-SetGID权限"><a href="#2-SetGID权限" class="headerlink" title="2. SetGID权限"></a>2. SetGID权限</h4><p>对文件</p><ul><li>只有可执行的二进制程序才能设置SGID权限</li><li>要求命令执行者要对该程序拥有x(执行)权限</li><li>命令执行者在运行该程序时，组身份会临时升为文件所属组身份</li><li>SGID权限只在该程序执行时有效，程序执行完毕权限失效</li></ul><div class="show">说明：当设置SGID权限后，该文件权限标识中所属组的可执行权限x会被修改为s，如 locate 命令的权限为-rwx--s--x  1 root root 174 Jan 23 18:56 usr/bin/locate</div><p>对目录</p><ul><li>要求用户必须拥有此目录的 r 和 x 权限</li><li>普通用户进入该目录时，用户的组会升为此目录的所属组</li><li>如果用户对目录有w权限，新建文件的默认组 将变为目录的所属组，而非创建者的所属组</li></ul><h5 id="设置SGID权限"><a href="#设置SGID权限" class="headerlink" title="设置SGID权限"></a>设置SGID权限</h5><p>2代表SGID</p><ul><li><span class="strong">chmod 2755 文件名</span>&emsp;755为权限值可任意，若为文件要保证拥有x权限，为目录则拥有r和x权限</li><li><span class="strong">chmod g+s 文件名</span></li></ul><h5 id="取消SGID权限"><a href="#取消SGID权限" class="headerlink" title="取消SGID权限"></a>取消SGID权限</h5><p><span class="strong">chmod 755 文件名</span></p><p><span class="strong">chmod g-s 文件名</span></p><h4 id="3-Sticky-BIT-粘着位权限"><a href="#3-Sticky-BIT-粘着位权限" class="headerlink" title="3. Sticky BIT(粘着位权限)"></a>3. Sticky BIT(粘着位权限)</h4><ul><li>只对目录有效</li><li><span class="tips">要求用户对目录拥有w和x权限</span></li><li>没有设置粘着位权限时，用户拥有w权限后可以删除目录下的所有文件，包括其他用户创建的文件。设置粘着位后，用户只能删除自己创建的文件，root用户不受此规则影响</li></ul><div class="show">说明：当设置SBIT权限后，文件权限标识中其他用户的可执行权限x会被修改为t，如drwxrwxrwt  1 root root 174 Jan 23 18:56 /dir/</div><h5 id="设置SBIT权限"><a href="#设置SBIT权限" class="headerlink" title="设置SBIT权限"></a>设置SBIT权限</h5><p>1代表SBID</p><ul><li><span class="strong">chmod 1755 目录名</span>&emsp;755为权限值可任意，要保证用户拥有w和x权限</li><li><span class="strong">chmod o+t 目录名</span></li></ul><h5 id="取消SBIT权限"><a href="#取消SBIT权限" class="headerlink" title="取消SBIT权限"></a>取消SBIT权限</h5><p><span class="strong">chmod 755 目录名</span></p><p><span class="strong">chmod o-t 目录名</span></p><h3 id="文件系统属性权限chattr权限"><a href="#文件系统属性权限chattr权限" class="headerlink" title="文件系统属性权限chattr权限"></a>文件系统属性权限chattr权限</h3><p><span class="strong">chattr&emsp;[+-=][i或a]&emsp;文件或目录名</span></p><ul><li><p>+为增加权限，-为删除权限，=为设置为指定权限</p></li><li><p>i &emsp;对文件：不允许删除、改名、添加内容或修改文件内容操作<br>&emsp;对目录：只能修改目录下文件的内容，不允许新建和删除文件<br><span class="tips">对root用户生效！</span></p></li><li><p>a &emsp;对文件：只能添加新内容，不能删除、修改已有内容(并且只允许使用echo添加，不能使用vi等编辑器添加)<br>&emsp;对目录：只能新建和修改文件，不能删除文件<br><span class="tips">对root用户生效！</span></p></li></ul><div class="show">示例：chattr +i test给文件test添加i属性，锁定文件，防止误操作</div><h5 id="查看chattr权限方法"><a href="#查看chattr权限方法" class="headerlink" title="查看chattr权限方法"></a>查看chattr权限方法</h5><p>该权限无法使用 ls 命令查看，而需要使用：</p><p><span class="strong">lsattr [参数] 文件名</span></p><ul><li>-a 显示所有文件和目录</li><li>-d 若为目录，则显示目录属性，而非子文件属性</li></ul><h3 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h3><p>由root用户赋予普通用户权限，使普通用户可以使用原本只有root用户才能执行的系统命令。能赋予的只能是系统命令！</p><h5 id="1-添加赋予的命令"><a href="#1-添加赋予的命令" class="headerlink" title="1. 添加赋予的命令"></a>1. 添加赋予的命令</h5><p>执行 <span class="strong">visudo</span> 命令，执行该命令实际是修改<span class="tips"> /etc/sudoers </span>文件，在文件中添加格式为<span class="tips">用户名 被管理主机地址=(赋予的身份) 授权命令的绝对路径</span> 的内容，赋予组相关权限的格式类似</p><div class="show">举例：  root    ALL=(ALL)       ALL   //文件自带，给root授予的权限  wj      ALL=/sbin/shutdown -r now//用户名  被授权的主机=被授予可以使用的命令，被授权主机指被授予的命令可以在哪些主机上使用  %wheel  ALL=(ALL)       ALL   //文件自带  //若要为组添加，组名前使用%号</div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>授予命令越简单，权限越大，因此命令应该尽量详细</div><h5 id="2-查看当前用户可以使用sudo权限执行的命令"><a href="#2-查看当前用户可以使用sudo权限执行的命令" class="headerlink" title="2. 查看当前用户可以使用sudo权限执行的命令"></a>2. 查看当前用户可以使用sudo权限执行的命令</h5><p><span class="strong">sudo -l</span></p><p>执行命令后Linux系统会要求输入当前账户密码</p><h5 id="3-使用sudo权限执行命令"><a href="#3-使用sudo权限执行命令" class="headerlink" title="3. 使用sudo权限执行命令"></a>3. 使用sudo权限执行命令</h5><p><span class="strong">sudo 被授予的命令</span></p><div class="show">wj用户被授予使用shutdown -r now命令后，可以使用sudo shutdown -r now 重启系统了</div><h3 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h3><h4 id="文件系统空间"><a href="#文件系统空间" class="headerlink" title="文件系统空间"></a>文件系统空间</h4><h5 id="1-显示磁盘分区大小"><a href="#1-显示磁盘分区大小" class="headerlink" title="1.显示磁盘分区大小"></a>1.显示磁盘分区大小</h5><p><span class="strong">df [参数] [挂载点]</span></p><ul><li>-a &emsp;显示所有文件系统信息，包括特殊文件系统</li><li>-h &emsp;将磁盘大小单位换算为KB、MB等单位</li><li>-T &emsp;显示文件系统类型</li><li>-m &emsp;以MB为单位显示容量</li><li>-k &emsp;以KB为单位显示容量，默认值</li></ul><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>df命令会统计包括一些磁盘碎片在内的空间，而该类空间是被程序占用后释放的碎片空间，需要Linux整理后才能使用，因此df命令统计结果也往往比du命令统计结果大，但更能正确反映系统可用的空间大小</div><h5 id="2-显示目录或文件大小"><a href="#2-显示目录或文件大小" class="headerlink" title="2. 显示目录或文件大小"></a>2. 显示目录或文件大小</h5><p><span class="strong">du [参数] [目录或文件名]</span></p><ul><li>-a &emsp;显示每个子目文件的大小</li><li>-h &emsp;将文件大小单位换算为KB、MB等单位</li><li>-s &emsp;只统计总大小，不列出子目录和文件</li></ul><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>ls命令只统计目录下一级子文件和子目录文件信息大小，而不统计子目录下属文件大小，du命令更能准确统计出子文件、子目录和子目录所含文件的数据大小</div><h4 id="文件系统修复"><a href="#文件系统修复" class="headerlink" title="文件系统修复"></a>文件系统修复</h4><p><span class="strong">fsck [参数] 分区设备名</span></p><ul><li>-a &emsp;不显示用户提示，自动修复文件系统</li><li>-y &emsp;功能同-a，部分文件系统仅支持-y</li></ul><h4 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h4><p><span class="strong">mount [-l]</span>查询已经挂载的设备，-l显示卷标</p><p><span class="strong">mount -a</span>根据配置文件 /etc/fstab 自动挂载</p><h5 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h5><p><span class="strong">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span></p><ul><li>-t 文件系统：挂载指定文件系统，如 ext4、iso9660</li><li>-L 卷标名：自定义卷标的名字</li><li>-o 特殊选项：指定挂载的额外选项，几个常用的选项：<div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>atime/noatime</td><td>访问分区文件时是否更新文件访问时间</td></tr><tr><td>exec/noexec</td><td>是否允许文件系统中的可执行程序可以运行，默认为exec允许</td></tr><tr><td>user/nouser</td><td>是否允许普通用户挂载文件系统，默认为不允许</td></tr><tr><td>remount</td><td>重挂载已经挂载的文件系统，一般用于修改特殊权限后重挂载</td></tr></tbody></table></div></li></ul><div class="show">示例：# mount -o remount,noexec /home/禁止 /home/分区中的所有可执行程序执行，包括root用户</div><h5 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h5><div class="table"><table><thead><tr><th>硬件</th><th>设备文件名</th></tr></thead><tbody><tr><td>IDE硬盘</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/USB硬盘</td><td>/dev/sd[a-p]</td></tr><tr><td>光驱</td><td>/dev/cdrom 或 /dev/sr0</td></tr><tr><td>软盘</td><td>/dev/fd[0-1]</td></tr><tr><td>打印机(25针)</td><td>/dev/lp[0-2]</td></tr><tr><td>打印机(USB)</td><td>/dev/usb/lp[0-15]</td></tr><tr><td>鼠标</td><td>/dev/mouse</td></tr></tbody></table></div><h5 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h5><p>为方便文件查找，一般将光盘挂载于根目录下的 /media  ，U盘挂载于/mnt目录下，iso9660为光盘默认文件系统，因此-t iso9660 可以省略</p><p><span class="strong">mount -t iso9660 /dev/cdrom /media</span></p><h5 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h5><ol><li><p><span class="strong">fdisk -l</span>查看U盘设备文件名</p></li><li><p><span class="strong">mount -t &emsp;文件系统 &emsp;/dev/U盘设备文件名 &emsp;/mnt</span></p></li></ol><p>linux默认不支持NTFS文件系统(大部分移动硬盘设备使用NTFS文件系统)，但可以通过插件提供支持</p><h5 id="卸载设备"><a href="#卸载设备" class="headerlink" title="卸载设备"></a>卸载设备</h5><p><span class="strong">umount 设备文件名或挂载点目录名</span></p>]]></content>
    
    
    <summary type="html">Linux文件与目录的相关操作，包括文件系统挂载，文件查找，命令查找，文件压缩与解压，文件rwx权限、ACL权限、SetUID权限、Sticky BIT权限、charttr权限、sudo权限的修改</summary>
    
    
    
    
    <category term="File" scheme="https://shiwei11.github.io/blog/tags/File/"/>
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务与系统资源管理</title>
    <link href="https://shiwei11.github.io/blog/2022/01/20/Linux%E6%9C%8D%E5%8A%A1%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://shiwei11.github.io/blog/2022/01/20/Linux%E6%9C%8D%E5%8A%A1%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</id>
    <published>2022-01-20T04:00:00.000Z</published>
    <updated>2022-11-18T06:03:29.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><h4 id="ping-测试网络"><a href="#ping-测试网络" class="headerlink" title="ping 测试网络"></a>ping 测试网络</h4><p><span class="strong">ping [-c 次数] IP地址</span></p><ul><li>-c &emsp;指定发送次数</li></ul><p>测试网络是否联通，如果不添加-c参数，则会无终止进行ping操作，直至 ctrl+c 停止</p><h4 id="ifconfig-网卡设置"><a href="#ifconfig-网卡设置" class="headerlink" title="ifconfig 网卡设置"></a>ifconfig 网卡设置</h4><p><span class="strong">ifconfig [网卡名称] [IP地址]</span></p><p>查看和设置网卡</p>  <div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>直接使用 ifconfig 为查看网卡，不同发行版的Linux网卡标识不同，Centos7中网卡名以eth+数字标识，其中lo为回环网卡，用于本地通信与测试</div><h4 id="traceroute-查看与目标主机间的网路节点"><a href="#traceroute-查看与目标主机间的网路节点" class="headerlink" title="traceroute 查看与目标主机间的网路节点"></a>traceroute 查看与目标主机间的网路节点</h4><p><span class="strong">traceroute 网址或IP地址</span></p><p>显示当前主机与目标主机之间的所有网络节点的IP地址、延迟等信息，节点为***表示该节点信息被加密</p><h4 id="查看网络状态"><a href="#查看网络状态" class="headerlink" title="查看网络状态"></a>查看网络状态</h4><p><span class="strong">netstat [参数]</span><br>查看当前主机的网络连接状态，包括端口号、IP地址等</p><ul><li>-t &emsp;TCP协议</li><li>-u &emsp;UDP协议</li><li>-l &emsp;监听</li><li>-r &emsp;路由</li><li>-n &emsp;显示IP地址和端口号</li><li>-a &emsp;所有</li><li>-p &emsp;列出相关程序名</li></ul><p>常用</p><ul><li><span class="strong">netstat -tulnp &emsp;查看本机监听的TCP和UDP端口并列出相关程序</span></li><li><span class="strong">netstat -an &emsp;查看本机的所有网络连接</span></li><li><span class="strong">netstat -rn &emsp;查看本机所有路由表</span></li></ul><h4 id="setup-配置网络-redhat系列操作系统专有"><a href="#setup-配置网络-redhat系列操作系统专有" class="headerlink" title="setup 配置网络(redhat系列操作系统专有)"></a>setup 配置网络(redhat系列操作系统专有)</h4><p><span class="strong">setup</span><br>调出GUI界面设置IP地址、子网掩码等信息，setup是redhat开发的用于配置网络IP地址、子网掩码等网络信息的GUI工具，只有部分redhat发行的操作系统中有该工具。</p><h4 id="mount-挂载设备"><a href="#mount-挂载设备" class="headerlink" title="mount 挂载设备"></a>mount 挂载设备</h4><h5 id="1-挂载设备"><a href="#1-挂载设备" class="headerlink" title="1.挂载设备"></a>1.挂载设备</h5><p><span class="strong">mount [-t 文件系统] 设备文件名 挂载路径</span></p><p>挂载u盘、光盘等设备到Linux中，设备文件名与挂载路径一般有约定俗成的设置</p><h5 id="2-卸载设备"><a href="#2-卸载设备" class="headerlink" title="2.卸载设备"></a>2.卸载设备</h5><p><span class="strong">umount 设备文件名或挂载路径</span></p><p>卸载已经挂载的设备，类似于Windows的U盘弹出，参数使用设备文件名或挂载路径其一，不能同时使用两个参数，卸载时需要回到挂载路径的母目录中。</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><h5 id="1-write-给某个在线用户发送信息"><a href="#1-write-给某个在线用户发送信息" class="headerlink" title="1. write 给某个在线用户发送信息"></a>1. write 给某个在线用户发送信息</h5><p><span class="strong">write 用户名 信息</span></p><p>给已经登录Linux的用户发送消息，<span class="tips">Ctrl+D</span>结束输入并发送，需要用户在线，可以使用<span class="tips">w</span>查询在线的账户。</p><h5 id="2-wall-给所有在线用户发送信息-write-all"><a href="#2-wall-给所有在线用户发送信息-write-all" class="headerlink" title="2. wall 给所有在线用户发送信息(write all)"></a>2. wall 给所有在线用户发送信息(write all)</h5><p><span class="strong">wall 信息</span></p>给所有在线用户发送广播信息<h4 id="mail-发送邮件"><a href="#mail-发送邮件" class="headerlink" title="mail 发送邮件"></a>mail 发送邮件</h4><p><span class="strong">mail 用户名</span></p><p>当用户未登录无法使用上述命令发送消息时，可以发送邮件给Linux用户。</p><div class="show">邮件发送:# mail 用户名 Subject : 邮件标题  //输入邮件邮件内容           //输入邮件内容，输入完毕<span class="tips">Ctrl+D</span>发送<p>邮件接收：<br>~ mail          //查看邮件箱<br>收到的邮件将以New标识(是否已读)、序号、发送用户、发送时间、邮件标题的格式列出<br>-&gt; N 1 root                  Sun Feb 20 12:38  18/532   “test”<br>~ 1             //直接输入序号查看对应邮件<br>~ h             //列出所有邮件<br>~ d1            //d+序号删除对应邮件<br>~ q             //退出邮件查看系统</div></p><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>Linux会通过mail给root用户发送一些邮件反映服务器错误信息等</div><h4 id="last-查看用户登录系统时间与系统重启时间"><a href="#last-查看用户登录系统时间与系统重启时间" class="headerlink" title="last 查看用户登录系统时间与系统重启时间"></a>last 查看用户登录系统时间与系统重启时间</h4><p><span class="strong">last </span><br>列出目前与过去所有登入过系统的用户信息，并列出了系统何时重启过</p><p><span class="strong">lastlog </span></p>列出用户上次登录系统的时间(包括系统用户)<p><span class="strong">lastlog -u UID</span></p>仅列出指定用户上次登录系统的时间<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>Linux中的软件安装包一般分为两种：源码包和二进制包</p><p>源码包：一般是使用C语言编写但未经过编译的包，安装时需要编译，所以时间长且安装步骤多，容易报错，但方便程序员阅读和修改源码</p><p>二进制包：源码包经过编译后形成二进制包，安装简单，安装速度快，但依赖性强，需要安装其他环境。二进制包通常有两大主流的管理系统：<ul><li>RPM 包管理系统：即Red-Hat Package Manager(红帽软件包管理器)，大多数 Linux 发行版默认的包管理方式，如 Fedora、CentOS、SuSE 操作系统。</li><li>DPKG 包管理系统：为 “Debian” 专门开发的套件管理系统，主要应用在 Debian 和 Ubuntu 上</p></li></ul><p>RPM包安装的默认路径为：</p><div class="table"><table><thead><tr><th>路径</th><th>文件</th><tr></thead><tbody><tr><td>/etc/</td><td>配置文件</td></tr><tr><td>/usr/bin/</td><td>可执行命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man</td><td>帮助文件保存位置</td></tr></tbody></table></div>因此通过RPM包安装的软件，服务启动时会自动去默认路径下寻找可执行命令，红帽系列的操作系统可通过系统服务管理命令<span class="tips">service、systemctl</span>命令管理<p>源码包安装路径自定义，一般安装在<span class="tips"> /usr/local/软件名/</span>路径下</p><h4 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h4><p>由于未经过编译，源码包安装一般需要先安装gcc编译器。源码包的安装一般要经过</p><ol><li>通过tar命令解压</li><li>进入解压缩的目录下</li><li>阅读INSTALL文件，INSTALL一般为安装说明</li><li>执行<span class="strong"> ./configure</span>设置安装在默认路径下，也可以使用<span class="strong"> ./configure –prefix=/usr/local/路径</span>自定义安装路径，执行完会根据配置项生成 Makefile 文件</li><li>执行<span class="strong">make</span> 命令进行编译。如果报错，除错后执行<span class="strong">make clean</span>删除编译产生的临时文件即可。</li><li>执行<span class="strong">make install</span> 命令进行安装</li><li>源码包的卸载只需删除安装目录即可，不会遗留任何垃圾文件。</li></ol><h4 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h4><p>RPM包安装需要提前安装好软件的依赖环境</p><h5 id="RPM包"><a href="#RPM包" class="headerlink" title="RPM包"></a>RPM包</h5><p>RPM包全名类似于 httpd-2.2.3-29.el5.i386.rpm ，其命名规则为</p><ol><li>包名</li><li>版本号，格式通常为“主版本号.次版本号.修正号”</li><li>发布次数，表示RPM包是第几次编译后发布的</li><li>适合的Liunx平台，如el5表示支持RHEL 5.x/CentOS 5.x下安装</li><li>适合的硬件平台，目前RPM支持的平台有：i386、i586、i686、sparc和alpha，noarch为支持所有硬件平台。</li><li>后缀名，.rpm是编译好的二进制包，可用rpm命令直接安装；.src.rpm表示是源码包，需要编译以后才能安装<div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>在安装软件时，有些命令后使用的是包的全名，有些命令使用的是包名，二者混用会导致软件无法安装</div>rpm模块依赖查询网站：<span class="tips"> www.rpmfind.net </span></li></ol><h5 id="安装升级与卸载"><a href="#安装升级与卸载" class="headerlink" title="安装升级与卸载"></a>安装升级与卸载</h5><ol><li><span class="strong">rpm -[i或U]vh 包全名</span>&emsp;安装或升级软件</li></ol><ul><li>-i &emsp;安装(install)</li><li>-U &emsp;升级(upgrade)</li><li>-v &emsp;显示详细信息(verbose)</li><li>-h &emsp;显示进度(hash)</li><li>-&nbsp;-nodeps &emsp;不检测依赖性(通常仅用于实验测试)</li></ul><ol start="2"><li><span class="strong">rpm -e 包名</span>&emsp;卸载软件</li></ol><ul><li>-&nbsp;-nodeps &emsp;不检测依赖性</li></ul><h5 id="查询包信息"><a href="#查询包信息" class="headerlink" title="查询包信息"></a>查询包信息</h5><h6 id="1-查询是否安装了某个包"><a href="#1-查询是否安装了某个包" class="headerlink" title="1. 查询是否安装了某个包"></a>1. 查询是否安装了某个包</h6><p><span class="strong">rpm -q 包名</span></p><ul><li>-q &emsp;查询(query)</li></ul><h6 id="2-列出所有已经安装的rpm包"><a href="#2-列出所有已经安装的rpm包" class="headerlink" title="2. 列出所有已经安装的rpm包"></a>2. 列出所有已经安装的rpm包</h6><p><span class="strong">rpm -qa&emsp;</span></p><ul><li>-a &emsp;所有(all)</li></ul><h6 id="3-查询rpm包详细信息"><a href="#3-查询rpm包详细信息" class="headerlink" title="3. 查询rpm包详细信息"></a>3. 查询rpm包详细信息</h6><p><span class="strong">rpm -qi 包名</span></p><ul><li>-i &emsp;查询信息(information)</li><li>-p &emsp;添加-p查询未安装包的信息(package)，对于未安装的包，包名应为完整包名</li></ul><h6 id="4-查询包文件安装位置"><a href="#4-查询包文件安装位置" class="headerlink" title="4. 查询包文件安装位置"></a>4. 查询包文件安装位置</h6><p><span class="strong">rpm -ql 包名</span></p><ul><li>-l &emsp;列表(list)</li><li>-p &emsp;未安装包的信息(package)，包名应为完整包名</li></ul><h6 id="5-查询某个系统文件属于哪个rpm包"><a href="#5-查询某个系统文件属于哪个rpm包" class="headerlink" title="5. 查询某个系统文件属于哪个rpm包"></a>5. 查询某个系统文件属于哪个rpm包</h6><p><span class="strong">rpm -qf 文件名</span></p><ul><li>-f &emsp;系统文件(file)</li></ul><h6 id="6-查询rpm包的依赖环境"><a href="#6-查询rpm包的依赖环境" class="headerlink" title="6. 查询rpm包的依赖环境"></a>6. 查询rpm包的依赖环境</h6><p><span class="strong">rpm -qR 包名</span></p><ul><li>-R &emsp;查询包的依赖(requires)</li><li>-p &emsp;未安装包的依赖(package)，包名应为完整包名</li></ul><h5 id="包校验"><a href="#包校验" class="headerlink" title="包校验"></a>包校验</h5><p><span class="strong">rpm -V 已经安装的包名</span></p><p>校验包中的文件是否正确，会返回包的验证信息</p><h5 id="包文件提取"><a href="#包文件提取" class="headerlink" title="包文件提取"></a>包文件提取</h5><p><span class="strong">rpm2cpio 包全名 | cpio -idv 文件绝对路径</span></p><p>cpio：标准工具，用于创建档案文件和从档案文件中提取文件</p><p>rpm2cpio命令用于将rpm包转换为cpio格式</p><div class="show">示例：rpm2cpio coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls该命令可用于 /bin 目录下的 ls 目录被误删除，因而无法使用 ls 命令时，从 coreutils-8.4-19.el6.i686.rpm 包中提取 ls 目录到 bin 目录下，修复 ls 命令</div><h3 id="yum操作"><a href="#yum操作" class="headerlink" title="yum操作"></a>yum操作</h3><p>yum是一个由RedHat社区开发，基于RPM包管理的Shell前端软件包管理器，被广泛用于Fedora、RedHat以及CentOS中。yum能自动从指定的服务器下载RPM包并且安装，并自动处理依赖性关系</p><h4 id="配置网络yum源"><a href="#配置网络yum源" class="headerlink" title="配置网络yum源"></a>配置网络yum源</h4><p>网络yum源的配置文件路径为<span class="tips"> /etc/yum.repos.d/CentOS-Base.repo </span>，配置信息类似于：</p><div class="shell">[base]name=CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</div><p>配置信息中各项配置解析：</p><ul><li>[base] &emsp;容器名称，放在[]中</li><li>name &emsp;容器说明，自由写</li><li>mirrorlist &emsp;镜像站点</li><li>baseurl &emsp;yum源服务器地址，默认为CentOS官方地址，国内可使用阿里云镜像地址</li><li>enabled &emsp;该容器是否失效，enable=0为不生效，enable=1为生效但会略写。</li><li>gpgcheck &emsp;为1则RPM的数字证书失效，0为不生效</li><li>gpgkey &emsp;数字证书公钥文件保存位置</li></ul><h4 id="yum安装软件"><a href="#yum安装软件" class="headerlink" title="yum安装软件"></a>yum安装软件</h4><p>yum命令中的包名不需要包的全名</p><h5 id="查询包"><a href="#查询包" class="headerlink" title="查询包"></a>查询包</h5><p><span class="strong">yum list &emsp;列出所有可用的软件包</span></p><p><span class="strong">yum search 关键字&emsp;搜索服务器上所有和关键字相关的包</span></p><h5 id="安装与升级"><a href="#安装与升级" class="headerlink" title="安装与升级"></a>安装与升级</h5><p><span class="strong">yum -y install 包名</span></p><ul><li>-y &emsp;对询问自动回答yes</li></ul><h5 id="升级、卸载"><a href="#升级、卸载" class="headerlink" title="升级、卸载"></a>升级、卸载</h5><ul><li>yum -y update 包名</li><li>yum -y remove 包名</li></ul><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>升级时必须写包名，否则会升级所有包，包括Linux内核，会直接导致服务器崩溃。而卸载时会卸载包和包的所有依赖，但依赖可能还是其他包的依赖，因此可能导致其他软件功能失效，因此这两条命令慎用</div><h4 id="yum安装软件包组"><a href="#yum安装软件包组" class="headerlink" title="yum安装软件包组"></a>yum安装软件包组</h4><ul><li><span class="strong">yum grouplist &emsp;列出所有可用软件组</span></li><li><span class="strong">yum groupinstall 软件组名&emsp;安装软件组</span></li><li><span class="strong">yum groupremove 软件组名&emsp;卸载软件组</span></li></ul><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>通过源码包安装的程序，所有文件会统一放置于如 /usr/local/ 目录下，而通过RPM包安装的程序，不同文件会放在不同目录下，如：可执行命令文件放在 /usr/bin 目录下，配置文件放在 /etc目录下。通过RPM包安装的软件服务，可以通过脚本文件启动，也可以通过service或systemctl命令直接启动，当执行该命令时，Linux会默认前往/usr/bin 目录下寻找相关文件。而通过源码包安装的服务由于安装路径不同，就无法通过该命令直接启动，但也可以将启动命令文件生成链接放置在/usr/bin目录下，这样源码包安装的服务也可以通过该命令启动了。</p><p>卸载软件时，通过源码包安装的程序直接删除对应文件即可，而通过RPM包安装的软件，由于文件散列分布，因此需要rpm -e 命令来卸载。</p><h4 id="服务查询"><a href="#服务查询" class="headerlink" title="服务查询"></a>服务查询</h4><p>查询服务开机自启动状态</p><h5 id="1-RPM包安装的应用服务"><a href="#1-RPM包安装的应用服务" class="headerlink" title="1. RPM包安装的应用服务"></a>1. RPM包安装的应用服务</h5><p><span class="strong">chkconfig -&zwnj;-list</span></p><p>查询所有RPM包安装的应用服务启动状态，会标出int0-6哪个级别系统启动状态下，服务会自启动。通过管道符可以查询指定服务的启动状态，如: chkconfig | grep nginx查看nginx服务的启动状态，在Centos7以后，该命令只能查看应用服务自启动情况，不包括系统本地服务，查看本地服务可以使用<span class="strong">systemctl list-unit-files</span>命令，使用管道符可以只查看指定服务的启动状况。</p><h5 id="2-源码包安装的服务"><a href="#2-源码包安装的服务" class="headerlink" title="2. 源码包安装的服务"></a>2. 源码包安装的服务</h5><p>查看安装位置下对应服务的配置文件，一般位于<span class="tips"> /usr/local/</span>路径下。</p><h4 id="RPM服务管理"><a href="#RPM服务管理" class="headerlink" title="RPM服务管理"></a>RPM服务管理</h4><h5 id="独立服务管理"><a href="#独立服务管理" class="headerlink" title="独立服务管理"></a>独立服务管理</h5><p>常用文件路径</p><div class="table"><table><thead><tr><th align="center">路径</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/etc/init.d</td><td align="center">启动脚本位置</td></tr><tr><td align="center">/etc/xinetd.d</td><td align="center">基于xinetd 服务的启动脚本</td></tr><tr><td align="center">/etc/sysconfig</td><td align="center">初始化环境配置文件</td></tr><tr><td align="center">/etc</td><td align="center">配置文件位置</td></tr><tr><td align="center">/etc/xinetd.conf</td><td align="center">xinetd 配置文件</td></tr><tr><td align="center">/var/lib</td><td align="center">放置服务产生的数据</td></tr><tr><td align="center">/var/log</td><td align="center">日志</td></tr></tbody></table></div><h5 id="独立服务命令"><a href="#独立服务命令" class="headerlink" title="独立服务命令"></a>独立服务命令</h5><ul><li><p><span class="strong">/etc/init.d/服务名&emsp;start/stop/status/restart </span></p></li><li><p><span class="strong">service/systemctl&emsp;服务名&emsp;start/stop/status/restart </span>&emsp;红帽系列系统专属</p></li></ul><h5 id="独立服务自启动"><a href="#独立服务自启动" class="headerlink" title="独立服务自启动"></a>独立服务自启动</h5><ul><li>将启动程序的命令写入<span class="tips"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令</li><li>chkconfig 服务名 on/off &emsp;开启、关闭自启动，默认在2345运行级别下自启动</li></ul><h5 id="基于xinetd-超级守护进程-服务"><a href="#基于xinetd-超级守护进程-服务" class="headerlink" title="基于xinetd(超级守护进程)服务"></a>基于xinetd(超级守护进程)服务</h5><p>xinetd负责管理系统中不频繁使用的服务，这些服务程序在有请求时才由xinetd服务负责启动运行，一旦完成服务请求服务程序结束运行，以减少对系统资源的占用。</p><p>基于 xinetd 的服务没有自己独立的启动脚本程序，需要依赖 xinetd 的启动脚本来启动。xinetd 本身是独立的服务，启动xinetd 服务的方法和启动独立服务的方法一致。</p><p>基于 xinetd 的服务只需修改 <span class="tips"> /etc/xinetd.d/服务名 </span> 文件下的 <span class="tips"> /disable</span>为 <span class="tips"> no</span>，然后重启xinetd 服务即可</p><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>xinetd常用于红帽系列的操作系统，需要用户自行安装</div><h4 id="源码包安装的服务管理"><a href="#源码包安装的服务管理" class="headerlink" title="源码包安装的服务管理"></a>源码包安装的服务管理</h4><h5 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h5><p>源码包安装的服务一般通过绝对路径下的脚本启动，具体路径需查看安装说明INSTALL文件。</p><h5 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h5><p>将启动程序的命令写入<span class="tips"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令</p><h4 id="查看开机时服务启动顺序"><a href="#查看开机时服务启动顺序" class="headerlink" title="查看开机时服务启动顺序"></a>查看开机时服务启动顺序</h4><p>Linux开机或关机时的服务启动/关闭顺序写于文件<span class="tips"> /etc/rc.d/</span>路径下的对应文件中， <span class="tips"> rc0-rc6 </span>文件中分别书写有系统不同启动级别下服务启动顺序。如 rc3 中，S85nginx表示系统启动时，nginx将是第85个启动的服务，K15nginx表示系统关机时，nginx将是第15个关闭的服务。</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><ol><li><span class="strong">ps aux</span>&emsp;使用BSD(unix)标准格式显示进程</li></ol><ul><li>a &emsp;显示所有前台进程</li><li>x &emsp;显示所有后台进程</li><li>u &emsp;显示进程由哪个用户产生</li></ul><div class="show">BSD格式的进程信息：USER：该进程由哪个用户产生PID：进程的ID号%CPU：进程占用的CPU百分比%MEM：进程占用的物理内存百分比VSZ：进程占用的虚拟内存，单位为KBRSS：进程占用的物理内存大小，单位为KBTTY：进程在哪个终端运行，？为由Linux系统运行，tty1-tty6为本地字符界面终端，tty7为图形终端，pts/0-255为远程登录虚拟终端STAT：进程状态，常见的状态字符有：R运行(runnable)，S睡眠(sleeping)，s包含子进程，+位于后台的进程组，T停止，&lt;优先级高的进程，N优先级低的进程，l多线程，Z僵尸进程，D无法中断的休眠进程(通常为IO进程)START：进程启动时间TIME：进程占用CPU时间COMMAND：产生进程的命令名</div>2. <span class="strong">ps -le</span>&emsp;使用Linux标准格式显示进程<ul><li>-l &emsp;显示详细信息</li><li>-e &emsp;显示所有进程</li><li>-C命令&emsp;显示指定命令的状态</li></ul><div class="show">Linux格式的进程信息：UID：产生进程的用户IDPID：进程的ID号PPID：父进程IDC：进程占用CPU百分比STIME：进程启动时间TTY：进程在哪个终端运行，参数同上CMD：产生进程的命令名</div><h4 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h4><p><span class="strong">pstree [选项]</span></p><ul><li>-p &emsp;显示进程PID</li><li>-u &emsp;显示进程所属用户</li></ul><h4 id="查看进程调用的文件"><a href="#查看进程调用的文件" class="headerlink" title="查看进程调用的文件"></a>查看进程调用的文件</h4><p><span class="strong">lsof [参数]</span></p><ul><li>-c 字符串 &emsp;只列出以字符串开头的进程打开的文件</li><li>-u 用户名 &emsp;只列出某个用户所启动进程打开的文件</li><li>-p pid   &emsp;只列出某个PID进程打开的文件</li></ul><h4 id="监控系统资源占用状态"><a href="#监控系统资源占用状态" class="headerlink" title="监控系统资源占用状态"></a>监控系统资源占用状态</h4><p><span class="strong">top [参数]</span></p><ul><li>-d 秒数 &emsp;指定每几秒更新系统状态，默认是3秒</li></ul><p>显示当前系统的内存、CPU占用情况，显示状态下通过下列按键进行交互</p><ul><li>?或h &emsp;显示交互帮助</li><li>P &emsp; 根据CPU占用率显示进程顺序，默认</li><li>M &emsp; 根据内存占用率显示进程顺序</li><li>N &emsp; 根据PID显示进程顺序</li><li>q &emsp; 退出top监控</li></ul><div class="shell">系统资源显示信息：top - 15:40:11 up 41 days, 15:45,  2 users,  load average: 0.04, 0.05, 0.01Tasks:  78 total,   1 running,  45 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :   492280 total,    15964 free,    74408 used,   401908 buff/cacheKiB Swap:        0 total,        0 free,        0 used.   375944 avail Mem<p>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND<br>  1 root      20   0   51704   4948   3660 S  0.0  1.0  10:45.34 systemd</p></div><div class="table" style="text-align:left;"><table><thead><tr><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">15:40:11</td><td align="left">系统当前时间</td></tr><tr><td align="left">up 41 days,15:45</td><td align="left">系统运行时间，已运行41天15小时45分</td></tr><tr><td align="left">2 users</td><td align="left">当前登录用户数量</td></tr><tr><td align="left">load average: 0.04, 0.05, 0.01</td><td align="left">系统在1分钟、5分钟、15分钟前的平均负载，根据主机内核数量判断负荷情况，如 8核，超过8表明已超负荷运行</td></tr><tr><td align="left">Tasks</td><td align="left">Tasks后分别为 系统中的总进程数、正在运行的进程、睡眠进程、停止的进程、僵尸进程</td></tr><tr><td align="left">%Cpu(s)</td><td align="left">us为CPU被用户占用的比率，sy为系统占用比例，ni为修改过优先级的用户进程CPU占用比率，id为CPU空闲的比率，wa为等待输入、输出的进程占用CPU的比率，hi为硬中断请求服务占用CPU比率，si为软中断请求服务占用CPU比率，st为有虚拟机时，虚拟CPU等待实际CPU的时间百分比</td></tr><tr><td align="left">Mem</td><td align="left">物理内存总大小、空闲内存大小、使用内存大小、正在缓冲的内存大小</td></tr><tr><td align="left">Swap</td><td align="left">交换分区总大小、空闲部分、使用部分、有效大小</td></tr></tbody></table></div><h4 id="按指定次数监控系统资源"><a href="#按指定次数监控系统资源" class="headerlink" title="按指定次数监控系统资源"></a>按指定次数监控系统资源</h4><p><span class="strong">vmstat 刷新延迟 监听次数</span></p><p>输出进程数、内存状态、交换分区状况、硬盘输入输出状况、CPU状态</p><div class="show"># vmstat 3 4每3秒监听一次系统资源，输出4次</div><h4 id="查看开机时检测的系统内核信息"><a href="#查看开机时检测的系统内核信息" class="headerlink" title="查看开机时检测的系统内核信息"></a>查看开机时检测的系统内核信息</h4><p><span class="strong">dmesg</span></p><p>会输出非常详细的CPU(如型号、主频、核心数….)、网卡、硬盘等主机开机检测的信息，一般通过管道符只查看某部分具体信息，如: dmesg | grep CPU 查看CPU详细信息</p><h5 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h5><p>开机检测后，检测到的信息会按格式写于<span class="tips">/proc/cpuinfo</span>文件中，通过该文件查看CPU信息更为清晰</p><h4 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h4><p><span class="strong">free [参数]</span></p><ul><li>-b &emsp;以字节单位显示内存大小</li><li>-k &emsp;以KB单位显示内存大小(默认)</li><li>-m &emsp;以MB单位显示内存大小</li><li>-g &emsp;以GB单位显示内存大小</li></ul><h4 id="查看操作系统内核"><a href="#查看操作系统内核" class="headerlink" title="查看操作系统内核"></a>查看操作系统内核</h4><p><span class="strong">uname [选项]</span></p><ul><li>-a &emsp;查看系统所有信息</li><li>-r &emsp;查看内核版本</li><li>-s &emsp;查看内核名称</li><li>-m &emsp;查看内核架构、操作系统位数</li></ul><p>通过查看文件系统的位数，也可以查看操作系统位数，如执行 <span class="tips">file /bin/ls</span>，其中/bin/ls可以为任意外部命令</p><h4 id="查看当前Linux操作系统的发行版本"><a href="#查看当前Linux操作系统的发行版本" class="headerlink" title="查看当前Linux操作系统的发行版本"></a>查看当前Linux操作系统的发行版本</h4><p>使用cat命令查看 <span class="tips">/etc/system-release</span>或 <span class="tips">/etc/redhat-release(红帽专属)</span>文件即可</p><h4 id="中止进程"><a href="#中止进程" class="headerlink" title="中止进程"></a>中止进程</h4><h5 id="系统的中止信号"><a href="#系统的中止信号" class="headerlink" title="系统的中止信号"></a>系统的中止信号</h5><p><span class="strong">kill -l</span>查询可用的进程信号<br>常用的进程信号</p><div class="table"><table><thead><tr><th>代号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>该信号用于让进程重新读取配置文件后重启</td></tr><tr><td>2</td><td>SIGINT</td><td>中止前台进程，相当于ctrl+C</td></tr><tr><td>9</td><td>SIGKILL</td><td>该信号用于强制中止进程</td></tr><tr><td>15</td><td>SIGTERM</td><td>正常中止进程，kill命令的默认信号</td></tr><tr><td>18</td><td>SIGCONT</td><td>让一个暂停的进程继续执行</td></tr><tr><td>19</td><td>SIGSTOP</td><td>暂停进程的执行</td></tr></tbody></table></div><h5 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h5><p><span class="strong">kill [信号代号] [进程PID]</span></p><p>根据进程PID中止进程</p><ul><li>kill -15 PID &emsp;中止进程(默认，-15可省略)</li><li>kill -1 PID &emsp;重新载入配置文件后重启</li><li>kill -9 PID &emsp;强制中止进程</li></ul><h5 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h5><p><span class="strong">kill [参数][信号代号] [进程名]</span></p><p>根据进程名中止进程</p><ul><li>-i &emsp;询问是否杀死某进程</li><li>-I &emsp;忽略进程名大小写</li></ul><h5 id="pkill命令"><a href="#pkill命令" class="headerlink" title="pkill命令"></a>pkill命令</h5><p><span class="strong">pkill [参数][信号代号] [进程名]</span></p><ul><li>-t 终端号 &emsp;按终端号关闭用户的连接(踢出用户)</li></ul><div class="show"># pkill -9 -t tty1关闭终端号为 tty1 用户的连接</div><h3 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h3><h4 id="将程序转入后台运行-暂停"><a href="#将程序转入后台运行-暂停" class="headerlink" title="将程序转入后台运行/暂停"></a>将程序转入后台运行/暂停</h4><p><span class="strong">在命令后添加 <span class="tips"> &amp; </span>，可使该命令在后台执行</span></p><div class="show">如：# tar -zxf test.tar.gz &在后台解压缩 test.tar.gz文件，执行完会提示Done</div><p><span class="strong">在命令运行时执行<span class="tips"> Ctrl + Z </span> 是将当前工作暂停后转入后台</span></p><div class="show">如：# top执行Ctrl + Z会将监视系统资源的top程序设为stopped(暂停)状态后转入后台</div><h4 id="查看后台的工作"><a href="#查看后台的工作" class="headerlink" title="查看后台的工作"></a>查看后台的工作</h4><p><span class="strong"> jobs [-l]</span></p><ul><li>-l &emsp;显示工作的PID</li></ul><div class="shell">[1]   Stopped                 top[2]-  Stopped                 top[3]+  Stopped                 top</div><p>[3]代表工作序号，“+”号代表最后一个放入后台的工作，“-”号代表倒数第二个放入后台的工作，恢复时默认使用出栈方式从最后一个放入后台的工作开始恢复</p><h4 id="将后台暂停的工作恢复到前台执行"><a href="#将后台暂停的工作恢复到前台执行" class="headerlink" title="将后台暂停的工作恢复到前台执行"></a>将后台暂停的工作恢复到前台执行</h4><p><span class="strong"> fg [%工作序号]</span></p><ul><li>%可省略，如果不添加工作序号，则默认从后放入的工作开始恢复</li></ul><h4 id="将后台暂停的工作恢复到后台执行"><a href="#将后台暂停的工作恢复到后台执行" class="headerlink" title="将后台暂停的工作恢复到后台执行"></a>将后台暂停的工作恢复到后台执行</h4><p><span class="strong"> bg [%工作序号]</span></p><ul><li>%可省略，如果不添加工作序号，则默认从后放入的工作开始恢复</li></ul><div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>top，vi等服务于前台的命令，不能恢复到后台执行。</div><h3 id="alternatives工具"><a href="#alternatives工具" class="headerlink" title="alternatives工具"></a>alternatives工具</h3><h4 id="alternatives简介"><a href="#alternatives简介" class="headerlink" title="alternatives简介"></a>alternatives简介</h4><p>alternatives工具常用于指定默认软件、默认配置，或者某一软件的默认版本。</p><p>如：在Linux中，yum等工具一般使用python2作为命令解释器，而一些较新的软件依赖较新版的python3。因此有时我们不得不同时安装python2和python3。如果使用 python3 作为默认的python版本，使用yum会抛出错误，这是因为使用了python3解析yum中python2的语法，同理，一些较新的软件也无法使用python2解析。此时，我们就需要使用alternatives来控制软件的默认版本。</p><p>alternatives的使用方法是：给定两个软件或多个软件的路径，然后将它们注册为一个组，为这个组建立一个软链接，之后调用软件将直接从这一软链接调用</p><h4 id="alternatives命令"><a href="#alternatives命令" class="headerlink" title="alternatives命令"></a>alternatives命令</h4><h5 id="注册组"><a href="#注册组" class="headerlink" title="注册组"></a>注册组</h5><p><span class="strong">alternatives -&zwnj;-install &lt;link&gt; &lt;name&gt; &lt;path&gt; &lt;priority&gt;</span></p><ul><li>-&zwnj;-install 注册(新增)需要管理的命令/软件</li><li>link：注册路径，会在该路径下生成一个软链，此后由该软链启动命令</li><li>name：组名</li><li>path：软件/命令的路径，将该路径下的命令加入alternatives管理组</li><li>priority：权值，在自动模式下，权值越高，软件优先级越高</li></ul><h5 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h5><ul><li><span class="strong">alternatives -&zwnj;-config &lt;name&gt;</span> 修改默认配置(将进入交互模式，并切换为手动模式)</li><li><span class="strong">alternatives -&zwnj;-set &lt;name&gt; &lt;path&gt;</span> 修改默认配置(将切换为手动模式)</li><li><span class="strong">alternatives -&zwnj;-auto &lt;name&gt;</span> 切换为自动模式</li><li><span class="strong">alternatives -&zwnj;-display &lt;name&gt;</span> 显示对应组的配置信息(包括自动/手动模式，路径，权值)</li><li><span class="strong">alternatives -&zwnj;-remove &lt;name&gt; &lt;path&gt;</span> 删除组中对应路径的软件</li><li><span class="strong">alternatives -&zwnj;-list</span> 列出所有组的信息(组名、自动/手动模式、当前默认软件路径)</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="1-注册组"><a href="#1-注册组" class="headerlink" title="1. 注册组"></a>1. 注册组</h5><p>在<span class="tips">/usr/bin</span>目录下有python2.7与python3.7的启动命令，我们可以新建python组，将python2和python3的启动路径加入到该组中，并指定python3为默认版本，此后直接执行<span class="tips">python</span>命令将唤醒python3，而不用再指定明确的版本号，且将默认唤醒python3，该默认值是可以随时更改的</p><div class="shell"><code># alternatives --install /usr/bin/python python /usr/bin/python2.7 10# alternatives --install /usr/bin/python python /usr/bin/python3.6 20</code></div><p>上述命令</p><ul><li>将在 <span class="tips">/usr/bin</span> 目录下新建名为 <span class="tips">python</span> 的软链接，该软链接指向<span class="tips">/etc/alternatives/python</span>，该链接又指向<span class="tips">/usr/bin/python3.6</span></li></ul><div class="show">即 /usr/bin/python --> /etc/alternatives/python --> /usr/bin/python3.6</div><ul><li>修改默认值，修改的是/etc/alternatives/python的指向，即默认值为python2.7时，/etc/alternatives/python链接指向将修改为/usr/bin/python2.7</li><li>python3.6的权值为20，python2.7的权值为10，自动模式下，alternatives将优先调用python3.6</li><li>生成链接名可以任意自定义，并且调用命令也将相应修改，如：<div class="shell"><code>alternatives --install /usr/bin/py ppyy /usr/bin/python3 10</code></div>调用命令将变为py:<div class="shell">py --version #同python3 --version命令</div></li></ul><h6 id="2-修改默认值"><a href="#2-修改默认值" class="headerlink" title="2. 修改默认值"></a>2. 修改默认值</h6><div class="shell"><code>alternatives --config python</code></div>将进入交互模式，让你输入序号选择版本<div class="shell">There are 2 programs which provide 'python'.  Selection    Command-----------------------------------------------   1           /usr/bin/python2.7*+ 2           /usr/bin/python3.6<p>Enter to keep the current selection[+], or type selection number: </p></div><p>+号为当前生效的版本，*为新增版本</p><h6 id="3-查看python组信息"><a href="#3-查看python组信息" class="headerlink" title="3. 查看python组信息"></a>3. 查看python组信息</h6><div class="shell"><code>alternatives --display python</code></div><div class="shell">python - status is manual. #python处于手动模式 link currently points to /usr/bin/python3.6 #当前默认使用python3.6版本/usr/bin/python2.7 - priority 10  #可选版本信息/usr/bin/python3.6 - priority 20Current `best' version is /usr/bin/python3.6.</div><h6 id="4-从组中删除python3-6版本"><a href="#4-从组中删除python3-6版本" class="headerlink" title="4. 从组中删除python3.6版本"></a>4. 从组中删除python3.6版本</h6><div class="shell"><code>alternatives --remove python /usr/bin/python3.6</code></div>从python组中移除3.6版本，将只剩2.7版本可选<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h4><p>cron即计划任务，而crond则是一个常驻服务，在Linux中用于周期性执行某个任务，该服务的配置文件位于<span class="tips">/etc/crontab</span></p><h5 id="查看crond服务运行情况"><a href="#查看crond服务运行情况" class="headerlink" title="查看crond服务运行情况"></a>查看crond服务运行情况</h5><p><span class="strong">ps aux | grep crond</span>查看crond进程是否在运行，红帽系列的操作系统可使用<span class="strong">service status crond</span>或<span class="strong">systemctl status crond</span>(centos7+)</p><h5 id="查看crond服务是否开机自启动"><a href="#查看crond服务是否开机自启动" class="headerlink" title="查看crond服务是否开机自启动"></a>查看crond服务是否开机自启动</h5><p><span class="strong">chkconfig -&zwnj;-list | grep crond</span>或<span class="strong">systemctl list-unit-files | grep crond</span>(centos7+)</p><h4 id="设置crond定时任务"><a href="#设置crond定时任务" class="headerlink" title="设置crond定时任务"></a>设置crond定时任务</h4><p>可通过修改<span class="tips">/etc/crontab</span>文件来设置定时任务，同路径下还有 cron.daily，cron.weekly等对应时间记录crond任务的文件。也可以通过命令来修改crontab文件，语法为:</p><p><span class="strong">crontab [参数]</span></p><ul><li>-e &emsp;编辑crontab定时任务</li><li>-l &emsp;查询crontab定时任务</li><li>-r &emsp;删除当前用户所有crontab任务</li></ul><h5 id="cron语法"><a href="#cron语法" class="headerlink" title="cron语法"></a>cron语法</h5><p>编辑定时任务时会打开vi编辑器，编辑语法格式需遵循cron语法，基本格式为：<span class="tips"><strong>***** 命令</strong></span></p><ul><li><span class="strong">第一个*表示一小时当中的第几分钟，范围为0-59</span></li><li><span class="strong">第二个*表示一天当中的第几个小时，范围为0-23</span></li><li><span class="strong">第三个*表示一个月当中的第几天，范围为1-31</span></li><li><span class="strong">第四个*表示一年当中的第几个月，范围为1-12</span></li><li><span class="strong">第五个*表示一周当中的星期几，范围为0-7(0和7都代表星期日)</span></li></ul><div class="table"><table><thead><tr><th align="left">特殊符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">代表任何时间</td></tr><tr><td align="left">,</td><td align="left">代表不连续的时间</td></tr><tr><td align="left">-</td><td align="left">代表连续的时间范围</td></tr><tr><td align="left">*/n</td><td align="left">代表隔多久执行一次</td></tr></tbody></table></div><div class="show">示例：30 23 * * * 命令      //每天的23：30执行对应命令0 1 1,15 * * 命令    //每个月1号和15号凌晨1:00执行命令30 2 * * 1-3 命令   // 每周一到周三凌晨2点30执行命令*/10 4 * * * 命令   //每天凌晨4点，每隔10分钟执行一次命令，执行6次(即小时数超过4时就停止)0 0 1,15 * 1 命令   //每个月1号，15号和每周一凌晨00:00执行一次命令0 2 1 * * /sbin/shutdown -r now 每个月1号凌晨2：00重启Linux</div><h3 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h3><h4 id="rsyslog服务"><a href="#rsyslog服务" class="headerlink" title="rsyslog服务"></a>rsyslog服务</h4><p>Syslog(系统日志协议)是在一个IP网络中转发系统日志信息的标准，syslogd服务被广泛用于老版Unix/Linux系统中负责记录系统日志，RSyslog是syslog的多线程增强版，CentOS6以后系统默认使用Rsyslogd服务记录系统日志。</p><h5 id="查询rsyslog服务是否在运行"><a href="#查询rsyslog服务是否在运行" class="headerlink" title="查询rsyslog服务是否在运行"></a>查询rsyslog服务是否在运行</h5><p>可使用命令<span class="strong">ps aux | grep rsyslogd</span>查看rsyslog进程是否在运行，红帽系列可使用命令<span class="strong">systemctl status rsyslog</span>查看</p><h5 id="查看rsyslog服务是否开机自启动"><a href="#查看rsyslog服务是否开机自启动" class="headerlink" title="查看rsyslog服务是否开机自启动"></a>查看rsyslog服务是否开机自启动</h5><ul><li><span class="strong">chkconfig –list |grep rsyslog</span></li><li><span class="strong">systemctl list-unit-files | grep rsyslog</span>(centos7)</li></ul><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>系统日志默认保存在 <span class="tips">/var/log</span> 路径下，对应文件的作用:</p><div class="table"><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>/var/log/cron</td><td>定时任务相关日志</td></tr><tr><td>/var/log/cups</td><td>打印系统的日志</td></tr><tr><td>/var/log/dmesg</td><td>开机内核自检的信息，使用dmesg命令就是读取了该文件</td></tr><tr><td>/var/log/btmp</td><td>错误登录日志，二进制文件，需通过<span class="tips">lastb</span>命令查看</td></tr><tr><td>/var/log/lastlog</td><td>记录所有用户最后一次登录系统的日志，二进制文件，需通过<span class="tips">lastlog</span>命令查看</td></tr><tr><td>/var/log/mailog</td><td>邮件日志</td></tr><tr><td>/var/log/message</td><td>记录系统所有重要事件信息</td></tr><tr><td>/var/log/secure</td><td>记录所有涉及用户账户和密码的信息，如：用户登录，添加用户，切换用户，sudo授权，修改密码等</td></tr><tr><td>/var/log/wtmp</td><td>永久记录所有用户的登录、注销、系统启动、重启等信息，二进制文件，需使用<span class="tips">last</span>命令查看</td></tr><tr><td>/var/log/utmp</td><td>记录当前登录的用户信息，并且随着用户注销、切换不断变化，使用w,who,users等命令查看</td></tr></tbody></table></div><p>使用RPM包安装的服务也会默认把日志文件放在<span class="tips">/vat/log/服务名</span> 路径下，但其日志由自身服务管理，而不归rsyslogd服务管理</p><p>使用源码包安装服务的日志文件位于用户指定的安装路径下，一般位于 /usr/local路径下</p><h4 id="rsyslog日志格式"><a href="#rsyslog日志格式" class="headerlink" title="rsyslog日志格式"></a>rsyslog日志格式</h4><p>日志文件通常由以下内容按顺序书写：</p><ul><li>事件产生时间</li><li>服务器主机名</li><li>产生事件的服务名</li><li>事件的具体信息</li></ul><h4 id="rsyslog日志配置文件"><a href="#rsyslog日志配置文件" class="headerlink" title="rsyslog日志配置文件"></a>rsyslog日志配置文件</h4><p>该配置文件位于<span class="tips">/etc/rsyslog.conf</span>，配置文件决定了日志系统记录哪些级别的日志信息，文件的格式为 <span class="tips"><strong>服务名[连接符]日志等级&emsp;&emsp;日志记录位置</strong></span></p><h5 id="服务名"><a href="#服务名" class="headerlink" title="服务名"></a>服务名</h5><div class="table"><table><thead><tr><th>服务名称</th><th>说明</th></tr></thead><tbody><tr><td>auth</td><td>安全和认证相关信息</td></tr><tr><td>authpriv</td><td>安全和认证相关信息(私有信息)</td></tr><tr><td>cron</td><td>系统定时任务cront和At产生的日志</td></tr><tr><td>daemon</td><td>守护进程相关的日志</td></tr><tr><td>ftp</td><td>ftp守护进程相关日志</td></tr><tr><td>kern</td><td>内核产生的日志</td></tr><tr><td>local0-local7</td><td>为本地预留的服务项</td></tr><tr><td>lpr</td><td>打印系统产生的日志</td></tr><tr><td>mail</td><td>邮件日志</td></tr><tr><td>news</td><td>新闻服务器相关日志</td></tr><tr><td>syslog</td><td>rsyslog服务产生的日志</td></tr><tr><td>user</td><td>用户等级类别产生的日志</td></tr><tr><td>uucp</td><td>uucp(数据传输协议)子系统的日志</td></tr></tbody></table></div><h5 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h5><div class="table"><table><thead><tr><th>连接符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>表示比后面所写等级高(包含该等级)的日志都记录下来</td></tr><tr><td>.=</td><td>只记录指定等级的日志</td></tr><tr><td>.!</td><td>除了该等级，其余等级都记录</td></tr></tbody></table></div><h5 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h5><div class="table"><table><thead><tr><th>等级</th><th>说明</th></tr></thead><tbody><tr><td><strong>*</strong></td><td>所有等级</td></tr><tr><td>none</td><td>与*相反，不记录任何日志</td></tr><tr><td>debug</td><td>调试信息</td></tr><tr><td>info</td><td>通知信息，反馈系统状态</td></tr><tr><td>notice</td><td>提醒信息，程序可能存在潜在错误，但不影响运行</td></tr><tr><td>warning</td><td>警告信息，程序发现错误，暂且不影响运行</td></tr><tr><td>err</td><td>错误信息，服务出错停止运行，需要修复</td></tr><tr><td>crit</td><td>临界状态信息，服务宕机，且可能无法修复</td></tr><tr><td>alert</td><td>警报信息，服务宕机，影响系统运行</td></tr><tr><td>emerg</td><td>紧急信息，系统疼痛等级，系统濒临崩溃甚至已经崩溃</td></tr></tbody></table></div><h5 id="日志记录位置"><a href="#日志记录位置" class="headerlink" title="日志记录位置"></a>日志记录位置</h5><p>日志记录位置可以是以下值:</p><ul><li>路径，写于本机指定位置，如:/var/log/lastlog</li><li>系统设备，写于U盘或者通过打印机打印日志，如:/dev/lp0</li><li>转发到远程主机或日志服务器，如:@192.168.0.100:514</li><li>用户名，发送给指定用户，如:root</li><li>忽略或丢弃日志，如：~ ，直接丢弃</li></ul><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>以下示例来源于centos7系统默认配置</p><div class="shell">cron.*                                                  /var/log/cron所有等级的cron日志写于/var/log/cron文件中*.emerg                                                 :omusrmsg:*出现疼痛等级的日志时，发送给所有用户*.info;mail.none;authpriv.none;cron.none                /var/log/messages不记录任何私人身份验证消息uucp,news.crit                                          /var/log/spooler将uucp,news服务crit和更高级别的日志信息保存在指定文件中</div><h4 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h4><p>日志轮替用于用新日志覆盖旧日志，其配置文件位于<span class="tips">/etc/logrotate.conf</span>，需要相关功能只需在配置文件中添加对应参数就即可。</p><div class="table"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daily/weekly/monthly</td><td>日志轮替周期</td></tr><tr><td>rotate 数字</td><td>保留日志文件的个数，0为不备份</td></tr><tr><td>compress</td><td>日志轮替时，对旧日志进行压缩</td></tr><tr><td>create 权限值 所有者 所属组</td><td>建立新日志，并指定日志文件的权限、所有者、所属组</td></tr><tr><td>mail address</td><td>日志轮替时，日志内容发送到指定邮箱，如:mail <a href="mailto:&#x31;&#x31;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#x31;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a></td></tr><tr><td>missingok</td><td>日志不存在时，忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志文件为空，则不进行轮替</td></tr><tr><td>maxsize 大小</td><td>当日志文件到达指定大小，无论是否到轮替时间，都进行一次轮替，未到达指定大小但到达轮替周期，也进行轮替</td></tr><tr><td>minsize 大小</td><td>到达轮替时间时，如果日志文件达到该最小值时就进行轮替，否则不进行轮替</td></tr><tr><td>size 大小</td><td>时间周期设置无效，只有当日志文件大于指定大小才进行轮替</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件名</td></tr></tbody></table></div><div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div><span class="tips">dateext</span>参数用于指定当前日期作为日志文件后缀名，如:secure-20210211。如果配置文件中没有该参数，则日志文件将以.1，.2作为文件名名后缀。如：当前日志文件为secure，进行轮替后该文件改名为secure.1，secure.1改为secure.2，而将新的日志文件命名为secure。</div><h5 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h5><p>通过RPM包安装的服务其日志会被自动识别配置轮替，通过源码包安装的服务需要自行添加配置，配置格式同本地配置的基本格式。</p><div class="shell"># see "man logrotate" for details# rotate log files weeklyweekly<p># keep 4 weeks worth of backlogs<br>rotate 4</p><p># create new (empty) log files after rotating old ones<br>create</p><p># use date as a suffix of the rotated file<br>dateext</p><p># uncomment this if you want your log files compressed<br>#compress</p><p># RPM packages drop log rotation information into this directory<br>include /etc/logrotate.d</p><p># no packages own wtmp and btmp – we’ll rotate them here<br>/var/log/wtmp {<br>    monthly<br>    create 0664 root utmp<br>    minsize 1M<br>    rotate 1<br>}<br>/var/log/btmp {<br>    missingok<br>    monthly<br>    create 0600 root utmp<br>    rotate 1<br>}<br>本地配置格式(若某参数同时设置了本地配置和全局配置，则本地配置生效)<br>日志路径 {<br>  配置参数<br>}<br>如：<br>/usr/local/apache/logs/access_log {<br>  daily      //每天进行日志轮替<br>  create    //日志轮替时新建日志，文件权限、所有者等信息默认<br>  rotate 30 //保留30份日志文件(即保留30天)<br>}</p></div><h5 id="手动进行日志轮替"><a href="#手动进行日志轮替" class="headerlink" title="手动进行日志轮替"></a>手动进行日志轮替</h5><p><span class="strong">logrotate [参数] 配置文件名</span></p><p>不添加任何参数时，将按配置文件进行轮替</p><ul><li>-v 显示日志轮替的过程</li><li>-f 无论是否达到轮替配置要求，强制进行日志轮替</li></ul><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p><strong>完全备份：</strong>即把所有需要备份的数据全部备份， 在Linux 中，完全备份指将根目录下的所有文件进行备份。</p><p><strong>增量备份：</strong>指第一次进行完全备份，服务器运行一段时间后，比较当前数据和第一次备份数据之间的差异，只备份有差异的数据，之后的每次备份都只备份与上一次备份有差异的数据。</p><h5 id="一般需备份的数据"><a href="#一般需备份的数据" class="headerlink" title="一般需备份的数据"></a>一般需备份的数据</h5><ul><li><strong>/root/</strong>&emsp;管理员账户根目录</li><li><strong>/home/</strong>&emsp;普通用户家目录</li><li><strong>/var/spool/mail</strong>&emsp;邮件</li><li><strong>/etc/</strong>&emsp;重要服务的配置文件</li><li><strong>/var/log</strong>&emsp;常用服务的日志</li><li><strong>数据库数据、账户资料….</strong></li></ul><h4 id="dump文件备份系统"><a href="#dump文件备份系统" class="headerlink" title="dump文件备份系统"></a>dump文件备份系统</h4><h5 id="1-安装dump"><a href="#1-安装dump" class="headerlink" title="1. 安装dump"></a>1. 安装dump</h5><ul><li><strong>yum -y install dump</strong> (redhalt系列)</li><li><strong>apt-get install dump</strong> (debian系列)</li></ul><h5 id="2-dump命令"><a href="#2-dump命令" class="headerlink" title="2. dump命令"></a>2. dump命令</h5><p><span class="strong">dump [参数] 备份后文件名 原文件或目录</span></p><ul><li>-[0-9级别]&emsp;可选0-9备份级别</li><li>-f 文件名&emsp;指定备份后的文件名</li><li>-u&emsp;备份成功后，把备份时间、备份级别等信息记录在 /etc/dumpdates 文件中</li><li>-v&emsp;显示备份过程中更多的输出信息</li><li>-j&emsp;调用 bzlib 库压缩备份文件，其实就是把备份文件压缩为 .bz2 格式，默认压缩等级为2</li><li>-W&emsp;显示允许被 dump 的分区的备份等级及备份时间</li></ul><h5 id="3-备份操作"><a href="#3-备份操作" class="headerlink" title="3.备份操作"></a>3.备份操作</h5><p>对于某个文件或不是分区的目录，dump只能使用 0 级别进行完全备份。而备份分区或整块硬盘时，dump 通过“备份级别”实现增量备份，其中，0 级别是完全备份，1-9为增量备份。</p><p>当我们备份数据时，第一次备份应该使用 0 级别，dump会把所有数据完全备份一次；第二次备份就可以使用 1 级别了，它会和 0 级别进行比较，把 0 级别备份之后变化的数据进行备份；第三次备份使用  2 级别，2 级别会和 1 级别进行比较，把 1 级别备份之后变化的数据进行备份，以此类推。</p><h6 id="备份目录"><a href="#备份目录" class="headerlink" title="备份目录"></a>备份目录</h6><div class="show"># dump -0uj -f /new/home.bak.bz2 /home/完全备份home目录到/new/home.bak.bz2路径下</div><h6 id="备份分区"><a href="#备份分区" class="headerlink" title="备份分区"></a>备份分区</h6><div class="show">#df -h 查看分区信息# dump -0uj -f /root/boot.bak.bz2 /boot/第一次备份进行完全备份，记录备份信息# dump -1uj -f /root/boot.bak1.bz2 /boot/第二次开始使用增量备份# dump -W查询分区的备份时间及备份级别(需要备份的时候添加u参数)</div><h4 id="restore还原dump备份的文件"><a href="#restore还原dump备份的文件" class="headerlink" title="restore还原dump备份的文件"></a>restore还原dump备份的文件</h4><p><span class="strong">restore [模式选项] [-f 文件名]</span></p><p>-f用于指定备份文件文件名，模式选项有四个，只能选一个模式</p><ul><li>-C&emsp;比较模式，比较备份数据和现有数据的不同并返回(只能检测出数据修改或减少的部分，如果新增了数据不会被检测到)</li><li>-i&emsp;交互模式，手动选择需要恢复的文件</li><li>-t&emsp;查看模式，用于查看备份文件中拥有哪些文件和目录</li><li>-r&emsp;还原模式，用于数据还原(如果是增量备份，则需先还原首次完全备份的数据)</li></ul><div class="show"># restore -r -f /root/boot.bak.bz2先还原增量备份中首次备份的数据# restore -r -f /root/boot.bak.bz2再还原第二次开始增量备份的数据</div><div class="broadcast color-pink"><div class="iconfont icon-yinle1"></div>一般使用<span class="tips">bak</span>作为系统备份文件名后缀</div>]]></content>
    
    
    <summary type="html">Linux网络操作，包括网络与网卡设置，源码包与二进制包的安装，yum工具使用，安装服务管理，系统资源的监控，日志服务，定时任务，文件备份</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="command" scheme="https://shiwei11.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>Linux 运行级别与用户管理</title>
    <link href="https://shiwei11.github.io/blog/2021/12/29/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84/"/>
    <id>https://shiwei11.github.io/blog/2021/12/29/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84/</id>
    <published>2021-12-29T01:57:08.000Z</published>
    <updated>2022-09-09T23:40:39.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h3><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><ul><li><strong>/bin</strong> &emsp; Binaries的缩写，存放普通用户可使用的系统命令,如:ls</li><li><strong>/sbin</strong>&emsp;Super user Binary的缩写，存放只有系统管理员才能使用的系统命令，如:shutdown、reboot</li><li><strong>/usr/bin</strong>&emsp;存放安装软件后，普通用户可以使用的软件命令，如:c++、make、wget等</li><li><strong>/usr/sbin</strong>&emsp;存放系统管理员用户安装使用的高级管理程序和系统服务程序，如:httpd、netconfig、tcpd等</li></ul><h4 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h4><ul><li><strong>/etc</strong>&emsp;Etcetera(其他)的缩写，这个目录用来存放所有系统管理所需要的<strong>配置文件</strong>和子目录</li><li><strong>/var</strong>存放一些经常被修改、扩充的文件，如各种日志文件</li><li>/boot&emsp;存放引导启动Linux时使用的核心文件,如镜像文件等</li><li>/sys&emsp; Linux2.6内核新增的文件系统sysfs，sysfs文件系统集成了3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统</li><li>/lib&emsp;存放系统所需要的动态链接库(如C++库)，相当于windows的dll文件</li><li>/dev&emsp;Device的缩写, 将Linux主机的硬件以文件形式存储并提供访问，相当于Windows的设备管理器</li><li>/usr/src&emsp;内核源代码、说明文档等默认放置目录</li><li>/opt&emsp;默认为空，常用于安装额外软件</li><li>/proc&emsp;Processes(进程)的缩写，虚拟的目录，用于管理内存空间，是系统内存的映射，我们可以直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里</li><li>/selinux&emsp;全称为security-enhanced linux，该目录是 Redhat/CentOS 所特有的目录，是Redhat/CentOS的安全子系统</li><li>/srv&emsp;service缩写，存放一些服务启动后需要提取的数据</li></ul><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><ul><li><strong>/root</strong>&emsp;系统管理员的账号主目录</li><li><strong>/home</strong>&emsp;存放普通用户的相关文件，Linux会在home目录下为每一个用户生成一个以用户账号命名的目录</li><li><strong>/usr</strong>&emsp;Unix Software Resource(共享资源)的缩写,放置用户的应用程序和文件，类似于windows下的program files目录</li><li><strong>/usr/local</strong>&emsp;软件安装目录，一般通过源码编译安装方式安装的软件都会存放于该目录下</li><li>/usr/include&emsp;放置如c/c++等程序语言的头文件(header)与包含档(include)</li><li>/usr/lib&emsp;放置各应用软件的函式库、目标文件等，如果使用的是X86_64的Linux系统，则可能会生成/usr/lib64文件夹</li></ul><h4 id="外部文件"><a href="#外部文件" class="headerlink" title="外部文件"></a>外部文件</h4><ul><li><strong>/media</strong>&emsp;挂载U盘、光驱等设备的目录，类似于windows的其他设备</li><li>/mnt&emsp;让用户挂载其他的文件系统，如将Windows上的某个目录挂载在/mnt下，可用于共享文件等</li></ul><h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><ul><li>/lost+found&emsp;一般情况下为空目录，用于存放系统非法关机或者发生意外错误后，fsck(磁盘修复)过程修复的部分文件</li><li>/tmp&emsp;用于存放临时文件</li><li>/run&emsp;一个临时文件系统，存放存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul><h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p>Linux系统的开机过程流程为：加载BIOS，进入Boot Loader，加载系统内核，进行内核初始化，启动初始化进程init。</p><p>可以使用<span class="tips">init 运行级别</span>在系统运行级别之间切换，使用<span class="tips">runlevel</span>查询当前运行级别。</p><div class="table"><table><thead><tr><th>运行级别(runlevel)</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>系统关机，禁止设置为系统默认运行级别</td></tr><tr><td>1</td><td>单用户状态，只启动系统核心，用于系统修复和维护</td></tr><tr><td>2</td><td>多用户状态，禁用NFS(网络文件系统)和网络服务，可用于停机维护</td></tr><tr><td>3</td><td>完全多用户状态，具有完整的功能</td></tr><tr><td>4</td><td>系统未使用，保留</td></tr><tr><td>5</td><td>GUI模式，桌面版Linux专属</td></tr><tr><td>6</td><td>系统重启，禁止设置为系统默认运行级别</td></tr><tr><td>emergency</td><td>用于系统救援</td></tr></tbody></table></div><p>在路径<span class="tips">/etc/rc.d</span>下存放有7个对应系统运行级别的目录<span class="tips">/rc0.d——rc6.d</span>，目录中列出了该运行级别下会启动/关闭的服务，init.d目录下存放有用户可以开机启动的脚本，对于以K(Kill)开头的文件，系统会关闭对应的服务，以S(Start)开头的文件，系统将启动对应的服务，并且启动/关闭次序为S/K之后的值。<span class="tips">rc.local</span>文件用于配置用户开机执行的命令，系统在启动后将自动执行该文件中的所有命令。</p><p>在一些旧版本的Linux中，/etc/rc.d路径下还含有<span class="tips">/etc/inittab</span>文件，文件中可以设置系统默认运行级别。centos7之后的系统将不再支持该方式修改默认级别，而使用target替代了sysvinit的运行级。</p><div class="table"><table><thead><tr><th>Sys v init runlevel</th><th>systemd target</th></tr></thead><tbody><tr><td>0</td><td>poweroff.target</td></tr><tr><td>1</td><td>rescue.target</td></tr><tr><td>2</td><td>multi-user.target</td></tr><tr><td>3</td><td>multi-user.target</td></tr><tr><td>4</td><td>multi-user.target</td></tr><tr><td>5</td><td>graphical.target</td></tr><tr><td>6</td><td>reboot.target</td></tr><tr><td>emergency</td><td>emergency.target</td></tr></tbody></table></div><div class="show">系统默认以启动runlevel3启动# systemctl set-default multi-user.target系统默认以启动runlevel5启动# systemctl set-default graphical.target查看当前运行级别# systemctl get-default</div><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>许多主流Linux系统默认使用的Shell(终端程序)是Bash(GNU Bourne-Again Shell)解释器，可以通过<span class="tips">上下方向键</span>来调取之前执行过的Linux命令，可以使用<span class="tips">Tab键</span>来补全命令、参数或文件名。</p><p>常见的执行Linux命令的格式为</p><p><span class="strong">命令  [参数] [对象]</span></p><ul><li>有多个可选参数时，可以写在一起</li><li>参数可以用长格式(完整的参数名称)并使用”-&zwnj;-“作为前缀，也可以用短格式（单个字母的缩写）使用”-“作为前缀。如：<span class="tips">-&zwnj;-help</span>和<span class="tips"> -h</span>，但有时短格式与长格式表示的不是同一个参数，如：shutdown -&zwnj;-help会显示shutdown命令的帮助信息,shutdown -h则为系统关机命令<div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>命令、参数与命令对象字母严格区分大小写</div></li></ul><h4 id="Linux的关闭与重启"><a href="#Linux的关闭与重启" class="headerlink" title="Linux的关闭与重启"></a>Linux的关闭与重启</h4><h5 id="1-sync-保存数据"><a href="#1-sync-保存数据" class="headerlink" title="1. sync 保存数据"></a>1. sync 保存数据</h5><p><span class="strong">sync</span>&emsp;将内存数据存储到磁盘，<span class="tips">关机或重启Linux前应当执行该命令防止数据丢失</span></p><h5 id="2-shutdown-命令-推荐使用"><a href="#2-shutdown-命令-推荐使用" class="headerlink" title="2.shutdown 命令(推荐使用)"></a>2.shutdown 命令(推荐使用)</h5><p>shutdown命令用于关闭/重启Linux，命令格式为</p><p> <span class="strong">   shutdown [选项] [时间] [警告消息]</span></p>常用选项<ul><li><span class="strong">-t 值</span>&emsp;设置在几秒后关机</li><li><span class="strong">-h</span>&emsp;关机</li><li><span class="strong">-r</span>&emsp;重启</li><li><span class="strong">-c</span>&emsp;取消已经设置的关机/重启命令</li><li>- m&emsp;强制杀死所有执行中的程序,然后关机(不调用init进程)</li><li>-k &emsp;不关机，仅把警告讯息传送给所有登录的用户</li><li>-f &emsp;强制略过fsck磁盘检测(unbuntu独有参数)</li><li>-F &emsp;强制进行fsck磁盘检测(unbuntu独有参数)</li><li>-w &emsp;测试使用，系统不会重启，但会把重新开机的数据写入/var/log目录下的wtmp记录文件</li><li>-H 或 --halt&emsp;&emsp;&emsp;相当于halt</li><li>-P 或 --poweroff&emsp;相当于poweroff</li><li>--no-wall &emsp;&emsp;&emsp;&emsp;系统在重启、关闭时不发送信息给登录的用户</li></ul><div class="show">示例：# shutdown -t 30        30s后关机# shutdown -h now       马上关机# shutdown -h 12:30     12:30关机，会占用终端# shutdown -h 12:30 &   12:30关机，关机命令会在后台处理不占用终端# shutdown -h 10 "System will shutdown after 10 minutes"    10分钟后关机并发送消息给用户# shutdown -r +10       10分钟后重启# shutdown -fr now      马上重启并强制略过fsck磁盘检测# shutdown -c           取消已设置的关机/重启命令</div><h5 id="3-halt-关机"><a href="#3-halt-关机" class="headerlink" title="3.halt 关机"></a>3.halt 关机</h5><p><span class="strong">halt [选项]</span></p><p>可选选项</p><ul><li>-d &emsp;不把关机记录写到 /var/log/wtmp 文件里</li><li>-n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)</li><li>-w &emsp;不会真的关机,只是把关机记录写到 /var/log/wtmp 文件里</li><li>-f &emsp;强制关机，不调用shutdown命令</li><li>-i &emsp;关机前关闭所有网络接口</li><li>-p &emsp;关机后关闭电源(poweroff)</li></ul><h5 id="4-reboot-重启"><a href="#4-reboot-重启" class="headerlink" title="4.reboot 重启"></a>4.reboot 重启</h5><p><span class="strong">reboot [选项]</span></p><p>可选选项</p><ul><li>-d &emsp;不把重启记录写到 /var/log/wtmp 文件里</li><li>-n &emsp;重启前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)</li><li>-w &emsp;不会真的重启,只是把重启记录写到 /var/log/wtmp 文件里</li><li>-f &emsp;强制重启，不调用shutdown命令</li><li>-i &emsp;重启前关闭所有网络接口</li></ul><h5 id="5-poweroff-关机并切断电源"><a href="#5-poweroff-关机并切断电源" class="headerlink" title="5.poweroff 关机并切断电源"></a>5.poweroff 关机并切断电源</h5><p><span class="strong">poweroff [选项]</span></p><p>可选选项</p><ul><li>-d &emsp;不把关机记录写到 /var/log/wtmp 文件里</li><li>-n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)</li><li>-w &emsp;不会真的关机,只是把关闭记录写到 /var/log/wtmp 文件里</li><li>-f &emsp;强制关闭</li><li>-i &emsp;关机前关闭所有网络接口</li><li>-h &emsp;关机前将系统中所有的硬件设置为备用模式<div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>除了上述命令，还可以通过设置系统运行级别进行关机、重启。使用 <span class="tips">init 0 </span>关机，使用<span class="tips">init 6 </span>重启。</div></li></ul><h3 id="用户与组管理"><a href="#用户与组管理" class="headerlink" title="用户与组管理"></a>用户与组管理</h3><p>Linux系统是一个多用户多任务的分时操作系统，用户可以属于一个或多个组方便系统管理员控制用户权限，默认有一个root管理员组并且root账户属于该组。可以使用<span class="tips">logout</span>登出当前用户账户。</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><h5 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1. 添加用户"></a>1. 添加用户</h5><p><span class="strong">useradd [可选参数] 用户名</span></p><p>默认会在/home 目录下生成一个以用户名命名的文件夹作为用户的主文件夹，并且会生成一个与用户名同名的用户组。</p>可选参数：<ul><li>-c 注释 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;为用户添加一段注释性描述</li><li>-d /路径/目录名&emsp;&emsp;&emsp;自定义用户的主目录，即不使用与用户名同名的默认目录,如果该目录不存在，则可以同时使用-m参数来新建文件夹指定为主目录</li><li>-g 用户组 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户所属的初始用户组</li><li>-G 用户组，用户组 &emsp;指定用户所属的附加用户组</li><li>-s Shell文件 &emsp;&emsp;&emsp;&emsp;指定用户的登录Shell</li><li>-u 用户号 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户的用户号，可以添加-o选项来重复使用与其他用户相同的标识号<div class="show">示例：# useradd yg新增用户yg，同时会新建一个组yg# useradd -g gumu lmc新增用户lmc，并且将lmc添加到gumu组# useradd -d /somedir/user2dir -m user2新建用户user2，在 /somedir 文件夹下新建user2dir并将其主目录指定为user2dir (somedir文件夹必须存在，无法用上述命令直接新建)</div></li></ul><h5 id="2-给用户添加-修改密码"><a href="#2-给用户添加-修改密码" class="headerlink" title="2. 给用户添加/修改密码"></a>2. 给用户添加/修改密码</h5><p><span class="strong">passwd [可选参数] [用户名]</span><br>不写用户名则会修改当前账户密码，输入密码时不会显示在终端上,可选参数：</p><ul><li>-l &emsp;锁定口令，禁止用户自行修改(参数为小写L)</li><li>-u &emsp;解锁口令，允许用户自行修改</li><li>-S &emsp;显示密码信息</li><li>-d &emsp;删除账户口令</li><li>-f &emsp;强迫用户下次登录时必须修改口令</li><li>-x &emsp;指定口令最长存活期</li><li>-k &emsp;    保留即将过期的用户在期满后能仍能使用</li></ul><h5 id="3-删除用户"><a href="#3-删除用户" class="headerlink" title="3. 删除用户"></a>3. 删除用户</h5><p>只能在root账户下删除用户</p><ul><li><span class="strong">userdel 用户名</span>&emsp;删除用户但保留用户的主目录</li><li> <span class="strong">userdel -r 用户名</span>&emsp;删除用户且不保留用户主目录</li></ul><h5 id="4-查询用户信息"><a href="#4-查询用户信息" class="headerlink" title="4. 查询用户信息"></a>4. 查询用户信息</h5><p><span class="strong">id 用户名</span><br>查询是否有该用户，有则返回用户号(uid)、组号(gid)、所属组名</p><h5 id="5-切换用户"><a href="#5-切换用户" class="headerlink" title="5. 切换用户"></a>5. 切换用户</h5><p><span class="strong">su [可选参数] 用户名</span><br>从权限高的账户切换到权限低的用户不需要输入密码，反之需要。切换完用户后，可通过 <span class="tips">exit</span> 命令返回原来的用户</p><ul><li>-&emsp; 使用”-“在切换用户时会连带切换用户环境，如:家目录，用户邮箱等</li><li>-c 命令 &emsp;仅切换到该用户执行一次-c后的命令<div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>仅使用 <span class="tips">su 用户名</span> 不会切换用户环境，在很多使用场景中会报错，推荐使用<span class="tips">su - 用户名</span>命令</div></li></ul><h5 id="6-修改用户信息"><a href="#6-修改用户信息" class="headerlink" title="6. 修改用户信息"></a>6. 修改用户信息</h5><p><span class="strong">usermod [可选参数] 用户名</span></p><ul><li>-u UID &emsp;修改用户UID</li><li>-c 用户说明 &emsp;修改用户说明信息</li><li>-G 组名 &emsp; 修改用户附加组</li><li>-L &emsp;&emsp;临时锁定用户</li><li>-U &emsp;&emsp;解锁用户</li></ul><h5 id="7-修改用户密码状态"><a href="#7-修改用户密码状态" class="headerlink" title="7. 修改用户密码状态"></a>7. 修改用户密码状态</h5><p><span class="strong">chage [可选参数] 用户名</span></p><ul><li>-l  &emsp;&emsp;列出用户详细密码状态</li><li>-d 日期 &emsp;修改密码最后一次修改日期(修改shadow文件字段3)</li><li>-m 天数 &emsp; 两次密码修改间隔(字段4)</li><li>-M 天数 &emsp;&emsp;密码有效期(字段5)</li><li>-W 天数 &emsp;&emsp;密码过期前警告天数(字段6)</li><li>-I 天数 &emsp;&emsp;密码过期后宽限天数(字段7)</li><li>-E 日期 &emsp;&emsp;账号失效时间(字段8)<div class="show">使用：# chage -d 0 user1强制用户user1下次登录修改密码</div></li></ul><h5 id="8-查看当前所有登录用户"><a href="#8-查看当前所有登录用户" class="headerlink" title="8. 查看当前所有登录用户"></a>8. 查看当前所有登录用户</h5><h6 id="8-1-查看当前使用的账户"><a href="#8-1-查看当前使用的账户" class="headerlink" title="8.1 查看当前使用的账户"></a>8.1 查看当前使用的账户</h6><p><span class="strong">whoami 或 who am i</span></p><h6 id="8-2-查看当前登录的用户"><a href="#8-2-查看当前登录的用户" class="headerlink" title="8.2 查看当前登录的用户"></a>8.2 查看当前登录的用户</h6><p><span class="strong">who</span></p><p>会返回登录用户名、登录终端、登陆时间(远程登录还有IP地址)，登录终端中tty表示本地登录终端，pts一般为远程登录。</p><p> <span class="strong">w</span></p><p>会返回更详细的登录信息。</p><div class="show">w命令返回值解析：15:20:10 up 25 days, 15:25,  1 user,  load average: 0.00, 0.00, 0.00USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATroot     pts/0    180.129.129.129  10:09    0.00s  0.04s  0.04s -bash第一行为登录时间，up后为linux运行时间，用户数量，服务器负载情况第二行IDLE为用户已经空闲时间，JCPU为用户累计CPU占用时间，PCPU为用户当前命令操作占用CPU时间，WHAT为用户操作</div><h4 id="用户的相关文件"><a href="#用户的相关文件" class="headerlink" title="用户的相关文件"></a>用户的相关文件</h4><p>Linux通过用户配置文件来查看和修改用户信息</p><h5 id="1-用户的信息文件"><a href="#1-用户的信息文件" class="headerlink" title="1. 用户的信息文件"></a>1. 用户的信息文件</h5><p>文件位于<span class="tips">/etc/passwd</span>，每一行代表一个用户，并且以</p><div class="show"><span class="tips">用户名:密码标识:用户UID:用户初始组GID:用户说明:家目录:登录的Shell</span></div>格式书写用户信息<ul><li><p>密码标识中，有 X 表示用户有密码，用户登录时linux会前往/etc/shadow查找密码</p></li><li><p>用户UID：0 为超级管理员用户，1-1000为系统用户，系统用户为ftp等由linux调用的用户，无法登录，修改可能会导致系统无法启动，1000以上为普通用户(旧版本的linux可能1-500为系统用户)</p></li><li><p>用户说明可以为空</p></li><li><p>用户登录shell一般默认为/bin/bash，系统用户为/sbin/nologin,可以将普通用户的shell更改为/sbin/nologin来禁止用户登录</p><h4 id="2-用户的密码文件"><a href="#2-用户的密码文件" class="headerlink" title="2. 用户的密码文件"></a>2. 用户的密码文件</h4><p>文件位于<span class="tips">/etc/shadow</span>，保存了加密后的用户密码等信息，每一行代表一个用户，如：</p><div class="show">swv:$6$hPQczrTV$urGtx/wXaOtfIKdyuD/aUO.tHogxBM7uie4ioSbyVgcpNS3Po.:19032:0:99999:7:::</div></li><li><p>字段一：用户名</p></li><li><p>字段二：加密后的密码，如果为”!!”或”*”表示没有密码，无法登录</p></li><li><p>字段三：密码最后一次修改日期，以1970年1月1日作为标准时间，每天+1</p></li><li><p>字段四：允许的两次密码修改间隔，如：10为只允许每10天修改一次密码</p></li><li><p>字段五：密码有效期</p></li><li><p>字段六：密码到期提前警告时间</p></li><li><p>字段七：密码到期后仍然可使用时间，如：3为还可以使用3天，其中0代表到期立马失效，-1代表到期后仍然能永久使用</p></li><li><p>字段八：账号失效时间，使用时间戳(到期时间与1970-1-1的间隔天数)表示</p></li><li><p>字段九：保留字段(未使用)</p></li></ul><h4 id="3-用户的邮箱文件"><a href="#3-用户的邮箱文件" class="headerlink" title="3. 用户的邮箱文件"></a>3. 用户的邮箱文件</h4><p>文件位于<span class="tips">/var/spool/mail/用户名/</span>，Linux用户可以相互发送内部邮件</p><h4 id="4-用户模板目录"><a href="#4-用户模板目录" class="headerlink" title="4. 用户模板目录"></a>4. 用户模板目录</h4><p>文件位于<span class="tips">/etc/skel/</span>，用于制作一个模板文件，在新注册用户时会在用户家目录下自动生成该文件。如：给每个账户生成一个用户操作手册。</p><h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><p>用户组方便系统对同一类型的用户进行管理，对用户组的修改实际上就是对/etc/group文件的更新。</p><h5 id="1-增加组"><a href="#1-增加组" class="headerlink" title="1. 增加组"></a>1. 增加组</h5><p><span class="strong">groupadd [可选参数] 组名</span><br>可选参数：</p><ul><li>-g GID &emsp;指定新用户组的组标识号（GID）</li><li>-o &emsp;&emsp;&emsp;一般与-g参数同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><h5 id="2-修改用户组"><a href="#2-修改用户组" class="headerlink" title="2.修改用户组"></a>2.修改用户组</h5><p><span class="strong">groupmod [可选参数] 组名</sapn></p><ul><li>-g GID &emsp;修改组ID</li><li>-n 新组名&emsp;修改组名</li></ul><h5 id="3-删除用户组"><a href="#3-删除用户组" class="headerlink" title="3. 删除用户组"></a>3. 删除用户组</h5><p><span class="strong">groupdel 组名</span><br>如果组中有初始用户，该组无法删除(以避免用户不属于任何一个组，想删除该组可以先删除该初始用户的账户)，若组中都为附加用户则可以删除。</p><h5 id="4-把用户添加入组或从组中删除"><a href="#4-把用户添加入组或从组中删除" class="headerlink" title="4. 把用户添加入组或从组中删除"></a>4. 把用户添加入组或从组中删除</h5><p><span class="strong">gpasswd 必选参数 组名</sapn></p><ul><li>-a 用户名&emsp;把用户加入组中</li><li>-d 用户名&emsp;把用户从组中删除</li></ul><h4 id="用户组的配置文件"><a href="#用户组的配置文件" class="headerlink" title="用户组的配置文件"></a>用户组的配置文件</h4><h5 id="1-用户组的信息文件"><a href="#1-用户组的信息文件" class="headerlink" title="1. 用户组的信息文件"></a>1. 用户组的信息文件</h5><p>组信息文件位于<span class="tips">/etc/group</span>，信息格式为：</p><div class="show"><span class="tips">组名:组密码标识:组GID:组中的附加用户</span></div>字段说明同用户配置文件类似<h5 id="2-组密码文件"><a href="#2-组密码文件" class="headerlink" title="2. 组密码文件"></a>2. 组密码文件</h5><p>文件位于<span class="tips">/etc/gshadow</span>，密码文件书写格式为：</p><div class="show"><span class="tips">组名:组密码:组管理员用户名:组中的附加用户</span></div>配置如上,该文件不常用]]></content>
    
    
    <summary type="html">包括Linux系统文件介绍，系统运行级别介绍，用户与用户组管理，用户身份切换</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="command" scheme="https://shiwei11.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>vim笔记</title>
    <link href="https://shiwei11.github.io/blog/2021/06/15/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://shiwei11.github.io/blog/2021/06/15/vim%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2021-06-14T18:22:18.000Z</published>
    <updated>2022-07-14T17:48:29.447Z</updated>
    
    <content type="html"><![CDATA[<div class="broadcast color-yellow"><div class="iconfont icon-dengpao14hao"></div>第一次接触到vim时连字都不会打...后来在某管乱逛的时候看到两个Google的<del> 秃头 </del>工程师用vim花式结对编程时，vim就深深折服了我，那效率真是芜湖~，谁不想有个这样的<del> jiyou </del>普通朋友来次愉快的多线程交流呢<span  style="white-space: nowrap;">๑乛◡乛๑</span></div><h3 id="vi-与-vim-简介"><a href="#vi-与-vim-简介" class="headerlink" title="vi 与 vim 简介"></a>vi 与 vim 简介</h3><p><span class="strong">vi:</span>为 visual interface 的简称，是<span class="tips">Linux</span>操作系统中最经典的文本编辑器。</p><p><span class="strong">vim:</span>全称为vi improved，从vi 发展而来的文本编辑器，支持代码补全、编译、错误跳转等功能。在很多Linux发行版中，直接预装有vim编辑器，vim本身也发布了支持Windows、Unix、MacOS等不同操作系统的编辑器版本，并且很多优秀的IDE都有支持vim的插件，因此使用vim命令可以在各种操作系统环境下高效编辑代码/文本。</p><p><span class="tips">vim官方网站：<a href="https://www.vim.org/" target="_blank">https://www.vim.org/</a></span></p><ul>vim的特点:<li>熟练掌握vim以后可以极大地提高编辑速率</li><li>所有操作可以靠键盘完成，免去了键盘鼠标来回切换的时间</li><li>甚至于在部分终端中不支持鼠标操作，无UI界面，所有操作靠命令</li><li>无花里胡哨的排版功能，但有很多花里胡哨的的插件可以玩</li><li>命令操作一切</li><li>大多数服务器默认安装</li></ul><h3 id="vim-的三种工作模式"><a href="#vim-的三种工作模式" class="headerlink" title="vim 的三种工作模式"></a>vim 的三种工作模式</h3><p>不同文档对命令、工作模式的翻译可能不同，不过在vim中操作是一样的</p><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><p>打开文件会首先进入命令模式，是 vim 使用的入口。该模式下可对文件内容进行基本的快捷操作，如：定位、翻页、复制、粘贴、删除等</p><p>在命令模式下输入<span class="tips">i</span>进入编辑模式，进入编辑模式后按下<span class="tips">esc</span>返回命令模式</p><p>在命令模式下输入<span class="tips">:</span>进入末行模式，进入末行模式后按下<span class="tips">esc</span>返回命令模式</p><div class="broadcast color-blue"><div class="iconfont icon-yinhao"></div>使用I、o、a等命令也可进入编辑模式，具体用法详见插入命令。</div><h5 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h5><p>在vim最底部输入命令的模式，也是vim 的出口，当要退出 vim 返回控制台时，需要在末行模式下输入命令。该模式下可对文件整体进行基本的操作，如：保存、退出、另存、搜索与替换等操作。</p><p>末行模式下输入<span class="tips">wq</span>可快速保存并关闭文件</p><h5 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h5><p>用于编辑文件具体内容的模式</p><h5 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h5><p>还有<span class="tips">可视模式</span>、<span class="tips">替换模式</span>两个用于选取字符、替换内容等具体操作的模式</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="打开与新建文件"><a href="#打开与新建文件" class="headerlink" title="打开与新建文件"></a>打开与新建文件</h4><ul><li><span class="strong">vim 文件名</span> 打开/新建文件</li><li><span class="strong">vim 文件名 +行号</span> 打开文件并跳转到对应行号</li><li><span class="strong">vim 文件名 +</span>打开文件并跳转到文件末尾</li><li><span class="strong">vim 文件名1 文件名2 ... </span>同时打开多个文件</li></ul><p>使用命令时，若文件名对应的文件存在，则会用vim编辑器打开该文件，若文件不存在，则会新建一个文件。打开多个文件时，默认显示第一个文件，可以通过命令<span class="tips">:ls</span>让vim列出所有打开的文件，使用<span class="tips">:b数字</span>来使对应序号的文件显示在屏幕上。</p><h4 id="保存与退出-末行模式下"><a href="#保存与退出-末行模式下" class="headerlink" title="保存与退出(末行模式下)"></a>保存与退出(末行模式下)</h4><p>需要先切换到末行模式下，因此下述命令前的<span class="tips"> : </span>号用于换到末行模式</p><ul><li><span class="strong">:w </span>保存</li><li><span class="strong">:w! </span>强制保存</li><li><span class="strong">:q </span>退出，如果没有保存则不允许退出</li><li><span class="strong">:q! </span>不保存，强制退出</li><li><span class="strong">:wq </span>保存并退出</li><li><span class="strong">:x </span>保存并退出</li></ul><p>更多末行模式下的命令在末行模式下的命令小节</p><h4 id="异常退出"><a href="#异常退出" class="headerlink" title="异常退出"></a>异常退出</h4><p>如果 vim 异常退出，会为当前编辑但尚未保存的文件创建一个后缀名为<span class="tips">.swp</span>的<span class="tips">交换文件</span>,该文件默认隐藏，下次打开未保存的文件会询问如何进行操作，可以根据vim提示选择恢复、直接编辑等操作。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="移动光标与选取文本"><a href="#移动光标与选取文本" class="headerlink" title="移动光标与选取文本"></a>移动光标与选取文本</h4><h5 id="上上下下左左右右-BABA"><a href="#上上下下左左右右-BABA" class="headerlink" title="上上下下左左右右 BABA"></a>上上下下左左右右 BABA</h5><ul><li><span class="strong">h&emsp;&emsp;向左</span></li><li><span class="strong">j &emsp;&emsp;向下</span></li><li><span class="strong">k&emsp;&emsp;向上</span></li><li><span class="strong">l &emsp;&emsp;向右</span></li></ul><h5 id="行内移动"><a href="#行内移动" class="headerlink" title="行内移动"></a>行内移动</h5><ul><li><span class="strong">w&emsp;&emsp;移动到下一个单词开头</span>(word)</li><li><span class="strong">b &emsp;&emsp;向前移动一个单词</span>(back)</li><li><span class="strong">0 &emsp;&emsp;行首</span></li><li><span class="strong">^ &emsp;&emsp;行首，第一个不是空白的字符位置</span></li><li><span class="strong">$ &emsp;&emsp;行尾</span></li><li><span class="strong">g_ &emsp;&emsp;行尾,最后一个不是空白的字符位置</span></li><li>&nbsp; e &emsp;&emsp;下一个单词结尾</li><li>&nbsp; f字符&emsp;&emsp;下一个对应字符位置</li><li>&nbsp; nf字符&emsp;&emsp;下n个对应字符位置</li><li>&nbsp; F字符&emsp;&emsp;上一个对应字符位置</li><li>&nbsp; nF字符&emsp;&emsp;上n个对应字符位置</li><li>&nbsp; t字符&emsp;&emsp;下一个该字符的前一个字符位置</li><li>&nbsp; nt字符&emsp;&emsp;下n个该字符的前一个字符位置</li><li>&nbsp; T字符&emsp;&emsp;上一个该字符的后一个字符位置</li><li>&nbsp; nT字符&emsp;&emsp;上n个字符的后一个字符位置</li></ul><p>当使用f、F、t、T关键字跳转时，使用 ; 可以快速跳转到下一个指定字符，使用 , 可以跳转到上一个指定字符。</p><h5 id="行间移动"><a href="#行间移动" class="headerlink" title="行间移动"></a>行间移动</h5><ul><li><span class="strong">gg&emsp;&emsp;&emsp;&emsp;跳转到文件第一行行首</span></li><li><span class="strong">G &emsp;&emsp;&emsp;&emsp;&nbsp;跳转到文件最后一行行首</span></li><li><span class="strong">数字gg&emsp;&emsp;跳转到数字对应行数</span></li><li><span class="strong">数字G &emsp;&emsp;&nbsp;跳转到数字对应行的行首</span></li><li><span class="strong">: 数字 &emsp;&emsp;&emsp;跳转到数字对应行数</span></li></ul><h5 id="屏幕内移动"><a href="#屏幕内移动" class="headerlink" title="屏幕内移动"></a>屏幕内移动</h5><ul><li><span class="strong">Ctrl+b&emsp;&emsp;&emsp;向上翻页</span>(back)</li><li><span class="strong">Ctrl+f &emsp;&emsp;&emsp;向下翻页</span>(forward)</li><li><span class="strong">H &emsp; &emsp;&emsp;&emsp;&emsp;当前屏幕第一行行首</span>(Head)</li><li><span class="strong">M&emsp; &emsp;&emsp;&emsp;&emsp;屏幕中间</span>(Middle)</li><li><span class="strong">L &emsp; &emsp; &emsp;&emsp;&emsp;屏幕底部</span>(Low)</li><li><span class="strong">zt &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕顶部</span></li><li><span class="strong">zz &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕中央</span></li><li><span class="strong">zb &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕尾部</span></li></ul><h5 id="段落切换"><a href="#段落切换" class="headerlink" title="段落切换"></a>段落切换</h5><p>vim 中以<span class="tips">空白行</span>来区分段落，开发程序时将同一个功能相关的代码写在一起，不留空行。而在不同功能间留下空白行方便切换。</p><ul><li><span class="strong">{&emsp;&emsp;上一个段落</span></li><li><span class="strong">}&emsp;&emsp;下一个段落</span></li></ul><h5 id="括号间切换"><a href="#括号间切换" class="headerlink" title="括号间切换"></a>括号间切换</h5><p>用于在程序中出现频率很高的<span class="tips">( )</span>、<span class="tips">[ ]</span>、<span class="tips">{ }</span>间切换，需要先把光标移动到其中一个括号上，然后使用%可切换到与其匹配的另外一边括号</p><ul><li><span class="strong">%&emsp;&emsp;括号匹配及切换</span></li></ul><h5 id="添加标记与跳转"><a href="#添加标记与跳转" class="headerlink" title="添加标记与跳转"></a>添加标记与跳转</h5><p>在开发时，某段代码可能需要稍后处理，此时可用标记功能并在稍后快速跳转。</p><ul><li><span class="strong">m字母&emsp;&emsp; &emsp; &emsp;添加标记，字母可用a-z或A-Z间的任意字母</span>(mark)</li><li><span class="strong">' 标记的字母&emsp;&emsp;跳转到该字母标记的行首</span>(英文单引号)</li><li><span class="strong">`标记的字母&emsp;&emsp;跳转到该字母标记处</span>(esc下的撇号)</li><li><span class="strong">:marks&emsp;&emsp;列出所有标记</span></li><li><span class="strong">:delmarks 标记名 标记名....&emsp;&emsp;删除对应标记名</span>(可单个删除可多个删除)</li><li><span class="strong">:delmarks!&emsp;&emsp;删除所有小写字母标记</span></li></ul><p><span class="tips">大写字母标记符可以实现文件间的跳转,因此大写字母通常用于文件间的标记</span></p><p><span class="tips">如果添加标记的行被删除，标记也将被删除。</span></p><p><span class="tips">如果其他行添加了同名标记，之前添加的标记将被替换掉。</span></p><h5 id="选中文本-可视模式"><a href="#选中文本-可视模式" class="headerlink" title="选中文本(可视模式)"></a>选中文本(可视模式)</h5><p>在命令模式下使用下列命令可切换到<span class="tips">可视模式</span>，vim 有三种可视模式。</p><p>可视模式通过与光标移动命令搭配使用来选取文本，如：<span class="tips">ggVG</span>可用于选中所有文本，选取的文本可通过<span class="tips">esc</span>放弃选中并返回命令模式。</p><ul><li><span class="strong">v(常规可视模式)&emsp;&emsp; &emsp;选中光标经过的所有文本</span></li><li><span class="strong">V(可视行模式)&emsp;&emsp;&emsp;&emsp;整行选中光标经过的所有文本</span></li><li><span class="strong">Ctrl+v(可视块模式)&emsp;&emsp;垂直方向选中文本</span>(类似于vscode的shift+Alt+鼠标点击，用于多行输入/删除)</li></ul><h4 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h4><h5 id="撤销与恢复撤销"><a href="#撤销与恢复撤销" class="headerlink" title="撤销与恢复撤销"></a>撤销与恢复撤销</h5><p>用于撤销错误的编辑操作，或者恢复撤销的命令,<span class="tips">可用多次使用!</span></p><ul><li><span class="strong">u&emsp;&emsp; &emsp; &emsp;撤销上一个命令</span>(undo)</li><li><span class="strong">Ctrl+r&emsp;&emsp;恢复撤销的命令</span>(redo)</li></ul><h5 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h5><ul><li><span class="strong">x&emsp; &emsp; &emsp; &emsp; &emsp;删除光标所在字符或选中的文本</span>(cut)</li><li><span class="strong">d移动命令&emsp;&emsp;删除移动命令对应的内容</span>(delete)</li><li><span class="strong">dd&emsp;&emsp;&emsp;&emsp; &emsp;删除光标所在行</span></li><li><span class="strong">D&emsp; &emsp; &emsp;&emsp; &emsp;删除光标至行尾间的内容</span></li><li><span class="strong">:n1,n2d&emsp;&emsp;&emsp;多行删除,n1为起始行号，n2为结束行号</span>(末行模式下)</li></ul><p>删除命令与移动命令的常用组合</p><ul><li>dw &emsp; &emsp;&emsp; 从光标位置删除到单词末尾</li><li>dnw &emsp; &emsp;&emsp; 删除n个单词</li><li>df字符 &emsp; &emsp;从光标处删除到下一个该字符处</li><li>d$ &emsp; &emsp;&emsp; 删除光标到本行末尾</li><li>d0 &emsp; &emsp; &emsp;从光标位置删除到该行起始位置(光标前该行的所有内容)</li><li>d} &emsp; &emsp; &emsp; 从光标位置删除到段落结尾</li><li>ndd &emsp; &emsp;&emsp;从光标位置向下连续删除 n 行</li><li>d行号G &emsp;&emsp;删除光标所在行到指定代码行之间的所有内容</li><li>d'标记符&emsp;&emsp;从光标所在行删除到标记符之间的所有代码</li><li>dH &emsp; &emsp;&emsp; 删除屏幕第一行到光标所在行</li><li>dG &emsp; &emsp;&emsp; 删除光标所在行到文件结束</li></ul><h5 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h5><p>vim提供一个用于保存被复制、删除文本的缓冲区</p><p> <span class="tips">复制</span>命令会将选中的文字保存在该缓冲区<p><p> <span class="tips">删除</span>命令会将删除内容保存在该缓冲区<p><p> <span class="tips">粘贴</span>命令会将缓冲区内容插入光标所在位置<p><ul><li><span class="strong">y移动命令&emsp;&emsp;复制</span>(copy)</li><li><span class="strong">yy &emsp;&emsp;&emsp;&emsp;&emsp;复制一行,nyy会复制n行</span>(copy)</li><li><span class="strong">y$ &emsp;&emsp;&emsp;&emsp;&emsp;复制光标到本行结尾</span></li><li><span class="strong">yH &emsp;&emsp;&emsp;&emsp;&emsp;复制屏幕第一行到光标所在行</span></li><li><span class="strong">yG &emsp;&emsp;&emsp;&emsp;&emsp;复制光标所在行到文件结束</span></li><li><span class="strong">p &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之后</span>(paste)</li><li><span class="strong">P &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之前</span>(paste)</li></ul><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>vim中的文本缓冲区只有一个，后续做过复制、删除命令操作后，之前缓冲区中的内容会被替换</div><h5 id="输入替换-替换模式"><a href="#输入替换-替换模式" class="headerlink" title="输入替换(替换模式)"></a>输入替换(替换模式)</h5><p><span class="tips">r</span>命令用于轻量级修改,不需要进入替换模式</p><p><span class="tips">R</span>可进入替换模式，修改完成后通过<span class="tips">esc</span>返回命令模式</p><ul><li><span class="strong">r &emsp;&emsp;替换当前字符</span>(replace)命令模式</li><li><span class="strong">R&emsp;&emsp;替换当前行光标后的所有字符</span>(replace)替换模式</li></ul><h5 id="缩排和重复执行"><a href="#缩排和重复执行" class="headerlink" title="缩排和重复执行"></a>缩排和重复执行</h5><p>用于编排代码格式</p><ul><li><span class="strong">&gt;&gt; &emsp;&emsp;向右增加缩进</span>(增加4个空格)</li><li><span class="strong">&lt;&lt; &emsp;&emsp;向左减少缩进</span>(减少4个空格)</li><li><span class="strong"> . &emsp;&emsp;&emsp;重复上次命令</span></li></ul><p>在<span class="tips">可视模式</span>下，缩排命令只需一个<span class="tips">&gt;</span>、<span class="tips">&lt;</span>即可。缩排一次后，用<span class="tips"> . </span>命令执行多次缩排快速进行排版</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><h6 id="1-指定字符查找"><a href="#1-指定字符查找" class="headerlink" title="1.指定字符查找"></a>1.指定字符查找</h6><ul><li><span class="strong">/字符 &emsp;&emsp;查找指定的字符</span></li></ul><p>输入查找内容后回车，vim会高亮找到的内容，此时可使用<span class="tips">n/N</span>命令跳转</p><ul><li><span class="strong">n &emsp;&emsp;查找上一个</span>(next)</li><li><span class="strong">N &emsp;&emsp;查找下一个</span>(next)</li></ul><h6 id="2-快速匹配单词"><a href="#2-快速匹配单词" class="headerlink" title="2.快速匹配单词"></a>2.快速匹配单词</h6><ul><li><span class="strong">* &emsp;&emsp;向后查找光标所在单词</span></li><li><span class="strong">N &emsp;&emsp;向前查找光标所在单词</span></li></ul><P></P>直接按上述键，vim会识别当前光标所在的单词，然后查找相同的单词<div class="broadcast color-green"><div class="iconfont icon-qiqiu"></div>vim会高亮显示查找到的内容，若想取消高亮显示，使用<span class="tips">/字符</span>命令查找一个不存在的字符串将取消高亮显示。<span class="tips">搜索支持正则表达式 !</span></div><h5 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h5><p>替换指定的内容，vim中查找并替换命令需要在<span class="tips">末行模式</span>下执行，语法组成为<span class="tips">:作用范围s/替换内容/新内容/标识符</span>,标识符可由下列3类自由组成。</p><p><span class="tips">i</span>表示大小写不敏感查找</p><p><span class="tips">I</span>表示大小写敏感查找</p><p><span class="tips">g</span>指定区域中找到的所有目标</p><p><span class="tips">c</span>替换前需确认</p><h6 id="1-仅替换第一个目标"><a href="#1-仅替换第一个目标" class="headerlink" title="1.仅替换第一个目标"></a>1.仅替换第一个目标</h6><ul><li><span class="strong">:s/替换内容/新内容&emsp;&emsp;仅替换当前行中的第一个目标内容</span></li><li><span class="strong">:%s/替换内容/新内容&emsp;&emsp;替换文件中所有行的第一个目标内容</span></li></ul><h6 id="2-文件全局替换"><a href="#2-文件全局替换" class="headerlink" title="2.文件全局替换"></a>2.文件全局替换</h6><ul><li><span class="strong">:%s/替换内容/新内容/g&emsp;&emsp;全局替换</span></li></ul>一次性替换整个文件中的所有指定内容<h6 id="3-局部替换"><a href="#3-局部替换" class="headerlink" title="3.局部替换"></a>3.局部替换</h6><ul><li><span class="strong">:s/替换内容/新内容/g&emsp;&emsp;替换当前行中的所有目标内容</span></li><li><span class="strong">:行号1,行号2s/替换内容/新内容/g&emsp;&emsp;替换行号1到行号2之间的所有目标内容</span></li></ul><h6 id="4-在选取内容中替换-可视模式下"><a href="#4-在选取内容中替换-可视模式下" class="headerlink" title="4.在选取内容中替换(可视模式下)"></a>4.在选取内容中替换(可视模式下)</h6><p>只替换选中区域中的指定内容，需要在可视模式下先选中需要替换的区域，选取区域后输入<span class="tips">:</span>,vim会自动补全为<span class="tips">:’&lt;,&gt;’</span>，完整语法为:</p><ul><li><span class="strong">:'<,>'s/替换内容/新内容/g&emsp;&emsp;替换选择区域中的所有目标</span></li></ul><h6 id="5-确认替换-使用标识符c时"><a href="#5-确认替换-使用标识符c时" class="headerlink" title="5.确认替换(使用标识符c时)"></a>5.确认替换(使用标识符c时)</h6><p>进行替换操作时会依次询问每一个内容是否要替换，可依次选择每个目标是否替换然后退出，或执行全部替换。</p><ul><li><span class="strong">:s/替换内容/新内容/gc&emsp;&emsp;确认替换</span>(comfirm)</li></ul><p>确认/取消替换命令:</p><ol><li><span class="strong">y&emsp;&emsp;替换</span>(yes)</li><li><span class="strong">n&emsp;&emsp;不替换</span>(no)</li><li><span class="strong">a&emsp;&emsp;替换所有</span>(all)</li><li><span class="strong">q&emsp;&emsp;退出替换</span>(quit)</li><li> l &emsp;&emsp;最后一个，并把光标移动到行首(last)</li><li>^E&emsp;&emsp;向下滚屏</li><li>^Y&emsp;&emsp;向上滚屏</li></ol><h5 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h5><p>用于进入编辑模式</p><ul><li><span class="strong">i&emsp;&emsp;在当前字符前插入文本</span>(insert)</li><li><span class="strong">I&emsp;&emsp;在行首插入文本</span>(insert)</li><li><span class="strong">a&emsp;&emsp;在当前字符后插入文本</span>(append)</li><li><span class="strong">A&emsp;&emsp;在行末插入文本</span>(append)</li><li><span class="strong">o&emsp;&emsp;在当前行后插入一个空行</span></li><li><span class="strong">O&emsp;&emsp;在当前行前插入一个空行</span></li><li><span class="strong">s&emsp;&emsp;删除光标所在字符然后插入文本</span></li><li><span class="strong">S&emsp;&emsp;删除光标所行然后插入文本</span></li><li><span class="strong">cw&emsp;&emsp;删除光标所在单词然后插入文本</span></li></ul><h5 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h5><ul><li><span class="strong">~&emsp;&emsp;改变光标所在字母大小写</span></li><li><span class="strong">n~&emsp;&emsp;改变光标开始的n个字母大小写</span></li><li><span class="strong">g~~&emsp;&emsp;改变当前行字母大小写</span></li><li><span class="strong">gUU&emsp;&emsp;将当前行字母改成大写</span></li><li><span class="strong">guu&emsp;&emsp;将当前行字母改成小写</span></li><li><span class="strong">ngUU&emsp;&emsp;将光标所在行开始的后n行改成大写</span></li><li><span class="strong">gUw&emsp;&emsp;将光标所处单词改成大写</span></li><li><span class="strong">guw&emsp;&emsp;将光标所处单词改成小写</span></li></ul><h3 id="重复执行命令"><a href="#重复执行命令" class="headerlink" title="重复执行命令"></a>重复执行命令</h3><h5 id="数字-命令的组合会让部分命令执行指定次数"><a href="#数字-命令的组合会让部分命令执行指定次数" class="headerlink" title="数字+命令的组合会让部分命令执行指定次数"></a><span class="tips">数字+命令的组合会让部分命令执行指定次数</span></h5><div class="code">如：10x  删除光标后的10个字符10>>  让光标后的10行文本进行缩进10yy  复制10行内容</div><div class="show">如：输入10个相同的字符串执行步骤1. 在命令模式下输入102. 输入i进入编辑模式3. 输入需要重复的字符串4. 输入完毕后esc返回命令模式，vim会把输入字符这个命令执行10次</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>以上原因，在进入编辑模式前，尽量不要触碰数字，否则可能导致命令的重复执行</div><h5 id="执行某个命令后使用-号可重复执行该命令"><a href="#执行某个命令后使用-号可重复执行该命令" class="headerlink" title="执行某个命令后使用 . 号可重复执行该命令"></a><span class="tips">执行某个命令后使用 . 号可重复执行该命令</span></h5><div class="code">如：dd 删除光标当前所在行后之后每使用一次 . 会删除一行</div><h5 id="运用举例"><a href="#运用举例" class="headerlink" title="运用举例"></a>运用举例</h5><div class="show">利用可视块将多行文本改为注释(注释符号为:#)执行步骤1. 移动光标到要添加注释的第一行代码，使用^定位到行首2. 使用Ctrl+v进入可视块模式3. 使用I进入编辑模式,并输入#。注：可视块模式下使用i插入无效4. 输入完毕后esc返回命令模式，vim会把选中的每一行文本前都插入#</div><div class="broadcast color-red"><div class="iconfont icon-gantanhao">注意</div>重复执行只对部分命令有效，而对如 u(撤销)命令无效，vim依旧会重复执行u 命令前执行的命令。</div><h3 id="末行模式下的命令"><a href="#末行模式下的命令" class="headerlink" title="末行模式下的命令"></a>末行模式下的命令</h3><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>末行命令主要用于文件的保存、退出、搜索与替换，以及浏览、新建、另存文件等操作</p><ul><li><span class="strong">:e.&emsp;&emsp;打开内置文件浏览器，浏览当前目录下的文件</span></li><li><span class="strong">:e 文件名&emsp;&emsp;打开另外一个文件并切换到其中</span>(edit)</li><li><span class="strong">:e!&emsp;&emsp;放弃对所有文件的修改，恢复文件到上次保存的位置</span></li><li><span class="strong">:n 文件名&emsp;&emsp;新建文件</span>(new)</li><li><span class="strong">:w 文件名&emsp;&emsp;保存当前文件修改到对应文件中(没有时会新建)</span>(write)</li><li><span class="strong">:saveas 文件名 &emsp;另存为新文件</span></li><li><span class="strong">:bn&emsp;切换到上一个文件</span>(打开多个文件时)</li><li><span class="strong">:bp&emsp;切换到下一个文件</span>(打开多个文件时)</li></ul><p>切换文件时若当前文件未保存时不能切换，但可用!强制执行。文件另存为操作不会将编辑界面跳转到新另存的文件里，依旧会在当前文件编辑界面中。</p><p>输入文件名时，输入部分文件名后按下<span class="tips">Tab</span>键，vim会提示文件名</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ul><li><span class="strong">:set nu&emsp;&emsp;显示行号</span></li><li><span class="strong">:set nonu&emsp;&emsp;取消行号显示</span></li><li><span class="strong">:数字&emsp;&emsp;定位到对应的行</span></li><li><span class="strong">:set ic&emsp;&emsp;不区分大小写</span></li><li><span class="strong">:set noic&emsp;&emsp;区分大小写</span></li></ul><h3 id="分屏命令"><a href="#分屏命令" class="headerlink" title="分屏命令"></a>分屏命令</h3><h4 id="分屏打开多个文件"><a href="#分屏打开多个文件" class="headerlink" title="分屏打开多个文件"></a>分屏打开多个文件</h4><ul><li><span class="strong">vim -On 文件名1 文件名2 ...&emsp;&emsp;横向分屏打开文件，从左到右依次显示</span></li><li><span class="strong">vim -on 文件名1 文件名2 ...&emsp;&emsp;竖向分屏打开文件，从上到下依次显示</span></li></ul><h4 id="拆分当前屏幕"><a href="#拆分当前屏幕" class="headerlink" title="拆分当前屏幕"></a>拆分当前屏幕</h4><p>方便同时编辑、浏览多个文件</p><ul><li><span class="strong">:sp [文件名]&emsp;&emsp;增加横向分屏</span>(split)</li><li><span class="strong">:vsp [文件名]&emsp;&emsp;增加竖向分屏</span>(vertical split)</li></ul><p>可以不跟文件名，当无文件名时分屏命令会将当前文件也显示在分屏上。输入文件名忘记全称时，使用<span class="tips">Tab</span>键，vim会提示文件名</p><p>上述命令不添加文件名时，功能同如下两个命令，但下面两个命令使用前需先执行<span class="tips">Ctrl+w</span>命令</p><ul><li>s&emsp;&emsp;上下屏幕同时显示当前文件</li><li>v&emsp;&emsp;左右屏幕同时显示当前文件</li></ul><h4 id="切换分屏窗口"><a href="#切换分屏窗口" class="headerlink" title="切换分屏窗口"></a>切换分屏窗口</h4><p>切换分屏窗口都是基于<span class="tips">Ctrl+w</span>命令，使用下述命令前都要先执行该命令。</p><h5 id="光标在分屏窗口中切换"><a href="#光标在分屏窗口中切换" class="headerlink" title="光标在分屏窗口中切换"></a>光标在分屏窗口中切换</h5><ul><li><span class="strong">w&emsp;&emsp;按顺序切换到下一个窗口</span>(window)(从上到下从左到右)</li><li><span class="strong">W&emsp;&emsp;逆顺序切换到下一个窗口</span>(window)(从下到上从右到左)</li><li><span class="strong">h&emsp;&emsp;切换到左边的窗口</span></li><li><span class="strong">l&emsp;&emsp;切换到右边的窗口</span></li><li><span class="strong">j&emsp;&emsp;切换到下面的窗口</span></li><li><span class="strong">k&emsp;&emsp;切换到上面的窗口</span></li></ul><h5 id="移动分屏窗口"><a href="#移动分屏窗口" class="headerlink" title="移动分屏窗口"></a>移动分屏窗口</h5><ul><li><span class="strong">r&emsp;&emsp;按顺序互换窗口</span>(reverse)</li><li><span class="strong">R&emsp;&emsp;逆顺序互换窗口</span>(reverse)</li><li><span class="strong">H&emsp;&emsp;将当前分屏移动到左边</span></li><li><span class="strong">L&emsp;&emsp;将当前分屏移动到右边</span></li><li><span class="strong">J&emsp;&emsp;关将当前分屏移动到下面</span></li><li><span class="strong">K&emsp;&emsp;将当前分屏移动到上面</span></li></ul><p>以从上到下的窗口分布为例，将7个窗口比作7个楼层，按顺序互换窗口指顶楼7楼变6楼，6楼变5楼，依次往下，而1楼移动到7楼变成顶楼。而当4楼还分割了左右多个窗口时，无法将窗口上下移动，使用命令vim报错。但仍可以将光标切换到4楼以后，在4楼内部移动4楼分割的左右窗口。</p><p>窗口左右分布时类似，窗口可以在左右间移动，而某个窗口内部还分割了上下窗口时，使用命令报错。逆顺序类似，移动方向相反。</p><h5 id="关闭分屏"><a href="#关闭分屏" class="headerlink" title="关闭分屏"></a>关闭分屏</h5><ul><li><span class="strong">c&emsp;&emsp;关闭当前窗口，只剩一个时无法使用</span>(close)</li><li><span class="strong">q&emsp;&emsp;关闭当前窗口，只剩一个时退出vim</span>(quit)</li><li><span class="strong">o&emsp;&emsp;关闭其他窗口</span>(other)</li></ul><h3 id="标签-tab"><a href="#标签-tab" class="headerlink" title="标签(tab)"></a>标签(tab)</h3><p>标签类似于在浏览器中打开多个网页,会在窗口顶部列出各个标签,标签相当于一个vim</p><ul><li><span class="strong">:tabnew [标签名]&emsp;&emsp;创建一个对应名字的新标签</span>(标签名省略时创建一个无名标签)</li><li><span class="strong">:tabc&emsp;&emsp;关闭当前标签</span></li><li><span class="strong">:tabn&emsp;&emsp;切换到下一个标签</span></li><li><span class="strong">:tabp&emsp;&emsp;切换到上一个标签</span></li><li><span class="strong">:tabs&emsp;&emsp;查看一共有几个标签</span></li><li><span class="strong">gt&emsp;&emsp;依次在标签间切换</span>(在命令模式下)</li><li><span class="strong">数字gt&emsp;&emsp;切换到对应顺序的标签中</span></li></ul><h3 id="执行Linux命令"><a href="#执行Linux命令" class="headerlink" title="执行Linux命令"></a>执行Linux命令</h3><ul><li><span class="strong">:!Linux命令&emsp;&emsp;让vim执行Linux命令</span>(执行完Enter会返回文件)</li><li><span class="strong">:r&nbsp;!Linux命令&emsp;&emsp;让vim执行Linux命令并添加执行结果到光标处</span></li></ul><h3 id="定义字符串快捷输入-ab"><a href="#定义字符串快捷输入-ab" class="headerlink" title="定义字符串快捷输入(ab)"></a>定义字符串快捷输入(ab)</h3><p>用于需要频繁输入某个长字符串时，使用一个较短的字符串快速打出该长字符串</p><ul><li><span class="strong">:ab 短字符 长字符串&emsp;&emsp;定义一个长字符串快捷输入</span></li></ul><div class="show" style="word-break: break-all;"><code>如：当需要频繁输入邮箱时，可以用一个短字符串定义邮箱地址:ab gmail sheiyoubingbayouxiangxiezhemechang@Gmail.com之后只需输入gmail空格或者回车，vim会自动补全该长字符串</code></div><h3 id="使用寄存器"><a href="#使用寄存器" class="headerlink" title="使用寄存器"></a>使用寄存器</h3><p>使用复制粘贴时，vim是将内容缓存在寄存器中。用户可以自定义寄存器，vim中使用<span class="tips">“字母</span>来定义一个该字母(大小写均可)命名的寄存器，寄存器后往往加上具体命令，空定义寄存器无效。</p><ul><li><span class="strong">"字母yy&emsp;&emsp;复制当前行到该寄存器中</span></li><li><span class="strong">"字母p&emsp;&emsp;从该寄存器中取出内容并粘贴</span></li><li><span class="strong">:reg&emsp;&emsp;列出所有寄存器</span></li><li><span class="strong">:reg 字母&emsp;&emsp;查看对应寄存器中内容</span></li><li><span class="strong">“”&emsp;&emsp;定义一个无名寄存器</span>(使用复制粘贴时vim启用的是该寄存器)</li></ul><h3 id="定义快捷键"><a href="#定义快捷键" class="headerlink" title="定义快捷键"></a>定义快捷键</h3><p>自定义一个用于某个操作的快捷键</p><ul><li><span class="strong">:map key value&emsp;&emsp;使用快捷键key快速执行value的步骤</span></li></ul>快捷键通常使用<span class="tips">Ctrl+某个不冲突的按键</span>，而定义时该组合按键时需要通过<span class="tips">Ctrl+v+该按键</span>来输入<div class="show" style="word-break: break-all;"><code>如：将某行代码注释掉输入的命令为 :map Ctrl+v+/ I#&lt;esc&gt;命令就会定义Ctrl+/为快捷键,执行的操作为:在行首插入(I的功能)#号,然后esc退出编辑模式,即以后只需要按下Ctrl+/就可以在当前行首插入#号把当前行注释掉(同vscode里的注释快捷键)</code></div><div class="broadcast color-purple"><div class="iconfont icon-fengche"></div>:map 命令的应用很广</div><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>vim还有其他诸如宏定义、运用插件等能显著提升效率和编程体验的功能，再展开文章就显得有点冗长了，边写边设计样式人麻了，文中可能存在错误。</p>]]></content>
    
    
    <summary type="html">vim是一款功能强大的文本编辑器，被广泛内置于类unix操作系统中，并且很多IDE都支持vim插件。vim可以让我们可以很方便地在Linux各种发行版中编写文件，修改系统配置</summary>
    
    
    
    
    <category term="Linux" scheme="https://shiwei11.github.io/blog/tags/Linux/"/>
    
    <category term="vim" scheme="https://shiwei11.github.io/blog/tags/vim/"/>
    
  </entry>
  
</feed>
