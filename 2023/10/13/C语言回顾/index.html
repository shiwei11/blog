<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="shiwi"><meta name="copyright" content="SHIWIVI"><link rel="shortcut icon" href="/blog/images/favicon.ico" type="image/x-icon"><style>.preload{position:absolute;display:flex;flex-direction:column;align-items:center;justify-content:center;left:0;top:0;width:100%;height:100%;background-color:#000;z-index:100}.text{margin-bottom:10px;color:#00cff3;text-shadow:0 0 3px #00cff3;font-size:20px}.text span{display:inline-block}.dance{animation:dance .8s linear}.text span:nth-child(1){animation-delay:0s}.text span:nth-child(2){animation-delay:.1s}.text span:nth-child(3){animation-delay:.2s}.text span:nth-child(4){animation-delay:.3s}.text span:nth-child(5){animation-delay:.4s}.text span:nth-child(6){animation-delay:.5s}.text span:nth-child(7){animation-delay:.6s}.text span:nth-child(8){animation-delay:.7s}.text span:nth-child(9){animation-delay:.8s}.text span:nth-child(10){animation-delay:.9s}@keyframes dance{0%{transform:translateY(0)}50%{transform:translateY(-20px)}100%{transform:translateY(0)}}.loading{width:80%;max-width:260px;height:6px;background-color:#e1e4e8;border-radius:6px}.bar{display:flex;height:100%;background:linear-gradient(90deg,#ffd33d,#ea4aaa 10%,#b34bff 30%,#01feff 51%,#ffb33d 68%,#ea4aaa 85%,#b34bff);background-size:300% 100%;animation:bar 2s linear infinite}@keyframes bar{0%{background-position:100%}100%{background-position:0}}</style><body><div class="preload"><div class="text"><span>L</span> <span>o</span> <span>a</span> <span>d</span> <span>i</span> <span>n</span> <span>g</span> <span>.</span> <span>.</span> <span>.</span></div><div class="loading"><span class="bar"></span></div></div><script>let texts=document.querySelector('.text').querySelectorAll('span');let timer=setInterval(()=>{texts.forEach((item)=>{item.classList.toggle("dance")})},1700);window.onload=function(){clearInterval(timer);document.querySelector('.preload').style="display:none;"}</script><title>SHIWIVI-文章</title>
<link rel="stylesheet" href="https://at.alicdn.com/t/font_2856826_bu73u0ahu7a.css">

<link rel="stylesheet" href="/blog/css/index.css">
<link rel="stylesheet" href="/blog/css/article.css">
<link rel="stylesheet" href="/blog/css/atelier-cave.min.css">

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blog/atom.xml" title="SHWIVI's blog" type="application/atom+xml">
</head>
<body>
<div class="nav">
    <div class="card">
        <div class="head">
            <img src="/blog/images/head.jpg"  alt="头不见了.." title="狗">
        </div>
        <div class="cardText">
            <p>(ー`´ー)</p>
            <p>那不是bug，是彩蛋</p>
        </div> 
    </div>
    <ul class="label">
        
        <li><a href="/blog/index.html">首页</a></li>
        
        <li><a href="/blog/life">日常</a></li>
        
        <li><a href="/blog/record">一句</a></li>
        
        <li><a href="/blog/message">留言</a></li>
        
        <li><a href="/blog/about">关于</a></li>
          
    </ul>
        <ul class="tag">
            <li><a href="/blog/tags/Command">#Command</a></li>
            <li>#Java</li>
            <li>#css</li>
            <li>#Life</li>
            <li>#Lua</li>
            <li>#PCB</li>
            <li>#Shell</li>
            <li>#C</li>
            <li>#html</li>
            <li>#硬件</li>
            <li>#JavaScript</li>
            <li>#Firewall</li>
            <li>#Security</li>
            <li><a href="/blog/tags/Linux">#Linux</a></li>
            <li>#Python</li>
            <li>#Serve</li>
            <li>#Web</li>
        </ul>
    <div class="rsstag"><a href="/blog/atom.xml"><span class="iconfont icon-rss"></span>RSS订阅</a></div>
<div class="flower">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="84.6px" height="70.5px" viewBox="0 0 254 212" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>窗</title>
<desc>Created with Sketch.</desc>
<defs></defs>
<g id="植物" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
    <g id="Artboard" transform="translate(-885.000000, -503.000000)">
        <g id="植物-紫色盆" transform="translate(882.000000, 500.000000)">
            <ellipse id="Oval-12" fill="#B3B7C7" cx="140.5" cy="137" rx="39.5" ry="6"></ellipse>
            <g id="Group-5">
                <path d="M131.5,149 C137.746054,149 138.400559,136.953074 140.297813,118.503702 C141.504079,106.77367 149.145158,88.1140929 147,75 C142.297813,46.2539062 153.271934,32.5660626 150.170125,19.4282488 C148.031314,10.3692495 142.862042,3 131.5,3 C123.603887,3 113.698654,6.59314895 110.722909,11.2157433 C103.206874,22.8913341 114,46.5137576 114,75 C114,90.4435309 122.495151,106.751425 123.699377,118.476362 C125.595832,136.941172 125.250862,149 131.5,149 Z" id="Oval-11" fill="#BAC4F6"></path>
                <path d="M135.5,146.5 C132.598908,121.877878 130.965369,104.566553 130.599381,94.5660242 C130.050399,79.5652312 132.963841,77.0580598 132.164069,55.3464601 C131.630888,40.8720602 130.242865,30.4232402 128,24" id="Line-15" stroke="#FFFFFF" stroke-width="2" opacity="0.800892857" stroke-linecap="square"></path>
                <path d="M77.0442201,163.336077 C84.2239219,163.336077 101.067658,131.237823 101.067658,92.025606 C101.067658,52.8133888 90.9057581,-2.32627732 72.6560979,17.2440872 C50.0508064,41.4852946 69.5871262,36.5862429 74.0442201,63.8595149 C75.572858,73.2133576 77.0442201,94.5993942 77.0442201,104.613421 C77.0442201,143.825638 69.8645184,163.336077 77.0442201,163.336077 Z" id="Oval-9" fill="#BAC4F6" transform="translate(81.510722, 88.251316) rotate(-43.000000) translate(-81.510722, -88.251316) "></path>
                <path d="M42.5,50.5 C47.5132933,48.8699207 59.3816332,57.6317857 78.1050199,76.785595 C96.8284065,95.9394043 113.960067,116.844206 129.5,139.5" id="Line-17" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M155.281006,152.144255 C162.116643,152.144255 178.153197,121.584207 178.153197,84.2511084 C178.153197,72.6051871 184.354199,51.8242671 182.531201,39.8465879 C178.51025,13.4276595 163.058175,0.233079666 151.10317,13.0532528 C129.581164,36.1327785 143.297279,29.7382802 147.540781,55.7045685 C148.996164,64.6101585 153.500382,80.3852665 153.500382,89.9194035 C153.500382,127.252502 148.445368,152.144255 155.281006,152.144255 Z" id="Oval-9-Copy-2" fill="#E9EDFD" transform="translate(161.092971, 80.123972) scale(-1, 1) rotate(-20.000000) translate(-161.092971, -80.123972) "></path>
                <path d="M180.5,34.5 C181.290102,21.4892162 175.746138,28.9223292 163.868108,56.7993391 C157.546037,71.6368512 150.532373,85.3308057 144.827114,101.881203 C141.023608,112.914801 138.581237,128.787733 137.5,149.5" id="Line-20" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M60.3426107,183.894782 C69.2498271,183.894782 90.1463498,156.072081 90.1463498,122.083011 C90.1463498,88.0939419 67.5408019,29.4364067 54.8986583,57.2625442 C45.0326912,78.978146 51.0912584,74.0282851 56.6207779,97.6687014 C58.5172227,105.776593 67.8616068,124.363423 67.8616068,133.043561 C67.8616068,167.032631 51.4353942,183.894782 60.3426107,183.894782 Z" id="Oval-9-Copy" fill="#BAC4F6" transform="translate(69.895982, 116.944107) rotate(-71.000000) translate(-69.895982, -116.944107) "></path>
                <path d="M24.5,109.5 C22.4991751,103.669523 35.0833631,105.49608 62.2525641,114.979669 C79.4278854,120.974828 92.103247,119.378882 106.278649,126.191831 C111.777518,128.834684 120.517968,134.937407 132.5,144.5" id="Line-19" stroke="#FFFFFF" stroke-width="2" opacity="0.595424107" stroke-linecap="square"></path>
                <path d="M169.495543,159.559977 C178.40276,159.559977 199.299282,131.737276 199.299282,97.7482062 C199.299282,85.7856682 202.004463,66.329956 197.824033,53.1018748 C190.126639,28.745108 172.2443,14.8950801 164.051591,32.9277389 C154.185624,54.6433407 160.244191,49.6934798 165.77371,73.3338961 C167.670155,81.4417878 177.014539,100.028618 177.014539,108.708756 C177.014539,142.697825 160.588327,159.559977 169.495543,159.559977 Z" id="Oval-9-Copy-3" fill="#BAC4F6" transform="translate(179.479352, 92.134636) scale(-1, 1) rotate(-43.000000) translate(-179.479352, -92.134636) "></path>
                <path d="M213.5,60.5 C209.183273,60.8948914 201.740861,65.4428024 191.172763,74.1437328 C175.320617,87.1951284 177.797205,83.2393994 161.560337,103.262986 C150.735758,116.612043 142.715646,131.024381 137.5,146.5" id="Line-21" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M81.1425752,168.630026 C85.1025169,165.536181 98.2051544,147.96348 98.2051544,111.236918 C98.2051544,74.5103552 86.0176544,46.7369177 70.0176544,46.7369177 C54.0176544,46.7369177 59.5351666,70.3889964 66.8400325,93.0530589 C69.6371249,101.731312 78.9791535,122.814465 81.0032985,132.88325 C84.2653955,149.110029 78.6989273,170.539213 81.1425752,168.630026 Z" id="Oval-10" fill="#E9EDFD" transform="translate(78.936475, 107.743055) rotate(-52.000000) translate(-78.936475, -107.743055) "></path>
                <path d="M39.5,84.5 C46.5402399,84.832105 55.9862242,87.7506309 67.8379528,93.2555776 C85.6155457,101.512998 79.9127462,96.6348296 100.298442,112.739947 C113.888906,123.476691 125.956092,135.063376 136.5,147.5" id="Line-18" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M194.823347,177.534556 C197.785465,175.220296 209.085075,165.125173 213.530819,146.109724 C215.496552,137.701844 211.555235,124.000271 211.555235,111.853141 C211.555235,72.2337887 199.639103,43.8487815 182.378853,43.8487815 C165.118604,43.8487815 168.053621,58.2764613 175.933859,82.7256721 C183.814096,107.174883 191.693317,118.61017 193.876895,129.472028 C197.395933,146.976919 192.187224,179.594121 194.823347,177.534556 Z" id="Oval-10-Copy-2" fill="#E9EDFD" transform="translate(191.881132, 110.738214) scale(-1, 1) rotate(-52.000000) translate(-191.881132, -110.738214) "></path>
                <path d="M237.5,84.5 C231.839918,82.6252532 222.387737,84.7837206 209.143456,90.9754021 C189.277034,100.262925 198.344222,96.9653923 174.587666,113.911421 C158.749962,125.208774 147.387407,137.071634 140.5,149.5" id="Line-22" stroke="#FFFFFF" stroke-width="2" opacity="0.785044643" stroke-linecap="square"></path>
                <path d="M102.095097,154.049614 C106.979303,150.233654 123.140143,128.559423 123.140143,83.2607523 C123.140143,37.9620813 108.108037,3.70622602 88.3735811,3.70622602 C68.639125,3.70622602 75.4444439,32.8787829 84.4542911,60.8327171 C87.9042347,71.5365054 99.4267255,97.5405402 101.923313,109.959415 C105.946795,129.97358 99.0810936,156.404412 102.095097,154.049614 Z" id="Oval-10-Copy" fill="#E9EDFD" transform="translate(99.374086, 78.951409) rotate(-21.000000) translate(-99.374086, -78.951409) "></path>
                <path d="M70.5,27.5 C77.9697854,36.2141564 84.664658,44.2949462 90.5846178,51.7423694 C99.4645574,62.9135043 102.309139,65.8595669 108.078018,74.773869 C113.846897,83.6881711 108.232283,69.1486166 118.500716,94.8794382 C125.346337,112.033319 129.012765,128.573507 129.5,144.5" id="Line-16" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M193.001521,189.153265 C198.929205,189.153265 212.83568,162.652399 212.83568,130.278124 C212.83568,97.9038493 204.210737,49.7003434 189.378612,68.5372278 C174.540517,87.3816949 180.150684,86.5530431 183.830536,109.070321 C185.092606,116.793013 193.001521,132.403088 193.001521,140.670839 C193.001521,173.045114 187.073837,189.153265 193.001521,189.153265 Z" id="Oval-9-Copy-4" fill="#BAC4F6" transform="translate(196.248002, 126.727326) scale(-1, 1) rotate(-73.000000) translate(-196.248002, -126.727326) "></path>
                <path d="M234.5,116.5 C229.435614,115.997419 220.043174,117.148484 206.322678,119.953197 C185.741934,124.160265 185.201799,123.9696 168.145826,131.063968 C156.775178,135.793546 148.226569,140.93889 142.5,146.5" id="Line-23" stroke="#FFFFFF" stroke-width="2" opacity="0.733426339" stroke-linecap="square"></path>
            </g>
            <g id="Group-4" transform="translate(101.000000, 137.000000)">
                <path d="M0,0 C11.7955729,2 24.5052083,3 38.1289062,3 C51.7526042,3 65.3763021,2 79,0 L71.2109375,75.3409091 C61.9375,77.1136364 51.8945312,78 41.0820312,78 C30.2695313,78 19.4570312,77.1136364 8.64453125,75.3409091 L0,0 Z" id="Rectangle-9" fill="#FCDCCF"></path>
                <path d="M59.2621996,2.19791001 C63.6483775,1.86496527 70.2276443,1.1323286 79,0 L71.2109375,75.3409091 C63.3055851,76.5844933 57.2271178,77.3450382 52.9755357,77.6225437 L59.2621996,2.19791001 Z" id="Rectangle-9" fill="#ECC6B6"></path>
                <path d="M0,0 C10.9588352,1.33333333 23.3572727,2 37.1953125,2 C51.0333523,2 64.9682481,1.33333333 79,0 L76.7909585,21.3672948 L40.573652,23.0934676 L2.38711382,20.8047516 L0,0 Z" id="Rectangle-9" fill="#F3B096"></path>
            </g>
        </g>
    </g>
</g>
</svg>
</div>

</div>
<div class="menuBtn closed"> 
    <div class="menu-line"></div>
    <div class="menu-line"></div>
    <div class="menu-line"></div>
</div>
<div class="nightSky"><!--当关闭夜间背景模式时，子元素将在一段延时后才会被清除--></div>
<div class="main">
    <div class="msg">
        <div class="msgText"></div>
        <div class="msgBar"></div>
    </div>
    <div class="motto">
        <p> //sunny forever<br />
            while(life&lt;end){<br />
               love++;<br />
               beAwesome :)} </p>
     </div>
     <div class="mainContent">
    <div class="canvasWrapper"></div>
<div class="setWrapper">
    <ul class="setMenu">
        <div id="setBtn" class="setButton"><</div>
        <li class="searchContainer">
            <input id="searchInput" class="localSearch" placeholder="搜索..." type="search" >
            <span class="searchIco"></span>
        </li>
        <li id="toggleItem">
        主题：<span class="itemIco sun"></span>
        </li>
        <li class="setSize">
            <span id="increaseFontSize">+</span>
            <span class="fontSizeNum"></span>
            <span id="reduceFontSize">-</span>
        </li>
        <li id="clearBack">清除背景</li>
        <li id="disableBack">禁用背景</li>
    </ul> 
</div>
    <div class="resultContainer">
        <div id="searchResult" class="displayResult"></div>
    </div>
    <div class="tocWrapper"><div class="tocBtn">目 录</div><div class="tocBox"><!--tocBox用于容纳生成在toc外的目录--><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">发展历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">编译流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">C语言内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E5%8C%BA-Reserved"><span class="toc-number">1.3.1.</span> <span class="toc-text">保留区(Reserved)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8C%BA-Code-Text"><span class="toc-number">1.3.2.</span> <span class="toc-text">代码区(Code&#x2F;Text)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8C%BA-Static"><span class="toc-number">1.3.3.</span> <span class="toc-text">静态区(Static)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86-Heap"><span class="toc-number">1.3.4.</span> <span class="toc-text">堆(Heap)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%AE%B5-mmap"><span class="toc-number">1.3.5.</span> <span class="toc-text">内存映射段(mmap)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88-Stack"><span class="toc-number">1.3.6.</span> <span class="toc-text">栈(Stack)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E6%AE%B5%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.7.</span> <span class="toc-text">各段生成时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">预处理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#include%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="toc-number">2.1.</span> <span class="toc-text">#include文件包含</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#define-%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">#define 宏定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">2.3.</span> <span class="toc-text">条件编译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">标识符命名规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">变量的作用域和生存期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">变量的存储类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#auto%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">auto自动变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">static静态变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#extern%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">extern外部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#register%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.4.</span> <span class="toc-text">register寄存器变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E8%A7%88"><span class="toc-number">4.1.</span> <span class="toc-text">数据类型总览</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">构造类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">其他类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.</span> <span class="toc-text">字符数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88"><span class="toc-number">5.2.</span> <span class="toc-text">字符指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">5.3.</span> <span class="toc-text">字符串的输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-number">5.4.</span> <span class="toc-text">字符串的输入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">6.</span> <span class="toc-text">构造类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.1.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.2.</span> <span class="toc-text">二维数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">7.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">结构体定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%88%90%E5%91%98%E5%BC%95%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">结构体变量初始化与成员引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">结构体所占内存字节数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-number">7.4.</span> <span class="toc-text">结构体数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">7.5.</span> <span class="toc-text">指向结构体的指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">8.</span> <span class="toc-text">共用体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">9.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">指针定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">10.2.</span> <span class="toc-text">指针与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">10.2.1.</span> <span class="toc-text">常用的指针变量运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">10.2.2.</span> <span class="toc-text">数组元素的遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">10.3.</span> <span class="toc-text">指针与函数传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">10.4.</span> <span class="toc-text">二维数组与指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%BC%95%E7%94%A8-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">10.4.1.</span> <span class="toc-text">二维数组元素的引用(指针变量)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">10.5.</span> <span class="toc-text">指向函数的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.</span> <span class="toc-text">返回指针的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">10.7.</span> <span class="toc-text">指针数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">10.8.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-%E6%97%A0%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">10.9.</span> <span class="toc-text">void * 无类型指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8Emain%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="toc-number">10.10.</span> <span class="toc-text">指针数组与main函数的形参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">11.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-number">11.1.</span> <span class="toc-text">运算符优先级与结合性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC"><span class="toc-number">11.2.</span> <span class="toc-text">赋值与复合赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F"><span class="toc-number">11.3.</span> <span class="toc-text">自增与自减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.4.</span> <span class="toc-text">逗号表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">11.5.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">11.6.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">11.7.</span> <span class="toc-text">逻辑运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.8.</span> <span class="toc-text">条件运算(三元表达式)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">选择与循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.1.</span> <span class="toc-text">选择语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#switch%E5%A4%9A%E5%88%86%E6%94%AF%E9%80%89%E6%8B%A9"><span class="toc-number">12.1.1.</span> <span class="toc-text">switch多分支选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#break%E4%B8%8Econtinue"><span class="toc-number">12.1.2.</span> <span class="toc-text">break与continue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#goto%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.1.3.</span> <span class="toc-text">goto语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">标准输入输出函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#printf%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.1.</span> <span class="toc-text">printf输出函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#scanf%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.2.</span> <span class="toc-text">scanf输入函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#putchar-%E4%B8%8Egetchar"><span class="toc-number">13.2.3.</span> <span class="toc-text">putchar()与getchar()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.</span> <span class="toc-text">自定义函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">13.3.1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">13.3.2.</span> <span class="toc-text">函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">13.3.3.</span> <span class="toc-text">函数声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-number">13.4.</span> <span class="toc-text">内部函数与外部函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">14.</span> <span class="toc-text">类型限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">14.1.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">14.1.1.</span> <span class="toc-text">const修饰变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E6%95%B0%E7%BB%84"><span class="toc-number">14.1.2.</span> <span class="toc-text">const修饰数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.1.3.</span> <span class="toc-text">const修饰复合类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8Econst%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">14.1.4.</span> <span class="toc-text">指针与const类型限定符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-number">14.2.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#restrict"><span class="toc-number">14.3.</span> <span class="toc-text">restrict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Atomic"><span class="toc-number">14.4.</span> <span class="toc-text">_Atomic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">15.</span> <span class="toc-text">动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">15.1.</span> <span class="toc-text">内存空间申请与释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">16.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">16.1.</span> <span class="toc-text">二进制文件与文本文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="toc-number">16.2.</span> <span class="toc-text">文件指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">16.3.</span> <span class="toc-text">文件的打开与关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fopen-%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.1.</span> <span class="toc-text">fopen()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fclose-%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.2.</span> <span class="toc-text">fclose()函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">16.4.</span> <span class="toc-text">文件的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%86%99"><span class="toc-number">16.4.1.</span> <span class="toc-text">按字符读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%BB%E5%86%99"><span class="toc-number">16.4.2.</span> <span class="toc-text">按字符串读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E6%A0%BC%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">16.4.3.</span> <span class="toc-text">按格式读写文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E6%95%B0%E6%8D%AE%E5%9D%97%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">16.4.4.</span> <span class="toc-text">按数据块读写文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%BB%E5%86%99putw-%E5%92%8Cgetw"><span class="toc-number">16.4.5.</span> <span class="toc-text">数字读写putw()和getw()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="toc-number">16.5.</span> <span class="toc-text">文件定位</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE%E6%8C%87%E9%92%88rewind"><span class="toc-number">16.5.1.</span> <span class="toc-text">重置位置指针rewind()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%8C%87%E9%92%88%E4%BD%8D%E7%BD%AEfseek"><span class="toc-number">16.5.2.</span> <span class="toc-text">指定指针位置fseek()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E4%BD%8D%E7%BD%AEftell"><span class="toc-number">16.5.3.</span> <span class="toc-text">返回指针位置ftell()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">16.6.</span> <span class="toc-text">文件状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">16.7.</span> <span class="toc-text">输入输出重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">C语言中的随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">18.</span> <span class="toc-text">常用函数和头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">18.1.</span> <span class="toc-text">字符与字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">18.2.</span> <span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">18.3.</span> <span class="toc-text">其他常用函数</span></a></li></ol></li></ol></div></div>
        <div class="article">
        <h1 class="title">C语言</h1>
        <div class="art-info">
            <div><span><span class="iconfont icon-zishu-jzl"></span>字数：72455</span>
            <span><span class="iconfont icon-riqi"></span>写于：2023-10-13</span></div>
            <div><span><span class="iconfont icon-zuixinnew3"></span>最新更新：2023-12-13</span>
            <span><span class="iconfont icon-shijian"></span>阅读本文预计花费您208分钟</span></div>
        </div>
        <div class="art-content">
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><div class="contentFolded">在计算机诞生初期，人们使用<span class="strong">机器语言</span>来编写程序，机器语言的指令由操作码和操作数组成，均使用二进制代码表示，而二进制则通过在纸带上打孔来表示0或1，程序员将编写的机器语言指令打在纸带上并通过纸带机输入计算机中，以此进行运算。机器语言虽然能被计算机直接执行，但对人类来说难以阅读和记忆，不便编写。

<p>为了简化机器语言的编写，1950年代中期，<span class="strong">汇编语言</span>应运而生。它使用助记符（mnemonic）来表示机器指令，极大地提高了程序员的工作效率。即便如此，书写和调试一个程序也需要用很长时间，并且需要程序员详细了解编写代码需要的指令、寄存器和CPU知识。</p>
<p>为了解决这些问题，IBM公司的一个研究小组开始着手研究一门能高效运行且简单易用的编程语言。1956年，IBM公司的John Backus带领他的团队开发出了世界上第一个<span class="strong">高级语言</span><span class="tips">FORTRAN</span>(FORmula TRANslation，意为公式翻译)，在科学和工程计算领域取得了很大成功，但该语言是专门为IBM 704计算机设计的，只能在特定型号的机器上工作。</p>
<p>为了解决这一问题，GAMM(德国应用数学和力学学会)、IBM、Datatron等公司要求ACM评估一种能脱离机器型号限定的“通用编程语言”。1958年5月，在美国计算机科学家Alan Jay Perlis的领导下，ACM、GAMM等代表在苏黎世会议上成立了IAL算法语言委员会，制定了国际算法语言(International Algorithmic Language,IAL)的定义并发布了IAL58语言。随后，ACM推崇IAL作为编程语言的标准，该算法语言由各种不同的“关键字”和“表达式”按照一定的语法规则组成，脱离了指令系统成为更接近人类的语言系统，编写者不必懂得完整的计算机的内部结构和工作原理也可以很好编写程序。</p>
<p>1959年，IAL被重新命名为ALGOL(算法语言)。</p>
<p>1960年，ALGOL算法语言委员会发布了<span class="tips">ALGOL 60</span>，里程碑式地引入了<span class="strong">递归</span>、<span class="strong">布尔类型</span>、<span class="strong">块结构</span>等概念，ALGOL 60也成为了后来所有计算机语言语法的鼻祖，Alan Jay Perlis也因此成为了世界首届图灵奖的获得者，以表彰其在 Algol 58 和 Algol 60 的形成和改进过程中的核心和关键作用。但ALGOL 60最大的缺点就是缺乏标准的输入输出能力，ALGOL 60编写的程序无法兼容不同的计算机外部设备，因此ALGOL 60迎来了进一步的迭代。</p>
<p>1963年，剑桥大学基于ALGOL 60发布了<span class="tips">CPL</span>（Combined Programming Langurage）语言，该语言旨在用于工业控制、数据处理等更为广泛的领域，因此规模宏大而复杂，编译器的编写进度十分缓慢，该语言并未大规模流行。</p>
<p>1967年，英国剑桥大学的Matin Richards对CPL语言做了简化，推出了<span class="tips">BCPL</span>(the Basic Combined Programming Language)语言，该语言是最早使用库函数封装基本输入输出的语言之一，主要用于编写系统和编译器，但BCPL对字符串的支持很差，并且内存管理很糟糕。</p>
<p>1969年，美国贝尔实验室的Kenneth Lane Thompson对BCPL语言做了改进和优化，由此衍生出了<span class="tips">B语言</span>，并用于书写<span class="strong">UNIX</span>系统，该语言的名字取自BCPL中的第一个字母，但此时的B语言过于简单，功能有限。</p>
<p>1972年，贝尔实验室的Dennis MacAlistair Ritchie在B语言的基础上设计出了<span class="tips">C语言</span>(取BCPL的第二个字母作为该语言的名字)，C语言保留了BCPL和B语言的优点，简练而接近硬件，又克服了它们无数据类型等缺点。1973年初， C语言的主体完成，汤普森和里奇使用C语言重写了UNIX操作系统，极大地提升了UNIX操作系统的可移植性，而C语言随着UNIX的广泛使用得到了迅速推广，成为了应用最广泛的计算机语言之一。</p>
<p>1983年，美国国家标准化协会(ANSI)制定了C语言标准——<span class="strong">ANSI C</span>，1987年，ANSI又公布了新的标准<span class="strong">87 ANSI C</span>，该标准于1990年被国际标准化组织(Internation Standard Organization)接受成为C语言国际标准——ISO/IEC 9899,简称<span class="strong">C89/C90</span>标准，是C语言的主流标准，被广泛应用于各个领域。1999年，ISO对C语言进行了大量扩展和改进，加入了如long long等新的数据类型，发布了<span class="strong">C99</span>标准，该标准在部分领域使用广泛，但在工业等领域普及度较低。目前最新标准为2018年发布的C17标准，但尚未被广泛使用。</div></p>
<h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><p>C语言源文件以<span class="tips">.c</span>为文件名后缀，从高级语言转换为机器码程需要经过<span class="strong">预处理</span>、<span class="strong">编译</span>、<span class="strong">汇编</span>、<span class="strong">链接</span>四个过程</p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>C语言源文件首先会被预处理，以一个名为hello.c的源文件为例，<span class="tips">hello.c</span>源文件经过预处理器处理，会生成一个<span class="tips">hello.i</span>临时文件，预处理阶段会进行以下工作：</p>
<ul>
<li>删除代码中的所有注释</li>
<li>对宏进行代码扩展，通过<span class="strong">#define</span>等指令定义的常量或表达式，会被替换到文件中，对<span class="strong">#if</span>等条件编译指令限定的代码进行选择性编译</li>
<li>包含文件，通过<span class="strong">#include</span>指令包含的文件，其内容会被添加到源文件中</li>
</ul>
<h6 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h6><p>编译器会将临时文件<span class="tips">hello.i</span>编译为汇编文件<span class="tips">hello.s</span>，该阶段编译器会对代码进行语法检查，并返回源代码中存在的语法错误和警告</p>
<h6 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h6><p>汇编程序将<span class="tips">hello.s</span>汇编文件编译成机器码，在<span class="strong">Windows</span>环境下生成<span class="tips">hello.obj</span>对象文件，在<span class="strong">Linux</span>环境下生成<span class="tips">hello.o</span>目标文件</p>
<h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>链接器会将多个目标文件合并为一个文件，并与库函数文件(.lib)等依赖链接，生成可执行文件，在Windows环境下生成一个可执行文件 hello.exe，在 Linux环境下中生成 hello.out文件</p>
<p>库函数文件由各软件公司编写并已经编译成目标文件(.obj文件)，它们将在链接阶段与源程序编译而成的目标文件(.obj文件)相链接，生成可执行文件。</p>
<h4 id="C语言内存模型"><a href="#C语言内存模型" class="headerlink" title="C语言内存模型"></a>C语言内存模型</h4><p>准确来讲，这是Linux的虚拟空间布局的一部分，Linux系统内核进程和用户进程所占的虚拟内存比是1：3，Windows是2：2，以32位Linux系统为例，模拟一个4GB的内存地址块沙盘，其中高地址位的1GB内存为系统内核进程占用的内核空间，低地址位的3GB内存为用于用户内进程的用户空间，内核空间由操作系统负责维护和处理，因此本文只涉及日常开发中C程序可以操控的3GB用户空间部分。</p>
<p>该虚拟沙盘地址通过页表(Page Table)映射到物理内存，其中，蓝色区域会被映射到物理内存的不同内存段，白色区域只用于虚拟内存地址的分析，不会映射到物理内存中，不占用内存空间</p>
<img src="#" alt="C语言内存" data-src="/blog/images/20240316041218.png" style="max-width:420px;max-height:470px;">

<h5 id="保留区-Reserved"><a href="#保留区-Reserved" class="headerlink" title="保留区(Reserved)"></a>保留区(Reserved)</h5><p>保留区是系统预留且禁止用户进程访问的地址区域，位于虚拟地址空间的最低部分，不赋予物理地址，一般用于捕捉空指针异常等情况。在大多数操作系统中，极小的地址空间通常都是不允许访问的，如NULL、0等。因此C语言也将无效指针赋值为0，因为0地址在正常情况下是不会存放有效的可访问数据的。</p>
<p>在32位X86架构的Linux系统中，系统将预留128MB的保留区，因此用户进程可执行程序一般从虚拟地址空间0x08048000开始加载内存区域。</p>
<h5 id="代码区-Code-Text"><a href="#代码区-Code-Text" class="headerlink" title="代码区(Code/Text)"></a>代码区(Code/Text)</h5><p>用于存放二进制代码，该区域是只读的，以防止恶意程序修改代码区的数据。代码段指令中包括操作码和操作数(操作对象)，如果操作对象是立即数(具体数值)，则该数据将直接包含在代码中；如果是字符串常量、变量中的数据，则将引用该数据地址。</p>
<h5 id="静态区-Static"><a href="#静态区-Static" class="headerlink" title="静态区(Static)"></a>静态区(Static)</h5><p>静态区又称全局区，这部分的空间大小在编译时就已经确定，因此是静态的，静态区分为<span class="strong">只读数据段</span>(RO Data，又称为常量区)、<span class="strong">已初始化数据段</span>(又称为读写数据段，RW Data)和<span class="strong">未初始化数据段</span>(又称为BSS段，Block Started by Symbol)三部分</p>
<ul>
<li><span class="strong">只读数据段(.rodata)：</span>只读，用于存储字符串常量，以及const修饰的只读全局变量(只读局部变量存储于栈区)、只读字符串变量，只读静态变量</li>
<li><span class="strong">已初始化数据段(.data)：</span>可读可写，存储已初始化且初值不为0的全局变量和静态局部变量</li>
<li><span class="strong">未初始化数据段(.bss)：</span>可读可写，存储未初始化或初始化为零的全局变量和静态变量。这些变量在编译阶段会被收集起来放到.bss段中，并在程序初始化时自动赋值为0(对数值型变量)或空字符(对字符变量)。由于.bss段的值全为0，因此这个段只记录段长，在编译-链接生成的可执行文件中不占用物理文件空间(全是0，没必要存储)，能在一定程度上节省磁盘空间。在程序执行(初始化)时，加载器(loader)根据其段长分配相应大小的内存，并将这些内存空间全部初始化为0。因此.bss段不占用物理文件尺寸，但占用内存空间；.data段占用物理文件，也占用内存空间</li>
</ul>
<h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h5><p>由程序员分配释放，如果程序员不释放，则操作系统在程序结束时回收，通过<span class="tips">malloc</span>、<span class="tips">realloc</span>、<span class="tips">calloc</span>语句开辟空间，通过<span class="tips">free</span>释放。</p>
<p>堆内存的增长方向为由低地址向高地址增长，其工作方式类似于数据结构中的<span class="tips">链表</span>。在操作系统中有一个记录空闲内存地址的链表，当使用malloc()等语句开辟内存空间时，操作系统会遍历该链表，寻找第一个空间大于等于所申请空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序，此外，系统会在该空间的首地址处记录所分配的空间大小，以便free语句能正确释放空间。</p>
<p>由于每次分配的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中，频繁的开辟、释放空间势必会造成内存空间的不连续，从而造成大量碎片。</p>
<p>堆空间的大小受限于系统的有效虚拟内存，32位Linux系统中堆内存可达2.9G空间。堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。</p>
<h5 id="内存映射段-mmap"><a href="#内存映射段-mmap" class="headerlink" title="内存映射段(mmap)"></a>内存映射段(mmap)</h5><p>该区域用于映射可执行文件用到的动态链接库到内存中，方便更快速地读取。<br>此外，在Linux中，如果通过malloc()请求一个大的内存空间，C运行库将在该区域创建一个匿名内存映射，而不使用堆内存。</p>
<div class="broadcast color-yellow">
<div class="iconfont icon-dengpao14hao"></div>
内存映射是一种强大的文件I/O技术，用于高效读写文件。它将文件映射到虚拟内存空间中，并且支持按需加载文件，然后通过内存地址来访问文件，从而避免了大量的文件读写操作，比传统的文件读写操作更加快捷方便。
</div>

<h5 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h5><p>栈内存由<span class="tips">编译器</span>负责分配和释放，主要用于存放：</p>
<ul>
<li>函数内部定义的局部自动变量(auto类型)，包括const修饰的只读局部变量</li>
<li>函数参数和返回值</li>
<li>调用函数时的上下文环境，如函数返回地址等</li>
<li>暂存一些算术表达式的计算结果</li>
<li>alloca()函数分配的栈内内存</li>
</ul>
<p>栈内存的增长方向为由高地址向低地址增长，其工作方式与数据结构中的栈相似，即先入后出，且栈分配的内存空间是连续的，不会有碎片化现象。栈是由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多</p>
<p>栈空间的大小由系统预定义(通常默认2M或10M)，当栈剩余空间大于所申请空间时，系统将分配内存，否则将抛出栈溢出(stack overflow)错误</p>
<h5 id="各段生成时间"><a href="#各段生成时间" class="headerlink" title="各段生成时间"></a>各段生成时间</h5><p>在C语言程序编译-链接后生成的映像文件中，将只包含代码段、只读数据段(.rodata)和读写数据段(.data)，双击运行该文件后，程序在初始化时将动态生成未初始化数据段(.bss)，程序的运行过程，将动态生成堆(Heap)和栈(Stack)</p>
<div class="show">char str[]="hello"; //数组末尾会添加'\0'代表存储结束
char * str="hello";
如果它们都是局部变量，则字符数组会在栈区申请空间，并将字符存储在数组空间中；而指针变量，字符串存储在全局区的只读数据段，栈中的指针变量存储的是其字符串在全局区中的地址
如果它们声明为全局变量，则字符数组声明在全局
const 声明的全局变量存储于静态区
const 声明的局部变量存储于栈
const 声明的字符串常量存储于静态区只读区 const char* str="hello"
</div>

<h3 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h3><p>预处理命令是C语言源程序中用于改进程序设计环境、提高编程效率的特殊命令，不属于C语言的组成部分，无法进行编译，只会对其在预处理阶段作出相应处理。预处理命令以<span class="tips strong">#</span>开头，且不以分号结尾，以便与一般的C语言语句区分</p>
<h4 id="include文件包含"><a href="#include文件包含" class="headerlink" title="#include文件包含"></a>#include文件包含</h4><p><span class="strong">文件包含</span>处理指将一个源文件中的内容包含到另一个源文件中，被包含的文件称为<span class="strong">头文件</span>(或标题文件)，文件名常以<span class="tips">.h</span>作为后缀，也可以以<span class="tips">.c</span>作为后缀甚至没有后缀。在编译的预处理阶段，头文件中的内容会被复制到主文件中，替换掉 #include &lt;xxx.h&gt;语句，得到一个新的源文件，再对该文件进行编译。</p>
<ul>
<li><span class="strong">#include &lt;文件名&gt;</span>一般用于包含系统库函数头文件</li>
<li><span class="strong">#include “文件名”</span>一般用于包含用户自己编写的头文件</li>
</ul>
<div class="show">eg:C语言中常用的标准输入输出函数头文件
#include &lt;stdio.h&gt;
// std：standard(标准)，i为input，o为output，将包含标准输入/输出函数的头文件stdio.h包含到源文件中</div>

<p>注意事项：</p>
<ul>
<li>一个#include语句只能包含一个文件，如果要包含多个文件，则只能使用多个语句</li>
<li>使用<span class="tips">&lt;文件名&gt;</span>包含文件时，系统会到存放C语言库函数头文件的路径下寻找该文件，，使用<span class="tips">“文件名”</span>包含文件时，系统会首先在用户当前目录中寻找文件，如果没有，再去C语言库函数路径下</li>
<li>如果A文件包含了B文件，而B文件需要使用C文件中的内容，则可以在A文件中使用两个#include命令同时包含文件B和C，且包含C文件的指令需要出现在包含B文件的指令前。也可以嵌套包含，即B文件包含C文件，A文件包含B文件</li>
<li>A文件包含B文件后，B文件中的内容会在预处理阶段被复制到A文件中，因此B文件中的全局静态变量在A文件中有效，不需要extern声明语句</li>
<li>#include通常用于包含.h头文件，也可以包含其他文本文件，如：源代码文件(.c)、c++的头文件(.hpp或.hxx)、库文件(.lib、.dll、.a等)，甚至可以为.txt文本文件</li>
</ul>
<h4 id="define-宏定义"><a href="#define-宏定义" class="headerlink" title="#define 宏定义"></a>#define 宏定义</h4><p>用一个指定的标识符代表一个字符串，在编译预处理阶段，预处理器会对源代码中的宏名进行<span class="strong">宏展开</span>，即将宏名替换成对应的字符串</p>
<ul>
<li><span class="strong">#define 标识符 字符串</span> 定义无参宏定义</li>
<li><span class="strong">#undef 标识符</span> 终止宏定义</li>
<li><span class="strong">#define 标识符(参数表列) 字符串</span> 定义带参数的宏定义</li>
</ul>
<p>注意事项： </p>
<ol>
<li>宏名一般使用<span class="strong">大写字母</span>表示，以便与普通变量名区分</li>
<li>宏定义只用作字符串替换，与定义普通变量不同，不分配内存空间</li>
<li>宏定义可以嵌套定义</li>
<li>宏定义用于定义符号常量，定义完毕后不能再赋值，也不能被修改</li>
<li>宏定义语句写于函数外，作用范围为宏定义语句之后到本源文件结束，或者到<span class="tips">#undef 宏名</span>行终止</li>
<li>预处理阶段只对宏名进行字符串替换，不作语法准确性检查。如果宏定义中有错误，只有在宏名被宏展开后的编译阶段，编译器对源程序进行语法检查时才会发现宏定义中存在的错误</li>
</ol>
<div class="show"> //无参数宏定义
#include &lt;stdio.h>
#define PI 3.1415926
#define R 4.0
#define L 2*PI*R //嵌套定义宏
int main()
{
    float l=L;
    printf("%f",l);
    return 0;
}
#undef R  //终止R的作用范围
void f1(){....}
</div>
<div class="show"> //带参宏定义
#include &lt;stdio.h>
#define L(r,s) r+s //带多个参数的宏定义
#define M(r) 3*r*r 
#define N(r) 3*(r)*(r)
int main(void){
 int a=1,b=2,result;
 result=L(a,b); //展开为result=a+b;
 result=M(a+b); //展开为result=3*a+b*a+b<span class="tips">注意宏定义时参数不带()可能会被展开为错误形式</span>
 result=N(a+b); //展开为result=3*(a+b)*(a+b);
 return 0;
}</div>

<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p><span class="strong">条件编译</span>指预处理器根据条件编译指令，选择性将源代码中的部分代码送到编译器进行编译</p>
<h6 id="ifdef宏定义判断"><a href="#ifdef宏定义判断" class="headerlink" title="#ifdef宏定义判断"></a>#ifdef宏定义判断</h6><p><span class="strong">#ifdef 标识符<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span><br>如果指定的标识符已经被#define定义过，则编译程序1，否则编译程序2，程序1和程序2既可以是C语句，也可以是预处理命令，类似于if…else…语句，#else可以不使用</p>
<div class="show">#include &lt;stdio.h>
#define TEST //TEST定义甚至可以为空，也视为被定义过
#ifdef TEST
    #define SIZE 32 //TEST被定义过，所以执行该语句
#else
    #define SIZE 64
#endif
....</div>

<h6 id="ifndef无宏定义判断"><a href="#ifndef无宏定义判断" class="headerlink" title="#ifndef无宏定义判断"></a>#ifndef无宏定义判断</h6><p>逻辑与#ifdef相反，如果指定的标识符未被#define定义，则编译程序1，否则编译程序2<br><span class="strong">#ifndef 标识符<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span></p>
<h6 id="if表达式判断"><a href="#if表达式判断" class="headerlink" title="#if表达式判断"></a>#if表达式判断</h6><p>如果表达式值为真，编译程序1，否则编译程序2<br><span class="strong">#if 表达式<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序1<br>&emsp;&emsp;#else<br>    &emsp;&emsp;&emsp;&emsp;&emsp;程序2<br>&emsp;&emsp;#endif<br></span></p>
<div class="show">#include &lt;stdio.h>
#define LINUX 1 //可以快速设置编译的目标平台，缩减源代码长度
int main(void){
    #if LINUX
        printf("linux专用代码");
    #else
        printf("非linux用代码");
    #endif
    .....
    return 0;
}</div>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>C语言中变量的声明方式如下：<br><span class="strong"><span class="text-green">存储类型</span><span class="text-blue">数据类型 </span> 变量名;</span></p>
<ul>
<li>存储类型代表编译器为变量分配内存的方式，如：自动变量内存分配于动态存储器，静态变量和外部变量内存分配于静态存储区，寄存器变量存储位置分配于CPU中的寄存器</li>
<li>存储类型和作用域(变量定义的位置)决定了变量的生存期</li>
<li>数据类型指该变量存储的数据类型</li>
<li>变量名需要满足标识符命名规则</li>
</ul>
<h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p><span class="strong">标识符</span>即C语言中的变量名、符号常量名、函数名、数组名等用来给数据对象命名的字符序列，标识符需要满足以下规则：</p>
<ul>
<li>只能由英文字母、数字、下划线组成</li>
<li>不能以数字开头</li>
<li>不能使用关键字</li>
<li>严格区分大小写</li>
</ul>
<h4 id="变量的作用域和生存期"><a href="#变量的作用域和生存期" class="headerlink" title="变量的作用域和生存期"></a>变量的作用域和生存期</h4><p>变量从其作用域区分，分为局部变量和全局变量：</p>
<p><span class="strong">局部变量</span>：定义在函数内部或{ }包裹的代码块内部，只在本函数或代码块内生效，分为静态局部变量和动态局部变量。默认情况下，局部变量的存储类型为auto(动态局部变量)，变量内存位于动态存储区，代码块内的语句执行完毕变量就会被销毁，释放其内存。可以将局部变量的存储类型定义为static(静态局部变量)，此时变量内存位于静态存储区，整个程序运行期间其内存不会被释放</p>
<p><span class="strong">全局变量</span>：定义在函数的外部，默认存储类型为extern，有效作用域为变量定义位置开始到本源文件结束，其作用域可以通过extern声明进行拓展。全局变量在程序的整个执行过程都占用内存单元。<span class="tips">习惯上，全局变量的首字母用大写表示</span>，当全局变量名和局部变量名相同时，局部变量有效</p>
<p>变量的生存期是指变量从生成(分配内存)到被销毁(释放内存)的时间段。对于存储在静态存储区中的变量，其内存在编译时就已经确定，是静态的，内存空间在整个程序运行期间不会被释放，变量与程序共存亡。而对于存储在动态存储区中的变量，其内存由操作系统根据程序运行动态分配。变量的存储类型直接决定了变量的生存期。</p>
<div class="show">#include&lt;stdio.h>
int Number=0;   //全局变量首字母大写
int main(void){
    void test();
    int num=10;
    int Number=10; //局部变量生效，全局变量被"屏蔽"
    test();
    return 0;
}
void test(){
    Number=100; //全局变量可以被任意函数访问和修改，会降低程序清晰性
}</div>

<h4 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h4><p>C语言提供的存储类型主要有以下几种：</p>
<ul>
<li>自动变量 auto</li>
<li>静态变量 static</li>
<li>外部变量 extern</li>
<li>寄存器变量 register</li>
</ul>
<h5 id="auto自动变量"><a href="#auto自动变量" class="headerlink" title="auto自动变量"></a>auto自动变量</h5><p>又称动态局部变量或局部作用域变量，定义于函数内部，是C语言中极为常用的变量类型，因此C语言把它设计为缺省类型(默认类型)，即auto可以省略不写，反之，如果没有指定局部变量的存储类型，则默认为auto，因此以下两个语句等价</p>
<div class="show"><code>&#123;
int num=10;
auto int num=10;
&#125;</code></div>

<p>自动变量数据存储在<span class="text-blue">动态存储区</span>中，操作系统会在代码执行到变量定义语句时为其分配内存，退出所属语句块时释放内存。函数形参和函数内定义的变量(未明确声明为static)都属于该类变量。自动变量有以下特点：</p>
<ul>
<li>自动变量在定义时不会自动初始化。所以除非程序员显式指定初值，否则自动变量的值是随机的垃圾值</li>
<li>自动变量在退出函数(语句块)后，其分配的内存立即被释放，再次进入该语句块，该变量被重新分配内存，所以不会保存上一次退出时的值</li>
</ul>
<h5 id="static静态变量"><a href="#static静态变量" class="headerlink" title="static静态变量"></a>static静态变量</h5><p>静态变量分为静态局部变量和静态外部变量，二者用于不同的场景。静态变量在<span class="text-blue">静态存储区</span>分配内存，在整个程序运行期间不会被释放，与程序共存亡。对于已经初始化的静态变量，其内存空间位于静态存储区的.data段，在编译时赋予内存。对于未初始化的静态变量，其内存空间位于静态存储区的.bss段，并在程序初始化时，给变量赋值0(对数值型变量)或空字符(对字符变量)。</p>
<h6 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h6><p>自动变量的内存会在代码退出函数块后被释放，其值也不会被保留，下次进入该函数块，该变量会被分配新的内存，如果希望变量的值在退出函数语句块后依旧被保留，其占用的存储单元不释放，方便函数基于上一次的运算结果进一步进行计算，此时可以使用static关键字将局部变量定义为静态局部变量。</p>
<div class="show">eg:计算n的阶乘
<code>int main(void)&#123;
    int i,n;
    scanf("%d",&n);
    for(i=1;i&lt;=n;i++)&#123;
        Func(i);
    &#125;
    return 0;
&#125;
long Func(int n)&#123;
    static long p=1;
    return p*n;
&#125;</code></div>

<p>静态局部变量，有以下特点：</p>
<ul>
<li>如果定义静态局部变量时不赋初值，编译器会自动赋为0(对数值型变量)或空字符(对字符变量)</li>
<li>自动变量(动态局部变量)占据的内存在函数调用结束后会被释放，每次调用都需要重新初始化。而静态局部变量仅在第一次调用函数时被初始化一次，其占据的内存在退出函数后不会被释放，再次调用该函数其值上次退出函数时的值</li>
<li>虽然静态局部变量在函数调用结束时仍然存在，但其他函数是无法引用它的</li>
</ul>
<h6 id="静态外部变量"><a href="#静态外部变量" class="headerlink" title="静态外部变量"></a>静态外部变量</h6><p>外部变量默认存储类型为extern，可以被其他文件使用extern声明后引用，如果希望外部变量只限于被本文件使用，而不能被其他文件引用，则可以在声明外部变量时添加static声明，将其声明为静态外部变量，该类变量可以应用于以下场景：</p>
<ul>
<li>多人开发时，可以在不同文件中声明同名外部变量而互不干扰</li>
<li>权限控制，避免其他文件引用或修改外部变量的值</li>
</ul>
<div class="show"><code>static int Number;
</code></div>


<h5 id="extern外部变量"><a href="#extern外部变量" class="headerlink" title="extern外部变量"></a>extern外部变量</h5><p>如果定义在函数之外的变量没有指定其他存储类别，那么它就是一个外部变量，外部变量是全局变量，作用域是从它的定义点到本文件末尾。但如果要在定义点之前或在其他文件中使用它，那就需要使用关键字extern对其进行声明(注意不是定义，编译器不为其分配内存)<br>声明语句为:<br><span class="strong">extern 类型名 变量名;</span><br>其中类型名可以省略，因此以下语句等价</p>
<div class="show"><code>extern int Num1;
extern Num1;</code>
注意！
在定义外部变量时，直接在函数外定义 int Num1;  即可
int Num1;  是“定义性声明”语句，会给变量分配内存空间，
extern int Num1;  为“引用性声明”语句，用于拓展外部变量作用域，不会分配内存，不能用来定义一个未初始化的外部变量
但如果在定义时进行初始化，根据右结合原则，会当作定义了变量，并进行了extern作用域拓展处理
extern int Num1=200;//既是定义语句，也是extern声明语句
</div>

<h6 id="在一个文件内声明外部变量"><a href="#在一个文件内声明外部变量" class="headerlink" title="在一个文件内声明外部变量"></a>在一个文件内声明外部变量</h6><p>如果外部变量不在文件开头定义，那么它的作用域就是从它的定义点到本文件末尾。如果在定义点之前想要引用该变量，则需要在引用之前对使用extern对其进行外部变量声明，声明后就可以从声明之处起，合法使用该外部变量</p>
<div class="show"><code>int main(void)&#123;
    int getMax(int ,int);
    <span class="text-blue">extern Num1,Num2;</span>//外部变量声明(仅作声明，不分配内存)
    printf("max is:%d", getMax(Num1,Num2);)//在定义前引用变量
&#125;
int Num1=10,Num2=20;//定义外部变量
int getMax(int x,int y)&#123;
    return x>y?x:y;
&#125;
</code></div>



<h6 id="在多文件中声明外部变量"><a href="#在多文件中声明外部变量" class="headerlink" title="在多文件中声明外部变量"></a>在多文件中声明外部变量</h6><p>C语言程序也可以由多个源文件组成，如果多个文件都需要用到同一个外部变量，不能在多个文件中都同时定义该变量，否则程序在链接阶段会出现“重复定义”错误。正确做法是：在某一个文件中定义外部变量，其他文件中用extern对该变量作“外部变量声明”，将变量的作用域拓展到这些文件中，然后在这些文件中合法引用外部变量。</p>
<div class="show">eg:文件file1.c中输入变量Num的值，文件file2.c对Num扩大10倍后返回结果
file1.c文件:
<code>#include&lt;stdio.h&gt;
<span class="text-blue">int Num;</span>//定义外部变量
int main(void)&#123;
    int getValue(int);
    printf("Input the value of Num:");
    scanf("%d",&Num);
    printf("%d",getValue(10));
    return 0;
&#125;</code>
file2.c文件:
<code><span class="text-red">extern Num;</span>//声明A为其他文件已经定义的外部变量
int getValue(int n)
&#123;
    return Num*n;
&#125;</code></div>

<h5 id="register寄存器变量"><a href="#register寄存器变量" class="headerlink" title="register寄存器变量"></a>register寄存器变量</h5><p>对于使用频率较高的变量，可以将其声明为寄存器变量，减少CPU对内存的频繁数据访问，使得程序更小，执行速度更快</p>
<div class="show"><code>int main(void)
&#123;
    int n;
    long countNum(int);
    scanf("%d",&n);
    countNum(n);
    return 0;
&#125;
long countNum(int n)
&#123;
    register long i,f=1;
    for(i=1;i&lt;n;i++)&#123;
          f=f*i;
    &#125;
    return f;
&#125;
</code></div>

<p>寄存器变量有以下特点：</p>
<ul>
<li>只有局部自动变量和形参可以作为寄存器变量</li>
<li>CPU中的寄存器数量有限，不能定义太多的寄存器变量</li>
<li>有的系统把寄存器变量当作自动变量处理，在内存中分配存储空间，并非放到寄存器中</li>
</ul>
<p>现代编译器能自动优化程序，自动把普通变量优化为寄存器变量，并且可以忽略用户定义的寄存器变量，因此一般无需特别声明变量为register，仅作了解。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="数据类型总览"><a href="#数据类型总览" class="headerlink" title="数据类型总览"></a>数据类型总览</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><div class="table">
<table>
        <thead>
            <tr>
                <th colspan="2">分类</th>
                <th>关键字</th>
                <th>长度(Bytes)</th>
                <th>示例</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="5">整型</td>
                <td>短整型</td>
                <td>short</td>
                <td>2</td>
                <td>short a;或
                    short int a;
                </td>
            </tr>
            <tr>
                <td>整型</td>
                <td>int</td>
                <td>4</td>
                <td>int a;</td>
            </tr>
            <tr>
                <td>长整型</td>
                <td>long</td>
                <td>4</td>
                <td>long a;或
                    long int a;
                </td>
            </tr>
            <tr>
                <td>长长整型</td>
                <td>long long</td>
                <td>8</td>
                <td>long long a;或
                    long long int a;
                </td>
            </tr>
            <tr>
                <td>无符号整型</td>
                <td>unsigned</td>
                <td>8</td>
                <td><div>unsigned int a;</div> 
                    unsigned long  a;
                </td>
            </tr>
            <tr>
                <td rowspan="3">浮点型(实型)</td>
                <td>单精度</td>
                <td>float</td>
                <td>4</td>
                <td>float a;</td>
            </tr>
            <tr>
                <td>双精度</td>
                <td>double</td>
                <td>8</td>
                <td>double a;</td>
            </tr>
            <tr>
                <td>长双精度</td>
                <td>long double</td>
                <td>12或8</td>
                <td>long double a;</td>
            </tr>
            <tr>
                <td colspan="2">字符型</td>
                <td>char</td>
                <td>1</td>
                <td>char a;</td>
            </tr>
            <tr>
                <td colspan="2">枚举型</td>
                <td>enum</td>
                <td>-</td>
                <td>enum res{yes,no,none};</td>
            </tr>
        </tbody>
    </table>
</div>


<div class="broadcast color-blue">
<div class="iconfont icon-yinhao"></div>
long long,unsigned long long,long double是C99标准新增的，部分编译器默认使用C89标准，需要手动指定使用C99标准编译才支持以上数据类型。此外，ANSI C标准对于数据类型所占内存的字节数并无明确定义，因此不同编译器中各数据类型的字节数可能不同</div>
<div class="broadcast color-red">
<div class="iconfont icon-gantanhao"></div>
C语言中没有string类型，处理字符串一般使用字符数组或指针，也没有bool类型，不能使用true和false逻辑常量</div>

<h5 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h5><div class="table">

<table>
<thead>
<tr>
<th>构造类型</th>
<th>关键字</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>-</td>
<td>int num[10];</td>
</tr>
<tr>
<td>结构体</td>
<td>struct</td>
<td></td>
</tr>
<tr>
<td>共用体</td>
<td>union</td>
<td>union{int num;char name[5];}man</td>
</tr>
</tbody></table>
</div>

<h5 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h5><div class="table">

<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>指针</td>
<td>-</td>
<td>int * p;</td>
</tr>
<tr>
<td>无类型</td>
<td>void</td>
<td>void f1(){…}</td>
</tr>
</tbody></table>
</div>

<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型从符号位的归属可分为<span class="strong">有符号整型(signed)</span>和<span class="strong">无符号整型(unsigned)</span>。有符号整型最高位为符号位，0表示该值为正数，1表示该值为负数，而无符号整型的最高位不表示正负，依旧用于储存数值，因此无符号整型只能表示0和正整数，但无符号整型可存储的数值范围要比同位数的有符号整型大2倍，如：signed int数值范围为-32768-32767，而unsigned int 数值范围为0-65535。如果一个整型不声明为unsigned或signed，则默认隐含为signed，因而signed可以省略不写。</p>
<p>对于短整型和长整型，int也可以省略不写(以下[]内的均可省略不写)</p>
<div class="table">

<table>
<thead>
<tr>
<th>类型</th>
<th>比特位数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>[signed] short [int]</td>
<td>16</td>
<td>-2<sup>15</sup>~(2<sup>15</sup>-1)</td>
</tr>
<tr>
<td>unsigned short [int]</td>
<td>16</td>
<td>0~(2<sup>16</sup>-1)</td>
</tr>
<tr>
<td>[signed] long [int]</td>
<td>32</td>
<td>-2<sup>31</sup>~(2<sup>31</sup>-1)</td>
</tr>
<tr>
<td>unsigned long [int]</td>
<td>32</td>
<td>0~(2<sup>32</sup>-1)</td>
</tr>
</tbody></table>
</div>

<p>对于整型常量，通常在其数值后加上相应符号表示其具体类型，如：加上<span class="tips">U或u</span>表示无符号整型，加上<span class="tips">L或者l</span>表示长整型</p>
<div class="show">233u或233U为无符号整型
-1024l或-1024L为长整型
203lu为无符号长整型</div>

<div class="broadcast color-red"><div class="iconfont icon-gantanhao"></div>如果使用u标识一个负整数,如-12345u，则将取-12345补码对应的无符号整数53191按无符号数存储</div>
<div class="show">-12345
原码：1011 0000 0011 1001
反码：1100 1111 1100 0110
补码：1100 1111 1100 0111 --->对应无符号数值为53191</div>

<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点数有两种表示方式：</p>
<ul>
<li>十进制小数形式，如：0.5,1.3,.95(省略0)</li>
<li>指数形式，以e或E为底数(其中e代表10)，e的左边为数值部分，e的右边为指数部分(必须为整数)，如：12.3可以表示为1.23e1、0.123e2、123e-1等形式，如果e左边的数值部分，小数点左边有且只有一位非零的数字，则该表示方法称为<span class="tips">“规范化的指数形式”</span>，如：1.23e1为规范化的指数形式，而0.123e2、123e-1不是</li>
</ul>
<p>C语言默认将浮点型常量作为<span class="tips">双精度(double)</span>类型进行处理，如果在常量后加上<span class="tips">f或F</span>将作为float型处理，加上<span class="tips">l或L</span>则作为long double型处理，eg:1.25e-2f，1.25L</p>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符常量使用<span class="tips">单引号’’</span>包裹，一个字符占用一个字节(中文字符需要两个字节)。字符在内存中以ASCII码形式存储，因此字符型数据和整型数据是通用且可以用于计算的(仅限于0-255之间的整数)，常见的应用为<span class="tips">大写字符+32转换为小写字符</span></p>
<div class="show">char a=97;
int  asciiA=a-32;
printf("%c\n",asciiA)//输出A
printf("%d",asciiA)//输出65
</div>

<p>此外，C语言中还有一些特殊的转义字符，作用如下</p>
<div class="table">

<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
<td>\a</td>
<td>响铃报警提示音</td>
</tr>
<tr>
<td>\r</td>
<td>回车(不换行)，将光标位置移到当前行开头</td>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\0</td>
<td>空操作字符，常用作字符串结束标志</td>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表，跳到下一个Tab位置</td>
<td>\\</td>
<td>反斜线</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表</td>
<td>\?</td>
<td>问号</td>
</tr>
<tr>
<td>\b</td>
<td>光标位置退一格</td>
<td>\ddd</td>
<td>1到3位八进制ASCII码代表的字符</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
<td>\xhh</td>
<td>1到2位十六进制ASCII码代表的字符</td>
</tr>
</tbody></table>
</div>

<div class="show">1. \ddd和\xhh是用一个八进制或者十六进制的ASCII码表示一个字符，如："\101"和"\x41"转换为十进制为65，表示ASCII码值为65的字符A
2.注意\r和\b的使用，会覆盖掉\r、\b之前的字符
printf("abcdefg\r1234");//输出1234 fg，光标回到本行开头，1234\0替换掉abcde(字符串末尾会添加\0，因此\0替换e并输出空白字符)
printf("abcdefg\b\b\b\b123");//输出abc 123
printf("abcdefg\b\b\b\b\b\b\b123");//输出123 efg
printf("abcdefg\b\b\b\b\b\b\b123\n");//输出123defg
</div>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串常量使用<span class="tips">双引号””</span>包裹，字符串末尾会被加上<span class="tips">‘\0’</span>作为字符串结束的标志。C语言中没有专门的关键字用来声明字符串变量，因此需要使用字符数组或者指针来存储和处理字符串</p>
<h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><p>字符串可以存储于字符数组中，但字符数组中存储的并不一定是字符串，这取决于字符数组最后一个元素是否是字符串结束标志’\0’，’\0’也占用一个字节内存，但它不计入字符串的实际长度，只计入数组长度。注意，如果字符数组最后没有’\0’，系统将无法将该数组当作字符串来处理(如：无法正确被printf(“%s”,xx)输出)</p>
<div class="show">对于字符数组，可以像其他数组一样用同样的方式初始化，如：
<code>char str[6]=&#123;'H','e','l','l','o','\0'&#125;;</code>
如果省略对数组长度的声明，则必须人为在初始化列表中添加'\0'，否则系统将无法将str当作字符串来处理
<code>char str[]=&#123;'H','e','l','l','o'&#125;;//长度为5的普通字符数组
char str[]=&#123;'H','e','l','l','o','\0'&#125;;//长度为6的字符串</code>
用printf("%s",str)语句输出上述变量时，第一个变量由于缺少'\0'，输出语句会在输出完Hello后继续输出乱码，直到遇见'\0'，而第二个变量会被正常输出

<p>也可以用字符串常量初始化字符数组，这样可以不指定数组大小，且由于字符串常量”Hello”末尾自带’\0’，可以不必人为添加’\0’<br><code>char str[6]=&#123;"Hello"&#125;;<br>char str[]=&#123;"Hello"&#125;;//数组长度可省略<br>char str[]="Hello";//大括号可省略</code><br><span class="text-red">但只允许在定义时整体赋值，不允许在赋值语句中整体赋值</span><br><code>char str[6];<br>str[]=&#123;"Hello"&#125;;//不允许先定义，定义完在赋值语句中整体赋值,Visual Studio报错：不允许使用不完整的类型</code><br>无论用哪种方式初始化字符数组，如果指定数组长度，都要保证预留足够空间以便存储字符串结束标志，即：字符数组大小一定要比字符串的实际字符数大1<br>可以使用数组下标访问字符串的单个字符，如：<br>str[1]代表字符’e’</div></p>
<div class="show">一个字符串可以用一维字符数组存储，多个字符串可以用二维字符数组存储。数组的第一维长度代表要存储的字符串个数，可以省略；第二维长度不能省略，应当设定为最长那个字符串长度+1，eg:
<code>char weekday[][10]=&#123;"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"&#125;;</code>
其中最长的字符串"Wendesday"长度为9，因此第二维长度应当为10，对于长度小于10的字符串，其剩余的内存单元会被'\0'填充
如果字符串太长，可以拆分为几个小片段写在不同行，其中空格也将占用数组长度和空间
<code>char longString[]="One day you will leave this world behind"
"so live a life you will remember"</code></div>

<h4 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h4><p>字符指针是指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一确定的地址，因此只要将字符串首地址赋值给指针变量，就可以让字符指针指向一个字符串。对于字符串常量，C语言按字符数组处理，在内存中开辟一个字符数组存储该字符串，字符串常量本身就代表存放它的常量存储区的首地址。</p>
<div class="show">1. 以下两个初始化语句等价，均表示将字符串常量在常量存储区中"Hello"的首地址赋值给ptr
<code>char * ptr="Hello";</code>
等价于
<code>char * ptr;
ptr="Hello";</code>
2. 由于字符串常量存储于只读的常量存储区中，因此只可以修改指针变量的指向，不能修改ptr所指向存储单元的内容
*ptr='a';//错误！写入权限异常，不能修改所指向存储空间的内容
ptr="another";//允许修改指针的指向
3. 通过指针也可以访问单个字符，如：
*(ptr+1)代表字符'e'
也可以修改指针指向位置，使其从所指位置开始输出，直至遇到'\0'，以此输出字符串的部分内容，如：
<code>char * sentence="Meet you like the wind";
sentence=sentence+14;
printf("%s",sentence);//输出the wind</code>
</div>

<h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><p>字符串的输出支持以下三种方法：</p>
<div class="show">1. 依次输出单个字符
<code>for(int i=0;i&lt;6;i++)&#123;
    printf("%c",str[i]);
&#125;</code>
由于字符串长度并不等于字符数组大小，且上述方法无法灵活输出不同长度字符串，因此一般会借助字符串结束标志'\0'来结束字符串输出，如：
<code>for(int i=0;str[i]!='\0';i++)&#123;
    printf("%c",str[i]);
&#125;</code>
2. 用格式符s，将字符串作为一个整体输出，同样输出到字符串结束标志为止
<code><span class="text-red">printf("%s",str)</span></code>
3. 使用<span class="text-blue">puts()</span>函数(&lt;stdio.h>库函数)，puts()函数用于从括号内的参数给出的地址开始，依次输出存储单元中的字符，直到遇到第一个'\0'时输出结束，并自动输出一个换行符，缺点是该函数无法如printf()函数一样添加其他字符信息并控制输出格式
<code><span class="text-red">puts(str)</span></code>
</div>

<p>字符串指针变量可以指向一个格式字符串，可以替代printf()函数中的格式，作为一种可变格式的字符串输出</p>
<div class="show"><code>char * format;
format="a=%d,b=%f\n";
printf(format,a,b);
也可以用字符数组实现
char format[]="a=%d,b=%f\n";
printf(format,a,b);</code></div>


<h4 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h4><p>与输出相似，字符串的输入支持以下三种方法：</p>
<div class="show">1. 依次输入单个字符
<code>for(int i=0;i&lt;6;i++)&#123;
    scanf("%c",&str[i]);
&#125;</code>
2. 用格式符s，将字符串作为一个整体输入，直至遇到<span class="tips">空白字符、空格、回车符、制表符</span>为止，注意！<span class="text-blue">由于字符数组名str本身已经代表字符串的首地址，因此str前不能再加上取地址符&</span>，此外，用scanf()不能输入带空格、制表符的字符串，空格、制表符、回车符及其之后的字符会被留在输入缓冲区
<code><span class="text-red">scanf("%s",str);</span></code>
3. 使用<span class="text-blue">gets()</span>函数(&lt;stdio.h>库函数)，gets()函数以回车符作为输入终止符，同时将回车符从输入缓冲区读走，但不作为字符串的一部分，因此该函数可用于输入带空格的字符串
<code><span class="text-red">gets(str);</span></code>

<p>以上方法都有一定的安全隐患，如果输入字符数超过了定义的字符数组大小，多出的字符可能引起缓冲区溢出，带来安全隐患，因此可以使用能限制输入字符串长度的函数<br><span class="text-blue">fgets(str,sizeof(str),stdin)</span><br>该语句表示从标准输入stdin中读取一行长度为sizeof(str)的字符串存储到str为首地址的存储区中，多余的字符舍弃</div></p>
<div class="broadcast color-red">
<div class="iconfont icon-gantanhao"></div>
注意！如果使用字符指针输入字符串，必须保证字符指针事先已经指向一个字符数组地址或确定的存储单元，否则可能导致非法内存访问错误！</div>
<div class="show">使用字符指针输入字符串需要注意以下情况
<code>char * ptr;//ptr未被初始化
scanf("%s",ptr);</code>
上述代码，编译时给指针变量ptr分配了内存单元，但ptr中的值是一个不可预料的垃圾值，该指针指向一个未确定的存储单元，可能指向空白存储区，也可能指向已经存放指令或数据的内存段，在现代编译器中会报错使用了未初始化的局部变量“ptr”，然而在低版本编译器中可能顺利通过编译，带来潜在安全隐患
因此，推荐使用字符数组输入字符串
<code>char str[10];
scanf("%s",str);</code>
如果使用字符指针输入字符串，则保证该指针指向了确定的地址
<code> char str[10];
<span class="text-red">char * ptr=str;</span>
 gets(ptr);</code>
</div>

<h3 id="构造类型-1"><a href="#构造类型-1" class="headerlink" title="构造类型"></a>构造类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>定义方式： </p>
<div class="apiBox">类型 数组名[数组长度]</div>

<p>数组名的命名规则遵守标识符命名规范，数组长度需要使用常量表达式，<span class="tips">不能包含变量</span>，一维数组的初始化可以使用以下方法：</p>
<ul>
<li>在定义时赋予全部初值，如：int nums[5]={0,1,2,3,4};</li>
<li>也可以只给一部分元素赋值，其余元素会被赋0(char类型赋’\0’)，如：int nums[5]={0,1};</li>
<li>如果全部元素相同，可以只写一个值，如:int nums[5]={0};</li>
<li>如果对全部元素赋予初值，由数据个数已经确定，可以不指定数组长度，如：int nums[]={0,1,2,3,4};</li>
</ul>
<div class="show">1. 数组在定义时可以被整体初始化赋值
<code>int nums[5]=&#123;11,22,33,44,55&#125;;</code>
<span class="text-red">但不允许在赋值语句中被整体赋值</span>
<code>int nums[5];
nums[]=&#123;11,22,33,44,55&#125;;//错误</code>
这是由于数组在定义时，编译系统就会为其分配连续的内存单元，其内存空间大小就已确定，后续的整体赋值语句如果执行，可能会导致内存覆盖或溢出等不可预期的行为，所以需要注意用数组和指针操作字符串时的不同情况
<code>char str[6];
str[]=&#123;"Hello"&#125;;//错误
char * ptr;
ptr="Hello";//正确</code>
2. <span class="text-blue">数组名代表数组首元素的内存地址，即数组的起始地址，是一个地址常量，不能像修改指针变量一样对数组名进行++或--等操作</span>
<code>int a[10];int *p;
p=a;
p++;//允许，指针指向a[1]
a++;//不允许，a是数组首地址，无法修改</code>
3. C语言数组无length属性，获取数组长度可借助sizeof()函数
<code>int nums[] = &#123;1,2,3,4,5&#125;;
printf("%d", sizeof(nums)/sizeof(nums[0]));</code>
</div>

<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>定义方式： </p>
<div class="apiBox">类型 数组名[数组长度][数组长度]</div>

<p>对数组名和数组长度的要求同一维数组，二维数组的初始化可以使用以下方法：</p>
<ul>
<li>分行赋值，如：<code>int nums[3][2]=&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;</code></li>
<li>也可以一次性统一赋值，但不如第一种赋值方法清晰，如：<code>int nums[3][2]=&#123;1,2,3,4,5,6&#125;</code></li>
<li>可以只给部分元素赋值，同样其余元素会被赋0(char类型赋’\0’)，如：<code>int nums[3][2]=&#123;&#123;1&#125;,&#123;&#125;,&#123;0,6&#125;&#125;</code></li>
<li>如果对所有元素赋初值，可以不指定第一维的长度，但<span class="tips">第二维的长度声明永远不能省略</span></li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><p>对于复杂数据对象，仅仅使用几种基本数据类型无法准确反映它们之间的内在联系，也无法做统一处理，于是衍生出了允许用户自定义的数据类型，C语言中称之为构造数据类型(复合数据类型)，结构体就是构造数据类型的典型代表</p>
<p>结构体模板的声明格式如下：</p>
<div class="apiBox">struct 结构体名
{
    结构体成员
};
</div>

<p>结构体模板只是声明了一种数据类型，并未声明结构体类型的变量，编译器不为其分配内存，需要再使用以下语句声明结构体变量，编译器才会为结构体变量分配内存：<br><span class="strong">struct 结构体名 结构体变量名;</span></p>
<ul>
<li>结构体的名字又称为结构体标签，用于标记用户自定义的结构体类型，struct+结构体名 共同构成一个数据类型，如：下述例子中的struct student是一个类型名，作用同系统提供的标准类型(如int、char等)，因此不为其分配内存</li>
<li>结构体成员的命名遵从变量的命名规则</li>
<li>结构体成员也可以为一个结构体，即结构体可以嵌套</li>
<li>结构体成员名可以与程序其他位置的变量名相同，二者互不干扰</li>
</ul>
<div class="show">eg:先声明结构体模板，再声明结构体变量
<code>struct student
&#123;
    long studentID;
    char studentName[10];
    int score[4];
&#125;;//声明结构体模板，末尾;不可省略
struct student stu1,stu2;//声明结构体变量</code></div>

<p>也可以在声明结构体模板时，定义结构体变量：</p>
<div class="apiBox">struct 结构体名
{
    结构体成员
}变量名1,变量名2...;</div>
<div class="show">eg:声明结构体模板同时声明结构体变量
<code>struct student
&#123;
    long studentID;
    char studentName[10];
    int score[4];
&#125;stu1,stu2;</code>
eg:当结构体模板与结构体变量一起声明时，结构体名是可以省略的，但该方法由于未指定结构体名，无法在程序其他地方再定义结构体变量，因此并不常用
<code>struct//无结构体名
&#123;
    long studentID;
    char studentName[10];
    int score[4];
&#125;stu1,stu2;</code></div>

<p>关键字<span class="strong">typedef</span>用于为已有数据类型定义一个别名，数据类型别名通常大写，便于区分已有数据类型。定义结构体时可用typedef定义一个结构体别名，便于使用更简洁的形式定义结构体变量</p>
<div class="show">为结构体定义别名时，以下两个别名定义形式等价：
<code>struct student
&#123;
    long studentID;
    char studentName[10];
    int score[4];
&#125;;
<span class="text-blue">typedef struct student STUDENT;</span>
与
<span class="text-blue">typedef</span> struct student
&#123;
    long studentID;
    char studentName[10];
    int score[4];
&#125;<span class="text-blue">STUDENT</span>;</code>
二者都为struct student类型定义了一个新名字STUDENT，因此以下两条定义结构变量的语句等价：
<code>STUDENT stu1,stu2;//简洁形式
struct student stu1,stu2;</code>
</div>

<h4 id="结构体变量初始化与成员引用"><a href="#结构体变量初始化与成员引用" class="headerlink" title="结构体变量初始化与成员引用"></a>结构体变量初始化与成员引用</h4><p>结构体变量的成员可以通过将成员初值置于花括号内进行初始化</p>
<div class="show">eg:在定义结构体变量时初始化
<code>STUDENT stu1=&#123;114604,"SHIWIVI",&#123;111,222,333,444&#125;&#125;</code>
也可以在定义结构体模板和变量同时初始化
<code>struct student
&#123;
    long studentID;
    char studentName[10];
    int score[4];
&#125;stu1=&#123;114604,"SHIWIVI",&#123;111,222,333,444&#125;&#125;</code></div>

<p>访问结构体变量的成员必须使用<span class="tipe">成员选择运算符</span>(圆点运算符)，访问格式为：<br><span class="apiBox">结构体变量名.成员名</span></p>
<ul>
<li>C语言规定，不能将结构体变量作为一个整体输入、输出，如：printf(“%d%s..”,stu1)为非法语句</li>
<li>只能通过用圆点运算符访问结构体成员的方式来输入输出，如：printf(“%s”,stu1.studentName)</li>
<li>成员运算符<span class="tips">.</span>在所有运算符中优先级最高，因此通常可以将stu1.studentName当成一个整体看待</li>
<li>结构体嵌套时，必须以级联方式访问结构体成员，如：stu1.birthday.year</li>
<li>结构体成员可以像普通变量一样进行各种运算，如：stu1.birthday.year++</li>
<li>C语言允许对具有相同结构体类型的变量进行整体赋值，如：stu1初始化后，可以通过stu2=stu1对stu2进行初始化，结构体成员会进行逐一顺序赋值</li>
<li>也可以使用=号对结构体成员进行分开赋值，但注意，当结构体成员为字符数组时，由于<span class="text-red">字符数组名是该数组的首地址，是一个地址常量，不能作为赋值表达式左值</span>，因此对字符数组类型的结构体成员进行赋值时，必须使用字符串处理函数<span class="text-blue">strcpy()</span></li>
<li>结构体变量的地址是其所占存储空间的首地址，而结构体成员的地址与该成员在结构体中的所处位置和所占内存字节数有关，可以单独访问成员地址，如：&amp;su1.studentID</li>
</ul>
<div class="show">
<code>#include&lt;stdio.h&gt;
typedef struct date
&#123;
    int year;
    int month;
    int day;
&#125;<span class="strong">DATE</span>;
typedef struct student
&#123;
    long studentID;
    char studentName[10];
    <span class="strong">DATE</span> birthday;
    int score[4];
&#125;
int main(void)&#123;
    STUDENT stu1=&#123;114604,"SHIWIVI",&#123;1998,10,1&#125;,&#123;111,222,333,444&#125;&#125;;
    STUDENT stu2;
    <span class="text-blue">stu2=stu1;//整体赋值</span>
    //也可以对结构体成员分开赋值，整体赋值等价于下述赋值语句
    stu2.studentID=stu1.studentID;
    <span class="text-blue">strcpy(stu2.studentName,stu1.studentName);</span>
    stu2.birthday.year=stu1.birthday.year;
    ...
    stu2.score[0]=stu1.score[0];
    ...
    //通过键盘输入成员值时，单独访问成员变量地址
    scanf("ld%",&su1.studentID);
    scanf("%s",stu1.studentName);
    scanf("%d",&stu1.birthday.year);
    for(int i=0;i&lt;4;i++)&#123;
        scanf("%d",&stu1.score[i]);
    &#125;
    return 0;
&#125;
</code></div>

<h4 id="结构体所占内存字节数"><a href="#结构体所占内存字节数" class="headerlink" title="结构体所占内存字节数"></a>结构体所占内存字节数</h4><p>系统为结构体变量分配内存大小时，结构体类型所占字节数，并非是所有成员所占内存字节数的总和，这是因为许多计算机系统为了提高寻址效率，处理器体系为特定的数据类型引入了<span class="strong">内存对齐</span>需求，编译器为了满足处理器的对齐要求，会在较小的成员后加入补位，从而导致结构体实际所占内存字节数会比预计的多出一些字节。<br>如：32位计算机体系结构，short型数据从偶数地址开始存放，int型数据则被对齐在4字节地址边界，这样就保证了一个int型数据通过一次内存操作就能被访问到，而读取存储在没有对齐地址处的32位整数，则需要两次读取操作，再从两次读取到的64位数据中提取该32位整数相关的数据，这样会导致系统性能下降</p>
<p>因此计算结构体类型大小时一定要使用<span class="text-red">sizeof()</span>运算符，不能想当然直接对各成员所占内存进行简单求和。</p>
<div class="show"><code>#include&lt;stdio.h>
typedef struct sample &#123;
    char c1;
    int num;
    char c2;
&#125;SAMPLE;
int main(void) &#123;
    SAMPLE s = &#123; 'a',10,'b' &#125;;
    printf("%d", sizeof(s));//12而非6
    return 0;
&#125;</code>
根据内存对齐需求，如下图所示，c1和c2后会被增补3个字节补位，以达到与成员变量num内存地址对齐的要求，因此结构体变量s将占用12个字节的存储单元而非6个字节。如果将int类型改为short，则c1和c2将以short(2字节)为基准，后补1个字节空闲存储单元，s将占用6个字节内存

<p><canvas width="200" height="110" id="canvasStruct" style="display:block;width:200px;height:110px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>const canvasStruct=document.getElementById("canvasStruct");
const ctxSt=canvasStruct.getContext('2d');
ctxSt.strokeRect(50, 10, 120, 90);
ctxSt.moveTo(50,40);
ctxSt.lineTo(170,40);
ctxSt.strokeRect(80, 10, 30, 30);
ctxSt.strokeRect(110, 10, 30, 30);
ctxSt.moveTo(50,70);
ctxSt.lineTo(170,70);
ctxSt.strokeRect(80, 70, 30, 30);
ctxSt.strokeRect(110, 70, 30, 30);
ctxSt.stroke();
ctxSt.font="600 13px Serif";
ctxSt.fillText("成员1", 10, 30);
ctxSt.fillText("c1", 60, 30);
ctxSt.fillText("成员2", 10, 60);
ctxSt.fillText("num", 100, 60);
ctxSt.fillText("成员3", 10, 90);
ctxSt.fillText("c2", 60, 90);</script></div>

<h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>与普通数组类似，结构体数组也可以在定义时统一初始化</p>
<div class="show">eg:在结构体数组定义时初始化数组，如果只初始化部分数组元素，则其余数组元素会被自动赋为0值
<code>STUDENT stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;//数组长度可以省略不写
或
struct student
&#123;
    long studentID;
    char studentName[10];
    int score[4];
&#125; stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;
访问数组元素的方法与普通数组一样
printf("%ld",stu[1].studentID);
</code></div>

<h4 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h4><p>可以使用一个指针变量p指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址，随后，就可以使用<span class="text-red">指向运算符</span>(箭头运算符)访问结构体的成员，以下三种访问结构体成员变量的方式等价：</p>
<ul>
<li><span class="strong">结构体变量.成员名</span></li>
<li><span class="strong">(*p).成员名</span></li>
<li><span class="strong">p-&gt;成员名</span><div class="show"><code>struct student stu1=&#123;1101,"LiLin",11,22,33,44&#125;;
<span class="text-blue">struct student * p=&stu1;</span>
printf("%ld"，<span class="text-red">stu1.studentID</span>);
printf("%ld"，<span class="text-red">(*p).studentID</span>);
printf("%ld"，<span class="text-red">p->studentID</span>);
</code></div></li>
</ul>
<p>指针也可以指向结构体数组，操作同指向普通数组类似，对指针进行的++操作会使指针指向下一个结构体数组元素</p>
<div class="show"><code>STUDENT stu[3]=&#123;&#123;1101,"LiLin",11,22,33,44&#125;,&#123;1102,"ZhangKe",10,20,30,40&#125;,&#123;1103,"MaLong",15,25,35,45&#125;&#125;;
struct student * p=stu;
for(;p&lt;stu+3;p++)&#123;
    printf("%s\n",p->studentName);
&#125;
//p被定义为是指向struct student类型的指针，如果需要将其指向其他类型，可以使用强制类型转换
p=(struct student *)stu[0].studentName;
printf("%s",p);//输出stu[0]的studentName
//但此时p仍然保持原来的类型，p+1将指向stu[1]的studentName
printf("%s",p+1);
</code></div>

<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>共用体(也称为联合,Union)是将不同类型的数据存放在一起，占用同一段内存的一种构造数据类型，共用体的声明形式与结构体类似：</p>
<div class="apiBox">union 共用体名
{
    共用体成员
};</div>

<ul>
<li>共用体类型所占内存大小取决于其成员中所占内存空间最大的成员变量</li>
<li>共用体同一内存段可以用来存放不同类型的数据，但在同一时间只能存放其中一种类型的成员，也就是说，同一时刻只能有一个成员起作用</li>
<li>共用体变量中起作用的成员是最后一个被赋值的成员，在存入一个新的成员值后，原有的成员值会被覆盖</li>
<li>共用体的成员一般单独赋值、调用</li>
<li>共用体变量的地址和其各成员的地址都是同一个地址</li>
<li>共用体不能进行比较操作</li>
<li>共用体不能作为函数参数，也不能作为函数返回值，但可以使用指向共用体变量的指针</li>
<li>不能只引用共用体变量，需要引用共用体的具体成员</li>
</ul>
<div class="show"><code>union sample
&#123;
    short i;
    char ch;
    float f;
&#125;;
union sample a;//共用体a中i,ch,f共占一段内存空间，因此a的大小由成员最大数据类型float决定，占用4个字节
a.i=10;//可以给共用体成员单独赋值
a.ch='R';
a.f=11.11;//完成上述3个赋值运算后，只有a.f有效，a.i和a.ch将被覆盖失效
//如果在定义时初始化共用体的成员初值，C89规定只能对共用体的第一个成员进行初始化，但c99无该限制，允许按以下形式按名设置成员初值
<span class="text-blue">union sample b=&#123;.i=10,.ch='b',.f=22.22&#125;;</span>//但也只有f会生效
</code></div>

<p>共用体可以用来存储程序中逻辑相关但情形互斥的变量，共享内存空间可以节省内存，也避免了操作失误引起的逻辑冲突。如：职工管理系统中，职工的个人婚姻状况只能有三种情况：未婚、已婚、离婚。且这三种情况应当是互斥的，此时可以用共用体来存储该数据</p>
<div class="show">eg:未婚标识为0，已婚则记录结婚日期、配偶姓名，离婚则记录离婚日期
<code>struct date
&#123;
    int year;
    int month;
    int day;
&#125;;
struct marriedState //已婚信息
&#123;
    struct date marryDate;//记录结婚日期
    char spouseName[20];//记录配偶姓名
&#125;;
struct divorceState //离婚信息
&#123;
    struct date divorceDay;//记录离婚日期
&#125;;
<span class="text-blue">union maritalState</span> //共用体，存储婚姻状况
&#123;
    int single;//未婚
    struct marriedState married;//已婚
    struct divorceState divorce;//离婚
&#125;;
struct person
&#123;
    char name[20];
    char sex;
    int age;
    union maritalState marital;
    int marryFlag; //共用体无法直接看出是哪个成员生效，因此使用一个变量标记婚姻状态
&#125;;
</code></div>

<p>共用体也可以用来构造混合数据结构，高效使用存储空间，如：需要存储的数据是int和float型数据的混合，可以定义如下共用体：</p>
<div class="show"><code>typedef union
&#123;
    int i;
    float f;
&#125;NUMBER;
NUMBER array[20];//既可以存储int数据，也可以存储float数据</code></div>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>当一个变量只有几种固定的值时，就可以使用枚举表示，枚举类型的定义方法与结构体类似，需要使用enum关键字：</p>
<div class="apiBox">enum 枚举标签名
{
    枚举常量
}枚举变量名;</div>

<ul>
<li><span class="strong">枚举常量都是整型常量</span>，除非特别指定，否则其值按顺序为0，1，2….</li>
<li>允许在定义时明确指定枚举常量的值，如：enum response {no=1,yes=1,none=0}，也可以只指定前几个值，其后的值会自动递增，如：enum month{Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec};</li>
<li>程序员在花括号内定义的枚举常量只作为标识符使用，并不代表什么含义，其值本质仍是整型常量，不是字符串</li>
<li>枚举常量可以作为整型值进行比较、输出操作</li>
<li>可以定义枚举型数组，如：enum response answers[10];</li>
</ul>
<div class="show"><code>enum response&#123;no,yes,none&#125;;
enum response res1,res2;
或
enum response&#123;no,yes,none&#125; res1,res2;
或
enum &#123;no,yes,none&#125; res1,res2;//枚举类型和枚举变量一起定义时，枚举标签可省略
</code></div>

<div class="show"><code>1. 枚举变量的赋值只能从枚举常量中选取
enum response&#123;no,yes,none&#125; res1,res2;
res1=yes;//只能赋值no、yes、none中的其中一个
2. 枚举变量可以用于条件语句，比较规则是按其定义时的整型值进行比较，默认情况下为：no=0,yes=1,none=2
if(res1==yes)
if(res1>none)
3. 枚举常量的值是整型常量，因此只能作为整型值处理，而不能作为字符串来使用
printf("%d",res1);//正确，输出res1为1
printf("%s",res1);//错误！不能作为字符串使用，无法输出yes
4. 虽然枚举常量都表示为整型常量，但不能直接将整型常量赋值给枚举变量，因为它们属于不同类型
res1=2; //错误
可以进行强制类型转换，相当于将值为2的none赋给res1，2也可以替换为表达式
res1=(enum response)2;
</code></div>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h4><div class="table">

<table>
<thead>
<tr>
<th>定义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>int * p</td>
<td>指向整型数据的指针变量</td>
</tr>
<tr>
<td>int *p[n]</td>
<td>指针数组，数组中含n个指针</td>
</tr>
<tr>
<td>int (*p)[n]</td>
<td>二维数组的行指针，p指向含n个元素的一维数组</td>
</tr>
<tr>
<td>int * p()</td>
<td>p为返回指针的函数，该指针指向整型值</td>
</tr>
<tr>
<td>int (*p)()</td>
<td>p为指向函数的指针，该函数返回整型值</td>
</tr>
<tr>
<td>int **p</td>
<td>p为指向指针的指针，p指向的指针指向整型数据</td>
</tr>
</tbody></table>
</div>

<ul>
<li><span class="strong">指针</span>：一个变量的地址称为该变量的”指针”，反之亦然，变量的指针即变量的地址</li>
<li><span class="strong">指针变量</span>：专门用于存放地址的变量</li>
<li><span class="strong">&amp;</span>：取地址运算符</li>
<li><span class="strong">*</span>：指针运算符，取出指针变量指向的内容，又称为间接寻址运算符<br>指针的定义：<div class="apiBox">数据类型 * 变量名</div></li>
</ul>
<div class="show"><code>int a=10;
int * p;//定义int *类型的变量p，p只能用于存储地址，*只是表明该变量是指针变量
p=&a;//取出变量a的地址并存储到p中
printf("%d",* p);//*p表示取出变量p中地址指向的内容，等价于printf("%d",a)
printf("%p",&a);//输出变量a在内存中所占存储空间的首地址，等价于printf("%p",p)</code></div>

<p>使用指针的注意事项：</p>
<ul>
<li><span class="text-red">不要使用未初始化的指针变量</span>，未决定指针指向时，可以使指针变量初始化为<span class="text-blue">NULL</span>(stdio.h中定义为零值的宏)</li>
<li>要永远清楚指针指向哪里，指针必须指向一块有意义的内存</li>
<li>要永远清楚每个指针指向的对象内容是什么</li>
</ul>
<h4 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h4><p>使用指针操作数组可以有效提高运行速度，减小内存占用。数组在定义时，编译系统就会为其分配连续的内存单元，相应地，内存首地址也确定了。C语言中，数组名代表数组首元素的内存地址(数组名作形参时除外，此时数组名不占据内存单元)，因此可以直接将数组名赋值给指针变量</p>
<div class="show">由于
<ul><li>数组变量名代表数组起始内存地址</li><li>数组首元素地址也是数组起始内存地址</li></ul>因此指针初始化一般可以用两个赋值方法，两个赋值语句等价:
int a[10]; int * p;
<span class="text-red">p=a;</span>或
<span class="text-red">p=&a[0];</span>
</div>

<p>而后，就可以使用指针引用数组元素。对于指针变量p，p+1将指向数组的下一个元素，即地址跳到<span class="text-green">1*sizeof(基类型)</span>个字节以后，而非对p中的地址进行简单加1，如：如果p指向int类型的数组，p+1会将p中的地址值增加4个字节对应的地址值，使其指向4个字节以后的空间。使用指针引用数组元素有以下特点：</p>
<div class="apiBox">p+i和a+i均是a[i]的地址
*(p+i)和*(a+i)均是a[i]的值
</div>

<p>实际上，读取数组元素a[i]就是通过*(a+i)处理，即在数组首元素地址的基础上加上地址偏移量得到要找元素的地址，然后取出该地址中的数据，由此可得，<span class="tips">[ ]实际上是变址运算符</span>，指向数组的指针变量也可以使用该变址运算符，如：p[i]等价于*(p+i)等价于i[p]</p>
<div class="show">数组元素a[i]的表示方法有：
<span class="strong">a[i]</span>、<span class="strong">i[a]</span>、<span class="strong">p[i]</span>、<span class="strong">i[p]</span>、<span class="strong">*(a+i)</span>、<span class="strong">*(p+i)</span>
</div>

<h5 id="常用的指针变量运算"><a href="#常用的指针变量运算" class="headerlink" title="常用的指针变量运算"></a>常用的指针变量运算</h5><ul>
<li><span class="strong">*p++</span> 右结合，解析为*(p++)，先获得*p的值，再使p+1=&gt;p</li>
<li><span class="strong">*(++p)</span> 先对p加1，使其指向下一个元素，再获得此时*p的值</li>
<li><span class="strong">(*p)++</span> 获得*p的值，并对该值加1</li>
<li><span class="strong">*(p--)，*(--p)，(*p)--</span> 与上类似</li>
</ul>
<!-- <div class="show">1. &*p等价于&a
2. *&a等价于a
3. (*p)++等价于a++，由于++和*同优先级且右结合，因此不能写为*p++，否则会被解析为*(p++)</div> -->

<h5 id="数组元素的遍历"><a href="#数组元素的遍历" class="headerlink" title="数组元素的遍历"></a>数组元素的遍历</h5><p>在遍历数组元素时，通过数组下标或通过数组元素地址遍历，二者执行效率是相同的，C编译系统对nums[i]的处理也是将其转换为*(nums+i)来作处理的，即根据首元素地址重新计算元素偏移地址，再访问该地址</p>
<p>而通过指针变量遍历时，指针变量通过有规律地改变地址值(p++)，直接指向元素，不必每次都重新计算地址，极大提高了执行效率</p>
<div class="show">遍历数组的三种方法：
int nums[5]={11,22,33,44,55};
//1.利用数组下标
for(int i=0;i&lt;5;i++){
    printf("%d",nums[i])
}
//2.通过求出数组元素地址，获得值
for(int i=0;i&lt;5;i++){
    printf("%d",*(nums+i))
}
<span class="strong">//3.通过指针变量
for(int *p=nums;p&lt;(nums+5);p++){
    printf("%d",*p)
}</span>
注意：p++和p+1本质是两个不同的操作，特别对于指针变量而言，p++有赋值操作，会修改p的值从而使p指向下一个元素，而p+1并不改变当前指针的指向

<p><span class="text-red">数组名nums代表数组元素首地址，是一个指针常量，它的值是固定不变的，因此只能像*(nums+i)一样基于此地址进行计算,不能使用nums++改变该地址值</span><br>for(int *p=nums;nums&lt;(p+5);nums++){//错误代码<br>    printf(“%d”,*a)<br>}</div></p>
<h4 id="指针与函数传参"><a href="#指针与函数传参" class="headerlink" title="指针与函数传参"></a>指针与函数传参</h4><p>使用指针作为函数参数时，不再是简单的<span class="tips">值传递</span>，而是<span class="tips">地址传递</span>，可以直接修改原参数的值</p>
<div class="show">eg:将一个数组中的值反序存放并输出
<code>#include&lt;stdio.h>
int main(void) &#123;
    void inv(int*, int);
    int nums[10] = &#123; 0,11,22,33,44,55,66,77,88,99 &#125;;
    printf("original array：");
    for (int* p = nums; p < nums + 10; p++) &#123;
        printf("%d ", *p);
    &#125;
    <span class="text-red">inv(nums, 10);</span>
    printf("\ninverted array：");
    for (int* p = nums; p < nums + 10; p++) &#123;
        printf("%d ", *p);
    &#125;
    return 0;
&#125;
void inv(<span class="text-red">int * p,int n</span>) &#123;//n为数组长度
    int temp;
    for (int i = 0; i < n / 2; i++) &#123;
        temp = *(p+i);
        *(p + i) = *(p + n - 1 - i);
        *(p + n - 1 - i) = temp;
    &#125;
&#125;</code>
在函数中修改数组值，实参与形参的对应关系一般有以下4中
1. 形参和实参都用数组名，形参接收实参的数组首地址，因此形参和实参数组共用一段内存空间。定义形参a[]时，可以不指定数组长度，因为编译器实际上是将形参数组名作为指针变量来处理，并不会真的开辟一个数组空间
void inv(int a[],int n)             inv(nums,10)
2. 实参用数组名，形参用指针变量。形参的指针初始指向数组元素首地址
void inv(int *p,int n)              inv(nums,10)
3. 实参和形参都用指针变量。实参n先指向数组首地址，再将该地址值传递给形参p，初始时两个指针指向同一个地址
void inv(int *p,int n)              int *n=nums; inv(n,10)
4. 实参为指针变量，形参为数组名。编译时，编译系统会将形参数组名作为a作为指针变量来处理，同样，初始时两个指针指向同一个地址
void inv(int a[],int n)             int *n=nums; inv(n,10)
</div>

<h4 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a>二维数组与指针</h4><p>一维数组可以拓展到二维数组、三维数组等等，以二维数组为例，一个二维数组可以视为是由多个一维数组构成的，即二维数组的数组元素也是一个数组。</p>
<div class="show">设一个3行4列的二维数组
<code>int a[3][4]={{0,0,0,0},{11,11,11,11},{22,22,22,22}};</code>
对于该数组，可以视为数组a中包含3个元素：a[0],a[1],a[2]，而这3个元素每个都是一维数组:
<span class="strong">a[0]</span>==> a[0][0]、a[0][1]、a[0][2]、a[0][3]
<span class="strong">a[1]</span>==> a[1][0]、a[0][1]、a[0][2]、a[0][3]
<span class="strong">a[2]</span>==> a[2][0]、a[0][1]、a[0][2]、a[0][3]
暂且忽略a[0],a[1],a[2]内部包含的内容，将它们当作普通的数组元素，由此：
数组a是包含a[0]、a[1]、a[2]三个数组元素的一维数组，其中：
a是数组首元素a[0]的地址(即&a[0])，a+1是a[1]的地址(&a[1])，a+2是a[2]的地址(&a[2])，所以：
<span class="strong">a=&a[0]，a+1=&a[1]，a+2=&a[2]</span>;
<span class="text-red">*(a+0)=a[0]，*(a+1)=a[1]，*(a+2)=a[2]</span>;

<p>此时将a[0]、a[1]、a[2]展开，这三个元素每个都是一维数组，在这三个数组内部，a[0]、a[1]、a[2]分别是它们内部一维数组的数组名，又因为C语言中数组名代表数组首元素地址，因此：<br>a[0]即为a[0][0]的地址，即&amp;a[0][0]，a[0]+1则为a[0][1]的地址 &amp;a[0][1]……<br>即：<br><span class="strong">a[0]+0=&amp;a[0][0]，a[0]+1=&amp;a[0][1]，a[0]+2=&amp;a[0][2]，a[0]+3=&amp;a[0][3]</span><br><span class="text-red">*(a[0]+0)=a[0][0]，*(a[0]+1)=a[0][1]，*(a[0]+2)=a[0][2]，*(a[0]+3)=a[0][3]</span>;</p>
<p>由于<span class="text-red">a[0]和*a</span>等价，因此<br>a[0]+0与*(a+0)均是a[0][0]的地址，a[0]+1与*(a+0)+1均是a[0][1]的地址，其他同理，由此可得：<br><span class="text-blue">*(a[0])=*(*(a+0)+0)=**a=a[0][0]，*(a[0]+1)=*(*(a+0)+1)=*(*a+1)=a[0][1]</span><br><span class="text-blue">*(a[1]+2)=*(*(a+1)+2)=a[1][2]，*(a[2]+3)=*(*(a+2)+3)=a[2][3]</span><br><span class="text-blue">其他以此类推</span></p>
<p><span class="text-red">注意！<br>对于一维数组，a[i]代表一个数组元素，占据内存单元，拥有物理地址，但在二维数组中，a[i]代表一维数组名，只是一个地址(如同一维数组中的数组名只是一个指针常量一样)，务必记住，a[i]和*(a+i)是等价的</span></p>
</div>

<p>由上，总结：</p>
<p>表示a[i][j]<span class="text-blue">地址</span>的方法：</p>
<ul>
<li><span class="text-blue">a[i]+j</span></li>
<li><span class="text-blue">*(a+i)+j</span></li>
<li><span class="text-blue">&amp;a[i][j]</span></li>
</ul>
<p>表示a[i][j]<span class="text-red">值</span>的方法：</p>
<ul>
<li><span class="text-red">*(a[i]+j)</span></li>
<li><span class="text-red">*(*(a+i)+j)</span></li>
<li><span class="text-red">(*(a+i))[j]</span></li>
<li><span class="text-red">a[i][j]</span></li>
</ul>
<h6 id="二维数组的行指针与列指针"><a href="#二维数组的行指针与列指针" class="headerlink" title="二维数组的行指针与列指针"></a>二维数组的行指针与列指针</h6><div class="show">对于二维数组，其地址也可以分为行地址和列地址，如图所示：
<div class="table"><table><thead>
<tr><th colspan="5">二维数组存储</th></tr>
</thead>
<tbody>
<tr style="color:#fb5b33;"><td style="color:#056efb;">行/列地址</td><td>a[i]+1</td><td>a[i]+2</td><td>a[i]+3</td><td>a[i]+4</td></tr>
<tr><td style="color:#25ccf7;">a+0</td><td>a[0][0]</td><td>a[0][1]</td><td>a[0][2]</td><td>a[0][3]</td></tr>
<tr><td style="color:#25ccf7;">a+1</td><td>a[1][0]</td><td>a[1][1]</td><td>a[1][2]</td><td>a[1][3]</td></tr>
<tr><td style="color:#25ccf7;">a+2</td><td>a[2][0]</td><td>a[2][1]</td><td>a[2][2]</td><td>a[2][3]</td></tr></tbody></table></div><p>其中，二维数组名a是指向行地址的，因此a+1中的"1"代表一个含有4个整型元素的一维数组所占存储单元的字节数，即<span class="text-green">4*sizeof(int)</span>，a+1将指向下一行</p><p>一维数组名a[0]、a[1]、a[2]是指向列元素的，a[0]+1中的1代表一个整型元素所占存储单元的字节数，a[0]+1将指向下一个列元素</p><p>在指向行的指针前加一个*，就转换为指向列的指针，如：指针a和a+1是指向行的，而*a和*(a+1)则是指向列的，它们拓展为*(a+0)+0和*(a+1)+0，分别指向第0行0列元素和第1行第0列。反之，在指向列的指针前加上&，该指针就变成了指向行的指针，如：列指针a[0]指向第0行第0列的元素，而&a[0]等价于&*(a+0)，而&*a等价于a，因此&a[0]是指向第0行的行指针。注意，&a[i]不能理解为a[i]的物理地址，因为二维数组中并不存在a[i]元素，它只是一个地址计算方法，能得到第i行的起始地址。</p>
练习：
a、a+0、&a[0]代表第0行首地址
*a、*(a+0),a[0],a[0]+0代表第0行第0列的地址
&a[0][0]代表第0行第0列元素地址
a[0][0]、**a代表第0行第0列元素值
a+i、&a[i]代表第i行地址
a[i]+j、\*(a+i)+j,&a[i][j]代表第i行第j列地址
a[i][j]、\*(\*(a+i)+j)代表第i行第j列元素值
</div>

<h5 id="二维数组元素的引用-指针变量"><a href="#二维数组元素的引用-指针变量" class="headerlink" title="二维数组元素的引用(指针变量)"></a>二维数组元素的引用(指针变量)</h5><h6 id="通过二维数组的列指针变量引用"><a href="#通过二维数组的列指针变量引用" class="headerlink" title="通过二维数组的列指针变量引用"></a>通过二维数组的列指针变量引用</h6><p>由于列指针指向数组的具体元素，因此定义列指针与定义同类型普通指针相同：<br><span class="strong">int * p</span><br>可以用以下三种等价方法对其进行初始化：</p>
<ul>
<li><span class="strong">p=a[0]</span></li>
<li><span class="strong">p=*a</span></li>
<li><span class="strong">p=&amp;a[0][0]</span></li>
</ul>
<p>此时，由于需要使用列指针对二维数组元素进行引用，因此可以将二维数组看成一个由m行*n列个元素组成的一维数组，获取第i行j列的元素，则其在一维数组中的索引为i*n+j，因此a[i][j]元素的地址为<span class="text-blue">p+i*n+j</span>，其值表示方法为<span class="text-red">*(p+i*n+j)</span>或<span class="text-red">p[i*n+j]</span></p>
<p>注意，此时不能用p[i][j]来表示数组元素，因为给p赋初值时将其赋为了列指针，即是将二维数组作为一维数组来进行处理的，p++将使指针依次指向下一个数组元素。正因如此，在定义二维数组的列指针时，无须指定它所指向的二维数组的列数。因此二维数组的列指针也常常用作函数参数，以实现二维数组的行列数需要动态指定的场合。</p>
<div class="show">eg:使用二维数组列指针引用数组元素
<code>#include&lt;stdio.h>
int main(void) &#123;
    void outputArray(int *,int);
    int a[3][4] = &#123; &#123;11,11,11,11&#125;,&#123;22,22,22,22&#125;,&#123;33,33,33,33&#125; &#125;;
    <span class="text-red">outputArray(a[0], 12);//列指针初始化int *p=a[0]</span>
    <span class="text-blue">outputArray(*a, 12);//列指针初始化int *p=*a</span>
    <span class="text-green">outputArray(&a[0][0], 12);//列指针初始化int *p=&a[0][0]</span>
    return 0;
&#125;
void outputArray(int* p, int length) &#123;
    for (int* index = p; index < p + length; index++) &#123;
        printf("%d,", *index);
    &#125;
    printf("\n");
&#125;</code></div>

<h6 id="通过二维数组的行指针变量引用"><a href="#通过二维数组的行指针变量引用" class="headerlink" title="通过二维数组的行指针变量引用"></a>通过二维数组的行指针变量引用</h6><p>由于行指针不再指向数组元素，而是指向一维数组，因此行指针变量比较特殊：<br><span class="strong">int (*p)[4]</span><br>可以用以下方法对其进行初始化：</p>
<ul>
<li><span class="strong">p=a</span></li>
<li><span class="strong">p=&amp;a[0]</span></li>
</ul>
<p>说明：定义了一个可指向含有4个元素一维整型数组的指针变量，[4]表示所指一维数组的长度，<span class="tips">在声明变量时必须显式指定，不可省略!</span>该指针可以作为一个指向二维数组的行指针，且它所指向的二维数组的每一行有4个元素。注意：定义该行指针变量时( )也不可省略，因为[ ]优先级高于*，p会优先与[ ]结合，int *p[4]是指针数组的定义方式。<br>可以用以下四种等价形式引用a[i][j]的值:</p>
<ul>
<li><span class="strong">p[i][j]</span></li>
<li><span class="strong">*(p[i]+j)</span></li>
<li><span class="strong">*(*(p+i)+j)</span></li>
<li><span class="strong">(*(p+i))[j]</span></li>
</ul>
<p>对于行指针变量，p++将指向二维数组的下一行，即移动4*sizeof(int)字节，因此需要显式指定所指一维数组的长度int (*p)[4]，否则无法计算指针移动的字节数。</p>
<div class="show">eg:使用行指针读入、输出二维数组元素
<code>#include&lt;stdio.h>
#define N 3
int main(void) &#123;
    <span class="text-red">//用普通的二维数组方式操作数组
    void inputArray(int p[][N], int,int);
    void outputArray(int p[][N], int,int);</span>
    <span class="text-blue">//只使用行指针操作数组元素
    void inputArray(int(*p)[N], int, int);
    void outputArray(int(*p)[N], int, int);</span>
    int a[2][3];
    printf("Input 2*3 numbers:\n");
    inputArray(a, 2,3);//把数组行数和列数也传参
    outputArray(a, 2,3);
    return 0;
&#125;
<span class="text-red">void inputArray(int p[][N], int rows,int columns) &#123;</span>
<span class="text-blue">void inputArray(int (*p)[N], int rows, int columns) &#123;</span>
    printf("Input numbers:\n");
    for (int i = 0; i < rows; i++) &#123;
        for (int j = 0; j < columns; j++)
        &#123;
            <span class="text-red">scanf_s("%d", &p[i][j]);</span>
            <span class="text-blue">scanf_s("%d", *(p+i)+j);</span>
        &#125;
    &#125;
&#125;
<span class="text-red">void outputArray(int p[][N], int rows, int columns) &#123;</span>
<span class="text-blue">void outputArray(int (*p)[N], int rows, int columns) &#123;</span>
    printf("Output numbers:\n");
    for (int i = 0; i < rows; i++) &#123;
        for (int j = 0; j < columns; j++)
        &#123;
            <span class="text-red">printf("%d,", p[i][j]);</span>
            <span class="text-blue">printf("%d,", *(*(p+i)+j));</span>
        &#125;
    &#125;
&#125;</code>
</div>

<h4 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h4><p>一个函数在编译时被分配一个入口地址，与数组类似，函数名代表该函数的入口地址，函数的入口地址就称为该函数的指针，可以用一个指针变量指向函数，然后通过该指针变量调用该函数，指向函数的指针变量的定义形式为：<br><span class="strong">函数返回值类型 (* 指针变量名)(函数参数)</span></p>
<ul>
<li>定义举例：int (*p)(int,int)，表示定义一个指向函数的指针变量p，它可以任意指向同类型的不同函数(该函数应是int类型且有两个int参数)，并非固定指向一个函数</li>
<li>*p两侧的括号不能省略，p先与*结合表明是指针变量，再与后面的( )结合表明该指针变量指向函数</li>
<li>对指向函数的指针变量进行p++、p+n等操作是无意义的</li>
</ul>
<div class="show">eg:
<code>int main(void)&#123;
    int getMax(int,int);
    <span class="text-blue">int (*p)(int,int);</span>//定义指向函数的指针
    int a=10,b=20;
    <span class="text-blue">p=getMax;</span>//将函数地址赋给p，不涉及实参和形参问题，因此不需要写任何参数
    int result=<span class="text-blue">(*p)(a,b)</span>;//使用指针调用函数，只需用(*p)替代函数名即可
    return 0;
&#125;
int getMax(int a,int b)&#123;
    return a>b?a:b;
&#125;
</code></div>

<p>函数指针变量的用途之一是将函数作为参数传递到其他函数，即实现函数入口地址的传递，常见用法是：调用同一个函数时，在不同情况下实现不同的功能</p>
<div class="show">eg:多次调用process函数，依次实现求最大值、求和、求积功能
<code>#include&lt;stdio.h>
int main(void) &#123;
    int getMax(int, int);
    int add(int, int);
    int multiply(int, int);
    <span class="text-blue">void process(int, int, int (* fun)(int, int));</span>
    int a = 10, b = 20;
    <span class="text-blue">process(a, b, getMax);
    process(a, b, add);
    process(a, b, multiply);</span>
    return 0;
&#125;
void process(int a,int b,int (* fun)(int,int)) &#123;
    int result =<span class="text-blue">(*fun)(a, b)</span>;//fun指向不同函数地址，实现不同功能
    printf("%d\n", result);
&#125;
int getMax(int a, int b) &#123;
    return a > b ? a : b;
&#125;
int add(int a, int b) &#123;
    return a + b;
&#125;
int multiply(int a, int b) &#123;
    return a * b;
&#125;</code></div>

<h4 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h4><p>函数除了可以返回整型值、字符值等，也可以返回一个指针(返回一个地址)，这种返回指针的函数，定义形式为:<br><span class="strong">类型 * 函数名(参数)</span></p>
<ul>
<li>函数定义举例：int * fun(int,int)，定义一个函数fun，该函数返回类型为int *，即返回一个指针，该指针指向int类型的数据，函数名fun和*两侧没有( )，fun先与(int,int)结合表明fun()是个函数</li>
<li>通过返回指针，C语言就可以实现返回数组、字符串等数据</li>
</ul>
<div class="show">eg:拼接两个字符串，返回一个新的字符串
<code>#include&lt;stdio.h>
int main(void) &#123;
    char* str1 = "aaa", * str2 = "111";
    char result[20];//存储拼接后的字符串，空间要足够大
    <span class="text-blue">char* strCat(char*, char*,char *);</span>
    printf("%s", strCat(result, str1, str2));
    return 0;
&#125;
char* strCat(char * result,char* str1, char* str2) &#123;
    char* p = result;
    while (*str1 != '\0') &#123;
        *p = *str1;
        str1++;
        p++;
    &#125;
    while (*str2 != '\0') &#123;
        *p = *str2;
        str2++;
        p++;
    &#125;
    *p = '\0';//拼接后的字符串末尾加上字符串结束标志符
    return result;//返回result数组的初始起始地址
&#125;</code>
</div>

<h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>一个数组，若其元素均为指针，则该数组为指针数组，一维指针数组的定义形式为：<br><span class="strong">类型名 * 数组名[数组长度]</span></p>
<ul>
<li>如：int *p[4]，p先与[4]结合，形成p[4]，表明这是一个数组，再与*结合，表明该数组是指针类型</li>
<li>注意区分于int (*p)[4]，这是指向一维数组的指针变量，即指向二维数组指针变量中的行指针</li>
<li>指针数组可用于指向不等长字符串、不等长数组等场景</li>
</ul>
<div class="show">指针数组可以指向若干不等长的字符串，如果用二维数组存储字符串，需要指定第二维的长度(一般为最长字符串的长度+1)，相较于二维数组，指针数组更为灵活快捷
eg:将若干字符串按字母顺序排序
<code>#include&lt;stdio.h>
#include&lt;string.h>
int main(void) &#123;
    void sort(char* ptr[], int length);
    <span class="text-blue">char* ptr[]</span>= &#123; "Document","ASCII","Java","CPP" &#125;;
     sort(ptr, 4);
     for (int i = 0; i < 4; i++) &#123;
         printf("%s\n", ptr[i]);
     &#125;
    return 0;
&#125;
void sort(char* ptr[], int length) &#123;
    char* temp;
    int i, j, k;
    for (i = 0; i < length-1; i++) &#123;
        k = i;
        for (j = i + 1; j < length; j++) &#123;//内循环找出全部字符串中字符顺序最小的字符串
            if (strcmp(ptr[k], ptr[j]) > 0) &#123;//strcmp()函数，ptr[k]中的字母在ASCII中位置大于ptr[j]，则返回值大于0
                k = j;
            &#125;
        &#125;
        if (k != i) &#123;//如果找到的字符串不是i，调换顺序
            temp = ptr[i]; ptr[i] = ptr[k]; ptr[k] = temp;
        &#125;
    &#125;
&#125;
</code></div>

<h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>指针变量也可以指向一个另一个指针，指向指针的指针变量定义形式为：<br><span class="strong">类型 *** 变量名</span></p>
<ul>
<li>如：char **p，指针变量p指向另一个指针变量，被p指向的指针变量指向一个字符型数据</li>
<li>结合上一节的指针数组，就可以用指向指针的指针操作指针数组中的指针所指向的数据</li>
<li>理论上指向指针的指针可以无限套娃，如：int *****p，但多层指针嵌套容易混乱，难以理解</li>
</ul>
<div class="show">1. eg:用指向指针的指针输出指针数组指向的内容
<code>#include&lt;stdio.h>
int main(void)&#123;
    char* ptr[]= &#123; "Document","ASCII","Java","CPP" &#125;;
    <span class="text-blue"> char **p;</span>
    for(int i=0;i&lt;4;i++)&#123;
        p=ptr+i;
        printf("%s\n",<span class="text-blue">*p</span>);
    &#125;
&#125;</code>
2. eg:注意输出字符串、数组数据与整型等其他普通类型数据时，指针运算符(间接寻址运算符)需要取到哪一层值(取出的值是地址值还是变量本身的值)
<code>#include&lt;stdio.h>
int main(void)&#123;
    int a = 11, b = 22;
    int c = a + b;
    int d = a + b + c;
    int* nums[] = &#123; &a,&b,&c,&d &#125;;
    <span class="text-blue">int** p=nums;</span>
    for (int i = 0; i < 4; i++,p++) &#123; 
        printf("%d\n",<span class="text-blue">**p</span>);
    &#125;
    return 0;
&#125;</code>
</div>

<h4 id="void-无类型指针"><a href="#void-无类型指针" class="headerlink" title="void * 无类型指针"></a>void * 无类型指针</h4><p>void *称为通用指针或无类型指针，用于声明基类型未知的指针变量，即声明了一个指针变量，但未指定它指向哪一种基类型的数据。它可以指向任意类型的数据，只需要在将它的值赋给其他类型的指针变量时，进行强制类型转换即可。ANSI标准要求动态分配内存的函数(malloc、calloc等)返回类型为void *无类型指针，方便将其转换为其他任意类型的指针变量。</p>
<p>注意区别于<span class="tips">空指针(NULL)</span>，空指针未指向任何有效内存(指向低地址保留区)，而<span class="tips">void *</span>当值不为NULL时，它指向了有效内存空间，只是尚未指定它指向的基类型。</p>
<div class="show">void *和其他类型的指针可以相互转换
<code>char *str;
void *p;
str=(char *)p;
或
p=(void *)str;</code>
动态分配内存函数返回值根据指向数据类型需要转换为其他类型
<code>int * p=(int *)malloc(10*sizeof(int));</code></div>

<h4 id="指针数组与main函数的形参"><a href="#指针数组与main函数的形参" class="headerlink" title="指针数组与main函数的形参"></a>指针数组与main函数的形参</h4><p>一般情况下，main函数一般会写为空参数形式：int main(void)，实际上main函数可以带有参数，如：<br><span class="strong">int main(int argc,char * argv[])</span><br>Java语言中的main默认就为上述形式，argc和argv就是main函数的形参。main函数由操作系统调用，在main所在的.c文件被编译后，会生成可执行文件(windows下后缀为.exe)，在系统命令终端下(如：Linux的shell、windows的cmd)，输入<span class="strong">文件路径/可执行文件名 参数1 参数2…</span>即可调用该可执行文件并将参数传递给main函数</p>
<div class="show">假设main函数写于文件file.c文件中，编译后生成file.out文件
在该文件所属路径下执行命令：<span class="strong">file.out data1 data2</span>
对于main函数原型<span class="strong">int main(int argc,char * argv[])</span>
argc指命令行中的参数个数，argv[]是存储参数字符串首地址的指针数组
它收到3个命令行参数：file.out，data1，data2 //file.out也算一个参数
所以argc=3，"file.out"、"data1"、"data2"字符串的首地址构成一个指针数组，存储于argv中：
argv[0]--->"file.out\0"
argv[1]--->"data1\0"
argv[2]--->"data2\0"
由于并不清楚输入的参数会多长，使用指针数组就可以巧妙解决这个问题
可以写一个main函数输出执行时传入的参数内容：
<code>int main(int argc,char * argv[])&#123;
    while(argc&gt;1)&#123;
         ++argv;
        printf("%s\n",*argv);
        --argc;
    &#125;
&#125;</code>
</div>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h4><div class="table">
<table>
<thead>
<tr><th>优先级</th><th>运算符</th><th>名称</th>
<th>使用</th><th>说明</th><th>结合方式</th></tr>
</thead>
<tbody>
<tr><td rowspan="4">1</td><td>[&nbsp;]</td><td>数组下标</td><td>数组名[]</td><td rowspan="4"></td><td rowspan="4">从左到右</td></tr>
<tr><td>(&nbsp;)</td><td>圆括号</td><td>(表达式)</td></tr>
</tr><td>.</td><td>成员选择（对象）</td><td>对象.成员名</td></tr>
</tr><td>-&gt;</td><td>成员选择（指针）</td><td>对象指针->成员名</td></tr>
<tr><td rowspan="9">2</td><td>-</td><td>负号</td><td>-表达式</td><td rowspan="9">单目运算符</td><td rowspan="9"><span class="tips">从右到左</span></td></tr>
<tr><td>(类型)</td><td>类型转换</td><td>(数据类型)表达式</td></tr>
<tr><td>sizeof(&nbsp;)</td><td>长度运算符</td><td>sizeof(表达式)</td></tr>
<tr><td>！</td><td>逻辑非</td><td>!表达式</td></tr>
<tr><td>~</td><td>按位取反</td><td>~表达式</td></tr>
<tr><td>*</td><td>取值</td><td>*指针变量</td></tr>
<tr><td>&</td><td>取地址运算符</td><td>&变量名</td></tr>
<tr><td>++</td><td>自增</td><td>++变量名或
变量名++</td></tr>
<tr><td>--</td><td>自减</td><td>--变量名或变量名--</td></tr>
<tr><td rowspan="3">3</td><td>*</td><td>乘</td><td>表达式*表达式</td><td rowspan="3">双目运算符</td><td rowspan="3">从左到右</td></tr>
<tr><td>/</td><td>除</td><td>表达式/表达式</td></tr>
<tr><td>%</td><td>求余</td><td>表达式%表达式</td></tr>
<tr><td rowspan="2">4</td><td>+</td><td>加</td><td>表达式+表达式</td><td rowspan="2">双目运算符</td><td rowspan="2">从左到右</td></tr>
<tr><td>-</td><td>减</td><td>a-b</td></tr>
<tr><td rowspan="2">5</td><td>&lt;&lt;</td><td>左移</td><td>变量&lt;&lt;表达式</td><td rowspan="2">双目运算符</td><td rowspan="2">从左到右</td></tr>
<tr><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td></tr>
<tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=</td><td>关系运算(大于，大于等于，小于，小于等于)</td><td>a&lt;b</td><td>双目运算符</td><td>从左到右</td></tr>
<tr><td>7</td><td>==、!=</td><td>是否等于</td><td>if(a==b)</td><td>双目运算符</td><td>从左到右</td></tr>
<tr><td>8</td><td>&</td><td>按位与</td><td>a&b</td><td>双目运算符</td><td>从左到右</td></tr>
<tr><td>9</td><td>^</td><td>按位异或</td><td>a^b</td>
<td>双目运算符</td><td>从左到右</td></tr>
<tr><td>10</td><td>|</td><td>按位或</td><td>a|b</td><td>双目运算符</td><td>从左到右</td></tr>
<tr><td>11</td><td>&&</td><td>逻辑与</td><td>a&&b</td><td>双目运算符</td><td>从左到右</td></tr>
<tr><td>12</td><td>||</td><td>逻辑或</td><td>a||b</td><td>双目运算符</td><td>从左到右</td></tr>
<tr><td>13</td><td>?&nbsp;:</td><td>条件运算</td><td>a>b?true:false</td><td>三目运算符</td><td><span class="tips">从右到左</span></td></tr>
<tr><td rowspan="2">14</td><td>=</td><td>赋值运算</td><td>a=10</td><td rowspan="2">双目运算符</td><td rowspan="2"><span class="tips">从右到左</span></td></tr>
<tr><td>+=、-=、*=、/=、%=、>>=、<<=、&=、^=、|=</td><td>运算后赋值</td><td>a+=10</td></tr>
<tr><td>15</td><td>,</td><td>逗号运算符(按顺序求值)</td><td>a,b,c</td><td></td><td>从左到右</td></tr>
</tbody>
</table>
</div>

<h4 id="赋值与复合赋值"><a href="#赋值与复合赋值" class="headerlink" title="赋值与复合赋值"></a>赋值与复合赋值</h4><p>静态变量和全局变量的赋值在编译阶段进行，而局部自动变量的赋值在程序运行到该语句时进行。赋值语句遵循<span class="tips">右结合</span>原则(从右向左运算)</p>
<div class="show">1. 赋值遵循右结合
int a,b,c;
a=b=c=0;执行过程为a=(b=(c=0))
2. 复合赋值
n*=m+1;
等价于n=n*(m+1)
3. 复合赋值会即时修改变量值
int a=3;
a+=a-=a*a;//执行完a=-12
a+=a-=a*=a;//执行完a=0
</div>

<p>赋值语句需要注意：将字节数长的数据赋值给字节数短的变量，会截取部分数据，也可能造成整个数据错误</p>
<ul>
<li>浮点型(float、double)数据赋值给整型变量，将舍弃小数部分</li>
<li>将double数据赋值给float变量，将截取前7位有效数字</li>
<li>将int、short、long型数据赋值给char变量，只截取该数据的低8位到char变量中</li>
<li>将unsigned 数据赋值给有符号整型时，进行高位补0即可，但如果该unsigned 数据的数值超出了有符号整型最大值范围时，会产生数据错误!</li>
</ul>
<p>将字节数短的数据赋值给字节数长的变量，一般需要进行位拓展</p>
<ul>
<li>将整型数据赋值给浮点型变量，数值不变，拓展小数部分为0以浮点数形式进行存储</li>
<li>将float数据赋值给double，数值不变，拓展有效位数</li>
<li>将char数据赋值给整型变量，将char的1个字节数据存储到低8位，如果该整型变量为无符号整型(unsigned)，则高8位补0。如果该整型变量为有符号整型，且该char字符最高位为0，则高8位补0，若char字符最高位为1，则高8位补1，以保证char对应的数值不变</li>
<li>将带符号的int赋值给long型变量，将int的值存入long的低16位，如果int为正整数(最高位为0)，则long的高16位补0，反之补1</li>
</ul>
<h4 id="自增与自减"><a href="#自增与自减" class="headerlink" title="自增与自减"></a>自增与自减</h4><p>用于对变量进行加1或减1操作，自增和自减运算符都属于一元运算符，只需要一个操作数，且<span class="tips">操作数必须是变量，不能是常量或表达式</span>。自增与自减运算符分为前缀(如++i)和后缀(i++)形式。区别在于前缀是先对变量进行加1操作，再使用变量。后缀形式是先使用变量的当前值，再进行加1操作，自减运算符同理。</p>
<div class="show">-i++;//应当解析为-(i++)，而非(-i)++，因为自增运算符操作数不能为表达式-i，(-i)++是非法语句
i+++j;//应当解析为(i++)+j，C编译系统会从左至右尽可能多地将若干个字符组成一个运算符
</div>

<h4 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h4><p><span class="strong">表达式1,表达式2,…表达式n</span><br>用于串联多个表达式，表达式从左至右顺序运算，<span class="tips">整个逗号表达式的值是最后一个表达式的值</span><span class="tips"></span>。多数情况下，逗号表达式仅用来顺序求值，并不一定用到整个逗号表达式的最终值。常见的情况是用于for语句进行多个变量的顺序运算，<span class="tips">逗号表达式的运算优先级是所有运算种最低的</span>。</p>
<div class="show">a=2*5,a*4;//逗号表达式运算优先级最低，所以a=10，整个逗号表达式值等于40
b=(a=2*5,a*4);//正确获得逗号表达式值的方法，运算结果：a=10,b=40
(a=3*5,a*4),a+5;//逗号表达式也可以嵌套到其他的逗号表达式中，运算结果：a=15，逗号表达式=20
for(i=0,j=0;i&lt;array.length,j&lt;i;i++,j++);//逗号表达式常用于for语句多变量运算
printf("%d,%d,%d",a,b,c);//逗号用于间隔函数参数,并不是逗号表达式
printf("%d,%d,%d",(a,b,c),b,c);//(a,b,c)是逗号表达式，输出值为c的值
</div>

<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>位运算是直接对二进制位进行运算，<span class="tips">只能用于整型或字符型数据</span>，不能用于浮点型，位运算符常用于编写系统软件。对于需要两个操作数的位运算，如果给的两个操作数长度不同，则系统将给较短的操作数高位补0或1，以保证两个操作数长度相同。如果该数是无符号数或者正数，则高位补0，如果为负数则高位补1。</p>
<h6 id="取反"><a href="#取反" class="headerlink" title="取反~"></a>取反~</h6><p>取反运算为单目运算符，用于将二进制数按位取反,eg:~12=-13</p>
<h6 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与&amp;"></a>按位与&amp;</h6><p>对两个数的二进制码进行按位与，该运算有一些特殊用途：</p>
<ul>
<li>数据清零，使之与0相与即可将所有二进制位置为0</li>
<li>保留或截取一个数中的某些指定位</li>
</ul>
<div class="show">1. 正数取原码相与，负数取其补码相与
3&5=1
   0000 0011
   0000 0101
 ------------
   0000 0001  
2. 若要保留一个数的低4位，将其与0000 1111相与
  1100 1011
  0000 1111
 -----------
  0000 1011 </div>

<h6 id="按位或"><a href="#按位或" class="headerlink" title="按位或|"></a>按位或|</h6><p>可用于将指定的二进制位置为1</p>
<h6 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或^"></a>按位异或^</h6><ul>
<li>使指定二进制位翻转</li>
<li>交换两个值，不使用临时变量</li>
<li>一个数与0相^，保留原值</li>
<li>一个数同本身相^，结果为0</li>
</ul>
<div class="show">1.使0100 1011的低四位翻转，可以与0000 1111相异或
0100 1011
0000 1111
----------
0100 0100
2. 异或可以交换两个值，且不使用临时变量
eg:a=3,b=4;交换a与b的值，可以使用：
a=a^b;
b=b^a;
a=a^b;
解析：
由上述语句1,2可得：b=b^a=b^(a^b)=a^b^b=a^0=a;
即b获得了a的值
由语句3可得：a=(a^b)^(a^b^b)=a^a^b^b^b=b;
</div>

<h6 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符&lt;&lt;"></a>左移运算符&lt;&lt;</h6><p>将一个数的二进制位左移若干位，高位溢出部分舍弃，低位补0。一个数左移n位，如果左边被舍弃的部分全为0，则该数相当于乘以2<sup>n</sup></p>
<div class="show">int result = 30&lt;&lt;2;//result=120</div>

<h6 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符&gt;&gt;"></a>右移运算符&gt;&gt;</h6><p>将一个数的二进制位右移若干位，低位溢出部分舍弃，高位补的值取决于该数值本身。如果是无符号数，或者该数符号位为0(该数为正)，则高位补0，如果该数为负数，高位补0还是补1取决于编译器，补0称为”逻辑右移”，补1称为”算术右移”。</p>
<p>同理，如果右边移除部分均为0，则右移n位相当于该数除以2<sup>n</sup></p>
<h6 id="位运算赋值运算符"><a href="#位运算赋值运算符" class="headerlink" title="位运算赋值运算符"></a>位运算赋值运算符</h6><p>位运算和赋值运算可以组成复合赋值运算符，如：&amp;=、|=、&lt;&lt;=、&gt;&gt;=、^=等</p>
<div class="show">a&lt;&lt;=2等价于a=a&lt;&lt;2</div>

<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>注意，关系运算符的优先级<span class="tips">低于</span>算术运算符，<span class="tips">高于</span>赋值运算符，且关系运算符中<span class="tips">&lt;</span>、<span class="tips">&lt;=</span>、<span class="tips">&gt;</span>、<span class="tips">&gt;=</span>的优先级是高于<span class="tips">==</span>、<span class="tips">!=</span>的</p>
<div class="show">c&lt;a+b等价于c&lt;(a+b)
a=b&gt;c等价于a=(b&gt;c)
a==b&lt;c应当等价于a==(a&lt;c)
</div>

<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>逻辑运算符中优先级顺序为<span class="tips">!高于&amp;&amp;高于||</span>，且&amp;&amp;和||有<span class="tips">短路特性</span></p>
<p>C语言中没有逻辑常量true和false，编译器在表示逻辑时使用1代表真，0代表假，在表示数值时，以非0代表真，0代表假</p>
<div class="show">优先计算!，再计算&&，最后计算||
!a&&b||x>y&&c
</div>

<h4 id="条件运算-三元表达式"><a href="#条件运算-三元表达式" class="headerlink" title="条件运算(三元表达式)"></a>条件运算(三元表达式)</h4><p><span class="strong">条件判断语句?表达式1:表达式2</span><br>先求解条件判断语句，若为真则执行表达式1，整个条件表达式的值<br>为表达式1的值，否则执行表达式2并作为条件表达式的值</p>
<div class="show">1. 条件运算符优先级高于赋值
max=a>b?a:b;等价于max=(a>b?a:b);
2. 条件运算符结合方向为从右至左
a>b?c:d>e?f:g;等价于a>b?c:(d>e?f:g)
</div>

<h3 id="选择与循环控制"><a href="#选择与循环控制" class="headerlink" title="选择与循环控制"></a>选择与循环控制</h3><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><p><span class="tips">if()..else</span>、<span class="tips">while()</span>、<span class="tips">do…while()</span>、<span class="tips">for</span></p>
<h5 id="switch多分支选择"><a href="#switch多分支选择" class="headerlink" title="switch多分支选择"></a>switch多分支选择</h5><div class="apiBox">switch(表达式)
  {
    case 常量表达式:语句1
    case 常量表达式:语句2
    ....
    default:       语句n
}</div>

<ul>
<li>case语句只起语句标号的作用，并不是在该处进行条件判断</li>
<li>switch语句表达式的值找到匹配的case入口标号后，会一直执行下去，不再进行判断，直到执行完或遇到break语句</li>
</ul>
<div class="show">1.满足匹配条件后，将依次执行后面的所有case语句，所以需要及时break。并且由于是依次执行，所以case后面是多个语句也不需要使用{ }括起来
switch(num)
  {
    case 1:printf("get 1");//如果num=1，则将输出get1、get2
    case 2:printf("get 2");break;
    case 3:{printf("get 3");break;}//可以不使用{ }
    default:printf("error\n");
}
2. 多个分支可以共用一个执行语句
switch(num)
  {
    case 1:
    case 2:
    case 3:printf("down");break;
    default:printf("error\n");
}
</div>

<h5 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h5><p>break用于终止循环和跳出switch，只能用于循环语句和switch语句。continue用于结束本次循环，代码将继续下一次循环判定。使用goto语句的形成的循环体不能使用这两个语句跳出循环。</p>
<div class="show">while(i&lt;10){
    if(i==5) break;
    .....
    i++;
}
while(i&lt;10){
     i++;
    if(i==5) continue;
    .....
}
</div>

<h5 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h5><p>goto语句为无条件转向语句，语法为：</p>
<div class="apiBox">goto 语句标号;</div>

<p>语句标号用标识符表示，命名规则同变量，常用于组成循环，或者从循环内部跳出循环，但会导致程序可读性差，结构混乱，应当谨慎使用。</p>
<div class="show">int i,sum;
i=sum=0;
loop:if(i&lt;10){
    sum+=i;
    i++;
    goto loop;
}
</div>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>谭浩强书的主函数一般写为void man()，但C语言标准(C99)定义的标准main函数写法为</p>
<div class="apiBox">int main(void){
    .....
return 0; 
}
或者
int main(int argc,char argv[]){.....return 0;}
</div>

<div class="show">在C语言中
int main()表示主函数可以传入任意个数的参数，而int main(void)表示该函数参数为空，不能传入任何参数
在C++中，int main()和int main(void)等效
</div>

<h4 id="标准输入输出函数"><a href="#标准输入输出函数" class="headerlink" title="标准输入输出函数"></a>标准输入输出函数</h4><p>C语言本身不提供输入输出语句，输入输出操作由C函数库中的函数提供支持。这是因为输入输出涉及到硬件操作，没有输入输出语句可以让C语言编译器避免在编译阶段处理硬件有关的问题，可以极大地简化编译系统，并提高其通用性和可移植性。</p>
<p>C函数库由各软件公司编写，并已经编译成目标文件(.obj文件)，源程序中的printf()等语句在编译阶段并不会被编译为目标指令，而是等待链接阶段源程序和库函数链接后，在执行阶段直接调用库函数目标文件(.obj文件)中的printf()函数。不同函数库提供的函数名、功能完全不同，但有一些通用的”标准输入输出函数”，调用这些函数需要引入头文件<span class="tips">#inculde&lt;stdio.h&gt;</span></p>
<h5 id="printf输出函数"><a href="#printf输出函数" class="headerlink" title="printf输出函数"></a>printf输出函数</h5><p>标准输出语句格式为：</p>
<div class="apiBox">printf("格式控制",输出表列)</div>

<p>输出表列即需要输出的数据，多个输出的数据使用<span class="tips">,</span>分隔，可以为表达式；格式控制需要使用双引号括起来，可以包括两种信息</p>
<ul>
<li>普通字符：printf会原样输出普通字符，包括空格、换行符等</li>
<li>格式字符：由%和格式字符组成，用于指定输出数据的格式</li>
</ul>
<div class="show">用于输出整型、浮点型、指数的格式字符:
1.<span class="tips">%d或%i</span>，用于输出int类型(-32768~32767之间)的十进制整数
2.<span class="tips">%ld</span>，输出长整型。%hd输出short类型，%I64d输出long long类型
3.<span class="tips">%md</span>,m用于指定宽度，若数据位数大于m则将原数据正常输出，小于m则左补空格
<code>eg: a=12345,b=123
printf("%4d,%4d",a,b);//输出12345, 123(123前补个空格)</code>
4.<span class="tips">%o,%x,%X</span>，以八进制、十六进制(字母小写)、十六进制(字母大写)形式输出整型(不输出前导符0和0x)，该输出方式会将符号位也作为八进制和十六进制的数值位输出，因此无法输出负数，输出时支持指定输出位数。同样,八进制和十六进制支持用<span class="tips">l</span>(long)、<span class="tips">h</span>(short)、<span class="tips">m</span>(输出位宽)修饰
5.<span class="tips">%u</span>，输出无符号(unsigned)整型，%lu输出unsigned long类型
6.<span class="tips">%c</span>，输出一个字符，支持将0~255内的整数输出为ASCII码对应字符，也支持将这些字符输出为整数
7.<span class="tips">%s</span>，输出字符串
<ul style="white-space: normal;">
<li><span class="strong">%ms</span>，指定输出的字符个数，若字符串串长大于m则原样输出字符串，若小于m则左补空格</li>
<li><span class="strong">%-ms</span>，同上，但是右补空格</li>
<li><span class="strong">%m.ns</span>，输出m个字符，但只取字符串左端n个字符，右对齐，左补空格</li>
<li><span class="strong">%-m.ns</span>，同上，但左对齐，右补空格</li>
</ul><code>eg：
printf("%5.2s","china");//输出   ch(左补3个空格)
printf("%4.2s","china");//输出  ch(右补2个空格)
printf("%-5.2s","china");//输出ch   (右补3个空格)
</code>
8.<span class="tips">%f</span>，输出浮点数(包括单、双精度)，输出全部整数部分，并输出6位小数。单精度浮点数有效位数一般为7位，双精度浮点数有效位数一般为16位，给出小数6位。
<ul style="white-space: normal;">
<li><span class="strong">%m.nf</span>，输出m列(小数点算一列)，其中保留有n位小数(四舍五入)，左补空格</li>
<li><span class="strong">%-m.nf</span>，同上，但左对齐，右补空格</li>
<li><span class="strong">%.nf</span>，省略m，即输出所有整数部分，保留n位小数</li>
</ul><code>eg：float a=123.456
printf("%f",a);//输出123.456001，输出6位小数，有一定存储误差
printf("%8.2f",a);//输出  123.46，左补2个空格，保留2位小数，小数四舍五入
printf("%-8.2f",a);//输出123.46  ，右补2个空格
printf("%.2f",a);//输出123.46，整数部分全部输出，小数部分保留2位 
float x,y;
x=111111.111,y=222222.222;
printf("%f",x+y);//输出333333.328125，只有前7位有效
</code>
9. <span class="tips">%e或%E</span>，以规格化指数形式输出小数，e和E分别表示指数e的大小写形式，可以使用<span class="tips">%m.ne或%m.nE</span>形式指定输出位数和数字部分的小数位数，一般默认数字部分的小数数位为6位，指数部分为5位(如：e+002)
<code>printf("%e",123.456);
printf("%e",123.456);//输出1.234560e+002，默认数字部分6位小数
printf("%10.2E",123.456);//输出 1.23E+002，左补1个空格，数字部分的小数保留2位，注意：小数点、e、+等字符均占用一个位置</code>
10.<span class="tips">%g或%G</span>，根据数值大小自动选择使用%f或%e形式，保证输出宽度最小，不输出无意义的0
11.<span class="tips">%%</span>，输出%
12.<span class="tips">%p</span>，以十六进制无符号整数形式输出变量或指针变量的地址
<code>int num = 10;
int* p;
p = &num ;
printf("%p\n", &num);//输出结果参考:001DFB0C
printf("%p\n", p);</code>
</div>

<h5 id="scanf输入函数"><a href="#scanf输入函数" class="headerlink" title="scanf输入函数"></a>scanf输入函数</h5><p>标准输入语句格式为：</p>
<div class="apiBox">scanf("格式控制",地址表列)</div>

<p>格式控制与printf()函数的格式控制类似，如果格式控制中有格式说明以外的字符，则输入数据时需要在对应位置输入相同的字符；地址表列可以为变量地址、字符串首地址，通常需要用取地址符<span class="tips">&amp;</span>加以引导，多个地址参数使用<span class="tips">,</span>分隔。</p>
<div class="table">

<table>
<thead>
<tr>
<th>格式输入符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d或%i</td>
<td>输入有符号十进制整数</td>
</tr>
<tr>
<td>%I64d</td>
<td>输入long long类型整数</td>
</tr>
<tr>
<td>%u</td>
<td>输入无符号十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>输入无符号八进制整数</td>
</tr>
<tr>
<td>%x或%X</td>
<td>输入无符号十六进制整数</td>
</tr>
<tr>
<td>%c</td>
<td>输入一个字符，空白字符、回车、制表符也视为有效字符</td>
</tr>
<tr>
<td>%s</td>
<td>输入字符串，输入空白字符、回车、制表符会被认为输入结束，但开头输入空白字符会被系统跳过</td>
</tr>
<tr>
<td>%f</td>
<td>输入小数，可以用小数形式或指数形式</td>
</tr>
<tr>
<td>%e,%E,%g,%G</td>
<td>与%f相同，大小写作用相同</td>
</tr>
<tr>
<td>%%</td>
<td>输入一个%</td>
</tr>
</tbody></table>
</div>
<div class="table">

<table>
<thead>
<tr>
<th>格式修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>l</td>
<td>用于输入长整型数据(%ld,%lo,%lx,%lu)和double型数据(%lf,%le)</td>
</tr>
<tr>
<td>h</td>
<td>用于输入短整型数据(%hd,%ho,%hx)</td>
</tr>
<tr>
<td>域宽m(正整数)</td>
<td>指定输入数据的宽度(列数)，系统根据此宽度自动截取数据</td>
</tr>
<tr>
<td>*</td>
<td>忽略输入修饰符，表示对应的输入项在读入后不赋给相应变量</td>
</tr>
</tbody></table>
</div>

<p>用scanf()输入数据时，遇到以下情况会被认为数据输入结束：</p>
<ul>
<li>遇到空格符、回车符、制表符(Tab)</li>
<li>达到输入域宽</li>
<li>遇到非法字符输入</li>
</ul>
<div class="show">1. 格式控制中有普通字符，则输入数据时也要输入对应字符(包括空格)
scanf("a=%d,b=%d",&a,&b);//输入形式必须为a=10,b=20
2. 可以指定输入数据所占的列宽，系统会自动截取
scanf("%3d%3d",&a,&b);//输入123456a1，则123赋值给a，456赋值给b，多余部分a1抛弃
3. 可以用*跳过指定列数
scanf("%d%*c%d",&a,&b);//输入123 456，则123赋值给a，456赋值给b，中间的空格符根据%*c跳过
scanf("%2d%*3d%2d",&a,&b);//输入1234567，则12赋值给a，345被忽略，67赋值给b
4. scanf()函数的返回值一般为正确读入数据的个数
scanf("%2d%2d",&a,&b);//输入1234返回值为2
scanf("%2d%2d",&a,&b);//输入12a,只给a读入了正确值，返回值为1
scanf("%2d%2d",&a,&b);//输入a，返回值为0
</div>

<h5 id="putchar-与getchar"><a href="#putchar-与getchar" class="headerlink" title="putchar()与getchar()"></a>putchar()与getchar()</h5><p>用于输入或输出一个字符，只能用于处理字符</p>
<ul>
<li><span class="strong">getchar() 输入一个字符，无参数</span></li>
<li><span class="strong">putchar(参数) 输出一个字符，参数可以为字符变量、整型变量，也可以为一个字符常量或转义字符</span></li>
</ul>
<div class="show">char a;
a=getchar();
putchar(a);
putchar('a');
putchar('\n');
</div>

<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>自定义函数的定义语法为：</p>
<div class="apiBox">返回值类型 函数名(类型 形参1,....){
        /*函数体*/
}
</div>

<ul>
<li>函数返回值只能有一个，返回值类型可以是除数组外的任何类型</li>
<li>函数无返回值时，返回值类型需要声明为<span class="strong">void</span>，可以不需要return语句，但通常会以 <span class="tips">return;</span>作为程序结束语句，表示程序正常执行结束且返回值为空，这是一种良好的编程习惯</li>
<li>如果函数返回值和函数定义时声明的返回值类型不同，则将以函数类型为准，系统自动进行数据转换</li>
<li>在定义函数时如果不指定返回值类型，系统会隐含指定为int型</li>
<li>函数名的命名规则与变量相同</li>
<li>形参(形式参数)必须指定类型，但变量名任意</li>
<li>形参在函数调用前，不占用存储单元，函数调用时才被分配内存，并在执行完后会被回收</li>
</ul>
<h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><p>函数调用语法：</p>
<div class="apiBox">函数名(实参1,....)</div>

<ul>
<li>实参(实际参数)可以为常量，或者有确定值的变量或表达式</li>
<li>实参和形参的数据类型应该相同，或者<span class="tips">赋值兼容</span>(参考赋值一节的赋值规则，如字符型和整型相互通用)，但应该尽量避免使用赋值兼容</li>
</ul>
<div class="show"><code>#include&lt;stdio.h>
//函数定义时不指定返回值类型，隐含为int类型
//用Visual Studio编译这段代码时，会有提示warning C4013: “getMax”未定义；假设外部返回 int
getMax(int a, int b) &#123;
    return a > b ? a : b;
&#125;
int main(void) &#123;
    printf("%d", getMax(10, 20));
    return 0;
&#125;</code>
</div>

<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>又称<span class="strong">函数原型</span>(Function Prototype)声明，其作用是将函数名、函数类型、形参类型、个数和顺序通知编译系统，以便调用该函数时系统按此进行对照检查。函数声明语法：</p>
<div class="apiBox">函数类型 函数名(形参1,....)</div>

<ul>
<li>如果被调用的函数定义在主调函数之前，可以不加声明，编译器会根据函数定义时首部提供的信息对函数调用作准确性检查</li>
<li>如果被调用函数类型为整型，也可以不加声明</li>
<li>函数声明可以在文件开头(所有函数前)，也可以在主调函数中</li>
<li>对于形参，编译器只检查形参类型和个数，不检查参数名，因此参数名任意，也可以省略</li>
</ul>
<div class="show"><code>#include&lt;stdio.h>
int main(void) &#123;
    int  getMax(int, int);//原型声明
    printf("%d", getMax(10, 20));
    return 0;
&#125;
int getMax(int a, int b) &#123;
    return a > b ? a : b;
&#125;
</code></div>

<h4 id="内部函数与外部函数"><a href="#内部函数与外部函数" class="headerlink" title="内部函数与外部函数"></a>内部函数与外部函数</h4><p><span class="strong">外部函数：</span>定义函数时，可以在函数返回值类型前加上<span class="text-blue">extern</span>将其定义为外部函数，extern可以省略，因此如果函数未特意声明为内部函数，则默认隐含为外部函数，即<span class="tips">C语言中，函数默认为外部函数</span>，外部函数可以被其他文件调用，只需要在要调用此函数的文件中，用extern作函数原型声明即可，其中函数原型声明前的extern也可以省略</p>
<p><span class="strong">内部函数：</span>又称静态函数，定义函数时在函数首部添加<span class="text-blue">static</span>修饰即可定义内部函数，内部函数作用域仅限于本文件，不能被其他文件调用，不同的文件可以有同名的内部函数，互不干扰</p>
<div class="show">eg:文件file1.c调用文件file2.c中的函数
file1.c
<code>#include&lt;stdio.h&gt;
int main(void)
&#123;
    <span class="text-blue"> extern void getStrings(char str[]);</span>//extern可以省略，写为void getString(char str[])
    <span class="text-red">static void test();</span>//调用内部函数需要static声明
    char str[50];
    getStrings(str);
    printf("%s\n", str);
    test();//调用本文件中的test()函数
    return 0;
&#125;
<span class="text-red">static void test()</span>//内部函数，仅供本文件调用
&#123;
    printf("file1.c");
    return;
&#125;</code>
file2.c
<code>#include&lt;stdio.h&gt;
<span class="text-blue">extern void getStrings(char str[])</span>//extern 可以省略
&#123;
    gets(str);
&#125;
<span class="text-red">static void test()</span>//内部函数，可以与file1.c中的test()函数同名
&#123;
    printf("file2.c");
    return;
&#125;</code></div>
<div class="broadcast color-pink">
<div class="iconfont icon-yinle1"></div>
由此可见，声明函数原型的作用除了在调用时作准确性检查，还可以拓展函数作用域到定义本函数的文件之外，只要在所有调用该函数的文件中作一个函数原型声明即可。如：各种库提供的头文件中，就包含了大量函数及其函数原型声明，我们只需要使用#include命令将其包含到我们的c文件中，就可以不需要了解其函数和函数原型，就直接使用该函数。原型声明时extern可以省略，但我们自己编写头文件中的原型声明时应当保留extern关键字来保证代码清晰性。</div>

<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h3><p>C语言中，类型限定符用于指定数据的访问属性。常见的类型限定符包括<span class="tips">const</span>(常量)、<span class="tips">volatile</span>(易变的)、<span class="tips">restrict</span>(限定)和<span class="tips">_Atomic</span>(原子)</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><h5 id="const修饰变量"><a href="#const修饰变量" class="headerlink" title="const修饰变量"></a>const修饰变量</h5><p>const用于限定变量的值不能被修改，表明变量中存储的值是一个常量，这类变量本质是变量，但又有常量属性，因此又称为”常变量”，const修饰的常变量必须在定义的同时赋值，而后其值就不能再改变，任何赋值行为都将引发错误。定义常变量时，const和变量类型位置可以互换，因此以下两个语句等价：</p>
<div class="show"><code>const int num=100;
int const num=100;</code></div>

<p>全局常变量存储于静态存储区的.rodata段，而局部常变量存储于栈内存中。对于局部常变量，由于栈内存本身是可读写的，所以即便编译器会对const修饰的局部变量进行内存保护，防止该变量的值被修改，但我们依然可以用其他方法修改该变量的值：</p>
<div class="show"><code>const int num=100;
int *p=&num ;
*p=0;
printf("%d",num);//num值被修改为0
</code></div>
这种通过指针来间接操作访问和操作指针所指对象值的方法称为指针解引用(dereference)，C语言标准明确指出，通过指针解引用的方式去修改一个const修饰的变量，其行为是未定义的，因此对于局部常变量，我们不应该通过该方法修改其值。对于全局常变量，数据存储于.rodata段，该段内存只有读权限，通过任何方法修改数据都会抛出写入访问权限冲突异常，在某些嵌入式系统中，全局常变量和代码会被一起存入ROM存储介质中无法修改。

<h5 id="const修饰数组"><a href="#const修饰数组" class="headerlink" title="const修饰数组"></a>const修饰数组</h5><p>对于数组，由于数组名本身就代表数组起始地址，是一个地址常量，不能被任何限定符修饰，因此const修饰数组时，将用于修饰数组元素，即const修饰数组时，数组元素为常量无法修改</p>
<div class="show"><code>const int nums[] = &#123; 10,20,30,40,50 &#125;;
<span class="text-red">nums[2] *= 10;//错误！无法修改</span></code></div>

<h5 id="const修饰复合类型"><a href="#const修饰复合类型" class="headerlink" title="const修饰复合类型"></a>const修饰复合类型</h5><p>const修饰结构体、枚举等复合类型时，表示该类型中的所有成员值不能被修改</p>
<div class="show"><code>struct test &#123;
        int a;
        int b;
    &#125;;
    const struct test num = &#123; 10,20 &#125;;
或
    const struct test &#123;
        int a;
        int b;
    &#125; num = &#123;10,20&#125;;
或
struct test &#123;
        int a;
        int b;
    &#125; const num = &#123;10,20&#125;;
初始化完毕成员变量值不能再被修改
<span class="text-red">num.a=100;//错误！不能修改成员值</span></code></div>

<h5 id="指针与const类型限定符"><a href="#指针与const类型限定符" class="headerlink" title="指针与const类型限定符"></a>指针与const类型限定符</h5><p>指针常用来在函数间传递数据，方便调用者直接对数据进行操作，但有时我们只希望将数据传到函数内部，而不希望它们在函数内被修改，此时，我们可以使用<span class="tips">const</span>对参数进行限定</p>
<div class="show">const位于声明语句的不同位置，将表示不同的含义，以int类型为例：
<code>int a,b;</code>
1. const放在类型关键字前面
<span class="text-blue">const int * p=&a;</span>
按从右到左解析为：p是一个指针变量，可指向一个整型常量，*p是一个常量，而p不是。即*p的值是不可修改的，无法用*p=10;等方式重新赋值，但指针变量p的指向是可以被修改的，即p=&b是允许的
2. const位于类型关键字后*变量名前
<span class="text-blue">int const *p=&a;</span>
按从右到左解析为：p是一个指针常量，可以指向一个常量整数，同样*p是一个常量，而p不是，不能用指针变量p去修改这个"为常量的整数"，与第一种情况作用相同
3. const位于*后，变量名前
<span class="text-blue">int * const p=&a;</span>
按从右到左解析为：p是一个指针常量，可以指向一个整型数据，它表明p是一个常量，而*p不是。由于p是常量指针，因此不能修改p的指向，p=&b操作是非法的，但*p=20是合法的
4. 两个const修饰，一个位于类型关键字前，一个位于*后
<span class="text-blue">const int * const p=&a;</span>
按从右到左解析为：p是一个指针常量，可指向一个整型常量，它表明p和*p都是常量，是只读的，*p=20和p=&b操作都是非法的
上述四种用法中，第一种用法较为常用，C语言很多库函数都使用该方法，只允许函数访问该指针指向的内容，不允许修改其内容，如：
<code>int puts(const char * str);
int printf(const char * format , ...);</code></div>

<p>对于被const限制的指针变量，不能将普通指针变量赋值给被限制的指针变量，但反过来可以，如：<span class="tips">const char *</span>和<span class="tips">char *</span>是不同的类型，const char *指向的数据只有读取权限，而char *指向的数据有读写权限，因此不能将const char *赋值给char *，但可以将char *类型的数据赋值给const char *类型的变量</p>
<div class="show">C语言函数库中很多函数参数都被const限制了，但我们仍然可以将非const类型的数据传递给const类型的形参，如对于函数原型
int puts(const char * str);
可以直接传递非const类型的数据
char * str="Hello";
puts(str);
</div>

<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile用于声明变量的值是易变的，每次用到该变量的值时都需要去内存中重新读取这个变量的值，而不是读取其在寄存器中的备份。在多线程环境下，volatile 表示变量可能会被多个同时执行的线程修改，存取时无需额外的内存保护，并且防止优化编译器把变量从内存装入寄存器中，因为如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，造成程序的错误执行，volatile的声明方式为：</p>
<div class="show"><code>volatile int counter;</code></div>

<h4 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h4><p>restrict是C99标准新增的限定符，该限定符只能用于指针变量，其作用是程序员通过该限定符告知编译器，restrict修饰的指针独占其所指向的内存，所有对该内存的操作都将基于该指针，而不再会有其他任何变量或指针操作该内存，以便让编译器进行一些针对性的优化。这种优化是针对特殊使用场景的，因此可能出现没有任何优化的情况，并且由于restrict指针独占是由程序员来判断并加以限定的，可能会出现误判的情况，因此，restrict一般用于非常需要性能优化，并且已经确认两个指针不会指向同一内存的场景，其定义语法为：</p>
<div class="show"><code>int * restrict a;</code>
eg:业务上明确得知，某个malloc开辟的空间，只会通过mySpace指针变量进行操作，则可以使用restrict限定符告知编译器，由其进行优化
<code>int * restrict mySpace=(int *)malloc(10*sizeof(int));</code></div>

<h4 id="Atomic"><a href="#Atomic" class="headerlink" title="_Atomic"></a>_Atomic</h4><p>_Atomic是C11标准引入的限定符，用于指定原子类型，提供原子性操作。原子操作是指对原子对象的操作是不可被打断的，该操作一旦执行，不会被其他线程或者事件中断，直到操作执行完毕。默认的声明方式为：</p>
<div class="show"><code>_Atomic int x=0;</code></div>

<p>但在实际使用时，应该使用<span class="text-blue">&lt;stdatomic.h&gt;</span>头文件中已经定义好的原子类型，该头文件还定义了相关的原子操作函数</p>
<div class="show">一些stdatomic.h头文件定义的原子类型和原子操作举例
<code>typedef _Atomic int atomic_int;
typedef _Atomic char atomic_char;
...
atomic_init(volatile A* obj, C desired )初始化原子类型变量
....</code>
eg:定义一个原子类型变量并初始化
<code>#include &lt;stdio.h>
#include &lt;stdatomic.h>
int main(void)
&#123;
    atomic_int a;
    atomic_init(&a,10);
    return 0;
&#125;</code></div>

<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>动态内存分配函数在堆上分配内存，使用前需要包含<span class="tips">&lt;stdlib.h&gt;</span>头文件</p>
<h4 id="内存空间申请与释放"><a href="#内存空间申请与释放" class="headerlink" title="内存空间申请与释放"></a>内存空间申请与释放</h4><ul>
<li><span class="strong">void *malloc(unsigned int size);</span></li>
</ul>
<p>分配长为size字节的内存空间，返回该内存首地址，若无足够内存单元，则返回空指针NULL</p>
<div class="show"><code>int *p=(int *)malloc(4*sizeof(int))</code></div>

<ul>
<li><span class="strong">void *calloc(unsigned int num,unsigned int size);</span></li>
</ul>
<p>用于给同一类型的数据分配连续的内存空间并赋值为0(数值型)或空(字符型)。它相对于声明了一个一维数组，并且会初始化该数组值为0或空，参数num为所需申请的内存空间数量，相对于数组长度，参数size为每个内存空间的字节数，相对于数组基类型的字节长度。若申请成功，返回该内存空间的首地址，否则返回空指针NULL</p>
<div class="show"><code>int * p=(int *)calloc(10,sizeof(int));
相对于
int * p=(int *)malloc(10*sizeof(int));
但calloc()会将分配的内存自动初始化为0或空，更为安全
</code></div>

<ul>
<li><span class="strong">void *realloc(void *p,unsigned int size);</span></li>
</ul>
<p>用于改变原来分配的内存，将p所指向的存储空间大小改为size个字节，返回值是新分配的内存空间首地址，与原来分配的首地址不一定相同</p>
<ul>
<li> <span class="strong">void free(void *p);</span></li>
</ul>
<p>用于释放所申请的内存空间，即p所指向的空间，其中p只能是由malloc()和calloc()申请的内存地址</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="二进制文件与文本文件"><a href="#二进制文件与文本文件" class="headerlink" title="二进制文件与文本文件"></a>二进制文件与文本文件</h4><p>C语言文件有两种类型：<span class="text-blue">文本文件</span>(也称ASCII码文件)和<span class="text-blue">二进制文件</span>。二者的区别在于存储数值型数据的方式不同。二进制文件中，数值型数据是将整个数值转码为二进制形式存储；而在文本文件中，数值型数据的每一位数字作为一个字符以其ASCII码形式存储，每个数字都单独占用一个字节的存储空间。如：对于short int n=123，二进制文件中，变量n为short类型仅占用2个字节存储空间，而在文本文件中占用3个字节存储空间。</p>
<p>二进制文件和文本文件各有优缺点。文本文件可以很方便被其他程序读取，包括文本编辑器、Office办公软件等，且输出内容与字符一一对应，一个字节表示一个字符，便于对字符逐个处理，便于输出字符，但一般占用的存储空间较大，且ASCII码和字符转换需要花费一定时间。二进制文件可以节省空间和转换时间，但不方便其他程序读取，不能直接输出其字符形式。</p>
<p>无论文件内容是什么形式，C语言一律将数据看成由字节构成的序列，即<span class="text-blue">字节流</span>，对文件的存取也是以字节为单位进行的，输入、输出的数据仅受程序控制而不受物理符号(如回车换行符)控制，因此，C语言文件又称为流式文件。</p>
<p>C语言文件系统分为<span class="text-blue">缓冲型</span>和<span class="text-blue">非缓冲型</span>，缓冲型文件系统是指系统自动为每一个正在使用的文件在内存中开辟一个输入/输出文件缓冲区，作为程序和文件之间数据交换的缓冲区域。在读文件时，数据先从磁盘送到缓冲区，再传给C语言程序；在写文件时，数据从C语言程序送到缓冲区，装满缓冲区后再输出到磁盘。缓冲文件系统利用<span class="text-red">文件指针</span>标识文件，不同版本的C语言缓冲区大小不一样，一般为512字节。而非缓冲文件系统不会自动数值文件缓冲区，缓冲区必须由程序员自己设定，它使用称为文件号的整数来标识文件。</p>
<p>在UNIX系统中，缓冲文件系统用来处理文本文件，用非缓冲文件系统来处理二进制文件。用缓冲文件系统进行输入输出的操作又称为高级文件操作，用非缓冲文件系统来处理输入输出的操作又称为低级输入输出操作。ANSI C标准规定只采用缓冲文件系统，即既用缓冲文件系统处理文本文件，也用它处理二进制文件，因此下文主要为高级文件操作函数。</p>
<h4 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h4><p>缓冲文件系统中，系统为每个正在使用的文件在内存中开辟了一个缓冲区，用来存放文件的有关信息(如：文件名、文件句柄、文件状态、文件路径等)，这些信息保存在一个结构体变量中，该结构体类型由系统定义，名为<span class="text-red">FILE</span>，stdio.h文件中有该文件类型声明：</p>
<div class="show"><code>typedef struct
&#123;   short level;    //缓冲区"满"或"空"的程度
    unsigned flags;//文件状态标志
    char fd;      //文件描述符
    unsigned char hold;//如果无缓冲区不读取字符
    short bsize;//缓冲区大小
    unsigned char *buffer;//数据缓冲区位置
    unsigned ar *curp;//指针当前指向
    unsigned istemp;//临时文件指示器
    short token;//用于有效性检查
&#125;FILE;
</code></div>

<p>由此，我们可以定义一个文件类型的指针变量：<span class="text-red">FILE *fp</span>，然后将该指针指向一个文件的结构体变量，从而通过该指针访问该结构体变量中的文件信息，并通过这些信息访问该文件。</p>
<h4 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h4><h5 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h5><p>函数fopen()用于打开文件，其函数原型如下：</p>
<div class="apiBox">FILE * fopen(const char * filename,const char * mode)</div>

<p>该函数返回一个文件类型的指针，如果文件打开失败，则返回一个空指针NULL(NULL在stdio.h文件中被定义为0)。fopen()有两个形参，第一个形参filename表示文件名，可以包含<span class="strong">文件路径和文件名</span>两部分，第二个形参mode表示文件的打开方式，取值如下所示：</p>
<div class="table">

<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以<span class="text-yellow">只读方式</span>打开<span class="text-blue">文本文件</span>，只能读出而不能写入数据，若文件不存在，则报错</td>
</tr>
<tr>
<td>w</td>
<td>以<span class="text-yellow">只写方式</span>(新建形式)，创建并打开<span class="text-blue">文本文件</span>，无论文件是否存在，都会创建一个新的文本文件，只能写入数据，已经存在的文件将被覆盖</td>
</tr>
<tr>
<td>a</td>
<td>以<span class="text-yellow">只写方式</span>(追加形式)，打开<span class="text-blue">文本文件</span>，位置指针移到文件末尾，向文件尾部添加新数据，若文件不存在，则会新建一个文件</td>
</tr>
<tr>
<td>b</td>
<td>与上面的字符串组合，表示打开二进制文件</td>
</tr>
<tr>
<td>rb</td>
<td>以<span class="text-yellow">只读方式</span>打开<span class="text-red">二进制文件</span></td>
</tr>
<tr>
<td>wb</td>
<td>以<span class="text-yellow">只写方式</span>打开<span class="text-red">二进制文件</span></td>
</tr>
<tr>
<td>ab</td>
<td>以<span class="text-yellow">只写方式</span>向<span class="text-red">二进制文件</span>末尾添加数据</td>
</tr>
<tr>
<td>+</td>
<td>与上面的字符串组合，表示以读写方式打开文本文件，既可以向文件中写入数据，也可以从文件中读取数据</td>
</tr>
<tr>
<td>r+</td>
<td>以<span class="text-green">可读可写</span>的方式打开<span class="text-blue">文本文件</span></td>
</tr>
<tr>
<td>w+</td>
<td>以<span class="text-green">可读可写</span>方式创建一个新的<span class="text-blue">文本文件</span></td>
</tr>
<tr>
<td>a+</td>
<td>以<span class="text-green">可读可写</span>方式向<span class="text-blue">文本文件</span>末尾追加数据</td>
</tr>
<tr>
<td>rb+</td>
<td>以<span class="text-green">可读可写</span>的方式打开<span class="text-red">二进制文件</span></td>
</tr>
<tr>
<td>wb+</td>
<td>以<span class="text-green">可读可写</span>方式创建一个新的<span class="text-red">二进制文件</span></td>
</tr>
<tr>
<td>ab+</td>
<td>以<span class="text-green">可读可写</span>方式向<span class="text-red">二进制文件</span>末尾追加数据</td>
</tr>
</tbody></table>
</div>

<p>注意：</p>
<ul>
<li>有的C语言编译系统可能不完全提供上述功能，如：有的C语言编译器不支持r+、w+、a+</li>
<li>输入文本文件时，内容中的回车换行符会被转换为一个换行符，在输出时，则会将换行符转换为回车和换行两个字符。而在输入输出二进制文件时，不会进行这种转换，文件中的数据与内存中的数据完全一致，一一对应</li>
</ul>
<h5 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose()函数"></a>fclose()函数</h5><p>函数fclose()用来关闭一个由函数fopen()打开的文件，其函数原型如下：</p>
<div class="apiBox">int fclose(FILE *fp);</div>

<p>函数返回一个整型值，当文件成功关闭时，返回0值，否则返回一个非0值(一般为EOF -1)，可用于判断文件是否关闭成功。当使用fclose()关闭文件后，指针fp将不再指向该文件。</p>
<p>由于操作系统对于同时打开的文件数目是有限制的，所以文件使用结束后必须关闭文件。此外，不建议使用读写方式打开文件，因为读写共用一个缓冲区，每次读写都会改变文件位置指针，很容易写乱，破坏文件内容，并且需要调用文件定位函数才能在读写之间切换。</p>
<div class="show"><code>FILE * fp;
fp=fopen("D:\\demo.text","a+");
fclose(fp);</code></div>

<h4 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h4><h5 id="按字符读写"><a href="#按字符读写" class="headerlink" title="按字符读写"></a>按字符读写</h5><ul>
<li><span class="strong">int fgetc(FILE *fp)</span> 从fp所指向文件读取一个字符，并使位置指针指向下一个字符。如果读取成功，则返回该字符，若读取到文件末尾，则返回EOF(stdio定义为-1)</li>
<li><span class="strong">int fputc(int c,FILE *fp)</span> 将字符c(尽管c定义为int型，但只写入低字节)写到文件指针fp所指向的文件中。若写入错误，则返回EOF，否则返回字符c</li>
</ul>
<div class="show">在读入文本文件时，可通过fgetc()函数的返回值来判断是否读取到了文件末尾(文件是否读取完毕)，当读入的字符值等于-1(即EOF)时，说明文件已经读取完毕。但在读入二进制文件时，读入的数据可能刚好为-1(EOF)，此时就需要使用feof()函数判断当前文件是否读取完毕。如果文件结束，则feof(fp)的值为1(真)，否则为0(假)
eg:从键盘输入字符，并将这些字符存储到磁盘文件中，直到输入"#"为止
<code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(void)&#123;
    FILE *fp;
    char ch,filename[10];
    scanf("%s",filename);//输入文件名
    if((fp=fopen(filename,"w"))==NULL)&#123;
        printf("文件打开失败\n");
        exit(0);
    &#125;
    ch=getchar();//接收执行scanf语句时输入的回车符
    ch=getchar();
    while(ch!='#')
    &#123;
        <span class="text-blue">fputc(ch,fp);</span>
        ch=getchar();
    &#125;
    fclose(fp);
        return 0;
&#125;</code>
eg:从当前路径文件夹下读取名为"myTest.txt"的文件，并将内容输出到控制台
<code>int main(void) &#123;
    FILE* fp;
    char ch;
    if ((fp = fopen("myTest.txt", "r")) == NULL) &#123;
        printf("文件打开失败！\n");
        exit(0);
    &#125;
    while (<span class="text-red">!feof(fp)</span>) &#123;
        ch = fgetc(fp);
        putchar(ch);
    &#125;
    return 0;
&#125;</code></div>

<h5 id="按字符串读写"><a href="#按字符串读写" class="headerlink" title="按字符串读写"></a>按字符串读写</h5><ul>
<li><span class="strong">char * fgets(char *s,int n,FILE *fp)</span> 从fp所指向文件中读取最多含n-1个字符的字符串，并在字符串末尾添加’\0’，然后存入s。当读取到回车换行符、到达文件末尾或者读满n-1个字符时，函数返回该字符串的首地址，即指针s的值；读取失败时返回空指针NULL</li>
<li><span class="strong">int fputs(const char *s,FILE * fp)</span> 将字符串s写入文件fp，若写入错误，则返回EOF(-1)，否则返回一个非负数</li>
</ul>
<div class="show">eg:从键盘输入一个字符串，追加到文件末尾
<code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(void)&#123;
    FILE * fp;
    char str[20];
    if((fp=fopen("demo.txt","a"))==NULL)&#123;
        printf("Failure to open file!\n");
        exit(0);
    &#125;
    gets(str);
    fputs(str,fp);
    fclose(fp);
    if((fp=fopen("demo.txt","r"))==NULL)&#123;
        printf("Failure to open file!\n");
        exit(0);
    &#125;
    fgets(str,20,fp);
    puts(str);
    fclose(fp);
    return 0;
&#125;
</code></div>
<div class="broadcast color-yellow">
<div class="iconfont icon-dengpao14hao"></div>
这两个函数与puts()和gets()类似，区别在于，gets()函数从输入缓冲区读取字符串时，会将回车符也从缓冲区读走，但不作为字符串的一部分，而fgets()函数读到换行符时会将换行符作为字符串的一部分读到字符串中来。输出时，puts()函数在向终端输出字符串时，会在字符串输出结束后，自动输出一个换行符，而fputs()函数不会在字符串末尾加上换行符。</div>

<h5 id="按格式读写文件"><a href="#按格式读写文件" class="headerlink" title="按格式读写文件"></a>按格式读写文件</h5><ul>
<li><span class="strong">int fscanf(FILE *fp,格式字符串,输入表列地址)</span>从指定文件按格式读取数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为输入变量的地址表列</li>
<li><span class="strong">int fprintf(FILE *fp,格式字符串,输出表列)</span>按指定格式向文件写入数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为要写入的变量</li>
</ul>
<p>用函数fscanf()和fprintf()进行文件的格式化读写，读写方便，容易理解，但输入时要将ASCII字符转换为二进制数，输出时要将二进制数转换为ASCII字符，耗时较多。因此，内存和磁盘进行频繁数据交换时，应当尽量避免使用这两个函数，而用fread()和fwrite()函数</p>
<div class="show"><code>int i=10;
float j=4.5;
fprintf(fp,"%d,%6.2f",i,j);//保存为10,  4.50
fscanf(fp,"%d,%f",&i,&j);//假设文件内容为10,4.5，则i赋值为10，j赋值为4.5</code></div>

<h5 id="按数据块读写文件"><a href="#按数据块读写文件" class="headerlink" title="按数据块读写文件"></a>按数据块读写文件</h5><ul>
<li><span class="strong">unsigned int fread(void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 从fp所指的文件读取数据块并存储到buffer所指向的内存。buffer是待存入数据块的起始地址，可以是数组起始地址、结构体变量起始地址等，size是每个数据块的大小，count是最多允许读取的数据块个数，函数返回的是实际读取到的数据块个数</li>
<li><span class="strong">unsigned int fwrite(const void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 将buffer所指内存中的数据块写入fp所指的文件。同样，buffer是待读出数据块的起始地址，size是每个数据块的大小，count是最多允许写入的数据块个数，函数返回的是实际写入的数据块个数<br>块数据读写允许用户以数组、结构体等数据类型整块读写，不再局限于一次只读写一个字符或字符串，可以指定想要读写的内存块大小，最小为1字节，最大可以为整个文件</li>
</ul>
<div class="show">eg:整块读写数组内容
<code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(void) &#123;
    int nums[] = &#123; 11,22,33,44,55,66,77,88,99 &#125;;
    int numsRead[9];
    FILE* fp;
    if ((fp = fopen("data.txt", "w")) == NULL) &#123;
        printf("文件打开失败!");
        exit(0);
    &#125;
    <span class="text-blue">fwrite(nums, 4, sizeof(nums)/4, fp);</span>//将数组nums到文件fp中，数组为int类型，数据块为4Bytes，需要写入9个数据块
    fclose(fp);
    if ((fp = fopen("data.txt", "r")) == NULL) &#123;
        printf("文件打开失败!");
        exit(0);
    &#125;
    <span class="text-red">fread(numsRead, 4, 9, fp);</span>//从fp文件中读取9个4Bytes的数据块，并存储到numsRead数组中
    for (int i = 0; i < 9; i++) &#123;
        printf("%4d", numsRead[i]);
    &#125;
    fclose(fp);
    return 0;
&#125;</code></div>

<p>eg:按块文件读写结构体变量，输入每个学生的信息并保存到studentData.txt文件中，并添加从该文件中读出学生信息并打印到控制台的功能</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 10
typedef struct student &#123;
    char name[10];
    long studentID;
    int age;
    int classID;
&#125;STUDENT;
int main(void) &#123;
    void writeToFile(STUDENT[], int);
    int readFromFile(STUDENT[]);
    void printToScreen(STUDENT[], int);
    STUDENT stu[MAXSIZE];
    int studentNum;
    printf("请输入学生数量：\n");
    scanf("%d", &studentNum);
    printf("请输入学生信息：\n");
    for (int i = 0; i &lt;studentNum; i++) &#123;
        scanf("%s %ld %d %d", stu[i].name, &stu[i].studentID, &stu[i].age, &stu[i].classID);
    &#125;
    writeToFile(stu, studentNum);
    studentNum = readFromFile(stu);
    printToScreen(stu, studentNum);
    return 0;
&#125;
void writeToFile(STUDENT stu[], int n) &#123;
    FILE* fp;
    if ((fp = fopen("studentData.txt", "w")) == NULL) &#123;
        printf("文件打开失败！");
        exit(0);
    &#125;
    fwrite(stu, sizeof(STUDENT), n, fp);
    fclose(fp);
&#125;
int readFromFile(STUDENT stu[]) &#123;
    FILE* fp;
    int i;
    if ((fp = fopen("studentData.txt", "r")) == NULL) &#123;
        printf("文件打开失败!\n");
        exit(0);
    &#125;
    for (i = 0; !feof(fp); i++) &#123;
        fread(&stu[i], sizeof(STUDENT), 1, fp);
    &#125;
    fclose(fp);
    return i - 1;
&#125;
void printToScreen(STUDENT stu[], int num) &#123;
    printf("----------------------\n");
    for (int i = 0; i &lt; num; i++) &#123;
        printf("%6s%10ld%4d%4d\n", stu[i].name, stu[i].studentID, stu[i].age, stu[i].classID);
    &#125;
&#125;</code></pre>

<h5 id="数字读写putw-和getw"><a href="#数字读写putw-和getw" class="headerlink" title="数字读写putw()和getw()"></a>数字读写putw()和getw()</h5><p>putw()和getw()不是ANSI C标准定义的函数，但很多编译器提供这两个函数，有的编译器将其命名为_putw()和_getw()函数(Visual Studio 2019(编译器版本主要支持ANSI C89标准，但其中包含几个Microsoft扩展支持ISO C99的一部分函数)只能用这两个函数名)，因此这两个函数的在不同编译器中函数名可能不同，函数名中的<span class="tips">w</span>是指<span class="tips">word(字)</span></p>
<ul>
<li><span class="strong"> int getw(FILE *fp)</span> 从fp读取一个整数，如果读取成功，返回该整数，读取失败或文件结束，返回-1</li>
<li><span class="strong">int putw(int w, FILE *fp)</span> 将一个字符或字输出到文件fp，返回值为输出的整数</li>
</ul>
<div class="show">eg:存储0-9整数到文件test.txt中，读出后输出到控制台
<code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(void) &#123;
    FILE* fp;
    int getNum;
    if ((fp = fopen("test.txt", "w")) == NULL) &#123;
        printf("文件打开失败!\n");
        exit(0);
    &#125;
    for (int i = 0; i < 10; i++) &#123;
        <span class="text-blue">_putw(i, fp);</span>
    &#125;
    fclose(fp);
    if ((fp = fopen("test.txt", "r")) == NULL) &#123;
        printf("文件打开失败!\n");
        exit(0);
    &#125;
    for (int i = 0; i < 10; i++) &#123;
        <span class="text-blue">getNum = _getw(fp);</span>
        printf("%4d", getNum);
    &#125;
    fclose(fp);
    return 0;
&#125;</code></div>

<h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><p>之前的示例执行的都是顺序文件处理，数据项是依次进行读写的，如果需要读取第5个数据项，按顺序文件处理方法必须先读取前4个数据项。如果要读写指定位置的数据项，则需要使用文件的随机访问，允许在文件中随机定位，并在文件任意位置读写数据。</p>
<p>为了实现文件的定位，每一个打开的文件中，都有一个<span class="text-blue">文件位置指针</span>，用来指向当前文件读写位置。当对文件进行顺序读写时，每读完一个字节，位置指针就会自动指向下一个字节。当需要随机读写时，需要我们人为指定位置指针的指向，C语言提供了几个关于位置指针的函数</p>
<h5 id="重置位置指针rewind"><a href="#重置位置指针rewind" class="headerlink" title="重置位置指针rewind()"></a>重置位置指针rewind()</h5><p><span class="strong">void rewind(FILE *fp)</span> 使fp文件的位置指针指向文件首字节，即重置位置指针到文件开头</p>
<div class="show">eg:打印file1文件内容到控制台，并将其复制到file2，两个任务分开执行。第一次打印完file1文件，文件位置指针位于文件末尾，使用rewind()函数将file1文件位置指针重置到文件开头，执行其他任务
<code>FILE *fp1=fopen("file1.txt","r");
FILE *fp2=fopen("file2.txt","r");//应当有文件打开失败的错误处理，这里省略
while(!feof(fp1))&#123;
    putchar(getc(fp1));
&#125;
<span class="text-blue">rewind(fp1);</span>
while(!feof(fp1))&#123;
   putc(getc(fp1),fp2);
&#125;
fclose(fp1);
fclose(fp2);
</code></div>

<h5 id="指定指针位置fseek"><a href="#指定指针位置fseek" class="headerlink" title="指定指针位置fseek()"></a>指定指针位置fseek()</h5><p><span class="strong">int fseek(FILE *fp,long offset,int fromwhere);</span>将fp的位置指针从fromwhere移动offset个字节</p>
<p>offset是一个偏移量，告诉文件指针跳过多少个字节，ANSI C要求offset是<span class="tips">long</span>类型的(其常量值后面要加L)，这样当文件长度大于64kb时不至于出问题。当offset为正时，位置指针向后移动，为负时向前移动。由于需要指定具体字节数，因此该参数往往需要<span class="tips">sizeof(数据类型)</span>函数来获取相应类型的字节数。</p>
<p>fromwhere用于确定偏移量计算的起始位置，可以取以下三个值：</p>
<div class="table">

<table>
<thead>
<tr>
<th>起始点</th>
<th>别名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>文件开始</td>
<td>SEEK_SET</td>
<td>0</td>
</tr>
<tr>
<td>文件当前位置</td>
<td>SEEK_CUR</td>
<td>1</td>
</tr>
<tr>
<td>文件末尾</td>
<td>SEEK_END</td>
<td>2</td>
</tr>
</tbody></table>
</div>

<div class="show">eg:读取studentData.txt中的第k条数据并打印到控制台，k由用户输入
<code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE 10
typedef struct student &#123;
    char name[10];
    long studentID;
    int age;
    int classID;
&#125;STUDENT;
int main(void) &#123;
    void searchData(char fileName[],long k);
    long k;
    printf("Input the searching record number:");
    scanf("%ld",&k);
    searchData("studentData.txt",k);
    return 0;
&#125;
void searchData(char fileName[],long k)
&#123;
    FILE* fp;
    STUDENT stu;
    if ((fp = fopen(filename, "r")) == NULL) &#123;
        printf("文件打开失败!\n");
        exit(0);
    &#125;
    <span class="text-blue">fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);</span>
    <span class="text-red">fread(&stu, sizeof(STUDENT), 1, fp);</span>
    printf("%8s%8ld%4d%4d", stu.name, stu.studentID, stu.age, stu.classID);
    fclose(fp);
&#125;
</code></div>

<h5 id="返回指针位置ftell"><a href="#返回指针位置ftell" class="headerlink" title="返回指针位置ftell()"></a>返回指针位置ftell()</h5><p><span class="strong">long ftell(FILE *fp)</span>返回当前位置指针相对于文件开头的位移量(字节数)，若函数调用失败则返回-1L</p>
<div class="show">eg:ftell()返回的文件位置是用字节偏移量表示的，如果要获取记录号(第几条数据)则还要除以sizeof(STUDENT)
<code>fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);//执行完指针跳转，不确定指针指向哪里，可以用ftell()返回指针位置
long num=ftell(fp);//指针相对于文件头的偏移字节数
int k=num/sizeof(STUDENT);//指针指向的数据序号
</code></div>

<h4 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h4><ul>
<li><span class="strong">int feof(FILE *fp)</span>检查fp所指向文件是否已经读到文件末尾。当文件位置指针指向文件结束符时，返回非0值，否则返回0值</li>
<li><span class="strong">int ferror(FILE *fp)</span>检查对文件的输入输出操作是否出错，如果出错返回非零值，如果未出错，返回0。对同一个文件，每调用一次输入输出函数，ferror()函数的值都会更新</li>
<li><span class="strong">void clearerr(FILE *fp)</span>将fp所指向文件的文件错误标志和文件结束标志置为0</li>
<li><span class="strong">void perror(const char *str)</span>向标准错误输出字符串str，并随后附上冒号以及全局变量errno代表的错误消息的文字说明，无返回值</li>
<li><span class="strong">int rename(const char *old,const char *new)</span>将文件名old所指的文件改为new，成功返回0，出错返回1<h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4>在从终端设备输入输出时，系统会自动打开三个标准文件：标准输入、标准输出、标准出错输出。系统为其定义了三个文件指针：stdin、stdout和stderr，分别指向终端输入、终端输出和标准出错输出(也从终端输出)。在默认情况下，标准输入设备是键盘，标准输出设备是屏幕，我们从终端输入、输出时不需要手动打开终端文件，系统会自动打开，同样，如果程序指定从stdin所指的文件输入数据，其实就是指从终端键盘输入数据。</li>
</ul>
<p>文件读写操作中的很多函数是标准输入输出函数的文件操作版，如：fprintf()是printf()的文件操作版，二者差别在于fprintf()多了一个文件指针类型的参数(FILE * fp)，如果给该参数传递的值是stdout，那么fprintf()就和printf()完全一样了，同理，以下语句是两两等价的：</p>
<div class="show"><code>putchar(c)等价于fputc(c,stdout)
puts(str)等价于fputs(str,stdout)
getchar()等价于fgetc(stdin)
以下函数，fgets()比gets()还多了一个参数size
char *fgets(char *str,int size,FILE *fp);
char *gets(char *str);
参数size用于限制输入字符串的长度，说明fgets()函数输入缓冲区大小，使读入的字符数不能超过限定的缓冲区大小，从而达到防止缓冲区溢出攻击的目的，因此，以下语句，后者安全性更高
gets(str);
fgets(str,sizeof(str),stdin);
</code></div>

<p>虽然系统隐含的标准I/O文件是指终端文件，但标准输入和标准输出是可以重定向的，操作系统可以把它们重定向到其他文件或具有文件属性的设备，只有标准错误输出不能进行一般的输出重定向，如：把标准输出重定向到打印机，把标准输入重定向到U盘文件等。使用<span class="strong">“&lt;”</span>表示输入重定向，用<span class="strong">“&gt;”</span>表示输出重定向。如：file.exe是可执行文件，执行该程序时需要从键盘输入数据，如果现在要求从文件file.in读取所需要输入的数据，那么只需在DOS命令提示符下，输入以下命令即可：</p>
<div class="shell">c:\file.exe &lt; file.in</div>
这样file.exe的标准输入就被"&lt;"重定向到了file.in文件，此时程序只会从文件file.in读取数据，而不再理会任何键盘输入。同样，以下命令可以将标准输出重定向到文件file.out：
<div class="shell">c:\file.exe &gt; file.out</div>

<h3 id="C语言中的随机数"><a href="#C语言中的随机数" class="headerlink" title="C语言中的随机数"></a>C语言中的随机数</h3><p>C语言标准库在&lt;stdlib.h&gt;头文件中提供了用于生成随机数的函数<span class="text-red">rand()</span>，其函数原型为：<span class="strong">int rand(void)</span>，该函数可以生成<span class="text-blue">0~32767</span>范围内的随机数，但该函数生成的数是伪随机数，每次调用该函数都会重复生成以下值：</p>
<div class="show"><code>    printf("%d\n", rand());//41
    printf("%d\n", rand());//18467
    printf("%d\n", rand());//6334
    printf("%d\n", rand());//26500
    printf("%d\n", rand());//19169
    ......</code></div>

<p>这是由于，各编程语言获取随机数实际上都是基于递推公式计算出一组数值，当序列足够长，这组数值可以近似满足均匀分布。在计算随机数时，这些随机函数都是基于一种名为”种子”的基准值进行运算，当种子值不变，生成的随机数也将固定。C语言中,rand()函数的种子值默认为1，可以通过<span class="text-red">srand()</span>函数来修改该种子值，其函数原型为:<br><span class="strong">void srand(unsigned int seed);</span></p>
<div class="show"><code>    srand(6);
    printf("%d\n", rand());//58
    printf("%d\n", rand());//6673
    printf("%d\n", rand());//30119
    printf("%d\n", rand());//15745
    printf("%d\n", rand());//5206</code></div>

<p>如果将种子值设为当前时间，由于时间是每时每刻都不一样的，此时就可以真正生成一个随机数，C语言提供了获取当前时间戳的函数：<br><span class="strong">time_t time(time_t *timer);</span></p>
<p>该函数会当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，其返回值类型为time_t(但本质上为64位整型)，在用作生成随机数时，传入的参数一般为空指针NULL(或0)</p>
<div class="show"><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
int main()
&#123;   <span class="text-red">srand((unsigned int)time(NULL));</span>
    printf("%d\n", rand());
    printf("%d\n", rand());
    return 0;
&#125;
</code></div>

<p>如果需要指定生成随机数的范围，则还需要一些额外的运算</p>
<div class="show">以下操作建立在设置了随机数种子的前提下
<code>srand((unsigned int)time(NULL));</code>
1. 通过取模运算来限制随机数范围
<code>int randomNum = rand() % 100;//生成0-99之间的随机整数
int randomNum = rand()%100+1;//生成1-100之间的随机整数
该语句解析为：
int randomNum = rand()%(101-1)+1;//生成1-101(不包括101)之间的整数</code>
生成min-max(不包括max)之间的随机整数
<span class="text-blue">rand()%(max-min)+min</span>
2. 将随机整数除以RAND_MAX宏常量来获取随机小数：stdlib.h定义了rand()函数能返回伪随机数的最大值RAND_MAX，其值一般为32767，我们将获得的随机整数除以该常量值，就获得了一个0.0-1.0之间的随机小数
<code>double random_double = (double)rand()/(double)RAND_MAX;</code>
类似地可以限定该随机小数的范围为a-b：
<span class="text-blue">(double)rand() / RAND_MAX * (b - a) + a;</span>
</div>

<h3 id="常用函数和头文件"><a href="#常用函数和头文件" class="headerlink" title="常用函数和头文件"></a>常用函数和头文件</h3><p>列出了一些常用的函数及其头文件，这些头文件中还有很多其他函数，可以参考文档：<a target="_blank" rel="noopener" href="https://cplusplus.com/reference/">https://cplusplus.com/reference/</a>，里面罗列了很多C语言和C++的头文件和函数，二者文件名和函数形参可能有所不同但能类似套用</p>
<h4 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h4><p>以下是对部分字符的定义</p>
<div class="table">

<table>
<thead>
<tr>
<th>字符类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>标点符号字符</td>
<td>!@”#$%^&amp;’(),*+-./:&lt;=&gt;;[]\_{</td>
</tr>
<tr>
<td>图形字符</td>
<td>包括字母、数字、标点符号</td>
</tr>
<tr>
<td>空白字符</td>
<td>空格符、水平制表符\t、换行符\n、垂直制表符\v、换页符\f、回车符\r</td>
</tr>
<tr>
<td>控制字符</td>
<td>在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）</td>
</tr>
<tr>
<td>可打印字符</td>
<td>包括字母、数字、标点符号和空格字符</td>
</tr>
</tbody></table>
</div>

<p>以下函数用于测试和映射字符，需要包含字符串<span class="text-red">&lt;ctype.h&gt;</span>，除了最后的大小写转换函数，其余函数如果参数 c 满足描述的条件，则这些函数返回非零值(true)，一般返回值为1，否则返回零(false)</p>
<div class="table">

<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>isalnum</td>
<td>int isalnum(int c)</td>
<td>检查字符c是否是字母和数字</td>
</tr>
<tr>
<td>isalpha</td>
<td>int isalpha(int c)</td>
<td>检查字符c是否是字母</td>
</tr>
<tr>
<td>iscntrl</td>
<td>int iscntrl(int c)</td>
<td>检查字符c是否是控制字符</td>
</tr>
<tr>
<td>isprint</td>
<td>int isprint(int c)</td>
<td>检查字符c是否是可打印的</td>
</tr>
<tr>
<td>isdigit</td>
<td>int isdigit(int c)</td>
<td>检查字符c是否是十进制数字</td>
</tr>
<tr>
<td>isxdigit</td>
<td>int isxdigit(int c)</td>
<td>检查字符c是否是十六进制数字</td>
</tr>
<tr>
<td>isgraph</td>
<td>int isgraph(int c)</td>
<td>检查字符c是否有图形表示法，有图形表示法的字符是指除了空白字符以外的所有可打印的字符</td>
</tr>
<tr>
<td>islower</td>
<td>int islower(int c)</td>
<td>检查字符c是否是小写字母</td>
</tr>
<tr>
<td>isupper</td>
<td>int isupper(int c)</td>
<td>检查字符c是否是大写字母</td>
</tr>
<tr>
<td>ispunct</td>
<td>int ispunct(int c)</td>
<td>检查字符c是否是标点符号字符</td>
</tr>
<tr>
<td>isspace</td>
<td>int isspace(int c)</td>
<td>检查字符c是否是空白字符</td>
</tr>
<tr>
<td>tolower</td>
<td>int tolower(int c)</td>
<td>把给定的字符c转换为小写字母，如果已经是小写字母则c不变</td>
</tr>
<tr>
<td>toupper</td>
<td>int toupper(int c)</td>
<td>把给定的字符c转换为大写字母，如果已经是大写字母则c不变</td>
</tr>
</tbody></table>
</div>

<p>以下函数用于处理字符串，需要包含头文件<span class="text-red">&lt;string.h&gt;</span></p>
<div class="table">

<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>strlen</td>
<td>unsigned int strlen( const char *str);</td>
<td>返回字符串str中实际字符的个数(不包括终止符’\0’)</td>
</tr>
<tr>
<td>strcat</td>
<td>char *strcat(char *str1,const char *str2)</td>
<td>把字符串str2拼接到str1后面,并在拼接好的str1串末尾添加一个’\0’,原str1末尾的’\0’将被覆盖。因无边界检查,调用时应保证str1的空间足够大,能存放原始str1和str2两个串的内容。函数返回指向str1的指针</td>
</tr>
<tr>
<td>strncat</td>
<td>char * strncat( char * strl, constchar * str2, unsigned int count);</td>
<td>把字符串str2中不多于count个字符拼接到str1后面,并添加\0’,原str1末尾的’\0’将覆盖，函数指向返回str1的指针</td>
</tr>
<tr>
<td>strcpy</td>
<td>char * strcpy( char * strl, constchar *str2);</td>
<td>把str2指向的字符串复制到str1中，str2必须是终止符为’\0’的字符串指针，函数返回指向str1的指针</td>
</tr>
<tr>
<td>strncpy</td>
<td>char *strncpy(char * strl, constchar *str2,unsigned int count);</td>
<td>把str2指向的字符串中的count个字符复制到st1中，str2必须是终止符为’\0’的字符串指针。如果str2指向的字符串少于 count个字符，则将’\0’加到str1的尾部,直到满足coun个字符为止。如果str2指向的字符串长度大于count个字符，则结果串str1不用’\0’结尾，函数返回指向strl的指针</td>
</tr>
<tr>
<td>strcmp</td>
<td>int strcmp(const char * strl,const char * str2);</td>
<td>按字典顺序比较两个字符串str1和str2。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数</td>
</tr>
<tr>
<td>strcnmp</td>
<td>int strcnmp( const char * strl,const char*str2,unsigned intcount);</td>
<td>按字典顺序比较两个字符串str1和str2的不多于count个字符。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数</td>
</tr>
<tr>
<td>strtr</td>
<td>char * strstr(char * strl, char *str2);</td>
<td>找出str2字符串在str1字符串中第一次出现的位置(不包括str2的串结束符)。函数返回该位置的指针。若找不到则返回空指针</td>
</tr>
</tbody></table>
</div>

<h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>使用以下函数，源文件需要包含<span class="tips">&lt;math.h&gt;</span>头文件，以下函数这里只写出了返回值和形参为double类型的函数原型，它们中的绝大多数还有一个返回值和形参为float或long double类型的函数原型，因此可以类似地套用</p>
<div class="table">

<table>
<thead>
<tr>
<th>函数名</th>
<th>函数原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>fabs</td>
<td>double fabs( double x);</td>
<td>计算x的绝对值，返回浮点数</td>
</tr>
<tr>
<td>abs</td>
<td>double abs (double x);</td>
<td>在c++中该函数声明于cmath头文件，可以用于计算double、float、long double的绝对值，在c语言中声明于stdlib.h文件，用于计算int的绝对值</td>
</tr>
<tr>
<td>ceil</td>
<td>double ceil (double x);</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor</td>
<td>double floor( double x);</td>
<td>向下取整，计算不大于x的最大整数</td>
</tr>
<tr>
<td>round</td>
<td>double round  (double x);</td>
<td>四舍五入取整</td>
</tr>
<tr>
<td>pow</td>
<td>double pow( double base, doubleexp);</td>
<td>返回base为底的exp次幂,即base<sup>exp</sup>,返回计算结果。当base等于0而exp小于0时或者base小于0而exp不为整数时,出现结果错误。该函数要求参数base和exp以及函数的返回值为double类型,否则有可能出现数值溢出问题</td>
</tr>
<tr>
<td>sqrt</td>
<td>double sqrt(double x)</td>
<td>计算√x(根号下x)的值，注意x&gt;=0</td>
</tr>
<tr>
<td>exp</td>
<td>double exp( double x);</td>
<td>计算e<sup>x</sup>的值</td>
</tr>
<tr>
<td>fmod</td>
<td>double fmod ( double x, double y);</td>
<td>计算整除x/y的余数</td>
</tr>
<tr>
<td>log</td>
<td>double log( double x );</td>
<td>计算log<sub>e</sub>x,即lnx,返回计算结果。注意,x&gt;0</td>
</tr>
<tr>
<td>log10</td>
<td>double log10( double x);</td>
<td>计算 log<sub>10</sub>x,返回计算结果。注意,x&gt;0</td>
</tr>
<tr>
<td>sin</td>
<td>double sin(double x)</td>
<td>计算sinx的值，x为弧度值</td>
</tr>
<tr>
<td>cos</td>
<td>double cos(double x)</td>
<td>计算cos(x)的值，x为弧度值</td>
</tr>
<tr>
<td>tan</td>
<td>double tan(double x);</td>
<td>计算tanx的值</td>
</tr>
<tr>
<td>asin</td>
<td>double asin(double x)</td>
<td>计算cos<sup>-1</sup>(x)的值，注意，x应为-1到1范围</td>
</tr>
<tr>
<td>acos</td>
<td>double acos(double x)</td>
<td>计算sin<sup>-1</sup>(x)的值，注意，x应为-1到1范围</td>
</tr>
<tr>
<td>atan</td>
<td>double atan(double x)</td>
<td>计算tan<sup>-1</sup>(x)的值</td>
</tr>
<tr>
<td>atan2</td>
<td>double atan2(double x,double y)</td>
<td>计算tan<sup>-1</sup>(x/y)的值</td>
</tr>
<tr>
<td>sinh</td>
<td>double sinh(double x)</td>
<td>计算x的双曲正弦函数sinh(x)的值</td>
</tr>
<tr>
<td>cosh</td>
<td>double cosh(double x)</td>
<td>计算x的双曲余弦 cosh(x)的值</td>
</tr>
<tr>
<td>tanh</td>
<td>double tanh(double x)</td>
<td>计算x的双曲正切函数tanh(x)的值</td>
</tr>
<tr>
<td>frexp</td>
<td>double frexp(double val,int*eptr);</td>
<td>把双精度数val分解为小数部分(尾数)x和以2为底的指数n(阶码),即val=x*2 <sup>n</sup>,n存放在eptr指向的变量中,函数返回小数部分x,0.5≤x&lt;1</td>
</tr>
<tr>
<td>modf</td>
<td>double modf( double val, double *iptr);</td>
<td>把双精度数val分解为整数部分和小数部分,把整数部分存到iptr指向的单元。返回val的小数部分</td>
</tr>
</tbody></table>
</div>


<h4 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h4><div class="table">

<table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>atof</td>
<td>stdlib.h</td>
<td>double atof(const char * str);</td>
<td>把str指向的字符串转换成双精度浮点值,串中必须含合法的浮点数,否则返回值无定义。函数返回转换后的双精度浮点值</td>
</tr>
<tr>
<td>atoi</td>
<td>stdlib.h</td>
<td>int atoi(const char *str);</td>
<td>把str指向的字符串转换成整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的整型值</td>
</tr>
<tr>
<td>alol</td>
<td>stdlib.h</td>
<td>long int atol(const char * str);</td>
<td>把str指向的字符串转换成长整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的长整型值</td>
</tr>
<tr>
<td>exit</td>
<td>stdlib.h</td>
<td>void exit(int code);</td>
<td>使程序立即终止,清空和关闭任何打开的文件。程序正常退出状态由code等于0或EXITSUCCESS表示，如exit(0)，非0值或EXIT_FAILURE表明定义实现错误。函数无返回值</td>
</tr>
<tr>
<td>rand</td>
<td>stdlib.h</td>
<td>int rand(void);</td>
<td>产生伪随机数序列。函数返回0到RAND_MAX之间的随机整数,RAND_MAX至少是32767</td>
</tr>
<tr>
<td>srand</td>
<td>stdlib.h</td>
<td>void srand(unsigned int seed );</td>
<td>为函数rand()生成的伪随机数序列设置起点种子值，函数无返回值</td>
</tr>
<tr>
<td>time</td>
<td>time.h</td>
<td>time_t time(time_t *timer)</td>
<td>如果传入的参数为空指针NULL，则该函数返回当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，返回值类型为time_t(但本质上为64位整型)。如果参数为time_t类型指针变量timer，则该时间差值也将放于timer所指向的内存中</td>
</tr>
<tr>
<td>clock</td>
<td>time.h</td>
<td>clock_t clock(void);</td>
<td>clock_t是long类型，该函数返回硬件的时钟节拍数，需要换成秒或者毫秒，通常需要除以CLK_TCK或者CLOCKS_PER_SEC。例如,在VC6.0下,这两个量的值都是1000,表示硬件1秒钟的时钟节拍数为1000，该函数常用于测量从程序开始运行到clock()被调用时所消耗的时间，或用于实现计时器功能，如：计算一个进程的时间需要用clock()除以1000。注意:本函数仅能返回ms级的计时精度</td>
</tr>
<tr>
<td>Sleep</td>
<td>stdlih.h</td>
<td>Sleep(unsigned long second);</td>
<td>在标准C中和Linux下是函数的首字母不大写。但在VC和Code::blocks环境下首字母要大写。Sleep()函数的功能是将进程挂起一段时间,即起到延时的作用。参数的单是毫秒</td>
</tr>
<tr>
<td>system</td>
<td>stdlib.h</td>
<td>int system(char * command);</td>
<td>发出一个DOS命令。例如,system(“CLS”)可以实现清屏操作</td>
</tr>
<tr>
<td>kbhit</td>
<td>conio.h</td>
<td>int kbhit(void);</td>
<td>检查当前是否有键盘输人,若有则返回一个非0值,否则回 0</td>
</tr>
<tr>
<td>getch</td>
<td>conio.h</td>
<td>int getch(void);</td>
<td>无需用户按回车键即可得到入户输入，只要用户按下一个键，立刻返回用户输入字符的ASCII码值，但输入的字符不会显示在屏幕上，出错时返回-1，该函数在游戏中比较常用</td>
</tr>
</tbody></table>
</div>
        </div>
    </div>
    <div class="post-nav">
        
            <div class="post-prev ">
                <a href="/blog/2025/07/21/systemd/">上一篇：systemd</a>
            </div>
            
            
                <div class="post-next">
                    <a href="/blog/2023/09/07/JavaScript%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B0%BA%E5%AF%B8/">下一篇：JavaScript中的各种尺寸 </a>
                </div>
                 
    </div>
    <div class="container">
        <!--设计来源于B站-季夏小贞-->
        <div class="bigHead"></div>
        <div class="ears"></div>
        <div class="body"></div>
        <div class="paws-front"></div>
        <div class="paws-back"></div>
        <div class="details"></div>
        <div class="tail"></div>
        <div class="sleep">
          <span class="s1">z</span>
          <span class="s2">z</span>
          <span class="s3">z</span>
          <span class="s4">z</span>
          <span class="s5">z</span>
        </div>
    </div>
</div>
<div class="right-menu">
    <a class="iconfont backTop" href="javascript:">&#xe655;</a>
    <div class="husky"></div>
  </div>
</div>

<script src="/blog/js/jquery.min.js"></script>
<script src="/blog/js/jquery.bumpytext.js"></script>
<script src="/blog/js/index.js"></script>
<script src="/blog/js/highlight.min.js"></script>
<script src="/blog/js/highlightjs-line-numbers.min.js"></script>
<script src="/blog/js/article.js"></script>

</body></html>