<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="shiwi"><meta name="copyright" content="SHIWIVI"><link rel="preconnect" href="https://cdn.jsdelivr.net/"><link rel="shortcut icon" href="/blog/images/favicon.ico" type="image/x-icon"><style>.preload{position:absolute;display:flex;flex-direction:column;align-items:center;justify-content:center;left:0;top:0;width:100%;height:100%;background-color:#000;z-index:100}.text{margin-bottom:10px;color:#00cff3;text-shadow:0 0 3px #00cff3;font-size:20px}.text span{display:inline-block}.dance{animation:dance .8s linear}.text span:nth-child(1){animation-delay:0s}.text span:nth-child(2){animation-delay:.1s}.text span:nth-child(3){animation-delay:.2s}.text span:nth-child(4){animation-delay:.3s}.text span:nth-child(5){animation-delay:.4s}.text span:nth-child(6){animation-delay:.5s}.text span:nth-child(7){animation-delay:.6s}.text span:nth-child(8){animation-delay:.7s}.text span:nth-child(9){animation-delay:.8s}.text span:nth-child(10){animation-delay:.9s}@keyframes dance{0%{transform:translateY(0)}50%{transform:translateY(-20px)}100%{transform:translateY(0)}}.loading{width:80%;max-width:260px;height:6px;background-color:#e1e4e8;border-radius:6px}.bar{display:flex;height:100%;background:linear-gradient(90deg,#ffd33d,#ea4aaa 10%,#b34bff 30%,#01feff 51%,#ffb33d 68%,#ea4aaa 85%,#b34bff);background-size:300% 100%;animation:bar 2s linear infinite}@keyframes bar{0%{background-position:100%}100%{background-position:0}}</style><body><div class="preload"><div class="text"><span>L</span> <span>o</span> <span>a</span> <span>d</span> <span>i</span> <span>n</span> <span>g</span> <span>.</span> <span>.</span> <span>.</span></div><div class="loading"><span class="bar"></span></div></div><script>let texts=document.querySelector('.text').querySelectorAll('span');let timer=setInterval(()=>{texts.forEach((item)=>{item.classList.toggle("dance")})},1700);window.onload=function(){clearInterval(timer);document.querySelector('.preload').style="display:none;"}</script><title>SHIWIVI-文章</title>
<link rel="stylesheet" href="https://at.alicdn.com/t/font_2856826_bu73u0ahu7a.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">

<link rel="stylesheet" href="/blog/css/index.css">
<link rel="stylesheet" href="/blog/css/article.css">
<link rel="stylesheet" href="/blog/css/atelier-cave.min.css">

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blog/atom.xml" title="SHWIVI's blog" type="application/atom+xml">
</head>
<body>
<div class="nav">
    <div class="card">
        <div class="head">
            <img src="/blog/images/head.jpg"  alt="头不见了.." title="狗">
        </div>
        <div class="cardText">
            <p>(ー`´ー)</p>
            <p>那不是bug，是彩蛋</p>
        </div> 
    </div>
    <ul class="label">
        
        <li><a href="/blog/index.html">首页</a></li>
        
        <li><a href="/blog/life">日常</a></li>
        
        <li><a href="/blog/record">一句</a></li>
        
        <li><a href="/blog/message">留言</a></li>
        
        <li><a href="/blog/about">关于</a></li>
          
    </ul>
        <ul class="tag">
            <li>#Document</li>
            <li>#Java</li>
            <li>#css</li>
            <li>#Life</li>
            <li>#Lua</li>
            <li>#PCB</li>
            <li>#Shell</li>
            <li>#C</li>
            <li>#html</li>
            <li>#硬件</li>
            <li>#javaScript</li>
            <li>#Firewall</li>
            <li>#Security</li>
            <li><a href="/blog/tags/Linux" target="_blank">#Linux</a></li>
            <li>#Python</li>
            <li>#Serve</li>
            <li>#Web</li>
        </ul>
    <div class="rsstag"><a href="/blog/atom.xml"><span class="iconfont icon-rss"></span>RSS订阅</a></div>
<div class="flower">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="84.6px" height="70.5px" viewBox="0 0 254 212" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>窗</title>
<desc>Created with Sketch.</desc>
<defs></defs>
<g id="植物" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
    <g id="Artboard" transform="translate(-885.000000, -503.000000)">
        <g id="植物-紫色盆" transform="translate(882.000000, 500.000000)">
            <ellipse id="Oval-12" fill="#B3B7C7" cx="140.5" cy="137" rx="39.5" ry="6"></ellipse>
            <g id="Group-5">
                <path d="M131.5,149 C137.746054,149 138.400559,136.953074 140.297813,118.503702 C141.504079,106.77367 149.145158,88.1140929 147,75 C142.297813,46.2539062 153.271934,32.5660626 150.170125,19.4282488 C148.031314,10.3692495 142.862042,3 131.5,3 C123.603887,3 113.698654,6.59314895 110.722909,11.2157433 C103.206874,22.8913341 114,46.5137576 114,75 C114,90.4435309 122.495151,106.751425 123.699377,118.476362 C125.595832,136.941172 125.250862,149 131.5,149 Z" id="Oval-11" fill="#BAC4F6"></path>
                <path d="M135.5,146.5 C132.598908,121.877878 130.965369,104.566553 130.599381,94.5660242 C130.050399,79.5652312 132.963841,77.0580598 132.164069,55.3464601 C131.630888,40.8720602 130.242865,30.4232402 128,24" id="Line-15" stroke="#FFFFFF" stroke-width="2" opacity="0.800892857" stroke-linecap="square"></path>
                <path d="M77.0442201,163.336077 C84.2239219,163.336077 101.067658,131.237823 101.067658,92.025606 C101.067658,52.8133888 90.9057581,-2.32627732 72.6560979,17.2440872 C50.0508064,41.4852946 69.5871262,36.5862429 74.0442201,63.8595149 C75.572858,73.2133576 77.0442201,94.5993942 77.0442201,104.613421 C77.0442201,143.825638 69.8645184,163.336077 77.0442201,163.336077 Z" id="Oval-9" fill="#BAC4F6" transform="translate(81.510722, 88.251316) rotate(-43.000000) translate(-81.510722, -88.251316) "></path>
                <path d="M42.5,50.5 C47.5132933,48.8699207 59.3816332,57.6317857 78.1050199,76.785595 C96.8284065,95.9394043 113.960067,116.844206 129.5,139.5" id="Line-17" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M155.281006,152.144255 C162.116643,152.144255 178.153197,121.584207 178.153197,84.2511084 C178.153197,72.6051871 184.354199,51.8242671 182.531201,39.8465879 C178.51025,13.4276595 163.058175,0.233079666 151.10317,13.0532528 C129.581164,36.1327785 143.297279,29.7382802 147.540781,55.7045685 C148.996164,64.6101585 153.500382,80.3852665 153.500382,89.9194035 C153.500382,127.252502 148.445368,152.144255 155.281006,152.144255 Z" id="Oval-9-Copy-2" fill="#E9EDFD" transform="translate(161.092971, 80.123972) scale(-1, 1) rotate(-20.000000) translate(-161.092971, -80.123972) "></path>
                <path d="M180.5,34.5 C181.290102,21.4892162 175.746138,28.9223292 163.868108,56.7993391 C157.546037,71.6368512 150.532373,85.3308057 144.827114,101.881203 C141.023608,112.914801 138.581237,128.787733 137.5,149.5" id="Line-20" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M60.3426107,183.894782 C69.2498271,183.894782 90.1463498,156.072081 90.1463498,122.083011 C90.1463498,88.0939419 67.5408019,29.4364067 54.8986583,57.2625442 C45.0326912,78.978146 51.0912584,74.0282851 56.6207779,97.6687014 C58.5172227,105.776593 67.8616068,124.363423 67.8616068,133.043561 C67.8616068,167.032631 51.4353942,183.894782 60.3426107,183.894782 Z" id="Oval-9-Copy" fill="#BAC4F6" transform="translate(69.895982, 116.944107) rotate(-71.000000) translate(-69.895982, -116.944107) "></path>
                <path d="M24.5,109.5 C22.4991751,103.669523 35.0833631,105.49608 62.2525641,114.979669 C79.4278854,120.974828 92.103247,119.378882 106.278649,126.191831 C111.777518,128.834684 120.517968,134.937407 132.5,144.5" id="Line-19" stroke="#FFFFFF" stroke-width="2" opacity="0.595424107" stroke-linecap="square"></path>
                <path d="M169.495543,159.559977 C178.40276,159.559977 199.299282,131.737276 199.299282,97.7482062 C199.299282,85.7856682 202.004463,66.329956 197.824033,53.1018748 C190.126639,28.745108 172.2443,14.8950801 164.051591,32.9277389 C154.185624,54.6433407 160.244191,49.6934798 165.77371,73.3338961 C167.670155,81.4417878 177.014539,100.028618 177.014539,108.708756 C177.014539,142.697825 160.588327,159.559977 169.495543,159.559977 Z" id="Oval-9-Copy-3" fill="#BAC4F6" transform="translate(179.479352, 92.134636) scale(-1, 1) rotate(-43.000000) translate(-179.479352, -92.134636) "></path>
                <path d="M213.5,60.5 C209.183273,60.8948914 201.740861,65.4428024 191.172763,74.1437328 C175.320617,87.1951284 177.797205,83.2393994 161.560337,103.262986 C150.735758,116.612043 142.715646,131.024381 137.5,146.5" id="Line-21" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M81.1425752,168.630026 C85.1025169,165.536181 98.2051544,147.96348 98.2051544,111.236918 C98.2051544,74.5103552 86.0176544,46.7369177 70.0176544,46.7369177 C54.0176544,46.7369177 59.5351666,70.3889964 66.8400325,93.0530589 C69.6371249,101.731312 78.9791535,122.814465 81.0032985,132.88325 C84.2653955,149.110029 78.6989273,170.539213 81.1425752,168.630026 Z" id="Oval-10" fill="#E9EDFD" transform="translate(78.936475, 107.743055) rotate(-52.000000) translate(-78.936475, -107.743055) "></path>
                <path d="M39.5,84.5 C46.5402399,84.832105 55.9862242,87.7506309 67.8379528,93.2555776 C85.6155457,101.512998 79.9127462,96.6348296 100.298442,112.739947 C113.888906,123.476691 125.956092,135.063376 136.5,147.5" id="Line-18" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M194.823347,177.534556 C197.785465,175.220296 209.085075,165.125173 213.530819,146.109724 C215.496552,137.701844 211.555235,124.000271 211.555235,111.853141 C211.555235,72.2337887 199.639103,43.8487815 182.378853,43.8487815 C165.118604,43.8487815 168.053621,58.2764613 175.933859,82.7256721 C183.814096,107.174883 191.693317,118.61017 193.876895,129.472028 C197.395933,146.976919 192.187224,179.594121 194.823347,177.534556 Z" id="Oval-10-Copy-2" fill="#E9EDFD" transform="translate(191.881132, 110.738214) scale(-1, 1) rotate(-52.000000) translate(-191.881132, -110.738214) "></path>
                <path d="M237.5,84.5 C231.839918,82.6252532 222.387737,84.7837206 209.143456,90.9754021 C189.277034,100.262925 198.344222,96.9653923 174.587666,113.911421 C158.749962,125.208774 147.387407,137.071634 140.5,149.5" id="Line-22" stroke="#FFFFFF" stroke-width="2" opacity="0.785044643" stroke-linecap="square"></path>
                <path d="M102.095097,154.049614 C106.979303,150.233654 123.140143,128.559423 123.140143,83.2607523 C123.140143,37.9620813 108.108037,3.70622602 88.3735811,3.70622602 C68.639125,3.70622602 75.4444439,32.8787829 84.4542911,60.8327171 C87.9042347,71.5365054 99.4267255,97.5405402 101.923313,109.959415 C105.946795,129.97358 99.0810936,156.404412 102.095097,154.049614 Z" id="Oval-10-Copy" fill="#E9EDFD" transform="translate(99.374086, 78.951409) rotate(-21.000000) translate(-99.374086, -78.951409) "></path>
                <path d="M70.5,27.5 C77.9697854,36.2141564 84.664658,44.2949462 90.5846178,51.7423694 C99.4645574,62.9135043 102.309139,65.8595669 108.078018,74.773869 C113.846897,83.6881711 108.232283,69.1486166 118.500716,94.8794382 C125.346337,112.033319 129.012765,128.573507 129.5,144.5" id="Line-16" stroke="#FFFFFF" stroke-width="2" stroke-linecap="square"></path>
                <path d="M193.001521,189.153265 C198.929205,189.153265 212.83568,162.652399 212.83568,130.278124 C212.83568,97.9038493 204.210737,49.7003434 189.378612,68.5372278 C174.540517,87.3816949 180.150684,86.5530431 183.830536,109.070321 C185.092606,116.793013 193.001521,132.403088 193.001521,140.670839 C193.001521,173.045114 187.073837,189.153265 193.001521,189.153265 Z" id="Oval-9-Copy-4" fill="#BAC4F6" transform="translate(196.248002, 126.727326) scale(-1, 1) rotate(-73.000000) translate(-196.248002, -126.727326) "></path>
                <path d="M234.5,116.5 C229.435614,115.997419 220.043174,117.148484 206.322678,119.953197 C185.741934,124.160265 185.201799,123.9696 168.145826,131.063968 C156.775178,135.793546 148.226569,140.93889 142.5,146.5" id="Line-23" stroke="#FFFFFF" stroke-width="2" opacity="0.733426339" stroke-linecap="square"></path>
            </g>
            <g id="Group-4" transform="translate(101.000000, 137.000000)">
                <path d="M0,0 C11.7955729,2 24.5052083,3 38.1289062,3 C51.7526042,3 65.3763021,2 79,0 L71.2109375,75.3409091 C61.9375,77.1136364 51.8945312,78 41.0820312,78 C30.2695313,78 19.4570312,77.1136364 8.64453125,75.3409091 L0,0 Z" id="Rectangle-9" fill="#FCDCCF"></path>
                <path d="M59.2621996,2.19791001 C63.6483775,1.86496527 70.2276443,1.1323286 79,0 L71.2109375,75.3409091 C63.3055851,76.5844933 57.2271178,77.3450382 52.9755357,77.6225437 L59.2621996,2.19791001 Z" id="Rectangle-9" fill="#ECC6B6"></path>
                <path d="M0,0 C10.9588352,1.33333333 23.3572727,2 37.1953125,2 C51.0333523,2 64.9682481,1.33333333 79,0 L76.7909585,21.3672948 L40.573652,23.0934676 L2.38711382,20.8047516 L0,0 Z" id="Rectangle-9" fill="#F3B096"></path>
            </g>
        </g>
    </g>
</g>
</svg>
</div>

</div>
<div class="menuBtn closed"> 
    <div class="menu-line"></div>
    <div class="menu-line"></div>
    <div class="menu-line"></div>
</div>
<div class="nightSky"><!--当关闭夜间背景模式时，子元素将在一段延时后才会被清除--></div>
<div class="main">
    <div class="msg">
        <div class="msgText"></div>
        <div class="msgBar"></div>
    </div>
    <div class="motto">
        <p> //sunny forever<br />
            while(life&lt;end){<br />
               love++;<br />
               beAwesome :)} </p>
     </div>
     <div class="mainContent">
    <div class="canvasWrapper"></div>
<div class="setWrapper">
    <ul class="setMenu">
        <div id="setBtn" class="setButton"><</div>
        <li class="searchContainer">
            <input id="searchInput" class="localSearch" placeholder="搜索..." type="search" >
            <span class="searchIco"></span>
        </li>
        <li id="toggleItem">
        主题：<span class="itemIco sun"></span>
        </li>
        <li class="setSize">
            <span id="increaseFontSize">+</span>
            <span class="fontSizeNum"></span>
            <span id="reduceFontSize">-</span>
        </li>
        <li id="clearBack">清除背景</li>
        <li id="disableBack">禁用背景</li>
    </ul> 
</div>
    <div class="resultContainer">
        <div id="searchResult" class="displayResult"></div>
    </div>
    <div class="tocWrapper"><div class="tocBtn">目 录</div><div class="tocBox"><!--tocBox用于容纳生成在toc外的目录--><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E"><span class="toc-number">1.1.</span> <span class="toc-text">关于</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%BB%E5%B8%83"><span class="toc-number">1.2.</span> <span class="toc-text">创建画布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87HTML%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">通过HTML标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87JavaScript%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">通过JavaScript动态创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E5%B0%BA%E5%AF%B8%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.3.</span> <span class="toc-text">画布尺寸的说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">1.3.</span> <span class="toc-text">兼容性检查</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Canvas-2D%E6%B8%B2%E6%9F%93API"><span class="toc-number"></span> <span class="toc-text">Canvas 2D渲染API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BE%B9"><span class="toc-number">1.2.</span> <span class="toc-text">描边</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85"><span class="toc-number">1.3.</span> <span class="toc-text">填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%81%E5%89%AA"><span class="toc-number">1.4.</span> <span class="toc-text">裁剪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4"><span class="toc-number">1.5.</span> <span class="toc-text">清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E8%B7%AF%E5%BE%84-Path2D%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">封装路径-Path2D对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%88%A4%E6%96%AD"><span class="toc-number">1.7.</span> <span class="toc-text">位置判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">线段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%BA%BF%E7%BA%BF%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">实线线段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E8%B7%AF%E5%BE%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">线段路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%8A%98%E7%82%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">线段折点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%9C%AB%E7%AB%AF"><span class="toc-number">2.1.3.</span> <span class="toc-text">线段末端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BA%BF%E7%BA%BF%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">虚线线段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E5%BD%A2"><span class="toc-number">3.</span> <span class="toc-text">矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A9%E5%BD%A2%E8%B7%AF%E5%BE%84"><span class="toc-number">3.0.1.</span> <span class="toc-text">矩形路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%8F%E8%BE%B9%E7%9F%A9%E5%BD%A2"><span class="toc-number">3.0.2.</span> <span class="toc-text">描边矩形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E7%9F%A9%E5%BD%A2"><span class="toc-number">3.0.3.</span> <span class="toc-text">填充矩形</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">渐变对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%B8%90%E5%8F%98%E8%89%B2"><span class="toc-number">4.1.</span> <span class="toc-text">添加渐变色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.</span> <span class="toc-text">线性渐变对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.</span> <span class="toc-text">径向渐变对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%A5%E5%BD%A2%E6%B8%90%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.</span> <span class="toc-text">锥形渐变对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">Pattern对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF"><span class="toc-number">6.</span> <span class="toc-text">曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%86%E4%B8%8E%E5%9C%86%E5%BC%A7%E7%BA%BF%E7%BB%98%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">圆与圆弧线绘制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%86%E5%BC%A7%E7%BA%BF%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%952"><span class="toc-number">6.2.</span> <span class="toc-text">圆弧线绘制方法2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A4%AD%E5%9C%86"><span class="toc-number">6.3.</span> <span class="toc-text">椭圆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">6.4.</span> <span class="toc-text">贝塞尔曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">6.4.1.</span> <span class="toc-text">二阶贝塞尔曲线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E9%98%B6%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-number">6.4.2.</span> <span class="toc-text">三阶贝塞尔曲线</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E7%BB%98%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">文字绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97"><span class="toc-number">7.1.</span> <span class="toc-text">绘制文字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%AE%BD%E5%BA%A6"><span class="toc-number">7.2.</span> <span class="toc-text">获取文本宽度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">7.3.</span> <span class="toc-text">文本属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%B9%E5%90%91"><span class="toc-number">7.4.</span> <span class="toc-text">文本方向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E7%BB%98%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">图像与视频绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE"><span class="toc-number">9.</span> <span class="toc-text">移动、旋转、缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1"><span class="toc-number">10.</span> <span class="toc-text">阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A4%E9%95%9C"><span class="toc-number">11.</span> <span class="toc-text">滤镜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">图像合成模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">13.</span> <span class="toc-text">状态保存与恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C-ImageData%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">像素操作-ImageData对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">15.</span> <span class="toc-text">案例</span></a></li></ol></div></div>
        <div class="article">
        <h1 class="title">Canvas</h1>
        <div class="art_infor">
            <div><span><span class="iconfont icon-zishu-jzl"></span>字数：29356</span>
            <span><span class="iconfont icon-riqi"></span>写于：2023-05-03</span></div>
            <div><span><span class="iconfont icon-zuixinnew3"></span>最新更新：2023-05-03</span>
            <span><span class="iconfont icon-shijian"></span>阅读本文预计花费您84分钟</span></div>
        </div>
        <div class="art_content">
        <h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p><span class="tips">canvas</span>是HTML5新增的标签，用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面，canvas不支持IE8及IE8以下浏览器</p>
<div class="broadcast color-blue">
<div class="iconfont icon-yinhao"></div>
具体的兼容性可以参考MDN文档：
<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas
">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas</a></div>


<h4 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h4><h5 id="通过HTML标签"><a href="#通过HTML标签" class="headerlink" title="通过HTML标签"></a>通过HTML标签</h5><p>可以通过直接添加HTML标签的方式创建canvas，并设置画布的宽高，然后通过<span class="tips">getContext()</span>方法获得画布的 2D 渲染上下文对象，需要为该方法提供<span class="tips">‘2d’</span>作为参数，该对象提供了用于在画布上绘图的方法和属性</p>
<pre><code>&lt;body>
    &lt;canvas width="600" height="400" id="canvas">&lt/canvas>
    &ltscript>
        const canvas=document.getElementById('canvas');
        const context = canvas.getContext('2d');
    &lt;/script>
&lt;/body>
</code></pre>

<h5 id="通过JavaScript动态创建"><a href="#通过JavaScript动态创建" class="headerlink" title="通过JavaScript动态创建"></a>通过JavaScript动态创建</h5><p>也可以通过JavaScript动态添加canvas并指定宽高，tips:通过JavaScript创建的canvas在写代码时IDE会有代码补全提示</p>
<pre><code> const canvas=document.createElement("canvas");
    canvas.width=600;
    canvas.height=400;
    document.body.appendChild(canvas);
 const context = canvas.getContext('2d');</code></pre>

<h5 id="画布尺寸的说明"><a href="#画布尺寸的说明" class="headerlink" title="画布尺寸的说明"></a>画布尺寸的说明</h5><ul>
<li>canvas需要通过属性来设置宽度、高度，且不需要单位</li>
<li>通过CSS设置canvas的width和height属性，仅用于缩放图像，无法改变画布尺寸，当CSS指定的宽高与画布的宽高比例不一致时，图像会出现扭曲</li>
<li>默认画布大小为300px * 150px，宽高比为2:1，如果不指定画布的宽高，或者设置了无效值(如负数)，则会使用默认值</li>
</ul>
<div class="broadcast color-blue">
<div class="iconfont icon-yinhao"></div>
通过CSS设置的Canvas宽高样式只会修改浏览器渲染后所显示图像的宽高，不会修改画布本身及其图像本身的宽高。浏览器会在渲染期间根据CSS对源图像进行伸缩，以适应指定的CSS样式大小。如果 CSS 的指定的宽高尺寸与画布的宽高比例不一致，图像有可能出现扭曲。而通过属性修改的画布宽度和高度，实际会修改Canvas DOM对象的属性值，即画布本身的宽度和高度，并将该DOM对象传递给canvas内部的2d渲染上下文环境对象(CanvasRenderingContext2D)
</div>

<h4 id="兼容性检查"><a href="#兼容性检查" class="headerlink" title="兼容性检查"></a>兼容性检查</h4><p>IE9之前的浏览器不支持Canvas，如果不兼容canvas，canvas 标签会被浏览器解析为自定义标签，显示标签内的提示信息</p>
<div class="show">&lt;canvas id="canvas">抱歉，您的浏览器不支持 canvas 标签&lt;/canvas></div>
    同时要做好JavaScript兼容性检查
<div class="show">const canvas = document.getElementById('canvas');
        if (canvas.getContext){
          const ctx = canvas.getContext('2d');
        }</div>

<h1 id="Canvas-2D渲染API"><a href="#Canvas-2D渲染API" class="headerlink" title="Canvas 2D渲染API"></a>Canvas 2D渲染API</h1><p>所有API都是基于canvas的2d渲染上下文对象，文中以context或ctx为对象名</p>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><ul>
<li><p><span class="strong">moveTo(x,y) 移动画笔到指定坐标</span><br>指定画笔最先开始绘制的点，此后Canvas的绘制方法都是基于上一次的路径终点进行的，仍可以使用moveTo(x,y)修改画笔的坐标到路径终点以外</p>
</li>
<li><p><span class="strong">context.beginPath() 创建一个新路径</span></p>
</li>
</ul>
<p>在同一个画布中绘制多个独立的图像，应当为每个图像创建不同的子路径，如:为不同的线段设置不同的颜色、线宽等样式，应当为每个线段创建独立的子路径，每个路径内部的样式、属性单独声明，否则后声明的样式会覆盖前面的样式，并且应当为每个独立的路径指定画笔初始点，执行绘制方法</p>
<div class="show">const canvasPath=document.getElementById("canvasPath");
   const ctxPath = canvasPath.getContext('2d');
        ctxPath.lineWidth=5;
        ctxPath.beginPath();
        ctxPath.strokeStyle="red";
        ctxPath.moveTo(150,50);
        ctxPath.lineTo(50,200);
        ctxPath.stroke();
        ctxPath.beginPath();
        ctxPath.strokeStyle="blue";
        ctxPath.moveTo(50,200);
        ctxPath.lineTo(250,200);
        ctxPath.stroke();
        ctxPath.beginPath();
        ctxPath.strokeStyle="yellow";
        ctxPath.moveTo(250,200);
        ctxPath.lineTo(150,50);
        ctxPath.stroke();
</div>
<canvas width="300" height="300" id="canvasPath" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas>
<script>
   const canvasPath=document.getElementById("canvasPath");
   const ctxPath = canvasPath.getContext('2d');
        ctxPath.lineWidth=5;
        ctxPath.beginPath();
        ctxPath.strokeStyle="red";
        ctxPath.moveTo(150,50);
        ctxPath.lineTo(50,200);
        ctxPath.stroke();
        ctxPath.beginPath();
        ctxPath.strokeStyle="blue";
        ctxPath.moveTo(50,200);
        ctxPath.lineTo(250,200);
        ctxPath.stroke();
        ctxPath.beginPath();
        ctxPath.strokeStyle="yellow";
        ctxPath.moveTo(250,200);
        ctxPath.lineTo(150,50);
        ctxPath.stroke();
</script>



<p>在使用循环定时器创建动画时，往往需要在每次定时器执行时创建一个新路径，避免上次的路径影响到本次路径的绘制</p>
<div class="show">const canvas=document.createElement("canvas");
        canvas.width=300;
        canvas.height=300;
        document.body.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        let cpx=10;
        let timer=setInterval(()=>{
        ctx.beginPath();//每次计时器开始时，开始新路径
        ctx.clearRect(0,0,300,300);//清空画布
        ctx.moveTo(50,50);
        ctx.quadraticCurveTo(cpx+=10,100,50,250);//动态绘制贝塞尔曲线
        ctx.stroke();
        if(cpx>=250){
            clearInterval(timer)
        }
        },50)</div>


<ul>
<li><span class="strong">context.closePath(); 闭合当前子路径</span><br>将画笔坐标移回到当前子路径起始点，该方法会尝试从当前点到起始点绘制一条直线，如果图形已经是封闭的或者只有一个点，该方法不会做任何操作，可用于闭合图形</li>
</ul>
<div class="show">const canvasLine=document.getElementById("canvasLine");
        const ctxLine = canvasLine.getContext('2d');
        ctxLine.lineWidth=3;
        ctxLine.moveTo(150,50);
        ctxLine.lineTo(100,150);
        ctxLine.lineTo(200,150);
        ctxLine.closePath();
        ctxLine.stroke();</div>

<h4 id="描边"><a href="#描边" class="headerlink" title="描边"></a>描边</h4><ul>
<li><span class="strong">context.stroke() 绘制当前路径</span></li>
<li><span class="strong">context.lineWidth=值; 修改描边线条的宽度</span></li>
<li><span class="strong">context.strokeStyle=”颜色/渐变对象/Pattern对象”; 设置描边样式</span></li>
</ul>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><ul>
<li><span class="strong">context.fill() 填充已闭合的路径</span></li>
<li><span class="strong">context.fillStyle=”颜色/渐变对象/Pattern对象”; 设置填充的样式</span></li>
</ul>
<h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><p><span class="strong">context.clip() 根据当前路径进行裁剪</span><br>沿着路径进行裁剪，裁剪路径外的图形将不再显示在Canvas中</p>
<h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h4><p><span class="strong">context.clearRect(x,y,width,height) 清除指定区域内的画布内容</span></p>
<div class="show">context.clearRect(0,0,canvas.width,canvas.height)//清空整个画布</div>

<h4 id="封装路径-Path2D对象"><a href="#封装路径-Path2D对象" class="headerlink" title="封装路径-Path2D对象"></a>封装路径-Path2D对象</h4><p> <span class="strong">let myPath2D=new Path2D();</span><br>返回一个Path2D对象，之后可以将路径添加到该对象中，并直接重用对象中的所有路径，stroke()、fill()、clip()均接收该对象作为参数</p>
<div class="show">const canvas=document.getElementById("canvas");
        const context = canvas.getContext('2d');
        let myDesign=new Path2D();
        //将路径封装到Path2D对象中而非context对象上
        myDesign.moveTo(50,50);
        myDesign.lineTo(100,50);
        myDesign.lineTo(100,100);
        myDesign.lineTo(50,100);
        myDesign.lineTo(50,50);
        //之后可以直接重用封装好的路径
        context.stroke(myDesign);//描边
        context.fill(myDesign);//填充
        context.clip(myDesign);//裁剪
</div>

<h4 id="位置判断"><a href="#位置判断" class="headerlink" title="位置判断"></a>位置判断</h4><ul>
<li><span class="strong">context.isPointInStroke(x, y) 返回boolean值，判断(x,y)点是否在当前路径上</span></li>
<li><span class="strong">context.isPointInStroke(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径上</span></li>
<li><span class="strong">context.isPointInPath(x, y) 返回boolean值，判断(x,y)点是否在当前路径内</span></li>
<li><span class="strong">context.isPointInPath(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径内</span></li>
</ul>
<h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><h4 id="实线线段"><a href="#实线线段" class="headerlink" title="实线线段"></a>实线线段</h4><h5 id="线段路径"><a href="#线段路径" class="headerlink" title="线段路径"></a>线段路径</h5><p><span class="strong">context.lineTo(x,y) 连接直线路径到指定坐标</span></p>
<h5 id="线段折点"><a href="#线段折点" class="headerlink" title="线段折点"></a>线段折点</h5><p><span class="strong">context.lineJoin=”miter/round/bevel”; </span></p>
<p>设置或返回两条线交汇时，线段折线处的样式</p>
<ul>
<li><strong>miter</strong> 尖锐折线(默认)</li>
<li><strong>round</strong> 圆角折线</li>
<li><strong>bevel</strong> 切角折线</li>
</ul>
<p><span class="strong">ctx.miterLimit = value; </span><br>设置或返回边角斜切面的限制长度(默认为10)，下图为miterLimit=2(左)以及miterLimit=10(右)的区别<br><canvas width="300" height="150" id="canvasLimit" style="display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>
   const canvasLimit=document.getElementById("canvasLimit");
        const ctxLimit = canvasLimit.getContext('2d');
        ctxLimit.lineWidth=20;
        ctxLimit.lineJoin="miter";
        ctxLimit.beginPath();
        ctxLimit.miterLimit=2;
        ctxLimit.moveTo(40,20);
        ctxLimit.lineTo(70,100);
        ctxLimit.lineTo(100,20);
        ctxLimit.stroke();
        ctxLimit.beginPath();
        ctxLimit.miterLimit=10;
        ctxLimit.moveTo(190,20);
        ctxLimit.lineTo(220,100);
        ctxLimit.lineTo(250,20);
        ctxLimit.stroke();
       
</script>

<h5 id="线段末端"><a href="#线段末端" class="headerlink" title="线段末端"></a>线段末端</h5><p><span class="strong">context.lineCap=”butt/round/square;”</span></p>
<p>设置或返回线段末端线帽的样式，”round” 和 “square” 值会使线条略微变长</p>
<ul>
<li><strong>butt</strong> 末端以方形结束(默认)</li>
<li><strong>round</strong>末端添加圆形线帽</li>
<li><strong>square</strong>末端添加一个宽度相同，长度为宽度一半的矩形线帽</li>
</ul>
<p><canvas width="400" height="150" id="canvasLine" style="display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>
   const canvasLine=document.getElementById("canvasLine");
        const ctxLine = canvasLine.getContext('2d');
        ctxLine.lineWidth=10;
        ctxLine.beginPath();
        ctxLine.lineCap="butt";
        ctxLine.lineJoin="miter";
        ctxLine.moveTo(90,50);
        ctxLine.lineTo(150,50);
        ctxLine.lineTo(190,10);
        ctxLine.lineTo(230,50);
        ctxLine.lineTo(290,50);
        ctxLine.stroke();
        ctxLine.beginPath();
        ctxLine.lineCap="round";
        ctxLine.lineJoin="round";
        ctxLine.moveTo(90,100);
        ctxLine.lineTo(150,100);
        ctxLine.lineTo(190,60);
        ctxLine.lineTo(230,100);
        ctxLine.lineTo(290,100);
        ctxLine.stroke();
        ctxLine.beginPath();
        ctxLine.lineCap="square";
        ctxLine.lineJoin="bevel";
        ctxLine.moveTo(90,140);
        ctxLine.lineTo(150,140);
        ctxLine.lineTo(190,100);
        ctxLine.lineTo(230,140);
        ctxLine.lineTo(290,140);
        ctxLine.stroke();
        ctxLine.beginPath();
        ctxLine.setLineDash([5,10]);
        ctxLine.lineWidth=1;
        ctxLine.strokeStyle="red";
        ctxLine.moveTo(90,0)
        ctxLine.lineTo(90,200)
        ctxLine.moveTo(290,0)
        ctxLine.lineTo(290,200)
        ctxLine.stroke();
</script>

<h4 id="虚线线段"><a href="#虚线线段" class="headerlink" title="虚线线段"></a>虚线线段</h4><ul>
<li><span class="strong">context.setLineDash([数组]);</span> 传递一个数组来指定虚线线段和间隙的交替长度，空数组将设置为实线</li>
<li><span class="strong">context.getLineDash();</span> 返回一个数组，获取当前线段的样式</li>
</ul>
<div class="show">context.setLineDash([2,10,5,10])
context.moveTo(0,0)
context.lineTo(100,200);
context.stroke();
</div>

<p><span class="strong">context.lineDashOffset = value;</span><br>设置虚线偏移值，可实现蚂蚁线效果</p>
<div class="show">const canvasDash=document.getElementById("canvasDash");
   const ctxDash = canvasDash.getContext('2d');
   let offset=0;
   ctxDash.lineWidth=5;
   ctxDash.setLineDash([30,20])
   ctxDash.setLineDash([30,20])
   ctxDash.moveTo(0,100)
   ctxDash.lineTo(300,100);
   function render(){
       offset++;
    if(offset>50){
        offset=0
    }
    ctxDash.clearRect(0,0,300,300)
    ctxDash.lineDashOffset=offset;
    ctxDash.stroke();
    requestAnimationFrame(render)
    }
    render();</div>
<canvas width="300" height="300" id="canvasDash" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas>
<script>
  const canvasDash=document.getElementById("canvasDash");
   const ctxDash = canvasDash.getContext('2d');
   let offset=0;
   ctxDash.lineWidth=5;
   ctxDash.setLineDash([30,20])
   ctxDash.setLineDash([30,20])
   ctxDash.moveTo(0,100)
   ctxDash.lineTo(300,100);
   function render(){
       offset++;
    if(offset>50){
        offset=0
    }
    ctxDash.clearRect(0,0,300,300)
    ctxDash.lineDashOffset=offset;
    ctxDash.stroke();
    requestAnimationFrame(render)
    }
    render();
</script>

<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><h5 id="矩形路径"><a href="#矩形路径" class="headerlink" title="矩形路径"></a>矩形路径</h5><p><span class="strong">context.rect(x,y,width,height) 创建矩形路径</span></p>
<ul>
<li>x, y为矩形坐标</li>
<li>width为矩形的宽度，正值矩形位于x坐标右侧，负值则位于左侧</li>
<li>height为矩形的高度，正值矩形位于y坐标下方，负值则在上方</li>
</ul>
<p>仅创建矩形路径，不会显示在画布中，可以使用stroke()方法或fill()方法进行描边绘制或者填充绘制</p>
<h5 id="描边矩形"><a href="#描边矩形" class="headerlink" title="描边矩形"></a>描边矩形</h5><p><span class="strong">context.strokeRect(x, y, width, height) 绘制描边矩形</span></p>
<p>创建矩形路径并描边，参数同上，相当于rect()方法和stroke()方法同时执行，可以使用<span class="tips">lineWidth</span>修改线宽，使用<span class="tips">strokeStyle</span>修改线条样式</p>
<h5 id="填充矩形"><a href="#填充矩形" class="headerlink" title="填充矩形"></a>填充矩形</h5><p><span class="strong">context.fillRect(x, y, width, height) 填充一个矩形</span></p>
<p>创建矩形路径并填充，参数同上，相当于rect()方法和fill()方法同时执行，可以使用<span class="tips">fillStyle</span>修改填充样式</p>
<h3 id="渐变对象"><a href="#渐变对象" class="headerlink" title="渐变对象"></a>渐变对象</h3><h4 id="添加渐变色"><a href="#添加渐变色" class="headerlink" title="添加渐变色"></a>添加渐变色</h4><p><span class="strong">渐变对象名.addColorStop(偏移量,”颜色”)</span></p>
<ul>
<li>对象名为以下三种渐变对象创建的实例</li>
<li>偏移量为0~1之间的值，代表渐变开始到渐变终止的位置，等同于CSS中的百分比位置</li>
<li>颜色取值同CSS</li>
</ul>
<h4 id="线性渐变对象"><a href="#线性渐变对象" class="headerlink" title="线性渐变对象"></a>线性渐变对象</h4><p><span class="strong">context.createLinearGradient(x1,y1,x2,y2)</span><br>在(x1,y1)到(x2,y2)矢量方向上创建径向渐变对象，并返回该对象</p>
<div class="show">const ctx = canvas.getContext('2d');
const gradient=ctx.createLinearGradient(0,0,600,400);
        gradient.addColorStop(0,"red");
        gradient.addColorStop(.3,"#df0");
        gradient.addColorStop(1,"blue");
        ctx.strokeStyle=gradient;</div>

<h4 id="径向渐变对象"><a href="#径向渐变对象" class="headerlink" title="径向渐变对象"></a>径向渐变对象</h4><p><span class="strong">context.createRadialGradient(x0, y0, r0, x1, y1, r1);</span><br>以(x0,y0)为圆心，r0为半径确定一圆，以(x1,y1)为圆心，r1为半径确定另一圆，</p>
<p>根据参数确定两个圆的坐标，绘制放射性渐变的方法</p>
<div class="show">const canvas1=document.getElementById("canvas1");
    const ctx1 = canvas1.getContext('2d');
    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);
    radial.addColorStop(0,"red");
    radial.addColorStop(.25,"yellow");
    radial.addColorStop(.5,"green");
    radial.addColorStop(.75,"#ff00fb");
    radial.addColorStop(1,"blue");
    ctx1.fillStyle=radial;
    ctx1.fillRect(0,0,300,300)</div>

<p><canvas width="300" height="300" id="canvas1" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;"></canvas></p>
<script>
    const canvas1=document.getElementById("canvas1");
    const ctx1 = canvas1.getContext('2d');
    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);
    radial.addColorStop(0,"red");
    radial.addColorStop(.25,"yellow");
    radial.addColorStop(.5,"green");
    radial.addColorStop(.75,"#ff00fb");
    radial.addColorStop(1,"blue");
    ctx1.fillStyle=radial;
    ctx1.fillRect(0,0,300,300)
     ctx1.moveTo(0,0);
    ctx1.lineTo(50,50);
    ctx1.stroke();
    ctx1.moveTo(250,250);
    ctx1.lineTo(300,300);
    ctx1.stroke();
</script>

<h4 id="锥形渐变对象"><a href="#锥形渐变对象" class="headerlink" title="锥形渐变对象"></a>锥形渐变对象</h4><p><span class="strong">context.createConicGradient(弧度值,x,y)</span><br>以(x,y)为锥形中心创建锥形渐变对象，弧度值角度为渐变开始的位置，角度通过<span class="tips">Math.PI*角度/180</span>运算为弧度值，值可正可负</p>
<div class="show">const canvas=document.getElementById("canvas");
   const ctx = canvas.getContext('2d');
    const cg=ctx.createConicGradient(Math.PI*45/180,150,150);
    cg.addColorStop(0,"red");
    cg.addColorStop(.25,"yellow");
    cg.addColorStop(.5,"green");
    cg.addColorStop(.75,"#ff00fb");
    cg.addColorStop(1,"blue");
    ctx.fillStyle=cg;
    ctx.fillRect(0,0,300,300);</div>

<p><canvas width="300" height="300" id="canvasCG" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>
   const canvasCG=document.getElementById("canvasCG");
   const ctxCG = canvasCG.getContext('2d');
   try{
     const cg=ctxCG.createConicGradient(Math.PI*45/180,150,150);
      cg.addColorStop(0,"red");
    cg.addColorStop(.25,"yellow");
    cg.addColorStop(.5,"green");
    cg.addColorStop(.75,"#ff00fb");
    cg.addColorStop(1,"blue");
    ctxCG.fillStyle=cg;
    ctxCG.fillRect(0,0,300,300);
   }
   catch(error){
    ctxCG.font=" 800 58px Serif"
    ctxCG.fillText("浏览器不支", 0, 100);
    ctxCG.fillText("持锥形渐变", 0, 150);
    console.warn("浏览器不支持锥形渐变createConicGradient()方法")}
   
</script>

<div class="broadcast color-red">
<div class="iconfont icon-gantanhao"></div>
锥形渐变兼容性远比线性渐变、径向渐变差，对浏览器内核版本要求较高，详见MDN文档：
<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient" style="display:block;word-break: break-all;">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient</a></div>


<h3 id="Pattern对象"><a href="#Pattern对象" class="headerlink" title="Pattern对象"></a>Pattern对象</h3><p>创建模板对象，</p>
<p><span class="strong">createPattern(image,重复模式)</span><br>image为图像源，可以是<span class="tips">&lt;img&gt;图像</span>、<span class="tips">&lt;video&gt;视频</span>、<span class="tips">&lt;canvas&gt;另外一个canvas对象</span>、<span class="tips">canvas的2d上下文对象(CanvasRenderingContext2D)</span>等</p>
<p>图像的重复模式可以为<span class="tips">repeat</span>、<span class="tips">repeat-x</span>、<span class="tips">repeat-y</span>、<span class="tips">no-repeat</span>，用法同CSS</p>
<div class="show"> const canvas=document.createElement("canvas");
        canvas.width=1000;
        canvas.height=1000;
        document.body.appendChild(canvas);
        const ctx=canvas.getContext("2d");
        let img=new Image();
        img.src="./dog.jpg";
        img.onload=function(){
            const p=ctx.createPattern(img,'repeat-y')
            ctx.fillStyle=p;
            ctx.fillRect(0,0,1000,1000)
        }</div>

<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><h4 id="圆与圆弧线绘制"><a href="#圆与圆弧线绘制" class="headerlink" title="圆与圆弧线绘制"></a>圆与圆弧线绘制</h4><p><span class="strong">context.arc(x,y,r,startAngle, endAngle, anticlockwise)</span></p>
<ul>
<li>x,y为圆弧中心</li>
<li>r为圆弧半径</li>
<li>startAngle, endAngle为圆弧起始点和终点角度，弧度表示，角度为css坐标x轴与y轴夹角</li>
<li>anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制<div class="show">const canvasArc=document.getElementById("canvasArc");
 const ctxArc = canvasArc.getContext('2d');
 ctxArc.lineWidth=5;
 ctxArc.arc(150,150,100,0,90/180*Math.PI,true);
 ctxArc.stroke();</div></li>
</ul>
<p><canvas width="300" height="300" id="canvasArc" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>
   const canvasArc=document.getElementById("canvasArc");
   const ctxArc = canvasArc.getContext('2d');
   ctxArc.lineWidth=5;
   ctxArc.arc(150,150,100,0,90/180*Math.PI,true);
   ctxArc.stroke();
</script>

<h4 id="圆弧线绘制方法2"><a href="#圆弧线绘制方法2" class="headerlink" title="圆弧线绘制方法2"></a>圆弧线绘制方法2</h4><p><span class="strong">context.arcTo(x1, y1, x2, y2, radius)</span></p>
<ul>
<li>x1, y1为第一个控制点坐标</li>
<li>x2, y2为第二个控制点坐标</li>
<li>radius 为圆弧半径</li>
</ul>
<p>将当前路径终点与控制点 1 连接的直线，和控制点 1 与控制点 2 连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径</p>
<div class="show"> const canvasArcTo=document.getElementById("canvasArcTo");
   const ctxArcTo = canvasArcTo.getContext('2d');
    ctxArcTo.beginPath();
    ctxArcTo.moveTo(100,50)
    ctxArcTo.strokeStyle="#000";
    ctxArcTo.lineWidth=5;
    ctxArcTo.arcTo(250,50,250,250,150);
    ctxArcTo.stroke()
    ctxArcTo.beginPath();
    ctxArcTo.moveTo(50,50)
    ctxArcTo.setLineDash([5,10]);
    ctxArcTo.lineWidth=5;
    ctxArcTo.strokeStyle="blue";
    ctxArcTo.lineTo(250,50)
    ctxArcTo.lineTo(250,250)
    ctxArcTo.stroke()</div>

<p><canvas width="300" height="300" id="canvasArcTo" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>
   const canvasArcTo=document.getElementById("canvasArcTo");
   const ctxArcTo = canvasArcTo.getContext('2d');
    ctxArcTo.beginPath();
    ctxArcTo.moveTo(100,50)
    ctxArcTo.strokeStyle="#000";
    ctxArcTo.lineWidth=5;
    ctxArcTo.arcTo(250,50,250,250,150);
    ctxArcTo.stroke()
    ctxArcTo.beginPath();
    ctxArcTo.moveTo(50,50)
    ctxArcTo.setLineDash([5,10]);
    ctxArcTo.lineWidth=5;
    ctxArcTo.strokeStyle="blue";
    ctxArcTo.lineTo(250,50)
    ctxArcTo.lineTo(250,250)
    ctxArcTo.stroke()
</script>

<h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><p><span class="strong">context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);</span></p>
<ul>
<li>x,y为椭圆圆心的坐标</li>
<li>radiusX 为椭圆长轴的半径，radiusY 为椭圆短轴半径</li>
<li>rotation 为椭圆的旋转角度，以弧度表示</li>
<li>startAngle, endAngle为椭圆圆弧起始点和终点角度，弧度表示</li>
<li>anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制</li>
</ul>
<div class="show"> const canvasEllipse=document.getElementById("canvasEllipse");
   const ctxEll = canvasEllipse.getContext('2d');
   ctxEll.lineWidth=5;
   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)
   ctxEll.stroke();</div>

<p><canvas width="300" height="300" id="canvasEllipse" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>
   const canvasEllipse=document.getElementById("canvasEllipse");
   const ctxEll = canvasEllipse.getContext('2d');
   ctxEll.lineWidth=5;
   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)
   ctxEll.stroke();
</script>

<h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><h5 id="二阶贝塞尔曲线"><a href="#二阶贝塞尔曲线" class="headerlink" title="二阶贝塞尔曲线"></a>二阶贝塞尔曲线</h5><p><span class="strong"> context.quadraticCurveTo(cpx, cpy, x, y)</span></p>
<ul>
<li>cpx, cpy为控制点的坐标</li>
<li>x, y为曲线终点坐标</li>
<li>起始点坐标为当前路径所在终点，或者可以使用moveTo()控制</li>
</ul>
<div class="show"> const canvasBC=document.getElementById("canvasBezierCurve");
   const ctxBC = canvasBC.getContext('2d');
   ctxBC.lineWidth=2;
   ctxBC.moveTo(50,50);
        let cpx=50;
        let timerBC=setInterval(()=>{
        //想绘制为动画还需再添加beginPath()和clearRect()方法
        ctxBC.moveTo(50,50)
        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)
        ctxBC.stroke()
        if(cpx>=350){
            clearInterval(timerBC)
        }
        },100)</div>
<canvas width="300" height="300" id="canvasBezierCurve" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas>
<script>
   const canvasBC=document.getElementById("canvasBezierCurve");
   const ctxBC = canvasBC.getContext('2d');
   ctxBC.lineWidth=2;
   ctxBC.moveTo(50,50);
        let cpx=50;
        let timerBC=setInterval(()=>{
        ctxBC.moveTo(50,50)
        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)
        ctxBC.stroke()
        if(cpx>=350){
            clearInterval(timerBC)
        }
        },100)
</script>


<h5 id="三阶贝塞尔曲线"><a href="#三阶贝塞尔曲线" class="headerlink" title="三阶贝塞尔曲线"></a>三阶贝塞尔曲线</h5><p><span class="strong"> context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</span></p>
<ul>
<li>cp1x, cp1y为第一个控制点的坐标</li>
<li>cp2x, cp2y为第二个控制点的坐标</li>
<li>x, y为曲线终点坐标</li>
<li>起始点坐标为当前路径所在终点，或者可以使用moveTo()控制</li>
</ul>
<div class="show"> const canvasBC2=document.getElementById("canvasBezierCurve2");
   const ctxBC2 = canvasBC2.getContext('2d');
   ctxBC2.lineWidth=2;
   ctxBC2.moveTo(50,50);
    ctxBC2.bezierCurveTo(300, 50, 50, 300,250, 290);
    ctx2BC.stroke()</div>


<p><canvas width="300" height="300" id="canvasBezierCurve2" style="display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas></p>
<script>
   const canvasBC2=document.getElementById("canvasBezierCurve2");
   const ctxBC2 = canvasBC2.getContext('2d');
   ctxBC2.lineWidth=2;
   ctxBC2.moveTo(50,50);
   ctxBC2.bezierCurveTo(250, 50, 50, 250,250, 290);
   ctxBC2.stroke()  
</script>




<h3 id="文字绘制"><a href="#文字绘制" class="headerlink" title="文字绘制"></a>文字绘制</h3><h4 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h4><p><span class="strong">context.fillText(text, x, y, [maxWidth]); 对文字进行填充</span></p>
<p><span class="strong">context.strokeText(text, x, y, [maxWidth]); 对文字进行描边</span></p>
<ul>
<li>text指定文本内容</li>
<li>x, y为文本左下角在画布中开始绘制的坐标(因此坐标不应该为0,0)</li>
<li>maxWidth(可选)，指定绘制的最大宽度，会对文本进行水平缩放</li>
</ul>
<h4 id="获取文本宽度"><a href="#获取文本宽度" class="headerlink" title="获取文本宽度"></a>获取文本宽度</h4><p><span class="strong">context.measureText(“文本”);</span></p>
<p>返回文本的TextMetrics 对象，一般会从该对象中获得文本宽度，以判断文字是否需要在Canva中进行换行</p>
<div class="show">&lt;canvas width="300" height="700" id="canvasText">&lt;/canvas>
&lt;script>
const canvasText=document.getElementById("canvasText");
const ctxText = canvasText.getContext('2d');
let string="微风需要竹林，溪流需要蜻蜓，乡愁般的离开，需要片片浮萍，青春属于表白，阳光属于窗台，而我想我属于一个，拥有你的未来";
ctxText.font=" 30px Serif";
let rowNum=1;//行号
let lastIndex=0;//上一行文字的截取索引位置
let rowWidth=0;//每一行的文本长度
    for(let i=0;i&lt;string.length;i++){
    rowWidth+=ctxText.measureText(string[i]).width;
        if(rowWidth>canvasText.width){
            ctxText.fillText(string.substring(lastIndex,i),0,50*rowNum)
            lastIndex=i--;//substring()截左不截右
            rowNum++;
            rowWidth=0;
        }
        if(i==string.length-1){
            ctxText.fillText(string.substring(lastIndex,i+1),0,50*rowNum)
        }}
&lt;/script>
</div>

<h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><span class="strong">context.font = “value”;</span><br>指定文本属性，默认为 10px sans-serif，value为CSS中的font简写属性，可以按顺序设置<span class="tips">[font-style]&emsp; [font-variant]&emsp;[font-weight]&emsp; font-size[/line-height] &emsp;font-family</span></p>
<ul>
<li>必须包含font-size和font-family</li>
<li>font-style：字体样式，常用取值normal(正常)、italic(斜体)、oblique(倾斜)</li>
<li>font-variant：设置小型大写字母，将字母写为大写，但除首字母外的文本将缩小字号，默认为normal，可以修改为small-caps(小型大写字母)</li>
<li>font-weight：设置文本的粗细，常用值：normal(正常)，bold(粗体)，bolder(再加粗)，lighter(细体)，以及100-900的整百数值</li>
<li>font-size必须，line-height为非必须，有line-height时要写为如：16px/20px 的形式</li>
<li>font-family：字体族，5个通用字体：Serif(衬线字体)、Sans-serif(无衬线字体)、Monospace(等宽字体)、Cursive(草书字体)、Fantasy(幻想字体)</li>
</ul>
<div class="show">const canvasText=document.getElementById("canvasText");
const ctxText = canvasText.getContext('2d');
ctxText.font=" 60px Serif";
ctxText.fillText("hello world",50,60) //对文字进行填充
ctxText.strokeText("hello world",50,180)//对文字进行描边</div>
<canvas width="400" height="200" id="canvasText" style="display:block;width:400px;height:200px;margin:0 auto;border:1px dashed #000;background:#fff;"></canvas>
    <script>
       const canvasText=document.getElementById("canvasText");
       const ctxText = canvasText.getContext('2d');
       ctxText.font=" 60px Serif";
       ctxText.fillText("hello world",50,60)
       ctxText.strokeText("hello world",50,180)
    </script>

<h4 id="文本方向"><a href="#文本方向" class="headerlink" title="文本方向"></a>文本方向</h4><p><span class="strong">context.direction =”ltr/rtl/inherit”; 设置当前文本方向</span> </p>
<ul>
<li>ltr ,从左往右</li>
<li>rtl ,从右往左(部分国家读写习惯)</li>
<li>inherit(默认)，从父元素继承</li>
</ul>
<p><span class="strong">context.textAlign = “left/right/center/start/end”; 定义文本水平方向上的对齐方式</span> </p>
<ul>
<li>center以绘制文本时的x坐标为基准，一半位于x左边，一半位于右边</li>
<li>start与end属性以direction定义的文本方向为基准</li>
</ul>
<p><span class="strong">context.textBaseline = “tophanging/middle/alphabetic/ideographic/bottom”; 定义文本垂直方向上的对齐方式</span></p>
<ul>
<li>与CSS相同，以文本基线为基准，详见MDN文档</li>
</ul>
<h3 id="图像与视频绘制"><a href="#图像与视频绘制" class="headerlink" title="图像与视频绘制"></a>图像与视频绘制</h3><ul>
<li><p><span class="strong">drawImage(image, dx, dy)</span></p>
</li>
<li><p><span class="strong">drawImage(image, dx, dy, dWidth, dHeight)  </span></p>
</li>
<li><p><span class="strong">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) </span></p>
<ul>
<li>image为图像源，可以是图片、SVG矢量图、视频、canvas等</li>
<li>dx, dy为图片左上角在画布中开始绘制的位置</li>
<li>dWidth, dHeight为图像在画布上绘制出来的尺寸，会对其进行缩 放、拉抻</li>
<li>sx, sy为裁剪时，距离图像左上角的开始裁剪的位置</li>
<li>sWidth, sHeight为裁剪的宽度和高度，省略该参数则默认裁剪到&gt;右下角，sHeight为负值将从sy反向裁剪</li>
</ul>
</li>
</ul>
<div class="show">const canvasImg=document.getElementById("canvasImg");
       const ctxImg = canvasImg.getContext('2d');
       let img=new Image();
       img.src="./dog.jpg";
       img.onload=function(){
        //仅指定图片在画布中的位置
        ctxImg.drawImage(img, 50, 50);
        //指定图片在画布中的位置及缩放尺寸
        ctxImg.drawImage(img, 50, 50,300,200);
        //裁剪图片，并指定图片在画布中的位置及缩放尺寸
        ctxImg.drawImage(img, 50, 50,300,200,0,0,300,300);
       }</div>

<h3 id="移动、旋转、缩放"><a href="#移动、旋转、缩放" class="headerlink" title="移动、旋转、缩放"></a>移动、旋转、缩放</h3><p><span class="strong">context.translate(x, y); 进行水平和垂直位移</span><br>  修改坐标系的原点，默认原点位于(0,0)，由此移动图像在Canvas中的相对位置，可以在上一次translate(x, y)的基础上再次移动坐标系，多次修改坐标原点</p>
<p><span class="strong">context.rotate(弧度值); 进行旋转变换</span><br>  修改坐标系的旋转角度，参数为弧度值</p>
<p><span class="strong">context.scale(x, y); 进行水平和垂直缩放</span><br>  对坐标系x轴和y轴进行伸缩，0-1进行缩小，大于1进行放大，负值则进行水平/垂直翻转后进行缩放</p>
<div class="show">const canvas=document.createElement('canvas');
        canvas.width=600;
        canvas.height=600;
        document.body.append(canvas);
        const ctx=canvas.getContext('2d');
        ctx.translate(50,50);
        ctx.fillRect(0,0,50,100)
        ctx.translate(100,100);
        ctx.scale(1,-2)
        ctx.rotate(180*Math.PI/180)
        ctx.fillRect(0,0,50,100)</div>

<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>类似于CSS的阴影效果，注意，阴影应当设置在图形绘画之前，如果设置阴影效果之前已经有图形和文字存在，则阴影不会对这些图形和文字生效</p>
<ul>
<li><span class="strong">context.shadowOffsetX = value; 阴影的水平偏移距离</span></li>
<li><span class="strong">context.shadowOffsetY = value; 阴影的垂直偏移距离</span></li>
<li><span class="strong">context.shadowBlur = value;  阴影的模糊值</span></li>
<li><span class="strong">context.shadowColor = “颜色”; 阴影颜色</span><div class="show">const ctx=canvas.getContext('2d');
ctx.shadowOffsetX=16;
ctx.shadowOffsetY=8;
ctx.shadowBlur=5;
ctx.shadowColor="#575656";
ctx.moveTo(50,50);
ctx.bezierCurveTo(300, 50, 50, 300,250, 290);
ctx.stroke()</div></li>
</ul>
<h3 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h3><p>类似于CSS3中的效果<br><span class="strong">context.filter = “一个或多个值”</span></p>
<ul>
<li>blur(值px)：高斯模糊</li>
<li>brightness(百分比)：亮度</li>
<li>contrast(百分比)：对比度</li>
<li>grayscale(百分比)：灰度滤镜</li>
<li>hue-rotate(角度deg)：对图像进行色彩旋转的处理</li>
<li>invert(百分比)：反色(呈现出照片底片的效果)</li>
<li>opacity(百分比)：不透明度</li>
<li>sepia(百分比)：褐色处理(怀旧风格)</li>
<li>drop-shadow(x, y, 模糊值, 阴影扩张/收缩, 阴影色)：阴影效果</li>
</ul>
<h3 id="图像合成模式"><a href="#图像合成模式" class="headerlink" title="图像合成模式"></a>图像合成模式</h3><p><span class="strong">context.globalCompositeOperation = “type”;</span></p>
<ul>
<li><span class="strong">source-over</span> 图像叠加显示(默认)</li>
<li><span class="strong">source-in</span> 只显示图像重叠部分</li>
<li><span class="strong">source-out</span> 只显示图像不重叠的部分</li>
<li><span class="strong">source-atop</span> 后叠加的图像只显示与原图像重叠的部分</li>
<li><span class="strong">destination-over</span> 将后叠加的图像置于原图像之下</li>
<li><span class="strong">destination-in</span> 只显示图像重叠部分，并且只显示原图像部分</li>
<li><span class="strong">destination-out</span> 将原图像抠去与后图像叠加部分显示，并且后图像不显示</li>
<li><span class="strong">destination-atop</span>将后图像重叠部分替换为原图像并显示</li>
<li><span class="strong">lighter</span>两图像重叠部分进行颜色相加</li>
<li><span class="strong">copy</span>去除原图像，只显示新图像</li>
<li><span class="strong">xor</span>重叠部分透明，其他正常显示</li>
<li><span class="strong">multiply</span>将重叠部分的顶层像素与底层像素相乘，重叠部分显示为暗黑色</li>
<li><span class="strong">screen</span>将重叠部分像素倒转，相乘，再倒转，重叠部分显示为亮色</li>
<li><span class="strong">overlay</span>multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮</li>
<li><span class="strong">darken</span>保留两个图层中最暗的像素</li>
<li><span class="strong">lighten</span>保留两个图层中最亮的像素</li>
<li><span class="strong">color-dodge</span>将底层除以顶层的反置</li>
<li><span class="strong">color-burn</span>将反置的底层除以顶层，然后将结果反过来</li>
<li><span class="strong">hard-light</span>类似于叠加，上下图层互换</li>
<li><span class="strong">soft-light</span>用顶层减去底层或者相反来得到一个正值</li>
<li><span class="strong">difference</span>一个柔和版本的强光(hard-light),纯黑或纯白不会导致纯黑或纯白</li>
<li><span class="strong">exclusion</span>和 difference 相似，但对比度较低</li>
<li><span class="strong">hue</span>保留底层的亮度和色度，同时采用顶层的色调</li>
<li><span class="strong">saturation</span>保留底层的亮度和色调，同时采用顶层的色度</li>
<li><span class="strong">color</span>保留了底层的亮度，同时采用了顶层的色调和色度</li>
<li><span class="strong">luminosity</span>保持底层的色调和色度，同时采用顶层的亮度</li>
</ul>
<h3 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h3><ul>
<li><span class="strong">context.save() 将当前状态推入栈中</span></li>
<li><span class="strong">context.restore() 读取栈顶的状态</span></li>
</ul>
<p>将保存当前的裁剪区域、虚线列表、以及各属性值压入栈中，之后可以直接依次读取栈顶存储的状态并直接绘制，会保存的属性值包括：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled</p>
<div class="show">const canvas=document.getElementById("canvas");
const ctx=canvas.getContext('2d');
ctx.fillStyle="red";
ctx.save(); //依次压栈
ctx.fillStyle="yellow";
ctx.save(); //依次压栈
ctx.fillStyle="green";
ctx.restore(); //弹栈
ctx.fillRect(50,50,100,100);//将绘制为黄色而非绿色
</div>

<h3 id="像素操作-ImageData对象"><a href="#像素操作-ImageData对象" class="headerlink" title="像素操作-ImageData对象"></a>像素操作-ImageData对象</h3><p>ImageData对象保存了Canvas图像的底层实际像素，可以直接进行读取和写入。其中，像素被保存在Uint8ClampedArray类型的一维数组中，每个数组元素为0-255之间的数据，每4个数组元素为一组代表了一个像素点的RGBA值。如：索引为0-3的数组元素，存储了第一个像素点的红、绿、蓝、不透明度对应的0-255十进制数值，以此类推</p>
<p><span class="strong">context.getImageData(x,y,width,height)</span><br>返回ImageData对象，获取(x,y)坐标开始，width为宽，height为高的矩形区域中的像素。返回的对象中包含width、height、data数组(Uint8ClampedArray类型)三个属性</p>
<p> <span class="strong">context.putImageData(imagedata对象, dx偏移, dy偏移)</span></p>
<p>getImageData()方法可以从(x,y)坐标开始获取一个矩形区域内的像素数据，将该部分数据修改后，可以通过putImageData()方法将数据绘制到canvas中。其中，dx，dy为在(x,y)的基础上进行的偏移量，之前获取到的(x,y)到(x+width,y+height)矩形区域内的图形，修改像素数据后将被绘制到(x+dx,y+dy)开始的同大小矩形区域内</p>
<p> <span class="strong">context.putImageData(imagedata对象,dx偏移, dy偏移, dirtyX, dirtyY,dirtyWidth, dirtyHeight)</span></p>
<ul>
<li>dx偏移, dy偏移作用同上</li>
<li>(dirtyX, dirtyY)为进行修改像素操作开始的位置坐标</li>
<li>dirtyWidth, dirtyHeight为将进行修改像素操作的矩形区域的长宽</li>
</ul>
<div class="show">&lt;canvas width="300" height="300" id="canvas">&lt;/canvas>
    &lt;script>
       const canvas=document.getElementById("canvas");
       const ctx = canvas.getContext('2d');
       let img=new Image();
       img.src="./dog.jpg";
       img.onload=function(){
        ctx.drawImage(img,0,0,300,300);
        let imageDate=ctx.getImageData(0, 0, 100, 100);
        //每4个索引为一组，代表一个像素的RGBA值
        for(let i=0;i&lt;imageDate.data.length;i+=4){
            //计算每个像素点的灰度值
            let avg=(imageDate.data[i]+imageDate.data[i+1]+imageDate.data[i+2])/3;
            imageDate.data[i]=avg; //修改像素点的R
            imageDate.data[i+1]=avg;//修改像素点的G
            imageDate.data[i+2]=avg;//修改像素点的B
            imageDate.data[i+3]=255;//修改像素点不透明度A为1
        }
        // 将(10,10)开始，长200，宽200的区域内的像素调为灰色
        ctxImg.putImageData(imageDate,0,0,10,10,200,200)
       }
    &lt;/script>
</div>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>使用图像合成模式的<span class="strong">“destination-out”</span>属性值制作刮刮卡</p>
<div class="ticketContainer" style="position:relative;width:100%;">
<div class="scratchTicket" style="width: 300px;height: 150px;font-size: 24px;color: red;text-align: center;line-height: 150px;margin:0 auto;letter-spacing: 8px;background-color: #ffffff;pointer-events: none;user-select: none;">再刮一次</div>
<canvas width="300" height="150" id="canvasTicket" style="position:absolute;top:0;left:50%;transform:translateX(-50%);"></canvas>
<div class="tryAgain" onclick="tryAgain()" style="width: 100px;height: 35px;line-height: 35px;text-align: center;background-color: aqua;border-radius: 5px;cursor: pointer;user-select: none;margin:10px auto;">再刮一次</div>
</div>
<script>
       const ticketContainer=document.querySelector(".ticketContainer");
       const canvasTicket=document.getElementById("canvasTicket");
       const contextTicket=canvasTicket.getContext('2d');
       const p=contextTicket.createPattern(cover(),"repeat");
        contextTicket.fillStyle=p;
        tryAgain();
        function tryAgain(){
            document.querySelector(".scratchTicket").innerText=Math.random()>.6?"恭喜中奖":"再刮一次";
            contextTicket.clearRect(0,0,300,150);
            contextTicket.globalCompositeOperation="copy";
            contextTicket.fillRect(0,0,300,150);
        }
        function cover(){
            const canvasCover=document.createElement('canvas');
            const coverCtx=canvasCover.getContext('2d');
            canvasCover.width=60;
            canvasCover.height=50;
            coverCtx.fillStyle="#6f6d6d"
            coverCtx.fillRect(0,0,60,50)
            coverCtx.rotate(45*Math.PI/180);
            coverCtx.font="300 15px Serif";
            coverCtx.fillStyle="#333333"
            coverCtx.fillText("发大财",20,0)
            return canvasCover;
        }
        let allowedDraw=false;
        canvasTicket.addEventListener('mousedown',function(){
            allowedDraw=true;
        }) 
        canvasTicket.addEventListener('mouseup',function(){
            allowedDraw=false;
        })
        canvasTicket.addEventListener('mousemove',function(event){
            var event = event || window.event;
            if(allowedDraw){
             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器
              var  x = event.offsetX;
              var y = event.offsetY;
            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器
              var x = event.layerX;
              var y = event.layerY;
            }
            contextTicket.globalCompositeOperation="destination-out";
            contextTicket.beginPath();
            contextTicket.arc(x,y,20,0,2*Math.PI);
            contextTicket.fill();
            }})
            canvasTicket.addEventListener('touchstart',function(){
            let canvasTicketRect=canvasTicket.getBoundingClientRect();
            canvasTicket.addEventListener('touchmove',function(e){
                e.preventDefault();
            var x=e.targetTouches[0].pageX-canvasTicketRect.left;
            var y=e.targetTouches[0].pageY-canvasTicketRect.top;
            contextTicket.globalCompositeOperation="destination-out";
            contextTicket.beginPath();
            contextTicket.arc(x,y,20,0,2*Math.PI);
            contextTicket.fill();
            },{passive:false})    
        },{passive:false})
    </script>
<div class="show">&lt;div class="card">&lt;/div>//底层卡片，显示是否中奖
&lt;canvas width="300" height="150" id="canvas1">&lt;/canvas>//刮刮乐灰色图层，监听刮开区域
&lt;div class="tryAgain" onclick="tryAgain()">再刮一次&lt;/div>//重新开始按钮&lt;/div>
&lt;script>
const canvas=document.getElementById("canvas1");
       const context=canvas.getContext('2d');
       const p=context.createPattern(cover(),"repeat");//创建模板对象，设置图像重复模式
        context.fillStyle=p;
        tryAgain();
        function tryAgain(){
            document.querySelector(".card").innerText=Math.random()>.8?"恭喜中奖":"再刮一次";
            context.clearRect(0,0,300,150);
            context.globalCompositeOperation="copy";
            context.fillRect(0,0,300,150);
        }
        /*
        *制作刮刮乐封面，返回canvas DOM
        */
        function cover(){
            const canvasCover=document.createElement('canvas');
            const coverCtx=canvasCover.getContext('2d');
            canvasCover.width=60;
            canvasCover.height=50;
            coverCtx.fillStyle="#6f6d6d"
            coverCtx.fillRect(0,0,60,50)
            coverCtx.rotate(45*Math.PI/180);
            coverCtx.font="300 15px Serif";
            coverCtx.fillStyle="#333333"
            coverCtx.fillText("发大财",20,0)
            return canvasCover;
        }
        let allowedDraw=false;
        canvas.addEventListener('mousedown',function(){
            allowedDraw=true;
        }) 
        canvas.addEventListener('mouseup',function(){
            allowedDraw=false;
        })
        canvas.addEventListener('mousemove',function(event){
            var event = event || window.event;
            if(allowedDraw){
             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器
              var  x = event.offsetX;
              var y = event.offsetY;
            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器
              var x = event.layerX;
              var y = event.layerY;
            }
            context.globalCompositeOperation="destination-out";
            context.beginPath();
            context.arc(x,y,20,0,2*Math.PI);
            context.fill();
            }})
            //移动端
            canvas.addEventListener('touchstart',function(){
            let canvasRect=canvas.getBoundingClientRect();
            canvas.addEventListener('touchmove',function(e){
                e.preventDefault();
            var x=e.targetTouches[0].pageX-canvasRect.left;
            var y=e.targetTouches[0].pageY-canvasRect.top;
            context.globalCompositeOperation="destination-out";
            context.beginPath();
            context.arc(x,y,20,0,2*Math.PI);
            context.fill();
            },{passive:false})    
        },{passive:false})
    </script></div>

        </div>
    </div>
    <div class="post-nav">
        
            <div class="post-prev ">
                <a href="/blog/2023/05/19/SVG%E7%9F%A2%E9%87%8F%E5%9B%BE/">上一篇：SVG矢量图</a>
            </div>
            
            
                <div class="post-next">
                    <a href="/blog/2022/09/18/History-of-browser/">下一篇：Web的发展旅程 </a>
                </div>
                 
    </div>
    <div class="container">
        <!--设计来源于B站-季夏小贞-->
        <div class="bigHead"></div>
        <div class="ears"></div>
        <div class="body"></div>
        <div class="paws-front"></div>
        <div class="paws-back"></div>
        <div class="details"></div>
        <div class="tail"></div>
        <div class="sleep">
          <span class="s1">z</span>
          <span class="s2">z</span>
          <span class="s3">z</span>
          <span class="s4">z</span>
          <span class="s5">z</span>
        </div>
    </div>
</div>
<div class="right-menu">
    <a class="iconfont backTop" href="javascript:">&#xe655;</a>
    <div class="husky"></div>
  </div>
</div>

<script src="/blog/js/jquery.min.js"></script>
<script src="/blog/js/jquery.bumpytext.js"></script>
<script src="/blog/js/index.js"></script>
<script src="/blog/js/highlight.min.js"></script>
<script src="/blog/js/highlightjs-line-numbers.min.js"></script>
<script src="/blog/js/article.js"></script>

</body></html>