[{"title":"C语言","url":"/blog/2023/10/13/C语言回顾/","content":"\n\n\n### 介绍\n#### 发展历史\n<div class=\"contentFolded\">在计算机诞生初期，人们使用<span class=\"strong\">机器语言</span>来编写程序，机器语言的指令由操作码和操作数组成，均使用二进制代码表示，而二进制则通过在纸带上打孔来表示0或1，程序员将编写的机器语言指令打在纸带上并通过纸带机输入计算机中，以此进行运算。机器语言虽然能被计算机直接执行，但对人类来说难以阅读和记忆，不便编写。\n\n为了简化机器语言的编写，1950年代中期，<span class=\"strong\">汇编语言</span>应运而生。它使用助记符（mnemonic）来表示机器指令，极大地提高了程序员的工作效率。即便如此，书写和调试一个程序也需要用很长时间，并且需要程序员详细了解编写代码需要的指令、寄存器和CPU知识。\n\n为了解决这些问题，IBM公司的一个研究小组开始着手研究一门能高效运行且简单易用的编程语言。1956年，IBM公司的John Backus带领他的团队开发出了世界上第一个<span class=\"strong\">高级语言</span><span class=\"tips\">FORTRAN</span>(FORmula TRANslation，意为公式翻译)，在科学和工程计算领域取得了很大成功，但该语言是专门为IBM 704计算机设计的，只能在特定型号的机器上工作。\n\n为了解决这一问题，GAMM(德国应用数学和力学学会)、IBM、Datatron等公司要求ACM评估一种能脱离机器型号限定的“通用编程语言”。1958年5月，在美国计算机科学家Alan Jay Perlis的领导下，ACM、GAMM等代表在苏黎世会议上成立了IAL算法语言委员会，制定了国际算法语言(International Algorithmic Language,IAL)的定义并发布了IAL58语言。随后，ACM推崇IAL作为编程语言的标准，该算法语言由各种不同的“关键字”和“表达式”按照一定的语法规则组成，脱离了指令系统成为更接近人类的语言系统，编写者不必懂得完整的计算机的内部结构和工作原理也可以很好编写程序。\n\n1959年，IAL被重新命名为ALGOL(算法语言)。\n\n1960年，ALGOL算法语言委员会发布了<span class=\"tips\">ALGOL 60</span>，里程碑式地引入了<span class=\"strong\">递归</span>、<span class=\"strong\">布尔类型</span>、<span class=\"strong\">块结构</span>等概念，ALGOL 60也成为了后来所有计算机语言语法的鼻祖，Alan Jay Perlis也因此成为了世界首届图灵奖的获得者，以表彰其在 Algol 58 和 Algol 60 的形成和改进过程中的核心和关键作用。但ALGOL 60最大的缺点就是缺乏标准的输入输出能力，ALGOL 60编写的程序无法兼容不同的计算机外部设备，因此ALGOL 60迎来了进一步的迭代。\n\n1963年，剑桥大学基于ALGOL 60发布了<span class=\"tips\">CPL</span>（Combined Programming Langurage）语言，该语言旨在用于工业控制、数据处理等更为广泛的领域，因此规模宏大而复杂，编译器的编写进度十分缓慢，该语言并未大规模流行。\n\n1967年，英国剑桥大学的Matin Richards对CPL语言做了简化，推出了<span class=\"tips\">BCPL</span>(the Basic Combined Programming Language)语言，该语言是最早使用库函数封装基本输入输出的语言之一，主要用于编写系统和编译器，但BCPL对字符串的支持很差，并且内存管理很糟糕。\n\n1969年，美国贝尔实验室的Kenneth Lane Thompson对BCPL语言做了改进和优化，由此衍生出了<span class=\"tips\">B语言</span>，并用于书写<span class=\"strong\">UNIX</span>系统，该语言的名字取自BCPL中的第一个字母，但此时的B语言过于简单，功能有限。\n\n1972年，贝尔实验室的Dennis MacAlistair Ritchie在B语言的基础上设计出了<span class=\"tips\">C语言</span>(取BCPL的第二个字母作为该语言的名字)，C语言保留了BCPL和B语言的优点，简练而接近硬件，又克服了它们无数据类型等缺点。1973年初， C语言的主体完成，汤普森和里奇使用C语言重写了UNIX操作系统，极大地提升了UNIX操作系统的可移植性，而C语言随着UNIX的广泛使用得到了迅速推广，成为了应用最广泛的计算机语言之一。\n\n1983年，美国国家标准化协会(ANSI)制定了C语言标准——<span class=\"strong\">ANSI C</span>，1987年，ANSI又公布了新的标准<span class=\"strong\">87 ANSI C</span>，该标准于1990年被国际标准化组织(Internation Standard Organization)接受成为C语言国际标准——ISO/IEC 9899,简称<span class=\"strong\">C89/C90</span>标准，是C语言的主流标准，被广泛应用于各个领域。1999年，ISO对C语言进行了大量扩展和改进，加入了如long long等新的数据类型，发布了<span class=\"strong\">C99</span>标准，该标准在部分领域使用广泛，但在工业等领域普及度较低。目前最新标准为2018年发布的C17标准，但尚未被广泛使用。</div>\n\n\n#### 编译流程\nC语言源文件以<span class=\"tips\">.c</span>为文件名后缀，从高级语言转换为机器码程需要经过<span class=\"strong\">预处理</span>、<span class=\"strong\">编译</span>、<span class=\"strong\">汇编</span>、<span class=\"strong\">链接</span>四个过程\n\n###### 预处理\nC语言源文件首先会被预处理，以一个名为hello.c的源文件为例，<span class=\"tips\">hello.c</span>源文件经过预处理器处理，会生成一个<span class=\"tips\">hello.i</span>临时文件，预处理阶段会进行以下工作：\n+ 删除代码中的所有注释\n+ 对宏进行代码扩展，通过<span class=\"strong\">#define</span>等指令定义的常量或表达式，会被替换到文件中，对<span class=\"strong\">#if</span>等条件编译指令限定的代码进行选择性编译\n+ 包含文件，通过<span class=\"strong\">#include</span>指令包含的文件，其内容会被添加到源文件中\n\n###### 编译\n编译器会将临时文件<span class=\"tips\">hello.i</span>编译为汇编文件<span class=\"tips\">hello.s</span>，该阶段编译器会对代码进行语法检查，并返回源代码中存在的语法错误和警告\n\n###### 汇编\n汇编程序将<span class=\"tips\">hello.s</span>汇编文件编译成机器码，在<span class=\"strong\">Windows</span>环境下生成<span class=\"tips\">hello.obj</span>对象文件，在<span class=\"strong\">Linux</span>环境下生成<span class=\"tips\">hello.o</span>目标文件\n\n###### 链接\n链接器会将多个目标文件合并为一个文件，并与库函数文件(.lib)等依赖链接，生成可执行文件，在Windows环境下生成一个可执行文件 hello.exe，在 Linux环境下中生成 hello.out文件\n\n库函数文件由各软件公司编写并已经编译成目标文件(.obj文件)，它们将在链接阶段与源程序编译而成的目标文件(.obj文件)相链接，生成可执行文件。\n\n#### C语言内存模型\n准确来讲，这是Linux的虚拟空间布局的一部分，Linux系统内核进程和用户进程所占的虚拟内存比是1：3，Windows是2：2，以32位Linux系统为例，模拟一个4GB的内存地址块沙盘，其中高地址位的1GB内存为系统内核进程占用的内核空间，低地址位的3GB内存为用于用户内进程的用户空间，内核空间由操作系统负责维护和处理，因此本文只涉及日常开发中C程序可以操控的3GB用户空间部分。\n\n该虚拟沙盘地址通过页表(Page Table)映射到物理内存，其中，蓝色区域会被映射到物理内存的不同内存段，白色区域只用于虚拟内存地址的分析，不会映射到物理内存中，不占用内存空间\n\n<img src=\"#\" alt=\"C语言内存\" data-src=\"/blog/images/20240316041218.png\" style=\"max-width:420px;max-height:470px;\">\n\n##### 保留区(Reserved)\n保留区是系统预留且禁止用户进程访问的地址区域，位于虚拟地址空间的最低部分，不赋予物理地址，一般用于捕捉空指针异常等情况。在大多数操作系统中，极小的地址空间通常都是不允许访问的，如NULL、0等。因此C语言也将无效指针赋值为0，因为0地址在正常情况下是不会存放有效的可访问数据的。\n\n在32位X86架构的Linux系统中，系统将预留128MB的保留区，因此用户进程可执行程序一般从虚拟地址空间0x08048000开始加载内存区域。\n\n##### 代码区(Code/Text)\n用于存放二进制代码，该区域是只读的，以防止恶意程序修改代码区的数据。代码段指令中包括操作码和操作数(操作对象)，如果操作对象是立即数(具体数值)，则该数据将直接包含在代码中；如果是字符串常量、变量中的数据，则将引用该数据地址。\n\n##### 静态区(Static)\n静态区又称全局区，这部分的空间大小在编译时就已经确定，因此是静态的，静态区分为<span class=\"strong\">只读数据段</span>(RO Data，又称为常量区)、<span class=\"strong\">已初始化数据段</span>(又称为读写数据段，RW Data)和<span class=\"strong\">未初始化数据段</span>(又称为BSS段，Block Started by Symbol)三部分\n+ <span class=\"strong\">只读数据段(.rodata)：</span>只读，用于存储字符串常量，以及const修饰的只读全局变量(只读局部变量存储于栈区)、只读字符串变量，只读静态变量\n+ <span class=\"strong\">已初始化数据段(.data)：</span>可读可写，存储已初始化且初值不为0的全局变量和静态局部变量\n+ <span class=\"strong\">未初始化数据段(.bss)：</span>可读可写，存储未初始化或初始化为零的全局变量和静态变量。这些变量在编译阶段会被收集起来放到.bss段中，并在程序初始化时自动赋值为0(对数值型变量)或空字符(对字符变量)。由于.bss段的值全为0，因此这个段只记录段长，在编译-链接生成的可执行文件中不占用物理文件空间(全是0，没必要存储)，能在一定程度上节省磁盘空间。在程序执行(初始化)时，加载器(loader)根据其段长分配相应大小的内存，并将这些内存空间全部初始化为0。因此.bss段不占用物理文件尺寸，但占用内存空间；.data段占用物理文件，也占用内存空间\n\n##### 堆(Heap)\n由程序员分配释放，如果程序员不释放，则操作系统在程序结束时回收，通过<span class=\"tips\">malloc</span>、<span class=\"tips\">realloc</span>、<span class=\"tips\">calloc</span>语句开辟空间，通过<span class=\"tips\">free</span>释放。\n\n堆内存的增长方向为由低地址向高地址增长，其工作方式类似于数据结构中的<span class=\"tips\">链表</span>。在操作系统中有一个记录空闲内存地址的链表，当使用malloc()等语句开辟内存空间时，操作系统会遍历该链表，寻找第一个空间大于等于所申请空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序，此外，系统会在该空间的首地址处记录所分配的空间大小，以便free语句能正确释放空间。\n\n由于每次分配的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中，频繁的开辟、释放空间势必会造成内存空间的不连续，从而造成大量碎片。\n\n堆空间的大小受限于系统的有效虚拟内存，32位Linux系统中堆内存可达2.9G空间。堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。\n\n\n##### 内存映射段(mmap)\n该区域用于映射可执行文件用到的动态链接库到内存中，方便更快速地读取。\n此外，在Linux中，如果通过malloc()请求一个大的内存空间，C运行库将在该区域创建一个匿名内存映射，而不使用堆内存。\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n内存映射是一种强大的文件I/O技术，用于高效读写文件。它将文件映射到虚拟内存空间中，并且支持按需加载文件，然后通过内存地址来访问文件，从而避免了大量的文件读写操作，比传统的文件读写操作更加快捷方便。\n</div>\n\n##### 栈(Stack)\n栈内存由<span class=\"tips\">编译器</span>负责分配和释放，主要用于存放：\n+ 函数内部定义的局部自动变量(auto类型)，包括const修饰的只读局部变量\n+ 函数参数和返回值\n+ 调用函数时的上下文环境，如函数返回地址等\n+ 暂存一些算术表达式的计算结果\n+ alloca()函数分配的栈内内存\n\n栈内存的增长方向为由高地址向低地址增长，其工作方式与数据结构中的栈相似，即先入后出，且栈分配的内存空间是连续的，不会有碎片化现象。栈是由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多\n\n栈空间的大小由系统预定义(通常默认2M或10M)，当栈剩余空间大于所申请空间时，系统将分配内存，否则将抛出栈溢出(stack overflow)错误\n\n##### 各段生成时间\n在C语言程序编译-链接后生成的映像文件中，将只包含代码段、只读数据段(.rodata)和读写数据段(.data)，双击运行该文件后，程序在初始化时将动态生成未初始化数据段(.bss)，程序的运行过程，将动态生成堆(Heap)和栈(Stack)\n\n<div class=\"show\">char str[]=\"hello\"; //数组末尾会添加'\\0'代表存储结束\nchar * str=\"hello\";\n如果它们都是局部变量，则字符数组会在栈区申请空间，并将字符存储在数组空间中；而指针变量，字符串存储在全局区的只读数据段，栈中的指针变量存储的是其字符串在全局区中的地址\n如果它们声明为全局变量，则字符数组声明在全局\nconst 声明的全局变量存储于静态区\nconst 声明的局部变量存储于栈\nconst 声明的字符串常量存储于静态区只读区 const char* str=\"hello\"\n</div>\n\n### 预处理命令\n预处理命令是C语言源程序中用于改进程序设计环境、提高编程效率的特殊命令，不属于C语言的组成部分，无法进行编译，只会对其在预处理阶段作出相应处理。预处理命令以<span class=\"tips strong\">#</span>开头，且不以分号结尾，以便与一般的C语言语句区分\n\n#### #include文件包含\n<span class=\"strong\">文件包含</span>处理指将一个源文件中的内容包含到另一个源文件中，被包含的文件称为<span class=\"strong\">头文件</span>(或标题文件)，文件名常以<span class=\"tips\">.h</span>作为后缀，也可以以<span class=\"tips\">.c</span>作为后缀甚至没有后缀。在编译的预处理阶段，头文件中的内容会被复制到主文件中，替换掉 #include &lt;xxx.h>语句，得到一个新的源文件，再对该文件进行编译。\n\n+ <span class=\"strong\">#include &lt;文件名></span>一般用于包含系统库函数头文件\n+ <span class=\"strong\">#include \"文件名\"</span>一般用于包含用户自己编写的头文件\n\n<div class=\"show\">eg:C语言中常用的标准输入输出函数头文件\n#include &lt;stdio.h&gt;\n// std：standard(标准)，i为input，o为output，将包含标准输入/输出函数的头文件stdio.h包含到源文件中</div>\n\n注意事项：\n+ 一个#include语句只能包含一个文件，如果要包含多个文件，则只能使用多个语句\n+ 使用<span class=\"tips\">&lt;文件名></span>包含文件时，系统会到存放C语言库函数头文件的路径下寻找该文件，，使用<span class=\"tips\">\"文件名\"</span>包含文件时，系统会首先在用户当前目录中寻找文件，如果没有，再去C语言库函数路径下\n+ 如果A文件包含了B文件，而B文件需要使用C文件中的内容，则可以在A文件中使用两个#include命令同时包含文件B和C，且包含C文件的指令需要出现在包含B文件的指令前。也可以嵌套包含，即B文件包含C文件，A文件包含B文件\n+ A文件包含B文件后，B文件中的内容会在预处理阶段被复制到A文件中，因此B文件中的全局静态变量在A文件中有效，不需要extern声明语句\n+ #include通常用于包含.h头文件，也可以包含其他文本文件，如：源代码文件(.c)、c++的头文件(.hpp或.hxx)、库文件(.lib、.dll、.a等)，甚至可以为.txt文本文件\n\n#### #define 宏定义\n用一个指定的标识符代表一个字符串，在编译预处理阶段，预处理器会对源代码中的宏名进行<span class=\"strong\">宏展开</span>，即将宏名替换成对应的字符串\n\n+ <span class=\"strong\">#define 标识符 字符串</span> 定义无参宏定义\n+ <span class=\"strong\">#undef 标识符</span> 终止宏定义\n+ <span class=\"strong\">#define 标识符(参数表列) 字符串</span> 定义带参数的宏定义\n\n注意事项： \n1. 宏名一般使用<span class=\"strong\">大写字母</span>表示，以便与普通变量名区分\n2. 宏定义只用作字符串替换，与定义普通变量不同，不分配内存空间\n3. 宏定义可以嵌套定义\n4. 宏定义用于定义符号常量，定义完毕后不能再赋值，也不能被修改\n5. 宏定义语句写于函数外，作用范围为宏定义语句之后到本源文件结束，或者到<span class=\"tips\">#undef 宏名</span>行终止\n6. 预处理阶段只对宏名进行字符串替换，不作语法准确性检查。如果宏定义中有错误，只有在宏名被宏展开后的编译阶段，编译器对源程序进行语法检查时才会发现宏定义中存在的错误\n\n\n<div class=\"show\"> //无参数宏定义\n#include &lt;stdio.h>\n#define PI 3.1415926\n#define R 4.0\n#define L 2*PI*R //嵌套定义宏\nint main()\n{\n    float l=L;\n    printf(\"%f\",l);\n    return 0;\n}\n#undef R  //终止R的作用范围\nvoid f1(){....}\n</div>\n<div class=\"show\"> //带参宏定义\n#include &lt;stdio.h>\n#define L(r,s) r+s //带多个参数的宏定义\n#define M(r) 3*r*r \n#define N(r) 3*(r)*(r)\nint main(void){\n int a=1,b=2,result;\n result=L(a,b); //展开为result=a+b;\n result=M(a+b); //展开为result=3*a+b*a+b<span class=\"tips\">注意宏定义时参数不带()可能会被展开为错误形式</span>\n result=N(a+b); //展开为result=3*(a+b)*(a+b);\n return 0;\n}</div>\n\n#### 条件编译\n<span class=\"strong\">条件编译</span>指预处理器根据条件编译指令，选择性将源代码中的部分代码送到编译器进行编译\n\n###### #ifdef宏定义判断\n<span class=\"strong\">#ifdef 标识符\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序1\n&emsp;&emsp;#else\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序2\n&emsp;&emsp;#endif\n</span>\n如果指定的标识符已经被#define定义过，则编译程序1，否则编译程序2，程序1和程序2既可以是C语句，也可以是预处理命令，类似于if...else...语句，#else可以不使用\n<div class=\"show\">#include &lt;stdio.h>\n#define TEST //TEST定义甚至可以为空，也视为被定义过\n#ifdef TEST\n    #define SIZE 32 //TEST被定义过，所以执行该语句\n#else\n    #define SIZE 64\n#endif\n....</div>\n\n###### #ifndef无宏定义判断\n逻辑与#ifdef相反，如果指定的标识符未被#define定义，则编译程序1，否则编译程序2\n<span class=\"strong\">#ifndef 标识符\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序1\n&emsp;&emsp;#else\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序2\n&emsp;&emsp;#endif\n</span>\n\n###### #if表达式判断\n如果表达式值为真，编译程序1，否则编译程序2\n<span class=\"strong\">#if 表达式\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序1\n&emsp;&emsp;#else\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序2\n&emsp;&emsp;#endif\n</span>\n\n<div class=\"show\">#include &lt;stdio.h>\n#define LINUX 1 //可以快速设置编译的目标平台，缩减源代码长度\nint main(void){\n    #if LINUX\n        printf(\"linux专用代码\");\n    #else\n        printf(\"非linux用代码\");\n    #endif\n    .....\n    return 0;\n}</div>\n\n### 变量\nC语言中变量的声明方式如下：\n<span class=\"strong\"><span class=\"text-green\">存储类型</span><span class=\"text-blue\">数据类型 </span> 变量名;</span>\n\n+ 存储类型代表编译器为变量分配内存的方式，如：自动变量内存分配于动态存储器，静态变量和外部变量内存分配于静态存储区，寄存器变量存储位置分配于CPU中的寄存器\n+ 存储类型和作用域(变量定义的位置)决定了变量的生存期\n+ 数据类型指该变量存储的数据类型\n+ 变量名需要满足标识符命名规则\n\n#### 标识符命名规则\n<span class=\"strong\">标识符</span>即C语言中的变量名、符号常量名、函数名、数组名等用来给数据对象命名的字符序列，标识符需要满足以下规则：\n\n+ 只能由英文字母、数字、下划线组成\n+ 不能以数字开头\n+ 不能使用关键字\n+ 严格区分大小写\n\n#### 变量的作用域和生存期\n变量从其作用域区分，分为局部变量和全局变量：\n\n<span class=\"strong\">局部变量</span>：定义在函数内部或{ }包裹的代码块内部，只在本函数或代码块内生效，分为静态局部变量和动态局部变量。默认情况下，局部变量的存储类型为auto(动态局部变量)，变量内存位于动态存储区，代码块内的语句执行完毕变量就会被销毁，释放其内存。可以将局部变量的存储类型定义为static(静态局部变量)，此时变量内存位于静态存储区，整个程序运行期间其内存不会被释放\n\n<span class=\"strong\">全局变量</span>：定义在函数的外部，默认存储类型为extern，有效作用域为变量定义位置开始到本源文件结束，其作用域可以通过extern声明进行拓展。全局变量在程序的整个执行过程都占用内存单元。<span class=\"tips\">习惯上，全局变量的首字母用大写表示</span>，当全局变量名和局部变量名相同时，局部变量有效\n\n变量的生存期是指变量从生成(分配内存)到被销毁(释放内存)的时间段。对于存储在静态存储区中的变量，其内存在编译时就已经确定，是静态的，内存空间在整个程序运行期间不会被释放，变量与程序共存亡。而对于存储在动态存储区中的变量，其内存由操作系统根据程序运行动态分配。变量的存储类型直接决定了变量的生存期。\n\n<div class=\"show\">#include&lt;stdio.h>\nint Number=0;   //全局变量首字母大写\nint main(void){\n    void test();\n    int num=10;\n    int Number=10; //局部变量生效，全局变量被\"屏蔽\"\n    test();\n    return 0;\n}\nvoid test(){\n    Number=100; //全局变量可以被任意函数访问和修改，会降低程序清晰性\n}</div>\n\n#### 变量的存储类型\nC语言提供的存储类型主要有以下几种：\n\n+ 自动变量 auto\n+ 静态变量 static\n+ 外部变量 extern\n+ 寄存器变量 register\n\n\n##### auto自动变量\n又称动态局部变量或局部作用域变量，定义于函数内部，是C语言中极为常用的变量类型，因此C语言把它设计为缺省类型(默认类型)，即auto可以省略不写，反之，如果没有指定局部变量的存储类型，则默认为auto，因此以下两个语句等价\n<div class=\"show\"><code>{\nint num=10;\nauto int num=10;\n}</code></div>\n\n自动变量数据存储在<span class=\"text-blue\">动态存储区</span>中，操作系统会在代码执行到变量定义语句时为其分配内存，退出所属语句块时释放内存。函数形参和函数内定义的变量(未明确声明为static)都属于该类变量。自动变量有以下特点：\n+ 自动变量在定义时不会自动初始化。所以除非程序员显式指定初值，否则自动变量的值是随机的垃圾值\n+ 自动变量在退出函数(语句块)后，其分配的内存立即被释放，再次进入该语句块，该变量被重新分配内存，所以不会保存上一次退出时的值\n\n##### static静态变量\n静态变量分为静态局部变量和静态外部变量，二者用于不同的场景。静态变量在<span class=\"text-blue\">静态存储区</span>分配内存，在整个程序运行期间不会被释放，与程序共存亡。对于已经初始化的静态变量，其内存空间位于静态存储区的.data段，在编译时赋予内存。对于未初始化的静态变量，其内存空间位于静态存储区的.bss段，并在程序初始化时，给变量赋值0(对数值型变量)或空字符(对字符变量)。\n\n###### 静态局部变量\n自动变量的内存会在代码退出函数块后被释放，其值也不会被保留，下次进入该函数块，该变量会被分配新的内存，如果希望变量的值在退出函数语句块后依旧被保留，其占用的存储单元不释放，方便函数基于上一次的运算结果进一步进行计算，此时可以使用static关键字将局部变量定义为静态局部变量。\n\n<div class=\"show\">eg:计算n的阶乘\n<code>int main(void){\n    int i,n;\n    scanf(\"%d\",&n);\n    for(i=1;i&lt;=n;i++){\n        Func(i);\n    }\n    return 0;\n}\nlong Func(int n){\n    static long p=1;\n    return p*n;\n}</code></div>\n\n静态局部变量，有以下特点：\n+ 如果定义静态局部变量时不赋初值，编译器会自动赋为0(对数值型变量)或空字符(对字符变量)\n+ 自动变量(动态局部变量)占据的内存在函数调用结束后会被释放，每次调用都需要重新初始化。而静态局部变量仅在第一次调用函数时被初始化一次，其占据的内存在退出函数后不会被释放，再次调用该函数其值上次退出函数时的值\n+ 虽然静态局部变量在函数调用结束时仍然存在，但其他函数是无法引用它的\n\n###### 静态外部变量\n外部变量默认存储类型为extern，可以被其他文件使用extern声明后引用，如果希望外部变量只限于被本文件使用，而不能被其他文件引用，则可以在声明外部变量时添加static声明，将其声明为静态外部变量，该类变量可以应用于以下场景：\n+ 多人开发时，可以在不同文件中声明同名外部变量而互不干扰\n+ 权限控制，避免其他文件引用或修改外部变量的值\n\n<div class=\"show\"><code>static int Number;\n</code></div>\n\n\n##### extern外部变量\n如果定义在函数之外的变量没有指定其他存储类别，那么它就是一个外部变量，外部变量是全局变量，作用域是从它的定义点到本文件末尾。但如果要在定义点之前或在其他文件中使用它，那就需要使用关键字extern对其进行声明(注意不是定义，编译器不为其分配内存)\n声明语句为:\n<span class=\"strong\">extern 类型名 变量名;</span>\n其中类型名可以省略，因此以下语句等价\n<div class=\"show\"><code>extern int Num1;\nextern Num1;</code>\n注意！\n在定义外部变量时，直接在函数外定义 int Num1;  即可\nint Num1;  是“定义性声明”语句，会给变量分配内存空间，\nextern int Num1;  为“引用性声明”语句，用于拓展外部变量作用域，不会分配内存，不能用来定义一个未初始化的外部变量\n但如果在定义时进行初始化，根据右结合原则，会当作定义了变量，并进行了extern作用域拓展处理\nextern int Num1=200;//既是定义语句，也是extern声明语句\n</div>\n\n###### 在一个文件内声明外部变量\n如果外部变量不在文件开头定义，那么它的作用域就是从它的定义点到本文件末尾。如果在定义点之前想要引用该变量，则需要在引用之前对使用extern对其进行外部变量声明，声明后就可以从声明之处起，合法使用该外部变量\n<div class=\"show\"><code>int main(void){\n    int getMax(int ,int);\n    <span class=\"text-blue\">extern Num1,Num2;</span>//外部变量声明(仅作声明，不分配内存)\n    printf(\"max is:%d\", getMax(Num1,Num2);)//在定义前引用变量\n}\nint Num1=10,Num2=20;//定义外部变量\nint getMax(int x,int y){\n    return x>y?x:y;\n}\n</code></div>\n\n\n\n###### 在多文件中声明外部变量\nC语言程序也可以由多个源文件组成，如果多个文件都需要用到同一个外部变量，不能在多个文件中都同时定义该变量，否则程序在链接阶段会出现“重复定义”错误。正确做法是：在某一个文件中定义外部变量，其他文件中用extern对该变量作“外部变量声明”，将变量的作用域拓展到这些文件中，然后在这些文件中合法引用外部变量。\n<div class=\"show\">eg:文件file1.c中输入变量Num的值，文件file2.c对Num扩大10倍后返回结果\nfile1.c文件:\n<code>#include&lt;stdio.h&gt;\n<span class=\"text-blue\">int Num;</span>//定义外部变量\nint main(void){\n    int getValue(int);\n    printf(\"Input the value of Num:\");\n    scanf(\"%d\",&Num);\n    printf(\"%d\",getValue(10));\n    return 0;\n}</code>\nfile2.c文件:\n<code><span class=\"text-red\">extern Num;</span>//声明A为其他文件已经定义的外部变量\nint getValue(int n)\n{\n    return Num*n;\n}</code></div>\n\n##### register寄存器变量\n对于使用频率较高的变量，可以将其声明为寄存器变量，减少CPU对内存的频繁数据访问，使得程序更小，执行速度更快\n<div class=\"show\"><code>int main(void)\n{\n    int n;\n    long countNum(int);\n    scanf(\"%d\",&n);\n    countNum(n);\n    return 0;\n}\nlong countNum(int n)\n{\n    register long i,f=1;\n    for(i=1;i&lt;n;i++){\n          f=f*i;\n    }\n    return f;\n}\n</code></div>\n\n寄存器变量有以下特点：\n+ 只有局部自动变量和形参可以作为寄存器变量\n+ CPU中的寄存器数量有限，不能定义太多的寄存器变量\n+ 有的系统把寄存器变量当作自动变量处理，在内存中分配存储空间，并非放到寄存器中\n\n现代编译器能自动优化程序，自动把普通变量优化为寄存器变量，并且可以忽略用户定义的寄存器变量，因此一般无需特别声明变量为register，仅作了解。\n\n### 数据类型\n#### 数据类型总览\n##### 基本类型\n<div class=\"table\">\n<table>\n        <thead>\n            <tr>\n                <th colspan=\"2\">分类</th>\n                <th>关键字</th>\n                <th>长度(Bytes)</th>\n                <th>示例</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td rowspan=\"5\">整型</td>\n                <td>短整型</td>\n                <td>short</td>\n                <td>2</td>\n                <td>short a;或\n                    short int a;\n                </td>\n            </tr>\n            <tr>\n                <td>整型</td>\n                <td>int</td>\n                <td>4</td>\n                <td>int a;</td>\n            </tr>\n            <tr>\n                <td>长整型</td>\n                <td>long</td>\n                <td>4</td>\n                <td>long a;或\n                    long int a;\n                </td>\n            </tr>\n            <tr>\n                <td>长长整型</td>\n                <td>long long</td>\n                <td>8</td>\n                <td>long long a;或\n                    long long int a;\n                </td>\n            </tr>\n            <tr>\n                <td>无符号整型</td>\n                <td>unsigned</td>\n                <td>8</td>\n                <td><div>unsigned int a;</div> \n                    unsigned long  a;\n                </td>\n            </tr>\n            <tr>\n                <td rowspan=\"3\">浮点型(实型)</td>\n                <td>单精度</td>\n                <td>float</td>\n                <td>4</td>\n                <td>float a;</td>\n            </tr>\n            <tr>\n                <td>双精度</td>\n                <td>double</td>\n                <td>8</td>\n                <td>double a;</td>\n            </tr>\n            <tr>\n                <td>长双精度</td>\n                <td>long double</td>\n                <td>12或8</td>\n                <td>long double a;</td>\n            </tr>\n            <tr>\n                <td colspan=\"2\">字符型</td>\n                <td>char</td>\n                <td>1</td>\n                <td>char a;</td>\n            </tr>\n            <tr>\n                <td colspan=\"2\">枚举型</td>\n                <td>enum</td>\n                <td>-</td>\n                <td>enum res{yes,no,none};</td>\n            </tr>\n        </tbody>\n    </table>\n</div>\n\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nlong long,unsigned long long,long double是C99标准新增的，部分编译器默认使用C89标准，需要手动指定使用C99标准编译才支持以上数据类型。此外，ANSI C标准对于数据类型所占内存的字节数并无明确定义，因此不同编译器中各数据类型的字节数可能不同</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nC语言中没有string类型，处理字符串一般使用字符数组或指针，也没有bool类型，不能使用true和false逻辑常量</div>\n\n##### 构造类型\n\n<div class=\"table\">\n\n构造类型|关键字|示例\n-----|-----|----\n数组|-| int num[10];\n结构体|struct|\n共用体|union|union{int num;char name[5];}man\n</div>\n\n##### 其他类型\n<div class=\"table\">\n\n数据类型|关键字|示例\n-----|-----|----\n指针|-|int * p;\n无类型|void|void f1(){...}\n</div>\n\n#### 整型\n整型从符号位的归属可分为<span class=\"strong\">有符号整型(signed)</span>和<span class=\"strong\">无符号整型(unsigned)</span>。有符号整型最高位为符号位，0表示该值为正数，1表示该值为负数，而无符号整型的最高位不表示正负，依旧用于储存数值，因此无符号整型只能表示0和正整数，但无符号整型可存储的数值范围要比同位数的有符号整型大2倍，如：signed int数值范围为-32768-32767，而unsigned int 数值范围为0-65535。如果一个整型不声明为unsigned或signed，则默认隐含为signed，因而signed可以省略不写。\n\n对于短整型和长整型，int也可以省略不写(以下[]内的均可省略不写)\n\n<div class=\"table\">\n\n类型|比特位数|取值范围\n------------|-----|----\n[signed] short [int]|16|-2<sup>15</sup>\\~(2<sup>15</sup>-1)\nunsigned short [int]|16|0\\~(2<sup>16</sup>-1)\n[signed] long [int]|32|-2<sup>31</sup>\\~(2<sup>31</sup>-1)\nunsigned long [int]|32|0\\~(2<sup>32</sup>-1)\n</div>\n\n对于整型常量，通常在其数值后加上相应符号表示其具体类型，如：加上<span class=\"tips\">U或u</span>表示无符号整型，加上<span class=\"tips\">L或者l</span>表示长整型\n\n<div class=\"show\">233u或233U为无符号整型\n-1024l或-1024L为长整型\n203lu为无符号长整型</div>\n\n<div class=\"broadcast color-red\"><div class=\"iconfont icon-gantanhao\"></div>如果使用u标识一个负整数,如-12345u，则将取-12345补码对应的无符号整数53191按无符号数存储</div>\n<div class=\"show\">-12345\n原码：1011 0000 0011 1001\n反码：1100 1111 1100 0110\n补码：1100 1111 1100 0111 --->对应无符号数值为53191</div>\n\n#### 浮点型\n浮点数有两种表示方式：\n+ 十进制小数形式，如：0.5,1.3,.95(省略0)\n+ 指数形式，以e或E为底数(其中e代表10)，e的左边为数值部分，e的右边为指数部分(必须为整数)，如：12.3可以表示为1.23e1、0.123e2、123e-1等形式，如果e左边的数值部分，小数点左边有且只有一位非零的数字，则该表示方法称为<span class=\"tips\">\"规范化的指数形式\"</span>，如：1.23e1为规范化的指数形式，而0.123e2、123e-1不是\n\nC语言默认将浮点型常量作为<span class=\"tips\">双精度(double)</span>类型进行处理，如果在常量后加上<span class=\"tips\">f或F</span>将作为float型处理，加上<span class=\"tips\">l或L</span>则作为long double型处理，eg:1.25e-2f，1.25L\n\n#### 字符\n字符常量使用<span class=\"tips\">单引号''</span>包裹，一个字符占用一个字节(中文字符需要两个字节)。字符在内存中以ASCII码形式存储，因此字符型数据和整型数据是通用且可以用于计算的(仅限于0-255之间的整数)，常见的应用为<span class=\"tips\">大写字符+32转换为小写字符</span>\n<div class=\"show\">char a=97;\nint  asciiA=a-32;\nprintf(\"%c\\n\",asciiA)//输出A\nprintf(\"%d\",asciiA)//输出65\n</div>\n\n此外，C语言中还有一些特殊的转义字符，作用如下\n<div class=\"table\">\n\n字符|含义                               |字符|含义\n---|-----------------------------------|----|---\n\\n |换行                               |\\a   |响铃报警提示音\n\\r |回车(不换行)，将光标位置移到当前行开头|\\\\\"   |双引号\n\\0|空操作字符，常用作字符串结束标志          |\\\\'   |单引号\n\\t|水平制表，跳到下一个Tab位置          |\\\\\\\\  |反斜线\n\\v|垂直制表                            |\\\\?   |问号\n\\b|光标位置退一格                               |\\ddd  |1到3位八进制ASCII码代表的字符\n\\f|换页                               |\\xhh  |1到2位十六进制ASCII码代表的字符\n</div>\n\n<div class=\"show\">1. \\ddd和\\xhh是用一个八进制或者十六进制的ASCII码表示一个字符，如：\"\\101\"和\"\\x41\"转换为十进制为65，表示ASCII码值为65的字符A\n2.注意\\r和\\b的使用，会覆盖掉\\r、\\b之前的字符\nprintf(\"abcdefg\\r1234\");//输出1234 fg，光标回到本行开头，1234\\0替换掉abcde(字符串末尾会添加\\0，因此\\0替换e并输出空白字符)\nprintf(\"abcdefg\\b\\b\\b\\b123\");//输出abc 123\nprintf(\"abcdefg\\b\\b\\b\\b\\b\\b\\b123\");//输出123 efg\nprintf(\"abcdefg\\b\\b\\b\\b\\b\\b\\b123\\n\");//输出123defg\n</div>\n\n### 字符串\n字符串常量使用<span class=\"tips\">双引号\"\"</span>包裹，字符串末尾会被加上<span class=\"tips\">'\\0'</span>作为字符串结束的标志。C语言中没有专门的关键字用来声明字符串变量，因此需要使用字符数组或者指针来存储和处理字符串\n\n#### 字符数组\n字符串可以存储于字符数组中，但字符数组中存储的并不一定是字符串，这取决于字符数组最后一个元素是否是字符串结束标志'\\0'，'\\0'也占用一个字节内存，但它不计入字符串的实际长度，只计入数组长度。注意，如果字符数组最后没有'\\0'，系统将无法将该数组当作字符串来处理(如：无法正确被printf(\"%s\",xx)输出)\n<div class=\"show\">对于字符数组，可以像其他数组一样用同样的方式初始化，如：\n<code>char str[6]={'H','e','l','l','o','\\0'};</code>\n如果省略对数组长度的声明，则必须人为在初始化列表中添加'\\0'，否则系统将无法将str当作字符串来处理\n<code>char str[]={'H','e','l','l','o'};//长度为5的普通字符数组\nchar str[]={'H','e','l','l','o','\\0'};//长度为6的字符串</code>\n用printf(\"%s\",str)语句输出上述变量时，第一个变量由于缺少'\\0'，输出语句会在输出完Hello后继续输出乱码，直到遇见'\\0'，而第二个变量会被正常输出\n\n也可以用字符串常量初始化字符数组，这样可以不指定数组大小，且由于字符串常量\"Hello\"末尾自带'\\0'，可以不必人为添加'\\0'\n<code>char str[6]={\"Hello\"};\nchar str[]={\"Hello\"};//数组长度可省略\nchar str[]=\"Hello\";//大括号可省略</code>\n<span class=\"text-red\">但只允许在定义时整体赋值，不允许在赋值语句中整体赋值</span>\n<code>char str[6];\nstr[]={\"Hello\"};//不允许先定义，定义完在赋值语句中整体赋值,Visual Studio报错：不允许使用不完整的类型</code>\n无论用哪种方式初始化字符数组，如果指定数组长度，都要保证预留足够空间以便存储字符串结束标志，即：字符数组大小一定要比字符串的实际字符数大1\n可以使用数组下标访问字符串的单个字符，如：\nstr[1]代表字符'e'</div>\n\n<div class=\"show\">一个字符串可以用一维字符数组存储，多个字符串可以用二维字符数组存储。数组的第一维长度代表要存储的字符串个数，可以省略；第二维长度不能省略，应当设定为最长那个字符串长度+1，eg:\n<code>char weekday[][10]={\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"};</code>\n其中最长的字符串\"Wendesday\"长度为9，因此第二维长度应当为10，对于长度小于10的字符串，其剩余的内存单元会被'\\0'填充\n如果字符串太长，可以拆分为几个小片段写在不同行，其中空格也将占用数组长度和空间\n<code>char longString[]=\"One day you will leave this world behind\"\n\"so live a life you will remember\"</code></div>\n\n#### 字符指针\n字符指针是指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一确定的地址，因此只要将字符串首地址赋值给指针变量，就可以让字符指针指向一个字符串。对于字符串常量，C语言按字符数组处理，在内存中开辟一个字符数组存储该字符串，字符串常量本身就代表存放它的常量存储区的首地址。\n\n<div class=\"show\">1. 以下两个初始化语句等价，均表示将字符串常量在常量存储区中\"Hello\"的首地址赋值给ptr\n<code>char * ptr=\"Hello\";</code>\n等价于\n<code>char * ptr;\nptr=\"Hello\";</code>\n2. 由于字符串常量存储于只读的常量存储区中，因此只可以修改指针变量的指向，不能修改ptr所指向存储单元的内容\n*ptr='a';//错误！写入权限异常，不能修改所指向存储空间的内容\nptr=\"another\";//允许修改指针的指向\n3. 通过指针也可以访问单个字符，如：\n*(ptr+1)代表字符'e'\n也可以修改指针指向位置，使其从所指位置开始输出，直至遇到'\\0'，以此输出字符串的部分内容，如：\n<code>char * sentence=\"Meet you like the wind\";\nsentence=sentence+14;\nprintf(\"%s\",sentence);//输出the wind</code>\n</div>\n\n#### 字符串的输出\n字符串的输出支持以下三种方法：\n<div class=\"show\">1. 依次输出单个字符\n<code>for(int i=0;i&lt;6;i++){\n    printf(\"%c\",str[i]);\n}</code>\n由于字符串长度并不等于字符数组大小，且上述方法无法灵活输出不同长度字符串，因此一般会借助字符串结束标志'\\0'来结束字符串输出，如：\n<code>for(int i=0;str[i]!='\\0';i++){\n    printf(\"%c\",str[i]);\n}</code>\n2. 用格式符s，将字符串作为一个整体输出，同样输出到字符串结束标志为止\n<code><span class=\"text-red\">printf(\"%s\",str)</span></code>\n3. 使用<span class=\"text-blue\">puts()</span>函数(&lt;stdio.h>库函数)，puts()函数用于从括号内的参数给出的地址开始，依次输出存储单元中的字符，直到遇到第一个'\\0'时输出结束，并自动输出一个换行符，缺点是该函数无法如printf()函数一样添加其他字符信息并控制输出格式\n<code><span class=\"text-red\">puts(str)</span></code>\n</div>\n\n字符串指针变量可以指向一个格式字符串，可以替代printf()函数中的格式，作为一种可变格式的字符串输出\n<div class=\"show\"><code>char * format;\nformat=\"a=%d,b=%f\\n\";\nprintf(format,a,b);\n也可以用字符数组实现\nchar format[]=\"a=%d,b=%f\\n\";\nprintf(format,a,b);</code></div>\n\n\n#### 字符串的输入\n与输出相似，字符串的输入支持以下三种方法：\n<div class=\"show\">1. 依次输入单个字符\n<code>for(int i=0;i&lt;6;i++){\n    scanf(\"%c\",&str[i]);\n}</code>\n2. 用格式符s，将字符串作为一个整体输入，直至遇到<span class=\"tips\">空白字符、空格、回车符、制表符</span>为止，注意！<span class=\"text-blue\">由于字符数组名str本身已经代表字符串的首地址，因此str前不能再加上取地址符&</span>，此外，用scanf()不能输入带空格、制表符的字符串，空格、制表符、回车符及其之后的字符会被留在输入缓冲区\n<code><span class=\"text-red\">scanf(\"%s\",str);</span></code>\n3. 使用<span class=\"text-blue\">gets()</span>函数(&lt;stdio.h>库函数)，gets()函数以回车符作为输入终止符，同时将回车符从输入缓冲区读走，但不作为字符串的一部分，因此该函数可用于输入带空格的字符串\n<code><span class=\"text-red\">gets(str);</span></code>\n\n以上方法都有一定的安全隐患，如果输入字符数超过了定义的字符数组大小，多出的字符可能引起缓冲区溢出，带来安全隐患，因此可以使用能限制输入字符串长度的函数\n<span class=\"text-blue\">fgets(str,sizeof(str),stdin)</span>\n该语句表示从标准输入stdin中读取一行长度为sizeof(str)的字符串存储到str为首地址的存储区中，多余的字符舍弃</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n注意！如果使用字符指针输入字符串，必须保证字符指针事先已经指向一个字符数组地址或确定的存储单元，否则可能导致非法内存访问错误！</div>\n<div class=\"show\">使用字符指针输入字符串需要注意以下情况\n<code>char * ptr;//ptr未被初始化\nscanf(\"%s\",ptr);</code>\n上述代码，编译时给指针变量ptr分配了内存单元，但ptr中的值是一个不可预料的垃圾值，该指针指向一个未确定的存储单元，可能指向空白存储区，也可能指向已经存放指令或数据的内存段，在现代编译器中会报错使用了未初始化的局部变量“ptr”，然而在低版本编译器中可能顺利通过编译，带来潜在安全隐患\n因此，推荐使用字符数组输入字符串\n<code>char str[10];\nscanf(\"%s\",str);</code>\n如果使用字符指针输入字符串，则保证该指针指向了确定的地址\n<code> char str[10];\n<span class=\"text-red\">char * ptr=str;</span>\n gets(ptr);</code>\n</div>\n\n### 构造类型\n#### 数组\n##### 一维数组\n定义方式： \n<div class=\"apiBox\">类型 数组名[数组长度]</div>\n\n数组名的命名规则遵守标识符命名规范，数组长度需要使用常量表达式，<span class=\"tips\">不能包含变量</span>，一维数组的初始化可以使用以下方法：\n+ 在定义时赋予全部初值，如：int nums[5]={0,1,2,3,4};\n+ 也可以只给一部分元素赋值，其余元素会被赋0(char类型赋'\\0')，如：int nums[5]={0,1};\n+ 如果全部元素相同，可以只写一个值，如:int nums[5]={0};\n+ 如果对全部元素赋予初值，由数据个数已经确定，可以不指定数组长度，如：int nums[]={0,1,2,3,4};\n\n<div class=\"show\">1. 数组在定义时可以被整体初始化赋值\n<code>int nums[5]={11,22,33,44,55};</code>\n<span class=\"text-red\">但不允许在赋值语句中被整体赋值</span>\n<code>int nums[5];\nnums[]={11,22,33,44,55};//错误</code>\n这是由于数组在定义时，编译系统就会为其分配连续的内存单元，其内存空间大小就已确定，后续的整体赋值语句如果执行，可能会导致内存覆盖或溢出等不可预期的行为，所以需要注意用数组和指针操作字符串时的不同情况\n<code>char str[6];\nstr[]={\"Hello\"};//错误\nchar * ptr;\nptr=\"Hello\";//正确</code>\n2. <span class=\"text-blue\">数组名代表数组首元素的内存地址，即数组的起始地址，是一个地址常量，不能像修改指针变量一样对数组名进行++或--等操作</span>\n<code>int a[10];int *p;\np=a;\np++;//允许，指针指向a[1]\na++;//不允许，a是数组首地址，无法修改</code>\n3. C语言数组无length属性，获取数组长度可借助sizeof()函数\n<code>int nums[] = {1,2,3,4,5};\nprintf(\"%d\", sizeof(nums)/sizeof(nums[0]));</code>\n</div>\n\n##### 二维数组\n定义方式： \n<div class=\"apiBox\">类型 数组名[数组长度][数组长度]</div>\n\n对数组名和数组长度的要求同一维数组，二维数组的初始化可以使用以下方法：\n+ 分行赋值，如：`int nums[3][2]={{1,2},{3,4},{5,6}}`\n+ 也可以一次性统一赋值，但不如第一种赋值方法清晰，如：`int nums[3][2]={1,2,3,4,5,6}`\n+ 可以只给部分元素赋值，同样其余元素会被赋0(char类型赋'\\0')，如：`int nums[3][2]={{1},{},{0,6}}`\n+ 如果对所有元素赋初值，可以不指定第一维的长度，但<span class=\"tips\">第二维的长度声明永远不能省略</span>\n\n### 结构体\n#### 结构体定义\n对于复杂数据对象，仅仅使用几种基本数据类型无法准确反映它们之间的内在联系，也无法做统一处理，于是衍生出了允许用户自定义的数据类型，C语言中称之为构造数据类型(复合数据类型)，结构体就是构造数据类型的典型代表\n\n结构体模板的声明格式如下：\n<div class=\"apiBox\">struct 结构体名\n{\n    结构体成员\n};\n</div>\n\n结构体模板只是声明了一种数据类型，并未声明结构体类型的变量，编译器不为其分配内存，需要再使用以下语句声明结构体变量，编译器才会为结构体变量分配内存：\n<span class=\"strong\">struct 结构体名 结构体变量名;</span>\n\n+ 结构体的名字又称为结构体标签，用于标记用户自定义的结构体类型，struct+结构体名 共同构成一个数据类型，如：下述例子中的struct student是一个类型名，作用同系统提供的标准类型(如int、char等)，因此不为其分配内存\n+ 结构体成员的命名遵从变量的命名规则\n+ 结构体成员也可以为一个结构体，即结构体可以嵌套\n+ 结构体成员名可以与程序其他位置的变量名相同，二者互不干扰\n\n<div class=\"show\">eg:先声明结构体模板，再声明结构体变量\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n};//声明结构体模板，末尾;不可省略\nstruct student stu1,stu2;//声明结构体变量</code></div>\n\n也可以在声明结构体模板时，定义结构体变量：\n<div class=\"apiBox\">struct 结构体名\n{\n    结构体成员\n}变量名1,变量名2...;</div>\n<div class=\"show\">eg:声明结构体模板同时声明结构体变量\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}stu1,stu2;</code>\neg:当结构体模板与结构体变量一起声明时，结构体名是可以省略的，但该方法由于未指定结构体名，无法在程序其他地方再定义结构体变量，因此并不常用\n<code>struct//无结构体名\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}stu1,stu2;</code></div>\n\n关键字<span class=\"strong\">typedef</span>用于为已有数据类型定义一个别名，数据类型别名通常大写，便于区分已有数据类型。定义结构体时可用typedef定义一个结构体别名，便于使用更简洁的形式定义结构体变量\n<div class=\"show\">为结构体定义别名时，以下两个别名定义形式等价：\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n};\n<span class=\"text-blue\">typedef struct student STUDENT;</span>\n与\n<span class=\"text-blue\">typedef</span> struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}<span class=\"text-blue\">STUDENT</span>;</code>\n二者都为struct student类型定义了一个新名字STUDENT，因此以下两条定义结构变量的语句等价：\n<code>STUDENT stu1,stu2;//简洁形式\nstruct student stu1,stu2;</code>\n</div>\n\n#### 结构体变量初始化与成员引用\n结构体变量的成员可以通过将成员初值置于花括号内进行初始化\n<div class=\"show\">eg:在定义结构体变量时初始化\n<code>STUDENT stu1={114604,\"SHIWIVI\",{111,222,333,444}}</code>\n也可以在定义结构体模板和变量同时初始化\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}stu1={114604,\"SHIWIVI\",{111,222,333,444}}</code></div>\n\n访问结构体变量的成员必须使用<span class=\"tipe\">成员选择运算符</span>(圆点运算符)，访问格式为：\n<span class=\"apiBox\">结构体变量名.成员名</span>\n\n+ C语言规定，不能将结构体变量作为一个整体输入、输出，如：printf(\"%d%s..\",stu1)为非法语句\n+ 只能通过用圆点运算符访问结构体成员的方式来输入输出，如：printf(\"%s\",stu1.studentName)\n+ 成员运算符<span class=\"tips\">.</span>在所有运算符中优先级最高，因此通常可以将stu1.studentName当成一个整体看待\n+ 结构体嵌套时，必须以级联方式访问结构体成员，如：stu1.birthday.year\n+ 结构体成员可以像普通变量一样进行各种运算，如：stu1.birthday.year++\n+ C语言允许对具有相同结构体类型的变量进行整体赋值，如：stu1初始化后，可以通过stu2=stu1对stu2进行初始化，结构体成员会进行逐一顺序赋值\n+ 也可以使用=号对结构体成员进行分开赋值，但注意，当结构体成员为字符数组时，由于<span class=\"text-red\">字符数组名是该数组的首地址，是一个地址常量，不能作为赋值表达式左值</span>，因此对字符数组类型的结构体成员进行赋值时，必须使用字符串处理函数<span class=\"text-blue\">strcpy()</span>\n+ 结构体变量的地址是其所占存储空间的首地址，而结构体成员的地址与该成员在结构体中的所处位置和所占内存字节数有关，可以单独访问成员地址，如：&su1.studentID\n\n<div class=\"show\">\n<code>#include&lt;stdio.h&gt;\ntypedef struct date\n{\n    int year;\n    int month;\n    int day;\n}<span class=\"strong\">DATE</span>;\ntypedef struct student\n{\n    long studentID;\n    char studentName[10];\n    <span class=\"strong\">DATE</span> birthday;\n    int score[4];\n}\nint main(void){\n    STUDENT stu1={114604,\"SHIWIVI\",{1998,10,1},{111,222,333,444}};\n    STUDENT stu2;\n    <span class=\"text-blue\">stu2=stu1;//整体赋值</span>\n    //也可以对结构体成员分开赋值，整体赋值等价于下述赋值语句\n    stu2.studentID=stu1.studentID;\n    <span class=\"text-blue\">strcpy(stu2.studentName,stu1.studentName);</span>\n    stu2.birthday.year=stu1.birthday.year;\n    ...\n    stu2.score[0]=stu1.score[0];\n    ...\n    //通过键盘输入成员值时，单独访问成员变量地址\n    scanf(\"ld%\",&su1.studentID);\n    scanf(\"%s\",stu1.studentName);\n    scanf(\"%d\",&stu1.birthday.year);\n    for(int i=0;i&lt;4;i++){\n        scanf(\"%d\",&stu1.score[i]);\n    }\n    return 0;\n}\n</code></div>\n\n#### 结构体所占内存字节数\n系统为结构体变量分配内存大小时，结构体类型所占字节数，并非是所有成员所占内存字节数的总和，这是因为许多计算机系统为了提高寻址效率，处理器体系为特定的数据类型引入了<span class=\"strong\">内存对齐</span>需求，编译器为了满足处理器的对齐要求，会在较小的成员后加入补位，从而导致结构体实际所占内存字节数会比预计的多出一些字节。\n如：32位计算机体系结构，short型数据从偶数地址开始存放，int型数据则被对齐在4字节地址边界，这样就保证了一个int型数据通过一次内存操作就能被访问到，而读取存储在没有对齐地址处的32位整数，则需要两次读取操作，再从两次读取到的64位数据中提取该32位整数相关的数据，这样会导致系统性能下降\n\n因此计算结构体类型大小时一定要使用<span class=\"text-red\">sizeof()</span>运算符，不能想当然直接对各成员所占内存进行简单求和。\n\n<div class=\"show\"><code>#include&lt;stdio.h>\ntypedef struct sample {\n\tchar c1;\n\tint num;\n\tchar c2;\n}SAMPLE;\nint main(void) {\n\tSAMPLE s = { 'a',10,'b' };\n\tprintf(\"%d\", sizeof(s));//12而非6\n\treturn 0;\n}</code>\n根据内存对齐需求，如下图所示，c1和c2后会被增补3个字节补位，以达到与成员变量num内存地址对齐的要求，因此结构体变量s将占用12个字节的存储单元而非6个字节。如果将int类型改为short，则c1和c2将以short(2字节)为基准，后补1个字节空闲存储单元，s将占用6个字节内存\n\n<canvas width=\"200\" height=\"110\" id=\"canvasStruct\" style=\"display:block;width:200px;height:110px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>const canvasStruct=document.getElementById(\"canvasStruct\");\nconst ctxSt=canvasStruct.getContext('2d');\nctxSt.strokeRect(50, 10, 120, 90);\nctxSt.moveTo(50,40);\nctxSt.lineTo(170,40);\nctxSt.strokeRect(80, 10, 30, 30);\nctxSt.strokeRect(110, 10, 30, 30);\nctxSt.moveTo(50,70);\nctxSt.lineTo(170,70);\nctxSt.strokeRect(80, 70, 30, 30);\nctxSt.strokeRect(110, 70, 30, 30);\nctxSt.stroke();\nctxSt.font=\"600 13px Serif\";\nctxSt.fillText(\"成员1\", 10, 30);\nctxSt.fillText(\"c1\", 60, 30);\nctxSt.fillText(\"成员2\", 10, 60);\nctxSt.fillText(\"num\", 100, 60);\nctxSt.fillText(\"成员3\", 10, 90);\nctxSt.fillText(\"c2\", 60, 90);</script></div>\n\n#### 结构体数组\n与普通数组类似，结构体数组也可以在定义时统一初始化\n<div class=\"show\">eg:在结构体数组定义时初始化数组，如果只初始化部分数组元素，则其余数组元素会被自动赋为0值\n<code>STUDENT stu[3]={{1101,\"LiLin\",11,22,33,44},{1102,\"ZhangKe\",10,20,30,40},{1103,\"MaLong\",15,25,35,45}};//数组长度可以省略不写\n或\nstruct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n} stu[3]={{1101,\"LiLin\",11,22,33,44},{1102,\"ZhangKe\",10,20,30,40},{1103,\"MaLong\",15,25,35,45}};\n访问数组元素的方法与普通数组一样\nprintf(\"%ld\",stu[1].studentID);\n</code></div>\n\n#### 指向结构体的指针\n可以使用一个指针变量p指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址，随后，就可以使用<span class=\"text-red\">指向运算符</span>(箭头运算符)访问结构体的成员，以下三种访问结构体成员变量的方式等价：\n+ <span class=\"strong\">结构体变量.成员名</span>\n+ <span class=\"strong\">(*p).成员名</span>\n+ <span class=\"strong\">p->成员名</span>\n<div class=\"show\"><code>struct student stu1={1101,\"LiLin\",11,22,33,44};\n<span class=\"text-blue\">struct student * p=&stu1;</span>\nprintf(\"%ld\"，<span class=\"text-red\">stu1.studentID</span>);\nprintf(\"%ld\"，<span class=\"text-red\">(*p).studentID</span>);\nprintf(\"%ld\"，<span class=\"text-red\">p->studentID</span>);\n</code></div>\n\n指针也可以指向结构体数组，操作同指向普通数组类似，对指针进行的++操作会使指针指向下一个结构体数组元素\n<div class=\"show\"><code>STUDENT stu[3]={{1101,\"LiLin\",11,22,33,44},{1102,\"ZhangKe\",10,20,30,40},{1103,\"MaLong\",15,25,35,45}};\nstruct student * p=stu;\nfor(;p&lt;stu+3;p++){\n    printf(\"%s\\n\",p->studentName);\n}\n//p被定义为是指向struct student类型的指针，如果需要将其指向其他类型，可以使用强制类型转换\np=(struct student *)stu[0].studentName;\nprintf(\"%s\",p);//输出stu[0]的studentName\n//但此时p仍然保持原来的类型，p+1将指向stu[1]的studentName\nprintf(\"%s\",p+1);\n</code></div>\n\n### 共用体\n共用体(也称为联合,Union)是将不同类型的数据存放在一起，占用同一段内存的一种构造数据类型，共用体的声明形式与结构体类似：\n<div class=\"apiBox\">union 共用体名\n{\n    共用体成员\n};</div>\n\n+ 共用体类型所占内存大小取决于其成员中所占内存空间最大的成员变量\n+ 共用体同一内存段可以用来存放不同类型的数据，但在同一时间只能存放其中一种类型的成员，也就是说，同一时刻只能有一个成员起作用\n+ 共用体变量中起作用的成员是最后一个被赋值的成员，在存入一个新的成员值后，原有的成员值会被覆盖\n+ 共用体的成员一般单独赋值、调用\n+ 共用体变量的地址和其各成员的地址都是同一个地址\n+ 共用体不能进行比较操作\n+ 共用体不能作为函数参数，也不能作为函数返回值，但可以使用指向共用体变量的指针\n+ 不能只引用共用体变量，需要引用共用体的具体成员\n\n<div class=\"show\"><code>union sample\n{\n    short i;\n    char ch;\n    float f;\n};\nunion sample a;//共用体a中i,ch,f共占一段内存空间，因此a的大小由成员最大数据类型float决定，占用4个字节\na.i=10;//可以给共用体成员单独赋值\na.ch='R';\na.f=11.11;//完成上述3个赋值运算后，只有a.f有效，a.i和a.ch将被覆盖失效\n//如果在定义时初始化共用体的成员初值，C89规定只能对共用体的第一个成员进行初始化，但c99无该限制，允许按以下形式按名设置成员初值\n<span class=\"text-blue\">union sample b={.i=10,.ch='b',.f=22.22};</span>//但也只有f会生效\n</code></div>\n\n共用体可以用来存储程序中逻辑相关但情形互斥的变量，共享内存空间可以节省内存，也避免了操作失误引起的逻辑冲突。如：职工管理系统中，职工的个人婚姻状况只能有三种情况：未婚、已婚、离婚。且这三种情况应当是互斥的，此时可以用共用体来存储该数据\n<div class=\"show\">eg:未婚标识为0，已婚则记录结婚日期、配偶姓名，离婚则记录离婚日期\n<code>struct date\n{\n    int year;\n    int month;\n    int day;\n};\nstruct marriedState //已婚信息\n{\n    struct date marryDate;//记录结婚日期\n    char spouseName[20];//记录配偶姓名\n};\nstruct divorceState //离婚信息\n{\n    struct date divorceDay;//记录离婚日期\n};\n<span class=\"text-blue\">union maritalState</span> //共用体，存储婚姻状况\n{\n    int single;//未婚\n    struct marriedState married;//已婚\n    struct divorceState divorce;//离婚\n};\nstruct person\n{\n    char name[20];\n    char sex;\n    int age;\n    union maritalState marital;\n    int marryFlag; //共用体无法直接看出是哪个成员生效，因此使用一个变量标记婚姻状态\n};\n</code></div>\n\n共用体也可以用来构造混合数据结构，高效使用存储空间，如：需要存储的数据是int和float型数据的混合，可以定义如下共用体：\n<div class=\"show\"><code>typedef union\n{\n    int i;\n    float f;\n}NUMBER;\nNUMBER array[20];//既可以存储int数据，也可以存储float数据</code></div>\n\n### 枚举\n当一个变量只有几种固定的值时，就可以使用枚举表示，枚举类型的定义方法与结构体类似，需要使用enum关键字：\n<div class=\"apiBox\">enum 枚举标签名\n{\n    枚举常量\n}枚举变量名;</div>\n\n+ <span class=\"strong\">枚举常量都是整型常量</span>，除非特别指定，否则其值按顺序为0，1，2....\n+ 允许在定义时明确指定枚举常量的值，如：enum response {no=1,yes=1,none=0}，也可以只指定前几个值，其后的值会自动递增，如：enum month{Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec};\n+ 程序员在花括号内定义的枚举常量只作为标识符使用，并不代表什么含义，其值本质仍是整型常量，不是字符串\n+ 枚举常量可以作为整型值进行比较、输出操作\n+ 可以定义枚举型数组，如：enum response answers[10];\n\n<div class=\"show\"><code>enum response{no,yes,none};\nenum response res1,res2;\n或\nenum response{no,yes,none} res1,res2;\n或\nenum {no,yes,none} res1,res2;//枚举类型和枚举变量一起定义时，枚举标签可省略\n</code></div>\n\n<div class=\"show\"><code>1. 枚举变量的赋值只能从枚举常量中选取\nenum response{no,yes,none} res1,res2;\nres1=yes;//只能赋值no、yes、none中的其中一个\n2. 枚举变量可以用于条件语句，比较规则是按其定义时的整型值进行比较，默认情况下为：no=0,yes=1,none=2\nif(res1==yes)\nif(res1>none)\n3. 枚举常量的值是整型常量，因此只能作为整型值处理，而不能作为字符串来使用\nprintf(\"%d\",res1);//正确，输出res1为1\nprintf(\"%s\",res1);//错误！不能作为字符串使用，无法输出yes\n4. 虽然枚举常量都表示为整型常量，但不能直接将整型常量赋值给枚举变量，因为它们属于不同类型\nres1=2; //错误\n可以进行强制类型转换，相当于将值为2的none赋给res1，2也可以替换为表达式\nres1=(enum response)2;\n</code></div>\n\n### 指针\n#### 指针定义\n<div class=\"table\">\n\n定义|含义\n--------------|-----\nint * p       |指向整型数据的指针变量\nint *p[n]     |指针数组，数组中含n个指针\nint (*p)[n]   |二维数组的行指针，p指向含n个元素的一维数组\nint * p()     |p为返回指针的函数，该指针指向整型值\nint (*p)()    |p为指向函数的指针，该函数返回整型值\nint **p       |p为指向指针的指针，p指向的指针指向整型数据\n</div>\n\n+ <span class=\"strong\">指针</span>：一个变量的地址称为该变量的\"指针\"，反之亦然，变量的指针即变量的地址\n+ <span class=\"strong\">指针变量</span>：专门用于存放地址的变量\n+ <span class=\"strong\">&</span>：取地址运算符\n+ <span class=\"strong\">*</span>：指针运算符，取出指针变量指向的内容，又称为间接寻址运算符\n指针的定义：\n<div class=\"apiBox\">数据类型 * 变量名</div>\n\n<div class=\"show\"><code>int a=10;\nint * p;//定义int *类型的变量p，p只能用于存储地址，*只是表明该变量是指针变量\np=&a;//取出变量a的地址并存储到p中\nprintf(\"%d\",* p);//*p表示取出变量p中地址指向的内容，等价于printf(\"%d\",a)\nprintf(\"%p\",&a);//输出变量a在内存中所占存储空间的首地址，等价于printf(\"%p\",p)</code></div>\n\n使用指针的注意事项：\n+ <span class=\"text-red\">不要使用未初始化的指针变量</span>，未决定指针指向时，可以使指针变量初始化为<span class=\"text-blue\">NULL</span>(stdio.h中定义为零值的宏)\n+ 要永远清楚指针指向哪里，指针必须指向一块有意义的内存\n+ 要永远清楚每个指针指向的对象内容是什么\n\n#### 指针与数组\n使用指针操作数组可以有效提高运行速度，减小内存占用。数组在定义时，编译系统就会为其分配连续的内存单元，相应地，内存首地址也确定了。C语言中，数组名代表数组首元素的内存地址(数组名作形参时除外，此时数组名不占据内存单元)，因此可以直接将数组名赋值给指针变量\n<div class=\"show\">由于\n<ul><li>数组变量名代表数组起始内存地址</li><li>数组首元素地址也是数组起始内存地址</li></ul>因此指针初始化一般可以用两个赋值方法，两个赋值语句等价:\nint a[10]; int * p;\n<span class=\"text-red\">p=a;</span>或\n<span class=\"text-red\">p=&a[0];</span>\n</div>\n\n而后，就可以使用指针引用数组元素。对于指针变量p，p+1将指向数组的下一个元素，即地址跳到<span class=\"text-green\">1*sizeof(基类型)</span>个字节以后，而非对p中的地址进行简单加1，如：如果p指向int类型的数组，p+1会将p中的地址值增加4个字节对应的地址值，使其指向4个字节以后的空间。使用指针引用数组元素有以下特点：\n<div class=\"apiBox\">p+i和a+i均是a[i]的地址\n*(p+i)和*(a+i)均是a[i]的值\n</div>\n\n实际上，读取数组元素a[i]就是通过*(a+i)处理，即在数组首元素地址的基础上加上地址偏移量得到要找元素的地址，然后取出该地址中的数据，由此可得，<span class=\"tips\">[ ]实际上是变址运算符</span>，指向数组的指针变量也可以使用该变址运算符，如：p[i]等价于*(p+i)等价于i[p]\n<div class=\"show\">数组元素a[i]的表示方法有：\n<span class=\"strong\">a[i]</span>、<span class=\"strong\">i[a]</span>、<span class=\"strong\">p[i]</span>、<span class=\"strong\">i[p]</span>、<span class=\"strong\">*(a+i)</span>、<span class=\"strong\">*(p+i)</span>\n</div>\n\n#####  常用的指针变量运算\n+ <span class=\"strong\">\\*p++</span> 右结合，解析为*(p++)，先获得*p的值，再使p+1=>p\n+ <span class=\"strong\">\\*(++p)</span> 先对p加1，使其指向下一个元素，再获得此时*p的值\n+ <span class=\"strong\">(\\*p)++</span> 获得*p的值，并对该值加1\n+ <span class=\"strong\">\\*(p\\-\\-)，\\*(\\-\\-p)，(\\*p)\\-\\-</span> 与上类似\n\n<!-- <div class=\"show\">1. &*p等价于&a\n2. *&a等价于a\n3. (*p)++等价于a++，由于++和*同优先级且右结合，因此不能写为*p++，否则会被解析为*(p++)</div> -->\n\n##### 数组元素的遍历\n在遍历数组元素时，通过数组下标或通过数组元素地址遍历，二者执行效率是相同的，C编译系统对nums[i]的处理也是将其转换为*(nums+i)来作处理的，即根据首元素地址重新计算元素偏移地址，再访问该地址\n\n而通过指针变量遍历时，指针变量通过有规律地改变地址值(p++)，直接指向元素，不必每次都重新计算地址，极大提高了执行效率\n<div class=\"show\">遍历数组的三种方法：\nint nums[5]={11,22,33,44,55};\n//1.利用数组下标\nfor(int i=0;i&lt;5;i++){\n    printf(\"%d\",nums[i])\n}\n//2.通过求出数组元素地址，获得值\nfor(int i=0;i&lt;5;i++){\n    printf(\"%d\",*(nums+i))\n}\n<span class=\"strong\">//3.通过指针变量\nfor(int *p=nums;p&lt;(nums+5);p++){\n    printf(\"%d\",*p)\n}</span>\n注意：p++和p+1本质是两个不同的操作，特别对于指针变量而言，p++有赋值操作，会修改p的值从而使p指向下一个元素，而p+1并不改变当前指针的指向\n\n<span class=\"text-red\">数组名nums代表数组元素首地址，是一个指针常量，它的值是固定不变的，因此只能像*(nums+i)一样基于此地址进行计算,不能使用nums++改变该地址值</span>\nfor(int *p=nums;nums&lt;(p+5);nums++){//错误代码\n    printf(\"%d\",*a)\n}</div>\n\n#### 指针与函数传参\n使用指针作为函数参数时，不再是简单的<span class=\"tips\">值传递</span>，而是<span class=\"tips\">地址传递</span>，可以直接修改原参数的值\n\n<div class=\"show\">eg:将一个数组中的值反序存放并输出\n<code>#include&lt;stdio.h>\nint main(void) {\n\tvoid inv(int*, int);\n\tint nums[10] = { 0,11,22,33,44,55,66,77,88,99 };\n\tprintf(\"original array：\");\n\tfor (int* p = nums; p < nums + 10; p++) {\n\t\tprintf(\"%d \", *p);\n\t}\n    <span class=\"text-red\">inv(nums, 10);</span>\n\tprintf(\"\\ninverted array：\");\n\tfor (int* p = nums; p < nums + 10; p++) {\n\t\tprintf(\"%d \", *p);\n\t}\n\treturn 0;\n}\nvoid inv(<span class=\"text-red\">int * p,int n</span>) {//n为数组长度\n\tint temp;\n\tfor (int i = 0; i < n / 2; i++) {\n\t\ttemp = *(p+i);\n\t\t*(p + i) = *(p + n - 1 - i);\n\t\t*(p + n - 1 - i) = temp;\n\t}\n}</code>\n在函数中修改数组值，实参与形参的对应关系一般有以下4中\n1. 形参和实参都用数组名，形参接收实参的数组首地址，因此形参和实参数组共用一段内存空间。定义形参a[]时，可以不指定数组长度，因为编译器实际上是将形参数组名作为指针变量来处理，并不会真的开辟一个数组空间\nvoid inv(int a[],int n)             inv(nums,10)\n2. 实参用数组名，形参用指针变量。形参的指针初始指向数组元素首地址\nvoid inv(int *p,int n)              inv(nums,10)\n3. 实参和形参都用指针变量。实参n先指向数组首地址，再将该地址值传递给形参p，初始时两个指针指向同一个地址\nvoid inv(int *p,int n)              int *n=nums; inv(n,10)\n4. 实参为指针变量，形参为数组名。编译时，编译系统会将形参数组名作为a作为指针变量来处理，同样，初始时两个指针指向同一个地址\nvoid inv(int a[],int n)             int *n=nums; inv(n,10)\n</div>\n\n#### 二维数组与指针\n一维数组可以拓展到二维数组、三维数组等等，以二维数组为例，一个二维数组可以视为是由多个一维数组构成的，即二维数组的数组元素也是一个数组。\n\n<div class=\"show\">设一个3行4列的二维数组\n<code>{% raw %}int a[3][4]={{0,0,0,0},{11,11,11,11},{22,22,22,22}};{% endraw %}</code>\n对于该数组，可以视为数组a中包含3个元素：a[0],a[1],a[2]，而这3个元素每个都是一维数组:\n<span class=\"strong\">a[0]</span>==> a[0][0]、a[0][1]、a[0][2]、a[0][3]\n<span class=\"strong\">a[1]</span>==> a[1][0]、a[0][1]、a[0][2]、a[0][3]\n<span class=\"strong\">a[2]</span>==> a[2][0]、a[0][1]、a[0][2]、a[0][3]\n暂且忽略a[0],a[1],a[2]内部包含的内容，将它们当作普通的数组元素，由此：\n数组a是包含a[0]、a[1]、a[2]三个数组元素的一维数组，其中：\na是数组首元素a[0]的地址(即&a[0])，a+1是a[1]的地址(&a[1])，a+2是a[2]的地址(&a[2])，所以：\n<span class=\"strong\">a=&a[0]，a+1=&a[1]，a+2=&a[2]</span>;\n<span class=\"text-red\">*(a+0)=a[0]，*(a+1)=a[1]，*(a+2)=a[2]</span>;\n\n此时将a[0]、a[1]、a[2]展开，这三个元素每个都是一维数组，在这三个数组内部，a[0]、a[1]、a[2]分别是它们内部一维数组的数组名，又因为C语言中数组名代表数组首元素地址，因此：\na[0]即为a[0][0]的地址，即&a[0][0]，a[0]+1则为a[0][1]的地址 &a[0][1]......\n即：\n<span class=\"strong\">a[0]+0=&a[0][0]，a[0]+1=&a[0][1]，a[0]+2=&a[0][2]，a[0]+3=&a[0][3]</span>\n<span class=\"text-red\">\\*(a[0]+0)=a[0][0]，\\*(a[0]+1)=a[0][1]，\\*(a[0]+2)=a[0][2]，\\*(a[0]+3)=a[0][3]</span>;\n\n由于<span class=\"text-red\">a[0]和\\*a</span>等价，因此\na[0]+0与\\*(a+0)均是a[0][0]的地址，a[0]+1与\\*(a+0)+1均是a[0][1]的地址，其他同理，由此可得：\n<span class=\"text-blue\">\\*(a[0])=\\*(\\*(a+0)+0)=\\*\\*a=a[0][0]，\\*(a[0]+1)=\\*(\\*(a+0)+1)=\\*(\\*a+1)=a[0][1]</span>\n<span class=\"text-blue\">\\*(a[1]+2)=\\*(\\*(a+1)+2)=a[1][2]，\\*(a[2]+3)=\\*(\\*(a+2)+3)=a[2][3]</span>\n<span class=\"text-blue\">其他以此类推</span>\n\n<span class=\"text-red\">注意！\n对于一维数组，a[i]代表一个数组元素，占据内存单元，拥有物理地址，但在二维数组中，a[i]代表一维数组名，只是一个地址(如同一维数组中的数组名只是一个指针常量一样)，务必记住，a[i]和*(a+i)是等价的</span>\n</div>\n\n由上，总结：\n\n表示a[i][j]<span class=\"text-blue\">地址</span>的方法：\n+ <span class=\"text-blue\">a[i]+j</span>\n+ <span class=\"text-blue\">\\*(a+i)+j</span>\n+ <span class=\"text-blue\">&a[i][j]</span>\n\n表示a[i][j]<span class=\"text-red\">值</span>的方法：\n+ <span class=\"text-red\">\\*(a[i]+j)</span>\n+ <span class=\"text-red\">\\*(\\*(a+i)+j)</span>\n+ <span class=\"text-red\">(\\*(a+i))[j]</span>\n+ <span class=\"text-red\">a[i][j]</span>\n\n###### 二维数组的行指针与列指针\n<div class=\"show\">对于二维数组，其地址也可以分为行地址和列地址，如图所示：\n<div class=\"table\"><table><thead>\n<tr><th colspan=\"5\">二维数组存储</th></tr>\n</thead>\n<tbody>\n<tr style=\"color:#fb5b33;\"><td style=\"color:#056efb;\">行/列地址</td><td>a[i]+1</td><td>a[i]+2</td><td>a[i]+3</td><td>a[i]+4</td></tr>\n<tr><td style=\"color:#25ccf7;\">a+0</td><td>a[0][0]</td><td>a[0][1]</td><td>a[0][2]</td><td>a[0][3]</td></tr>\n<tr><td style=\"color:#25ccf7;\">a+1</td><td>a[1][0]</td><td>a[1][1]</td><td>a[1][2]</td><td>a[1][3]</td></tr>\n<tr><td style=\"color:#25ccf7;\">a+2</td><td>a[2][0]</td><td>a[2][1]</td><td>a[2][2]</td><td>a[2][3]</td></tr></tbody></table></div><p>其中，二维数组名a是指向行地址的，因此a+1中的\"1\"代表一个含有4个整型元素的一维数组所占存储单元的字节数，即<span class=\"text-green\">4*sizeof(int)</span>，a+1将指向下一行</p><p>一维数组名a[0]、a[1]、a[2]是指向列元素的，a[0]+1中的1代表一个整型元素所占存储单元的字节数，a[0]+1将指向下一个列元素</p><p>在指向行的指针前加一个*，就转换为指向列的指针，如：指针a和a+1是指向行的，而*a和*(a+1)则是指向列的，它们拓展为*(a+0)+0和*(a+1)+0，分别指向第0行0列元素和第1行第0列。反之，在指向列的指针前加上&，该指针就变成了指向行的指针，如：列指针a[0]指向第0行第0列的元素，而&a[0]等价于&*(a+0)，而&*a等价于a，因此&a[0]是指向第0行的行指针。注意，&a[i]不能理解为a[i]的物理地址，因为二维数组中并不存在a[i]元素，它只是一个地址计算方法，能得到第i行的起始地址。</p>\n练习：\na、a+0、&a[0]代表第0行首地址\n*a、*(a+0),a[0],a[0]+0代表第0行第0列的地址\n&a[0][0]代表第0行第0列元素地址\na[0][0]、**a代表第0行第0列元素值\na+i、&a[i]代表第i行地址\na[i]+j、\\*(a+i)+j,&a[i][j]代表第i行第j列地址\na[i][j]、\\*(\\*(a+i)+j)代表第i行第j列元素值\n</div>\n\n##### 二维数组元素的引用(指针变量)\n###### 通过二维数组的列指针变量引用\n由于列指针指向数组的具体元素，因此定义列指针与定义同类型普通指针相同：\n<span class=\"strong\">int * p</span>\n可以用以下三种等价方法对其进行初始化：\n\n+ <span class=\"strong\">p=a[0]</span>\n+ <span class=\"strong\">p=*a</span>\n+ <span class=\"strong\">p=&a[0][0]</span>\n\n此时，由于需要使用列指针对二维数组元素进行引用，因此可以将二维数组看成一个由m行*n列个元素组成的一维数组，获取第i行j列的元素，则其在一维数组中的索引为i\\*n+j，因此a[i][j]元素的地址为<span class=\"text-blue\">p+i\\*n+j</span>，其值表示方法为<span class=\"text-red\">\\*(p+i\\*n+j)</span>或<span class=\"text-red\">p[i\\*n+j]</span>\n\n注意，此时不能用p[i][j]来表示数组元素，因为给p赋初值时将其赋为了列指针，即是将二维数组作为一维数组来进行处理的，p++将使指针依次指向下一个数组元素。正因如此，在定义二维数组的列指针时，无须指定它所指向的二维数组的列数。因此二维数组的列指针也常常用作函数参数，以实现二维数组的行列数需要动态指定的场合。\n\n<div class=\"show\">eg:使用二维数组列指针引用数组元素\n<code>#include&lt;stdio.h>\nint main(void) {\n\tvoid outputArray(int *,int);\n\tint a[3][4] = { {11,11,11,11},{22,22,22,22},{33,33,33,33} };\n    <span class=\"text-red\">outputArray(a[0], 12);//列指针初始化int *p=a[0]</span>\n\t<span class=\"text-blue\">outputArray(*a, 12);//列指针初始化int *p=*a</span>\n\t<span class=\"text-green\">outputArray(&a[0][0], 12);//列指针初始化int *p=&a[0][0]</span>\n\treturn 0;\n}\nvoid outputArray(int* p, int length) {\n\tfor (int* index = p; index < p + length; index++) {\n\t\tprintf(\"%d,\", *index);\n\t}\n\tprintf(\"\\n\");\n}</code></div>\n\n###### 通过二维数组的行指针变量引用\n由于行指针不再指向数组元素，而是指向一维数组，因此行指针变量比较特殊：\n<span class=\"strong\">int (*p)[4]</span>\n可以用以下方法对其进行初始化：\n\n+ <span class=\"strong\">p=a</span>\n+ <span class=\"strong\">p=&a[0]</span>\n\n说明：定义了一个可指向含有4个元素一维整型数组的指针变量，[4]表示所指一维数组的长度，<span class=\"tips\">在声明变量时必须显式指定，不可省略!</span>该指针可以作为一个指向二维数组的行指针，且它所指向的二维数组的每一行有4个元素。注意：定义该行指针变量时( )也不可省略，因为[ ]优先级高于*，p会优先与[ ]结合，int *p[4]是指针数组的定义方式。\n可以用以下四种等价形式引用a[i][j]的值:\n+ <span class=\"strong\">p[i][j]</span>\n+ <span class=\"strong\">\\*(p[i]+j)</span>\n+ <span class=\"strong\">\\*(\\*(p+i)+j)</span>\n+ <span class=\"strong\">(\\*(p+i))[j]</span>\n\n对于行指针变量，p++将指向二维数组的下一行，即移动4\\*sizeof(int)字节，因此需要显式指定所指一维数组的长度int (\\*p)[4]，否则无法计算指针移动的字节数。\n\n<div class=\"show\">eg:使用行指针读入、输出二维数组元素\n<code>#include&lt;stdio.h>\n#define N 3\nint main(void) {\n    <span class=\"text-red\">//用普通的二维数组方式操作数组\n    void inputArray(int p[][N], int,int);\n    void outputArray(int p[][N], int,int);</span>\n\t<span class=\"text-blue\">//只使用行指针操作数组元素\n    void inputArray(int(*p)[N], int, int);\n\tvoid outputArray(int(*p)[N], int, int);</span>\n\tint a[2][3];\n\tprintf(\"Input 2*3 numbers:\\n\");\n\tinputArray(a, 2,3);//把数组行数和列数也传参\n\toutputArray(a, 2,3);\n\treturn 0;\n}\n<span class=\"text-red\">void inputArray(int p[][N], int rows,int columns) {</span>\n<span class=\"text-blue\">void inputArray(int (*p)[N], int rows, int columns) {</span>\n\tprintf(\"Input numbers:\\n\");\n\tfor (int i = 0; i < rows; i++) {\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n            <span class=\"text-red\">scanf_s(\"%d\", &p[i][j]);</span>\n            <span class=\"text-blue\">scanf_s(\"%d\", *(p+i)+j);</span>\n\t\t}\n\t}\n}\n<span class=\"text-red\">void outputArray(int p[][N], int rows, int columns) {</span>\n<span class=\"text-blue\">void outputArray(int (*p)[N], int rows, int columns) {</span>\n\tprintf(\"Output numbers:\\n\");\n\tfor (int i = 0; i < rows; i++) {\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n            <span class=\"text-red\">printf(\"%d,\", p[i][j]);</span>\n            <span class=\"text-blue\">printf(\"%d,\", *(*(p+i)+j));</span>\n\t\t}\n\t}\n}</code>\n</div>\n\n#### 指向函数的指针\n一个函数在编译时被分配一个入口地址，与数组类似，函数名代表该函数的入口地址，函数的入口地址就称为该函数的指针，可以用一个指针变量指向函数，然后通过该指针变量调用该函数，指向函数的指针变量的定义形式为：\n<span class=\"strong\">函数返回值类型 (* 指针变量名)(函数参数)</span>\n\n+ 定义举例：int (*p)(int,int)，表示定义一个指向函数的指针变量p，它可以任意指向同类型的不同函数(该函数应是int类型且有两个int参数)，并非固定指向一个函数\n+ \\*p两侧的括号不能省略，p先与\\*结合表明是指针变量，再与后面的( )结合表明该指针变量指向函数\n+ 对指向函数的指针变量进行p++、p+n等操作是无意义的\n\n<div class=\"show\">eg:\n<code>int main(void){\n    int getMax(int,int);\n    <span class=\"text-blue\">int (*p)(int,int);</span>//定义指向函数的指针\n    int a=10,b=20;\n    <span class=\"text-blue\">p=getMax;</span>//将函数地址赋给p，不涉及实参和形参问题，因此不需要写任何参数\n    int result=<span class=\"text-blue\">(*p)(a,b)</span>;//使用指针调用函数，只需用(*p)替代函数名即可\n    return 0;\n}\nint getMax(int a,int b){\n    return a>b?a:b;\n}\n</code></div>\n\n函数指针变量的用途之一是将函数作为参数传递到其他函数，即实现函数入口地址的传递，常见用法是：调用同一个函数时，在不同情况下实现不同的功能\n<div class=\"show\">eg:多次调用process函数，依次实现求最大值、求和、求积功能\n<code>#include&lt;stdio.h>\nint main(void) {\n\tint getMax(int, int);\n\tint add(int, int);\n\tint multiply(int, int);\n    <span class=\"text-blue\">void process(int, int, int (* fun)(int, int));</span>\n\tint a = 10, b = 20;\n    <span class=\"text-blue\">process(a, b, getMax);\n\tprocess(a, b, add);\n\tprocess(a, b, multiply);</span>\n\treturn 0;\n}\nvoid process(int a,int b,int (* fun)(int,int)) {\n\tint result =<span class=\"text-blue\">(*fun)(a, b)</span>;//fun指向不同函数地址，实现不同功能\n\tprintf(\"%d\\n\", result);\n}\nint getMax(int a, int b) {\n\treturn a > b ? a : b;\n}\nint add(int a, int b) {\n\treturn a + b;\n}\nint multiply(int a, int b) {\n\treturn a * b;\n}</code></div>\n\n#### 返回指针的函数\n函数除了可以返回整型值、字符值等，也可以返回一个指针(返回一个地址)，这种返回指针的函数，定义形式为:\n<span class=\"strong\">类型 * 函数名(参数)</span>\n\n+ 函数定义举例：int * fun(int,int)，定义一个函数fun，该函数返回类型为int \\*，即返回一个指针，该指针指向int类型的数据，函数名fun和\\*两侧没有( )，fun先与(int,int)结合表明fun()是个函数\n+ 通过返回指针，C语言就可以实现返回数组、字符串等数据\n\n<div class=\"show\">eg:拼接两个字符串，返回一个新的字符串\n<code>#include&lt;stdio.h>\nint main(void) {\n\tchar* str1 = \"aaa\", * str2 = \"111\";\n\tchar result[20];//存储拼接后的字符串，空间要足够大\n    <span class=\"text-blue\">char* strCat(char*, char*,char *);</span>\n\tprintf(\"%s\", strCat(result, str1, str2));\n\treturn 0;\n}\nchar* strCat(char * result,char* str1, char* str2) {\n\tchar* p = result;\n\twhile (*str1 != '\\0') {\n\t\t*p = *str1;\n\t\tstr1++;\n\t\tp++;\n\t}\n\twhile (*str2 != '\\0') {\n\t\t*p = *str2;\n\t\tstr2++;\n\t\tp++;\n\t}\n\t*p = '\\0';//拼接后的字符串末尾加上字符串结束标志符\n\treturn result;//返回result数组的初始起始地址\n}</code>\n</div>\n\n#### 指针数组\n一个数组，若其元素均为指针，则该数组为指针数组，一维指针数组的定义形式为：\n<span class=\"strong\">类型名 * 数组名[数组长度]</span>\n\n+ 如：int \\*p[4]，p先与[4]结合，形成p[4]，表明这是一个数组，再与\\*结合，表明该数组是指针类型\n+ 注意区分于int (*p)[4]，这是指向一维数组的指针变量，即指向二维数组指针变量中的行指针\n+ 指针数组可用于指向不等长字符串、不等长数组等场景\n\n<div class=\"show\">指针数组可以指向若干不等长的字符串，如果用二维数组存储字符串，需要指定第二维的长度(一般为最长字符串的长度+1)，相较于二维数组，指针数组更为灵活快捷\neg:将若干字符串按字母顺序排序\n<code>#include&lt;stdio.h>\n#include&lt;string.h>\nint main(void) {\n\tvoid sort(char* ptr[], int length);\n    <span class=\"text-blue\">char* ptr[]</span>= { \"Document\",\"ASCII\",\"Java\",\"CPP\" };\n\t sort(ptr, 4);\n\t for (int i = 0; i < 4; i++) {\n\t\t printf(\"%s\\n\", ptr[i]);\n\t }\n\treturn 0;\n}\nvoid sort(char* ptr[], int length) {\n\tchar* temp;\n\tint i, j, k;\n\tfor (i = 0; i < length-1; i++) {\n\t\tk = i;\n\t\tfor (j = i + 1; j < length; j++) {//内循环找出全部字符串中字符顺序最小的字符串\n\t\t\tif (strcmp(ptr[k], ptr[j]) > 0) {//strcmp()函数，ptr[k]中的字母在ASCII中位置大于ptr[j]，则返回值大于0\n\t\t\t\tk = j;\n\t\t\t}\n\t\t}\n\t\tif (k != i) {//如果找到的字符串不是i，调换顺序\n\t\t\ttemp = ptr[i]; ptr[i] = ptr[k]; ptr[k] = temp;\n\t\t}\n\t}\n}\n</code></div>\n\n#### 指向指针的指针\n指针变量也可以指向一个另一个指针，指向指针的指针变量定义形式为：\n<span class=\"strong\">类型 *** 变量名</span>\n\n+ 如：char **p，指针变量p指向另一个指针变量，被p指向的指针变量指向一个字符型数据\n+ 结合上一节的指针数组，就可以用指向指针的指针操作指针数组中的指针所指向的数据\n+ 理论上指向指针的指针可以无限套娃，如：int \\*\\*\\*\\*\\*p，但多层指针嵌套容易混乱，难以理解\n\n<div class=\"show\">1. eg:用指向指针的指针输出指针数组指向的内容\n<code>#include&lt;stdio.h>\nint main(void){\n    char* ptr[]= { \"Document\",\"ASCII\",\"Java\",\"CPP\" };\n    <span class=\"text-blue\"> char **p;</span>\n    for(int i=0;i&lt;4;i++){\n        p=ptr+i;\n        printf(\"%s\\n\",<span class=\"text-blue\">*p</span>);\n    }\n}</code>\n2. eg:注意输出字符串、数组数据与整型等其他普通类型数据时，指针运算符(间接寻址运算符)需要取到哪一层值(取出的值是地址值还是变量本身的值)\n<code>#include&lt;stdio.h>\nint main(void){\n\tint a = 11, b = 22;\n\tint c = a + b;\n\tint d = a + b + c;\n\tint* nums[] = { &a,&b,&c,&d };\n    <span class=\"text-blue\">int** p=nums;</span>\n\tfor (int i = 0; i < 4; i++,p++) { \n\t\tprintf(\"%d\\n\",<span class=\"text-blue\">**p</span>);\n\t}\n\treturn 0;\n}</code>\n</div>\n\n#### void * 无类型指针\nvoid *称为通用指针或无类型指针，用于声明基类型未知的指针变量，即声明了一个指针变量，但未指定它指向哪一种基类型的数据。它可以指向任意类型的数据，只需要在将它的值赋给其他类型的指针变量时，进行强制类型转换即可。ANSI标准要求动态分配内存的函数(malloc、calloc等)返回类型为void *无类型指针，方便将其转换为其他任意类型的指针变量。\n\n注意区别于<span class=\"tips\">空指针(NULL)</span>，空指针未指向任何有效内存(指向低地址保留区)，而<span class=\"tips\">void *</span>当值不为NULL时，它指向了有效内存空间，只是尚未指定它指向的基类型。\n\n<div class=\"show\">void *和其他类型的指针可以相互转换\n<code>char *str;\nvoid *p;\nstr=(char *)p;\n或\np=(void *)str;</code>\n动态分配内存函数返回值根据指向数据类型需要转换为其他类型\n<code>int * p=(int *)malloc(10*sizeof(int));</code></div>\n\n#### 指针数组与main函数的形参\n一般情况下，main函数一般会写为空参数形式：int main(void)，实际上main函数可以带有参数，如：\n<span class=\"strong\">int main(int argc,char * argv[])</span>\nJava语言中的main默认就为上述形式，argc和argv就是main函数的形参。main函数由操作系统调用，在main所在的.c文件被编译后，会生成可执行文件(windows下后缀为.exe)，在系统命令终端下(如：Linux的shell、windows的cmd)，输入<span class=\"strong\">文件路径/可执行文件名 参数1 参数2...</span>即可调用该可执行文件并将参数传递给main函数\n\n<div class=\"show\">假设main函数写于文件file.c文件中，编译后生成file.out文件\n在该文件所属路径下执行命令：<span class=\"strong\">file.out data1 data2</span>\n对于main函数原型<span class=\"strong\">int main(int argc,char * argv[])</span>\nargc指命令行中的参数个数，argv[]是存储参数字符串首地址的指针数组\n它收到3个命令行参数：file.out，data1，data2 //file.out也算一个参数\n所以argc=3，\"file.out\"、\"data1\"、\"data2\"字符串的首地址构成一个指针数组，存储于argv中：\nargv[0]--->\"file.out\\0\"\nargv[1]--->\"data1\\0\"\nargv[2]--->\"data2\\0\"\n由于并不清楚输入的参数会多长，使用指针数组就可以巧妙解决这个问题\n可以写一个main函数输出执行时传入的参数内容：\n<code>int main(int argc,char * argv[]){\n    while(argc&gt;1){\n         ++argv;\n        printf(\"%s\\n\",*argv);\n        --argc;\n    }\n}</code>\n</div>\n\n### 运算符\n#### 运算符优先级与结合性\n<div class=\"table\">\n<table>\n<thead>\n<tr><th>优先级</th><th>运算符</th><th>名称</th>\n<th>使用</th><th>说明</th><th>结合方式</th></tr>\n</thead>\n<tbody>\n<tr><td rowspan=\"4\">1</td><td>[&nbsp;]</td><td>数组下标</td><td>数组名[]</td><td rowspan=\"4\"></td><td rowspan=\"4\">从左到右</td></tr>\n<tr><td>(&nbsp;)</td><td>圆括号</td><td>(表达式)</td></tr>\n</tr><td>.</td><td>成员选择（对象）</td><td>对象.成员名</td></tr>\n</tr><td>-&gt;</td><td>成员选择（指针）</td><td>对象指针->成员名</td></tr>\n<tr><td rowspan=\"9\">2</td><td>-</td><td>负号</td><td>-表达式</td><td rowspan=\"9\">单目运算符</td><td rowspan=\"9\"><span class=\"tips\">从右到左</span></td></tr>\n<tr><td>(类型)</td><td>类型转换</td><td>(数据类型)表达式</td></tr>\n<tr><td>sizeof(&nbsp;)</td><td>长度运算符</td><td>sizeof(表达式)</td></tr>\n<tr><td>！</td><td>逻辑非</td><td>!表达式</td></tr>\n<tr><td>~</td><td>按位取反</td><td>~表达式</td></tr>\n<tr><td>*</td><td>取值</td><td>*指针变量</td></tr>\n<tr><td>&</td><td>取地址运算符</td><td>&变量名</td></tr>\n<tr><td>++</td><td>自增</td><td>++变量名或\n变量名++</td></tr>\n<tr><td>--</td><td>自减</td><td>--变量名或变量名--</td></tr>\n<tr><td rowspan=\"3\">3</td><td>*</td><td>乘</td><td>表达式*表达式</td><td rowspan=\"3\">双目运算符</td><td rowspan=\"3\">从左到右</td></tr>\n<tr><td>/</td><td>除</td><td>表达式/表达式</td></tr>\n<tr><td>%</td><td>求余</td><td>表达式%表达式</td></tr>\n<tr><td rowspan=\"2\">4</td><td>+</td><td>加</td><td>表达式+表达式</td><td rowspan=\"2\">双目运算符</td><td rowspan=\"2\">从左到右</td></tr>\n<tr><td>-</td><td>减</td><td>a-b</td></tr>\n<tr><td rowspan=\"2\">5</td><td>&lt;&lt;</td><td>左移</td><td>变量&lt;&lt;表达式</td><td rowspan=\"2\">双目运算符</td><td rowspan=\"2\">从左到右</td></tr>\n<tr><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td></tr>\n<tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=</td><td>关系运算(大于，大于等于，小于，小于等于)</td><td>a&lt;b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>7</td><td>==、!=</td><td>是否等于</td><td>if(a==b)</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>8</td><td>&</td><td>按位与</td><td>a&b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>9</td><td>^</td><td>按位异或</td><td>a^b</td>\n<td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>10</td><td>|</td><td>按位或</td><td>a|b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>11</td><td>&&</td><td>逻辑与</td><td>a&&b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>12</td><td>||</td><td>逻辑或</td><td>a||b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>13</td><td>?&nbsp;:</td><td>条件运算</td><td>a>b?true:false</td><td>三目运算符</td><td><span class=\"tips\">从右到左</span></td></tr>\n<tr><td rowspan=\"2\">14</td><td>=</td><td>赋值运算</td><td>a=10</td><td rowspan=\"2\">双目运算符</td><td rowspan=\"2\"><span class=\"tips\">从右到左</span></td></tr>\n<tr><td>+=、-=、*=、/=、%=、>>=、<<=、&=、^=、|=</td><td>运算后赋值</td><td>a+=10</td></tr>\n<tr><td>15</td><td>,</td><td>逗号运算符(按顺序求值)</td><td>a,b,c</td><td></td><td>从左到右</td></tr>\n</tbody>\n</table>\n</div>\n\n#### 赋值与复合赋值\n静态变量和全局变量的赋值在编译阶段进行，而局部自动变量的赋值在程序运行到该语句时进行。赋值语句遵循<span class=\"tips\">右结合</span>原则(从右向左运算)\n<div class=\"show\">1. 赋值遵循右结合\nint a,b,c;\na=b=c=0;执行过程为a=(b=(c=0))\n2. 复合赋值\nn*=m+1;\n等价于n=n*(m+1)\n3. 复合赋值会即时修改变量值\nint a=3;\na+=a-=a*a;//执行完a=-12\na+=a-=a*=a;//执行完a=0\n</div>\n\n赋值语句需要注意：将字节数长的数据赋值给字节数短的变量，会截取部分数据，也可能造成整个数据错误\n+ 浮点型(float、double)数据赋值给整型变量，将舍弃小数部分\n+ 将double数据赋值给float变量，将截取前7位有效数字\n+ 将int、short、long型数据赋值给char变量，只截取该数据的低8位到char变量中\n+ 将unsigned 数据赋值给有符号整型时，进行高位补0即可，但如果该unsigned 数据的数值超出了有符号整型最大值范围时，会产生数据错误!\n\n将字节数短的数据赋值给字节数长的变量，一般需要进行位拓展\n+ 将整型数据赋值给浮点型变量，数值不变，拓展小数部分为0以浮点数形式进行存储\n+ 将float数据赋值给double，数值不变，拓展有效位数\n+ 将char数据赋值给整型变量，将char的1个字节数据存储到低8位，如果该整型变量为无符号整型(unsigned)，则高8位补0。如果该整型变量为有符号整型，且该char字符最高位为0，则高8位补0，若char字符最高位为1，则高8位补1，以保证char对应的数值不变\n+ 将带符号的int赋值给long型变量，将int的值存入long的低16位，如果int为正整数(最高位为0)，则long的高16位补0，反之补1\n\n#### 自增与自减\n用于对变量进行加1或减1操作，自增和自减运算符都属于一元运算符，只需要一个操作数，且<span class=\"tips\">操作数必须是变量，不能是常量或表达式</span>。自增与自减运算符分为前缀(如++i)和后缀(i++)形式。区别在于前缀是先对变量进行加1操作，再使用变量。后缀形式是先使用变量的当前值，再进行加1操作，自减运算符同理。\n<div class=\"show\">-i++;//应当解析为-(i++)，而非(-i)++，因为自增运算符操作数不能为表达式-i，(-i)++是非法语句\ni+++j;//应当解析为(i++)+j，C编译系统会从左至右尽可能多地将若干个字符组成一个运算符\n</div>\n\n#### 逗号表达式\n<span class=\"strong\">表达式1,表达式2,...表达式n</span>\n用于串联多个表达式，表达式从左至右顺序运算，<span class=\"tips\">整个逗号表达式的值是最后一个表达式的值</span><span class=\"tips\"></span>。多数情况下，逗号表达式仅用来顺序求值，并不一定用到整个逗号表达式的最终值。常见的情况是用于for语句进行多个变量的顺序运算，<span class=\"tips\">逗号表达式的运算优先级是所有运算种最低的</span>。\n\n<div class=\"show\">a=2*5,a*4;//逗号表达式运算优先级最低，所以a=10，整个逗号表达式值等于40\nb=(a=2*5,a*4);//正确获得逗号表达式值的方法，运算结果：a=10,b=40\n(a=3*5,a*4),a+5;//逗号表达式也可以嵌套到其他的逗号表达式中，运算结果：a=15，逗号表达式=20\nfor(i=0,j=0;i&lt;array.length,j&lt;i;i++,j++);//逗号表达式常用于for语句多变量运算\nprintf(\"%d,%d,%d\",a,b,c);//逗号用于间隔函数参数,并不是逗号表达式\nprintf(\"%d,%d,%d\",(a,b,c),b,c);//(a,b,c)是逗号表达式，输出值为c的值\n</div>\n\n#### 位运算\n位运算是直接对二进制位进行运算，<span class=\"tips\">只能用于整型或字符型数据</span>，不能用于浮点型，位运算符常用于编写系统软件。对于需要两个操作数的位运算，如果给的两个操作数长度不同，则系统将给较短的操作数高位补0或1，以保证两个操作数长度相同。如果该数是无符号数或者正数，则高位补0，如果为负数则高位补1。\n###### 取反~\n取反运算为单目运算符，用于将二进制数按位取反,eg:~12=-13\n\n###### 按位与&\n对两个数的二进制码进行按位与，该运算有一些特殊用途：\n+ 数据清零，使之与0相与即可将所有二进制位置为0\n+ 保留或截取一个数中的某些指定位\n\n<div class=\"show\">1. 正数取原码相与，负数取其补码相与\n3&5=1\n   0000 0011\n   0000 0101\n ------------\n   0000 0001  \n2. 若要保留一个数的低4位，将其与0000 1111相与\n  1100 1011\n  0000 1111\n -----------\n  0000 1011 </div>\n\n###### 按位或|\n可用于将指定的二进制位置为1\n\n###### 按位异或^\n\n+ 使指定二进制位翻转\n+ 交换两个值，不使用临时变量\n+ 一个数与0相^，保留原值\n+ 一个数同本身相^，结果为0\n\n<div class=\"show\">1.使0100 1011的低四位翻转，可以与0000 1111相异或\n0100 1011\n0000 1111\n----------\n0100 0100\n2. 异或可以交换两个值，且不使用临时变量\neg:a=3,b=4;交换a与b的值，可以使用：\na=a^b;\nb=b^a;\na=a^b;\n解析：\n由上述语句1,2可得：b=b^a=b^(a^b)=a^b^b=a^0=a;\n即b获得了a的值\n由语句3可得：a=(a^b)^(a^b^b)=a^a^b^b^b=b;\n</div>\n\n###### 左移运算符&lt;&lt;\n将一个数的二进制位左移若干位，高位溢出部分舍弃，低位补0。一个数左移n位，如果左边被舍弃的部分全为0，则该数相当于乘以2<sup>n</sup>\n<div class=\"show\">int result = 30&lt;&lt;2;//result=120</div>\n\n###### 右移运算符&gt;&gt;\n将一个数的二进制位右移若干位，低位溢出部分舍弃，高位补的值取决于该数值本身。如果是无符号数，或者该数符号位为0(该数为正)，则高位补0，如果该数为负数，高位补0还是补1取决于编译器，补0称为\"逻辑右移\"，补1称为\"算术右移\"。\n\n同理，如果右边移除部分均为0，则右移n位相当于该数除以2<sup>n</sup>\n\n###### 位运算赋值运算符\n位运算和赋值运算可以组成复合赋值运算符，如：&=、|=、&lt;&lt;=、&gt;&gt;=、^=等\n<div class=\"show\">a&lt;&lt;=2等价于a=a&lt;&lt;2</div>\n\n#### 关系运算符\n注意，关系运算符的优先级<span class=\"tips\">低于</span>算术运算符，<span class=\"tips\">高于</span>赋值运算符，且关系运算符中<span class=\"tips\">&lt;</span>、<span class=\"tips\">&lt;=</span>、<span class=\"tips\">&gt;</span>、<span class=\"tips\">&gt;=</span>的优先级是高于<span class=\"tips\">==</span>、<span class=\"tips\">!=</span>的\n\n<div class=\"show\">c&lt;a+b等价于c&lt;(a+b)\na=b&gt;c等价于a=(b&gt;c)\na==b&lt;c应当等价于a==(a&lt;c)\n</div>\n\n#### 逻辑运算\n逻辑运算符中优先级顺序为<span class=\"tips\">!高于&&高于||</span>，且&&和||有<span class=\"tips\">短路特性</span>\n\nC语言中没有逻辑常量true和false，编译器在表示逻辑时使用1代表真，0代表假，在表示数值时，以非0代表真，0代表假\n<div class=\"show\">优先计算!，再计算&&，最后计算||\n!a&&b||x>y&&c\n</div>\n\n#### 条件运算(三元表达式)\n<span class=\"strong\">条件判断语句?表达式1:表达式2</span>\n先求解条件判断语句，若为真则执行表达式1，整个条件表达式的值\n为表达式1的值，否则执行表达式2并作为条件表达式的值\n\n<div class=\"show\">1. 条件运算符优先级高于赋值\nmax=a>b?a:b;等价于max=(a>b?a:b);\n2. 条件运算符结合方向为从右至左\na>b?c:d>e?f:g;等价于a>b?c:(d>e?f:g)\n</div>\n\n### 选择与循环控制\n#### 选择语句\n<span class=\"tips\">if()..else</span>、<span class=\"tips\">while()</span>、<span class=\"tips\">do...while()</span>、<span class=\"tips\">for</span>\n\n##### switch多分支选择\n<div class=\"apiBox\">switch(表达式)\n  {\n    case 常量表达式:语句1\n    case 常量表达式:语句2\n    ....\n    default:       语句n\n}</div>\n\n+ case语句只起语句标号的作用，并不是在该处进行条件判断\n+ switch语句表达式的值找到匹配的case入口标号后，会一直执行下去，不再进行判断，直到执行完或遇到break语句\n\n<div class=\"show\">1.满足匹配条件后，将依次执行后面的所有case语句，所以需要及时break。并且由于是依次执行，所以case后面是多个语句也不需要使用{ }括起来\nswitch(num)\n  {\n    case 1:printf(\"get 1\");//如果num=1，则将输出get1、get2\n    case 2:printf(\"get 2\");break;\n    case 3:{printf(\"get 3\");break;}//可以不使用{ }\n    default:printf(\"error\\n\");\n}\n2. 多个分支可以共用一个执行语句\nswitch(num)\n  {\n    case 1:\n    case 2:\n    case 3:printf(\"down\");break;\n    default:printf(\"error\\n\");\n}\n</div>\n\n##### break与continue\nbreak用于终止循环和跳出switch，只能用于循环语句和switch语句。continue用于结束本次循环，代码将继续下一次循环判定。使用goto语句的形成的循环体不能使用这两个语句跳出循环。\n<div class=\"show\">while(i&lt;10){\n    if(i==5) break;\n    .....\n    i++;\n}\nwhile(i&lt;10){\n     i++;\n    if(i==5) continue;\n    .....\n}\n</div>\n\n##### goto语句\ngoto语句为无条件转向语句，语法为：\n<div class=\"apiBox\">goto 语句标号;</div>\n\n语句标号用标识符表示，命名规则同变量，常用于组成循环，或者从循环内部跳出循环，但会导致程序可读性差，结构混乱，应当谨慎使用。\n<div class=\"show\">int i,sum;\ni=sum=0;\nloop:if(i&lt;10){\n    sum+=i;\n    i++;\n    goto loop;\n}\n</div>\n\n### 函数\n#### main函数\n谭浩强书的主函数一般写为void man()，但C语言标准(C99)定义的标准main函数写法为\n<div class=\"apiBox\">int main(void){\n    .....\nreturn 0; \n}\n或者\nint main(int argc,char argv[]){.....return 0;}\n</div>\n\n<div class=\"show\">在C语言中\nint main()表示主函数可以传入任意个数的参数，而int main(void)表示该函数参数为空，不能传入任何参数\n在C++中，int main()和int main(void)等效\n</div>\n\n#### 标准输入输出函数\nC语言本身不提供输入输出语句，输入输出操作由C函数库中的函数提供支持。这是因为输入输出涉及到硬件操作，没有输入输出语句可以让C语言编译器避免在编译阶段处理硬件有关的问题，可以极大地简化编译系统，并提高其通用性和可移植性。\n\nC函数库由各软件公司编写，并已经编译成目标文件(.obj文件)，源程序中的printf()等语句在编译阶段并不会被编译为目标指令，而是等待链接阶段源程序和库函数链接后，在执行阶段直接调用库函数目标文件(.obj文件)中的printf()函数。不同函数库提供的函数名、功能完全不同，但有一些通用的\"标准输入输出函数\"，调用这些函数需要引入头文件<span class=\"tips\">#inculde&lt;stdio.h></span>\n\n##### printf输出函数\n标准输出语句格式为：\n<div class=\"apiBox\">printf(\"格式控制\",输出表列)</div>\n\n输出表列即需要输出的数据，多个输出的数据使用<span class=\"tips\">,</span>分隔，可以为表达式；格式控制需要使用双引号括起来，可以包括两种信息\n+ 普通字符：printf会原样输出普通字符，包括空格、换行符等\n+ 格式字符：由%和格式字符组成，用于指定输出数据的格式\n\n<div class=\"show\">用于输出整型、浮点型、指数的格式字符:\n1.<span class=\"tips\">%d或%i</span>，用于输出int类型(-32768~32767之间)的十进制整数\n2.<span class=\"tips\">%ld</span>，输出长整型。%hd输出short类型，%I64d输出long long类型\n3.<span class=\"tips\">%md</span>,m用于指定宽度，若数据位数大于m则将原数据正常输出，小于m则左补空格\n<code>eg: a=12345,b=123\nprintf(\"%4d,%4d\",a,b);//输出12345, 123(123前补个空格)</code>\n4.<span class=\"tips\">%o,%x,%X</span>，以八进制、十六进制(字母小写)、十六进制(字母大写)形式输出整型(不输出前导符0和0x)，该输出方式会将符号位也作为八进制和十六进制的数值位输出，因此无法输出负数，输出时支持指定输出位数。同样,八进制和十六进制支持用<span class=\"tips\">l</span>(long)、<span class=\"tips\">h</span>(short)、<span class=\"tips\">m</span>(输出位宽)修饰\n5.<span class=\"tips\">%u</span>，输出无符号(unsigned)整型，%lu输出unsigned long类型\n6.<span class=\"tips\">%c</span>，输出一个字符，支持将0~255内的整数输出为ASCII码对应字符，也支持将这些字符输出为整数\n7.<span class=\"tips\">%s</span>，输出字符串\n<ul style=\"white-space: normal;\">\n<li><span class=\"strong\">%ms</span>，指定输出的字符个数，若字符串串长大于m则原样输出字符串，若小于m则左补空格</li>\n<li><span class=\"strong\">%-ms</span>，同上，但是右补空格</li>\n<li><span class=\"strong\">%m.ns</span>，输出m个字符，但只取字符串左端n个字符，右对齐，左补空格</li>\n<li><span class=\"strong\">%-m.ns</span>，同上，但左对齐，右补空格</li>\n</ul><code>eg：\nprintf(\"%5.2s\",\"china\");//输出   ch(左补3个空格)\nprintf(\"%4.2s\",\"china\");//输出  ch(右补2个空格)\nprintf(\"%-5.2s\",\"china\");//输出ch   (右补3个空格)\n</code>\n8.<span class=\"tips\">%f</span>，输出浮点数(包括单、双精度)，输出全部整数部分，并输出6位小数。单精度浮点数有效位数一般为7位，双精度浮点数有效位数一般为16位，给出小数6位。\n<ul style=\"white-space: normal;\">\n<li><span class=\"strong\">%m.nf</span>，输出m列(小数点算一列)，其中保留有n位小数(四舍五入)，左补空格</li>\n<li><span class=\"strong\">%-m.nf</span>，同上，但左对齐，右补空格</li>\n<li><span class=\"strong\">%.nf</span>，省略m，即输出所有整数部分，保留n位小数</li>\n</ul><code>eg：float a=123.456\nprintf(\"%f\",a);//输出123.456001，输出6位小数，有一定存储误差\nprintf(\"%8.2f\",a);//输出  123.46，左补2个空格，保留2位小数，小数四舍五入\nprintf(\"%-8.2f\",a);//输出123.46  ，右补2个空格\nprintf(\"%.2f\",a);//输出123.46，整数部分全部输出，小数部分保留2位 \nfloat x,y;\nx=111111.111,y=222222.222;\nprintf(\"%f\",x+y);//输出333333.328125，只有前7位有效\n</code>\n9. <span class=\"tips\">%e或%E</span>，以规格化指数形式输出小数，e和E分别表示指数e的大小写形式，可以使用<span class=\"tips\">%m.ne或%m.nE</span>形式指定输出位数和数字部分的小数位数，一般默认数字部分的小数数位为6位，指数部分为5位(如：e+002)\n<code>printf(\"%e\",123.456);\nprintf(\"%e\",123.456);//输出1.234560e+002，默认数字部分6位小数\nprintf(\"%10.2E\",123.456);//输出 1.23E+002，左补1个空格，数字部分的小数保留2位，注意：小数点、e、+等字符均占用一个位置</code>\n10.<span class=\"tips\">%g或%G</span>，根据数值大小自动选择使用%f或%e形式，保证输出宽度最小，不输出无意义的0\n11.<span class=\"tips\">%%</span>，输出%\n12.<span class=\"tips\">%p</span>，以十六进制无符号整数形式输出变量或指针变量的地址\n<code>int num = 10;\nint* p;\np = &num ;\nprintf(\"%p\\n\", &num);//输出结果参考:001DFB0C\nprintf(\"%p\\n\", p);</code>\n</div>\n\n##### scanf输入函数\n标准输入语句格式为：\n<div class=\"apiBox\">scanf(\"格式控制\",地址表列)</div>\n\n格式控制与printf()函数的格式控制类似，如果格式控制中有格式说明以外的字符，则输入数据时需要在对应位置输入相同的字符；地址表列可以为变量地址、字符串首地址，通常需要用取地址符<span class=\"tips\">&</span>加以引导，多个地址参数使用<span class=\"tips\">,</span>分隔。\n\n<div class=\"table\">\n\n格式输入符|说明\n---------|------\n%d或%i   |输入有符号十进制整数\n%I64d    |输入long long类型整数\n%u       |输入无符号十进制整数\n%o       |输入无符号八进制整数\n%x或%X   |输入无符号十六进制整数\n%c       |输入一个字符，空白字符、回车、制表符也视为有效字符\n%s       |输入字符串，输入空白字符、回车、制表符会被认为输入结束，但开头输入空白字符会被系统跳过\n%f       |输入小数，可以用小数形式或指数形式\n%e,%E,%g,%G|与%f相同，大小写作用相同\n%%       |输入一个%\n</div>\n<div class=\"table\">\n\n格式修饰符|说明\n---------|------\nl        |用于输入长整型数据(%ld,%lo,%lx,%lu)和double型数据(%lf,%le)\nh        |用于输入短整型数据(%hd,%ho,%hx)\n域宽m(正整数)|指定输入数据的宽度(列数)，系统根据此宽度自动截取数据\n\\*        |忽略输入修饰符，表示对应的输入项在读入后不赋给相应变量\n</div>\n\n用scanf()输入数据时，遇到以下情况会被认为数据输入结束：\n+ 遇到空格符、回车符、制表符(Tab)\n+ 达到输入域宽\n+ 遇到非法字符输入\n\n<div class=\"show\">1. 格式控制中有普通字符，则输入数据时也要输入对应字符(包括空格)\nscanf(\"a=%d,b=%d\",&a,&b);//输入形式必须为a=10,b=20\n2. 可以指定输入数据所占的列宽，系统会自动截取\nscanf(\"%3d%3d\",&a,&b);//输入123456a1，则123赋值给a，456赋值给b，多余部分a1抛弃\n3. 可以用*跳过指定列数\nscanf(\"%d%*c%d\",&a,&b);//输入123 456，则123赋值给a，456赋值给b，中间的空格符根据%*c跳过\nscanf(\"%2d%*3d%2d\",&a,&b);//输入1234567，则12赋值给a，345被忽略，67赋值给b\n4. scanf()函数的返回值一般为正确读入数据的个数\nscanf(\"%2d%2d\",&a,&b);//输入1234返回值为2\nscanf(\"%2d%2d\",&a,&b);//输入12a,只给a读入了正确值，返回值为1\nscanf(\"%2d%2d\",&a,&b);//输入a，返回值为0\n</div>\n\n##### putchar()与getchar()\n用于输入或输出一个字符，只能用于处理字符\n+ <span class=\"strong\">getchar() 输入一个字符，无参数</span>\n+ <span class=\"strong\">putchar(参数) 输出一个字符，参数可以为字符变量、整型变量，也可以为一个字符常量或转义字符</span>\n\n<div class=\"show\">char a;\na=getchar();\nputchar(a);\nputchar('a');\nputchar('\\n');\n</div>\n\n#### 自定义函数\n##### 函数定义\n自定义函数的定义语法为：\n<div class=\"apiBox\">返回值类型 函数名(类型 形参1,....){\n        /*函数体*/\n}\n</div>\n\n+ 函数返回值只能有一个，返回值类型可以是除数组外的任何类型\n+ 函数无返回值时，返回值类型需要声明为<span class=\"strong\">void</span>，可以不需要return语句，但通常会以 <span class=\"tips\">return;</span>作为程序结束语句，表示程序正常执行结束且返回值为空，这是一种良好的编程习惯\n+ 如果函数返回值和函数定义时声明的返回值类型不同，则将以函数类型为准，系统自动进行数据转换\n+ 在定义函数时如果不指定返回值类型，系统会隐含指定为int型\n+ 函数名的命名规则与变量相同\n+ 形参(形式参数)必须指定类型，但变量名任意\n+ 形参在函数调用前，不占用存储单元，函数调用时才被分配内存，并在执行完后会被回收\n\n##### 函数调用\n函数调用语法：\n<div class=\"apiBox\">函数名(实参1,....)</div>\n\n+ 实参(实际参数)可以为常量，或者有确定值的变量或表达式\n+ 实参和形参的数据类型应该相同，或者<span class=\"tips\">赋值兼容</span>(参考赋值一节的赋值规则，如字符型和整型相互通用)，但应该尽量避免使用赋值兼容\n\n<div class=\"show\"><code>#include&lt;stdio.h>\n//函数定义时不指定返回值类型，隐含为int类型\n//用Visual Studio编译这段代码时，会有提示warning C4013: “getMax”未定义；假设外部返回 int\ngetMax(int a, int b) {\n\treturn a > b ? a : b;\n}\nint main(void) {\n\tprintf(\"%d\", getMax(10, 20));\n\treturn 0;\n}</code>\n</div>\n\n##### 函数声明\n又称<span class=\"strong\">函数原型</span>(Function Prototype)声明，其作用是将函数名、函数类型、形参类型、个数和顺序通知编译系统，以便调用该函数时系统按此进行对照检查。函数声明语法：\n<div class=\"apiBox\">函数类型 函数名(形参1,....)</div>\n\n+ 如果被调用的函数定义在主调函数之前，可以不加声明，编译器会根据函数定义时首部提供的信息对函数调用作准确性检查\n+ 如果被调用函数类型为整型，也可以不加声明\n+ 函数声明可以在文件开头(所有函数前)，也可以在主调函数中\n+ 对于形参，编译器只检查形参类型和个数，不检查参数名，因此参数名任意，也可以省略\n\n<div class=\"show\"><code>#include&lt;stdio.h>\nint main(void) {\n\tint  getMax(int, int);//原型声明\n\tprintf(\"%d\", getMax(10, 20));\n\treturn 0;\n}\nint getMax(int a, int b) {\n\treturn a > b ? a : b;\n}\n</code></div>\n\n#### 内部函数与外部函数\n<span class=\"strong\">外部函数：</span>定义函数时，可以在函数返回值类型前加上<span class=\"text-blue\">extern</span>将其定义为外部函数，extern可以省略，因此如果函数未特意声明为内部函数，则默认隐含为外部函数，即<span class=\"tips\">C语言中，函数默认为外部函数</span>，外部函数可以被其他文件调用，只需要在要调用此函数的文件中，用extern作函数原型声明即可，其中函数原型声明前的extern也可以省略\n\n<span class=\"strong\">内部函数：</span>又称静态函数，定义函数时在函数首部添加<span class=\"text-blue\">static</span>修饰即可定义内部函数，内部函数作用域仅限于本文件，不能被其他文件调用，不同的文件可以有同名的内部函数，互不干扰\n\n<div class=\"show\">eg:文件file1.c调用文件file2.c中的函数\nfile1.c\n<code>#include&lt;stdio.h&gt;\nint main(void)\n{\n    <span class=\"text-blue\"> extern void getStrings(char str[]);</span>//extern可以省略，写为void getString(char str[])\n    <span class=\"text-red\">static void test();</span>//调用内部函数需要static声明\n    char str[50];\n    getStrings(str);\n    printf(\"%s\\n\", str);\n    test();//调用本文件中的test()函数\n    return 0;\n}\n<span class=\"text-red\">static void test()</span>//内部函数，仅供本文件调用\n{\n    printf(\"file1.c\");\n    return;\n}</code>\nfile2.c\n<code>#include&lt;stdio.h&gt;\n<span class=\"text-blue\">extern void getStrings(char str[])</span>//extern 可以省略\n{\n    gets(str);\n}\n<span class=\"text-red\">static void test()</span>//内部函数，可以与file1.c中的test()函数同名\n{\n    printf(\"file2.c\");\n    return;\n}</code></div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n由此可见，声明函数原型的作用除了在调用时作准确性检查，还可以拓展函数作用域到定义本函数的文件之外，只要在所有调用该函数的文件中作一个函数原型声明即可。如：各种库提供的头文件中，就包含了大量函数及其函数原型声明，我们只需要使用#include命令将其包含到我们的c文件中，就可以不需要了解其函数和函数原型，就直接使用该函数。原型声明时extern可以省略，但我们自己编写头文件中的原型声明时应当保留extern关键字来保证代码清晰性。</div>\n\n### 类型限定符\nC语言中，类型限定符用于指定数据的访问属性。常见的类型限定符包括<span class=\"tips\">const</span>(常量)、<span class=\"tips\">volatile</span>(易变的)、<span class=\"tips\">restrict</span>(限定)和<span class=\"tips\">_Atomic</span>(原子)\n#### const\n##### const修饰变量\nconst用于限定变量的值不能被修改，表明变量中存储的值是一个常量，这类变量本质是变量，但又有常量属性，因此又称为\"常变量\"，const修饰的常变量必须在定义的同时赋值，而后其值就不能再改变，任何赋值行为都将引发错误。定义常变量时，const和变量类型位置可以互换，因此以下两个语句等价：\n<div class=\"show\"><code>const int num=100;\nint const num=100;</code></div>\n\n全局常变量存储于静态存储区的.rodata段，而局部常变量存储于栈内存中。对于局部常变量，由于栈内存本身是可读写的，所以即便编译器会对const修饰的局部变量进行内存保护，防止该变量的值被修改，但我们依然可以用其他方法修改该变量的值：\n<div class=\"show\"><code>const int num=100;\nint *p=&num ;\n*p=0;\nprintf(\"%d\",num);//num值被修改为0\n</code></div>\n这种通过指针来间接操作访问和操作指针所指对象值的方法称为指针解引用(dereference)，C语言标准明确指出，通过指针解引用的方式去修改一个const修饰的变量，其行为是未定义的，因此对于局部常变量，我们不应该通过该方法修改其值。对于全局常变量，数据存储于.rodata段，该段内存只有读权限，通过任何方法修改数据都会抛出写入访问权限冲突异常，在某些嵌入式系统中，全局常变量和代码会被一起存入ROM存储介质中无法修改。\n\n##### const修饰数组\n对于数组，由于数组名本身就代表数组起始地址，是一个地址常量，不能被任何限定符修饰，因此const修饰数组时，将用于修饰数组元素，即const修饰数组时，数组元素为常量无法修改\n<div class=\"show\"><code>const int nums[] = { 10,20,30,40,50 };\n<span class=\"text-red\">nums[2] *= 10;//错误！无法修改</span></code></div>\n\n##### const修饰复合类型\nconst修饰结构体、枚举等复合类型时，表示该类型中的所有成员值不能被修改\n<div class=\"show\"><code>struct test {\n\t\tint a;\n\t\tint b;\n\t};\n\tconst struct test num = { 10,20 };\n或\n    const struct test {\n\t\tint a;\n\t\tint b;\n\t} num = {10,20};\n或\nstruct test {\n\t\tint a;\n\t\tint b;\n\t} const num = {10,20};\n初始化完毕成员变量值不能再被修改\n<span class=\"text-red\">num.a=100;//错误！不能修改成员值</span></code></div>\n\n##### 指针与const类型限定符\n指针常用来在函数间传递数据，方便调用者直接对数据进行操作，但有时我们只希望将数据传到函数内部，而不希望它们在函数内被修改，此时，我们可以使用<span class=\"tips\">const</span>对参数进行限定\n<div class=\"show\">const位于声明语句的不同位置，将表示不同的含义，以int类型为例：\n<code>int a,b;</code>\n1. const放在类型关键字前面\n<span class=\"text-blue\">const int * p=&a;</span>\n按从右到左解析为：p是一个指针变量，可指向一个整型常量，*p是一个常量，而p不是。即*p的值是不可修改的，无法用*p=10;等方式重新赋值，但指针变量p的指向是可以被修改的，即p=&b是允许的\n2. const位于类型关键字后*变量名前\n<span class=\"text-blue\">int const *p=&a;</span>\n按从右到左解析为：p是一个指针常量，可以指向一个常量整数，同样*p是一个常量，而p不是，不能用指针变量p去修改这个\"为常量的整数\"，与第一种情况作用相同\n3. const位于*后，变量名前\n<span class=\"text-blue\">int * const p=&a;</span>\n按从右到左解析为：p是一个指针常量，可以指向一个整型数据，它表明p是一个常量，而*p不是。由于p是常量指针，因此不能修改p的指向，p=&b操作是非法的，但*p=20是合法的\n4. 两个const修饰，一个位于类型关键字前，一个位于*后\n<span class=\"text-blue\">const int * const p=&a;</span>\n按从右到左解析为：p是一个指针常量，可指向一个整型常量，它表明p和*p都是常量，是只读的，*p=20和p=&b操作都是非法的\n上述四种用法中，第一种用法较为常用，C语言很多库函数都使用该方法，只允许函数访问该指针指向的内容，不允许修改其内容，如：\n<code>int puts(const char * str);\nint printf(const char * format , ...);</code></div>\n\n对于被const限制的指针变量，不能将普通指针变量赋值给被限制的指针变量，但反过来可以，如：<span class=\"tips\">const char *</span>和<span class=\"tips\">char *</span>是不同的类型，const char *指向的数据只有读取权限，而char *指向的数据有读写权限，因此不能将const char *赋值给char *，但可以将char *类型的数据赋值给const char *类型的变量\n<div class=\"show\">C语言函数库中很多函数参数都被const限制了，但我们仍然可以将非const类型的数据传递给const类型的形参，如对于函数原型\nint puts(const char * str);\n可以直接传递非const类型的数据\nchar * str=\"Hello\";\nputs(str);\n</div>\n\n#### volatile\nvolatile用于声明变量的值是易变的，每次用到该变量的值时都需要去内存中重新读取这个变量的值，而不是读取其在寄存器中的备份。在多线程环境下，volatile 表示变量可能会被多个同时执行的线程修改，存取时无需额外的内存保护，并且防止优化编译器把变量从内存装入寄存器中，因为如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，造成程序的错误执行，volatile的声明方式为：\n<div class=\"show\"><code>volatile int counter;</code></div>\n\n#### restrict\nrestrict是C99标准新增的限定符，该限定符只能用于指针变量，其作用是程序员通过该限定符告知编译器，restrict修饰的指针独占其所指向的内存，所有对该内存的操作都将基于该指针，而不再会有其他任何变量或指针操作该内存，以便让编译器进行一些针对性的优化。这种优化是针对特殊使用场景的，因此可能出现没有任何优化的情况，并且由于restrict指针独占是由程序员来判断并加以限定的，可能会出现误判的情况，因此，restrict一般用于非常需要性能优化，并且已经确认两个指针不会指向同一内存的场景，其定义语法为：\n<div class=\"show\"><code>int * restrict a;</code>\neg:业务上明确得知，某个malloc开辟的空间，只会通过mySpace指针变量进行操作，则可以使用restrict限定符告知编译器，由其进行优化\n<code>int * restrict mySpace=(int *)malloc(10*sizeof(int));</code></div>\n\n#### _Atomic\n_Atomic是C11标准引入的限定符，用于指定原子类型，提供原子性操作。原子操作是指对原子对象的操作是不可被打断的，该操作一旦执行，不会被其他线程或者事件中断，直到操作执行完毕。默认的声明方式为：\n<div class=\"show\"><code>_Atomic int x=0;</code></div>\n\n但在实际使用时，应该使用<span class=\"text-blue\">&lt;stdatomic.h&gt;</span>头文件中已经定义好的原子类型，该头文件还定义了相关的原子操作函数\n<div class=\"show\">一些stdatomic.h头文件定义的原子类型和原子操作举例\n<code>typedef _Atomic int atomic_int;\ntypedef _Atomic char atomic_char;\n...\natomic_init(volatile A* obj, C desired )初始化原子类型变量\n....</code>\neg:定义一个原子类型变量并初始化\n<code>#include &lt;stdio.h>\n#include &lt;stdatomic.h>\nint main(void)\n{\n    atomic_int a;\n    atomic_init(&a,10);\n    return 0;\n}</code></div>\n\n### 动态内存分配\n动态内存分配函数在堆上分配内存，使用前需要包含<span class=\"tips\">&lt;stdlib.h&gt;</span>头文件\n\n#### 内存空间申请与释放\n+ <span class=\"strong\">void *malloc(unsigned int size);</span>\n\n分配长为size字节的内存空间，返回该内存首地址，若无足够内存单元，则返回空指针NULL\n<div class=\"show\"><code>int *p=(int *)malloc(4*sizeof(int))</code></div>\n\n+ <span class=\"strong\">void *calloc(unsigned int num,unsigned int size);</span>\n\n用于给同一类型的数据分配连续的内存空间并赋值为0(数值型)或空(字符型)。它相对于声明了一个一维数组，并且会初始化该数组值为0或空，参数num为所需申请的内存空间数量，相对于数组长度，参数size为每个内存空间的字节数，相对于数组基类型的字节长度。若申请成功，返回该内存空间的首地址，否则返回空指针NULL\n\n<div class=\"show\"><code>int * p=(int *)calloc(10,sizeof(int));\n相对于\nint * p=(int *)malloc(10*sizeof(int));\n但calloc()会将分配的内存自动初始化为0或空，更为安全\n</code></div>\n\n+ <span class=\"strong\">void *realloc(void *p,unsigned int size);</span>\n\n用于改变原来分配的内存，将p所指向的存储空间大小改为size个字节，返回值是新分配的内存空间首地址，与原来分配的首地址不一定相同\n\n\n+  <span class=\"strong\">void free(void *p);</span>\n\n用于释放所申请的内存空间，即p所指向的空间，其中p只能是由malloc()和calloc()申请的内存地址\n\n### 文件操作\n#### 二进制文件与文本文件\nC语言文件有两种类型：<span class=\"text-blue\">文本文件</span>(也称ASCII码文件)和<span class=\"text-blue\">二进制文件</span>。二者的区别在于存储数值型数据的方式不同。二进制文件中，数值型数据是将整个数值转码为二进制形式存储；而在文本文件中，数值型数据的每一位数字作为一个字符以其ASCII码形式存储，每个数字都单独占用一个字节的存储空间。如：对于short int n=123，二进制文件中，变量n为short类型仅占用2个字节存储空间，而在文本文件中占用3个字节存储空间。\n\n二进制文件和文本文件各有优缺点。文本文件可以很方便被其他程序读取，包括文本编辑器、Office办公软件等，且输出内容与字符一一对应，一个字节表示一个字符，便于对字符逐个处理，便于输出字符，但一般占用的存储空间较大，且ASCII码和字符转换需要花费一定时间。二进制文件可以节省空间和转换时间，但不方便其他程序读取，不能直接输出其字符形式。\n\n无论文件内容是什么形式，C语言一律将数据看成由字节构成的序列，即<span class=\"text-blue\">字节流</span>，对文件的存取也是以字节为单位进行的，输入、输出的数据仅受程序控制而不受物理符号(如回车换行符)控制，因此，C语言文件又称为流式文件。\n\nC语言文件系统分为<span class=\"text-blue\">缓冲型</span>和<span class=\"text-blue\">非缓冲型</span>，缓冲型文件系统是指系统自动为每一个正在使用的文件在内存中开辟一个输入/输出文件缓冲区，作为程序和文件之间数据交换的缓冲区域。在读文件时，数据先从磁盘送到缓冲区，再传给C语言程序；在写文件时，数据从C语言程序送到缓冲区，装满缓冲区后再输出到磁盘。缓冲文件系统利用<span class=\"text-red\">文件指针</span>标识文件，不同版本的C语言缓冲区大小不一样，一般为512字节。而非缓冲文件系统不会自动数值文件缓冲区，缓冲区必须由程序员自己设定，它使用称为文件号的整数来标识文件。\n\n在UNIX系统中，缓冲文件系统用来处理文本文件，用非缓冲文件系统来处理二进制文件。用缓冲文件系统进行输入输出的操作又称为高级文件操作，用非缓冲文件系统来处理输入输出的操作又称为低级输入输出操作。ANSI C标准规定只采用缓冲文件系统，即既用缓冲文件系统处理文本文件，也用它处理二进制文件，因此下文主要为高级文件操作函数。\n\n#### 文件指针\n缓冲文件系统中，系统为每个正在使用的文件在内存中开辟了一个缓冲区，用来存放文件的有关信息(如：文件名、文件句柄、文件状态、文件路径等)，这些信息保存在一个结构体变量中，该结构体类型由系统定义，名为<span class=\"text-red\">FILE</span>，stdio.h文件中有该文件类型声明：\n<div class=\"show\"><code>typedef struct\n{   short level;    //缓冲区\"满\"或\"空\"的程度\n    unsigned flags;//文件状态标志\n    char fd;      //文件描述符\n    unsigned char hold;//如果无缓冲区不读取字符\n    short bsize;//缓冲区大小\n    unsigned char *buffer;//数据缓冲区位置\n    unsigned ar *curp;//指针当前指向\n    unsigned istemp;//临时文件指示器\n    short token;//用于有效性检查\n}FILE;\n</code></div>\n\n由此，我们可以定义一个文件类型的指针变量：<span class=\"text-red\">FILE *fp</span>，然后将该指针指向一个文件的结构体变量，从而通过该指针访问该结构体变量中的文件信息，并通过这些信息访问该文件。\n\n#### 文件的打开与关闭\n##### fopen()函数\n函数fopen()用于打开文件，其函数原型如下：\n<div class=\"apiBox\">FILE * fopen(const char * filename,const char * mode)</div>\n\n该函数返回一个文件类型的指针，如果文件打开失败，则返回一个空指针NULL(NULL在stdio.h文件中被定义为0)。fopen()有两个形参，第一个形参filename表示文件名，可以包含<span class=\"strong\">文件路径和文件名</span>两部分，第二个形参mode表示文件的打开方式，取值如下所示：\n\n<div class=\"table\">\n\n字符|含义\n----|------ \nr   |以<span class=\"text-yellow\">只读方式</span>打开<span class=\"text-blue\">文本文件</span>，只能读出而不能写入数据，若文件不存在，则报错\nw   |以<span class=\"text-yellow\">只写方式</span>(新建形式)，创建并打开<span class=\"text-blue\">文本文件</span>，无论文件是否存在，都会创建一个新的文本文件，只能写入数据，已经存在的文件将被覆盖\na   |以<span class=\"text-yellow\">只写方式</span>(追加形式)，打开<span class=\"text-blue\">文本文件</span>，位置指针移到文件末尾，向文件尾部添加新数据，若文件不存在，则会新建一个文件\nb   |与上面的字符串组合，表示打开二进制文件\nrb  |以<span class=\"text-yellow\">只读方式</span>打开<span class=\"text-red\">二进制文件</span>\nwb  |以<span class=\"text-yellow\">只写方式</span>打开<span class=\"text-red\">二进制文件</span>\nab  |以<span class=\"text-yellow\">只写方式</span>向<span class=\"text-red\">二进制文件</span>末尾添加数据\n\\+   |与上面的字符串组合，表示以读写方式打开文本文件，既可以向文件中写入数据，也可以从文件中读取数据\nr+  |以<span class=\"text-green\">可读可写</span>的方式打开<span class=\"text-blue\">文本文件</span>\nw+  |以<span class=\"text-green\">可读可写</span>方式创建一个新的<span class=\"text-blue\">文本文件</span>\na+  |以<span class=\"text-green\">可读可写</span>方式向<span class=\"text-blue\">文本文件</span>末尾追加数据\nrb+  |以<span class=\"text-green\">可读可写</span>的方式打开<span class=\"text-red\">二进制文件</span>\nwb+  |以<span class=\"text-green\">可读可写</span>方式创建一个新的<span class=\"text-red\">二进制文件</span>\nab+  |以<span class=\"text-green\">可读可写</span>方式向<span class=\"text-red\">二进制文件</span>末尾追加数据\n</div>\n\n注意：\n+ 有的C语言编译系统可能不完全提供上述功能，如：有的C语言编译器不支持r+、w+、a+\n+ 输入文本文件时，内容中的回车换行符会被转换为一个换行符，在输出时，则会将换行符转换为回车和换行两个字符。而在输入输出二进制文件时，不会进行这种转换，文件中的数据与内存中的数据完全一致，一一对应\n\n##### fclose()函数\n函数fclose()用来关闭一个由函数fopen()打开的文件，其函数原型如下：\n<div class=\"apiBox\">int fclose(FILE *fp);</div>\n\n函数返回一个整型值，当文件成功关闭时，返回0值，否则返回一个非0值(一般为EOF -1)，可用于判断文件是否关闭成功。当使用fclose()关闭文件后，指针fp将不再指向该文件。\n\n由于操作系统对于同时打开的文件数目是有限制的，所以文件使用结束后必须关闭文件。此外，不建议使用读写方式打开文件，因为读写共用一个缓冲区，每次读写都会改变文件位置指针，很容易写乱，破坏文件内容，并且需要调用文件定位函数才能在读写之间切换。\n\n<div class=\"show\"><code>FILE * fp;\nfp=fopen(\"D:\\\\demo.text\",\"a+\");\nfclose(fp);</code></div>\n\n#### 文件的读写\n##### 按字符读写\n+ <span class=\"strong\">int fgetc(FILE *fp)</span> 从fp所指向文件读取一个字符，并使位置指针指向下一个字符。如果读取成功，则返回该字符，若读取到文件末尾，则返回EOF(stdio定义为-1)\n+ <span class=\"strong\">int fputc(int c,FILE *fp)</span> 将字符c(尽管c定义为int型，但只写入低字节)写到文件指针fp所指向的文件中。若写入错误，则返回EOF，否则返回字符c\n\n<div class=\"show\">在读入文本文件时，可通过fgetc()函数的返回值来判断是否读取到了文件末尾(文件是否读取完毕)，当读入的字符值等于-1(即EOF)时，说明文件已经读取完毕。但在读入二进制文件时，读入的数据可能刚好为-1(EOF)，此时就需要使用feof()函数判断当前文件是否读取完毕。如果文件结束，则feof(fp)的值为1(真)，否则为0(假)\neg:从键盘输入字符，并将这些字符存储到磁盘文件中，直到输入\"#\"为止\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void){\n    FILE *fp;\n    char ch,filename[10];\n    scanf(\"%s\",filename);//输入文件名\n    if((fp=fopen(filename,\"w\"))==NULL){\n        printf(\"文件打开失败\\n\");\n        exit(0);\n    }\n    ch=getchar();//接收执行scanf语句时输入的回车符\n    ch=getchar();\n    while(ch!='#')\n    {\n        <span class=\"text-blue\">fputc(ch,fp);</span>\n        ch=getchar();\n    }\n    fclose(fp);\n        return 0;\n}</code>\neg:从当前路径文件夹下读取名为\"myTest.txt\"的文件，并将内容输出到控制台\n<code>int main(void) {\n\tFILE* fp;\n\tchar ch;\n\tif ((fp = fopen(\"myTest.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败！\\n\");\n\t\texit(0);\n\t}\n\twhile (<span class=\"text-red\">!feof(fp)</span>) {\n\t\tch = fgetc(fp);\n\t\tputchar(ch);\n\t}\n\treturn 0;\n}</code></div>\n\n##### 按字符串读写\n+ <span class=\"strong\">char * fgets(char *s,int n,FILE *fp)</span> 从fp所指向文件中读取最多含n-1个字符的字符串，并在字符串末尾添加'\\0'，然后存入s。当读取到回车换行符、到达文件末尾或者读满n-1个字符时，函数返回该字符串的首地址，即指针s的值；读取失败时返回空指针NULL\n+ <span class=\"strong\">int fputs(const char *s,FILE * fp)</span> 将字符串s写入文件fp，若写入错误，则返回EOF(-1)，否则返回一个非负数\n\n<div class=\"show\">eg:从键盘输入一个字符串，追加到文件末尾\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void){\n    FILE * fp;\n    char str[20];\n    if((fp=fopen(\"demo.txt\",\"a\"))==NULL){\n        printf(\"Failure to open file!\\n\");\n        exit(0);\n    }\n    gets(str);\n    fputs(str,fp);\n    fclose(fp);\n    if((fp=fopen(\"demo.txt\",\"r\"))==NULL){\n        printf(\"Failure to open file!\\n\");\n        exit(0);\n    }\n    fgets(str,20,fp);\n    puts(str);\n    fclose(fp);\n    return 0;\n}\n</code></div>\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n这两个函数与puts()和gets()类似，区别在于，gets()函数从输入缓冲区读取字符串时，会将回车符也从缓冲区读走，但不作为字符串的一部分，而fgets()函数读到换行符时会将换行符作为字符串的一部分读到字符串中来。输出时，puts()函数在向终端输出字符串时，会在字符串输出结束后，自动输出一个换行符，而fputs()函数不会在字符串末尾加上换行符。</div>\n\n##### 按格式读写文件\n+ <span class=\"strong\">int fscanf(FILE *fp,格式字符串,输入表列地址)</span>从指定文件按格式读取数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为输入变量的地址表列\n+ <span class=\"strong\">int fprintf(FILE *fp,格式字符串,输出表列)</span>按指定格式向文件写入数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为要写入的变量\n\n用函数fscanf()和fprintf()进行文件的格式化读写，读写方便，容易理解，但输入时要将ASCII字符转换为二进制数，输出时要将二进制数转换为ASCII字符，耗时较多。因此，内存和磁盘进行频繁数据交换时，应当尽量避免使用这两个函数，而用fread()和fwrite()函数\n<div class=\"show\"><code>int i=10;\nfloat j=4.5;\nfprintf(fp,\"%d,%6.2f\",i,j);//保存为10,  4.50\nfscanf(fp,\"%d,%f\",&i,&j);//假设文件内容为10,4.5，则i赋值为10，j赋值为4.5</code></div>\n\n##### 按数据块读写文件\n+ <span class=\"strong\">unsigned int fread(void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 从fp所指的文件读取数据块并存储到buffer所指向的内存。buffer是待存入数据块的起始地址，可以是数组起始地址、结构体变量起始地址等，size是每个数据块的大小，count是最多允许读取的数据块个数，函数返回的是实际读取到的数据块个数\n+ <span class=\"strong\">unsigned int fwrite(const void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 将buffer所指内存中的数据块写入fp所指的文件。同样，buffer是待读出数据块的起始地址，size是每个数据块的大小，count是最多允许写入的数据块个数，函数返回的是实际写入的数据块个数\n块数据读写允许用户以数组、结构体等数据类型整块读写，不再局限于一次只读写一个字符或字符串，可以指定想要读写的内存块大小，最小为1字节，最大可以为整个文件\n\n<div class=\"show\">eg:整块读写数组内容\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void) {\n\tint nums[] = { 11,22,33,44,55,66,77,88,99 };\n\tint numsRead[9];\n\tFILE* fp;\n\tif ((fp = fopen(\"data.txt\", \"w\")) == NULL) {\n\t\tprintf(\"文件打开失败!\");\n\t\texit(0);\n\t}\n    <span class=\"text-blue\">fwrite(nums, 4, sizeof(nums)/4, fp);</span>//将数组nums到文件fp中，数组为int类型，数据块为4Bytes，需要写入9个数据块\n\tfclose(fp);\n\tif ((fp = fopen(\"data.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败!\");\n\t\texit(0);\n\t}\n    <span class=\"text-red\">fread(numsRead, 4, 9, fp);</span>//从fp文件中读取9个4Bytes的数据块，并存储到numsRead数组中\n\tfor (int i = 0; i < 9; i++) {\n\t\tprintf(\"%4d\", numsRead[i]);\n\t}\n    fclose(fp);\n\treturn 0;\n}</code></div>\n\neg:按块文件读写结构体变量，输入每个学生的信息并保存到studentData.txt文件中，并添加从该文件中读出学生信息并打印到控制台的功能\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define MAXSIZE 10\ntypedef struct student {\n\tchar name[10];\n\tlong studentID;\n\tint age;\n\tint classID;\n}STUDENT;\nint main(void) {\n\tvoid writeToFile(STUDENT[], int);\n\tint readFromFile(STUDENT[]);\n\tvoid printToScreen(STUDENT[], int);\n\tSTUDENT stu[MAXSIZE];\n\tint studentNum;\n\tprintf(\"请输入学生数量：\\n\");\n\tscanf(\"%d\", &studentNum);\n\tprintf(\"请输入学生信息：\\n\");\n\tfor (int i = 0; i &lt;studentNum; i++) {\n\t\tscanf(\"%s %ld %d %d\", stu[i].name, &stu[i].studentID, &stu[i].age, &stu[i].classID);\n\t}\n\twriteToFile(stu, studentNum);\n\tstudentNum = readFromFile(stu);\n\tprintToScreen(stu, studentNum);\n\treturn 0;\n}\nvoid writeToFile(STUDENT stu[], int n) {\n\tFILE* fp;\n\tif ((fp = fopen(\"studentData.txt\", \"w\")) == NULL) {\n\t\tprintf(\"文件打开失败！\");\n\t\texit(0);\n\t}\n    fwrite(stu, sizeof(STUDENT), n, fp);\n\tfclose(fp);\n}\nint readFromFile(STUDENT stu[]) {\n\tFILE* fp;\n\tint i;\n\tif ((fp = fopen(\"studentData.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败!\\n\");\n\t\texit(0);\n\t}\n\tfor (i = 0; !feof(fp); i++) {\n\t\tfread(&stu[i], sizeof(STUDENT), 1, fp);\n\t}\n\tfclose(fp);\n\treturn i - 1;\n}\nvoid printToScreen(STUDENT stu[], int num) {\n\tprintf(\"----------------------\\n\");\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tprintf(\"%6s%10ld%4d%4d\\n\", stu[i].name, stu[i].studentID, stu[i].age, stu[i].classID);\n\t}\n}</code></pre>\n\n##### 数字读写putw()和getw()\nputw()和getw()不是ANSI C标准定义的函数，但很多编译器提供这两个函数，有的编译器将其命名为_putw()和_getw()函数(Visual Studio 2019(编译器版本主要支持ANSI C89标准，但其中包含几个Microsoft扩展支持ISO C99的一部分函数)只能用这两个函数名)，因此这两个函数的在不同编译器中函数名可能不同，函数名中的<span class=\"tips\">w</span>是指<span class=\"tips\">word(字)</span>\n+ <span class=\"strong\"> int getw(FILE *fp)</span> 从fp读取一个整数，如果读取成功，返回该整数，读取失败或文件结束，返回-1\n+ <span class=\"strong\">int putw(int w, FILE *fp)</span> 将一个字符或字输出到文件fp，返回值为输出的整数\n\n<div class=\"show\">eg:存储0-9整数到文件test.txt中，读出后输出到控制台\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void) {\n\tFILE* fp;\n\tint getNum;\n\tif ((fp = fopen(\"test.txt\", \"w\")) == NULL) {\n\t\tprintf(\"文件打开失败!\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < 10; i++) {\n        <span class=\"text-blue\">_putw(i, fp);</span>\n\t}\n\tfclose(fp);\n\tif ((fp = fopen(\"test.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败!\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < 10; i++) {\n        <span class=\"text-blue\">getNum = _getw(fp);</span>\n\t\tprintf(\"%4d\", getNum);\n\t}\n\tfclose(fp);\n\treturn 0;\n}</code></div>\n\n#### 文件定位\n之前的示例执行的都是顺序文件处理，数据项是依次进行读写的，如果需要读取第5个数据项，按顺序文件处理方法必须先读取前4个数据项。如果要读写指定位置的数据项，则需要使用文件的随机访问，允许在文件中随机定位，并在文件任意位置读写数据。\n\n为了实现文件的定位，每一个打开的文件中，都有一个<span class=\"text-blue\">文件位置指针</span>，用来指向当前文件读写位置。当对文件进行顺序读写时，每读完一个字节，位置指针就会自动指向下一个字节。当需要随机读写时，需要我们人为指定位置指针的指向，C语言提供了几个关于位置指针的函数\n\n##### 重置位置指针rewind()\n<span class=\"strong\">void rewind(FILE *fp)</span> 使fp文件的位置指针指向文件首字节，即重置位置指针到文件开头\n\n<div class=\"show\">eg:打印file1文件内容到控制台，并将其复制到file2，两个任务分开执行。第一次打印完file1文件，文件位置指针位于文件末尾，使用rewind()函数将file1文件位置指针重置到文件开头，执行其他任务\n<code>FILE *fp1=fopen(\"file1.txt\",\"r\");\nFILE *fp2=fopen(\"file2.txt\",\"r\");//应当有文件打开失败的错误处理，这里省略\nwhile(!feof(fp1)){\n    putchar(getc(fp1));\n}\n<span class=\"text-blue\">rewind(fp1);</span>\nwhile(!feof(fp1)){\n   putc(getc(fp1),fp2);\n}\nfclose(fp1);\nfclose(fp2);\n</code></div>\n\n##### 指定指针位置fseek()\n<span class=\"strong\">int fseek(FILE *fp,long offset,int fromwhere);</span>将fp的位置指针从fromwhere移动offset个字节\n\n\noffset是一个偏移量，告诉文件指针跳过多少个字节，ANSI C要求offset是<span class=\"tips\">long</span>类型的(其常量值后面要加L)，这样当文件长度大于64kb时不至于出问题。当offset为正时，位置指针向后移动，为负时向前移动。由于需要指定具体字节数，因此该参数往往需要<span class=\"tips\">sizeof(数据类型)</span>函数来获取相应类型的字节数。\n\nfromwhere用于确定偏移量计算的起始位置，可以取以下三个值：\n\n<div class=\"table\">\n\n起始点      |别名     |值\n-----------|---------|----\n文件开始    |SEEK_SET |0\n文件当前位置|SEEK_CUR |1\n文件末尾    |SEEK_END |2\n</div>\n\n<div class=\"show\">eg:读取studentData.txt中的第k条数据并打印到控制台，k由用户输入\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define MAXSIZE 10\ntypedef struct student {\n\tchar name[10];\n\tlong studentID;\n\tint age;\n\tint classID;\n}STUDENT;\nint main(void) {\n\tvoid searchData(char fileName[],long k);\n\tlong k;\n    printf(\"Input the searching record number:\");\n    scanf(\"%ld\",&k);\n    searchData(\"studentData.txt\",k);\n\treturn 0;\n}\nvoid searchData(char fileName[],long k)\n{\n    FILE* fp;\n    STUDENT stu;\n    if ((fp = fopen(filename, \"r\")) == NULL) {\n        printf(\"文件打开失败!\\n\");\n        exit(0);\n    }\n    <span class=\"text-blue\">fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);</span>\n    <span class=\"text-red\">fread(&stu, sizeof(STUDENT), 1, fp);</span>\n    printf(\"%8s%8ld%4d%4d\", stu.name, stu.studentID, stu.age, stu.classID);\n    fclose(fp);\n}\n</code></div>\n\n##### 返回指针位置ftell()\n<span class=\"strong\">long ftell(FILE *fp)</span>返回当前位置指针相对于文件开头的位移量(字节数)，若函数调用失败则返回-1L\n<div class=\"show\">eg:ftell()返回的文件位置是用字节偏移量表示的，如果要获取记录号(第几条数据)则还要除以sizeof(STUDENT)\n<code>fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);//执行完指针跳转，不确定指针指向哪里，可以用ftell()返回指针位置\nlong num=ftell(fp);//指针相对于文件头的偏移字节数\nint k=num/sizeof(STUDENT);//指针指向的数据序号\n</code></div>\n\n#### 文件状态\n+ <span class=\"strong\">int feof(FILE *fp)</span>检查fp所指向文件是否已经读到文件末尾。当文件位置指针指向文件结束符时，返回非0值，否则返回0值\n+ <span class=\"strong\">int ferror(FILE *fp)</span>检查对文件的输入输出操作是否出错，如果出错返回非零值，如果未出错，返回0。对同一个文件，每调用一次输入输出函数，ferror()函数的值都会更新\n+ <span class=\"strong\">void clearerr(FILE *fp)</span>将fp所指向文件的文件错误标志和文件结束标志置为0\n+ <span class=\"strong\">void perror(const char *str)</span>向标准错误输出字符串str，并随后附上冒号以及全局变量errno代表的错误消息的文字说明，无返回值\n+ <span class=\"strong\">int rename(const char *old,const char *new)</span>将文件名old所指的文件改为new，成功返回0，出错返回1\n#### 输入输出重定向\n在从终端设备输入输出时，系统会自动打开三个标准文件：标准输入、标准输出、标准出错输出。系统为其定义了三个文件指针：stdin、stdout和stderr，分别指向终端输入、终端输出和标准出错输出(也从终端输出)。在默认情况下，标准输入设备是键盘，标准输出设备是屏幕，我们从终端输入、输出时不需要手动打开终端文件，系统会自动打开，同样，如果程序指定从stdin所指的文件输入数据，其实就是指从终端键盘输入数据。\n\n文件读写操作中的很多函数是标准输入输出函数的文件操作版，如：fprintf()是printf()的文件操作版，二者差别在于fprintf()多了一个文件指针类型的参数(FILE * fp)，如果给该参数传递的值是stdout，那么fprintf()就和printf()完全一样了，同理，以下语句是两两等价的：\n<div class=\"show\"><code>putchar(c)等价于fputc(c,stdout)\nputs(str)等价于fputs(str,stdout)\ngetchar()等价于fgetc(stdin)\n以下函数，fgets()比gets()还多了一个参数size\nchar *fgets(char *str,int size,FILE *fp);\nchar *gets(char *str);\n参数size用于限制输入字符串的长度，说明fgets()函数输入缓冲区大小，使读入的字符数不能超过限定的缓冲区大小，从而达到防止缓冲区溢出攻击的目的，因此，以下语句，后者安全性更高\ngets(str);\nfgets(str,sizeof(str),stdin);\n</code></div>\n\n虽然系统隐含的标准I/O文件是指终端文件，但标准输入和标准输出是可以重定向的，操作系统可以把它们重定向到其他文件或具有文件属性的设备，只有标准错误输出不能进行一般的输出重定向，如：把标准输出重定向到打印机，把标准输入重定向到U盘文件等。使用<span class=\"strong\">\"&lt;\"</span>表示输入重定向，用<span class=\"strong\">\"&gt;\"</span>表示输出重定向。如：file.exe是可执行文件，执行该程序时需要从键盘输入数据，如果现在要求从文件file.in读取所需要输入的数据，那么只需在DOS命令提示符下，输入以下命令即可：\n<div class=\"shell\">c:\\file.exe &lt; file.in</div>\n这样file.exe的标准输入就被\"&lt;\"重定向到了file.in文件，此时程序只会从文件file.in读取数据，而不再理会任何键盘输入。同样，以下命令可以将标准输出重定向到文件file.out：\n<div class=\"shell\">c:\\file.exe &gt; file.out</div>\n\n### C语言中的随机数\nC语言标准库在&lt;stdlib.h&gt;头文件中提供了用于生成随机数的函数<span class=\"text-red\">rand()</span>，其函数原型为：<span class=\"strong\">int rand(void)</span>，该函数可以生成<span class=\"text-blue\">0~32767</span>范围内的随机数，但该函数生成的数是伪随机数，每次调用该函数都会重复生成以下值：\n<div class=\"show\"><code>    printf(\"%d\\n\", rand());//41\n\tprintf(\"%d\\n\", rand());//18467\n\tprintf(\"%d\\n\", rand());//6334\n\tprintf(\"%d\\n\", rand());//26500\n\tprintf(\"%d\\n\", rand());//19169\n    ......</code></div>\n\n这是由于，各编程语言获取随机数实际上都是基于递推公式计算出一组数值，当序列足够长，这组数值可以近似满足均匀分布。在计算随机数时，这些随机函数都是基于一种名为\"种子\"的基准值进行运算，当种子值不变，生成的随机数也将固定。C语言中,rand()函数的种子值默认为1，可以通过<span class=\"text-red\">srand()</span>函数来修改该种子值，其函数原型为:\n<span class=\"strong\">void srand(unsigned int seed);</span>\n<div class=\"show\"><code>    srand(6);\n    printf(\"%d\\n\", rand());//58\n\tprintf(\"%d\\n\", rand());//6673\n\tprintf(\"%d\\n\", rand());//30119\n\tprintf(\"%d\\n\", rand());//15745\n\tprintf(\"%d\\n\", rand());//5206</code></div>\n\n如果将种子值设为当前时间，由于时间是每时每刻都不一样的，此时就可以真正生成一个随机数，C语言提供了获取当前时间戳的函数：\n<span class=\"strong\">time_t time(time_t *timer);</span>\n\n该函数会当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，其返回值类型为time_t(但本质上为64位整型)，在用作生成随机数时，传入的参数一般为空指针NULL(或0)\n\n<div class=\"show\"><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;time.h&gt;\nint main()\n{   <span class=\"text-red\">srand((unsigned int)time(NULL));</span>\n    printf(\"%d\\n\", rand());\n\tprintf(\"%d\\n\", rand());\n    return 0;\n}\n</code></div>\n\n如果需要指定生成随机数的范围，则还需要一些额外的运算\n<div class=\"show\">以下操作建立在设置了随机数种子的前提下\n<code>srand((unsigned int)time(NULL));</code>\n1. 通过取模运算来限制随机数范围\n<code>int randomNum = rand() % 100;//生成0-99之间的随机整数\nint randomNum = rand()%100+1;//生成1-100之间的随机整数\n该语句解析为：\nint randomNum = rand()%(101-1)+1;//生成1-101(不包括101)之间的整数</code>\n生成min-max(不包括max)之间的随机整数\n<span class=\"text-blue\">rand()%(max-min)+min</span>\n2. 将随机整数除以RAND_MAX宏常量来获取随机小数：stdlib.h定义了rand()函数能返回伪随机数的最大值RAND_MAX，其值一般为32767，我们将获得的随机整数除以该常量值，就获得了一个0.0-1.0之间的随机小数\n<code>double random_double = (double)rand()/(double)RAND_MAX;</code>\n类似地可以限定该随机小数的范围为a-b：\n<span class=\"text-blue\">(double)rand() / RAND_MAX * (b - a) + a;</span>\n</div>\n\n### 常用函数和头文件\n列出了一些常用的函数及其头文件，这些头文件中还有很多其他函数，可以参考文档：[https://cplusplus.com/reference/](https://cplusplus.com/reference/)，里面罗列了很多C语言和C++的头文件和函数，二者文件名和函数形参可能有所不同但能类似套用\n\n#### 字符与字符串\n以下是对部分字符的定义\n<div class=\"table\">\n\n字符类|说明\n-----|-----\n标点符号字符|!@\"#$%^&'(),*+-./:&lt;=&gt;;[]\\\\_{|}~`\n图形字符|包括字母、数字、标点符号\n空白字符|空格符、水平制表符\\t、换行符\\n、垂直制表符\\v、换页符\\f、回车符\\r\n控制字符|在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）\n可打印字符|包括字母、数字、标点符号和空格字符\n</div>\n\n以下函数用于测试和映射字符，需要包含字符串<span class=\"text-red\">&lt;ctype.h&gt;</span>，除了最后的大小写转换函数，其余函数如果参数 c 满足描述的条件，则这些函数返回非零值(true)，一般返回值为1，否则返回零(false)\n\n<div class=\"table\">\n\n函数名  |函数原型            |说明\n------  |-------------------|-------\nisalnum |int isalnum(int c)|检查字符c是否是字母和数字\nisalpha |int isalpha(int c)|检查字符c是否是字母\niscntrl |int iscntrl(int c)|检查字符c是否是控制字符\nisprint |int isprint(int c)|检查字符c是否是可打印的\nisdigit |int isdigit(int c)|检查字符c是否是十进制数字\nisxdigit|int isxdigit(int c)|检查字符c是否是十六进制数字\nisgraph |int isgraph(int c)|检查字符c是否有图形表示法，有图形表示法的字符是指除了空白字符以外的所有可打印的字符\nislower |int islower(int c)|检查字符c是否是小写字母\nisupper |int isupper(int c)|检查字符c是否是大写字母\nispunct |int ispunct(int c)|检查字符c是否是标点符号字符\nisspace |int isspace(int c)|检查字符c是否是空白字符\ntolower |int tolower(int c)|把给定的字符c转换为小写字母，如果已经是小写字母则c不变\ntoupper |int toupper(int c)|把给定的字符c转换为大写字母，如果已经是大写字母则c不变\n</div>\n\n以下函数用于处理字符串，需要包含头文件<span class=\"text-red\">&lt;string.h&gt;</span>\n<div class=\"table\">\n\n函数名 |函数原型            |说明\n-------|-------------------|-----\nstrlen|unsigned int strlen( const char *str);|返回字符串str中实际字符的个数(不包括终止符'\\0')\nstrcat|char *strcat(char *str1,const char *str2)|把字符串str2拼接到str1后面,并在拼接好的str1串末尾添加一个'\\0',原str1末尾的'\\0'将被覆盖。因无边界检查,调用时应保证str1的空间足够大,能存放原始str1和str2两个串的内容。函数返回指向str1的指针\nstrncat|char * strncat( char * strl, constchar * str2, unsigned int count);|把字符串str2中不多于count个字符拼接到str1后面,并添加\\0',原str1末尾的'\\0'将覆盖，函数指向返回str1的指针\nstrcpy|char * strcpy( char * strl, constchar *str2);|把str2指向的字符串复制到str1中，str2必须是终止符为'\\0'的字符串指针，函数返回指向str1的指针\nstrncpy|char *strncpy(char * strl, constchar *str2,unsigned int count);|把str2指向的字符串中的count个字符复制到st1中，str2必须是终止符为'\\0'的字符串指针。如果str2指向的字符串少于 count个字符，则将'\\0'加到str1的尾部,直到满足coun个字符为止。如果str2指向的字符串长度大于count个字符，则结果串str1不用'\\0'结尾，函数返回指向strl的指针\nstrcmp|int strcmp(const char * strl,const char * str2);|按字典顺序比较两个字符串str1和str2。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数\nstrcnmp|int strcnmp( const char * strl,const char*str2,unsigned intcount);|按字典顺序比较两个字符串str1和str2的不多于count个字符。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数\nstrtr|char * strstr(char * strl, char *str2);|找出str2字符串在str1字符串中第一次出现的位置(不包括str2的串结束符)。函数返回该位置的指针。若找不到则返回空指针\n</div>\n\n#### 数学函数\n使用以下函数，源文件需要包含<span class=\"tips\">&lt;math.h&gt;</span>头文件，以下函数这里只写出了返回值和形参为double类型的函数原型，它们中的绝大多数还有一个返回值和形参为float或long double类型的函数原型，因此可以类似地套用\n\n<div class=\"table\">\n\n函数名 |函数原型            |说明\n-------|-------------------|-----\nfabs|double fabs( double x);|计算x的绝对值，返回浮点数\nabs|double abs (double x);|在c++中该函数声明于cmath头文件，可以用于计算double、float、long double的绝对值，在c语言中声明于stdlib.h文件，用于计算int的绝对值\nceil|double ceil (double x);|向上取整\nfloor|double floor( double x);|向下取整，计算不大于x的最大整数\nround|double round  (double x);|四舍五入取整\npow|double pow( double base, doubleexp);|返回base为底的exp次幂,即base<sup>exp</sup>,返回计算结果。当base等于0而exp小于0时或者base小于0而exp不为整数时,出现结果错误。该函数要求参数base和exp以及函数的返回值为double类型,否则有可能出现数值溢出问题\nsqrt|double sqrt(double x)|计算√x(根号下x)的值，注意x>=0\nexp|double exp( double x);|计算e<sup>x</sup>的值\nfmod|double fmod ( double x, double y);|计算整除x/y的余数\nlog|double log( double x );|计算log<sub>e</sub>x,即lnx,返回计算结果。注意,x>0\nlog10|double log10( double x);|计算 log<sub>10</sub>x,返回计算结果。注意,x>0\nsin|double sin(double x)|计算sinx的值，x为弧度值\ncos|double cos(double x)|计算cos(x)的值，x为弧度值\ntan|double tan(double x);|计算tanx的值\nasin|double asin(double x)|计算cos<sup>-1</sup>(x)的值，注意，x应为-1到1范围\nacos|double acos(double x)|计算sin<sup>-1</sup>(x)的值，注意，x应为-1到1范围\natan|double atan(double x)|计算tan<sup>-1</sup>(x)的值\natan2|double atan2(double x,double y)|计算tan<sup>-1</sup>(x/y)的值\nsinh|double sinh(double x)|计算x的双曲正弦函数sinh(x)的值\ncosh|double cosh(double x)|计算x的双曲余弦 cosh(x)的值\ntanh|double tanh(double x)|计算x的双曲正切函数tanh(x)的值\nfrexp|double frexp(double val,int*eptr);|把双精度数val分解为小数部分(尾数)x和以2为底的指数n(阶码),即val=x\\*2 <sup>n</sup>,n存放在eptr指向的变量中,函数返回小数部分x,0.5≤x<1\nmodf|double modf( double val, double *iptr);|把双精度数val分解为整数部分和小数部分,把整数部分存到iptr指向的单元。返回val的小数部分\n</div>\n\n\n#### 其他常用函数\n<div class=\"table\">\n\n函数名 |头文件|函数原型            |说明\n-------|-----|--------------|----------\natof|stdlib.h|double atof(const char * str);|把str指向的字符串转换成双精度浮点值,串中必须含合法的浮点数,否则返回值无定义。函数返回转换后的双精度浮点值\natoi|stdlib.h|int atoi(const char *str);|把str指向的字符串转换成整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的整型值\nalol|stdlib.h|long int atol(const char * str);|把str指向的字符串转换成长整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的长整型值\nexit|stdlib.h|void exit(int code);|使程序立即终止,清空和关闭任何打开的文件。程序正常退出状态由code等于0或EXITSUCCESS表示，如exit(0)，非0值或EXIT_FAILURE表明定义实现错误。函数无返回值\nrand|stdlib.h|int rand(void);|产生伪随机数序列。函数返回0到RAND_MAX之间的随机整数,RAND_MAX至少是32767\nsrand|stdlib.h|void srand(unsigned int seed );|为函数rand()生成的伪随机数序列设置起点种子值，函数无返回值\ntime|time.h|time_t time(time_t *timer)|如果传入的参数为空指针NULL，则该函数返回当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，返回值类型为time_t(但本质上为64位整型)。如果参数为time_t类型指针变量timer，则该时间差值也将放于timer所指向的内存中\nclock|time.h|clock_t clock(void);|clock_t是long类型，该函数返回硬件的时钟节拍数，需要换成秒或者毫秒，通常需要除以CLK_TCK或者CLOCKS_PER_SEC。例如,在VC6.0下,这两个量的值都是1000,表示硬件1秒钟的时钟节拍数为1000，该函数常用于测量从程序开始运行到clock()被调用时所消耗的时间，或用于实现计时器功能，如：计算一个进程的时间需要用clock()除以1000。注意:本函数仅能返回ms级的计时精度\nSleep|stdlih.h|Sleep(unsigned long second);|在标准C中和Linux下是函数的首字母不大写。但在VC和Code::blocks环境下首字母要大写。Sleep()函数的功能是将进程挂起一段时间,即起到延时的作用。参数的单是毫秒\nsystem|stdlib.h|int system(char * command);|发出一个DOS命令。例如,system(\"CLS”)可以实现清屏操作\nkbhit|conio.h|int kbhit(void);|检查当前是否有键盘输人,若有则返回一个非0值,否则回 0\ngetch|conio.h|int getch(void);|无需用户按回车键即可得到入户输入，只要用户按下一个键，立刻返回用户输入字符的ASCII码值，但输入的字符不会显示在屏幕上，出错时返回-1，该函数在游戏中比较常用\n</div>","tags":["C","note"]},{"title":"JavaScript中的各种尺寸","url":"/blog/2023/09/07/JavaScript中的各种尺寸/","content":"\n### 全局尺寸\n#### 屏幕尺寸\n+ <span class=\"strong\">window.screen.height</span>返回整个屏幕的高度\n+ <span class=\"strong\">window.screen.width</span>返回整个屏幕的宽度\n+ <span class=\"strong\">window.screen.availHeight</span>返回屏幕可用高度(去掉任务栏高度)\n+ <span class=\"strong\">window.screen.availWidth</span>返回屏幕可用宽度(去掉任务栏宽度)\n+ <span class=\"strong\">window.screenTop/window.sceenY</span>返回浏览器左边界到屏幕左边缘的距离\n+ <span class=\"strong\">window.screenLeft/window.screenX</span>返回浏览器的上边界到屏幕上边缘的距离\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\navailHeight和availWidth主要用于PC端，一般情况下，任务栏位于屏幕底部占用了屏幕高度，所以window.screen.availHeight的值是window.screen.height减去任务栏高度后得出的值，如果任务栏隐藏，screen.availHeight的值将等于screen.height。同理，当任务栏在屏幕左侧或右侧时，可以用availWidth获得当前屏幕可用宽度。</div>\n\n#### 浏览器尺寸\n+ <span class=\"strong\">window.outerHeight</span>返回整个浏览器窗口的高度，包括地址栏、标签栏、收藏栏和显示网页的布局视口高度\n+ <span class=\"strong\">window.outerWidth</span>返回整个浏览器窗口的宽度\n+ <span class=\"strong\">window.innerHeight</span>返回浏览器显示网页用的布局视口(layout viewport)高度，包含滚动条(如果有)，不包含地址栏、标签栏、收藏栏的高度\n+ <span class=\"strong\">window.innerWidth</span>返回浏览器视口宽度，包含滚动条(如果有)\n\n任何窗口对象window、frame、frameset都支持window.innerHeight属性，outerHeight和innerHeight区别如下(图片来源于MDN文档)\n\n<img data-src=\"/blog/images/innervsouterheight.png\" src=\"#\" alt=\"innerHeight\">\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n在Android端浏览器中，上述4个属性的返回值可能不可靠，如可能出现innerHeight值大于outerHeight等情况，不同Android系统版本返回值不同，因此在移动端中请慎用，Stack Overflow上有一篇讨论这一问题的帖子：<a href=\"https://stackoverflow.com/questions/10610743/android-browsers-screen-width-screen-height-window-innerwidth-window-inner\" target=\"_blank\">Android browser's screen.width, screen.height & window.innerWidth & window.innerHeight are unreliable</a></div>\n\n#### 鼠标位置\n鼠标事件触发时，与鼠标位置有关的坐标\n+ <span class=\"strong\">event.screenY</span>返回触发事件时，鼠标在屏幕中的Y坐标值\n+ <span class=\"strong\">event.screenX</span>返回触发事件时，鼠标在屏幕中的X坐标值\n+ <span class=\"strong\">event.pageY</span>返回触发事件时，鼠标相对于整个document的Y坐标值，其值会受文档滚动影响\n+ <span class=\"strong\">event.pageX</span>返回触发事件时，鼠标相对于整个document的X坐标值，其值会受文档滚动影响\n+ <span class=\"strong\">event.clientY</span>返回触发事件时，鼠标相对于浏览器当前网页视口的Y坐标值，其值不受滚动影响\n+ <span class=\"strong\">event.clientX</span>返回触发事件时，鼠标相对于浏览器当前网页视口的X坐标值，其值不受滚动影响\n+ <span class=\"strong\">event.offsetY</span>返回触发事件时，鼠标相对于事件触发源Dom上边界的Y坐标值，其值会受该Dom滚动的影响\n+ <span class=\"strong\">event.offsetX</span>返回触发事件时，鼠标相对于事件触发源Dom左边界的X坐标值，其值会受该Dom滚动的影响\n+ event.movementY 返回当前事件和上一个mousemove事件之间，鼠标在竖直方向上的移动值\n+ event.movementX 返回当前事件和上一个mousemove事件之间，鼠标在水平方向上的移动值\n+ event.x 即event.clientX的别名，实验性属性，兼容性较差\n+ event.y 即event.clientY的别名，实验性属性，兼容性较差\n\n<canvas width=\"300\" height=\"400\" id=\"canvasMouseEvent\"\n        style=\"display:block;width:300px;height:400px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n        const canvasMouseEvent = document.getElementById('canvasMouseEvent');\n        const ctxME = canvasMouseEvent.getContext('2d');\n        ctxME.beginPath();\n        ctxME.lineWidth = 2;\n        ctxME.strokeRect(10, 150, 280, 200);\n        ctxME.lineWidth = 1;\n        ctxME.strokeRect(60, 200, 180, 100);\n        ctxME.arc(160,250,3,0,Math.PI*2);\n        ctxME.stroke();\n        ctxME.closePath();\n        ctxME.beginPath();\n        ctxME.lineWidth = 1;\n        ctxME.strokeStyle = \"#f00\";\n        ctxME.moveTo(160, 200);\n        ctxME.lineTo(160, 250);\n        ctxME.moveTo(155, 205);\n        ctxME.lineTo(160, 200);\n        ctxME.lineTo(165, 205);\n        ctxME.moveTo(160, 250);\n        ctxME.lineTo(60, 250);\n        ctxME.moveTo(65, 255);\n        ctxME.lineTo(60, 250);\n        ctxME.lineTo(65, 245);\n        ctxME.font = \"16px Serif\";\n        ctxME.fillStyle = \"#f00\";\n        ctxME.fillText('offsetY', 160, 230)\n        ctxME.fillText('offsetX', 80, 245)\n        ctxME.stroke();\n        ctxME.closePath();\n        ctxME.beginPath();\n        ctxME.strokeStyle = \"#00f\";\n        ctxME.moveTo(190, 10);\n        ctxME.lineTo(190, 250);\n        ctxME.moveTo(185, 25);\n        ctxME.lineTo(190, 10);\n        ctxME.lineTo(195, 25);\n        ctxME.moveTo(10, 280);\n        ctxME.lineTo(160, 280);\n        ctxME.moveTo(20, 275);\n        ctxME.lineTo(10, 280);\n        ctxME.lineTo(20, 285);\n        ctxME.fillStyle = \"#00f\";\n        ctxME.fillText('pageY', 200, 80)\n        ctxME.fillText('pageX', 80, 295)\n        ctxME.stroke();\n        ctxME.closePath();\n        ctxME.beginPath();\n        ctxME.strokeStyle = \"#05fe05\";\n        ctxME.moveTo(170, 152);\n        ctxME.lineTo(170, 250);\n        ctxME.moveTo(165, 167);\n        ctxME.lineTo(170, 152);\n        ctxME.lineTo(175, 167);\n        ctxME.moveTo(10, 260);\n        ctxME.lineTo(160, 260);\n        ctxME.moveTo(25, 265);\n        ctxME.lineTo(10, 260);\n        ctxME.lineTo(25, 255);\n        ctxME.stroke();\n        ctxME.font = \"16px Serif\";\n        ctxME.fillStyle = \"#05fe05\";\n        ctxME.fillText('clientY', 170, 190);\n        ctxME.fillText('clientX', 70, 275);\n        ctxME.closePath();\n        ctxME.fillStyle = \"#000\";\n        ctxME.fillText('浏览器可视区', 15, 170)\n        ctxME.fillText('document溢出部分', 15, 30)\n        ctxME.fillText('dom', 65, 215)\n        ctxME.fillText('鼠标事件', 165, 265)\n        ctxME.beginPath();\n        ctxME.strokeStyle = \"#000\";\n        ctxME.setLineDash([10, 5]);\n        ctxME.strokeRect(10, 10, 280, 380);\n        ctxME.closePath();\n</script>\n\n<div class=\"show\">pageY、pageX、offsetY、offsetX的值会受到文档/Dom滚动的影响，即在鼠标位置不变的情况下，文档和Dom滚动前后，鼠标事件触发获得的返回值不一样，因为鼠标相对于整个文档/Dom的位置改变了。而clientX、clientY的返回值始终是以当前网页视口左上角为基准进行计算的，与文档、Dom滚动无关\nbox.addEventListener('click',e=>{\n            e.stopPropagation();\n            console.log('offsetX:'+e.offsetX+'px;\\noffsetY:'+e.offsetY+'px;\\n');\n            console.log('pageX:'+e.pageX+'px;\\npageY'+e.pageY+'px;\\n');\n        })</div>\n\n### Dom\n#### client\n+ <span class=\"strong\">Element.clientHeight</span>元素内部的高度，包含padding值，但不包含border，margin和滚动条带来的高度\n+ <span class=\"strong\">Element.clientWidth</span>元素内部的宽度，同上\n+ <span class=\"strong\">Element.clientTop</span>返回元素顶部边框的宽度，即border--top-width的值，表示元素内容(content)到元素顶部的距离\n+ <span class=\"strong\">Element.clientLeft</span>返回元素左边框的宽度，即border-left-width的值，表示元素内容到元素左侧的距离。如果元素左边有垂直滚动条，则该属性包括滚动条的宽度\n\n#### offset\n+ <span class=\"strong\">Element.offsetHeight</span>元素高度，包含padding，border和滚动条，不包含:before 或:after 等伪类元素的高度\n+ <span class=\"strong\">Element.offsetWidth</span>元素的宽度，同上\n+ <span class=\"strong\">Element.offsetTop</span>返回当前元素相对于最近的祖先定位元素的顶部距离，一般是top值+子元素的margin-top值\n+ <span class=\"strong\">Element.offsetLeft</span>返回当前元素相对于最近的祖先定位元素的左侧距离，一般是left值+子元素的margin-left值\n\n#### scroll\n+ <span class=\"strong\">Element.scrollHeight</span> 返回包括溢出部分的元素高度，包括padding值、伪元素的高度，但不包括border、margin和滚动条的值，如果元素不溢出，则该值等于clientHeight\n+ <span class=\"strong\">Element.scrollWidth</span>返回包括溢出部分的元素宽度，内容同上\n\n+ <span class=\"strong\">Element.scrollTop</span>可以设置和获取，代表元素的内容顶部到它的视口可见内容顶部的距离\n+ <span class=\"strong\">Element.scrollTop</span>可以设置和获取，代表元素的内容左边界到它的视口可见内容左边界的距离\n\n\n<canvas width=\"300\" height=\"500\" id=\"canvasScroll\" style=\"display:block;width:300px;height:500px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n      const canvasScroll = document.getElementById('canvasScroll');\n        const ctxScroll = canvasScroll.getContext('2d');\n        ctxScroll.beginPath();\n        ctxScroll.lineWidth = 5;\n        ctxScroll.strokeRect(10, 150, 280, 200);\n        ctxScroll.closePath();\n        ctxScroll.beginPath();\n        ctxScroll.lineWidth = 1;\n        ctxScroll.strokeStyle = \"#f00\";\n        ctxScroll.moveTo(40, 10);\n        ctxScroll.lineTo(40, 490);\n        ctxScroll.moveTo(35, 25);\n        ctxScroll.lineTo(40, 10);\n        ctxScroll.lineTo(45, 25);\n        ctxScroll.moveTo(35, 475);\n        ctxScroll.lineTo(40, 490);\n        ctxScroll.lineTo(45, 475);\n        ctxScroll.font = \"20px Serif\";\n        ctxScroll.fillStyle = \"#f00\";\n        ctxScroll.fillText('scrollHeight', 40, 250)\n        ctxScroll.stroke();\n        ctxScroll.closePath();\n        ctxScroll.beginPath();\n        ctxScroll.strokeStyle = \"#00f\";\n        ctxScroll.moveTo(190, 10);\n        ctxScroll.lineTo(190, 150);\n        ctxScroll.moveTo(185, 25);\n        ctxScroll.lineTo(190, 10);\n        ctxScroll.lineTo(195, 25);\n        ctxScroll.moveTo(185, 135);\n        ctxScroll.lineTo(190, 150);\n        ctxScroll.lineTo(195, 135);\n        ctxScroll.fillStyle = \"#00f\";\n        ctxScroll.fillText('scrollTop', 190, 80)\n        ctxScroll.stroke();\n        ctxScroll.closePath();\n        ctxScroll.beginPath();\n        ctxScroll.strokeStyle = \"#05fe05\";\n        ctxScroll.moveTo(170, 152);\n        ctxScroll.lineTo(170, 348);\n        ctxScroll.moveTo(165, 167);\n        ctxScroll.lineTo(170, 152);\n        ctxScroll.lineTo(175, 167);\n        ctxScroll.moveTo(165, 333);\n        ctxScroll.lineTo(170, 348);\n        ctxScroll.lineTo(175, 333);\n        ctxScroll.stroke();\n        ctxScroll.font = \"20px Serif\";\n        ctxScroll.fillStyle = \"#05fe05\";\n        ctxScroll.fillText('clientHeight', 170, 250)\n        ctxScroll.closePath();\n        ctxScroll.fillStyle = \"#000\";\n        ctxScroll.fillText('元素显示部分', 45, 180)\n        ctxScroll.fillText('元素溢出部分', 45, 30)\n        ctxScroll.beginPath();\n        ctxScroll.strokeStyle = \"#000\";\n        ctxScroll.setLineDash([10, 5]);\n        ctxScroll.strokeRect(20, 10, 260, 480);\n        ctxScroll.closePath();\n</script>\n\n<div class=\"show\">判断元素是否已经滚到底部，以及判定用户是否已经阅读完文本的解决方案：\n判断是否满足scrollHeight-scrollTop=clientHeight，由于scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的整数，因此判断三个值的差值小于某个阈值即可\nMath.abs(ele.scrollHeight - ele.clientHeight - ele.scrollTop)&lt;3\n</div>\n\n### DOMRect对象\n上述属性返回值一般为四舍五入的整数值，通过DOMRect对象可以获得更为精确的浮点数坐标值\n#### Element.getBoundingClientRect()\n该方法会返回一个DOMRect对象，该对象提供了几个描述该Dom位置和大小的属性，这些属性都是基于网页可视窗口的左上角作为坐标原点进行计算的\n\n+ <span class=\"strong\">width</span>返回Dom的宽度，包含padding值和border-width值\n+ <span class=\"strong\">height</span>返回Dom的高度，包含padding值和border-width值\n+ <span class=\"strong\">x/left</span>返回Dom左边界到网页可视窗口左边界的距离\n+ <span class=\"strong\">y/top</span>返回Dom上边界到网页可视窗口上边界的距离\n+ <span class=\"strong\">right</span>返回Dom右边界到网页可视窗口左边界的距离\n+ <span class=\"strong\">bottom</span>返回Dom下边界到网页可视窗口左边界的距离\n\n<canvas width=\"300\" height=\"300\" id=\"canvasDomRect\"\n        style=\"display:block;width:300px;height:300px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n        const canvasDomRect = document.getElementById('canvasDomRect');\n        const ctxDR = canvasDomRect.getContext('2d');\n        ctxDR.beginPath();\n        ctxDR.lineWidth = 2;\n        ctxDR.strokeRect(10, 10, 280, 280);\n        ctxDR.lineWidth = 1;\n        ctxDR.strokeRect(70, 70, 150, 150);\n        ctxDR.stroke();\n        ctxDR.closePath();\n        ctxDR.beginPath();\n        ctxDR.font = \"16px Serif\";\n        ctxDR.strokeStyle = \"#f00\";\n        ctxDR.moveTo(70,200);\n        ctxDR.lineTo(220,200);\n        ctxDR.moveTo(85,195);\n        ctxDR.lineTo(70,200);\n        ctxDR.lineTo(85,205);\n        ctxDR.moveTo(205,195);\n        ctxDR.lineTo(220,200);\n        ctxDR.lineTo(205,205);\n        ctxDR.fillStyle = \"#f00\";\n        ctxDR.fillText('width', 130, 190)\n        ctxDR.fillText('height', 165, 150);\n        ctxDR.moveTo(200,70);\n        ctxDR.lineTo(200,220);\n        ctxDR.moveTo(195,85);\n        ctxDR.lineTo(200,70);\n        ctxDR.lineTo(205,85);\n        ctxDR.moveTo(195,205);\n        ctxDR.lineTo(200,220);\n        ctxDR.lineTo(205,205);\n        ctxDR.stroke();\n        ctxDR.closePath();\n        ctxDR.beginPath();\n        ctxDR.strokeStyle = \"#00f\";\n        ctxDR.moveTo(100, 10);\n        ctxDR.lineTo(100, 70);\n        ctxDR.moveTo(95, 25);\n        ctxDR.lineTo(100, 10);\n        ctxDR.lineTo(105, 25);\n        ctxDR.moveTo(10, 100);\n        ctxDR.lineTo(70, 100);\n        ctxDR.moveTo(25, 95);\n        ctxDR.lineTo(10, 100);\n        ctxDR.lineTo(25, 105);\n        ctxDR.fillStyle = \"#00f\";\n        ctxDR.fillText('y/top', 110, 45)\n        ctxDR.fillText('x/left', 15, 90)\n        ctxDR.stroke();\n        ctxDR.closePath();\n        ctxDR.beginPath();\n        ctxDR.strokeStyle = \"#05fe05\";\n        ctxDR.moveTo(240, 10);\n        ctxDR.lineTo(240, 220);\n        ctxDR.moveTo(235, 25);\n        ctxDR.lineTo(240, 10);\n        ctxDR.lineTo(245, 25);\n        ctxDR.moveTo(10, 240);\n        ctxDR.lineTo(220, 240);\n        ctxDR.moveTo(25, 245);\n        ctxDR.lineTo(10, 240);\n        ctxDR.lineTo(25, 235);\n        ctxDR.stroke();\n        ctxDR.setLineDash([5,2]);\n        ctxDR.moveTo(260,220);\n        ctxDR.lineTo(220, 220);\n        ctxDR.lineTo(220, 260);\n        ctxDR.stroke();\n        ctxDR.fillStyle = \"#05fe05\";\n        ctxDR.fillText('bottom', 230, 140);\n        ctxDR.fillText('right', 100, 255);\n        ctxDR.closePath();\n        ctxDR.fillStyle = \"#000\";\n        ctxDR.fillText('viewPort', 15, 30);\n        ctxDR.fillText('Element', 125, 85);\n    </script>\n\n\n<div class=\"show\">使用前，使用css清除浏览器默认的padding和margin值，避免浏览器默认值带来的影响\n*{\n            margin: 0;\n            padding: 0;\n        }\n但返回值还是会有一些底层渲染和二进制转化带来的误差\n  const box=document.querySelector('.box');\n  const boxRect=box.getBoundingClientRect();\n  console.log(boxRect.width);//eg: 309.6000061035156\n  console.log(boxRect.left);\n</div>\n\n","tags":["javaScript","html"]},{"title":"xml","url":"/blog/2023/05/25/xml/","content":"### 简介\n#### 关于\nXML 指可扩展标记语言(EXtensible Markup Language)，其文件以<span class=\"tips\">.xml</span>为后缀名，主要用于数据存储、数据传输、编写配置文件，语法格式与HTML相似，二者主要差异有：\n+ XML标签没有被预定义，需要自行定义标签；HTML虽然支持自定义标签，但主要使用预定义标签\n+ XML主要用于传输和存储数据，HTML主要用于显示数据\n+ XML语法要求比HTML严格\n\n#### 组成\nxml文档基本由以下模块组成\n+ 标签(元素)：文档主要部分，将被解析为XML DOM\n+ 标签属性：提供关于标签的信息\n+ 转义字符(实体)：XML中预用字符的实体引用\n+ PCDATA(Parsed Character Data)：需要由解析器解析的文本\n+ CDATA(Character Data)：解析器不会解析的文本，内容将视为字符串\n\n### 语法\n#### xml标签定义规范\nxml中的标签需要自定义，标签名需要遵循以下规范\n+ 可以包含字母、数字和其他符号，包括连字符(-)、下划线(_)和点号(.)\n+ 不能以数字或者标点符号开始\n+ 不能以xml、 XML、Xml开始\n+ 不能包含空格\n+ 尽量避免使用<span class=\"tips\">-</span>和<span class=\"tips\">.</span>字符，该类字符在某些XML解析器中中可能会被错误解析\n+ 避免使用<span class=\"tips\">:</span>，该字符用于命名空间\n\n#### xml基本语法格式\n<div class=\"code\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;web> \n&lt;author>SHIWIVI&lt;/author>\n&lt;license>CC BY-NC&lt;/license>\n&lt;heading>&lt;type>Document&lt;/type>&lt;/heading>\n&lt;body>Meet you like the wind&lt;/body>\n&lt;/web></div>\n\n+ 首行进行xml文档声明，version属性定义版本，encoding声明编码格式\n+ 必须包含一个根标签，标签名自定义\n+ XML标签大小写敏感\n+ 所有XML标签都必须闭合，自闭合标签禁止省略<span class=\"tips strong\">/</span>\n+ XML的属性值须加引号，即便属性值是数值，单双引号均可用\n+ XML标签禁止交叉嵌套\n+ XML中多个连续空格也会被保留，HTML中会被合并\n+ XML 以 LF 存储换行\n\n\n<div class=\"show\">xml正确嵌套：\n&lt;a>&lt;b>content&lt;/b>&lt;/a>\n严禁交叉嵌套：\n&lt;a>&lt;b>content&lt;/a>&lt;/b>\n</div>\n\n##### 空标签\nxml允许空标签，即标签中无内容\n<div class=\"show\">&lt;element>&lt;/element>\n空标签可以使用自闭合，但禁止省略 /\n&lt;element /></div>\n\n\n#### 转义字符\n以下字符在XML中被预定义，使用时需要转义\n<div class=\"table\">\n\n字符|转义     |字符|转义|\n----|---------|----|-----\n&lt;|&amp;lt;|&apos;|&amp;apos;\n&gt;|&amp;gt;|&quot;|&amp;quot;\n&amp;|&amp;amp;\n\n</div>\n\n#### CDATA字符数据\nCDATA(character data)指不被xml解析器解析的文本数据，当文档中出现需要大量转义的字符时，可以直接使用CDATA进行引用，这样，这些字符将不会被xml解析器解析，\n\nCDATA 部分由<span class=\"strong tips\">&lt;![CDATA[</span>开始，<span class=\"strong tips\">]]&gt;</span>结束\n<div class=\"show\">&lt;root>\n&lt;title>标题&lt;/title>\n&lt;![CDATA[\n    if(a&lt;b&&b&lt;c){\n    ....\n        }\n    ]]&gt;\n&lt;/root></div>\n\n### 命名空间\n由于xml中标签是自定义的，多个xml文档同时使用可能出现标签名相同导致命名冲突的情况，此时需要使用命名空间来解决标签名冲突问题\n<div class=\"show\">&lt;person>\n&lt;name>周杰伦&lt;/name>\n&lt;song>米兰的小铁匠&lt;/song>\n&lt;/person>\n</div>\n<div class=\"show\">&lt;person>\n&lt;name>东野圭吾&lt;/name>\n&lt;writing>解忧杂货店&lt;/writing>\n&lt;/person></div>\n\n#### 添加前缀\n在标签名前添加前缀，来定义不同的标签，从而对不同文档的同名标签加以区分\n<div class=\"show\">&lt;j:person>\n&lt;j:name>周杰伦&lt;/j:name>\n&lt;j:song>米兰的小铁匠&lt;/j:song>\n&lt;/j:person>\n&lt;h:person>\n&lt;h:name>东野圭吾&lt;/h:name>\n&lt;h:writing>解忧杂货店&lt;/h:writing>\n&lt;/h:person></div>\n\n#### 添加XML Namespace(xmlns)属性\n可以在父标签中添加命名空间属性，以此定义一个命名空间，之后带有相同前缀的子标签都将同属于该命名空间\n<span class=\"strong\">xmlns:命名前缀=\"namespaceURI\"</span>\n\n<div class=\"show\">&lt;j:person xmlns:j=\"Jay Chou\">\n&lt;j:name>周杰伦&lt;/j:name>\n&lt;j:song>米兰的小铁匠&lt;/j:song>\n&lt;/j:person>\n&lt;h:person xmlns:h=\"Higashino Keigo\">\n&lt;h:name>东野圭吾&lt;/h:name>\n&lt;h:writing>解忧杂货店&lt;/h:writing>\n&lt;/h:person></div>\n\n#### 使用默认的命名空间\n当父元素定义默认的命名空间时，我们可以省略子元素中的前缀\n<span class=\"strong\">xmlns=\"namespaceURI\"</span>\n\n<div class=\"show\">&lt;person xmlns=\"Jay Chou\">\n&lt;name>周杰伦&lt;/name>\n&lt;song>米兰的小铁匠&lt;/song>\n&lt;/person>\n&lt;person xmlns=\"Higashino Keigo\">\n&lt;name>东野圭吾&lt;/name>\n&lt;writing>解忧杂货店&lt;/writing>\n&lt;/person></div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\nURI指统一资源标识符(Uniform Resource Identifier)，用于标识因特网资源，最常用的 URI 是用来标示因特网域名地址的统一资源定位器(URL)，另一个不那么常用的 URI 是统一资源命名(URN)，在使用命名空间时，很多xml文档会将名称写为一个链接形式，但该链接仅作为该命名空间的字符串名称，并不是要”链接”到某个地址，不会引入任何资源</div>\n\n### DTD验证\nDTD(Document Type Definition):文档类型定义，是一套为了进行程序间的数据交换而建立的关于标记符的语法规则\n\nxml的标签是可以自由定义的，每个人写的xml将完全不同。但在一个团队内部，我们往往希望拥有一个统一的文件格式来进行数据交换。此时，我们可以使用DTD来对xml文件进行约束，使用一个标准的 DTD 来交换数据\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n使用IntelliJ IDEA写xml文件可以即时校验文档内容是否满足DTD验证</div>\n\n#### 标签声明\n限制标签内可以写入哪些内容\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child1,child2...)> 标签中可以包含的子标签</span>\n父标签中按顺序声明其中可以包含的子标签，子标签必须以相同的顺序出现在xml文档中，并且所有子标签也要声明其中可以写入的内容，子标签可以嵌套地拥有子标签\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child1,(child2|child3)...)> 标签中可以包含的子标签并可选</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (#PCDATA)> 标签中仅包含需要解析的字符数据(可以为空)</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 EMPTY> 声明为空标签</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 ANY> 标签中可包含任何内容 </span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (#PCDATA|child1|child2|...)*> 标签中可包含PCDATA数据，也可以包含指定子标签<span class=\"tips\">必须添加\\*号</span></span>\n\n##### 限制子标签的数量\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child)> 子标签必须出现一次，且只能出现一次</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child+)> 子元素至少出现一次</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child*)> 子元素出现零次或多次</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child?)> 子元素出现零次或一次</span>\n\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n        &lt;!ELEMENT web (author,license,(body|content))>\n        &lt;!ELEMENT author     (#PCDATA)>\n        &lt;!ELEMENT license    (#PCDATA)>\n        &lt;!ELEMENT heading    (#PCDATA|type)*>\n        &lt;!ELEMENT type       (#PCDATA)>\n        &lt;!ELEMENT body       (#PCDATA)>\n        &lt;!ELEMENT content    (#PCDATA)>\n]>\n&lt;web> \n    &lt;author>SHIWIVI&lt;/author>\n    &lt;license>lol&lt;/license>\n    &lt;heading>&lt;type>Document&lt;/type>&lt;/heading>\n    &lt;body>Meet you like the wind&lt;/body>\n&lt;/web>\n1. !DOCTYPE web -  声明文档的根标签是web\n2. !ELEMENT web -  声明web元素必须包含元素：author,license标签，body和content标签可二选一\n3. !ELEMENT author - 声明author标签内容为 \"#PCDATA\"(其余语句同理)\n4. !ELEMENT heading  - 声明author标签内容为 \"#PCDATA\"或type标签，由于标签内容受限，需添加*号表示可出现零次或多次\n</div>\n\n##### 声明实体\n<span class=\"strong\">&lt;!ENTITY 实体引用名称 \"实体实际代表含义\"> 定义一个实体</span>\n引用实体需要添加<span class=\"tips\">&</span>和<span class=\"tips\">;</span>\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n        &lt;!ELEMENT web (author,license)>\n        &lt;!ELEMENT author (#PCDATA)>\n        &lt;!ELEMENT license (#PCDATA)>\n        &lt;!ENTITY sm \"shiwivi.com\">//实体声明\n        &lt;!ENTITY license \"License CC BY-NC 4.0\">\n        ]>\n&lt;web>\n    &lt;author>&amp;sm;&lt;/author>//将解析为&lt;author>shiwivi.com&lt;/author>\n    &lt;license>&amp;license;&lt;/license>\n&lt;/web></div>\n\n\n\n#### 属性声明\n限制标签可添加的属性以及属性值，语法格式为：\n<span class=\"strong\">&lt;!ATTLIST 标签名 属性名 属性类型 属性值></span>\n\n<div class=\"table\">\n\n属性类型     |     说明         |属性类型   |说明\n----------|------------------|---------|----\nCDATA     |字符               |NMTOKEN  |该值是有效的XML名称\n(v1\\|v2\\|..)|值只能为指定内容(枚举)    |NMTOKENS|该值是有效XML名称的列表\nID        |值为唯一ID         |ENTITY\t|值是一个实体\nIDREF      |值是另一个元素的id |ENTITIES|值是实体列表\nIDREFS\t   |该值是其他ID的列表 |xml:\t|该值是预定义的xml值\n</div>\n\n<div class=\"table\">\n\n属性值 | 说明 | 属性值 |说明\n-------|------|-------|-----\n字符串 |属性默认值|#REQUIRED|属性是必需的\n#IMPLIED|属性是可选的|#FIXED 值|属性值是固定的\n\n</div>\n\n<div class=\"show\">1. 限制为test标签添加的属性只能为code，如果开发者不指定属性值，则默认值为java\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n        &lt;!ELEMENT web (test)>\n        &lt;!ELEMENT test EMPTY>\n        &lt;!ATTLIST test code \"java\">//属性声明\n        ]>\n&lt;web>\n    &lt;test code=\"javaScript\"/>\n&lt;/web>\n2. 该标签必须添加code属性，并且不指定默认值\n&lt;!ATTLIST test code CDATA #REQUIRED>\n3. 该标签不强制要求添加code属性，也不指定默认值\n&lt;!ATTLIST test code CDATA #IMPLIED>\n4. 该标签强制拥有code属性并指定属性值为java，且不允许修改\n&lt;!ATTLIST test code CDATA #FIXED \"java\">\n</div>\n\n\n\n\n#### DTD文件引入\n##### 内部DTD\n如果DTD被包含在xml文件中，需要被包装于<span class=\"tips\">DOCTYPE</span>声明中\n<span class=\"strong\">&lt;!DOCTYPE 根标签 [标签声明内容]&gt;</span>\n\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n     &lt;!ELEMENT web (author,license)>\n     &lt;!ELEMENT author (#PCDATA)>\n     &lt;!ELEMENT license (#PCDATA)>\n]&gt;\n&lt;web> \n    .....\n&lt;/web></div>\n\n##### 外部私有DTD\n可以将DTD声明为一个外部文件，然后引用到xml文档中\n<span class=\"strong\">&lt;!DOCTYPE 根标签 SYSTEM \"DTD的URL\"></span>\n\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web SYSTEM \"./check.dtd\">\n&lt;web> \n    ....\n&lt;/web></div>\n<div class=\"code\">&lt;!--check.dtd文件-->\n&lt;!ELEMENT web (author,license)>\n     &lt;!ELEMENT author (#PCDATA)>\n     &lt;!ELEMENT license (#PCDATA)></div>\n\n##### 外部公用DTD\n也可以使用一些标准化组织或权威机构提供的DTD\n<span class=\"strong\">&lt;!DOCTYPE 根标签 PUBLIC \"DTD公共名称\" \"DTD的URL\"></span>\n\nDTD公共名称格式为：<span class=\"strong\">\"是(否)ISO注册//注册组织//DTD所描述的文件的信息//语言\"</span>\n+ 是否由国际标准化组织(ISO)注册，+表示是，-表示不是\n+ 注册组织或个人\n+ 该DTD所验证文件的描述性信息，经常还会添加版本号\n+ 语言标识，如：ZH为中文，EN为英文\n<div class=\"show\">lt;!DOCTYPE web PUBLIC \"-//shiwivi//blog config//CN\" \"http://www.shiwivi.com/blog/check.dtd\"></div>\n","tags":["Serve","Web"]},{"title":"SVG矢量图","url":"/blog/2023/05/19/SVG矢量图/","content":"\n### 简介\n<span class=\"strong\">SVG</span>(Scalable Vector Graphics)全称为可缩放矢量图形，是一种用 XML 标记语言描述二维矢量图形的技术，它有以下特点：\n+ 使用XML语法文本定义图形，因此SVG图形可以被索引、搜索、选中，很适合制作地图\n+ SVG提供的是矢量图，可以被无限放大且不会失真，也可以在任何分辨率下被高质量地打印\n+ SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强\n\n### 使用\n在HTML中使用SVG，可以直接在文档中直接创建SVG标签，也可以先创建svg文件或者xml文件，再引入到HTML中\n#### svg文件\nSVG文件通常以<span class=\"tips\">.svg</span>作为文件后缀，使用<span class=\"tips\">gzip</span>压缩的SVG文件以<span class=\"tips\">.svgz</span>为后缀名\n\n<div class=\"show\">&lt;svg version=\"1.1\"\n     baseProfile=\"full\"\n     width=\"300\" height=\"200\"\n     viewBox=\"0 0 100 100\"\n     xmlns=\"http://www.w3.org/2000/svg\">\n&lt;/svg></div>\n\n+ version属性用于验证识别SVG版本，SVG 2之后的版本不再推荐使用该属性值\n+ baseProfile 属性用于描述作者认为正确呈现内容所必需的最小SVG语言配置文件，当用户修改内容超出所指定的基准概述范围时，编辑工具会发出警告，一般可以不指定，即使用默认值none，可取值：\n> + none(默认)，代表作者无观点，使用最小的 SVG 语言配置\n> + full(正常)，适用于PC\n> + basic(轻量级)，适用于平板电脑等PDA\n> + tiny(更轻量级)，适用于手机\n+ width和height属性用于指定画布大小，单位会自行解析为px而无需指定，默认大小为300px*150px\n+ viewBox属性用于指定显示区域，上述参数解析为仅显示从(0,0)坐标开始，长宽均为100px的矩形区域内的图形\n+ xmlns属性用于声明命名空间，这里的URL只做该命名空间的字符串名称，并不是要\"链接\"到某个地址。命名空间用于多个文档声明了相同的标签时，帮助XML内容的使用者区别该标签属于哪一个命名空间\n+ 拥有命名空间后意味着该&lt;svg> 标签和它的子节点都属于该命名空间\n\n##### svg写入xml文件\n\n<div class=\"show\">&lt;?xml version=\"1.0\" ?>\n&lt;svg version=\"1.1\"\n     baseProfile=\"full\"\n     width=\"300\" height=\"200\"\n     xmlns=\"http://www.w3.org/2000/svg\">\n     &lt;circle cx=\"150\" cy=\"100\" r=\"80\" fill=\"green\" />\n&lt;/svg></div>\n\n\n#### 引入\n##### 直接插入&lt;svg>标签\n可以直接在HTML所需位置插入&lt;svg>标签\n<div class=\"show\">&lt;body>\n     &lt;svg width=\"400\" height=\"300\">\n          &lt;!--svg内容-->\n     &lt;/svg>\n&lt;/body>     \n</div>\n\n##### 通过img标签引入\n可以将svg定义为一个单独文件，然后通过img标签引入图片\n<div class=\"show\">&lt;img src=\"./index.svg\" alt=\"未加载SVG\"></div>\n\n##### CSS引入\n在CSS样式中将svg作为背景图引入\n<div class=\"show\">.svgPic{\n         width: 400px;\n         height: 300px;\n         background-image: url(./index.svg);\n         background-repeat: no-repeat;\n     }\n</div>\n\n##### object标签引入\nobject标签可用于包含音视频及图形对象，并且支持<span class=\"tips\">.svg</span>和<span class=\"tips\">.xml</span>格式的文件\n<div class=\"show\">&lt;object data=\"./index.svg\" type=\"image/svg+xml\" width=\"400\" height=\"300\">未加载SVG&lt;/object></div>\n<div class=\"show\">&lt;object data=\"./index.xml\" type=\"image/svg+xml\" width=\"400\" height=\"300\">未加载SVG&lt;/object></div>\n\n##### iframe标签引入\n使用内联框架引入svg数据，该标签也同时支持<span class=\"tips\">.svg</span>和<span class=\"tips\">.xml</span>文件\n<div class=\"show\">&lt;iframe src=\"./index.svg\"  width=\"400\" height=\"300\">浏览器不支持iframe标签&lt;/iframe></div>\n<div class=\"show\">&lt;iframe src=\"./index.xml\"  width=\"400\" height=\"300\">浏览器不支持iframe标签&lt;/iframe></div>\n\n\n\n### 基本图形\n#### 矩形\n<span class=\"strong\">rect标签</span>\n<div class=\"show\">&lt;rect x=\"10\" y=\"10\" rx=\"20\" ry=\"40\" width=\"200\" height=\"200\" >&lt;/rect></div>\n\n+ (x,y)为矩形左上角坐标\n+ width,height为矩形长和高，不能为负值！(与canvas不同)\n+ rx为矩形与x轴平行的两条边的圆角半径，默认为0\n+ ry为矩形与y轴平行的两条边的圆角半径，默认为0\n\n#### 圆\n<span class=\"strong\">circle标签</span>\n<div class=\"show\">&lt;circle cx=\"100\" cy=\"100\" r=\"50\">&lt;/circle></div>\n\n+ (cx,cy)为圆心坐标\n+ r为圆的半径\n\n#### 椭圆\n<span class=\"strong\">ellipse标签</span>\n<div class=\"show\">&lt;ellipse cx=\"200\" cy=\"200\" rx=\"100\" ry=\"50\">&lt;/ellipse></div>\n\n+ (cx,cy)为椭圆中心的坐标\n+ rx为椭圆的 x 半径，ry为椭圆的 y 半径\n\n#### 线段line\n<div class=\"show\">&lt;line x1=\"150\" y1=\"300\" x2=\"300\" y2=\"350\"stroke=\"#fff\" stroke-width=\"5\">&lt;/line></div>\n\n+ (x1,y1)为线段起始坐标\n+ (x2,y2)为线段终点坐标\n+ stroke指定线段绘制颜色\n\n#### 折线polyline\n<div class=\"show\">&lt;polyline points=\"0 0,10 10,20 0,30 10\" style=\"stroke:#fff;\" /></div>\n\n+ points属性指定折线折点，每个折点必须指定x,y坐标\n+ 坐标之间可以用空白符、逗号、或者可附带空格的换行符分隔开\n\n<div class=\"show\">以下写法均可以表示(0,0)、(10,10)、(20,0)、(30,10)四个坐标点，也可以用换行替代\npoints=\"0 0 10 10 20 0 30 10\"\npoints=\"0 0,10 10,20 0,30 10\"\npoints=\"0,0 10,10 20,0 30,10\"\n</div>\n\n#### 多边形polygon\n<div class=\"show\">&lt;polygon points=\"10 10,60 30,120 10\" style=\"stroke:#fff;\" />\n</div>\n\n+ points属性与polyline类似\n+ 坐标最后一个点会和第一个点闭合\n\n### path路径\n通过描述路径坐标理论上可绘制任意图形，路径坐标的表示方法与上述points属性坐标表示方法相同，可以用空白符、逗号、或者可附带空格的换行符进行分隔\n#### 命令参数\n<div class=\"show\">&lt;path d=\"M250 150 L150 350 L350 350 Z\" /></div>\n\n+ d属性通过\"命令+坐标参数\"的组合来描述路径\n+ 命令为<span class=\"tips\">大写字母</span>时表示<span class=\"strong\">绝对定位</span>，即相对于svg左上角坐标原点的坐标，命令为<span class=\"tips\">小写字母</span>时表示<span class=\"strong\">相对定位</span>，即相对于上一个命令终点的相对位移\n\n 命令包括以下：\n+ M = moveto，移动画笔\n+ L = lineto，绘制直线\n+ H = horizontal lineto，绘制水平直线，只需要x一个参数\n+ V = vertical lineto，绘制垂直直线，只需要y一个参数\n+ C = curveto，绘制三次贝塞尔曲线\n+ S = smooth curveto，可衔接的三次贝塞尔曲线\n+ Q = quadratic Belzier curve，绘制二次贝塞尔曲线\n+ T = smooth quadratic Belzier curveto，绘制可衔接的二次贝塞尔曲线\n+ A = elliptical Arc，绘制弧线\n+ Z = closepath，闭合路径，一般用于路径最后\n\n#### 二阶贝塞尔曲线\n通过给定一个控制点坐标和曲线终点坐标绘制贝塞尔曲线\n<span class=\"strong\">Q x1 y1, x y</span>\n\n+ 只需要一个控制点(x1,y1)\n+ (x,y)为终点坐标\n\n##### 延长的平滑二阶贝塞尔曲线\n可以将多个贝塞尔曲线衔接起来，形成一条更长的曲线\n<span class=\"strong\">T x y</span>\n\n+ 只需要指定曲线终点坐标(x,y)\n+ 如果该命令前为另一个Q命令或T命令，该命令会把上一个命令控制点关于曲线终点的中心对称点作为其控制点\n+ 如果该命令单独使用，则会认为控制点和终点为同一点，绘制一条直线\n<div class=\"show\">&lt;path d=\"M 10 80 Q 50 200 100 100 T 200 120\"/></div>\n<svg width=\"220\" height=\"200\" style=\"display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;\"> <circle cx=\"10\" cy=\"80\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"50\" cy=\"196\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"100\" cy=\"100\" r=\"4\" style=\"fill:#f00;\"/><polyline points=\"10 80, 50 196,100 100\" style=\"stroke:f00;\" /><circle cx=\"150\" cy=\"4\" r=\"4\" style=\"fill:#00f;\"/><circle cx=\"200\" cy=\"120\" r=\"4\" style=\"fill:#00f;\"/><polyline points=\"100 100, 150 4,200 120\" style=\"stroke:#00f;\" /><path d=\"M 10 80 Q 50 200 100 100 T 200 120\"/>\n</svg>\n\n#### 三阶贝塞尔曲线\n通过指定两个控制点，一个终点坐标绘制曲线\n<span class=\"strong\">C x1 y1, x2 y2, x y</span>\n\n+ (x1,y1)(x2,y2)为控制点坐标\n+ (x,y)为曲线终点坐标\n+ c小写时(x,y)应当为上一个路径终点的相对坐标(dx,dy)\n<div class=\"show\">&lt;path d=\"M 10 10 C 0 200, 150 20, 300 300 \"/></div>\n\n\n同理，可以将多个三阶贝塞尔曲线衔接起来，形成一条更长的曲线\n<span class=\"strong\">S x2 y2, x y</span>\n\n+ (x2,y2)为控制点坐标\n+ (x,y)为终点坐标\n+ 如果该命令跟在一个 C 或 S 命令后面，则该曲线的第一个控制点会被设置为前一个曲线第二个控制点关于曲线终点的中心对称点(以此保持斜率不变来保证曲线可以平滑衔接)\n<div class=\"show\">&lt;path d=\"M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 \"/></div>\n<svg width=\"400\" height=\"200\" style=\"display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;\"><circle cx=\"10\" cy=\"10\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"10\" cy=\"150\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"150\" cy=\"20\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"200\" cy=\"50\" r=\"4\" style=\"fill:#f00;\"/><line x1=\"10\" y1=\"10\" x2=\"10\" y2=\"150\" style=\"stroke:#f00;\" /><line x1=\"150\" y1=\"20\" x2=\"200\" y2=\"50\" style=\"stroke:#f00;\" /><circle cx=\"250\" cy=\"80\" r=\"4\" style=\"fill:#00f;\"/><circle cx=\"160\" cy=\"150\" r=\"4\" style=\"fill:#00f;\"/><circle cx=\"396\" cy=\"100\" r=\"4\" style=\"fill:#00f;\"/><line x1=\"200\" y1=\"50\" x2=\"250\" y2=\"80\" style=\"stroke:#00f;\" /><line x1=\"160\" y1=\"150\" x2=\"396\" y2=\"100\" style=\"stroke:#00f;\" /><path d=\"M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 \"/></svg>\n\n### 颜色与样式\n#### 描边\n默认情况下，创建路径后不会进行描边，需要使用<span class=\"stroke\">stroke</span>属性指定描边颜色\n\n+ <span class=\"strong\">stroke=\"颜色\" 指定描边颜色，取值同CSS</span>\n+ <span class=\"strong\">stroke-opacity=\"值\" 单独指定不透明度</span>\n+ <span class=\"strong\">stroke-width=\"值\" 指定描边线宽度</span>\n\n#### 描边终点与折点样式\n+ <span class=\"strong\">stroke-linecap=\"butt/round/square\"  描边终点为正常(平头截断)/圆形线帽/矩形线帽</span>\n+ <span class=\"strong\">stroke-linejoin=\"miter/round/bevel\" 描边折点为尖角/圆角/切角</span>\n+ <span class=\"strong\">stroke-miterlimit=\"值\" 设置折点斜切面的限制长度</span>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n具体样式区别可以参考这篇博文：<a href=\"http://localhost:4000/blog/2023/05/03/canvas/#%E7%BA%BF%E6%AE%B5%E6%8A%98%E7%82%B9\" target=\"_blank\">canvas绘制线段-实线部分</a></div>\n\n#### 填充\n默认情况下，闭合图形或路径的填充色为黑色，可以通过<span class=\"tips\">fill</span>属性修改\n\n+ <span class=\"strong\">fill=\"颜色\" 指定填充颜色，取值同CSS</span>\n+ <span class=\"strong\">fill-opacity=\"值\" 单独指定填充不透明度</span>\n\n#### 虚线\n+ <span class=\"strong\">stroke-dasharray=\"值,值...\" 设置虚线线段和间隙的长度</span>\n+ <span class=\"strong\">stroke-dashoffset=\"值\" 设置虚线偏移值</span>\n\n#### 使用CSS定义样式\nsvg的属性除了能在标签属性中定义外，也能在CSS中直接声明，但仅适用于部分属性\n+ stroke\n+ fill\n\n### 特殊标签\n#### defs标签\ndefs标签用于定义需要重复使用的图形元素，该标签中定义的图形元素不会直接呈现，只供后续调用\n\n#### g标签\n容器标签，用于包含一组标签，然后将该组标签的共同样式属性添加到g标签上，这样该属性值会对所有子标签继承。注意：g标签不支持使用x,y属性来进行定位，需要修改位置时，可以使用transform属性或CSS修改\n\n### 渐变\n#### 线性渐变\n在<span class=\"tips\">&lt;defs></span>标签内创建一个<span class=\"tips\">&lt;linearGradient></span>标签，在该标签内定义线性渐变，并通过<span class=\"tips\">&lt;stop/></span>标签的属性定义颜色、渐变位置、不透明度，然后在需要调用的图形中，用<span class=\"tips\">fill</span>属性或<span class=\"tips\">stroke</span>属性调用<span class=\"tips\">url</span>引用<span class=\"tips\">&lt;linearGradient></span>标签的<span class=\"tips\">ID</span>值(调用类名无效)\n\n\n<span class=\"strong\">&lt;linearGradient x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\">&lt;/linearGradient></span>\n\n+ x1,x2,y1,y2通过确定两个点来定义渐变路径走向，一般取值0-1间的小数，取大于1的值将导致渐变超出图形范围(溢出的渐变部分不可见)\n+ 默认从左往右，即x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\"\n+ x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\"即调整为从上到下\n\n<span class=\"strong\">&lt;stop offset=\"50%\" stop-color=\"#00f\" /></span>\n+ offset属性定义颜色渐变(偏移)位置，可以取0%-100%，也可以取0-1间的小数\n+ stop-color定义颜色，取值同CSS\n+ stop-opacity定义不透明度\n\n<div class=\"show\">&lt;defs>\n     &lt;linearGradient id=\"G1\">\n          &lt;stop offset=\"0%\" stop-color=\"red\"/>\n          &lt;stop offset=\"50%\" stop-color=\"yellow\"/>\n          &lt;stop offset=\"100%\" stop-color=\"blue\"/>\n     &lt;/linearGradient>\n&lt;/defs>\n&lt;rect x=\"0\" y=\"0\" rx=\"10\" ry=\"10\" width=\"300\" height=\"300\" fill=\"url(#G1)\"/></div>\n\n#### 径向渐变\n与线性渐变类似，径向渐变需要在<span class=\"tips\">&lt;defs></span>标签内创建一个<span class=\"tips\">&lt;radialGradient></span>标签，然后通过<span class=\"tips\">&lt;stop/></span>标签的属性定义颜色、渐变位置、不透明度\n\n<span class=\"strong\">&lt;radialGradient cx=\".5\" cy=\".5\" r=\".5\" fx=\".2\" fy=\".2\">&lt;radialGradient></span>\n\n+ cx,cy定义渐变结束所围绕的圆环，取值0-1\n+ r定义渐变圆在当前图形中的占用半径，一般取值0-1，大于1将导致渐变溢出图形\n+ fx,fy定义渐变开始的位置\n\n<div class=\"show\">&lt;defs>\n     &lt;radialGradient cx=\".5\" cy=\".5\" r=\".5\" fx=\".2\" fy=\".2\"  id=\"R1\">\n          &lt;stop offset=\"0%\" stop-color=\"red\"/>\n          &lt;stop offset=\"25%\" stop-color=\"yellow\"/>\n          &lt;stop offset=\"50%\" stop-color=\"blue\"/>\n          &lt;stop offset=\"75%\" stop-color=\"green\"/>\n          &lt;stop offset=\"100%\" stop-color=\"purple\"/>\n     &lt;/radialGradient>\n&lt;/defs>\n&lt;rect class=\"fillRect\" x=\"0\" y=\"0\"  width=\"200\" height=\"200\" fill=\"url(#R1)\"/>\n1. 渐变开始位置为矩形图20%,20%位置\n2. 渐变结束所形成的圆环：圆心位于矩形50%,50%点处，半径为矩形长的50%\n</div>\n\n<svg width=\"200\" height=\"200\" xmlns=\"radialGradientSVG\" style=\"display:block;margin:0 auto;\">\n<defs>\n<radialGradient cx=\".5\" cy=\".5\" r=\".5\" fx=\".2\" fy=\".2\"  id=\"R1\"><stop offset=\"0%\" stop-color=\"red\"/>\n<stop offset=\"25%\" stop-color=\"yellow\"/>\n<stop offset=\"50%\" stop-color=\"blue\"/>\n<stop offset=\"75%\" stop-color=\"green\"/>\n<stop offset=\"100%\" stop-color=\"purple\"/>\n</radialGradient>\n</defs>\n<rect class=\"fillRect\" x=\"0\" y=\"0\"  width=\"200\" height=\"200\" fill=\"url(#R1)\"/>\n</svg>\n\n#### spreadMethod属性\nspreadMethod属性用于指定渐变到达终点的行为，默认情况下，offset为100%时的颜色会填充剩余部分，该属性对线性渐变和径向渐变均生效\n+ pad(默认)，渐变结束后使用终点颜色填充剩下区域\n+ reflect，渐变结束后按反向颜色顺序填充剩下区域\n+ repeat，渐变结束后从头开始填充剩下区域\n\n<div class=\"show\">&lt;linearGradient  id=\"g2\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"pad\">//\n            &lt;stop offset=\"0%\" stop-color=\"red\"/>\n            &lt;stop offset=\"33%\" stop-color=\"yellow\"/>\n            &lt;stop offset=\"66%\" stop-color=\"blue\"/>\n            &lt;stop offset=\"100%\" stop-color=\"green\"/>\n&lt;/linearGradient>\n1. x2=\".5\"指定了颜色渐变填充到矩形的50%位置\n2. pad值会用终点颜色填充剩下区域\n3. reflect值会按绿，蓝，黄，红顺序(与原顺序相反)填充剩下区域\n3. repeat值会按颜色顺序(从头开始)填充剩下区域\n</div>\n<svg style=\"display:block;margin:0 auto;\" width=\"340\" height=\"200\" xmlns=\"spreadMethodSVG\"><defs>\n<linearGradient  id=\"g2\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"pad\">\n            <stop offset=\"0%\" stop-color=\"red\"/>\n            <stop offset=\"33%\" stop-color=\"yellow\"/>\n            <stop offset=\"66%\" stop-color=\"blue\"/>\n            <stop offset=\"100%\" stop-color=\"green\"/>\n        </linearGradient>\n        <linearGradient  id=\"g3\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"reflect\">\n            <stop offset=\"0%\" stop-color=\"red\"/>\n            <stop offset=\"33%\" stop-color=\"yellow\"/>\n            <stop offset=\"66%\" stop-color=\"blue\"/>\n            <stop offset=\"100%\" stop-color=\"green\"/>\n        </linearGradient>\n        <linearGradient  id=\"g4\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"repeat\">\n            <stop offset=\"0%\" stop-color=\"red\"/>\n            <stop offset=\"33%\" stop-color=\"yellow\"/>\n            <stop offset=\"66%\" stop-color=\"blue\"/>\n            <stop offset=\"100%\" stop-color=\"green\"/>\n        </linearGradient>\n</defs>\n        <rect  x=\"0\" y=\"0\" width=\"100\" height=\"130\" fill=\"url(#g2)\"/>\n        <rect  x=\"110\" y=\"0\" width=\"100\" height=\"130\" fill=\"url(#g3)\"/>\n        <rect  x=\"220\" y=\"0\" width=\"100\" height=\"130\" fill=\"url(#g4)\"/>\n</svg>\n\n### Pattern\n\n与canvas相同，svg也有一个模板对象，常用于定义需要重复填充的背景图等。与渐变一样，&lt;pattern> 也需要定义在的 &lt;defs> 内部，然后使用其他图形引用Patterns的ID\n<span class=\"strong\">&lt;pattern x=\"0\" y=\"0\" width=\".25\" height=\".25\">&lt;/pattern></span>\n+ x,y定义Pattern图形的开始位置\n+ width,height决定该Pattern图形会在x轴和y轴上重复几次，0.25意味着将在横轴和纵轴方向上均重复4次\n\n<div class=\"show\">&lt;svg width=\"200\" height=\"200\">\n        &lt;defs>\n&lt;pattern id=\"Pattern\" x=\"0\" y=\"0\" width=\".25\" height=\".25\">\n&lt;rect x=\"0\" y=\"0\" width=\"50\" height=\"50\" fill=\"skyblue\"/>\n&lt;circle cx=\"25\" cy=\"25\" r=\"20\" fill=\"yellow\" fill-opacity=\"0.5\"/>\n    &lt;/pattern>\n        &lt;/defs>\n&lt;rect fill=\"url(#Pattern)\" stroke=\"black\" x=\"0\" y=\"0\" width=\"200\" height=\"200\"/>\n    &lt;/svg>\n</div>\n\n<svg width=\"200\" height=\"200\" xmlns=\"pattern\" style=\"display:block;margin:0 auto;\"><defs><pattern id=\"pattern\" x=\"0\" y=\"0\" width=\".25\" height=\".25\"><rect x=\"0\" y=\"0\" width=\"50\" height=\"50\" fill=\"skyblue\" stroke=\"#000\"/><circle cx=\"25\" cy=\"25\" r=\"20\" fill=\"yellow\" fill-opacity=\"0.5\"/></pattern></defs><rect fill=\"url(#pattern)\" x=\"0\" y=\"0\" width=\"200\" height=\"200\"/>\n</svg>\n\n### 文本\n#### text标签\n\n<span class=\"strong\">&lt;text x=\"0\" y=\"0\">&lt;/text></span>\n+ x,y定义文字左下角在SVG中的开始位置(y值)\n+ 通过fill属性和stroke属性指定文字填充/描边颜色\n+ text-anchor属性决定文本开始方向，可取值：start、middle、end、inherit(该属性一般用于阿拉伯语等从右到左阅读的语言)\n+ 以下属性定义文字大小、字间距等，可以直接定义在标签中，也可以定义在CSS中，取值和CSS大致相同：<span class=\"tips\">font-family</span>、<span class=\"tips\">font-style</span>、<span class=\"tips\">font-weight</span>、<span class=\"tips\">font-size</span>、<span class=\"tips\">letter-spacing</span>、<span class=\"tips\">word-spacing</span>、<span class=\"tips\">text-decoration</span>、<span class=\"tips\">font-variant</span>、<span class=\"tips\">font-size-adjust</span>等，注意，文字的填充和描边需要使用<span class=\"tip\">fill</span>和<span class=\"tips\">stroke</span>属性指定颜色\n\n<div class=\"show\">&lt;style>\n #svgText{\n            text-anchor:start;\n            fill: red;\n            font-size: 20px;\n            font-weight: 900;\n        }\n&lt;/style>\n&lt;svg width=\"600\" height=\"600\"  xmlns=\"http://www.w3.org/2000/svg\">\n&lt;text id=\"svgText\" x=\"10\" y=\"30\">手写的从前&lt;/text>\n&lt;/svg></div>\n\n#### tspan标签\ntspan标签常用于标记出一段文本中的特殊部分，如将某句话的关键词加粗标识，该标签必须包含于<span class=\"tips\">text</span>标签或<span class=\"tips\">tspan</span>标签中\n<span class=\"strong\">&lt;tspan>文本内容&lt;/tspan></span>\n+ 该标签需要置于父级text标签或tspan标签内，且文本在svg的位置跟随父级标签\n+ x,y属性可以为该标签设置一个新的位置坐标，该坐标是相对于svg的坐标原点，无视父级坐标\n+ dx,dy属性可以在父级坐标的基础上，进行偏移\n+ rotate属性可以将文字 进行旋转\n+ 上述属性都允许赋值一个数列，表示为tspan标签中的每个字符设置单独的坐标/旋转值\n\n<div class=\"show\">1. x和y属性是相对于SVG的坐标，可能导致tspan标签内容覆盖到父级文本之上\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan x=\"20\" fill=\"red\">x属性&lt;/tspan>父级标签&lt;/text>\n2. dx,dy属性是在父级坐标基础上进行位移\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan dx=\"20\" fill=\"red\">dx属性&lt;/tspan>父级标签&lt;/text>\n3. x,y,dx,dy的属性值可以为一组数列值，依次指定标签中每个字符的坐标\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan dx=\"20,25,30,35\" fill=\"red\">dx属性赋值数列&lt;/tspan>父级标签&lt;/text>\n4. rotate属性值也可以是单个，或者为一组数列，对字符进行旋转\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan rotate=\"20,30,40,50,60,70,80\" fill=\"red\">dx属性赋值数列&lt;/tspan>父级标签&lt;/text>\n</div>\n\n<svg width=\"400\" height=\"180\" xmlns=\"tspan\" style=\"display:block;margin:0 auto;font-size:18px;\"><rect x=\"0\" y=\"0\" width=\"400\" height=\"400\" fill=\"skyblue\" /><text x=\"0\" y=\"20\" fill=\"#fff\">1.父级标签<tspan x=\"20\" fill=\"red\">x属性</tspan>父级标签</text><text x=\"0\" y=\"60\" fill=\"#fff\">2.父级标签<tspan  dx=\"20\" fill=\"red\">dx属性</tspan>父级标签</text><text x=\"0\" y=\"100\" fill=\"#fff\">3.父级标签<tspan  dx=\"20,25,30,35,40\" fill=\"red\">dx属性赋值数列</tspan>父级标签</text><text x=\"0\" y=\"140\" fill=\"#fff\">4.父级标签<tspan  rotate=\"20,30,40,50,60,70,80\" fill=\"red\">rotate属性赋值数列</tspan>父级标签</text>\n</svg>\n\n#### textPath标签\ntextPath可创建出跟随路径排列的文本，需要通过<span class=\"tips\">xlink:href</span>属性引用路径ID\n\n<div class=\"show\">&lt;path d=\"M 10 80 Q 50 200 100 100 T 200 120\" id=\"my_path\" fill=\"none\" stroke=\"red\"/>\n&lt;text fill=\"skyblue\" font-size=\"20\">\n&lt;textPath  xlink:href=\"#my_path\">So live a life you will remember&lt;/textPath>\n&lt;/text></div>\n\n<svg width=\"300\" height=\"150\" xmlns=\"textPath\" style=\"display:block;margin:0 auto;\"><path d=\"M 10 80 Q 50 200 100 100 T 200 120\" id=\"my_path\" fill=\"none\" stroke=\"red\"/><text fill=\"skyblue\" font-size=\"20\"> <textPath  xlink:href=\"#my_path\">So live a life you will remember</textPath>\n</svg>\n\n### 变形、剪切、遮罩、图片\n#### 变形\n+ <span class=\"strong\">transform=\"translate(x,y)\" 平移</span>(如果只指定一个值，则默认第二个值为0)\n+ <span class=\"strong\">transform=\"rotate(角度值)\" 沿着图形左上角顺时针(正值)旋转</span>\n+ <span class=\"strong\">transform=\"skewX(角度值)或skewY(角度值)\" 在x/y轴方向上斜切</span>\n+ <span class=\"strong\">transform=\"scale(x缩放,y缩放)\" 在x/y轴进行缩放</span>(如果只指定一个值，则默认第二个值等于第一个值)\n+ 多个属性值可以写到一个transform中，用空格隔开\n\n<div class=\"show\"> &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"red\" transform=\"translate(50,10) scale(.2,1.2) rotate(60)\"/></div>\n\n#### clipPath剪切\n定义一个<span class=\"tips\">clipPath</span>标签并指定路径或图形，然后在需要裁剪的目标元素上使用<span class=\"tips\">clip-path</span>属性调用<span class=\"tips\">clipPath</span>标签的ID值进行裁剪，剪裁会保留二者相同部分，对其余部分进行裁剪。该标签一般定义于<span class=\"tips\">defs</span>标签中\n\n<div class=\"show\">&lt;defs>\n        &lt;clipPath id=\"cut\">\n            &lt;rect x=\"200\" y=\"200\" width=\"200\" height=\"100\"/>\n        &lt;/clipPath>\n    &lt;/defs>\n &lt;circle cx=\"300\" cy=\"300\" r=\"100\" fill=\"yellow\" clip-path=\"url(#cut)\"/></div>\n\n #### mask遮罩\n 遮罩常用于制作淡出淡入效果，<span class=\"tips\">mask</span>标签定义于defs标签中，然后在需要添加遮罩的标签中使用<span class=\"tips\">mask</span>属性引用遮罩ID\n\n <div class=\"show\">&lt;defs>\n    &lt;linearGradient id=\"Gradient\">\n      &lt;stop offset=\"0\" stop-color=\"white\" stop-opacity=\"0\"/>\n      &lt;stop offset=\"1\" stop-color=\"white\" stop-opacity=\"1\"/>\n    &lt;/linearGradient>\n    &lt;mask id=\"Mask\">\n      &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"url(#Gradient)\"/>\n    &lt;/mask>\n&lt;/defs>\n\n  &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"green\"/>\n  &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"red\" mask=\"url(#Mask)\" /></div>\n\n#### 图片\nSVG使用<span class=\"tips\">image</span>标签插入图片，并且可以在图像上使用剪切、变形、遮罩等SVG提供的功能\n<span class=\"strong\">&lt;image xlink:href=\"\"/></span>\n+ 可以使用x,y属性指定图片位置\n+ 可以使用width,height属性指定图片宽高\n+ xlink:href属性用于指定图片地址\n<div class=\"show\">&lt;image x=\"50\" y=\"50\" width=\"300\" height=\"300\"  xlink:href=\"../dog.jpg\"/></div>\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nSVG中还有链接、动画、滤镜等标签，详见MDN文档:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element\">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element</a></div>","tags":["Web","html"]},{"title":"Canvas","url":"/blog/2023/05/03/canvas/","content":"\n### 引入\n#### 关于\n<span class=\"tips\">canvas</span>是HTML5新增的标签，用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面，canvas不支持IE8及IE8以下浏览器\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n具体的兼容性可以参考MDN文档：\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas\n\">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas</a></div>\n\n\n#### 创建画布\n##### 通过HTML标签\n可以通过直接添加HTML标签的方式创建canvas，并设置画布的宽高，然后通过<span class=\"tips\">getContext()</span>方法获得画布的 2D 渲染上下文对象，需要为该方法提供<span class=\"tips\">'2d'</span>作为参数，该对象提供了用于在画布上绘图的方法和属性\n<pre><code>&lt;body>\n    &lt;canvas width=\"600\" height=\"400\" id=\"canvas\">&lt/canvas>\n    &ltscript>\n        const canvas=document.getElementById('canvas');\n        const context = canvas.getContext('2d');\n    &lt;/script>\n&lt;/body>\n</code></pre>\n\n##### 通过JavaScript动态创建\n也可以通过JavaScript动态添加canvas并指定宽高，tips:通过JavaScript创建的canvas在写代码时IDE会有代码补全提示\n\n<pre><code> const canvas=document.createElement(\"canvas\");\n    canvas.width=600;\n    canvas.height=400;\n    document.body.appendChild(canvas);\n const context = canvas.getContext('2d');</code></pre>\n\n##### 画布尺寸的说明\n\n+ canvas需要通过属性来设置宽度、高度，且不需要单位\n+ 通过CSS设置canvas的width和height属性，仅用于缩放图像，无法改变画布尺寸，当CSS指定的宽高与画布的宽高比例不一致时，图像会出现扭曲\n+ 默认画布大小为300px * 150px，宽高比为2:1，如果不指定画布的宽高，或者设置了无效值(如负数)，则会使用默认值\n\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n通过CSS设置的Canvas宽高样式只会修改浏览器渲染后所显示图像的宽高，不会修改画布本身及其图像本身的宽高。浏览器会在渲染期间根据CSS对源图像进行伸缩，以适应指定的CSS样式大小。如果 CSS 的指定的宽高尺寸与画布的宽高比例不一致，图像有可能出现扭曲。而通过属性修改的画布宽度和高度，实际会修改Canvas DOM对象的属性值，即画布本身的宽度和高度，并将该DOM对象传递给canvas内部的2d渲染上下文环境对象(CanvasRenderingContext2D)\n</div>\n\n#### 兼容性检查\nIE9之前的浏览器不支持Canvas，如果不兼容canvas，canvas 标签会被浏览器解析为自定义标签，显示标签内的提示信息\n<div class=\"show\">&lt;canvas id=\"canvas\">抱歉，您的浏览器不支持 canvas 标签&lt;/canvas></div>\n    同时要做好JavaScript兼容性检查\n<div class=\"show\">const canvas = document.getElementById('canvas');\n        if (canvas.getContext){\n          const ctx = canvas.getContext('2d');\n        }</div>\n\n# Canvas 2D渲染API\n\n所有API都是基于canvas的2d渲染上下文对象，文中以context或ctx为对象名\n### 绘制\n#### 路径\n+ <span class=\"strong\">moveTo(x,y) 移动画笔到指定坐标</span>\n指定画笔最先开始绘制的点，此后Canvas的绘制方法都是基于上一次的路径终点进行的，仍可以使用moveTo(x,y)修改画笔的坐标到路径终点以外\n\n+ <span class=\"strong\">context.beginPath() 创建一个新路径</span>\n\n在同一个画布中绘制多个独立的图像，应当为每个图像创建不同的子路径，如:为不同的线段设置不同的颜色、线宽等样式，应当为每个线段创建独立的子路径，每个路径内部的样式、属性单独声明，否则后声明的样式会覆盖前面的样式，并且应当为每个独立的路径指定画笔初始点，执行绘制方法\n<div class=\"show\">const canvasPath=document.getElementById(\"canvasPath\");\n   const ctxPath = canvasPath.getContext('2d');\n        ctxPath.lineWidth=5;\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"red\";\n        ctxPath.moveTo(150,50);\n        ctxPath.lineTo(50,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"blue\";\n        ctxPath.moveTo(50,200);\n        ctxPath.lineTo(250,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"yellow\";\n        ctxPath.moveTo(250,200);\n        ctxPath.lineTo(150,50);\n        ctxPath.stroke();\n</div>\n<canvas width=\"300\" height=\"300\" id=\"canvasPath\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasPath=document.getElementById(\"canvasPath\");\n   const ctxPath = canvasPath.getContext('2d');\n        ctxPath.lineWidth=5;\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"red\";\n        ctxPath.moveTo(150,50);\n        ctxPath.lineTo(50,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"blue\";\n        ctxPath.moveTo(50,200);\n        ctxPath.lineTo(250,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"yellow\";\n        ctxPath.moveTo(250,200);\n        ctxPath.lineTo(150,50);\n        ctxPath.stroke();\n</script>\n\n\n\n在使用循环定时器创建动画时，往往需要在每次定时器执行时创建一个新路径，避免上次的路径影响到本次路径的绘制\n<div class=\"show\">const canvas=document.createElement(\"canvas\");\n        canvas.width=300;\n        canvas.height=300;\n        document.body.appendChild(canvas);\n        const ctx = canvas.getContext('2d');\n        let cpx=10;\n        let timer=setInterval(()=>{\n        ctx.beginPath();//每次计时器开始时，开始新路径\n        ctx.clearRect(0,0,300,300);//清空画布\n        ctx.moveTo(50,50);\n        ctx.quadraticCurveTo(cpx+=10,100,50,250);//动态绘制贝塞尔曲线\n        ctx.stroke();\n        if(cpx>=250){\n            clearInterval(timer)\n        }\n        },50)</div>\n\n\n+ <span class=\"strong\">context.closePath(); 闭合当前子路径</span>\n将画笔坐标移回到当前子路径起始点，该方法会尝试从当前点到起始点绘制一条直线，如果图形已经是封闭的或者只有一个点，该方法不会做任何操作，可用于闭合图形\n\n<div class=\"show\">const canvasLine=document.getElementById(\"canvasLine\");\n        const ctxLine = canvasLine.getContext('2d');\n        ctxLine.lineWidth=3;\n        ctxLine.moveTo(150,50);\n        ctxLine.lineTo(100,150);\n        ctxLine.lineTo(200,150);\n        ctxLine.closePath();\n        ctxLine.stroke();</div>\n\n#### 描边\n\n+ <span class=\"strong\">context.stroke() 绘制当前路径</span>\n+ <span class=\"strong\">context.lineWidth=值; 修改描边线条的宽度</span>\n+ <span class=\"strong\">context.strokeStyle=\"颜色/渐变对象/Pattern对象\"; 设置描边样式</span>\n\n#### 填充\n+ <span class=\"strong\">context.fill() 填充已闭合的路径</span>\n+ <span class=\"strong\">context.fillStyle=\"颜色/渐变对象/Pattern对象\"; 设置填充的样式</span>\n\n#### 裁剪\n<span class=\"strong\">context.clip() 根据当前路径进行裁剪</span>\n沿着路径进行裁剪，裁剪路径外的图形将不再显示在Canvas中\n\n#### 清除\n<span class=\"strong\">context.clearRect(x,y,width,height) 清除指定区域内的画布内容</span>\n<div class=\"show\">context.clearRect(0,0,canvas.width,canvas.height)//清空整个画布</div>\n\n#### 封装路径-Path2D对象\n <span class=\"strong\">let myPath2D=new Path2D();</span>\n返回一个Path2D对象，之后可以将路径添加到该对象中，并直接重用对象中的所有路径，stroke()、fill()、clip()均接收该对象作为参数\n<div class=\"show\">const canvas=document.getElementById(\"canvas\");\n        const context = canvas.getContext('2d');\n        let myDesign=new Path2D();\n        //将路径封装到Path2D对象中而非context对象上\n        myDesign.moveTo(50,50);\n        myDesign.lineTo(100,50);\n        myDesign.lineTo(100,100);\n        myDesign.lineTo(50,100);\n        myDesign.lineTo(50,50);\n        //之后可以直接重用封装好的路径\n        context.stroke(myDesign);//描边\n        context.fill(myDesign);//填充\n        context.clip(myDesign);//裁剪\n</div>\n\n#### 位置判断\n+ <span class=\"strong\">context.isPointInStroke(x, y) 返回boolean值，判断(x,y)点是否在当前路径上</span>\n+ <span class=\"strong\">context.isPointInStroke(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径上</span>\n+ <span class=\"strong\">context.isPointInPath(x, y) 返回boolean值，判断(x,y)点是否在当前路径内</span>\n+ <span class=\"strong\">context.isPointInPath(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径内</span>\n\n\n\n\n\n### 线段\n#### 实线线段\n##### 线段路径\n<span class=\"strong\">context.lineTo(x,y) 连接直线路径到指定坐标</span>\n\n##### 线段折点\n<span class=\"strong\">context.lineJoin=\"miter/round/bevel\"; </span>\n\n设置或返回两条线交汇时，线段折线处的样式\n+ <strong>miter</strong> 尖锐折线(默认)\n+ <strong>round</strong> 圆角折线\n+ <strong>bevel</strong> 切角折线\n\n<span class=\"strong\">ctx.miterLimit = value; </span>\n设置或返回边角斜切面的限制长度(默认为10)，下图为miterLimit=2(左)以及miterLimit=10(右)的区别\n<canvas width=\"300\" height=\"150\" id=\"canvasLimit\" style=\"display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasLimit=document.getElementById(\"canvasLimit\");\n        const ctxLimit = canvasLimit.getContext('2d');\n        ctxLimit.lineWidth=20;\n        ctxLimit.lineJoin=\"miter\";\n        ctxLimit.beginPath();\n        ctxLimit.miterLimit=2;\n        ctxLimit.moveTo(40,20);\n        ctxLimit.lineTo(70,100);\n        ctxLimit.lineTo(100,20);\n        ctxLimit.stroke();\n        ctxLimit.beginPath();\n        ctxLimit.miterLimit=10;\n        ctxLimit.moveTo(190,20);\n        ctxLimit.lineTo(220,100);\n        ctxLimit.lineTo(250,20);\n        ctxLimit.stroke();\n       \n</script>\n\n##### 线段末端\n<span class=\"strong\">context.lineCap=\"butt/round/square;\"</span>\n\n设置或返回线段末端线帽的样式，\"round\" 和 \"square\" 值会使线条略微变长\n+ <strong>butt</strong> 末端以方形结束(默认)\n+ <strong>round</strong>末端添加圆形线帽\n+ <strong>square</strong>末端添加一个宽度相同，长度为宽度一半的矩形线帽\n\n\n\n<canvas width=\"400\" height=\"150\" id=\"canvasLine\" style=\"display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasLine=document.getElementById(\"canvasLine\");\n        const ctxLine = canvasLine.getContext('2d');\n        ctxLine.lineWidth=10;\n        ctxLine.beginPath();\n        ctxLine.lineCap=\"butt\";\n        ctxLine.lineJoin=\"miter\";\n        ctxLine.moveTo(90,50);\n        ctxLine.lineTo(150,50);\n        ctxLine.lineTo(190,10);\n        ctxLine.lineTo(230,50);\n        ctxLine.lineTo(290,50);\n        ctxLine.stroke();\n        ctxLine.beginPath();\n        ctxLine.lineCap=\"round\";\n        ctxLine.lineJoin=\"round\";\n        ctxLine.moveTo(90,100);\n        ctxLine.lineTo(150,100);\n        ctxLine.lineTo(190,60);\n        ctxLine.lineTo(230,100);\n        ctxLine.lineTo(290,100);\n        ctxLine.stroke();\n        ctxLine.beginPath();\n        ctxLine.lineCap=\"square\";\n        ctxLine.lineJoin=\"bevel\";\n        ctxLine.moveTo(90,140);\n        ctxLine.lineTo(150,140);\n        ctxLine.lineTo(190,100);\n        ctxLine.lineTo(230,140);\n        ctxLine.lineTo(290,140);\n        ctxLine.stroke();\n        ctxLine.beginPath();\n        ctxLine.setLineDash([5,10]);\n        ctxLine.lineWidth=1;\n        ctxLine.strokeStyle=\"red\";\n        ctxLine.moveTo(90,0)\n        ctxLine.lineTo(90,200)\n        ctxLine.moveTo(290,0)\n        ctxLine.lineTo(290,200)\n        ctxLine.stroke();\n</script>\n\n#### 虚线线段\n+ <span class=\"strong\">context.setLineDash([数组]);</span> 传递一个数组来指定虚线线段和间隙的交替长度，空数组将设置为实线\n+ <span class=\"strong\">context.getLineDash();</span> 返回一个数组，获取当前线段的样式\n\n<div class=\"show\">context.setLineDash([2,10,5,10])\ncontext.moveTo(0,0)\ncontext.lineTo(100,200);\ncontext.stroke();\n</div>\n\n<span class=\"strong\">context.lineDashOffset = value;</span>\n设置虚线偏移值，可实现蚂蚁线效果\n<div class=\"show\">const canvasDash=document.getElementById(\"canvasDash\");\n   const ctxDash = canvasDash.getContext('2d');\n   let offset=0;\n   ctxDash.lineWidth=5;\n   ctxDash.setLineDash([30,20])\n   ctxDash.setLineDash([30,20])\n   ctxDash.moveTo(0,100)\n   ctxDash.lineTo(300,100);\n   function render(){\n       offset++;\n    if(offset>50){\n        offset=0\n    }\n    ctxDash.clearRect(0,0,300,300)\n    ctxDash.lineDashOffset=offset;\n    ctxDash.stroke();\n    requestAnimationFrame(render)\n    }\n    render();</div>\n<canvas width=\"300\" height=\"300\" id=\"canvasDash\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n  const canvasDash=document.getElementById(\"canvasDash\");\n   const ctxDash = canvasDash.getContext('2d');\n   let offset=0;\n   ctxDash.lineWidth=5;\n   ctxDash.setLineDash([30,20])\n   ctxDash.setLineDash([30,20])\n   ctxDash.moveTo(0,100)\n   ctxDash.lineTo(300,100);\n   function render(){\n       offset++;\n    if(offset>50){\n        offset=0\n    }\n    ctxDash.clearRect(0,0,300,300)\n    ctxDash.lineDashOffset=offset;\n    ctxDash.stroke();\n    requestAnimationFrame(render)\n    }\n    render();\n</script>\n\n### 矩形\n##### 矩形路径\n<span class=\"strong\">context.rect(x,y,width,height) 创建矩形路径</span>\n+ x, y为矩形坐标\n+ width为矩形的宽度，正值矩形位于x坐标右侧，负值则位于左侧\n+ height为矩形的高度，正值矩形位于y坐标下方，负值则在上方\n\n仅创建矩形路径，不会显示在画布中，可以使用stroke()方法或fill()方法进行描边绘制或者填充绘制\n\n##### 描边矩形\n<span class=\"strong\">context.strokeRect(x, y, width, height) 绘制描边矩形</span>\n\n创建矩形路径并描边，参数同上，相当于rect()方法和stroke()方法同时执行，可以使用<span class=\"tips\">lineWidth</span>修改线宽，使用<span class=\"tips\">strokeStyle</span>修改线条样式\n\n##### 填充矩形\n<span class=\"strong\">context.fillRect(x, y, width, height) 填充一个矩形</span>\n\n创建矩形路径并填充，参数同上，相当于rect()方法和fill()方法同时执行，可以使用<span class=\"tips\">fillStyle</span>修改填充样式\n\n\n### 渐变对象\n#### 添加渐变色\n<span class=\"strong\">渐变对象名.addColorStop(偏移量,\"颜色\")</span>\n+ 对象名为以下三种渐变对象创建的实例\n+ 偏移量为0~1之间的值，代表渐变开始到渐变终止的位置，等同于CSS中的百分比位置\n+ 颜色取值同CSS\n\n#### 线性渐变对象\n<span class=\"strong\">context.createLinearGradient(x1,y1,x2,y2)</span>\n在(x1,y1)到(x2,y2)矢量方向上创建径向渐变对象，并返回该对象\n\n<div class=\"show\">const ctx = canvas.getContext('2d');\nconst gradient=ctx.createLinearGradient(0,0,600,400);\n        gradient.addColorStop(0,\"red\");\n        gradient.addColorStop(.3,\"#df0\");\n        gradient.addColorStop(1,\"blue\");\n        ctx.strokeStyle=gradient;</div>\n\n#### 径向渐变对象\n<span class=\"strong\">context.createRadialGradient(x0, y0, r0, x1, y1, r1);</span>\n以(x0,y0)为圆心，r0为半径确定一圆，以(x1,y1)为圆心，r1为半径确定另一圆，\n\n根据参数确定两个圆的坐标，绘制放射性渐变的方法\n\n<div class=\"show\">const canvas1=document.getElementById(\"canvas1\");\n    const ctx1 = canvas1.getContext('2d');\n    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);\n    radial.addColorStop(0,\"red\");\n    radial.addColorStop(.25,\"yellow\");\n    radial.addColorStop(.5,\"green\");\n    radial.addColorStop(.75,\"#ff00fb\");\n    radial.addColorStop(1,\"blue\");\n    ctx1.fillStyle=radial;\n    ctx1.fillRect(0,0,300,300)</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvas1\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;\"></canvas>\n<script>\n    const canvas1=document.getElementById(\"canvas1\");\n    const ctx1 = canvas1.getContext('2d');\n    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);\n    radial.addColorStop(0,\"red\");\n    radial.addColorStop(.25,\"yellow\");\n    radial.addColorStop(.5,\"green\");\n    radial.addColorStop(.75,\"#ff00fb\");\n    radial.addColorStop(1,\"blue\");\n    ctx1.fillStyle=radial;\n    ctx1.fillRect(0,0,300,300)\n     ctx1.moveTo(0,0);\n    ctx1.lineTo(50,50);\n    ctx1.stroke();\n    ctx1.moveTo(250,250);\n    ctx1.lineTo(300,300);\n    ctx1.stroke();\n</script>\n\n#### 锥形渐变对象\n<span class=\"strong\">context.createConicGradient(弧度值,x,y)</span>\n以(x,y)为锥形中心创建锥形渐变对象，弧度值角度为渐变开始的位置，角度通过<span class=\"tips\">Math.PI*角度/180</span>运算为弧度值，值可正可负\n\n\n<div class=\"show\">const canvas=document.getElementById(\"canvas\");\n   const ctx = canvas.getContext('2d');\n    const cg=ctx.createConicGradient(Math.PI*45/180,150,150);\n    cg.addColorStop(0,\"red\");\n    cg.addColorStop(.25,\"yellow\");\n    cg.addColorStop(.5,\"green\");\n    cg.addColorStop(.75,\"#ff00fb\");\n    cg.addColorStop(1,\"blue\");\n    ctx.fillStyle=cg;\n    ctx.fillRect(0,0,300,300);</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasCG\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasCG=document.getElementById(\"canvasCG\");\n   const ctxCG = canvasCG.getContext('2d');\n   try{\n     const cg=ctxCG.createConicGradient(Math.PI*45/180,150,150);\n      cg.addColorStop(0,\"red\");\n    cg.addColorStop(.25,\"yellow\");\n    cg.addColorStop(.5,\"green\");\n    cg.addColorStop(.75,\"#ff00fb\");\n    cg.addColorStop(1,\"blue\");\n    ctxCG.fillStyle=cg;\n    ctxCG.fillRect(0,0,300,300);\n   }\n   catch(error){\n    ctxCG.font=\" 800 58px Serif\"\n    ctxCG.fillText(\"浏览器不支\", 0, 100);\n    ctxCG.fillText(\"持锥形渐变\", 0, 150);\n    console.warn(\"浏览器不支持锥形渐变createConicGradient()方法\")}\n   \n</script>\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n锥形渐变兼容性远比线性渐变、径向渐变差，对浏览器内核版本要求较高，详见MDN文档：\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient\" style=\"display:block;word-break: break-all;\">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient</a></div>\n\n\n### Pattern对象\n创建模板对象，\n\n<span class=\"strong\">createPattern(image,重复模式)</span>\nimage为图像源，可以是<span class=\"tips\">&lt;img>图像</span>、<span class=\"tips\">&lt;video>视频</span>、<span class=\"tips\">&lt;canvas>另外一个canvas对象</span>、<span class=\"tips\">canvas的2d上下文对象(CanvasRenderingContext2D)</span>等\n\n\n图像的重复模式可以为<span class=\"tips\">repeat</span>、<span class=\"tips\">repeat-x</span>、<span class=\"tips\">repeat-y</span>、<span class=\"tips\">no-repeat</span>，用法同CSS\n\n<div class=\"show\"> const canvas=document.createElement(\"canvas\");\n        canvas.width=1000;\n        canvas.height=1000;\n        document.body.appendChild(canvas);\n        const ctx=canvas.getContext(\"2d\");\n        let img=new Image();\n        img.src=\"./dog.jpg\";\n        img.onload=function(){\n            const p=ctx.createPattern(img,'repeat-y')\n            ctx.fillStyle=p;\n            ctx.fillRect(0,0,1000,1000)\n        }</div>\n\n### 曲线\n#### 圆与圆弧线绘制\n\n<span class=\"strong\">context.arc(x,y,r,startAngle, endAngle, anticlockwise)</span>\n\n+ x,y为圆弧中心\n+ r为圆弧半径\n+ startAngle, endAngle为圆弧起始点和终点角度，弧度表示，角度为css坐标x轴与y轴夹角\n+ anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制\n<div class=\"show\">const canvasArc=document.getElementById(\"canvasArc\");\n   const ctxArc = canvasArc.getContext('2d');\n   ctxArc.lineWidth=5;\n   ctxArc.arc(150,150,100,0,90/180*Math.PI,true);\n   ctxArc.stroke();</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasArc\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasArc=document.getElementById(\"canvasArc\");\n   const ctxArc = canvasArc.getContext('2d');\n   ctxArc.lineWidth=5;\n   ctxArc.arc(150,150,100,0,90/180*Math.PI,true);\n   ctxArc.stroke();\n</script>\n\n#### 圆弧线绘制方法2\n<span class=\"strong\">context.arcTo(x1, y1, x2, y2, radius)</span>\n\n+ x1, y1为第一个控制点坐标\n+ x2, y2为第二个控制点坐标\n+ radius 为圆弧半径\n\n将当前路径终点与控制点 1 连接的直线，和控制点 1 与控制点 2 连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径\n\n<div class=\"show\"> const canvasArcTo=document.getElementById(\"canvasArcTo\");\n   const ctxArcTo = canvasArcTo.getContext('2d');\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(100,50)\n    ctxArcTo.strokeStyle=\"#000\";\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.arcTo(250,50,250,250,150);\n    ctxArcTo.stroke()\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(50,50)\n    ctxArcTo.setLineDash([5,10]);\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.strokeStyle=\"blue\";\n    ctxArcTo.lineTo(250,50)\n    ctxArcTo.lineTo(250,250)\n    ctxArcTo.stroke()</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasArcTo\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasArcTo=document.getElementById(\"canvasArcTo\");\n   const ctxArcTo = canvasArcTo.getContext('2d');\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(100,50)\n    ctxArcTo.strokeStyle=\"#000\";\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.arcTo(250,50,250,250,150);\n    ctxArcTo.stroke()\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(50,50)\n    ctxArcTo.setLineDash([5,10]);\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.strokeStyle=\"blue\";\n    ctxArcTo.lineTo(250,50)\n    ctxArcTo.lineTo(250,250)\n    ctxArcTo.stroke()\n</script>\n\n#### 椭圆\n<span class=\"strong\">context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);</span>\n\n+ x,y为椭圆圆心的坐标\n+ radiusX 为椭圆长轴的半径，radiusY 为椭圆短轴半径\n+ rotation 为椭圆的旋转角度，以弧度表示\n+ startAngle, endAngle为椭圆圆弧起始点和终点角度，弧度表示\n+ anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制\n\n<div class=\"show\"> const canvasEllipse=document.getElementById(\"canvasEllipse\");\n   const ctxEll = canvasEllipse.getContext('2d');\n   ctxEll.lineWidth=5;\n   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)\n   ctxEll.stroke();</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasEllipse\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasEllipse=document.getElementById(\"canvasEllipse\");\n   const ctxEll = canvasEllipse.getContext('2d');\n   ctxEll.lineWidth=5;\n   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)\n   ctxEll.stroke();\n</script>\n\n#### 贝塞尔曲线\n##### 二阶贝塞尔曲线\n<span class=\"strong\"> context.quadraticCurveTo(cpx, cpy, x, y)</span>\n\n+ cpx, cpy为控制点的坐标\n+ x, y为曲线终点坐标\n+ 起始点坐标为当前路径所在终点，或者可以使用moveTo()控制\n\n<div class=\"show\"> const canvasBC=document.getElementById(\"canvasBezierCurve\");\n   const ctxBC = canvasBC.getContext('2d');\n   ctxBC.lineWidth=2;\n   ctxBC.moveTo(50,50);\n        let cpx=50;\n        let timerBC=setInterval(()=>{\n        //想绘制为动画还需再添加beginPath()和clearRect()方法\n        ctxBC.moveTo(50,50)\n        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)\n        ctxBC.stroke()\n        if(cpx>=350){\n            clearInterval(timerBC)\n        }\n        },100)</div>\n<canvas width=\"300\" height=\"300\" id=\"canvasBezierCurve\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasBC=document.getElementById(\"canvasBezierCurve\");\n   const ctxBC = canvasBC.getContext('2d');\n   ctxBC.lineWidth=2;\n   ctxBC.moveTo(50,50);\n        let cpx=50;\n        let timerBC=setInterval(()=>{\n        ctxBC.moveTo(50,50)\n        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)\n        ctxBC.stroke()\n        if(cpx>=350){\n            clearInterval(timerBC)\n        }\n        },100)\n</script>\n\n\n##### 三阶贝塞尔曲线\n<span class=\"strong\"> context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</span>\n\n+ cp1x, cp1y为第一个控制点的坐标\n+ cp2x, cp2y为第二个控制点的坐标\n+ x, y为曲线终点坐标\n+ 起始点坐标为当前路径所在终点，或者可以使用moveTo()控制\n\n<div class=\"show\"> const canvasBC2=document.getElementById(\"canvasBezierCurve2\");\n   const ctxBC2 = canvasBC2.getContext('2d');\n   ctxBC2.lineWidth=2;\n   ctxBC2.moveTo(50,50);\n    ctxBC2.bezierCurveTo(300, 50, 50, 300,250, 290);\n    ctx2BC.stroke()</div>\n\n\n<canvas width=\"300\" height=\"300\" id=\"canvasBezierCurve2\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasBC2=document.getElementById(\"canvasBezierCurve2\");\n   const ctxBC2 = canvasBC2.getContext('2d');\n   ctxBC2.lineWidth=2;\n   ctxBC2.moveTo(50,50);\n   ctxBC2.bezierCurveTo(250, 50, 50, 250,250, 290);\n   ctxBC2.stroke()  \n</script>\n\n\n\n\n### 文字绘制\n#### 绘制文字\n<span class=\"strong\">context.fillText(text, x, y, [maxWidth]); 对文字进行填充</span>\n\n<span class=\"strong\">context.strokeText(text, x, y, [maxWidth]); 对文字进行描边</span>\n\n+ text指定文本内容\n+ x, y为文本左下角在画布中开始绘制的坐标(因此坐标不应该为0,0)\n+ maxWidth(可选)，指定绘制的最大宽度，会对文本进行水平缩放\n\n#### 获取文本宽度\n<span class=\"strong\">context.measureText(\"文本\");</span>\n\n返回文本的TextMetrics 对象，一般会从该对象中获得文本宽度，以判断文字是否需要在Canva中进行换行\n<div class=\"show\">&lt;canvas width=\"300\" height=\"700\" id=\"canvasText\">&lt;/canvas>\n&lt;script>\nconst canvasText=document.getElementById(\"canvasText\");\nconst ctxText = canvasText.getContext('2d');\nlet string=\"微风需要竹林，溪流需要蜻蜓，乡愁般的离开，需要片片浮萍，青春属于表白，阳光属于窗台，而我想我属于一个，拥有你的未来\";\nctxText.font=\" 30px Serif\";\nlet rowNum=1;//行号\nlet lastIndex=0;//上一行文字的截取索引位置\nlet rowWidth=0;//每一行的文本长度\n    for(let i=0;i&lt;string.length;i++){\n    rowWidth+=ctxText.measureText(string[i]).width;\n        if(rowWidth>canvasText.width){\n            ctxText.fillText(string.substring(lastIndex,i),0,50*rowNum)\n            lastIndex=i--;//substring()截左不截右\n            rowNum++;\n            rowWidth=0;\n        }\n        if(i==string.length-1){\n            ctxText.fillText(string.substring(lastIndex,i+1),0,50*rowNum)\n        }}\n&lt;/script>\n</div>\n\n#### 文本属性\n<span class=\"strong\">context.font = \"value\";</span>\n指定文本属性，默认为 10px sans-serif，value为CSS中的font简写属性，可以按顺序设置<span class=\"tips\">[font-style]&emsp; [font-variant]&emsp;[font-weight]&emsp; font-size[/line-height] &emsp;font-family</span>\n\n+ 必须包含font-size和font-family\n+ font-style：字体样式，常用取值normal(正常)、italic(斜体)、oblique(倾斜)\n+ font-variant：设置小型大写字母，将字母写为大写，但除首字母外的文本将缩小字号，默认为normal，可以修改为small-caps(小型大写字母)\n+ font-weight：设置文本的粗细，常用值：normal(正常)，bold(粗体)，bolder(再加粗)，lighter(细体)，以及100-900的整百数值\n+ font-size必须，line-height为非必须，有line-height时要写为如：16px/20px 的形式\n+ font-family：字体族，5个通用字体：Serif(衬线字体)、Sans-serif(无衬线字体)、Monospace(等宽字体)、Cursive(草书字体)、Fantasy(幻想字体)\n\n<div class=\"show\">const canvasText=document.getElementById(\"canvasText\");\nconst ctxText = canvasText.getContext('2d');\nctxText.font=\" 60px Serif\";\nctxText.fillText(\"hello world\",50,60) //对文字进行填充\nctxText.strokeText(\"hello world\",50,180)//对文字进行描边</div>\n<canvas width=\"400\" height=\"200\" id=\"canvasText\" style=\"display:block;width:340px;height:160px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n    <script>\n       const canvasText=document.getElementById(\"canvasText\");\n       const ctxText = canvasText.getContext('2d');\n       ctxText.font=\" 60px Serif\";\n       ctxText.fillText(\"hello world\",50,60)\n       ctxText.strokeText(\"hello world\",50,180)\n    </script>\n\n#### 文本方向\n<span class=\"strong\">context.direction =\"ltr/rtl/inherit\"; 设置当前文本方向</span> \n\n+ ltr ,从左往右\n+ rtl ,从右往左(部分国家读写习惯)\n+ inherit(默认)，从父元素继承\n\n<span class=\"strong\">context.textAlign = \"left/right/center/start/end\"; 定义文本水平方向上的对齐方式</span> \n\n+ center以绘制文本时的x坐标为基准，一半位于x左边，一半位于右边\n+ start与end属性以direction定义的文本方向为基准\n\n\n<span class=\"strong\">context.textBaseline = \"tophanging/middle/alphabetic/ideographic/bottom\"; 定义文本垂直方向上的对齐方式</span>\n\n+ 与CSS相同，以文本基线为基准，详见MDN文档\n\n\n### 图像与视频绘制\n\n+ <span class=\"strong\">drawImage(image, dx, dy)</span>\n+ <span class=\"strong\">drawImage(image, dx, dy, dWidth, dHeight)  </span>\n+ <span class=\"strong\">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) </span>\n\n    + image为图像源，可以是图片、SVG矢量图、视频、canvas等\n    + dx, dy为图片左上角在画布中开始绘制的位置\n    + dWidth, dHeight为图像在画布上绘制出来的尺寸，会对其进行缩 放、拉抻\n    + sx, sy为裁剪时，距离图像左上角的开始裁剪的位置\n    + sWidth, sHeight为裁剪的宽度和高度，省略该参数则默认裁剪到>右下角，sHeight为负值将从sy反向裁剪\n\n<div class=\"show\">const canvasImg=document.getElementById(\"canvasImg\");\n       const ctxImg = canvasImg.getContext('2d');\n       let img=new Image();\n       img.src=\"./dog.jpg\";\n       img.onload=function(){\n        //仅指定图片在画布中的位置\n        ctxImg.drawImage(img, 50, 50);\n        //指定图片在画布中的位置及缩放尺寸\n        ctxImg.drawImage(img, 50, 50,300,200);\n        //裁剪图片，并指定图片在画布中的位置及缩放尺寸\n        ctxImg.drawImage(img, 50, 50,300,200,0,0,300,300);\n       }</div>\n\n### 移动、旋转、缩放\n<span class=\"strong\">context.translate(x, y); 进行水平和垂直位移</span>\n  修改坐标系的原点，默认原点位于(0,0)，由此移动图像在Canvas中的相对位置，可以在上一次translate(x, y)的基础上再次移动坐标系，多次修改坐标原点\n\n<span class=\"strong\">context.rotate(弧度值); 进行旋转变换</span>\n  修改坐标系的旋转角度，参数为弧度值\n\n<span class=\"strong\">context.scale(x, y); 进行水平和垂直缩放</span>\n  对坐标系x轴和y轴进行伸缩，0-1进行缩小，大于1进行放大，负值则进行水平/垂直翻转后进行缩放\n\n<div class=\"show\">const canvas=document.createElement('canvas');\n        canvas.width=600;\n        canvas.height=600;\n        document.body.append(canvas);\n        const ctx=canvas.getContext('2d');\n        ctx.translate(50,50);\n        ctx.fillRect(0,0,50,100)\n        ctx.translate(100,100);\n        ctx.scale(1,-2)\n        ctx.rotate(180*Math.PI/180)\n        ctx.fillRect(0,0,50,100)</div>\n\n### 阴影\n类似于CSS的阴影效果，注意，阴影应当设置在图形绘画之前，如果设置阴影效果之前已经有图形和文字存在，则阴影不会对这些图形和文字生效\n+ <span class=\"strong\">context.shadowOffsetX = value; 阴影的水平偏移距离</span>\n+ <span class=\"strong\">context.shadowOffsetY = value; 阴影的垂直偏移距离</span>\n+ <span class=\"strong\">context.shadowBlur = value;  阴影的模糊值</span>\n+ <span class=\"strong\">context.shadowColor = \"颜色\"; 阴影颜色</span>\n<div class=\"show\">const ctx=canvas.getContext('2d');\nctx.shadowOffsetX=16;\nctx.shadowOffsetY=8;\nctx.shadowBlur=5;\nctx.shadowColor=\"#575656\";\nctx.moveTo(50,50);\nctx.bezierCurveTo(300, 50, 50, 300,250, 290);\nctx.stroke()</div>\n\n### 滤镜\n类似于CSS3中的效果\n<span class=\"strong\">context.filter = \"一个或多个值\"</span>\n\n+ blur(值px)：高斯模糊\n+ brightness(百分比)：亮度\n+ contrast(百分比)：对比度\n+ grayscale(百分比)：灰度滤镜\n+ hue-rotate(角度deg)：对图像进行色彩旋转的处理\n+ invert(百分比)：反色(呈现出照片底片的效果)\n+ opacity(百分比)：不透明度\n+ sepia(百分比)：褐色处理(怀旧风格)\n+ drop-shadow(x, y, 模糊值, 阴影扩张/收缩, 阴影色)：阴影效果\n\n### 图像合成模式\n<span class=\"strong\">context.globalCompositeOperation = \"type\";</span>\n\n+ <span class=\"strong\">source-over</span> 图像叠加显示(默认)\n+ <span class=\"strong\">source-in</span> 只显示图像重叠部分\n+ <span class=\"strong\">source-out</span> 只显示图像不重叠的部分\n+ <span class=\"strong\">source-atop</span> 后叠加的图像只显示与原图像重叠的部分\n+ <span class=\"strong\">destination-over</span> 将后叠加的图像置于原图像之下\n+ <span class=\"strong\">destination-in</span> 只显示图像重叠部分，并且只显示原图像部分\n+ <span class=\"strong\">destination-out</span> 将原图像抠去与后图像叠加部分显示，并且后图像不显示\n+ <span class=\"strong\">destination-atop</span>将后图像重叠部分替换为原图像并显示\n+ <span class=\"strong\">lighter</span>两图像重叠部分进行颜色相加\n+ <span class=\"strong\">copy</span>去除原图像，只显示新图像\n+ <span class=\"strong\">xor</span>重叠部分透明，其他正常显示\n+ <span class=\"strong\">multiply</span>将重叠部分的顶层像素与底层像素相乘，重叠部分显示为暗黑色\n+ <span class=\"strong\">screen</span>将重叠部分像素倒转，相乘，再倒转，重叠部分显示为亮色\n+ <span class=\"strong\">overlay</span>multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮\n+ <span class=\"strong\">darken</span>保留两个图层中最暗的像素\n+ <span class=\"strong\">lighten</span>保留两个图层中最亮的像素\n+ <span class=\"strong\">color-dodge</span>将底层除以顶层的反置\n+ <span class=\"strong\">color-burn</span>将反置的底层除以顶层，然后将结果反过来\n+ <span class=\"strong\">hard-light</span>类似于叠加，上下图层互换\n+ <span class=\"strong\">soft-light</span>用顶层减去底层或者相反来得到一个正值\n+ <span class=\"strong\">difference</span>一个柔和版本的强光(hard-light),纯黑或纯白不会导致纯黑或纯白\n+ <span class=\"strong\">exclusion</span>和 difference 相似，但对比度较低\n+ <span class=\"strong\">hue</span>保留底层的亮度和色度，同时采用顶层的色调\n+ <span class=\"strong\">saturation</span>保留底层的亮度和色调，同时采用顶层的色度\n+ <span class=\"strong\">color</span>保留了底层的亮度，同时采用了顶层的色调和色度\n+ <span class=\"strong\">luminosity</span>保持底层的色调和色度，同时采用顶层的亮度\n\n### 状态保存与恢复\n+ <span class=\"strong\">context.save() 将当前状态推入栈中</span>\n+ <span class=\"strong\">context.restore() 读取栈顶的状态</span>\n\n将保存当前的裁剪区域、虚线列表、以及各属性值压入栈中，之后可以直接依次读取栈顶存储的状态并直接绘制，会保存的属性值包括：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled\n<div class=\"show\">const canvas=document.getElementById(\"canvas\");\nconst ctx=canvas.getContext('2d');\nctx.fillStyle=\"red\";\nctx.save(); //依次压栈\nctx.fillStyle=\"yellow\";\nctx.save(); //依次压栈\nctx.fillStyle=\"green\";\nctx.restore(); //弹栈\nctx.fillRect(50,50,100,100);//将绘制为黄色而非绿色\n</div>\n\n### 像素操作-ImageData对象\nImageData对象保存了Canvas图像的底层实际像素，可以直接进行读取和写入。其中，像素被保存在Uint8ClampedArray类型的一维数组中，每个数组元素为0-255之间的数据，每4个数组元素为一组代表了一个像素点的RGBA值。如：索引为0-3的数组元素，存储了第一个像素点的红、绿、蓝、不透明度对应的0-255十进制数值，以此类推\n\n<span class=\"strong\">context.getImageData(x,y,width,height)</span>\n返回ImageData对象，获取(x,y)坐标开始，width为宽，height为高的矩形区域中的像素。返回的对象中包含width、height、data数组(Uint8ClampedArray类型)三个属性\n\n <span class=\"strong\">context.putImageData(imagedata对象, dx偏移, dy偏移)</span>\n\ngetImageData()方法可以从(x,y)坐标开始获取一个矩形区域内的像素数据，将该部分数据修改后，可以通过putImageData()方法将数据绘制到canvas中。其中，dx，dy为在(x,y)的基础上进行的偏移量，之前获取到的(x,y)到(x+width,y+height)矩形区域内的图形，修改像素数据后将被绘制到(x+dx,y+dy)开始的同大小矩形区域内\n\n\n <span class=\"strong\">context.putImageData(imagedata对象,dx偏移, dy偏移, dirtyX, dirtyY,dirtyWidth, dirtyHeight)</span>\n+ dx偏移, dy偏移作用同上\n+ (dirtyX, dirtyY)为进行修改像素操作开始的位置坐标\n+ dirtyWidth, dirtyHeight为将进行修改像素操作的矩形区域的长宽\n\n<div class=\"show\">&lt;canvas width=\"300\" height=\"300\" id=\"canvas\">&lt;/canvas>\n    &lt;script>\n       const canvas=document.getElementById(\"canvas\");\n       const ctx = canvas.getContext('2d');\n       let img=new Image();\n       img.src=\"./dog.jpg\";\n       img.onload=function(){\n        ctx.drawImage(img,0,0,300,300);\n        let imageDate=ctx.getImageData(0, 0, 100, 100);\n        //每4个索引为一组，代表一个像素的RGBA值\n        for(let i=0;i&lt;imageDate.data.length;i+=4){\n            //计算每个像素点的灰度值\n            let avg=(imageDate.data[i]+imageDate.data[i+1]+imageDate.data[i+2])/3;\n            imageDate.data[i]=avg; //修改像素点的R\n            imageDate.data[i+1]=avg;//修改像素点的G\n            imageDate.data[i+2]=avg;//修改像素点的B\n            imageDate.data[i+3]=255;//修改像素点不透明度A为1\n        }\n        // 将(10,10)开始，长200，宽200的区域内的像素调为灰色\n        ctxImg.putImageData(imageDate,0,0,10,10,200,200)\n       }\n    &lt;/script>\n</div>\n\n### 案例\n使用图像合成模式的<span class=\"strong\">\"destination-out\"</span>属性值制作刮刮卡\n<div class=\"ticketContainer\" style=\"position:relative;width:100%;\">\n<div class=\"scratchTicket\" style=\"width: 300px;height: 150px;font-size: 24px;color: red;text-align: center;line-height: 150px;margin:0 auto;letter-spacing: 8px;background-color: #ffffff;pointer-events: none;user-select: none;\">再刮一次</div>\n<canvas width=\"300\" height=\"150\" id=\"canvasTicket\" style=\"position:absolute;top:0;left:50%;transform:translateX(-50%);\"></canvas>\n<div class=\"tryAgain\" onclick=\"tryAgain()\" style=\"width: 100px;height: 35px;line-height: 35px;text-align: center;background-color: aqua;border-radius: 5px;cursor: pointer;user-select: none;margin:10px auto;\">再刮一次</div>\n</div>\n<script>\n       const ticketContainer=document.querySelector(\".ticketContainer\");\n       const canvasTicket=document.getElementById(\"canvasTicket\");\n       const contextTicket=canvasTicket.getContext('2d');\n       const p=contextTicket.createPattern(cover(),\"repeat\");\n        contextTicket.fillStyle=p;\n        tryAgain();\n        function tryAgain(){\n            document.querySelector(\".scratchTicket\").innerText=Math.random()>.6?\"恭喜中奖\":\"再刮一次\";\n            contextTicket.clearRect(0,0,300,150);\n            contextTicket.globalCompositeOperation=\"copy\";\n            contextTicket.fillRect(0,0,300,150);\n        }\n        function cover(){\n            const canvasCover=document.createElement('canvas');\n            const coverCtx=canvasCover.getContext('2d');\n            canvasCover.width=60;\n            canvasCover.height=50;\n            coverCtx.fillStyle=\"#6f6d6d\"\n            coverCtx.fillRect(0,0,60,50)\n            coverCtx.rotate(45*Math.PI/180);\n            coverCtx.font=\"300 15px Serif\";\n            coverCtx.fillStyle=\"#333333\"\n            coverCtx.fillText(\"发大财\",20,0)\n            return canvasCover;\n        }\n        let allowedDraw=false;\n        canvasTicket.addEventListener('mousedown',function(){\n            allowedDraw=true;\n        }) \n        canvasTicket.addEventListener('mouseup',function(){\n            allowedDraw=false;\n        })\n        canvasTicket.addEventListener('mousemove',function(event){\n            var event = event || window.event;\n            if(allowedDraw){\n             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器\n              var  x = event.offsetX;\n              var y = event.offsetY;\n            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器\n              var x = event.layerX;\n              var y = event.layerY;\n            }\n            contextTicket.globalCompositeOperation=\"destination-out\";\n            contextTicket.beginPath();\n            contextTicket.arc(x,y,20,0,2*Math.PI);\n            contextTicket.fill();\n            }})\n            canvasTicket.addEventListener('touchstart',function(){\n            let canvasTicketRect=canvasTicket.getBoundingClientRect();\n            canvasTicket.addEventListener('touchmove',function(e){\n                e.preventDefault();\n            var x=e.targetTouches[0].pageX-canvasTicketRect.left;\n            var y=e.targetTouches[0].pageY-canvasTicketRect.top;\n            contextTicket.globalCompositeOperation=\"destination-out\";\n            contextTicket.beginPath();\n            contextTicket.arc(x,y,20,0,2*Math.PI);\n            contextTicket.fill();\n            },{passive:false})    \n        },{passive:false})\n    </script>\n<pre><code>&lt;div class=\"card\">&lt;/div>//底层卡片，显示是否中奖\n&lt;canvas width=\"300\" height=\"150\" id=\"canvas1\">&lt;/canvas>//刮刮乐灰色图层，监听刮开区域\n&lt;div class=\"tryAgain\" onclick=\"tryAgain()\">再刮一次&lt;/div>//重新开始按钮&lt;/div>\n&lt;script>\n       const canvas=document.getElementById(\"canvas1\");\n       const context=canvas.getContext('2d');\n       const p=context.createPattern(cover(),\"repeat\");//创建模板对象，设置图像重复模式\n        context.fillStyle=p;\n        function tryAgain(){\n            document.querySelector(\".card\").innerText=Math.random()>.8?\"恭喜中奖\":\"再刮一次\";\n            context.clearRect(0,0,300,150);\n            context.globalCompositeOperation=\"copy\";\n            context.fillRect(0,0,300,150);\n        }\n        tryAgain();\n        /*\n        *制作刮刮乐封面，返回canvas DOM\n        */\n        function cover(){\n            const canvasCover=document.createElement('canvas');\n            const coverCtx=canvasCover.getContext('2d');\n            canvasCover.width=60;\n            canvasCover.height=50;\n            coverCtx.fillStyle=\"#6f6d6d\"\n            coverCtx.fillRect(0,0,60,50)\n            coverCtx.rotate(45*Math.PI/180);\n            coverCtx.font=\"300 15px Serif\";\n            coverCtx.fillStyle=\"#333333\"\n            coverCtx.fillText(\"发大财\",20,0)\n            return canvasCover;\n        }\n        let allowedDraw=false;\n        canvas.addEventListener('mousedown',function(){\n            allowedDraw=true;\n        }) \n        canvas.addEventListener('mouseup',function(){\n            allowedDraw=false;\n        })\n        canvas.addEventListener('mousemove',function(event){\n            var event = event || window.event;\n            if(allowedDraw){\n             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器\n              var  x = event.offsetX;\n              var y = event.offsetY;\n            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器\n              var x = event.layerX;\n              var y = event.layerY;\n            }\n            context.globalCompositeOperation=\"destination-out\";\n            context.beginPath();\n            context.arc(x,y,20,0,2*Math.PI);\n            context.fill();\n            }})\n            //移动端\n            canvas.addEventListener('touchstart',function(){\n            let canvasRect=canvas.getBoundingClientRect();\n            canvas.addEventListener('touchmove',function(e){\n                e.preventDefault();\n            var x=e.targetTouches[0].pageX-canvasRect.left;\n            var y=e.targetTouches[0].pageY-canvasRect.top;\n            context.globalCompositeOperation=\"destination-out\";\n            context.beginPath();\n            context.arc(x,y,20,0,2*Math.PI);\n            context.fill();\n            },{passive:false})    \n        },{passive:false})\n    &lt;/script></code></pre>\n","tags":["Web","javaScript"]},{"title":"Web的发展旅程","url":"/blog/2022/09/18/History-of-browser/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n了解这些历史解开了此前我心中的一些疑惑，比如：UA标识里为什么同时会有好几个内核的标识？CSS为什么需要写浏览器前缀来做兼容性？</div>\n\n### 世界线的开端\n#### 超文本(Hyper Text )\n<span class=\"strong\">超文本:</span>是指利用链接将非线性分布的节点上的信息联结，把各种不同空间的文字信息组织在一起形成的超级文本。它使得原先的线性文本变成可以通向四面八方的非线性文本，读者查阅文本时可以在任何一个关节点上停下来，进入其他文本，然后再点击、再进入另一文本，理论上，这个过程是可以无限重复的。从而，原先单一的文本变成了无限延伸、扩展的超级文本。\n\n1945年，美国工程师Vannevar Bush(曼哈顿计划的主要组织者、雷神公司创始人之一)提出了一种基于静态缩微胶片页面的memex(memory extender)设备,人们可以在该设备中压缩和存储书籍、文件、通信记录及其索引，并以极快的速度对其进行检索查询。这意味着，人们不用再根据特定的程序，一步一步寻找信息，利用文本间的交叉引用链接,人们可以用非线性的方式查阅信息，由于条件所限，Vannevar Bush的思想在当时并没有变成现实，但这一开创性的信息组织方法，奠定了超文本的基础。\n\n1960年，Ted Nelson在哈弗大学参加计算机编程课时，考虑编写一个文档系统来索引和管理他收藏的笔记，他在进入哈弗大学前曾担任电影制片人，因此他准备将电影镜头引入了该系统的设计中。所有信息都可以通过其他任何地方的链接访问，信息导航是非线性的，这取决于每个访问信息的人，人们可以从一个信息跳转到另外一则信息，就像从一个镜头切换到另外一个镜头。基于这个想法，1963年，Ted Nelson 首次提出了“超文本”的概念。\n\n1968年，美国科学家Doug Engelbart在美国秋季联合计算机会议上展示了第一个超文本系统NLS(oN-Line System)，并首次展示了鼠标、第一个图形用户界面。\n\n#### 万维网的诞生\n1989年，工作于CERN(欧洲核子研究所)的Tim Berners Lee为查找存储在不同计算机上的信息而苦恼，不兼容的网络、磁盘、数据格式和字符编码使得人们查找信息十分困难且低效。于是，他向CERN的领导层提交了一个超文本项目提案，该提案提出建立一个用于CERN研究人员之间交流信息的系统，用以帮助处于不同网络、计算机系统、国家的研究人员共享信息和交流问题。\n\n1990年，Tim Berners Lee开发出了构建Web所需要的三个基本技术：\n+ <span class=\"strong\">统一资源定位符(URL)</span>\n+ <span class=\"strong\">超文本标记语言(HTML)</span>\n+ <span class=\"strong\">超文本传输协议(HTTP)</span>\n\n同年，在同事Robert Cailliau的帮助下，Tim Berners Lee发起建立了一个名为World Wide Web (万维网)的超文本项目。1990年12月，Tim Berners Lee和他的团队开发出了世界上第一个Web浏览器(WorldWideWeb，与万维网同名)，第一个Web服务器(CERN httpd)，并发布了世界上第一个网站：<a href=\"http://info.cern.ch/\">http://info.cern.ch/</a>，万维网就此诞生！\n\n1994年，W3C联盟(万维网联盟)正式成立，由Tim Berners-Lee 担任W3C联盟主任，这是一个非营利性技术组织，旨在对 web 技术进行标准化，以协调服务提供商、内容供应商、实验室等各方协同工作，致力在万维网发展方向上达成共识，并起草发布<span class=\"strong\">W3C标准</span>，主要包括HTML、XHTML、CSS、DOM、ECMAScript标准的规划制定。\n\n#### 浏览器的发展\nWorldWideWeb浏览器最初只能在NeXTSTEP操作系统上使用(next公司老板是大名鼎鼎的乔布斯，后来next被苹果收购，NeXTSTEP系统和OpenStep结合，衍生出了MacOS)，为了解决这个问题，Tim Berners Lee的团队使用C语言重写了WorldWideWeb的许多组件，从而创建了libwww API。\n\n1992年4月，在Robert Cailliau的指导下，赫尔辛基理工大学的4名硕士生小组联合开发出了第一个可运行于Unix的浏览器Erwise，该项目在学生毕业后被搁置了，Tim Berners Lee前往芬兰鼓励该小组毕业后继续开发该项目，但后期由于缺少资金该项目再次被搁置。\n\n1992年，加州大学伯克利分校学生魏培源使用Viola语言将WWW浏览器的组件组合了起来，发布了第二个可以运行于Unix系统中的浏览器ViolaWWW，这是第一个支持添加扩展功能的浏览器，该浏览器得到了CERN的推崇，成为了第一个流行于万维网中的浏览器。\n\n1993年，美国国家超级计算应用中心(NCSA)的俩名员工Marc Andreessen和Eric Bina在接触了ViolaWWW后，为Unix的X窗口系统设计出了Mosaic浏览器，这是第一款可以显示图形界面和图片的浏览器，设计之初就考虑到了非技术用户的使用体验，由此引发了Web网络的爆炸式发展，Web在短短几个月内从鲜为人知变成了无处不在，该浏览器也很快被移植到Amiga、Apple Macintosh和Windows等平台。\n\n### 内核的发展\n#### 开拓者 网景导航者\n1994年4月，Mosaic浏览器的核心开发人员Marc Andreessen离开了NCSA，与几何图形发生器的发明人Jim Clark共同创办了网景公司（Netscape Communications Corporation），网景大量聘用了原有的Mosaic浏览器工程师，但由于Mosaic的版权在NCSA，于是开发团队重写了浏览器代码。\n\n1994年11月，网景发布了大名鼎鼎的<span class=\"strong\">网景导航者（Netscape Navigator）</span>浏览器1.0版本，这是全球第一款商业浏览器，由于公司目标是替代NCSA Mosaic成为全球第一的浏览器，因此将其内部代号定为了\"Mozilla\"，意为Mosaic杀手。1995年，网景开发出了<span class=\"strong\">HTTP cookie、</span><span class=\"strong\">Frame框架、</span><span class=\"strong\">SSL</span>等一系列技术，并创建了<span class=\"strong\">JavaScript</span>语言，网景导航者由于其功能更新迅速，又有新技术的加持，市场份额一度达到了86%。\n\n意气风发的网景将目光转向了操作系统的开发，网景希望开发出一款基于浏览器的操作系统，类似于如今的Chrome OS。这引起了微软的警觉，这一跨越浏览器界限的作业系统，被微软视为是对Windows的直接威胁，微软担心网景抢占他们在操作系统和应用软件方面的市场份额。\n\n\n#### 泥石流 IE\n1995年，为了对抗网景导航者，微软从Spyglass公司(Spyglass是NCSA创建的商业化公司)购买了Mosaic浏览器的源代码和许可，同年8月，微软推出了基于此开发的<span class=\"strong\">Internet Explorer</span>浏览器1.0版本。IE浏览器的发布引发了“浏览器大战”，网景和微软竭力为各自的产品推陈出新，以求占据更大的市场份额。\n\n1996年，微软推出了IE3,这是第一款支持<span class=\"strong\">CSS</span>的商用浏览器。\n\n1997年9月，微软发布了<span class=\"strong\">Trident</span>内核，并推出了第一个以该内核作为引擎的浏览器 IE4。事态开始逐渐失控，微软的团队制作了一个巨大的字母\"E\"模型并将它放在了网景总部的草坪上。网景的团队不甘示弱，推倒了模型并放上了Mozilla的恐龙吉祥物，并写上标语\"Netscape 72，Microsoft 18\"以嘲讽微软IE浏览器的市场份额比网景低。\n\n随后，微软开始不讲武德，将IE集成到了Windows中进行捆绑发行，并投给了苹果1.5亿美元，让苹果撤销之前对微软的侵权指控，附加条件是让苹果在其Macintosh上内置IE浏览器。此外，微软在授权条款中，要求主机厂商们在桌面上展示IE的图标，并不得加入Netscape，否则以涨价方式作为处罚。\n\n微软的垄断式发行卓有成效，当人们看到打开操作系统就有开箱即用的浏览器时，很少会有人再想到网景导航者了，更何况IE是免费的而网景导航者需要付费。微软的一系列操作让IE浏览器的市场份额很快暴涨，直至2002年，IE浏览器的市场份额达到恐怖的96%，比网景的峰值还高。\n\n过高的市场占有率开始使微软养尊处优，没有了网景这一竞争对手的压力，微软放慢了对内核的更新进程，并开始奉行一套自己的Web标准，在IE浏览器中加入了VBScript，DHTML等不遵循W3C公开标准的专属技术，以巩固自己的霸主地位，IE浏览器开始变得臃肿而笨重。由于IE浏览器垄断了市场，不少网页开发者只能迎合微软的Web标准，公开的W3C标准反而不被关注，从而衍生出了一大堆只和IE专属技术契合的网站，使得一些网站只能使用IE浏览器打开。\n\n此外，IE由于市场占有率高，已然成为了蠕虫病毒的主要攻击目标，IE浏览器一旦被发现安全漏洞，蠕虫病毒会由于IE的普及高速传播。IE的泥石流行径为web的发展带来了难以根治的后遗症，而微软的不正当竞争行径也使之背负了多年的反垄断指控。\n\n#### 网景的继承 Mozilla火狐\n除了微软的垄断式打压，网景后期对浏览器的错误定位也成为了网景覆灭的导火索之一。网景在与微软的“浏览器大战”中过分追求为浏览器增加特色功能，将电子邮件、新闻组件、文件编辑等功能塞入了浏览器中，并将其更名为了 Netscape Communicator4.0（网景通讯家）。过多的组件造成整个软件渲染缓慢，臃肿不堪。并且其新增的“特色”功能并没有革命性的创新，反而逐渐脱离了W3C的标准，期间曾一度创造了臭名昭著的<span class=\"tips\">&lt;blink&gt;</span>标签。欠缺的使用体验，再加上微软的流氓式打压，网景浏览器的市场份额一落千丈。\n\n1998年1月，在与微软的“浏览器大战”中失利后，为了挽回市场，网景宣布旗下所有软件对公众免费，并开源了Netscape Communicator4.0的源代码。与此同时，网景发布了一个全新的开源项目Mozilla，其中包含了全新的排版引擎<span class=\"strong\">Gecko</span>，并建立了非正式组织Mozilla，以支持后续的Netscape Communicator开发。\n\n1998年10月，网景宣布Netscape Communicator5.0将使用全新的Gecko引擎，这引起了Netscape开发人员的不满，因为在此之前他们对旧引擎<span class=\"strong\">Mariner</span>进行了长达六个月的改进工作，而此举意味着他们此前的努力将付诸东流。网景的盈利主要依靠网景导航者及其衍生产品的收益，主要支柱遭受巨大打击，此时的网景已经摇摇欲坠，内部进行了大量人员裁剪。诸多原因直接导致Netscape Communicator5.0的发布被极大地推迟了，而此前微软发布的IE4比旧版本的网景通讯家拥有更好的性能，包括对HTML4、CSS、DOM和ECMAScript等W3C标准的支持，市场的天平进一步向微软倾斜。\n\n1998年11月，AOL(美国在线)公司以42亿美元、免税换股的方式收购了网景通讯公司。AOL在证实微软因滥用垄断能力而败诉后(此前微软因垄断问题在和苹果等公司打官司)，AOL向微软提出了索偿诉讼，指控微软在与网景的竞争中滥用垄断能力。2003年5月，微软和AOL达成和解协议，微软将向网景支付7.5亿美元，而AOL允许微软在7年无限制的使用和散布IE浏览器，AOL的这一举动带领网景走向了覆灭。\n\n2000年11月，在推迟将近两年后，网景跳过了Netscape Communicator5.0，发布了基于Gecko引擎的Netscape 6，但此时已是IE5的天下。\n\n2003年7月15日，AOL解散了网景公司，解雇了Gecko的开发人员，并将Gecko及其相关产品的知识产权交给了Mozilla组织，Mozilla组织接收了大量Gecko的开发人员。同一天，Mozilla基金会正式成立，其目的是保证Mozilla组织可以在没有网景以后能继续生存下去。\n\n2004年11月，Mozilla发布了Firefox(火狐)1.0版本，起初，Firefox被命名为Phoenix，寓意网景导航者的欲火重生，但由于与一家科技公司重名而改为了Firebird，该名称又和一个数据库软件重名，最后Mozilla 将名称确定为了Firefox。\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nMozilla还负责运行维护MDN开发者平台，该平台提供了大量关于HTML、CSS、JavaScript和Web API的免费文档资料，是最好的Web开发资源平台之一。</div>\n\n#### 勤劳的蜜蜂 苹果safari\n在safari之前，苹果Macintosh系列计算机所使用的默认浏览器为网景导航者、Cyberdog（苹果自行开发的浏览器，由于苹果经营不善该项目被裁掉）和IE。\n\n2001年6月，苹果fork了由KDE社区(一个崇尚开源自由的软件社区)开发的开源渲染引擎KHTML和JS引擎KJS，然后利用适配器库将其移植到了苹果的Mac OS X系统上，并重命名为WebCore和JavaScriptCore。经过苹果二次开发的KHTML和KJS拥有了更为严谨的代码结构和更快的渲染速度，苹果将其命名为<span class=\"strong\">Webkit</span>引擎。\n\n2003年1月，苹果发布了首个以此为内核的<span class=\"strong\">safari</span>浏览器\n\n2005年6月，苹果开源了Webkit源代码，同年12月，添加了对SVG(矢量图)的支持\n\n2007年，苹果开始对CSS进行拓展，使得CSS开始支持动画、过渡、2D和3D变换，并于2009年将其以草案的方式发布给了网维网联盟进行标准化，辛勤的苹果为CSS标准库提供了大量的草案和建议。\n\n#### 新的引领 谷歌chrome\nWebkit的高效和稳定引来了谷歌的青睐，2008年9月，谷歌发布了以Webkit为引擎的<span class=\"strong\">Chrome</span>浏览器,实际上，Chrome还使用了Mozilla等组织的诸多开源组件来增强性能。\n\n2010年苹果发布了Webkit2，由于Webkit2使用的进程隔离技术与谷歌的沙箱设计存在冲突，谷歌决定在WebKit的基础上自行开发引擎。谷歌的工程师们fork了WebKit的Webcore渲染引擎，并对源代码作了大量的精简和修改，而JS引擎将谷歌自行开发。\n\n2013年4月，谷歌发布并开源了全新的浏览器内核<span class=\"strong\">Blink</span>，其名字来源于网景创建的臭名昭著的<span class=\"tips\">&lt;blink&gt;</span>标签，谷歌的工程师戏虐的表示：\"我们永远不会支持blink标签\"。此外，谷歌还开发出了强悍的JavaScript解释器——V8引擎(基于Strongtalk)，大大加快了chrome的JS解析速度。\n\n随着Blink的发布，Opera等浏览器厂商纷纷宣布将转向使用Blink引擎。2015年3月，微软宣布放弃IE浏览器的开发，转而使用Microsoft Edge取代IE。2020年，微软宣布Microsoft Edge浏览器将弃用EdgeHTML转而使用Blink内核。\n\n#### 兢兢业业的Opear\n1994年，挪威电信公司Telenor的两名员工Jon Stephenson von Tetzchner和Geir Ivarsøy开始开发Opear浏览器，后来，他们离开了Telenor并创立了Opear Software，并于1995年4月发布了Opear浏览器\n\n2003年1月，欧朋发布就基于<span class=\"strong\">Presto</span>内核的Opera 7\n\n2010年，欧朋首创了选项卡堆叠、鼠标手势等功能，这些功能后来也被其他浏览器大量应用\n\n2013年2月，欧朋宣布放弃presto转而使用Webkit，2013年4月，欧朋跟随谷歌转而使用Blink引擎。\n\n2016年2月，欧朋被360公司和昆仑万维收购\n\n欧朋浏览器自发布以来严格遵守W3C标准，老老实实地开发使用符合W3C规范的技术拓展，然而“浏览器大战”与IE的横行造就了一大堆不符合W3C标准的网页，由于Opear不支持非标准的技术栈，这些网页在Opear上往往会解析错误，Opear的兢兢业业反而为其带来了负面的用户口碑，因为用户只会将页面的不解析归咎于浏览器的问题。\n\n2001年10月，随着WindowsXP的发布，微软对MSN通讯软件进行了重大更新，随后就有用户反馈无法使用Opear浏览器进入MSN主页。微软随即甩锅解释是因为Opear浏览器不支持W3C的XHTML技术规范导致。Opear公司反驳表示，Opear浏览器比微软更能满足W3C标准，并给出了W3C验证服务结果：微软的MSN主页使用了非标准的编码。Opear公司还制作了一份标准XHTML的页面进行还击，经过测试，网景6、Opear 等浏览器能正确访问该页面，而IE 6则无法正常显示。随后，微软开始排挤Opear用户，谷歌在发布Chrome后也曾排挤Opear，直至Opear改用Blink引擎后才有所好转。\n\nOpear在不断遭受排挤后开始考虑支持非标准拓展，Opear公司为浏览器添加了伪装功能，允许用户将Opear伪装为IE、Firefox等浏览器以解决某些网站排挤Opear的问题，兢兢业业的欧朋由于遵守W3C标准反而吃了不少亏，这不是欺负老实人吗!!（胡万腔）\n\n#### 国产浏览器\n中国互联网发展最快的时间刚好遇上了IE浏览器霸榜的时代，由于IE的Trident内核市场占有率较高，许多网页设计者不得不将以IE的标准作为优先考量，直接导致许多政府机构、高校、企业、银行的网站只能在IE浏览器上正常访问，而在更支持W3C标准的safari、chrome、Firefox等浏览器反而会出现加载或解析错误的情况。为此，国内的浏览器厂商们整合了IE的Trident内核与苹果的Webkit内核，美其名曰双内核并以此作为宣传浏览器的噱头(其实都是别人家的内核)。兼容模式下，浏览器会启用Trident内核以适应脱离w3c标准的垃圾网页。\n\n### 浏览器UA标识\nUA为User Agent的简写，指浏览器等软件在网络协议中工作时，会向服务器等对等方提交一个特征字符串，方便对方识别应用类型、操作系统、软件版本号等信息。例如：由于手机屏幕和电脑屏幕尺寸相差巨大，网站设计者一般会为手机端和电脑端设计两个不同大小的网页(或者响应式网页)，当我们访问网站时，服务器会通过UA标识(或者屏幕大小)检测到我们使用的设备是手机还是电脑，从而返回相应的网页。浏览器UA的语法格式通常为：\n<div class=\"show\"><span class=\"strong\">&lt;product> /&lt;version> (&lt;system-information>) &lt;platform> (&lt;platform-details>) &lt;extensions></span></div>\n\n\n\nUA也起源于著名的“浏览器之战”，当时，由于网景首先开创使用了JavaScript、Frames框架等技术，使得网景导航者浏览器的使用体验一骑绝尘，当时的网景导航者支持图片嵌入、网页嵌入等技术，而Mosaic、Samba等一些比较旧的浏览器只支持显示简单的HTML文档。为了提高网站的使用体验，网站设计者们往往希望网页拥有比较前沿的技术设计，但用户的浏览器却不一定支持网站的新颖技术。解决这一问题，UA嗅探技术诞生了。通过UA，网站会动态识别访问用户的浏览器，如：如果是网景导航者，则返回带有Frames框架技术的高级网页内容，如果为Mosaic，则只需返回简单的HTML文档即可。\n\n起初，网景的UA长这样：\n<div class=\"show\"><code>Mozilla/1.0 (win3.1)</code></div>\n\n后来，IE浏览器诞生，IE及其他浏览器逐步追上了网景的脚步，并开始支持网景的特色功能，但由于它们起步较晚，绝大多数网站仍只支持为带有Mozilla标识的浏览器返回高级网页。于是乎，微软等公司的在UA中添加了Mozilla的标识来“欺骗”Web服务器，于是，IE浏览器的标识写为了：\n\n<div class=\"show\"><code>Mozilla/1.22 (compatible;MSIE 2.0;Windows 95)</code></div>\n\n后来，网景飞升，留下了遗孤Mozilla ，Mozilla 打造 Gecko并发布了Firefox，Firefox的UA写为了\n<div class=\"show\"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0</code></div>\n\n再后来，KDE社区开发出了KHTML引擎，并发布了嵌入式浏览器 Konqueror，但网页不给他们分发高级内容，他们很烦，于是他们也伪装成了Mozilla，并且表示KHTML跟Gecko一样好~\n<div class=\"show\"><code>Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)</code></div>\n\n\n后来，苹果基于KHTML开发出了WebKit，他们又在KHTML的UA上套了一层娃\n<div class=\"show\"><code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5</code></div>\n\n再再后来，谷歌又在WebKit基础上开发出了blink，他们也想套娃\n<div class=\"show\"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13</code></div>\n\n于是，人人都是网景Mozilla\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n参考：<a href=\"https://webaim.org/blog/user-agent-string-history/\">user-agent-string-history</a></div>\n\n\n### 代码兼容性\n#### CSS浏览器前缀\n为了兼容旧版本的浏览器，对于比较新颖的CSS样式我们需要添加浏览器前缀\n<div class=\"table\">\n\n浏览器 | 内核 | 前缀\n------|------|----\nIE    |Trident|-ms-\nFirefox|Gecko| -moz-\nOpera |Presto| -o-\nSafari | WebKit|-webkit-\nChrome |WebKit| -webkit-\n\n</div>\n\n#### 渲染内核\n##### 双核浏览器\n对于双核浏览器，我们可以使用<span class=\"tips\">meta</span>标签指定内核渲染网页，国内的双核浏览器一般是Trident内核和webkit内核，因此选其一。\n<div class=\"show\">使用webkit渲染网页，用于提高渲染速度\n&lt;meta name=\"renderer\" content=\"webkit\"> \n使用IE兼容内核，用于兼容为低版本IE浏览器\n&lt;meta name=\"renderer\" content=\"ie-comp\">\n使用IE标准内核，用于网站用了IE专属技术\n&lt;meta name=\"renderer\" content=\"ie-stand\">\n</div>\n\n\n##### IE浏览器\n<span class=\"tips\">X-UA-Compatible</span>是IE8的一个专有<meta>属性，它用来指示IE8以上浏览器采用何种IE版本去渲染网页\n\n常用值有：\n<div class=\"show\">使用最高版本的IE内核渲染\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n启用谷歌内嵌框架Chrome Frame(谷歌推出的IE插件)进行渲染，没有则使用最高版本的IE内核渲染（推荐使用）\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge,chrome=1\" />\n</div>\n\n其他还支持\n<div class=\"show\">使用IE7内核渲染\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" />\n值可并列，该值表示IE8降级使用IE7内核渲染，若有IE9则使用IE9\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7;IE=9\" />\n</div>\n\n","tags":["Web","CS"]},{"title":"基于certbot获取TLS证书","url":"/blog/2022/07/29/lets-encrypt/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nLet’s Encrypt 官网：<a href=\"https://letsencrypt.org/\">https://letsencrypt.org/</a></div>\n\n### 关于 \n#### Let's Encrypt\nLet’s Encrypt 是由 ISRG (Internet Security Research Group)推出的免费安全证书计划，我们可以利用Let’s Encrypt 提供的TLS证书，在我们的网站上部署HTTPS 服务。\n\n#### ISRG\nISRG（Internet Security Research Group ，互联网安全研究小组）是一个公益性的组织，该公益组织旨在减少资金、技术、教育障碍，以保护互联网上的通信，推动全球网站的HTTPS化。ISRG成立于2013 年 5 月，起初由Mozilla、电子前沿基金会(EFF)、密歇根大学、思科和 Akamai共同建立，后来又得了谷歌、亚马逊、讯飞、IBM、RedHat、Linux基金会等大厂商的赞助，所以他们的技术和证书安全是可以保障的。\n\n#### Certbot\nCertbot 是由电子前沿基金会 (EFF)制作的免费开源软件工具，用于在网站上申请、管理、使用由Let's Encrypt颁发的证书，证书每60天更新一次。\n\n### 前置需要\n+ 一台可用的服务器，并拥有<span class=\"tips\">root</span>权限\n+ 安装了Web服务，以<span class=\"tips\">Nginx</span>为例\n+ 一个可用的域名，并解析到了该服务器上\n\n### 安装certbot\n#### 官方安装\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\ncertbot官方文档：<a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></div>\n\n官网文档里给出了不同系统的详细安装方法，但在安装过程中会遇到不少问题，有些甚至涉及到需要重新编译Linux内核，这在已经部署业务的服务器上往往是无法实现的。\n\n以CentOS7为例，根据官方的文档，安装Certbot需要先添加EPEL存储库，然后从中安装snapd软件包，但安装snapd需要解决诸多依赖问题：\n+ 安装snapd需要Linux内核支持 SquashFS 文件系统\n+ 手动编译安装的SquashFS 文件系统，yum可能无法识别\n+ 内核编译时需要启用CONFIG_DEVPTS_MULTIPLE_INSTANCES 选项，如果没有需要重新编译内核\n\n#### 通过pip3安装\n如果无法安装snapd，那只能绕过它，通过其他包管理工具安装，以pip（python包管理工具）为例\n\n安装python并通过pip安装certbot\n<pre><code>yum install -y python3 && pip3 install certbot</code></pre>\n\n##### pip3版本较低报错问题\n在安装certbot时，如果yum源中的pip3版本较低，可能会导致模块导入失败，从而报错\n<div class=\"shell\">Complete output from command python setup.py egg_info:\n            =============================DEBUG ASSISTANCE==========================\n            If you are seeing an error here please try the following to\n            successfully install cryptography:\n            Upgrade to the latest pip and try again. This will fix errors for most\n            users. See: https://pip.pypa.io/en/stable/installing/#upgrading-pip\n            =============================DEBUG ASSISTANCE==========================\n    Traceback (most recent call last):\n      File \"&lt;string>\", line 1, in &lt;module>\n      File \"/tmp/pip-build-2bwzqu_0/cryptography/setup.py\", line 14, in &lt;module>\n        from setuptools_rust import RustExtension\n    ModuleNotFoundError: No module named 'setuptools_rust'\n    ----------------------------------------\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-2bwzqu_0/cryptography/</div>\n\n此时根据报错提示，升级pip3到最新版本即可\n<pre><code>sudo pip3 install --upgrade pip</code></pre>\n\n升级完毕再安装certbot\n<pre><code>pip3 install certbot</code></pre>\n\n\n\n### 申请证书\n#### 验证域名\n申请证书前，Let’s Encrypt需要先验证域名，以确认用户拥有对域名的控制权。验证通过后，certbot会立马进入申请流程，因此下述命令会同时验证域名和申请证书。certbot针对不同的web服务器和需求，有多种不同的验证方式：\n##### 1. Nginx\n如果部署了Nginx，可以直接执行（但要确保安装了certbot-nginx插件）\n<pre><code>sudo certbot --nginx</code></pre>\ncertbot将自动获取域名，并在进入证书申请流程时让你确认域名，也可以在执行上述命令时通过添加<span class=\"tips\">-d</span>参数来指定域名，如：\n<div class=\"show\"><code>sudo certbot -&zwnj;-nginx -d  shiwivi.com -d  www.shiwivi.com</code></div>\n\n可以通过<span class=\"tips\">-&zwnj;-email</span>来添加邮箱，Let’s Encrypt会在证书即将到期时发邮件通知你更新证书。\n<div class=\"show\"><code>sudo certbot -&zwnj;-nginx --email xxxx@gmail.com -d  shiwivi.com -d  www.shiwivi.com</code></div>\n\n如果不添加上述参数，certbot会在验证通过后要求你添加，邮箱一般只需要在首次验证证书或者更改邮箱时添加。\n\n##### 2. Apache\nApache中的验证方法与上类似\n<pre><code>sudo certbot --apache</code></pre>\n\n##### 3. Webroot模式\n上述方法会重启我们的web服务以重新加载配置文件，如果我们希望在颁发证书时，不重启web服务，则可以使用webroot模式。webroot模式下，certbot 会利用已经部署的 web 服务，在其 web 服务根目录下创建名为<span class=\"tips\">/.well-known/acme-challenge</span>的隐藏文件，然后由 Let’s Encrypt 服务端通过域名来访问该隐藏文件，从而完成验证。\n\n因此，在执行命令时，我们需要添加<span class=\"tips\">-w</span>参数来引导certbot找到web服务的根目录\n\n<pre><code>certbot certonly --webroot -w 网站根目录 -d 域名</code></pre>\n如：Nginx默认放置网页的根目录为：<span class=\"tips\">/usr/local/nginx/html</span>，则对应命令为\n<div class=\"show\"><code>certbot certonly --webroot -w /usr/local/nginx/html -d shiwivi.com</code></div>\n\n\n##### 3. Standalone模式\n如果服务器上没有部署任何web服务，或者不想使用已部署的服务，则可以使用Standalone模式，该模式下，certbot 会自动运行一个 web server 来进行验证。该服务需要占用<span class=\"tips\">80</span>端口，如果我们自己的服务器上已经有 web server 正在运行 （如 Nginx 或 Apache ）并且占用了80端口，则使用Standalone前应该关闭相关服务或修改端口。\n<pre><code>certbot certonly --standalone -d 域名</code></pre>\n可以在命令中指定验证的端口和协议\n<div class=\"show\"><code>certbot certonly --standalone --&lt;challenge-type>-address  -d 域名</code></div>\n\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n更多验证方法详见官方文档：<a href=\"https://eff-certbot.readthedocs.io/en/stable/\">https://eff-certbot.readthedocs.io/en/stable/</a></div>\n\n#### 申请流程\ncertbot完成认证后会开始进入申请流程，初次申请证书，可能需要经历以下流程：\n\n+ certbot会提示你阅读并同意使用者条款\n+ 让你输入一个email地址以推送消息，在证书快到期时，lets encrypt会发邮件提醒你及时更新证书\n+ 询问是否愿意将该邮箱提供给EFF，他们会推送有关lets encrypt 的资讯\n\n邮箱的添加可以在一开始使用<span class=\"tips\"></span>\n\n\n证书申请成功后，certbot会返回如下提示信息，其中较为重要的信息包括证书与密钥路径，证书到期时间\n\n<div class=\"shell\">IMPORTANT NOTES:\n - Congratulations! Your certificate and chain have been saved at:\n   /etc/letsencrypt/live/newyear1234.xyz/fullchain.pem\n   Your key file has been saved at:\n   /etc/letsencrypt/live/newyear1234.xyz/privkey.pem\n   Your certificate will expire on 2022-10-27. To obtain a new or\n   tweaked version of this certificate in the future, simply run\n   certbot again. To non-interactively renew *all* of your\n   certificates, run \"certbot renew\"\n - If you like Certbot, please consider supporting our work by:\n\n   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate\n   Donating to EFF:                    https://eff.org/donate-le</div>\n\n#### 插件未安装报错问题\n以nginx为例，执行<span class=\"tips\">sudo certbot -&zwnj;-nginx</span>时，可能会有nginx插件未被正确安装报错\n<div class=\"shell\">The requested nginx plugin does not appear to be installed</div>\n\n安装nginx插件\n<pre><code>yum install python-certbot-nginx</code></pre>\n\n问题叠问题，如果源中没有该插件包，又可能会遇到报错提示无有效的包\n<div class=\"shell\">No package python-certbot-nginx available.\nError: Nothing to do</div>\n\n此时需要更换一下repo 源，更换前记得先将自己的源的备份\n<pre><code>yum remove -y epel-release  # 先移除当前的包</code></pre>\n<pre><code>yum clean all -v     # 清除所有下载缓存的包，并显示过程</code></pre>\n<pre><code>yum makecache        # 重新将远程服务器的包下载缓存到本地</code></pre>\n<pre><code>yum install -y epel-release # 重新安装 epel </code></pre>\n\n安装完epel，再重新尝试安装插件，安装完成就可以开始申请证书了\n<pre><code>yum install python-certbot-nginx</code></pre>\n\n#### web服务无法找到报错问题\n执行<span class=\"tips\">sudo certbot -&zwnj;-nginx</span>时，还可能会遇到 certbot 无法找到 web server 或配置文件报错，这是路径问题，可以建一个软链接到 /etc/nginx 目录下\n<pre><code>ln -s /usr/local/nginx/conf/ /etc/nginx</code></pre>\n或者在申请证书时手动指定nginx配置文件路径\n<pre><code>certbot --nginx-server-root /usr/local/nginx/conf</code></pre>\n\n### 文件说明\n证书申请成功后，相关文件会放置在<span class=\"tips\">/etc/letsencrypt</span>目录下，一般就用得到证书和密钥文件\n#### 密钥与证书\n证书和密钥位于 <span class=\"tips\">/etc/letsencrypt/live/域名.xx/</span> 路径下，该路径下有如下几个文件（配置时一般只需要fullchain.pem和privkey.pem文件）：\n\n+ <span class=\"strong\">fullchain.pem：</span>完整的证书链文件，包含了cert.pem和chain.pem文件中的内容\n+ <span class=\"strong\">privkey.pem：</span>证书对应的私钥\n+ cert.pem：证书文件，需要与chain.pem文件结合使用\n+ chain.pem：链文件，包含了浏览器解析所需的其他全部证书，比如根证书和中间证书\n+ README：说明文件\n\n#### 通用配置文件\n在<span class=\"tips\">/etc/letsencrypt</span>路径下会生成Nginx的通用配置文件<span class=\"tips\">options-ssl-nginx.conf</span>\n<div class=\"shell\">ssl_session_cache shared:le_nginx_SSL:10m;\nssl_session_timeout 1440m;\n\nssl_protocols TLSv1.2;\nssl_prefer_server_ciphers off;\n\nssl_ciphers \"FCDHE-FCLSA....\";</div>\n\n+ ssl_session_cache：会话缓存\n+ ssl_session_timeout：用户会话缓存失效时间，如果对安全性有较高要求，可以降低此值\n+ ssl_protocols：加密协议\n+ ssl_prefer_server_ciphers：是否开启服务端加密算法优先\n+ ssl_ciphers：加密算法列表\n\n#### 密钥交换\n在<span class=\"tips\">/etc/letsencrypt</span>路径下还有一个用于密钥交换算法的Diffie-Hellman 密钥<span class=\"tips\">ssl-dhparams.pem</span>\n\n#### 历史文件\n<span class=\"tips\">/etc/letsencrypt/archive</span>和<span class=\"tips\">/etc/letsencrypt/keys</span>包含所有以前的密钥和证书，而<span class=\"tips\">/etc/letsencrypt/live</span>目录下保存了最新的证书和密钥\n\n#### 日志文件\n默认情况下，certbot 的日志文件位于/var/log/letsencrypt 路径下。且默认情况下，一旦日志目录中有 1000 条日志，certbot 就会开始日志轮替。\n\n\n\n### Nginx配置文件\n\n<div class=\"show\">server {\nlisten 443 ssl;\n\n#配置SSL证书和密钥路径\nssl_certificate    /etc/letsencrypt/live/域名/fullchain.pem;\nssl_certificate_key    /etc/letsencrypt/live/域名/privkey.pem;\n\n#可以将certbot生成的通用配置文件包含进去，自由选择\ninclude    /etc/letsencrypt/options-ssl-nginx.conf;\n\n#使用生成的Diffie-Hellman 密钥，自由选择\nssl_dhparam    /etc/letsencrypt/ssl-dhparams.pem;\n......\n}</div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nDiffie-Hellman密钥用于密钥交换</div>\n\n\n### 常用命令\n#### 测试自动续订\n+ <span class=\"strong\">sudo certbot renew -&zwnj;-dry-run</span> 测试更新证书\n\n如果测试成功，certbot会返回成功信息\n<div class=\"shell\">- - - - -\nAccount registered.\nSimulating renewal of an existing certificate for newyear110.xyz\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nCongratulations, all simulated renewals succeeded: \n  /etc/letsencrypt/live/newyear110.xyz/fullchain.pem (success)\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </div>\n\n##### 插件未安装报错\n在测试续订时，如果遇到插件未安装的报错，则需要安装nginx插件\n<div class=\"shell\">Failed to renew certificate newyear110.xyz with error: \nThe requested nginx plugin does not appear to be installed</div>\n\n安装<span class=\"tips\">letsencrypt-nginx</span>插件\n<pre><code>pip3 install -U letsencrypt-nginx</code></pre>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n更多关于插件未安装的报错，可以查看github上的Issues，上述解决方法也来源于该贴：<a href=\"https://github.com/certbot/certbot/issues/1736\">https://github.com/certbot/certbot/issues/1736</a></div>\n\n#### 续订证书\n\n+ <span class=\"strong\">certbot renew</span> 自动更新30天内到期的证书（推荐）\n+ <span class=\"strong\">certbot renew -&zwnj;-force-renewal</span> 强制更新未到期的证书\n\n\n\n在初次申请证书时，certbot会记住所使用的配置和插件，并在续订时使用相同的配置和插件。如果需要更改配置（如：修改文件路径），则需要以下步骤\n1. 在命令行中使用修改以后的配置进行一次测试自动续订\n2. 测试成功，说明新的配置是可以运行的，再执行一次证书更新（时间未到就使用强制更新），这将保存新的配置\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nCA机构会限制证书颁发速度并阻止用户在短时间内多次续订同一个域名的证书，所以不要在短时间内多次执行强制更新证书操作</div>\n\n\n\n\n\n#### 查看证书列表\n+ <span class=\"strong\">certbot certificates</span> 查看证书\n\n会返回当前所有域名的证书情况，包括证书名、 证书序列号、密钥类型、到期时间、证书路径、私钥路径信息\n<div class=\"show\">Found the following certs:\n  Certificate Name: newyear110.xyz\n    Serial Number: 34829c6e3465f2b1b90db11c36111480280\n    Key Type: RSA\n    Domains: newyear110.xyz\n    Expiry Date: 2022-10-27 11:47:25+00:00 (VALID: 87 days)\n    Certificate Path: /etc/letsencrypt/live/newyear110.xyz/fullchain.pem\n    Private Key Path: /etc/letsencrypt/live/newyear110.xyz/privkey.pem\n</div>\n\n#### 吊销与删除证书\n删除与吊销证书前，应当从web服务器软件的配置文件中删除对对应证书的引用\n+ <span class=\"strong\">certbot revoke -&zwnj;-cert-name 域名.xxx</span> 吊销证书(根据域名)\n+ <span class=\"strong\">certbot revoke -&zwnj;-cert-path /etc/letsencrypt/live/域名.xxx/cert.pem</span> 吊销证书(根据路径)\n+ <span class=\"strong\">certbot delete -&zwnj;-cert-name 域名.xxx</span> 删除指定证书\n+ <span class=\"strong\">certbot delete</span> 从列表中选择删除证书\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n官方命令和文档：<a href=\"https://eff-certbot.readthedocs.io/en/stable/using.html\">https://eff-certbot.readthedocs.io/en/stable/using.html</a></div>\n","tags":["Server","Web"]},{"title":"路由与路由守卫","url":"/blog/2022/07/16/路由与路由守卫/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nvue路由官方网站：<a href=\"https://router.vuejs.org/zh/\">https://router.vuejs.org/zh/</a></div>\n\n### 入门\n#### 介绍\n+ Vue Router 是Vue的官方路由插件，用于构建单页应用\n+ 页面不刷新，配合ajax实现页面的局部更新，并响应式更新地址栏URL\n+ 在工程中，普通组件一般放在components下，而路由组件放于pages目录下\n+ 切换组件时，未调用的组件是被销毁的，调用时被挂载\n+ 整个应用由一个<span class=\"tips\">router</span>(路由器)统一管理，通过<span class=\"tips\">$router</span>调用\n+ 但每个路由组件都有自己的<span class=\"tips\">$route</span>属性\n\n#### 安装vue router\nvue2的工程使用vue-router3，vue3的工程使用vue-router4，版本需要对应，这里以安装vue-router3为例\n\n在脚手架中执行：\n<code><pre>npm i vue-router@3</pre></code>\n\n### 路由的使用\n案例：通过组件嵌套，实现功能\n1. 在app单个页面中通过按钮实现Home和About页面的切换\n2. About页面中嵌套aboutMe和aboutWeb页面\n\n<span class=\"strong\">1. 新建pages目录，存放Home.vue、About.vue、aboutMe、aboutWeb组件</span>\n\nHome.vue文件:\n<pre><code>&lt;template>\n  &lt;div class=\"home\">\n    &lt;h2>Home页面&lt;/h2>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n    name:'pageHome'\n  }\n&lt;/script></code></pre>\n\nAbout.vue文件:\n<pre><code>&lt;template>\n  &lt;div class=\"about\">\n    &lt;h2>About页面&lt;/h2>\n    &lt;div class=\"about-btn\">\n    &lt;!--router-link标签路由切换按钮的两种写法，该标签最后会被解析为a标签-->\n    &lt;!--1. 根据路径调用组件-->\n    &lt;router-link to=\"/about/aboutWeb\">关于网页&lt;/router-link> \n    &lt;router-link to=\"/about/aboutMe\">关于我&lt;/router-link> \n    &lt;!--2. 根据路由规则中的name属性调用组件-->\n    &lt;router-link :to=\"{name: 'aboutme'}\">关于网页&lt;/router-link> \n    &lt;router-link :to=\"{name: 'aboutweb'}\">关于我&lt;/router-link> \n    &lt;/div>\n    &lt;div class=\"about-content\">\n    &lt;!--子组件显示的位置-->\n    &lt;router-view>&lt;/router-view> \n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n &lt;script>\n export default {\n     name:'pageAbout'\n }\n&lt;/script></code></pre>\n\naboutWeb.vue文件 (aboutMe.vue类似)\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">{{t}}&lt;/li>\n    &lt;/ul>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:{\n                前端:'html/css/javaScript',\n                后端:'java',\n                系统:'CentOS7',\n                服务器:'nginx'\n            }\n        }\n    }\n }\n&lt;/script></code></pre>\n\n<span class=\"strong\">2. 新建router目录，新建index.js文件用于创建路由器</span>\nindex.js文件：\n<pre><code>// 引入vueRouter插件\nimport VueRouter from \"vue-router\";\n//引入路由组件\nimport Home from '../pages/pageHome'\nimport About from '../pages/pageAbout'\nimport aboutMe from '../pages/aboutMe'\nimport aboutWeb from '../pages/aboutWeb'\n// 创建路由器\nexport default new VueRouter({\n    // 创建路由规则一个{}内为一条路由\n    routes:[\n        {\n            name: 'home',    //路由规则指定的组件别名\n            path:'/home',   //路由路径\n            component:Home //调用的组件\n        },\n        {   \n            name: 'about',\n            path:'/about',\n            component:About,\n            children:[     //组件嵌套\n                {   \n                    name:'aboutme',\n                    path:'aboutMe',\n                    component:aboutMe\n                },\n                {   \n                    name:'aboutweb',\n                    path:'aboutWeb',\n                    component:aboutWeb\n                }\n            ]\n        }\n    ]\n })\n</code></pre>\n\n<span class=\"strong\">3. 在main.js中引入路由器</span>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\n// 引入vue-router\nimport VueRouter from 'vue-router'\n// 使用vue-router\nVue.use(VueRouter)\n// 引入创建的路由器\nimport router from './router'\nnew Vue({\n  render: h => h(App),\n  router:router   //配置路由器\n}).$mount('#app')</code></pre>\n\n<span class=\"strong\">4. 在App中调用路由组件</span>\n\n<pre><code>&lt;template>\n  &lt;div id=\"app\">\n    &lt;div class=\"btn\">\n      &lt;!-- active-class用于指定该链接按钮被选中时生效的样式-->\n      &lt;router-link class=\"link\" active-class=\"active\" to=\"/home\">Home&lt;/router-link>\n      &lt;router-link class=\"link\" active-class=\"active\" to=\"/about\">About&lt;/router-link>\n      &lt;!-- 同样，to可以写为对象形式 -->\n      &lt;router-link class=\"link\" active-class=\"active\" :to=\"{name:'home'}\">Home&lt;/router-link>\n      &lt;router-link class=\"link\" active-class=\"active\" :to=\"{name:'about'}\">About&lt;/router-link>\n    &lt;/div>\n    &lt;div class=\"content\">\n      &lt;!-- 指定组件显示的位置 -->\n      &lt;router-view>&lt;/router-view>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n  name:'App',\n }\n&lt;/script></code></pre>\n\n### 路由传参\n#### query传参\n父组件可通过向<span class=\"tips\"> to </span>属性添加参数进行传参，类似于带参数的http请求，子路由可通过<span class=\"tips\">$route.query.参数名</span>读取数据\n\n案例：为aboutWeb组件添加子组件webTech，并由aboutWeb向webTech传参\n\n##### 方法1：通过字符串传参\n在路由路径后添加查询字符串<span class=\"tips\"> ? </span>，并在之后以键值对的方式传参。\n\n父组件 aboutWeb.vue\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">\n        &lt;!-- 字符串写法 -->\n        &lt;!-- 注意：由于to前使用了:解析js语法，因此要添加``将语句解析为字符串 -->\n        &lt;router-link :to=\"`/about/aboutWeb/webTech?name=${t.name}&lang=${t.language}`\">{{t.name}}&lt;/router-link>\n        &lt;/li>\n    &lt;/ul>\n    &lt;router-view>&lt;/router-view>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:[\n                {name:'前端',language:'html/css/javaScript'},\n                {name:'框架',language:'vue'},\n                {name:'后端',language:'java'},\n                {name:'系统',language:'CentOS7'},\n                {name:'服务器',language:'nginx'},\n                ]\n            }\n        }\n }\n&lt;/script></code></pre>\n\n##### 方法2：通过对象传参\n\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">\n        &lt;!-- 对象写法 -->\n            &lt;router-link :to=\"{\n            path:'/about/aboutWeb/webTech',\n            query:{\n                name:t.name,\n                lang:t.language\n            }\n            }\">\n            {{t.name}}\n            &lt;/router-link>\n        &lt;/li>\n    &lt;/ul>\n    &lt;router-view>&lt;/router-view>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:[\n                {name:'前端',language:'html/css/javaScript'},\n                {name:'框架',language:'vue'},\n                {name:'后端',language:'java'},\n                {name:'系统',language:'CentOS7'},\n                {name:'服务器',language:'nginx'},\n                ]\n            }\n        }\n }\n&lt;/script></code></pre>\n\n##### 子路由读取参数\nwebTech.vue文件：\n<pre><code>&lt;template>\n  &lt;div class=\"show\">\n  &lt;!-- 读取数据 -->\n    &lt;span class=\"tech-name\">{{$route.query.name}}：&lt;/span>\n    &lt;span class=\"tech-lang\">{{$route.query.lang}}&lt;/span>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n export default {\n    name:'webTech'\n }\n&lt;/script></code></pre>\n\n#### params传参\n##### 方法1：通过字符串传参\n通过字符串传参时，必须在配置路由规则时在<span class=\"tips\">path</span>路径中指定解析的参数\n\n<pre><code> {   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    path:'webTech/:name/:lang', //在路径中解析参数\n    conpontent:webTech\n  }]\n      }</code></pre>\n\n父组件通过附带参数的路径传输参数\n<pre><code>&lt;router-link :to=\"`/about/aboutWeb/webTech?name=${t.name}&lang=${t.language}`\">{{t.name}}&lt;/router-link></code></pre>\n\n子组件通过<span class=\"tips\">$route.params.参数名</span>读取参数\n<pre><code>&lt;span class=\"tech-name\">{{$route.params.name}}&lt;/span>\n&lt;span class=\"tech-lang\">{{$route.params.lang}}&lt;/span></code></pre>\n\n##### 方法2：通过对象传参\n通过对象传参时，<span class=\"tips\">to</span>属性不能再使用<span class=\"tips\">path</span>调用组件，而需要使用<span class=\"tips\">name</span>属性，因此路由规则中一定需要给予组件name属性\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' //必须\n    path:'webTech/:name/:lang', //必须\n    conpontent:webTech\n  }]\n      }</code></pre>\n\n传参的父组件\n<pre><code>&lt;router-link :to=\"{\n            name:'webtech', //不能使用path\n            params:{\n                name:t.name,\n                lang:t.language\n            }}\">\n            {{t.name}}\n&lt;/router-link></code></pre>\n子组件通过<span class=\"tips\">$route.params.参数名</span>读取参数，代码同上\n\n#### props属性\n当需要大量调用参数时，频繁使用$route.query增加了代码量，可以在路由中配置<span class=\"tips\">props</span>属性简化代码。props属性支持三种配置方法。\n\n##### 1. 对象形式，传输固定参数\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' \n    path:'webTech',\n    conpontent:webTech,\n    //对象形式，传输固定参数\n    props:{ name:'框架',\n            lang:'Vue'}\n  }]\n      }</code></pre>\n##### 2. 函数形式，传输指定参数(用query)\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' \n    path:'webTech',\n    conpontent:webTech,\n    //对象形式，传输固定参数\n    pros(route){\n      return {\n        name: route.query.name,\n        lang: route.query.language\n      }\n    }\n  }]\n      }</code></pre>\n\n##### 3. 布尔值，自动传输所有params参数\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' \n    path:'webTech/:name/:lang', //自动传输所有参数\n    conpontent:webTech,\n    //布尔值形式\n    pros: true\n  }]\n      }</code></pre>\n##### 接收参数\n子组件需要通过<span class=\"tips\">props</span>属性接收参数\n<pre><code>&lt;span>{{name}}&lt;/span> //直接调用\n&lt;span>{{lang}}&lt;/span>\nexport default{\n   name:'webTech',\n  pros:['name','lang'] //接收参数\n   }</code></pre>\n\n### 路由导航\n路由导航分为声明式和编程式\n+ <span class=\"strong\">声明式：</span>通过&lt;router-link>配置to属性实现跳转\n+ <span class=\"strong\">编程式：</span>通过调用push、back等API跳转组件\n\n#### 路由导航与浏览器历史记录\n浏览器历史记录默认为<span class=\"tips\">push</span>状态，组件的跳转会记录到历史记录中，通过浏览器的前进/后退按钮，或者调用<span class=\"tips\">go</span>、<span class=\"tips\">back</span>等API，能根据历史记录实现页面的前进、回退。当浏览器历史记录切换为<span class=\"tips\">replace</span>状态时，浏览器会使用当前页面的记录替换掉上一条历史记录。\n<pre><code> &lt;--跳转到About页面后，About页面的历史记录会替换掉该页的历史记录，此时无法再使用浏览器的回退按钮返回该页面了-->\n&lt;router-link replace to=\"...\">跳转到About页面&lt;/router-link></code></pre>\n\n#### 编程式路由导航\n不借助&lt;router-link>标签，实现路由跳转\nAPI：\n+ <span class=\"strong\">push：</span>跳转到指定路由组件\n+ <span class=\"strong\">replace：</span>跳转到指定路由组件并替换浏览器历史记录\n+ <span class=\"strong\">back：</span>回退\n+ <span class=\"strong\">forward：</span>前进(需要之前回退过)\n+ <span class=\"strong\">go(值)：</span>根据值前进/回退指定次数\n\neg：通过按钮实现(或div)实现路由跳转\n<pre><code>&lt;template>\n  &lt;div>\n   &lt;button class=\"link\" @click=\"backTo\">回退&lt;/button>\n    &lt;button class=\"link\" @click=\"forwardTo\">前进&lt;/button>\n    &lt;button class=\"link\" @click=\"goTo\">跳转&lt;/button>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">\n            &lt;button @click=\"pushTo(t)\">push&lt;/button>\n            &lt;button @click=\"replaceTo(t)\">replace&lt;/button>\n        &lt;/li>\n    &lt;/ul>\n    &lt;router-view>&lt;/router-view>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:[\n                {name:'前端',language:'html/css/javaScript'},\n                {name:'后端',language:'java'},\n                {name:'系统',language:'CentOS7'},\n                {name:'服务器',language:'nginx'},\n                ]\n            }\n        },\n    methods:{\n        backTo(){\n      this.$router.back() //回退一次\n    },\n    forwardTo(){\n      this.$router.forward() //前进一次\n    },\n    goTo(){\n      this.$router.go(-2) //，回退2步，正数前进，负数后退\n    },\n        pushTo(m){    //跳转到指定组件\n            this.$router.push({\n                path:'/about/aboutWeb/webTech',\n                query:{\n                name:m.name,\n                lang:m.language\n            }\n            })\n        },\n        replaceTo(n){  //跳转到指定组件并替换上一个历史记录\n            this.$router.replace({\n                path:'/about/aboutWeb/webTech',\n                query:{\n                name:n.name,\n                lang:n.language\n            }\n            })\n        }\n    }\n }\n&lt;/script></code></pre>\n\n### 路由组件的缓存\n当组件进行切换时，原组件会被销毁，原组件中未保存的表单内容等数据同时也会被删除，此时，可以使用<span class=\"tips\">&lt;keep-alive></span>标签阻止组件被销毁，保留数据。\n\n<pre><code> //缓存多组件使用 :include=\"['组件1','组件2',...]\"\n&lt;keep-alive include=\"aboutMe\"> \n  &lt;router-view>&lt;/router-view>\n&lt;/keep-alive></code></pre>\n\n### 路由独有生命周期\n+ <span class=\"strong\">activated：</span>当组件被激活时(显示到页面)\n+ <span class=\"strong\">deactivated：</span>当组件失活时\n当组件被&lt;keep-alive>时，组件不会被销毁，在切换组件时created、destory等钩子函数不会执行，此时可以使用activated、deactivated替代。\n\neg：使某组件在激活时启用定时器，失活时关闭\n<pre><code> export default {\n  name:'webTech',\n  data(){.....},\n  activated(){\n            let timer=setInterval(....);\n            },\n  deactivated(){\n            clearInterval(this.timer)\n            }\n }</code></pre>\n\n ### 路由守卫\n 在切换组件时，可借助路由守卫来阻止/放行组件的跳转，常用于判断用户是否有权限访问，无权限时阻止访问,也可用于在组件跳转前后执行某些功能。\n\n #### 前置、后置路由守卫(全局)\n 该路由守卫写于路由器配置文件中\n+ <span class=\"strong\">beforeEach((to,from,next)=>{ })：</span>前置路由守卫，在<span class=\"tips\">初始化、路由跳转前</span>执行，接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行\n+ <span class=\"strong\">beforeEach((to,from)=>{ })：</span>后置路由守卫，在<span class=\"tips\">路由跳转后</span>执行，接收to,from两个参数\n\n\neg: 检查用户是否为指定用户，不是则禁止访问aboutWeb和aboutMe组件\n<pre><code> import VueRouter from \"vue-router\";\n import Home from '../pages/pageHome'\n import About from '../pages/pageAbout'\n import aboutMe from '../pages/aboutMe'\n import aboutWeb from '../pages/aboutWeb'\n import webTech from '../pages/webTech'\n const router= new VueRouter({\n    routes:[\n        {\n            name:'home',\n            path:'/home',   \n            component:Home, \n            meta:{title:'首页'}//meta为自定义属性，程序员可自定义添加任何参数\n        },\n        {\n            name:'about',\n            path:'/about',\n            component:About,\n            meta:{title:'关于'},\n            children:[\n                {\n                    name:'aboutme',\n                    path:'aboutMe',\n                    component:aboutMe,\n                    meta:{isAuth:true,//标识该组件是否需要鉴别权限\n                          title:'关于我'}//用于组件跳转后修改地址栏标题\n                },\n                {\n                    name:'aboutweb',\n                    path:'aboutWeb',\n                    component:aboutWeb,\n                    meta:{isAuth:true,\n                        title:'关于网站'},\n                    children:[\n                        {\n                            name:'webTech',\n                            path:'webTech',\n                            component:webTech,\n                            meta:{title:'关于本站采用的技术'}\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n })\n// 全局前置路由守卫\n router.beforeEach((to,from,next)=>{\n        if(to.meta.isAuth){//确认是否鉴权，避免对所有组件都进行鉴权消耗性能\n // 当组件不多时，可以使用下面的代码通过判断路径来识别哪些组件需要权限认证\n        // if(to.name==='aboutme'||to.path==='/about/aboutWeb')\n        //只有localStorage中的user为zhoujielun才能访问\n            if(localStorage.getItem('user')==='zhoujielun'){\n                next() //放行访问\n            }\n            else{\n                alert('无权限访问')\n            }\n        }\n        else{\n            next()  //对不需要权限认证的页面直接放行\n        } \n })\n// 全局后置路由守卫\n//用于切换完毕后，修改网页地址栏的标题\n router.afterEach((to)=>{\n    document.title=to.meta.title  \n })\n export default router</code></pre>\n\n#### 独享路由守卫\n只为某个路由组件配置的路由守卫， 同样写于路由器配置文件中\n<span class=\"strong\">beforeEnter:(to,from,next)=>{ }</span>只对针对某个组件配置守卫，同样接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行\n \neg: 判断用户是否为指定用户，不是则禁止访问aboutMe组件\n<pre><code>{\n            name:'about',\n            path:'/about',\n            component:About,\n            meta:{title:'关于'},\n            children:[\n                {\n                    name:'aboutme',\n                    path:'aboutMe',\n                    component:aboutMe,\n                    meta:{isAuth:true,//鉴别权限\n                          title:'关于我'},\n                          //独享路由守卫\n                          beforeEnter:(to,from,next)=>{\n                                if(to.meta.isAuth){\n                                  //只有localStorage中的user为zhoujielun才能访问\n                                    if(localStorage.getItem('user')==='zhoujielun'){\n                                        next()\n                                    }\n                                    else{\n                                        alert('无权限访问')\n                                    }\n                                }\n                                else{\n                                    next()\n                                } \n                          }\n                },</code></pre>\n\n#### 组件内路由守卫\n无法修改路由器配置文件时，可以将路由守卫设于组件.vue的文件中。<span class=\"tips\">组件内的路由守卫只会在通过路由规则进入组件时才会执行</span>，如果将组件标签直接添加到页面中，该组件会被调用，但此时不属于通过路由规则进入组件，不会执行下述路由守卫函数。\n\n+ <span class=\"strong\">beforeRouteEnter(to,from,next){ }</span>：进入组件前执行\n+ <span class=\"strong\">beforeRouteLeave(to,from,next){ }</span>：离开组件前执行\n+ <span class=\"strong\">beforeRouteUpdate(to,from,next){ }</span>：组件更新时执行\n\n<pre><code>&lt;template>\n  &lt;div class=\"about\">\n    &lt;h2>About页面&lt;/h2>\n    &lt;div class=\"about-btn\">\n    &lt;router-link  to=\"/about/aboutWeb\">关于网页&lt;/router-link>\n    &lt;router-link  to=\"/about/aboutMe\">关于我&lt;/router-link>\n    &lt;/div>\n    &lt;div class=\"about-content\">\n      &lt;keep-alive include=\"aboutMe\">\n      &lt;router-view>&lt;/router-view>\n      &lt;/keep-alive>\n    &lt;/div>\n  &lt;/div>\n &lt;/template>\n &lt;script>\n export default {\n    name:'pageAbout',\n    // 通过路由规则进入组件时调用\n    beforeRouteEnter(to,from,next){\n      //只有localStorage中的user为zhoujielun才能访问\n            if(localStorage.getItem('user')==='zhoujielun'){\n                    next()\n                    }\n            else{\n                 alert('无权限访问')\n             }\n    },\n     // 通过路由规则离开组件时调用\n    beforeRouteLeave(to,from,next){\n      console.log('即将离开组件')\n        next();//放行\n    }\n}\n &lt;/script></code></pre>","tags":["web","vue"]},{"title":"yaml语法","url":"/blog/2022/07/14/yaml语法/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nYAML官方文档：<a href=\"https://yaml.org/spec/1.2.2/\">YAML 1.2.2</a></div>\n\n### 简介\n#### 关于\nYAML是一种数据序列化语言，可用于存储和传输数据，常用于编写配置文件、数据文件、日志文件，以及跨语言进行数据共享等环境，大多数编程语言都可以使用 YAML 进行数据序列化。\n\nYAML文件后缀为<span class=\"tips\">.yml</span>或<span class=\"tips\">.yaml</span>\n\n#### 基本语法\n<span class=\"strong\">1. 通常使用键值对形式</span>\n\n+ 键与值通常不需要引号包裹 (这点与json不同)\n+ 值可以为：数组、对象、标量值\n+ 标量值是指：整数、浮点数、字符串、布尔值、Null、时间、日期\n\n<span class=\"strong\">2. 通过缩进或者样式流表示数据结构</span>\n\n+ 数据可以通过空格缩进来表示层级关系，但不能用制表符(Tab)\n+ 子结构相较父结构必须缩进至少一个空格，同一级数据须缩进相同空格数，即左端对齐\n+ 也可以使用花括号{&nbsp;}，中括号[&nbsp;]等样式流表示层级关系\n<span class=\"strong\">3. 大小写敏感</span>\n<span class=\"strong\">4. 使用#号注释</span>\n\n\n### 对象\n最为常用的数据类型，又称为字典、哈希、映射，以<span class=\"tips\"> key: &nbsp;value </span>键值对的形式存储数据，<span class=\"tips\">key: 后需要有空格!</span>\n#### 对象写法\n<div class=\"show\">name: JayChou\nalbum: 十一月的萧邦\n</div>\n\n或者使用样式流：\n<div class=\"show\">{\n    name: JayChou,\n    album: 十一月的萧邦\n}\n</div>\n等同于json格式下的\n<div class=\"show\">{\n  \"name\": \"JayChou\",\n  \"album\": \"十一月的萧邦\"\n}\n</div>\n\n#### 缩进与嵌套\n可以通过缩进至少一个空格表示层级关系，从而嵌套其他对象、数组等\n<div class=\"show\">student:\n   name: aaa\n   age: 16\n   hobby:\n    - basketball\n    - swimming</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n多级嵌套时，每层嵌套都应当缩进，<span class=\"tips\">且每个子元素左边应该缩进相等的空格数，即左端对齐</span></div>\n   使用样式流：\n   <div class=\"show\">student: {\n        name: aaa,\n        age: 16,\n        hobby: [ basketball , swimming ]\n   }</div>\n\n#### 复杂对象格式\n使用<span class=\"tips\">?加空格</span>可以指定多个key值，使用<span class=\"tips\">:加空格</span>指定多个value\n<div class=\"show\">? \n      - key1\n      - key2\n: \n      - value1\n      - value2</div>\n    表示key是一个数组，值也是一个数组，样式流：\n    <div class=\"show\">key1,key2: [\"value1\",\"value2\"]</div>\n\n### 数组\n使用<span class=\"tips strong\">-</span>开头表示数组元素\n#### 数组写法\n<div class=\"show\">- value1\n- value2\n- value3</div>\n样式流：\n<div class=\"show\">[value1,value2,value3]</div>\n\n#### 缩进与嵌套\n可以通过缩进表示层级关系，来嵌套数组、对象等\n<div class=\"show\">- name: 周杰伦,\n  age: 42,\n  songs: \n   - 夜曲\n   - 米兰的小铁匠\n- name: 林肯公园,\n  age: 41,\n  songs:\n   - In the End\n   - Numb\n</div>\n样式流\n<div class=\"show\">[\n  {\n    name: 周杰伦,\n    age: 42,\n    songs: [ 夜曲 , 米兰的小铁匠 ]\n  },\n  {\n    name: 林肯公园,\n    age: 41,\n    songs: [ In the End , Numb ]\n  }\n]</div>\n\n### 标量\n标量指最基本的，不可再分的值，这里指：整数、浮点数、字符串、布尔值、Null、时间、日期\n\n基本使用方法：\n<div class=\"show\">1. 整数可以为非十进制数\nnum1: 120           #普通十进制数\nnum2: 0b10_1011     #二进制以0b开头\nnum3: 07100         #八进制以0开头\nnum4: 0xf1ab        #十六进制以0x开头\n2. 浮点数可以使用科学计数法\nfloat1: 3.14\nfloat2: 3.1415926e+5 #科学计数法314159.26\nfloat3: -.inf        #负无穷大\nflota4: .nan         #不是数字\n3. 布尔值大小写均可\nbool: true\n值为：true、True、TRUE均可，但TRUe将被解析为字符串\n4. Null可用<span class=\"tips\">~</span>表示\ndata: ~\n5. 日期必须使用ISO 8601格式，即yyyy-MM-dd\ndate: 2021-07-15\n6. 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\ntime: 2021-07-15T00:42:31+08:00\n在JavaScript中解析为Thu Jul 15 2021 00:42:31 GMT+0800 (中国标准时间)\n7. 使用<span class=\"tips\">!!数据类型 值</span>进行类型转换\ndate: !!str 2021-01-15\n</div>\n\n### 字符串处理\n一般情况下，字符串不需要添加引号，但如果字符串中间包含特殊字符，尤其是<span class=\"tips\">冒号加空格</span>组合时，为了避免被yaml解析为键值对，需要添加引号\n<div class=\"show\">str: 'said: meet you like wind'</div>\n\n给数值等标量添加引号将解析为字符串\n<div class=\"show\">str: '99.99'</div>\n\n多行字符串，<span class=\"tips\">第二行开始所有行需要缩进至少一个空格</span>，但解析时将被解析为一行字符串，且换行符会被替换为空格\n<div class=\"show\">str: aaaa\n bbbb\n cccc\n 将被解析为\n str: \"aaaa bbbb cccc\"</div>\n\n #### 单引号与双引号\n 单引号和双引号均可以用于包裹字符串\n + <span class=\"strong\">单引号会原样输出，将转义字符作为普通字符串输出</span>\n + <span class=\"strong\">双引号会转义字符串，如将 \\n 转义为换行</span>\n\n<div class=\"show\">如：\ncontent: '不会\\n换行'\n内容输出为：\n<span class=\"tips\">不会\\n换行</span>\ncontent: \"进行\\n换行\"\n内容输出为：\n <span class=\"tips\">进行\n  换行</span>\n</div>\n\n#### 区块字符串处理\n1. 多行字符串可以使用<span class=\"tips strong\">|</span>保留所有换行符，内容从第二行开始需要缩进至少一个空格，且最后一行的换行符也会保留。\n<div class=\"show\">lyrics: |\n aaaa \n bbbb\n cccc \n dddd\n</div>\n输出为：\n<div class=\"show\">aaaa \n bbbb\n cccc \n dddd\n <br/></div>\n\n2. 可以使用<span class=\"tips strong\">></span>去除换行，换行符将被空格代替 (如果某一行是空行，该空行会被额外保留)\n<div class=\"show\">lyrics: >\n aaaa \n bbbb\n cccc \n dddd</div>\n 输出为：\n<div class=\"show\">aaaa bbbb cccc dddd</div>\n\n3. 可以使用<span class=\"tips strong\">+</span>保留文字块末尾的换行\n<div class=\"show\">lyrics: |+\n aaaa \n bbbb\n cccc \n dddd</div>\n 输出为：\n<div class=\"show\">aaaa \n bbbb\n cccc \n dddd\n <br/></div>\n\n4. 可以使用<span class=\"tips strong\">-</span>去除文字块末尾的换行\n<div class=\"show\">lyrics: |-\n aaaa \n bbbb\n cccc \n dddd</div>\n 输出为：\n<div class=\"show\">aaaa \n bbbb\n cccc \n dddd\n</div>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n在yml文件中配置好字符串格式后，读取到html中时往往需要添加如<span class=\"tips\">white-space: pre-line;</span>等css属性来保留换行符和空格，否则读入的数据可能会被css默认样式去除换行符，从而无法展示原生yml指定的数据格式</div>\n\n5. <div class=\"tips strong\">在样式流中，无法使用 | > + -</div>\n<div class=\"show\">如：以上数据写为样式流\n             { \n               lyrics: |-\n                aaaa \n                bbbb\n                cccc \n                dddd\n               }\n  |- 将无法解析，抛出错误</div>\n\n\n### 添加HTML标签\nyaml允许在值中添加HTML标签，并且标签会被正确地解析为DOM\n<div class=\"show\">- tag: web\n  content: 推荐网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>\n  或\n  <div class=\"show\">- tag: web\n  content: |-\n   推荐\n   网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>\n解析为：\n<div class=\"show\">推荐网站 <a href=\"#\">SHIWIVI</a></div>\n   <div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n使用时需要注意，插入的HTML标签是否会被其他语言解析为字符串，但yaml本身是可以输出为DOM元素的</div>\n\n### 锚点与引用\n可以使用<span class=\"tips\">&</span>定义一个锚点，然后使用<span class=\"tips\">*</span>引用锚点\n<div class=\"show\">first: &anchor  #定义锚点\n - aaa\n - bbb\nsecond:  *anchor #调用锚点</div>\n解析为\n<div class=\"show\">first: [aaaaa,bbb]\nsecond: [aaaaa,bbb] </div>\n\n如果将多个键值对引用到其他地方，可以使用<span class=\"tips\"><<</span>合并数据\n<div class=\"show\">first: &data  #定义锚点\n   name: lol\n   age: 18\n   hobby:\n    - sing\n    - swing\nsecond: \n   <<: *data    #将数据插入此处\n   address: zzz</div>\n 解析为：\n <div class=\"show\">{\n  \"first\": {\n      \"name\": \"lol\",\n      \"age\": 18,\n      \"hobby\": \"sing  swimming\"\n  },\n  \"second\": {\n      \"name\": \"lol\",\n      \"age\": 18,\n      \"hobby\": \"sing  swimming\",\n      \"address\": \"zzz\"\n  }\n}</div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n如果多次定义了同名的锚点(重定义)，则先定义的锚点会被覆盖</div>\n\n### 文件格式\n一个完整的yml文档以<span class=\"tips\">-&zwnj;-&zwnj;-</span>标识文档开始，以<span class=\"tips\">...</span>标识文档结束，该标识非必须，无标识的称为<span class=\"tips\">裸文档</span>，文件开头可以添加<span class=\"tips\">%YAML</span>来识别文件的YAML版本\n<div class=\"show\">%YAML 1.2\n# 开头注释，注明文档作者等信息\n---\nip: 45.77.77.49\nport: 443\n...</div>\n\n一个yml文件中可能有多个文档\n<div class=\"show\">---\nip: 45.77.77.10\nport: 80\n...\n---\nip: 45.77.77.11\nport: 443\n...</div>\n但如果在一个yml文件中写入多个文档，在某些环境下读入可能报错，需要分割为多个文件\n<div class=\"shell\">err: YAMLException: expected a single document in the stream, but found more</div>\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n更多语法和拓展详见官方文档</div>","tags":["File","CS"]},{"title":"Grid栅格布局","url":"/blog/2022/06/14/Grid布局/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nGrid在MDN上翻译为网格布局，在《CSS权威指南》中翻译为栅格布局，其实是同一种布局方案，本文语句主要整理自《CSS权威指南》一书</div>\n\n### 1. 栅格布局\nGrid 是一种强大的布局方案，也是最为普适的布局方案，允许在Web上创建二维布局，通过对父元素定义不同参数的行与列垂直线，再将子元素部署于行列网格上，由此实现各类灵活的布局，如：\n<br/>\n<div style=\"display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;grid-area:a;\">box1</div>\n<div style=\"background-color:#fff200;grid-area:b;\">box2</div>\n<div style=\"background-color:#7d5fff;grid-area:c;\">box3</div>\n<div style=\"background-color:#32ff7e;grid-area:d;\">box4</div>\n<div style=\"background-color:#4b4b4b;grid-area:e;\">box5</div>\n</div>\n<br/>\n\n通过标准流、float、flex也可以实现类似的布局，但这些方案往往需要更多的DOM元素，或者需要指定更多的参数，并且很多情况下无法做到自适应，此时，grid布局方案的优势就体现出来了。并且语法兼容性也很好，除了那位大爷.....\n\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>Chrome</th><th>Edeg</th><th>Firefox</th><th>IE</th><th>Opera</th><th>Safari</th>\n</tr>\n</thead>\n<tr><td>57</td><td>16</td><td>52</td><td style=\"color:red;\">不支持</td><td>44</td><td>10.1</td></tr>\n</table>\n</div>\n\n### 2. 栅格容器\n创建栅格的第一步就是创建一个栅格容器，并将其中的内容定义为栅格布局\n#### 2.1 栅格属性\n<span class=\"strong\">display: grid/inline-grid;</span>\n\n指定容器布局方式为栅格布局，该属性和 block 与 inline-block 值相似\n\n#### 2.2 定义栅格模板\n<span class=\"strong\">grid-template-columns: 值;</span>\n\n<span class=\"strong\">grid-template-rows: 值;</span>\n\n将容器划分为行列栅格,栅格线的值可以为<span class=\"tips\">固定值</span>、<span class=\"tips\">百分比</span>、<span class=\"tips\">fr关键字</span>、<span class=\"tips\">repeat()语句</span>、<span class=\"tips\">minmax()语句</span>、<span class=\"tips\">calc()函数</span>等，并且参数可以混用\n\n##### 2.2.1 固定值行列轨道宽度\n将子元素宽高设为固定值，单位可以为px，也可以为em、rem等相对单位\n\n<div class=\"show\">如：给父元素指定行列轨道宽度，子元素可以不设置任何参数\ndiv{\n    display:grid;\n    grid-template-columns:50px 60px 100px;\n    grid-template-rows:50px 60px 100px;\n}\n</div>\n<div style=\"display:grid;grid-template-columns:50px 60px 100px;grid-template-rows:50px 60px 100px;text-align:center;color:#fff;width:210px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">类似的取值可以为\n    grid-template-columns:5em 5em 5em;\n</div>\n\n##### 2.2.2 百分比配置宽高\n将元素的宽高按百分比配置，可以让网页元素自适应不同屏幕大小\n\n<div class=\"show\">如：元素宽高分别为20% 20% 50% \ndiv{\n    display:grid;\n    grid-template-columns:20% 20% 50%;\n    grid-template-rows:20% 20% 50%;\n    border:1px solid black;\n    box-sizing: border-box;\n}\n</div>\n<div style=\"display:grid;grid-template-columns:20% 20% 50%;grid-template-rows:20% 20% 50%;text-align:center;color:#fff;width:280px;height:300px;margin:0 auto;border:1px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n百分比是基于父容器的宽度和高度计算，不管子元素内容大小如何变化也不会变，因此要给与父元素宽高参数，即不能再使用子元素撑开父元素了。若子元素宽高相加不到100%，则剩余部分空置</div>\n\n##### 2.2.3 fr按比例配置宽高\ngrid布局提供了 <span class=\"tips\">fr</span> 关键字(fraction)用于表示比例关系\n\n<div class=\"show\">如：元素宽高比为1:2:2 \ndiv{\n    display:grid;\n    grid-template-columns:1fr 2fr 2fr;\n    grid-template-rows:1fr 2fr 2fr;\n    border:1px solid black;\n    box-sizing: border-box;\n}\n</div>\n<div style=\"display:grid;grid-template-columns:1fr 2fr 2fr;grid-template-rows:1fr 2fr 2fr;text-align:center;color:#fff;width:210px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">配合其他值来实现弹性布局\n     grid-template-columns:150px 1fr 10%;\n     <span class=\"tips\">第一列宽为150px，最后一列宽为10%,剩下宽度给中间一列</span>\n</div>\n\n##### 2.2.4 定义栅格线名称\n可以使用<span class=\"tips\">[ ]</span>为边框线起名字，并且同一条线的名称可以有无数多个，如：<span class=\"tips\">[a1 b1]</span>为同一条线取名a1和b1\n<div class=\"show\">如：元素宽高比为1:2:2 \ndiv{\n    display:grid;\n    grid-template-columns: [c1] 80px [c2] 80px [c3] 80px [c4];\n    grid-template-rows: [r1] 60px [r2] 60px [r3] 60px [r4];\n    border:1px solid black;\n    box-sizing: border-box;\n}\nbox1、box4、box7左边框线相连为c1，右边框线相连为c2；\nbox1、box2、box3上边框线相连为r1，下边框线相连为r2\n其他以此类推\n</div>\n<div style=\"display:grid;grid-template-columns:[c1] 80px [c2] 80px [c3] 80px [c4];\n    grid-template-rows:[r1] 60px [r2] 60px [r3] 60px [r4];text-align:center;color:#fff;margin:0 auto;width:240px;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n##### 2.2.5 repeat()重复填充\n对于多个宽高值相同的元素，可以使用<span class=\"tips\">repeat()</span>语句简写\n\n<div class=\"show\">如：\n1. 对于grid-template-columns: 5em 5em 5em;\n该语句可以简写为\n    grid-template-columns: repeat(3,5em);\n2. 类似地可以创建宽度有一定规律的子元素\n    如：创建宽度依次为20px,40px,60px,20px,40px,60px的6列元素\n    grid-template-columns: repeat(2, 20px 40px 60px);\n3. 还可以repeat()前后添加不想重复的宽高值\n    grid-template-columns: repeat(2,1em 5em) 2em;\n    这就生成了1em 5em 1em 5em 2em的网格\n4. 百分号和比例依旧适用\n    grid-template-columns: repeat(3,33.3%);\n5. 如果包含了栅格线名，名称也会被复制\n    grid-template-columns: repeat(3,[top] 5em [bottom]);\n    则会生成\n    [top] 5em [bottom top] 5em [bottom top] 5em [bottom]\n    即：中间的栅格线将会有两个名称，该语句等同于：\n    grid-template-columns: [top] 5em [bottom top] 5em [bottom top] 5em [bottom];\n</div>\n\n\n\n\n##### 2.2.6 minmax()限制尺寸\n当子元素溢出父容器之外时，除了使用<span class=\"tips\">overflow: hidden;</span>外，还可以使用<span class=\"tips\">minmax(最小值，最大值)</span>来限制宽高尺寸\n<div class=\"show\">如：将剩余空间分配给第二列，但又要避免他被挤占得太小\n     grid-template-columns:5em minmax(10%,1fr) 2em;\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n注意！当minmax()中最大值小于最小值时，最大值将失效。如minmax(100px,2em)中，当2em计算值小于100px时，元素宽高将被解析为100px</div>\n\n##### 2.2.7 calc()计算尺寸\ngrid是支持<span class=\"tips\">calc()</span>语句的，只是有时候不太适用\n<div class=\"show\">如：第二列宽度通过计算得出\n     grid-template-columns:2em calc(100%-1.5em) 10%;\n</div>\n\n##### 2.2.8 根据内容自适应\n子元素宽高还可以根据子元素内容，通过<span class=\"tips\">max-content</span>、<span class=\"tips\">min-content</span>、<span class=\"tips\">fit-content</span>来实现栅格自适应\n\n+ <span class=\"strong\">max-content:</span>解析为尽可能大的空间，以防换行\n+ <span class=\"strong\">min-content:</span>解析为尽可能小的空间，能够显示内容即可\n+ <span class=\"strong\">fit-content:</span>解析为空间尽可能小，但如果超过指定空间大小就换行\n\n<div class=\"show\">如：尽可能容纳内容\ndiv{\n    display:grid;\n    grid-template-columns:max-content max-content max-content;\n    grid-template-rows:max-content max-content max-content;\n}\n可以看到，每一列的宽度由该列有最长内容的列宽决定，行类似。当父元素指定宽度时，这可能会溢出到父容器之外\n</div>\n\n<div style=\"display:grid;grid-template-columns:max-content max-content max-content;grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">1</div>\n<div style=\"background-color:#fff200;\">22</div>\n<div style=\"background-color:#7d5fff;\">33333333</div>\n<div style=\"background-color:#32ff7e;\">44444444444</div>\n<div style=\"background-color:#4b4b4b;\">5</div>\n<div style=\"background-color:#67e6dc;\">6</div>\n<div style=\"background-color:#ff9f1a;\">77</div>\n<div style=\"background-color:#ffb8b8;\">8888</div>\n<div style=\"background-color:#c56cf0;\">9</div>\n</div>\n\n<div class=\"show\">配合minmax()使用可以不破坏外部布局，但会挤压内部空间\ndiv{\n    display:grid;\n    grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);\n    grid-template-rows:max-content max-content max-content;\n}\n</div>\n\n<div style=\"display:grid;grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">1</div>\n<div style=\"background-color:#fff200;\">22</div>\n<div style=\"background-color:#7d5fff;\">33333333</div>\n<div style=\"background-color:#32ff7e;\">44444444444</div>\n<div style=\"background-color:#4b4b4b;\">5</div>\n<div style=\"background-color:#67e6dc;\">6</div>\n<div style=\"background-color:#ff9f1a;\">77</div>\n<div style=\"background-color:#ffb8b8;\">8888</div>\n<div style=\"background-color:#c56cf0;\">9</div>\n</div>\n\n<div class=\"show\"><span class=\"tips\">fit-content</span>用于限制最大长度，类似于max-width\n指定三列宽均为50等宽字符，当未满50ch时按实际字符长度算，超过该值则进行换行，即最大值只能为50ch\ndiv{\n    display:grid;\n    grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(5.0ch);\n}\n只指定宽度，高度自适应，第一第二列未满50ch时，以各自长度为列宽，第三列超过50ch，则进行换行，以50ch为列宽\n</div>\n<div style=\"display:grid;grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(50ch);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#18dcff;\">the night</div>\n<div style=\"background-color:#4b4b4b;\">Avicii</div>\n<div style=\"background-color:#7d5fff;\">He said one day you will leave this world behind So live a life you will remember</div>\n</div>\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n当父容器较小时，第一、第二列即便未满50ch也可能会进行换行，以保证不会溢出父亲容器</div>\n\n##### 2.2.9 auto-fill自动填充\n当父容器宽度固定，可以使用<span class=\"tips\">auto-fill</span>让子元素根据大小自动填充\n<div class=\"show\">如：\ndiv{\n    display:grid;\n    width:50vh;\n    grid-template-columns:repeat(auto-fill,5em);\n    grid-template-rows:max-content max-content max-content;\n    }\n在父容器中尽量排列宽3em的元素，排列到第一行排完，如果剩下空间不足3em，则剩余子元素将进行换行\n</div>\n<div style=\"display:grid;grid-template-columns:repeat(auto-fill,3em);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">1. 一个父容器的宽/高只能有一次自动排列，因此下述语句是不允许的\ngrid-template-columns: repeat(auto-fill,5em) repeat(auto-fill,2em);\n2. 但可以固定尺寸的repeat与自动填充的repear共存，如：\ngrid-template-columns: repeat(2,5em) repeat(auto-fill,2em);\n或者\ngrid-template-columns: repeat(auto-fill,5em) repeat(3,2em);\n但无论语序如何，grid总会为固定尺寸的元素分配空间，因此auto-fill会被最后才被分配空间\n</div>\n\n#### 2.3栅格间距\n通过<span class=\"tips\">row-gap</span>、<span class=\"tips\">column-gap</span>来设置栅格见的行、列间隔。或者将两个属性合并为一个 <span class=\"tips\">grid-gap：行间隔 列间隔;</span>\n<div class=\"show\">给父容器添加该属性\ndiv{\n    display:grid;\n    width:50vh;\n    height:50vh;\n    grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);\n    row-gap:10px;\n    column-gap:10px;\n    }\n如图所见，添加间隔可能导致栅格溢出，这两个属性可合并为 grid-gap ，如果该语句之后的值只有一个，则解析为行列间隔都为该值。\n    grid-gap:10px 10px;\n等价于\n    grid-gap:10px;\n</div>\n\n<div style=\"display:grid;grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);row-gap:10px;\n    column-gap:10px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n### 3. 栅格区域\n此前都是给父容器添加属性，但如果同时给子元素添加相应属性可以做出更好的布局\n\n\n#### 3.1 调用栅格线名\n通过<span class=\"tips\">grid-template-columns</span>、<span class=\"tips\">grid-template-rows</span>定义栅格宽高和栅格线名后，可以通过下列语句调用栅格线名\n\n+ <span class=\"strong\">grid-column-start：</span>列开始的栅格线名\n+ <span class=\"strong\">grid-column-end：</span>列结束的栅格线名\n+ <span class=\"strong\">grid-row-start：</span>行开始的栅格线名\n+ <span class=\"strong\">grid-row-end：</span>行结束的栅格线名\n\n<div class=\"show\">通过四条边来定义子元素的具体位置，当未定义栅格线名时，可以使用1，2，3...作为栅格线名\n.box1 {\n    grid-column-start:1;\n    grid-column-end:2;\n    grid-row-start:2;\n    grid-row-end:4;\n    background-color: #ff3426;//红色\n}\n.box2 {\n    grid-column-start:3;\n    grid-column-end:5;\n    grid-row-start:1;\n    grid-row-end:3;\n    background-color: #39f64f;//绿色\n}\n\n.parbox {\n    display:grid;\n    grid-template-columns: repeat(4,50px);\n    grid-template-rows: repeat(4,50px);\n}\n栅格线名可以为负数，表示从该栅格线往其反方向数\n</div>\n\n\n<div style=\"display:grid;display:grid;grid-template-columns: repeat(4,50px);grid-template-rows: repeat(4,50px);text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;box-sizing: border-box;\">\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #ff3426;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #ff3426;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n</div>\n\n<div class=\"show\">1. 栅格线的编号可以为<span class=\"tips\">负值</span>，表示从倒数第n条线开始从后往前数\n如：不知道栅格有几列，但想从最右边的栅格线开始部署，可以使用\n        grid-column-start:-1;\n        grid-row-start:-1;(行同理)\n2. 如果为栅格线定义过名称，则可以使用该名称作为上述语句的值，如果变量对应的栅格线有多条，则使用<span class=\"strong\">变量名 序号</span>来确定具体的栅格线，序号从1开始排列。如：有多条名为col-A的线，表示列从第4条col-A开始：\n            grid-column-start:col-A 4;\n3. 此外可以使用<span class=\"tips\">span</span>语句指定子元素跨越的行列数，如：\n.box1 {\n    grid-column-start:1;\n    grid-column-end: span 1;\n    grid-row-start:2;\n    grid-row-end: span 2;\n}\n上述代码等同于：\n.box1 {\n    grid-column-start:1;\n    grid-column-end: 2;\n    grid-row-start:2;\n    grid-row-end: 4;\n}\n表示该子元素从左边框号1开始，跨越1列，从上边框号2开始，跨越2行，其中<span class=\"strong\">span 1</span>可以直接简写为<span class=\"strong\">span</span>(默认为1)，且span后的值不能为<span class=\"tips\">0</span>或<span class=\"tips\">负值</span>\n4. 当使用 <span class=\"strong\">span 栅格线名 n</span> 时，表示该元素跨越了n条该名称的栅格线\n如：栅格部署为A、B栅格线交替命名时\nA 格子 B 格子 A 格子 B 格子 A 格子 B 格子\n此时\n    grid-column-start: A 1;\n    grid-column-end: span 2 A;\n表示栅格从第1条A线开始，跨越1条名为A的栅格线，在下一个A线处结束\n\n</div>\n\n#### 3.2 调用栅格线名的简写\n上一节中 grid-column-start，grid-column-end和grid-row-start，grid-row-end用于指定栅格起始和结束的位置，该属性可以简写为\n\n+ <span class=\"strong\">grid-column: 起始栅格线/结束栅格线</span>\n+ <span class=\"strong\">grid-row: 起始栅格线/结束栅格线</span>\n\n<div class=\"show\">1. 元素开始和结束的栅格线名用 / 隔开 \n.box1 {\n    grid-column-start:1;\n    grid-column-end: 2;\n    grid-row-start:2;\n    grid-row-end: 4;\n}\n等价于\n.box1 {\n    grid-column: 1 / 2;\n    grid-row: 2 / 4;\n}\n也可以用跨越了多少栅格表示\n.box1 {\n    grid-column: 1 / span 1;\n    grid-row: 2 / span 2;\n}\n2. 如果 / 和第二个值省略，则默认起始结束的栅格线名都一致\n如：列栅格线中有两条名为header的线，则\n        grid-column: header;\n等价于\n        grid-column: header / header;\n即以第一条header开始，第二条header结束，无论中间跨越多少栅格\n</div>\n\n\n#### 3.3 grid-area\ngrid-area可用于调用网格线，也可用于为子元素命名\n##### 3.3.1 grid-area调用网格线\n grid-column-start，grid-column-end和grid-row-start，grid-row-end可以直接用一个语句代替：\n <span class=\"strong\">grid-area：行开始/列开始/行结束/列结束</span>\n<div class=\"show\">如：\n.box1 {\n    grid-row-start:2;\n    grid-row-end: 4;\n    grid-column-start:1;\n    grid-column-end: 2;  \n}\n等价于\n.box1 {\n    grid-area:2/1/4/2;\n}\n同样，值可以为跨越了多少个网格\n.box1 {\n  grid-area: 2 / 1 / span 2 / span 1;\n}\n</div>\n\n\n##### 3.3.2 grid-area为子元素命名\n可以通过<span class=\"tips\">grid-area</span>给每个栅格子元素定义名称，然后由父容器通过<span class=\"tips\">grid-template-areas</span>定义它们的排列方法\n\n<div class=\"show\">如：\n.box1 {\n    grid-area: a;\n}\n.box2 {\n    grid-area: b;\n}\n.box3 {\n    grid-area: c;\n}\n.box4 {\n    grid-area: d;\n}\n.box5 {\n    grid-area: e;\n}\n.parbox {\n    display:grid;\n    grid-template-areas: 'a a a'\n                        &emsp;&emsp;&emsp;&emsp;'b c d'\n                        &emsp;&emsp;&emsp;&emsp;'b e e';\n}\n排列方法可以写于同一行上，但需要注意'&nbsp;'号\ngrid-template-areas: 'a a a''b c d''b e e';\n</div>\n\n<div style=\"display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;grid-area:a;\">box1</div>\n<div style=\"background-color:#fff200;grid-area:b;\">box2</div>\n<div style=\"background-color:#7d5fff;grid-area:c;\">box3</div>\n<div style=\"background-color:#32ff7e;grid-area:d;\">box4</div>\n<div style=\"background-color:#4b4b4b;grid-area:e;\">box5</div>\n</div>\n\n<div class=\"show\">变量名应该尽量使用有含义的单词\n(子元素变量名应相应改变，这里只展示父容器属性)\n.parbox {\n    display:grid;\n    grid-template-areas: 'header header header''left content right''left footer footer';\n}\n也可以省略其中的部分变量，使用...代替\n.parbox {\n    display:grid;\n    grid-template-areas: 'header header header''left ... right''left footer footer';\n}\n</div>\n\n### 4. 栅格的对齐方式\n栅格对齐方式类似于flex弹性盒里的属性\n<div class=\"table\">\n\n属性   |  目标 | 适用于\n----------------|--------------|-------\njustify-self    |行(一个栅格元素)|子元素\njustify-items   |行(所有栅格元素)|父容器\njustify-content |行(整个栅格)   |父容器\nalign-self      |列(一个栅格元素)|子元素\nalign-items     |列(所有栅格元素)|父容器\nalign-content   |列(整个栅格)   |父容器\n</div>\n\n<div class=\"show\">以行为例\n.box1{\n    justify-self:start;\n}\n.box2{\n    justify-self:center;\n}\n.box3{\n    justify-self:end;\n}\njustify-self和justify-items用来调整单个或多个元素在它们自己栅格内的位置\n当justify-self赋值为start、center、end时，如果子元素没有指定宽度和高度，则会自动缩为仅合适内容的大小，对齐方式同单词含义。赋值为stretch时会被拉伸，完全填充box(同剩下的box)\n当需要所有元素都有该对齐方式，则可以给父容器添加justify-items和对应的值\n</div>\n\n<div style=\"display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;justify-self:start;\">box1</div>\n<div style=\"background-color:#fff200;justify-self:center;\">box2</div>\n<div style=\"background-color:#7d5fff;justify-self:end;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">同样以行为例\n.parbox{\n    width:260px;\n    height:260px;\n    display:grid;\n    grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);\n    justify-content:center;\n}\njustify-content则是用来调整整个grid网格在父容器中的位置\n</div>\n<div style=\"display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);justify-content:center;text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n\n\n\n### 5. 隐式栅格\n此前通过<span class=\"strong\">grid-template-rows</span>定义的栅格为<span class=\"tips\">显式栅格</span>，当一部分栅格超出了显式栅格，系统会将超出的那部分定义为<span class=\"tips\">隐式栅格</span>。可以使用<span class=\"tips strong\">grid-auto-rows</span>与<span class=\"tips strong\">grid-auto-columns</span>定义隐式栅格的大小\n<div class=\"show\">如：\n.grid{\n    display:grid;\n    width:200px;\n    height:200px;\n        //定义2*2的显式栅格\n    grid-template-columns:100px 100px;\n    grid-template-rows:100px 100px;\n        //定义隐式栅格尺寸(以行为例)\n    grid-auto-rows: 50px;\n}\nbox1、box2、box3、box4在显式栅格内，高为100px，box5，box6超出了显式栅格，高将变为隐式栅格的高50px\n</div>\n<div style=\"display:grid;width:200px;\n    height:200px;grid-template-columns:100px 100px;grid-template-rows:100px 100px;grid-auto-rows: 50px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:5px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n</div>\n<br/>\n<br/>\n<br/>\n\n### 6. 栅格流\n栅格流主要分为优先行、优先列、密集流三种模式，由<span class=\"tips\">grid-auto-flow</span>决定\n\n<div class=\"show\">grid-auto-flow的取值有row、column、dense(密集流)\n .box{\n    display: grid;\n    grid-template: repeat(3,80px) / repeat(3,80px);\n    width: 240px;\n    height: 240px; \n    grid-auto-flow: row;\n    }\n优先行与优先列的部署模型如下\n</div>\n<div style=\"display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: row;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n</div>\n<br/>\n<div style=\"display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: column;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n</div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n密集流的主要作用是让元素尽量靠紧，因此有时会破坏栅格元素的顺序进行密集分布，向任何可以插入的位置安插合适的子元素</div>\n\n### 7. 错误处理\n当输入错误的代码时，部分情况下grid会帮我们修正属性，但在有些情况下会抛弃部分无法解析的值，甚至不解析整个语句\n<div class=\"show\">1. 当栅格开始线放在结束线后\n    grid-row-start:5;\n    grid-row-end:2;\ngrid将修正为\n    grid-row-start:2;\n    grid-row-end:5;\n2. 当栅格开始线和结束线都被声明为了跨度\n    grid-row-start: span ;\n    grid-row-end: span 3;\n结束线的值将被修改为 auto\n    grid-row-start: span ;\n    grid-row-end: auto;\n3. 如果栅格开始线被声明为跨越已命名的线，则该语句将被认为非法\n    grid-row-start: span header;\n</div>\n\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n当栅格元素出现重叠时，可以使用 z-index 或 order 进行排序，并且栅格元素可以使用margin、position等标准流、定位等属性。并且还有其他一些更复杂的属性简写语法，本文不再展开说明，具体可以查阅MDN的文档</div>","tags":["css","web"]},{"title":"Vux状态管理","url":"/blog/2022/06/13/Vux状态管理/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nVux官网：<a href=\"https://vuex.vuejs.org/zh/\">https://vuex.vuejs.org/zh/</a></div>\n\n### 入门\n#### 简介\n<span class=\"tips\">Vuex</span>是专门为Vue应用程序开发的集中式状态(数据)管理插件，可以对Vue中的组件进行统一的数据管理。\n\n#### 搭建环境\nvue2的工程使用vux3，vue3的工程需要使用vux4，版本需要对应，这里以安装vux3为例\n\n在脚手架中执行：\n<pre><code>npm i vuex@3</code></pre>\n\n#### 工作流程\n<img data-src=\"/blog/images/vuex_art.jpg\" src=\"/blog/images/vuex_art.jpg\" alt=\"vuex工作流程\">\n\n\n+ <span class=\"strong\">Action</span>主要用于响应Vue Conponents的消息，或者从后端接收数据，并且可以将数据在Action中进行初步处理(主要为异步处理，如：添加定时器)\n+ <span class=\"strong\">Mutation</span>主要用于处理数据，在Mutation处理的数据才能被Devtools调试工具监测\n+ <span class=\"strong\">State</span>主要用于集中存储数据\n\n<span class=\"strong\">工作流程：</span>Vue Conponents发送消息<span class=\"tips\">(dispatch)</span>给Action，或者Action通过Ajax等技术从后端异步获取数据 ---> Actions提交<span class=\"tips\">(commit)</span>到Mutation ---> 数据在Mutation中进行处理后，修改<span class=\"tips\">(mutate)</span>State中存储的数据 ---> 监测到State数据发生变化，Vue重新渲染<span class=\"tips\">(render)</span>页面\n\nvue组件的中数据不要预处理时，也可以越过Action，直接commit到mutation中进行处理\n\n<span class=\"strong\">关于store：</span>store是Vuex的核心库，可以理解为一个容器，Action、Mutation、state由Store统一管理，在进行消息提交、数据操作时往往需要经过store，通过<span class=\"tips\">this.$store.dispatch</span>、<span class=\"tips\">this.$store.commit</span>等语句来调用api\n\n### 上手\n#### 开发步骤\n##### 1. 配置store\n在src目录下新建store目录，新建index.js文件\n<pre><code>import Vue from 'vue'\nimport Vue from 'vue'\n//引入并应用vux\nimport Vuex from 'vuex'\nVue.use(Vuex)\n//创建action、mutations、state\nconst actions={....}\nconst mutations={....}\nconst state={.....}\n//创建并暴露Store\nexport default new Vuex.Store({\n    actions,\n    mutations,\n    state,\n    getters\n})</code></pre>\n\n##### 2. 引入store配置项\n在main.js中引入store配置项\n<pre><code>// 全写为import store from './store/index.js'\nimport store from './store'\nnew Vue({\n  render: h => h(App),\n  store\n  }).$mount('#app')</code></pre>\n\n#### 案例\neg：简单求和差案例，4个按钮分别实现求和、求差、判断偶数后求和、定时器延时1s求和\n+ 直接求和、求差可以直接commit到Mutation中运算\n+ 判断当前值是否为偶数，延时求和需要dispatch到Action中预处理，再commit到Mutation中运算\n+ 需要多次处理的数据可以在Action中多次dispatch，处理完毕再commit\n\n##### 1. 创建组件\n在components中创建Count.vue\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>求和案例&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{$store.getters.addTen}}&lt;/h2>\n    &lt;h3>当前值为{{$store.state.sum}}&lt;/h3>\n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    &lt;button @click=\"incrace\">加&lt;/button>\n    &lt;button @click=\"decrace\">减&lt;/button>\n    &lt;button @click=\"addOpp\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate\">延迟3s加&lt;/button>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1, //加数\n        }\n    },\n    methods:{\n        // 求和、求差直接commit\n    incrace(){\n        this.$store.commit('JIA',this.num)\n    },\n    decrace(){\n        this.$store.commit('JIAN',this.num)\n    },\n    //延时、判断奇偶dispatch到actions经过处理后再提交\n    addOpp(){\n        this.$store.dispatch('addOpp',this.num)\n    },\n    addLate(){\n        this.$store.dispatch('addLate',this.num)\n    }\n    }\n }\n&lt;/script>\n</code></pre>\n\n##### 2. 配置store\n新建store目录并在该目录下新建index.js\n<pre><code>import Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\nconst actions={\n    // actions里的方法名一般小写\n    //接收参数 (context,实参)\n    // context是一个对象，拥有store的部分属性,变量名可以为其他\n    addOpp(context,value){          \n        if(!(value%2)){             //判断是否为偶数，为偶数则commit到mutations\n        context.commit('JIA',value)\n        }else{\n            console.log('非偶数，数未提交')\n        }\n    },\n    addLate(context,value){       //数据想要多道处理时，可以在actions内多次dispatch，无限套娃\n        setTimeout(()=>{\n            context.dispatch('addLate2',value);\n            console.log('第一次延迟处理')\n        },500)\n    },\n    addLate2(context,value){      //数据经过第二道处理后，再提交\n        setTimeout(()=>{\n            context.commit('JIA',value);\n            console.log('第二次延迟处理')\n        },500)\n    }\n}\n// mutations里的方法名一般大写，用于和actions里的区别\nconst mutations={\n    //接收参数(state,实参)\n    JIA(state,value){           //加\n        state.sum+=value\n    },\n    JIAN(state,value){          //减\n        state.sum-=value;\n    }\n}\nconst state={ //存储数据\n    sum:0\n }\nconst getters={                //读取数据前，想要预先进行处理使用getters\n    addTen(state){\n        return state.sum+10\n    }\n}\n// 创建并暴露store\nexport default new Vuex.Store({\n    actions,\n    mutations,\n    state,\n    getters\n })\n</code></pre>\n\n##### 3. 引入store配置项\n在main.js中引入store配置\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport store from './store'// 全写为import store from './store/index.js'\nVue.config.productionTip = false\n new Vue({\n  render: h => h(App),\n  store\n }).$mount('#app')\n</code></pre>\n\n##### 4. 引入Count组件\n在App中使用Count组件\n<pre><code>&lt;template>\n  &lt;div id=\"app\">\n    &lt;Count/>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nimport Count from'./components/Count.vue'\nexport default {\n  name:'App',\n  components:{\n    Count\n             }\n   }\n&lt;/script></code></pre>\n\n### getters\n组件从state读取数据前，如果需要对数据进行预处理，可以在getter中进行。如：读取state中的num前进行处理(完整代码位于上一个案例)\n\n#### 1. 在store中添加getter\n<pre><code>\nconst actions={.....}\nconst mutations={....}\nconst state={.....}\nconst getter={ \n    //读取state中的sum前，将值增大10\n     addTen(state){\n        return state.sum+10;\n     }\n}\n</code></pre>\n\n#### 2. 读取数据\n读取数据使用\n<pre><code>$store.getters.addTen</code></pre>\n\n### 辅助函数\n当一个组件需要获取多个数据(状态)时，调用数据和api需要大量使用this.$store.state.number等语句，为了减小代码书写量，可以在计算属性中借助<span class=\"tips\">mapState</span>、<span class=\"tips\">mapGetters</span>、<span class=\"tips\">mapMutations</span>、<span class=\"tips\">mapActions</span>辅助函数简化代码\n\n#### 通过对象\n当组件中的方法名、变量名与State、Mutations...中的变量名不同时，需要通过对象方式接收。并借助模板语法解析变量，以读取State中的数据为例：\n<div class=\"show\">...mapState({组件中的变量名:'state数据',.....})</div>\n\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>求和案例&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{addTen}}&lt;/h2>\n    &lt;h3>当前值为{{sum1}}&lt;/h3>\n    &lt;h2>从state获取name为{{name1}},从state获取song为{{song1}}&lt;/h2>\n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    //当使用mapState等语法时，需要在写函数时传参(num)\n    &lt;button @click=\"incrace(num)\">加&lt;/button>\n    &lt;button @click=\"decrace(num)\">减&lt;/button>\n    &lt;button @click=\"addOpp(num)\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate(num)\">延迟3s加&lt;/button>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n//引入mapState、mapGetters、mapMutations、mapActions\n import {mapState,mapGetters, mapMutations,mapActions} from 'vuex'\n export default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1,\n        }\n    },\n    computed:{\n        //模板语法\n        ...mapState({sum1:'sum',name1:'name',song1:'song'}),\n        ...mapGetters({addTen:'addTen'})\n        // 可以简写为数组形式...mapGetters(['addTen'])，在对象中不能简写，会解析为addTen:addTen，值也解析为变量\n    },\n    methods:{\n    //原语句\n    // incrace(){this.$store.commit('JIA',this.num)},\n    // decrace(){this.$store.commit('JIAN',this.num)},\n    // 借助mapMutations生成对应方法，该方法会自动调用commit，数组写法在另一组件中\n     ...mapMutations({incrace:'JIA',decrace:'JIAN'}),\n    //原语句\n    // addOpp(){this.$store.dispatch('addOpp',this.num)},\n    // addLate(){this.$store.dispatch('addLate',this.num)}\n     ...mapActions({addOpp:'addOpp',addLate:'addLate'})\n     }\n }\n&lt;/script></code></pre>\n\n#### 通过数组\n当组件中的方法名、变量名与State、Mutations...中的变量名相同时，可以直接使用数组\n<div class=\"show\">...mapState(['变量名1','变量名2',....])</div>\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>不同的mapstate等写法&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{addTen}}&lt;/h2>\n    &lt;h3>当前值为{{sum}}&lt;/h3>\n    &lt;h2>从state获取name为{{name}},从state获取song为{{song}}&lt;/h2>\n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    &lt;button @click=\"JIA(num)\">加&lt;/button>\n    &lt;button @click=\"JIAN(num)\">减&lt;/button>\n    &lt;button @click=\"addOpp(num)\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate(num)\">延迟3s加&lt;/button>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nimport {mapState,mapGetters, mapMutations,mapActions} from 'vuex'\nexport default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1,\n        }\n    },\n    computed:{\n        ...mapState(['sum','name','song']),\n        ...mapGetters(['addTen'])\n    },\n    methods:{\n        //数组写法\n    ...mapMutations(['JIA','JIAN']),\n     ...mapActions(['addOpp','addLate'])\n    }\n }\n&lt;/script></code></pre>\n\n### 模块化与命名空间\n当有多类数据需要vuex管理时，可以将他们的state、actions、mutation封装到多个js文件中，并为它们开启<span class=\"tips\">命名空间</span>\n\n#### 方法\n1. 在store目录中创建多个store配置文件\n2. 将配置文件统一引入该目录的index.js中\n3. 将store配置引入main.js中\n4. 创建组件，需要注意辅助函数的用法，指向命名空间的方法\n5. 在app中引入组件\n\n#### 案例\neg: 在上个案例基础上加入添加成员的功能。现在有两个功能：求和求差、添加成员，因此store目录下需要两个store配置项。在组件中调用数据时，需要用到命名空间，从不同state中引用数据。\n\n\n##### 1. 配置store\n在store目录新建 person.js文件\n<pre><code>//添加人员模块\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\n const person = {\n    namespaced:true, //开启命名空间\n    actions:{\n        addPersonZhou(context,value){\n            if(value.name.indexOf('周')===0){\n                context.commit('ADD_PERSON',value)\n            }\n            else{\n                alert('只能添加姓周的名')\n            }\n        },     \n    },\n    mutations:{\n        ADD_PERSON(state,personObj){\n            state.personList.unshift(personObj);\n        }\n    },\n    state:{\n        personList:[{id:'001',name:'张三'}]\n    },\n    getters:{\n        getFirstName(state){\n            return state.personList[0].name;\n        }\n    }\n }\n export default person</code></pre>\n\n在store目录新建 count.js文件\n<pre><code>//求和模块\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\nexport default {\n    namespaced:true, //开启命名空间\n    actions: {\n        addOpp(context,value){          //判断是否为偶数\n            if(!(value%2)){\n            context.commit('JIA',value)\n            }else{\n                console.log('非偶数，数未提交')\n            }\n        },\n        addLate(context,value){        //数据想要多道处理时，可以dispatch为actions内的其他方法，无限套娃\n            setTimeout(()=>{\n                context.dispatch('addLate2',value);\n                console.log('第一次延迟处理')\n            },500)\n        },\n        addLate2(context,value){      //数据经过第二道处理后，再提交\n            setTimeout(()=>{\n                context.commit('JIA',value);\n                console.log('第二次延迟处理')\n            },500)\n        }\n    },\n    mutations:{\n        JIA(state,value){           //加\n            state.sum+=value\n        },\n        JIAN(state,value){          //减\n            state.sum-=value;\n        },\n    },\n    state:{\n        sum:0,\n        name:'周杰伦',\n        song:'夜曲',\n    },\n    getters:{\n        addTen(state){\n            return state.sum+10\n        }\n    }\n}</code></pre>\n\n ##### 2. 在index.js中引入\n 在store目录下index.js中引入\n<pre><code> import Vue from 'vue'\n import Vuex from 'vuex'\nVue.use(Vuex)\n//引入两个配置项\nimport count from './count'\nimport person from './person'\n// 创建并暴露store\nexport default new Vuex.Store({\n    //引入模块\n    modules:{\n        //全写count: count,\n        count,\n        person\n    }\n })</code></pre>\n\n #### 3. 在main.js中引入store\n <pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport store from './store'\nnew Vue({\n  render: h => h(App),\n  store\n}).$mount('#app')</code></pre>\n\n##### 4. 书写组件\n创建count.vue组件\n<pre><code>\n&lt;template>\n  &lt;div>\n    &lt;h2>求和案例&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{addTen}}&lt;/h2>\n    &lt;h3>当前值为{{sum}}&lt;/h3>\n    &lt;h2>从state获取name为{{name}},从state获取song为{{song}}&lt;/h2>\n    \n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    &lt;button @click=\"incrace(num)\">加&lt;/button>\n    &lt;button @click=\"decrace(num)\">减&lt;/button>\n    &lt;button @click=\"addOpp(num)\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate(num)\">延迟3s加&lt;/button>\n    &lt;h1>组件2共享过来的人员名单&lt;/h1>\n   &lt;ol class=\"person-list\">\n    &lt;li v-for=\"person in personList\" :key=\"person.id\">{{person.name}}&lt;/li>\n    &lt;/ol>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n import {mapState,mapGetters, mapMutations,mapActions} from 'vuex'\n export default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1,\n        }\n    },\n    //使用mapState,mapGetters, mapMutations,mapActions时更简洁\n    computed:{\n        // 从count组件获取数据\n        ...mapState('count',{sum:'sum',name:'name',song:'song'}),\n         // 从person组件获取数据\n        ...mapState('person',['personList']),\n\n        ...mapGetters('count',{addTen:'addTen'})\n    },\n    methods:{\n    ...mapMutations('count',{incrace:'JIA',decrace:'JIAN'}),\n    ...mapActions('count',{addOpp:'addOpp',addLate:'addLate'})\n    }\n }\n&lt;/script></code></pre>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n辅助函数指向命名空间时，需要在数据和方法名前添加命名空间名，如：...mapState('命名空间',{参数})</div>\n\nperson.vue组件\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>组件2：添加成员&lt;/h2>\n    &lt;input type=\"text\" v-model=\"personName\" placeholder=\"添加成员\">\n    &lt;button @click=\"add\">添加&lt;/button>\n    &lt;button @click=\"addZhou\">只添加姓周的人&lt;/button>\n    &lt;ul>\n        &lt;li v-for=\"person in personList\" :key=\"person.id\">{{person.name}}&lt;/li>\n    &lt;/ul>\n    &lt;h2>名单第一个人为{{firstPersonName}}&lt;/h2>\n    &lt;h2>组件一共享的值&lt;/h2>\n    &lt;h3>和为：{{sum}}&lt;/h3>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nimport { nanoid } from 'nanoid'\nexport default {\n    name:'CountSum',\n    data(){\n        return {\n            personName:''\n        }\n    },\n    //不使用mapState,mapGetters, mapMutations,mapActions时更新、获取数据的方法\n    computed:{\n        personList(){\n            return this.$store.state.person.personList\n        },\n        sum(){\n            return this.$store.state.count.sum\n        },\n        //通过getters获取时，想要指定组件名与路径\n        firstPersonName(){\n            return this.$store.getters['person/getFirstName']\n        }\n    },\n    methods:{\n     add(){\n        const personObj={id:nanoid(),name:this.personName};\n        //指定为person组件下的ADD_PERSON函数\n        this.$store.commit('person/ADD_PERSON',personObj);\n        this.personName='';\n     },\n     addZhou(){\n         const personObj={id:nanoid(),name:this.personName};\n         this.$store.dispatch('person/addPersonZhou',personObj);\n         this.personName='';\n     }\n    }\n  }\n&lt;/script></code></pre>\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n不借助mapState等辅助函数，需要使用路径来指定命名空间名称，其中读取state中的数据使用<span class=\"tips\">this.$store.state.配置文件名.数据名</span>来指向命名空间，而<span class=\"tips\">dispatch</span>、<span class=\"tips\">commit</span>、<span class=\"tips\">getter</span>等api需要使用<span class=\"tips\">this.$store.api名['命名空间/方法名',变量名]</span>语句来指向命名空间</div>\n\n##### 5. App.vue引入两个组件即可\n<pre><code>&lt;template>\n  &lt;div id=\"app\">\n    &lt;Count/>\n    &lt;Person/>\n  &lt;/div>\n&lt;/template>\n &lt;script>\n import Count from'./components/Count.vue'\n import Person from'./components/Person.vue'\n export default {\n  name:'App',\n  components:{\n    Count,\n    Person\n  }\n }\n&lt;/script>\n</code></pre>","tags":["web","vue"]},{"title":"一位资深数据工程师酒后的肺腑之言(转载)","url":"/blog/2022/03/15/一位十年IT工程师的酒后真言/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n原帖来源于Reddit论坛：<a href=\"https://www.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/\">Drunk Post: Things I've learned as a Sr Engineer</a></div>\n\n最早我是在知乎上看到的，后来又陆陆续续在公众号、贴吧多次看到，最后追到了Reddit上，原帖作者是flipstables，这篇帖子目前已经获得了12k的点赞，写的很有意思。\n\n### 节选\n<span class=\"strong\">我喝醉了，这是我作为一名工程师在过去十年学到的一些东西，我可能会后悔说了这些话，但是.....醉都醉了，管他呢。</span>\n\n(1)\t提升职业生涯的最好方法是换公司。\n\n(2)\t技术栈不重要。每个技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。\n\n(3)\t人们爱跳槽是有原因的。 如果对当前工作不满意，也许是时候离开了\n\n(4)\t工作和人际关系是两回事。在一些公司，我交到了好朋友，但是工作得并不开心；在另一些公司里，我没有与任何同事建立友谊，但是工作得很开心。\n\n(5)\t我学会了对经理诚实，总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。\n\n(6)\t如果我每个季度不止一次在凌晨2点被人叫醒，并且他们认为我是可以随叫随到的，那么肯定是出了很严重的问题(系统或人)，要么我得修正他们的看法(或者修复系统)，要么提桶跑路。\n\n(7)<span class=\"strong\">再倒一杯</span>\n\t\n(8)\t优秀的经理和优秀的工程师有很多相似之处。\n\n(9)\t刚开始的时候，我也曾痴迷技术、编程、计算机，但现在已经翻篇了。\n\n(10)\t好的代码是能被初级工程师理解的代码。伟大的代码是可以被CS 专业的大一新生理解的代码。\n\n(11)\t作为一名工程师，最被忽视的能力是写文档。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。\n\n(12)\t网上的口水战(vim vs emacs ,mac vs linux)，几乎都无关紧要，别去参与，除了下一条。\n\n(13)\t年纪越大，我就越觉得动态语言更好，妈的，我就这么说了，有谁反对？\n\n(14)\t如果发现自己是公司里面最厉害的工程师，那就该离开了。\n\n(15)\t我不知道为什么全栈工程师的工资这么低。 不，真的，他们应该每年得到50万的年薪，只是基本工资。 妈的，他们必须了解前端和后端以及不同的浏览器如何工作，还得了解网络、数据库、缓存以及PC端和移动端之间的差异，天哪，还有公司使用的其他框架？ 说真的，为什么全栈工程师工资这么少\n\n(16)\t我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了，我喜欢实习生。\n\n(17) <span class=\"strong\">抿~</span>\n\n(18)\t不要过于迷恋大牛，我花了 5000 美元参加了我所崇拜大牛的公开课。 他是一个才华横溢的人，但后来我意识到，他和我们其他人一样，在瞎编。\n\n(19)\t技术栈很重要。好吧，我刚刚说过不重要之类的话，但听我说完，如果你使用 Python 或 C++ 语言，就会忍不住想用这些语言做一些非同寻常的事情，因为这些语言确实适合干这些工作。\n\n(20)\t如果你不确定自己想做什么东西，请使用 Java。这是一门很糟糕的编程语言，但它几乎无所不能。\n\n(21)\t对于初学者来说，最赚钱的编程语言是 SQL，能干翻所有其他语言。就算你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。\n\n(22)\t测试很重要，但 TDD （测试驱动的开发）是个该死的邪教。\n\n(23)\t政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你得出卖你的灵魂去深究这些专有技术，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄多数在 50 岁以上是有原因的。\n\n(24)\t如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。\n\n(25)\t我从来没有在FAANG (Facebook、亚马逊、苹果、奈飞、谷歌)工作过，所以我不知道我错过了什么。但是我招过FAANG的工程师，他们也不知道自己在做什么。\n\n(26)\t自我价值不是和薪酬挂钩的函数，跟那东西没什么关系，用资本来确定自我价值很糟糕。\n\n(27)\t头衔大多无关紧要，随便什么公司都可以有首席工程师。\n\n(28)\t说到头衔，在职业生涯早期，头衔升级很好，因为这可以让你历练技能，学会担当责任。但到后期，头衔降级很好，这会让你增加薪水。\n\n(29)\t善待每一个人，不是因为这会有助于你的事业，而是因为向善本身就有回报。\n\n(30)\t如果上个月我没有从初级工程师或实习生那里学到点什么，那说明我没有上心。\n\n(31)\t<span class=\"strong\">该死，没酒了</span>\n\n(32)\t在课程、书籍、会议方面花点钱是值得的。\n\n(33)\t手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。\n\n(34)\t当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。\n\n(35)\t就算我心里讨厌某种技术，但如果我觉得他好的话，我还是会把它推荐给客户，比如我恨 Jenkins，但会把它推荐给客户，我不觉得做错了。\n\n(36)\tGit很糟糕，但我没有选择只能使用它，它的GUI可以见鬼去了，给我命令就行，大概只需要记住7个，其他的可以Google。\n\n(37)\t我喜欢团队里的半技术分析师， 因为懂编程但不懂软件工程，他们对我成长的帮助比最杰出的工程师要大得多。\n\n(38) <span class=\"strong\">糟糕，又没酒了</span>\n\n(39)\t成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。\n\n(40)\t发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。\n\n(41)\t我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。\n\n(42)\t算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。\n\n(43)\t做自己喜欢的事情并不重要，不要让做讨厌的事情更重要。\n\n(44)\t越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。\n\n(45)\t即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。\n\n(46)\t不是所有好工作都在硅谷，但那里有很多。\n\n(47) <span class=\"strong\">哦，该死，我又找到啤酒了</span>\n\n(48)\t结对编程很棒，只是需要花很多时间，而公司往往不想花那么多时间。\n\n(49)\t和聪明的工程师一起工作让我变成更好的码农，和聪明的非技术同事一起工作让我成为更好的工程师。\n\n(50)\t朝九晚五以外的时间就别花在工作上了，除非那个项目真的很棒，你状态很好。\n\n(51)\t人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那将是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。\n\n(52)\t好人写的代码也有烂的，聪明人写的代码也是，好的工程师也会写出糟糕的代码。不要让代码质量成为你衡量自我价值的因变量。\n\n(53)\t我进入这个行业是因为我喜欢技术，但现在工作已经毁了我的爱好。\n\n(54)\t我挣的钱还不错，对此我心存感激，不过还是得省着点用。\n\n","tags":["life","CS"]},{"title":"VLess+TLS+WS代理服务器搭建","url":"/blog/2022/03/10/VLess-TLS高阶搭建/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n本文采用 WTFPL 许可证书，转载请不要标注任何本站信息\n<div><a href=\"https://wtfpl2.com/\">WTFPL © Do What the Fuck You Want to Public License</a></div></div>\n\n### 简介\nVLESS 是一种无状态的轻量级数据传输协议，使用 UUID 进行身份验，其协议不再依赖系统时间，配置灵活。但其本身协议不带加密，因此需要配合 TLS 等加密手段。\n\n### 前置需要\n#### 一台可用的VPS\n国内的可以使用香港、台湾地区的服务器，如GCP在台湾的节点、softshellweb，国外的推荐vultr、搬瓦工等主流厂商，支持支付宝付款并且不容易跑路。\n\n操作系统请选择自己熟悉的发行版，并能解决防火墙策略、开放端口等问题，这里以CentOS7为例。\n\n安装完毕后需要测试是否能Ping通，可以直接使用ping命令尝试，或者去相关网站，国内可以通过<a href=\"https://ping.chinaz.com/\">站长Ping工具</a>检测，国外通过<a href=\"https://www.yougetsignal.com/\">yougetsignal</a>检测。如果国内能ping通，说明该服务器可用，可以开始搭建了。如果国外能ping通，国内无法ping通，则说明被拦截了，需要换一台服务器。如果国内国外都无法ping通，则说明服务器还未部署好，需等待几分钟后再重试。\n\n#### 域名\n域名推荐去 godaddy 购买，顶级域名为<span class=\"tips\">.com</span>的域名一般第一年只需要59元，<span class=\"tips\">.cn</span>域名一般35元，最便宜的诸如<span class=\"tips\">.live</span>结尾的域名第一年不到14元\n\n拿到域名后将其解析到所购买的VPS IP地址，域名一般需要24h才会生效(实际不用)。\n\n#### SSL/TLS证书\nSSL/TLS证书可以从以下平台免费获取，证书有效期一般为90天，90天后需要更换\n+ zerossl：<a href=\"https://zerossl.com/\">https://zerossl.com/</a>\n+ letsencrypt：<a href=\"https://letsencrypt.org/\">https://letsencrypt.org/</a>\n+ FreeSSL：<a href=\"https://freessl.org/\">https://freessl.org/</a>\n+ SSL For Free：<a href=\"https://www.sslforfree.com/\">https://www.sslforfree.com/</a>\n\n将获取的证书、密钥文件上传到服务器上，在配置文件时使用。如果不想手动更新SSL证书，可以使用脚本自动更新\n脚本地址：https://github.com/acmesh-official/acme.sh\n### 安装内核\n#### 安装V2fly\nGithub开源地址：https://github.com/v2fly/fhs-install-v2ray\n\n安装/更新 v2fly命令：\n<pre><code>bash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)</pre></code>\n\n安装完成后，配置文件放在<span class=\"tips\">/usr/local/etc/v2ray/config.json</span>路径下\n\n#### Google BBR加速算法\nTCP BBR(Bottleneck Bandwidth and Round-trip propagation time)是由Google于2016年发布的一种拥塞控制算法，可以显著地提高Linux服务器吞吐量并减少TCP连接的延迟\n\n安装bbrplus：\n<pre><code>wget \"https://github.com/cx9208/bbrplus/raw/master/ok_bbrplus_centos.sh\" && chmod +x ok_bbrplus_centos.sh && ./ok_bbrplus_centos.sh</code></pre>\n\n安装完毕需要重启系统，重启完毕可通过<span class=\"tips\">uname -r</span>命令查询内核，返回bbr相关值说明升级完成，通过命令<span class=\"tips\">lsmod | grep bbr</span>查看是否载入bbr系统模块，返回bbr相关值说明已经加载。\n\nCentOS8+系统内核自带BBR，开启方法可自行百度。\n### 服务端\n#### 服务端配置\n使用vim在<span class=\"tips\">/usr/local/etc/v2ray/config.json</span>配置文件中添加配置设置。\n\n<pre><code>{\n  {\n\t\"log\": {\n\t\"loglevel\": \"warning\",\n\t\"access\": \"/var/log/v2ray/access.log\",   \n\t\"error\": \"/var/log/v2ray/error.log\"  //日志输出路径\n    },\n\t\"inbounds\": [{\n\t\"port\": 8180 ,  //监听端口\n\t\"protocol\": \"vless\",//主传入协议\n\t\"settings\": {\n\t\"decryption\": \"none\",\n\t\"clients\": [\n\t{\n\t\"id\": \"41803377-5789-4bf5-8cb4-dd6ad659554c\",//UUID\n\t\"level\": 0\n\t    }\n      ]\n\t},\n\t\"streamSettings\": {\n\t\"network\":\"ws\",  //传输协议\n\t\"security\": \"tls\", //传输层安全\n\t\"wsSettings\":{\n\t\"path\":\"/\",     //路径\n\t\"headers\":{}\n    },\n    \"tlsSettings\": {\n    \"serverName\": \"newyear101.xyz\", //域名\n    \"certificates\": [{\n    \"certificateFile\": \"/etc/ssl/certificate.crt\",//SSL证书路径\n    \"keyFile\": \"/etc/ssl/private.key\" //密钥路径\n            }]\n         }\n      }\n    }],\n    \"outbounds\": [{\n    \"protocol\": \"freedom\",//主传出协议\n    \"settings\": {}\n    },{\n    \"protocol\": \"blackhole\",\n    \"settings\": {},\n    \"tag\": \"blocked\"\n    }],\n    \"routing\": {\n    \"rules\": [\n    {\n    \"type\": \"field\",\n    \"ip\": [\"geoip:private\"],\n    \"outboundTag\": \"blocked\"\n        }\n      ]\n   }\n }\n</code></pre>\n\n+ UUID作为唯一身份识别码，可通过客户端生成，或通过UUID生成网站获得，不能自行编写\n##### 检测配置文件是否正确\nv2ray官方检测命令：\n<pre><code>/usr/local/bin/v2ray -test -config  /usr/local/etc/v2ray/config.json</pre></code>\n文件正确会返回值：\n<div class=\"shell\">V2Ray 4.44.0 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.17.3 linux/amd64)\nA unified platform for anti-censorship.\n2021/02/03 21:46:12 [Info] main/jsonem: Reading config: /usr/local/etc/v2ray/config.json\nConfiguration OK.</div>\n\n#### 更新防火墙规则\n##### Centos 7/8 firewalld 放行端口\n<div class=\"show\">// 8180改成自己的端口号\nfirewall-cmd --permanent --add-port=8180/tcp \n//重启使之生效\nfirewall-cmd --reload\n</div>\n\n##### ubuntu系统 ufw放行端口\n<div class=\"show\">//8180改成自己的端口号\nsudo ufw allow 8180/tcp\n//重启\nsudo ufw reload\n</div>\n\n##### Centos 6/7 iptable放行端口\n<div class=\"show\">//8180改成自己的端口号\niptables -I INPUT -p tcp --dport 8180 -j ACCEPT\n//保存添加的规则链\nservice iptables save\n</div>\n\n\n\n\n\n### 客户端\n客户端需要使用4.23.2以上内核\n\n#### 客户端下载地址：\n+ <strong>Android</strong>: [v2rayNG](https://github.com/2dust/v2rayNG/releases)\n+ <strong>windows</strong>:[v2rayN](https://github.com/2dust/v2rayN/releases)\n+ <strong>MacOS</strong>:[V2rayU](https://github.com/yanue/V2rayU/releases)\n\n### 客户端配置\n<div class=\"table\">\n\n配置项 | 值\n--------|-------\n别名    | 任意\n地址    |VPS的IP地址\n端口    |配置文件中的端口号\n用户ID   |UUID,需要和配置文件一致\n传输协议 |ws\n伪装域名 |解析的域名\n路径    |配置文件中的路径\n传输层安全|tls\n</div>\n\n### 命令\n#### 系统命令\n如果已经启动v2ray服务，修改的配置文件需要重启生效\n+ <strong>systemctl start v2ray</strong> 运行\n+ <strong>systemctl stop v2ray</strong> 停止\n+ <strong>systemctl restart v2ray</strong> 重启\n\n#### 常用服务命令\n##### 生成uuid\n <span class=\"strong\">v2ctl uuid</span> 生成一个新的uuid\n\n ##### 配置相关\n <span class=\"strong\">v2ray [参数]</span>\n\n<div class=\"table\">\n\n参数 | 说明\n--------|-------\n-version | 查看当前版本\n-test    |测试配置文件有效性\n-config |手动指定配置文件，值可以是绝对路径、相对路径、url链接、\"stdin:\"(从标准输入读取内容)\n\n</div>\n","tags":["Server","VPS"]},{"title":"Nginx笔记(上)","url":"/blog/2022/03/04/nginx笔记/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nnginx官方文档：<a target=\"_blank\" href=\"http://nginx.org/en/docs/\">http://nginx.org/en/docs/</a></div>\n\n### 基本介绍\n#### Nginx简介\nNginx是一款高性能的Web服务器软件，能在高并发环境下快速响应http/https请求，同时也提供IMAP/POP3/SMTP服务,可用于反向代理服务器、虚拟主机、域名解析、负载均衡、防盗链、URL重定向、http/https、邮件代理服务器等各类场景。\n\n根据[Netcraft](https://news.netcraft.com/) 发布的web服务器调查报告，截至2022年1月，nginx是全球最常用的web服务器软件，占有全球32.3%的站点，另一服务器软件Apache占有23.9%的站点，很大一部分web服务器使用Nginx作为负载均衡服务器。\n\n#### 依赖与环境\n<strong>操作系统要求：</strong>Nginx底层使用了多进程和I/O多路复用(epoll)来提高并发能力，因此需要使用Linux2.6以上的内核以支持epoll\n\n<strong>源码包依赖：</strong>\n\n+ GCC编译器：编译C语言\n+ PCRE库(兼容正则表达式库)：用于支持正则表达式\n+ zlib库：为Nginx的gzip压缩提供压缩算法\n+ OpenSSL：提供安全通信\n\n#### 进程模型\n\nmaster进程：主进程，以root权限运行，负责读取检测配置文件，启动和管理worker进程\n\nworker进程：工作进程，权限由配置文件中的user决定，负责处理网络请求，进程数量由配置文件中的worker_processes决定\n\n### 常用命令\n#### Nginx服务命令\n未配置全局环境变量的情况下，nginx命令执行路径为<span class=\"tips\">/usr/local/nginx/sbin</span>，可以通过./nginx -h查看所有命令\n\n<div class=\"table\">\n\n命令|说明\n----|-----\n./nginx|启动nginx\n./nginx -h|-h可替换为-?,查看nginx的所有命令\n./nginx -v|查看nginx的版本\n./nginx -s 信号量|发送一个信号量操作nginx\n./nginx -s stop|强制关闭nginx\n./nginx -s quit|停止接受新请求，等待nginx处理完当前任务后关闭nginx\n./nginx -s reload|重新加载配置文件\n./nginx -s reopen|重新打开日志文件(可用于日志分割)\n./nginx -t [文件路径]|检测nginx的配置文件是否书写正确\n./nginx -T |检测nginx的配置文件是否书写正确，若正确则将内容输出到屏幕\n./nginx -c 文件路径 |手动指定nginx的配置文件后启动\n</div>\n\n#### Linux系统命令\n<span class=\"strong\">kill -信号 master进程PID</span>\n<div class=\"table\">\n\n信号|说明\n----|-----\nTERM/INT | 强制关闭nginx\nQUIT | 停止接受新请求，处理完当前任务后关闭nginx\nHUP |重新加载配置文件\nUSR1|重新打开日志文件(可用于日志分割)\nUSR2|不停止服务，平滑升级到最新版nginx\nWINCH|停止接受新请求，处理完当前任务后关闭所有worker进程\n</div>\n\n##### 关于平滑升级\n执行 <span class=\"tips\">kill -USR2 17482</span>(假设17482为master进程PID)命令进行平滑升级时，更新完ngixn后会开启一个新版本nginx对应的master进程和work进程，此时系统中将会有两个master进程，并且新版本的master进程PID会被记录在<span class=\"tips\">/usr/loca1/nginx/logs/nginx.pid</span>文件中，而旧版本master进程PID会被记录在<span class=\"tips\">/usr/loca1/nginx/logs/nginx.pid.oldbin</span>文件中，之后会发送QUIT信号给旧的master进程，让其处理完请求后关闭，完成升级。\n\n\n\n\n### 配置文件\n配置文件位于<span class=\"tips\">/usr/local/nginx/conf/nginx.conf</span>路径下\n#### 全局配置\n<div class=\"show\">#user  nobody;          //指定nginx工作进程的用户身份，默认为nobody\nworker_processes  1;   //允许生成的worker process数\n\n#error_log  logs/error.log;     //日志级别与存放路径\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid; //master进程pid存放路径\n......</div>\n\n##### user配置进程权限\n<span class=\"strong\">user 用户名 [用户组];</span>\n\n默认为nobody，配置决定了worker进程的调用用户，以及nginx对文件(一般指资源文件和目录)的读写权限，而日志文件、pid文件、配置文件等由master进程调用的文件则不受此配置影响，所有者一般为root。当配置的用户对指定文件无访问权限时，Nginx将返回403错误，此时需要授予该用户相关权限，或者更改为权限更高的用户。\n\n##### worker_processes配置进程数量\n+ <span class=\"strong\">master_process on/off;</span>用于指定是否生成worker进程，默认为on\n+ <span class=\"strong\">worker_processes 值/auto;</span>指定worker进程生成数量，默认为1\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nworker_processes值越大，处理并发能力越强。但需要考虑服务器的CPU核心数、内存余量等硬件资源大小</div>\n\n\n##### daemon配置nginx为守护进程\n<span class=\"strong\">daemon on/off;</span>\n\n配置nginx是否以守护进程方式启动，并在后台运行，默认为on\n\n\n##### error_log配置日志\n<span class=\"strong\">error_log 路径 [日志级别];</span>\n\n配置日志路径和记录级别，这里指Nginx本身运行错误产生的日志，用户连接产生的日志需要在http/https块里配置，默认将notice以上级别的日志写入error.log日志文件中，日志级别有 debug、info、notice、warn、error、crit\n\n\n##### pid配置pid文件路径\n<span class=\"strong\">pid 路径;</span>\n\n自定义pid文件路径，默认在/usr/local/nginx/logs/nginx.pid路径下。pid文件用于存放master进程的pid，会在master进程产生时生成，进程关闭时删除。当使用nginx -s reload/reopen重新加载配置文件或日志时，nginx会到该文件中读取进程pid，如果该文件无法找到或者已经被删除，nginx将报错，常用的解决方法是使用<span class=\"tips\">nginx -c 配置文件名</span>命令重新指定配置文件后启动nginx\n\n#### events块\n<div class=\"show\">...\nevents {\n    worker_connections  1024;//每个worker允许的最大连接数\n}\n</div>\n\n##### accept_mutex配置网络连接序列号\n<span class=\"strong\">accept_mutex on/off;</span>\n\n默认为on，用于解决“惊群”问题，即将连接到nginx的网络连接进行序列化，并依次分配给worker进程，防止多个worker争抢连接。\n\n##### accept_mutex配置网络连接序列号\n<span class=\"strong\">multi_accept on/off;</span>\n\n默认为off，在off状态下，一个worker进程只能接收一个新的连接请求，否则，一个worker进程将同时接收所有新连接。\n\n##### worker_connections配置单进程最大连接数\n<span class=\"strong\">worker_connections 值;</span>\n\n默认为1024，用于配置每个worker允许的最大连接数，值不能超过操作系统最大文件句柄数量。\n\n##### use配置事件处理模型\n<span class=\"strong\">use 参数;</span>\n\n可选参数有poll/select/epoll/kqueue等，Linux2.6以上内核默认使用epoll函数以优化并发连接能力。\n\n\n#### http块\n<div class=\"shell\">http {\n    include       mime.types;   //引入外部文件mime.types\n    default_type  application/octet-stream;\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #access_log  logs/access.log  main; //定义access连接日志的路径与内容\n//快速传输文件\n    sendfile        on;\n    #tcp_nopush     on;\n//服务器保持连接最大时间，单位为s\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n//传输文件前是否压缩\n    #gzip  on;\n    ....</div>\n\n#####  include\n<span class=\"strong\">include 文件名;</span>\n\n+ 用于引入外部文件，管理员可以定义一个外部文件书写配置，然后通过include将该文件内容引入到相应位置。\n+ 这里引入的mime.types用于标识文档、媒体文件格式和类型，该文件标识了常用的html、css、js、jpg等文件类型，用于帮助nginx识别请求的文件类型\n\n#####  default_type\n<span class=\"strong\">default_type MIME类型;</span>\n\n默认值application/octet-stream指没有特定类型的二进制文件，MIME类型可参考MDN文档：\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" style=\"word-wrap: break-word;\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a>\n\n##### access_log\n+ <span class=\"strong\">log_format 变量名 日志格式;</span>\n+ <span class=\"strong\">access_log 路径 变量名;</span>\n\n二者搭配使用，第一个语句用于定义一个变量名，并将配置的日志格式赋值给该变量，变量名取值需使用<span class=\"tips\">$</span>符。第二个语句用于根据变量名对应的日志格式，将用户访问日志书写到对应路径下。日志格式中对应的变量含义：\n<div class=\"table\">\n\n变量名 | 说明\n------|------\nremote_addr|客户端地址\nremote_user |客户端用户名\ntime_local  |访问时间和时区\nrequest|请求的URL和HTTP协议\nhttp_host|请求地址，即浏览器中输入的地址\nstatus |http请求返回的状态码，如：301、404等\nupstream_status|upstream状态\nbody_bytes_sent |发送给客户端的文件大小(字节)\nhttp_referer | 该请求是从哪个链接跳转过来\nhttp_user_agent |客户端信息，如：浏览器标识等\nssl_protocol|SSL协议版本\nssl_cipher|交换数据中的算法\nrequest_time|整个请求的总时间\nupstream_addr|upstream的地址，即真正提供服务的主机地址\nhttp_x_forwarded_for  |记录有代理服务器时客户端地址的配置\nupstream_response_time|请求过程中，upstream响应时间\n</div>\n\n#####  sendfile\n+ <span class=\"strong\">sendfile on/off;</span>\n+ <span class=\"strong\">tcp_nopush on/off;</span>\n\nsendfile用于高效传输文件，在sendfile为on的状态下，开启tcp_nopush会将文件积累到一定大小后再统一发送，用于提高包传输效率\n\n##### keepalive_timeout\n+ <span class=\"strong\">keepalive_timeout 值;</span>\n+ <span class=\"strong\">tcp_nodelay on/off;</span>\n\nkeepalive_timeout用于设置保持与客户端连接的最大时间，单位默认为s，超时时nginx会关闭连接并释放服务器资源，若设置为0则禁用该设置。设置的时间过大会导致大量的无效连接未断开，从而占用服务器资源，太小会导致服务未处理完，就被强制关闭连接。\n\n在keepalive_timeout启用状态下，配置tcp_nodelay on;可以将数据即使发送。\n\n##### gzip\n<span class=\"strong\">gzip on/off;</span>\n\ngzip 用于配置传输文件前是否进行压缩以提高传输速率，压缩会占用一定系统资源\n\n#### server块\n<div class=\"show\">server {\n        listen      80;   //监听端口\n        server_name  localhost;//监听的域名或ip地址\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;//日志输出路径\n        location /web/ {  //路由路径\n            root   /test;\n            index  index.html index.htm;\n        }\n        location /images {\n            root /test;\n            autoindex on;//自动生成文件归档页面\n        }\n        location /.well-known/pki-validation/{\n        root /;\n        }\n        location /new/{\n        root    /;\n        add_header Content-Disposition \"attachment;\";\n        }\n//定义404页面\n        #error_page  404              /404.html;\n//定义50x页面\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }</div>\n\n#####  listen\n<span class=\"strong\">listen 地址/端口 [default_server];</span>\n\n配置监听地址和端口，default_server参数用于将该server设置为默认主机，无该参数则第一个server为默认主机，当没有匹配到客户端指定的端口/IP时，将连接到默认主机。地址和端口格式可以为：\n\n+ listen 127.0.0.1 监听该地址所有端口\n+ listen 127.0.0.1:8080 监听该地址的8080端口\n+ listen *:8080 监听所有地址的8080端口\n\n\n ##### server_name\n<span class=\"strong\">server_name 域名/IP地址;</span>\n\n用于配置虚拟主机的标识名称，域名或IP地址可以写多个，使用空格隔开。当listen中配置了域名或IP地址，则server_name配置的域名和IP地址将失效，配置方法可以使用以下三种，当域名被多个server匹配到，将按精确匹配>通配符在开头>通配符在结尾>正则匹配>默认主机的优先级进行分配。\n\n###### 精确匹配\n<div class=\"show\">server {\n    listen 80;\n    server_name aaaa.com bbbbb.cn;//配置多个域名\n    .....}\n</div>\n\n###### 通配符匹配\n通配符只能在段首和段尾使用，不能再域名中间使用！\n<div class=\"show\">server {\n    listen 80;\n    server_name *.aaaa.com www.aaaa.*;\n    .....}\n</div>\n\n###### 正则匹配\n<div class=\"show\">server {\n    listen 80;\n    server_name ~正则表达式;\n    .....}\n</div>\n\n ##### charset\n<span class=\"strong\">charset 编码格式;</span>\ncharset 用于指定字符编码格式，默认的koi8-r为俄语编码格式(nginx作者是俄罗斯人)，与utf-8类似\n\n ##### access_log\n<span class=\"strong\">access_log 路径 日志格式;</span>\n\n用于指定该server的连接日志，日志格式默认使用http模块中的main变量定义的格式，可用<span class=\"tips\">log_format</span>命令自行定义。\n\n ##### location\n<span class=\"strong\">location 请求路径;</span>\n\n配置请求路径，可配置多个location块用于响应不同请求\n\n\n<div class=\"show\">location  /路径{   //在test目录下匹配该路径(默认)\n    root /test\n}\nlocation = /路径{   //在test目录下精准匹配该路径\n    root /test\n}\nlocation ~* \\正则表达式  {   //在test目录下正则匹配(添加*号不区分大小写)\n    root  /test            \n}\n~用于标识正则表达式，*表示不区分大小写，^~则表示不包含正则表达式，功能和不加~一致</div>\n\n ##### root/alias\n<span class=\"strong\">root/alias 路径;</span>\n\n用于指定资源查找路径，使用root语句时，客户端请求location路径，Nginx查找资源会直接前往<span class=\"tips\">root路径+location路径</span>。alias一般在需要隐藏服务器真实路径时使用，查找资源会直接前往alias路径，location路径仅作为客户端请求的虚拟路径\n\n ##### index\n<span class=\"strong\">index 文件名;</span>\n\n用于设置主页，文件名可以写多个，如: index index1.html index2.html;当找不到第一个文件时，会依次往后查找。\n\n ##### error_page\n<span class=\"strong\">error_page 状态码 [=状态码] 路径;</span>\n\n用于设置错误处理方法，根据不同的状态码，进行相应处理，常用于配置404，50x页面，可以通过添加[=状态码]修改返回给客户端的状态码，如：error_page 404 [=200] /404.html，浏览器收到的状态码将从404修改为200。路径可以为：\n+ 地址：error_page 404 http://<span></span>wrong.com\n+ 重定向:<div class=\"show\">error_page   500 502 503 504  /50x.html;\nlocation = /50x.html {\nroot   html;\n}</div>\n+ 返回信息:<div class=\"show\">error_page 404 @goto\nloaction @goto{\n    default_type text/plain;\n    return 404 'not found....'\n}</div>\n\n### Web服务器配置实例\n<strong>需求：</strong>在服务器8081和8082端口分别配置server1、server2两个服务，每个服务下有两个页面，根据客户端请求返回不同页面，为每个服务配置单独的访问日志。\n\n#### 目录树\nwebservers目录位于服务器根目录下，conf.d目录用于存放每个服务的配置文件，web目录用于存放页面和访问日志。每个服务下的logs目录用于存放access_log日志文件，webpages目录用于存放页面。\n<div class=\"shell\">webservers\n     |____conf.d\n     |          |_____server1.conf\n     |          |_____server2.conf\n     |____web\n           |____404.html\n           |____server1\n           |          |____logs——access_log\n           |          |____webpages\n           |                |____web1.html\n           |                |____web2.html\n           |____server2\n                      |_____logs——access_log\n                      |_____webpages\n                                 |_____web3.html\n                                 |_____web4.html\n</div>\n\n#### http块配置\n定义两个变量server1和server2，用于配置日志格式，两个服务的配置文件独立存放于/webservers/conf.d路径下，使用include引入nginx.conf配置文件中。\n<div class=\"show\">http{\n    ......\n    log_format server1 'new access =>$time_local';\n    log_format server2 'new access =>$time_local';\n    include /webservers/conf.d/*.conf;//引入两个服务的配置文件\n}\n</div>\n\n#### server1配置\n访问<span class=\"tips\">`http://45.77.77.10:8081`</span>访问web1页面\n\n访问<span class=\"tips\">`http://45.77.77.10:8081/pages`</span>访问web2页面\n\n<pre><code>server{\n\tlisten 8081;\n\tserver_name 45.77.77.10;\n\taccess_log /webservers/web/server1/logs/access.log server1;\n\terror_page 404 /404.html;\n    location /{\n\talias /webservers/web/server1/webpages/;\n\tindex web1.html;\n\t}\n\tlocation /pages{\n\talias /webservers/web/server1/webpages/;\n\tindex web2.html;\n\t}\n\tlocation =/404.html{\n\troot /webservers/web;\n\tindex 404.html;\n\t}\n      }\n</code></pre>\n\n##### server2配置\n访问<span class=\"tips\">`http://45.77.77.10:8082/web3.html`</span>访问web3页面\n\n访问<span class=\"tips\">`http://45.77.77.10:8082/webpages`</span>访问web4页面\n<pre><code>server{\n\tlisten 8082;\n\tserver_name 45.77.77.10;\n\taccess_log /webservers/web/server2/logs/access.log server2;\n\terror_page 404 /404.html;\n\tlocation /web3.html{\n\troot /webservers/web/server2/webpages;\n\tindex web3.html;\n\t}\n\t\n\tlocation /webpages{\n\troot /webservers/web/server2;\n\tindex web4.html;\n\t}\n\n\tlocation =/404.html{\n\troot /webservers/web;\n\tindex 404.html;\n\t}\n      }\n</code></pre>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n配置https服务时，使用<span class=\"tips\">ssl_certificatessl 路径</span>语句配置证书，使用<span class=\"tips\">ssl_certificate_key 路径</span>配置密钥</div>\n\n\n\n### 静态资源提供服务\n\n<pre><code>http {\n    .......\ngzip on;\ngzip_min_length 1;  //设置最小压缩大小，小于1字节的文件不进行压缩\ngzip_comp_level 3; //压缩级别(压缩比)，取值范围为1-9，值越大，压缩越多，cpu占用率越高\ngzip_types text/css text/javascript; //配置压缩的文件类型\n    server {\n        listen      80;\n        server_name  45.77.78.10;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n\t    location /images/ {  //匹配路径\n\t    root /test;         //资源所在路径\n\t    autoindex on;  //自动生成资源归档页面\n \t    }\n\t    location /images {  //匹配路径\n\t    root /test;         //资源所在路径\n \t    }\n         location /other/ {  //匹配路径\n\t    alias /test/images;         //资源所在路径\n \t    }\n        #error_page  404              /404.html;\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n        .....\n    }\n    ........\n}</code></pre>\ntest目录服务器根目录下，并且在/test/images路径下存放了photo.jpg照片\n\n+ 使用第一个location配置时，当访问 http:<span></span>//45.77.78.10/images/ 时，ngxin会在自动生成的归档页面上输出/test/images/目录下的所有文件。请求只能为location后面配置的参数，若请求为 http:<span></span>//45.77.78.10/test/images/则会返回404\n+ 使用第二个location配置时，由于未使用 <span class=\"tips\">autoindex on</span> 配置，nginx不会生成归档页面，当访问 http:<span></span>//45.77.78.10/images/ 时nginx将返回403，访问文件需指定具体文件路径，如：http:<span></span>//45.77.78.10/test/images/photo.jpg\n+ 当需要对访问者隐藏服务器实际文件路径时，可以使用<span class=\"tips\">alias</span>进行配置，使用第三个location配置，url应当为http:<span></span>//45.77.78.10/other/photo.jpg，此时实际访问的依旧alias指定的/test/images路径下的文件\n","tags":["Server","Web"]},{"title":"Redhat防火墙","url":"/blog/2022/02/23/Centos防火墙/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n本文不涉及Debian系列操作系统使用的ufw(Uncomplicated FireWall)防火墙</div>\n\n### Firewalld\nFirewalld支持动态更新防火墙规则，并加入了区域（zone）的概念，zone是Firewalld预先准备的几套防火墙策略模板，用户可以根据不同生产场景选择合适的策略集合，从而实现防火墙策略之间的快速切换。\n\n#### 常用的区域\n\n<div class=\"table\">\n\n区域 | 默认策略\n-----|-------\ntrusted(信任)|允许所有数据包\nblock(阻塞)|拒绝所有数据包\ndrop(丢弃)|丢弃所有数据包，并且不回复信息\nhome(家庭)|仅接受与流出数据有关，或者与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关的数据包\npublic(公共)|仅接受与流出数据有关，或与ssh、dhcpv6-client服务相关的数据包\ninternal(内部)|仅接受与流出数据有关，或与ssh、mdns、ipp-client、dhcpv6-client服务相关的数据包\nwork(工作)|仅接受与流出的流量，或与ssh、ipp-client与dhcpv6-client服务相关的数据包\nexternal(外部)|仅接受与流出流量和ssh服务相关的数据包\nDMZ(隔离)|又称为非军事区域，内外网络之间增加的一层网络，起到缓冲作用，仅接受与流出的流量相关和ssh服务相关的数据包\n</div>\n\nfirewalld默认提供了9个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、 home.xml、internal.xml、public.xml、trusted.xml、work.xml，文件位于<span class=\"tips\">/usr/lib /firewalld/zones/</span>目录下。用户对区域进行修改后，会在<span class=\"tips\">/etc/firewalld/zones</span>目录下生成对应的(用户自定义)配置文件。\n\n#### 防火墙开启与关闭\n<div class=\"table\">\n\n命令 | 说明\n---- |------\nsystemctl start firewalld|开启防火墙\nsystemctl stop firewalld  |关闭防火墙\nsystemctl enable firewalld|开机自启动防火墙\nsystemctl disable firewalld|禁止开机自启动\nsystemctl status firewalld |查看防火墙状态\n</div>\n\n\n#### 命令与参数\n<span class=\"strong\">firewall-cmd [参数]</span>\n\n<div class=\"table\">\n\n参数 | 说明\n ----|-----\n-&zwnj;-state|查看防火墙是否在运行\n-&zwnj;-get-default-zone|查看当前生效的防火墙区域\n-&zwnj;-set-default-zone=区域名|设置生效的防火墙区域\n-&zwnj;-get-zones\t|显示所有可用的区域\n-&zwnj;-get-active-zones|显示当前正在使用的区域与网卡名称\n-&zwnj;-zone=区域名 -&zwnj;-list-all|列出指定区域的所有配置参数\n-&zwnj;-list-all-zones\t|显示所有区域的网卡配置参数、资源、端口以及服务等信息\n-&zwnj;-get-services\t|查看当前域所有支持的服务(需要放行的服务需要自行添加)\n-&zwnj;-list-services\t|查看当前区域允许放行的服务列表\n-&zwnj;-add-service=服务名|设置当前区域允许该服务的流量通过\n-&zwnj;-add-port=端口号/协议\t|设置当前区域允许该端口的流量通过\n-&zwnj;-remove-service=服务名\t|设置默认区域禁止该服务的流量通过\n-&zwnj;-remove-port=端口号/协议\t|设置当前区域禁止该端口的流量通过\n-&zwnj;-add-source=\t|将源自此IP或子网的流量导向指定的区域\n-&zwnj;-remove-source=\t|不再将源自此IP或子网的流量导向某个指定区域\n-&zwnj;-add-interface=网卡名\t|将源自该网卡的所有流量都导向某个指定区域\n-&zwnj;-change-interface=网卡名|\t将某个网卡与区域进行关联\n-&zwnj;-list-all\t|显示当前区域的网卡、资源配置，以及开放了哪些端口、服务\n-&zwnj;-reload\t|让“永久生效”的配置规则立即生效，并覆盖当前的配置规则\n-&zwnj;-panic-on|开启应急状况模式(关闭所有网络连接，包括远程ssh连接)\n-&zwnj;-panic-off\t|关闭应急状况模式\n\n</div>\n\n#### 生效模式，更新防火墙规则\n默认情况下，firewalld配置的防火墙策略为当前生效模式(Runtime)，系统重启时会失效。想让配置策略永久生效，需要添加<span class=\"tips\">-&zwnj;-permanent</span>参数使用永久模式(Permanent)，如：永久开放10800端口：firewall-cmd -&zwnj;-add-port=10800/tcp -&zwnj;-permanent ，但该模式配置的策略需要执行firewall-cmd -&zwnj;-reload命令重新加载后才会生效。\n\n<div class=\"table\">\n\n命令  | 说明\n----|-----\nfirewall-cmd -&zwnj;-reload|重新加载防火墙配置\nfirewall-cmd -&zwnj;-complete-reload |重新加载防火墙，不中断用户的连接,如远程连接（防火墙出严重故障时使用）\n</div>\n\n#### 示例\n<strong>1. 查看区域信息</strong>\n<div class=\"shell\">查看public区域的所有信息\n# firewall-cmd --zone=public --list-all\n返回值的含义：\nTarget：default                  //目标\nicmp-block-inversion：yes/no    //是否允许ICMP协议类型的数据包通过防火墙\nInterfaces：                   //关联的网卡\nsources：                     //来源，可以是IP地址或mac地址\nservices：                   //允许的服务\nports：                     //允许的端口，即本地开放的端口\nprotocols：                //允许通过的协议\nmasquerade: yes/no        //是否允许伪装，可改写来源IP地址及mac地址 \nforward-ports：          //允许转发的端口 \nsource-ports：          //允许的来源端口 \nicmp-blocks：         //可添加的ICMP类型，当icmp-block-inversion为no时，这些ICMP类型被拒绝；当icmp-block-inversion为yes时，这些ICMP类型被允许\n rich rules： //富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。\n</div>\n\n<strong>2. 放行端口</strong>\n<div class=\"shell\">永久放行10800-10805端口的tcp数据\n# firewall-cmd --permanent --add-port=10800-10805/tcp\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n<strong>3. 为网卡绑定区域</strong>\n\n一般情况下，一台主机会有多个网卡，比如一块对公网，一块对内网，因此网卡使用的防火墙策略也不一样，可以单独为某个网卡绑定某个区域。通过firewall-cmd --set-default-zone命令设置的区域会对所有网卡生效，但如果该网卡绑定了单独的区域，则单独绑定区域的优先级更高。\n<div class=\"shell\">将网卡eth0默认区域修改为external\n# firewall-cmd --permanent --zone=external --change-interface=eth0\n</div>\n\n<strong>4. 查询服务是否放行</strong>\n\n如：查询SSH和HTTPS协议的流量是否允许放行\n<div class=\"shell\">查询public区域中SSH协议的流量是否被放行\n# firewall-cmd --zone=public --query-service=ssh\n查询public区域中https协议的流量是否被放行\n# firewall-cmd --zone=public --query-service=https\n</div>\n\n<strong>5. 放行协议流量</strong>\n\n把HTTPS协议的流量设置为永久允许放行\n<div class=\"shell\">在public区域中放行https协议的流量\n# firewall-cmd --permanent --zone=public --add-service=https\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n\n#### 端口转发\n端口转发命令格式如下，目标IP地址为所要访问服务器的IP地址：\n<span class=\"strong\">firewall-cmd --permanent --zone=区域 --add-forward-port=port=源端口号:proto=协议:toport=目标端口号:toaddr=目标IP地址</span>\n\n<div class=\"shell\">将9000端口转发到22端口，使得用户能通过9000端口使用ssh远程连接服务\n# firewall-cmd --permanent --zone=public --add-forward-port=port=9000:proto=tcp:toport=22:toaddr=192.168.0.1\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n\n#### 富规则\n富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置，它的优先级在所有的防火墙策略中也是最高的。\n<div class=\"shell\">拒绝192.168.0.1/24网段的所有用户访问本机的ssh服务\n# # firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.0.1/24\" service name=\"ssh\" reject\"\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n\n### IPTables\n早期的RHEL系列的操作系统，默认使用IPTables来配置防火墙。RHEL7之后的系统使用firewalld取代了IPTables防火墙，IPTables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nCentos官方IPTables文档：<a target=\"_blank\" href=\"https://wiki.centos.org/HowTos/Network/IPTables\">https://wiki.centos.org/HowTos/Network/IPTables</a></div>\n\n#### 策略与规则链\nIPTables会根据管理员书写的策略来决定防火墙是否放行数据包通过，基本的策略规则有四种：ACCEPT、REJECT、LOG、DROP。IPTables会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后立即执行规则定义的行为(如：放行或阻止流量)，若在读取完所有的策略规则之后没有匹配项，则会执行默认的策略。\n\nIPTables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链。<span class=\"tips\">由于防火墙策略规则是按照从上到下的顺序匹配执行的，因此一定要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝，因此规则链最后一条往往为拒绝规则。</span>\n\n当防火墙的默认策略为拒绝时，需要添加相应的规则链来放行允许进入服务器的数据，否则服务器将拒绝所有数据包；而当防火墙的默认策略为允许时，则需要添加相应的拒绝规则链，否则防火墙就失去了它的作用。一般情况下，INPUT流量的默认策略为拒绝，OUTPUT流量默认策略为允许。\n\n#### 数据包分类与处理方式\n根据数据包的不同处理位置，数据包分为\n+ <span class=\"strong\">在进行路由选择前处理数据包(PREROUTING)</strong>\n+ <span class=\"strong\">处理流入的数据包(INPUT)</strong>\n+ <span class=\"strong\">处理流出的数据包(OUTPUT)</strong>\n+ <span class=\"strong\">处理转发的数据包(FORWARD)</strong>\n+ <span class=\"strong\">在进行路由选择后处理数据包(POSTROUTING)</strong>\n\n\n##### 数据包处理方式\n<div class=\"table\">\n\n 语句|说明\n  ---|---\nACCEPT|允许流量通过\nREJECT|拒绝流量通过并返回流量被丢弃的提示信息\nLOG   |记录日志信息\nDROP  |拒绝流量通过且不返回任何信息\n</div>\n\nREJECT会在拒绝流量后，告知流量发送方流量已收到，但服务器拒绝响应的信息\n\nDROP会直接丢弃流量，使流量发送方不清楚流量是被拒绝还是主机不在线，一般能更好保护主机安全。\n\n#### 命令与参数\n\n<span class=\"strong\">iptables [参数] [对象]</span>\n<div class=\"table\">\n\n参数 | 作用\n---|---\n-L  |查看当前的规则链，可以使用iptables -L --line-numbers命令显示规则链的序号\n-P|设置默认策略\n-F|清空规则链\n-A|在规则链末尾加入新规则\n-I [序号]|在指定序号规则前加入新规则，无序号默认在规则链首加入\n-R 序号|替换指定规则，无序号默认替换第一条规则\n-D 序号|删除指定规则\n-s IP/主机名|匹配来源的IP和主机，加!号表示除该IP外，子网掩码可以使用/MASK的方式表示\n-d |匹配目标地址，类似于参数-s\n-J |跳转到下一个处理规则，可能的值有：ACCEPT(允许数据通过), DROP(丢弃), QUEUE(进入队列), RETURN(返回上一个跳转规则)。也可以添加规则名跳转到指定规则\n-i 网卡名|匹配从该网卡流入的数据\n-o 网卡名|匹配从该网卡流出的数据\n-p 协议 |匹配协议，如:TCP、UDP等,all代表所有协议(一般不使用)\n-&zwnj;-dport 端口号|匹配目标端口号\n-&zwnj;-sport 端口号|匹配来源端口号\n\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n防火墙命令均需要root权限</div>\n<div class=\"shell\">如：查看当前规则链\niptables -L\n返回结果：\nChain INPUT (policy ACCEPT)     //INPUT数据包，默认策略为ACCEPT\nnum  target     prot opt source               destination         \n1    ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED\n2    ACCEPT     all  --  anywhere             anywhere            \n3    INPUT_direct  all  --  anywhere             anywhere            \n4    INPUT_ZONES_SOURCE  all  --  anywhere             anywhere            \n5    INPUT_ZONES  all  --  anywhere             anywhere            \n6    DROP       all  --  anywhere             anywhere             ctstate INVALID\n7    REJECT     all  --  anywhere             anywhere             reject-with icmp-host-prohibited\n</div>\n<div class=\"show\">示例：\n<strong>1. 修改INPUT规则链默认配置为拒绝，并允许允许ICMP流量进入(允许服务器被ping后返回信息)</strong>\n# iptables -P INPUT DROP\n# iptables -I INPUT -p icmp -j ACCEPT\n<strong>2. 拒绝所有人访问本机10800端口</strong>\n# iptables -I INPUT -p tcp --dport 10800 -j REJECT\n# iptables -I INPUT -p udp --dport 10800 -j REJECT\n<strong>3. 拒绝192.168.10.5主机访问本机80端口</strong>\niptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT\n<strong>4.拒绝所有主机访问本机1000～1024端口</strong>\n# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT\n# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT\n<strong>5.只允许192.168.10.0主机访问本机的22端口，拒绝来自其他所有主机的流量。</strong>\n# iptables -I INPUT -s 192.168.10.0 -p tcp --dport 22 -j ACCEPT\n# iptables -A INPUT -p tcp --dport 22 -j REJECT\n</div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n如同第5条命令，由于防火墙策略规则是按照从上到下的顺序匹配的，因此需要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝</div>\n<div class=\"show\">\n网口转发,如将公网的数据包转发到内网,假设eth0连接内网，eth1连接公网\niptables -A FORWARD -i eth0 -o eth1 -j ACCEPT\n</div>\n\n\n\n#### 保存规则\n通过命令添加的规则链，会在系统重启后失效，因此需要写入配置文件使其永久生效，可以使用命令<span class=\"tips\">service iptables save</span>保存\n\nipv4默认保存位置为<span \nclass=\"tips\">/etc/sysconfig/iptables-config</span>\n\nipv6默认保存位置为<span class=\"tips\">/etc/sysconfig/ip6tables-config</span>\n\n\n\n","tags":["CentOS","firewall"]},{"title":"Shell脚本语言","url":"/blog/2021/12/29/Shell脚本语言/","content":"### shell脚本基础\n#### 脚本声明\nshell脚本文件通常以<span class=\"tips\">.sh</span>作为文件扩展名，扩展名仅作为文件标识，并不影响脚本执行。shell程序的第一行，往往需要一个<span class=\"tips\">#!</span>约定标记符，用于告诉系统这个脚本需要调用哪一种Shell解释器来执行\n<div class=\"show\">#!bin/bash  #申明shell脚本的解释器</div>\n\n#### shell脚本的执行方式\n###### 1.通过文件名直接执行\n首先需要为该脚本添加可执行权限，然后通过文件路径和文件名直接运行，操作系统会调用脚本文件第一行所指定的解释器来执行该脚本，如对于名为HelloWorld.sh脚本，执行方式为:\n<div class=\"show\"><span class=\"strong\">chmod 755 HelloWorld.sh</span> #或chmod +x HelloWorld.sh赋予可执行权限\n<span class=\"strong\">./HelloWorld.sh</span> #在当前路径中执行HelloWorld.sh，如果直接写为HelloWorld.sh，则系统会前往PATH路径中查找该命令</div> \n\n###### 2.通过shell解释器调用\n第二种执行方式为在调用shell解释器时，将脚本作为shell程序参数传入，该方法会忽略脚本第一行所指定解释器信息，直接使用用户唤起的shell程序作为脚本解释器\n<div class=\"show\"><span class=\"strong\">bash HelloWorld.sh  #通过bash执行</span>\n或\n<span class=\"strong\">/bin/sh HelloWorld.sh #通过sh执行</span></div>\n\n#### 全局执行脚本方式\n执行脚本一般需要在赋予脚本执行权限后，使用绝对路径调用，或者进入脚本所在目录，使用相对路径调用。那些全局可用的脚本和命令，Linux是根据PATH环境变量中所存储的脚本路径自动寻找执行实现的，可通过<span class=\"strong\">echo $PATH</span>查看当前所配置的全局路径，手动安装的服务想实现全局执行脚本，有两种实现方法：\n+ <span class=\"strong\">将脚本通过cp命令复制到PATH中的某个路径下，如:/usr/bin下</span>\n+ <span class=\"strong\">通过变量叠加的方式，将脚本路径添加到PATH变量中，格式为PATH=\"$PATH\":路径</span>\n\n通过变量叠加的方式添加的全局变量，在系统重启后将失效，永久生效方法是将路径添加到<span class=\"tips\">/etc/profile</span>文件的PATH变量后\n<div class=\"show\">如Nginx的启动脚本在/usr/local/nginx/sbin路径下，非全局启动方法为：\n1.相对路径： 在 /usr/local/nginx/sbin 目录下执行./nginx \n2. 绝对路径：执行 /usr/local/nginx/sbin/nginx\n添加到全局的方法为：\n执行PATH=\"$PATH\":/usr/local/nginx/sbin\n使调用命令永久生效的方法：在 /etc/profile 中最后一行添加\nPATH=$PATH:/usr/local/nginx/sbin\n</div>\n\n#### 注释\nshell程序使用<span class=\"tips\">#</span>开头作为注释，多行注释需要在每一行开头都添加#号，注意程序第一行的脚本声明并不是注释符\n<div class=\"show\">#!/bin/bash\n#author: shiwivi\n#version: v0.1.0\n#data: 2023-09-01</div>\n\n对于需要多行注释的内容，可以将其写入花括号中定义成一个函数，然后不调用即可\n\n#### 脚本格式转换\n在Linux中，回车符识别为<span class=\"tips\"><strong>`$`</strong></span>，而在windows中回车符为^M$，因此在windows中编写的sh脚本需要经过转换，才能在Linux中运行，转换命令为：\n<span class=\"strong\">dos2unix 文件名</span>\n相反，将文件从Linux格式转为Windows格式为\n<span class=\"strong\">unix2dos 文件名</span>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n该功能需要自行安装dos2unix软件，red hat系列操作系统安装命令为：yum -y install dos2unix</div>\n\n#### 脚本退出状态码\nshell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕，这个状态码可以使用<span class=\"strong\">$?</span>查看。同样，我们的脚本也可以使用退出状态码优雅地结束脚本执行，并返回脚本执行的状态。\n\n退出状态码是一个0～255的整数值，默认情况下，命令成功执行时退出状态码是0，如果命令执行错误，则退出状态码就是一个正整数值。在脚本中，可通过<span class=\"strong\">exit 状态码</span>命令指定脚本结束时的退出状态码，<span class=\"tips\">注意！exit命令会退出脚本，exit命令之后的任何代码都将不再执行</span>。状态码应当设置在0-255区间内，否则会对其进行求模运算，如：指定状态码为300，则进行300%256运算，最后取值44，设置状态码时也可以使用变量\n\n<div class=\"show\">#!/bin/bash \necho \"Hello world\"\n<span class=\"text-blue\">exit 0</span>\n</div>\n\nLinux中命令执行错误时的退出状态码无标准可循，但有一些可用参考：\n\n<div class=\"table\">\n\n状态码|描述\n------|------\n0     |命令成功执行\n1     |一般性未知错误\n2     |不适合的shell命令\n126   |命令不可执行\n127   |没找到命令\n128   |无效的退出参数\n128+x |与Linux信号相关的严重错误\n130   |通过Ctrl C终止的命令\n255   |正常范围之外的退出状态码\n</div>\n\n<div class=\"show\">上述的状态码有一些常见的情况：\n状态码126表明用户没有权限执行该命令，即Permission denied\n状态码1表明命令发生了未知错误，如：为命令提供了无效参数\n</div>\n\n### shell中的运算\n#### 各种括号使用预览\n+ ()用来创建子shell执行命令组，而$()则可以用来获取命令的输出，并将其赋值给变量，其作用和 ``命令调用一致，如：today=$(date \"+%D\")。如果( )中指定了多个命令，则变量获取的是最后一个命令的输出\n+ [ ]用来进行条件判断，它是test命令的替代，可以结合if-then等条件判断语句进行数值比较、字符串比较、文件比较\n+ $(())和$[]用来进行整形数值运算，如：num=$[11+22]\n+ (())可以用来运算高级数学表达式，如：++、&gt;&gt;(右移位)、&&(逻辑与)等运算，也可以搭配if-then语句进行条件判断\n+ 双方括号[[]]命令用来进行高级字符串比较，允许使用*和?通配符，支持模式匹配，但部分shell可能不支持\n+ 大括号{ }用来进行变量引用，支持字符串拼接\n\n#### $()与``命令调用\nshell中最有用的特性之一是可以将命令的输出赋值给变量，然后通过变量来任意调用，有两种方法可以将命令输出赋值给变量：\n+ 通过<span class=\"strong\">反引号``</span>\n+ 通过<span class=\"strong\">$( )</span>\n\n<div class=\"show\">e.g.每天使用当前日期为文件名创建一个文件，并将bin目录信息写入其中\ntoday=`date`\n或\ntoday=$(date \"+%D\")\nls /usr/bin -al &gt; log.$today\n</div>\n\n#### $(())与$[]整数运算\n+ <span class=\"strong\">变量名=$((运算式))</span>\n+ <span class=\"strong\">变量名=$[运算式]</span>\n\n$[]是一种旧的Bash算术扩展方式，现代Shell更推荐使用$(())进行算术运算\n\n<div class=\"shell\">示例：\n[root@localhost ~]# num1=$((11+22))\n[root@localhost ~]# num2=$[11+22]\n</div>\n\n#### expr表达式\nexpr是由Bourne shell提供的数学工具，bash shell为了保持跟Bourne shell的兼容而包含了expr命令。尽管现代脚本中大部分功能被更强大的 $(()) 算术求值或 ${} 字符串操作所取代，但 expr 在经典UNIX和早期shell脚本中仍然非常重要，expr表达式支持以下功能：\n+ 整数运算：加减乘除、取模运算等\n+ 字符串操作：获取字符串长度、子串提取、模式匹配等\n+ 条件判断：执行条件判断并返回 0 或 1 表示真假\n\nexpr通常搭配<span class=\"tips\">``</span>和<span class=\"tips\">$()</span>来获取expr表达式最后的计算值：\n<div class=\"show\"> num=<span class=\"strong\">`expr 2 + 2`</span>\n注意表达式和运算符之间要有空格，即+号前后都要有一个空格，正确形式为2 + 2，省略空格2+2会被解析为一个字符串，而不是数值运算</div>\n\n<div class=\"shell\">示例:\n[root@localhost ~]# a=11\n[root@localhost ~]# b=22\n[root@localhost ~]# num1=$a+$b  //字符串运算\n[root@localhost ~]# echo $num1  //输出11+22\n[root@localhost ~]# num2=$(expr $a + $b)  //数值运算\n[root@localhost ~]# echo $num2  //输出33\n</div>\n\nexpr命令能够识别以下数学和字符串操作符，特殊字符的转义 expr 中的某些字符，如 *, &, <, >, | 等，在 shell 中具有特殊含义，需要用反斜杠 \\ 进行转义处理\n<div class=\"table\">\n\n操作符 | 描述\n-------|-------\nARG1 + ARG2 |返回ARG1和ARG2的算术运算和\nARG1 - ARG2 |返回ARG1和ARG2的算术运算差\nARG1 \\\\* ARG2 |返回ARG1和ARG2的算术乘积，需要将*号转义\nARG1 / ARG2 |返回ARG1被ARG2除的算术商\nARG1 % ARG2 |返回ARG1被ARG2除的算术余数\nARG1 \\\\< ARG2 |如果ARG1小于ARG2，返回1；否则返回0\nARG1 <= ARG2 |如果ARG1小于或等于ARG2，返回1；否则返回0\nARG1 = ARG2 |如果ARG1等于ARG2，返回1；否则返回0\nARG1 != ARG2 |如果ARG1不等于ARG2，返回1；否则返回0\nARG1 >= ARG2| 如果ARG1大于或等于ARG2，返回1；否则返回0\nARG1 \\\\> ARG2 |如果ARG1大于ARG2，返回1；否则返回0\nA\nARG1 \\\\&#124; ARG2 |如果ARG1既不是null也不是零值，返回ARG1；否则返回ARG2\nARG1 \\\\& ARG2 |如果没有参数是null或零值，返回ARG1；否则返回0\nSTRING : REGEXP |如果REGEXP匹配到了STRING中的某个模式，返回匹配的子字符串或长度\nmatch STRING REGEXP |如果REGEXP匹配到了STRING中的某个模式，返回该模式匹配\nsubstr STRING POS LENGTH |返回起始位置为POS（从1开始计数）、长度为LENGTH个字符的子字符串\nindex STRING CHARS |返回在STRING中找到CHARS字符串的位置；否则，返回0\nlength STRING |返回字符串STRING的数值长度\n`+` TOKEN |将TOKEN解释成字符串，即使是个关键字\n(EXPRESSION) |返回EXPRESSION的值\n</div>\n\n<div class=\"show\">1. 数值运算\nexpr 3 \\* 4  #输出12\n2. 获取字符串长度\nexpr length \"hello\"  # 输出：5\n3. 截取子字符串(substr)\nexpr substr \"hello world\" 1 5  # 输出：hello\n4. 查找字符位置(index)\nexpr index \"hello world\" \"o\"  # 输出：5\n5. 字符串模式匹配(返回匹配的子字符串或长度)\nexpr \"abc123\" : 'abc[0-9]*'  # 输出：6\n6. 大于、小于判断\nexpr 4 \\> 3  # 输出：1 （表示 true）\nexpr 4 \\< 5  # 输出：1 （表示 true）\n7. 逻辑与和或运算\nexpr 0 \\| 1 # 输出：1\nexpr 0 \\& 1 # 输出：0\n</div>\n\n### 变量\n#### shell中的变量类型\nshell程序的变量可以分为以下几种：\n+ 自定义变量，即程序员自定义的变量\n+ 预定义变量：bash预定义的变量\n+ 环境变量：由操作系统或用户设置的特殊变量，用于保存操作系统环境相关的数据，以及配置 Shell 的行为和执行环境\n+ 位置参数变量：用于向脚本中传递参数和数据，变量名不能自定义\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n可以通过 <strong>set</strong> 命令查看所有变量，包括系统预定义的变量</div>\n\n#### 自定义变量\n+ 变量名规则同C语言，允许由字母、数字、下划线组成，但不能以数字开头\n+ bash中变量默认类型都为字符串类型\n+ 变量赋值时，若值包含空格，则需要使用单引号或双引号包裹\n+ 变量值中可以使用\\进行转义\n+ 变量名通常使用下划线分隔单词，如：user_name,server_ip\n+ 自定义的环境变量名、常量的变量名一般使用大写，如：readonly MAX_VLAUE=10\n\n\n##### 变量定义、赋值、调用\n定义自定义变量不需要int、var等关键字，可以直接使用<span class=\"tips\">变量名=值</span>形式定义并赋值，默认情况下，变量通常被视为字符串。对于定义过的变量，可以使用<span class=\"tips\">${变量名}</span>调用，花括号用于识别变量边界，可以不加，但加上花括号是个好的编程习惯\n\n<div class=\"show\">1. 赋值时等号两侧避免使用空格\nname=\"Ken\"\n2. 除了显式地直接赋值，还可以用语句给变量赋值\nfor file in `ls /etc`\n3. 可以用$调用变量，使用花括号可以识别变量边界，如果有花括号，则以下变量会被识别为$nameChou\necho \"my name is ${name}Chou\"\n4. 变量可以重新定义，即重新赋值，重新赋值不需要使用$\nname=\"new\"\n</div>\n\n##### 只读变量\n使用<span class=\"tips\">readonly</span> 命令可以将变量定义为只读变量，只读变量的值不能被改变，且只读变量不能使用unset删除\n<div class=\"show\">myName=\"Ken\"\nreadonly myName\nmyName=\"New\" #执行脚本会报错myName：This variable is read only\n</div>\n\n##### 删除变量\n可以通过<span class=\"strong\">unset 变量名</span>命令删除变量，但无法删除只读变量\n<div class=\"show\">myName=\"Ken\"\nunset myName\necho $myName  #无任何输出</div>\n\n#### 变量值检测与替换\n\n类似于C语言三元表达式的一种功能，即检测变量y是否存在，或者其值是否为空/非空，然后根据y的状态赋予变量x不同值\n\n\n<div class=\"table\">\n<table>\n<thead><tr>\n   <th>语句</th>\n   <th>未定义变量y</th>\n   <th>变量y为空</th>\n   <th>变量y非空</th>\n   <th>说明</th>\n</tr></thead>\n<tbody>\n<tr>\n   <td>x=${y:-默认值}</td>\n   <td>x=默认值</td>\n   <td>x=默认值</td>\n   <td>x=$y</td>\n   <td>如果变量y未定义或为空，则x使用指定的默认值</td>\n</tr>\n<tr>\n   <td>x=${y:=默认值}</td>\n   <td>x=y=默认值</td>\n   <td>x=y=默认值</td>\n   <td>x=$y,y值不变</td>\n   <td>如果变量y未定义或为空，则赋予y默认值，且x也使用默认值</td>\n</tr>\n<tr>\n   <td>x=${y:+替代值}</td>\n   <td>x为空</td>\n   <td>x为空</td>\n   <td>x=替代值</td>\n   <td>如果变量y已定义且非空，则x使用替代值</td>\n</tr>\n<tr>\n   <td>x=${y:?错误消息}</td>\n   <td>输出消息到标准错误输出</td>\n   <td>输出消息到标准错误输出</td>\n   <td>x=$y</td>\n   <td>如果变量y未定义或为空，输出错误信息并退出</td>\n</tr>\n<tr><td colspan=\"5\"><span class=\"text-red\">不带<span class=\"text-blue\">:</span>的语法不检查变量是否为空值，只检查变量是否未定义(即使y为空也视为有效)</span></td></tr>\n<tr>\n   <td>x=${y-默认值} </td>\n   <td>x=默认值 </td>\n   <td>x=$y(空)</td>\n   <td>x=$y</td>\n   <td>如果y未定义，则x使用默认值</td>\n</tr>\n<tr>\n   <td>x=${y=默认值} </td>\n   <td>x=y=默认值</td>\n   <td>x=$y(空)</td>\n   <td>x=$y,y值不变</td>\n   <td>如果变量y未定义，则x和y都赋值为默认值</td>\n</tr>\n<tr>\n   <td>x=${y+替代值}</td>\n   <td>x为空</td>\n   <td>x=替代值</td>\n   <td>x=替代值</td>\n   <td>如果变量y已定义(即使为空)，则x使用替代值</td>\n</tr>\n<tr>\n   <td>x=${y?错误消息}</td>\n   <td>输出消息到标准错误输出</td>\n   <td>x=$y(空)</td>\n   <td>x=$y</td>\n   <td>如果变量y未定义，则输出错误消息并退出</td>\n</tr></tbody>\n</table>\n</div>\n\n<div class=\"show\">1. 如果变量filePath未定义或路径为空，则使用默认的路径\nfilePath=${filePath:-/usr/local/etc/myfile}\n2. 当变量port未定义或为空时，为newPort赋值为2000，且port也赋值为2000(虽然2000依旧会被解析为字符串而不是数值)\nnewPort=${port:=2000}\n</div>\n\n\n### 字符串\nshell中的字符串可以使用单引号声明，也可以使用双引号声明，二者的特性：\n+ 单引号里的字符会原样输出，无法使用转义字符和变量，双引号里字符串的可以使用转义字符、引用变量\n+ 二者都可以用于字符串拼接\n\n#### 字符串拼接\n可以直接在字符串前后使用<span class=\"tips\">${变量名}</span>拼接字符串，不需要像其他语言一样添加+号等字符串拼接符\n<div class=\"show\">text=\"1234\"\nstr1=\"aaa\"${text}\"bbb\"  #可以直接将多个字符串拼接在一起，并拼接变量，输出aaa1234bbb\nstr2=\"aaa${text}bbb\"    #可以直接在字符串中引用变量，输出aaa1234bbb\nstr3='aaa'${text}'bbb'  #单引号也可以拼接字符串，输出aaa1234bbb\nstr4='aaa${text}bbb'    #但不能在单引号声明的字符串中引用变量，会原样输出aaa${text}bbb\necho str1 str2 str3 str4</div>\n\n#### 获取字符串长度\n可以使用<span class=\"tips\">${{'{#'}}字符串变量名}</span>来获取字符串长度\n<div class=\"show\">str=\"abcd\necho ${{'{#'}}str}  #当变量为字符串时，${{'{#'}}str} 等价于 ${{'{#'}}str[0]}</div>\n\n#### 截取字符串\n使用<span class=\"tips\">${字符串变量名:索引1:索引2}</span>来截取从索引1到索引2的字符串，字符串索引从0开始\n<div class=\"show\">str=\"He said, one day you will leave this world behind.\"\necho ${str:1:5} #输出e sai\n</div>\n\n#### 查找子字符串\n<div class=\"show\">查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)\nstr=\"He said, one day you will leave this world behind.\"\necho `expr index \"${str}\" io`</div>\n\n### 数组\n#### 数组定义\nbash只支持一维数组，不支持多维数组，bash中的一维数组不限制数组大小，使用括号囊括数组元素，数组元素之间使用空格分隔：<span class=\"strong\">数组名=(值1 值2 值3)</span>\n\n<div class=\"show\">1. 数组支持整体赋值\narray1=(10 20 30)\n2.数组元素间可以使用空格，也可以用换行符\narray1=(10\n20\n30)\n3.也支持数组元素单独赋值\narray1[0]=10\narray1[1]=20\narray1[2]=30\n4. 数组元素默认都被声明为字符串类型，因此以下语句也正确\narray1=(100 \"Hello\" abc)</div>\n\n#### 数组元素\nbash中数组使用<span class=\"tips\">${数组名[下标]}</span>表示数组元素，与绝大多数语言一样，数组下标从0开始，可以用<span class=\"tips\">${数组名[@]}</span>或<span class=\"tips\">${数组名[*]}</span>表示数组中的所有元素\n<div class=\"show\">echo ${array1[1]} #输出20\necho ${array1[@]} #输出10 20 30\necho ${array1[*]} #输出10 20 30</div>\n\n#### 数组长度\n获取数组长度的方法与获取字符串长度的方法类似，即在需要获取的对象前加上<span class=\"tips\">#</span>号，该方法可以获得整个数组的长度，也可以用于获取单个数组元素的长度\n<div class=\"show\">1. 获取数组长度\necho ${{'{#'}}array1[@]}\n或\necho ${{'{#'}}array1[*]}\n2. 获取单个数组元素的长度\necho ${{'{#'}}array1[1]}\n3. 注意${{'{#'}}array1}返回的是数组第一个元素的长度(数组名代表数组首元素的起始地址)\narray1=(12345 \"Hello\" abcd)\necho ${{'{#'}}array1} #输出字符串12345的长度5\n</div>\n\n#### 关联数组\nBash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素，关联数组的键是唯一的\n关联数组使用 declare 命令来声明，语法格式为：\n<span class=\"strong\">declare -A 数组名</span>\n数组元素访问方式为：<span class=\"tips\">${数组名[\"键名\"]}</span>，通过<span class=\"tips\">${数组名[@]}</span>或<span class=\"tips\">${数组名[*]}</span>可以获取所有元素，在此基础上，在数组名前加上<span class=\"tips\">!</span>可以获取数组所有键，在数组名前加上<span class=\"tips\">#</span>可以获取数组长度\n\n<div class=\"show\">1.关联数组可以在定义同时赋值\ndeclare -A singer=([\"周杰伦\"]=\"手写的从前\" [\"陈奕迅\"]=\"十年\" [\"林俊杰\"]=\"江南\")\n也可以先声明，再赋值\ndeclare -A singer\nsinger[\"周杰伦\"]=\"手写的从前\"\nsinger[\"陈奕迅\"]=\"十年\" \nsinger[\"林俊杰\"]=\"江南\"\n2. 数组元素、键访问方式\necho ${singer[\"周杰伦\"]}         #访问单个元素\necho \"数组的元素有\" ${singer[*]}#访问所有元素\necho \"数组的键有\" ${!singer[*]}  #访问所有键\necho \"数组的元素有\" ${{'{#'}}singer[*]}#访问数组长度\n</div>\n\n### 位置变量与参数传递\n#### 给脚本传递参数\n在使用命令执行脚本时，可以向脚本中传递参数，在脚本中可以使用一些预定义变量获取到这些参数\n\n<div class=\"table\">\n   \n   变量|作用\n   ---|---\n   $n |n为数字，$0代表命令本身(包含文件路径)，$1-$9代表命令第1-9个参数，10以上用{}包裹，如:${10}\n   $* |代表命令行所有参数，$*将命令行所有参数作为一个整体进行处理，在遍历时循环只执行一次\n   $@ |代表命令行所有参数，$@会将参数依次拆开\n   $# |代表传递到脚本的参数总个数\n   $? |返回上一个命令的执行状态，如果返回0则说明执行正确，返回值非0则说明上一个命令执行不正确，用于检测上一个命令是否正确执行，方便后续处理\n   $$ |脚本运行当前进程的进程号(PID)\n   $! |后台运行最后一个进程的进程号(PID)\n   $- |显示shell所使用的当前设置(如：是否使用监视模式，是否只读取指令，而不实际执行)，与set命令功能相同\n</div>\n\n<div class=\"show\">定义一个test.sh脚本\n<code>#! /bin/bash\necho $1   #输出10\necho $*   #将参数 10 20作为一个整体输出\necho $@   #将参数依次处理为10和20两个参数输出\necho $#   #输出参数个数</code>\n执行该脚本并传参\nchmod 755 test.sh\n./test.sh 10 20\n</div>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n在使用$1、$2..调用参数之前，应当使用-n等命令测试用户是否传递了参数，如果直接调用了参数，而用户忘记传参，则脚本可能出现严重错误，示例：<div class=\"apiBox\">if [ -n \"$1\" ]\nthen\n   #正常执行功能\nelse\n   echo \"请输入参数\"\nfi</div></div>\n\n\n<div class=\"show\">$*和$@的区别\n<code>for i in \"$*\";do\n   echo $i\ndone\nfor i in \"$@\";do\n   echo $i\ndone</code>\n执行 ./test.sh 1 2 3\n第一个语句相当于传递了1个参数，输出1 2 3\n第二个语句相当于传递了3个参数，输出\n1\n2\n3\n</div>\n\n##### $0参数的使用\n$0参数用于获取shell在命令行启动的脚本名，如果调用脚本时包含了路径，该参数会获取完整的脚本路径\n<div class=\"show\">执行命令./test.sh\n则 $0=./test.sh\n执行命令 bash /home/myshell/test.sh\n则 $0=/home/myshell/test.sh\n</div>\n\n如果不想获取文件路径，而只需要脚本名，则可以结合<span class=\"tips\">basename</span>命令来剥离脚本名\n<div class=\"show\">name=$(basename $0)\necho $name\n# 执行命令 /home/myshell/test.sh\n输出值为test.sh\n</div>\n\n基于该方法，可以写一个脚本，当用户输入不同的命令(不同脚本名)，实现不同功能，但它们本质上是同一个脚本\n<div class=\"show\">e.g.执行addem 10 20命令返回10+20，执行multem 10 20返回10*20\n#!/bin/bash \nname=$(basename $0) \nif [ $name = \"addem\" ] \nthen \n total=$[ $1 + $2 ] \nelif [ $name = \"multem\" ] \nthen \n total=$[ $1 * $2 ] \nfi \necho \necho 最后计算结果为： $total\n# 将该文件命名为addem，然后执行ln -s addem multem为该文件创建一个软链接，执行任何一个脚本名都会执行同一个脚本，脚本随后根据$0参数识别对应的命令\n</div>\n\n#### 移动参数shift\nbash shell的<span class=\"strong\">shift</span>命令能够用来操作命令行参数，在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也就是程序名，不会改变）\n\n在不知道到底有多少参数时，可以先处理$1参数，然后用该命令依次移动参数，然后继续操作第一个参数，由此实现了对参数的遍历。但注意，如果某个参数被移出，它的值就被丢弃了，无法再恢复。shift也支持一次移动多个数据，只需要指定一个参数即可：<span class=\"strong\">shift 参数</span>，因此，shift也常用来跳过不需要的参数\n\n<div class=\"show\">#!/bin/bash \necho \"The original parameters: $*\" \nshift 2 \necho \"Here's the new first parameter: $1\"\n</div>\n\n### 脚本选项\n除了参数，绝大部分命令还会带有选项，如：ls -alh中的alh，同样，编写的shell脚本如果需要选项来加持命令的功能，则需要在脚本中对选项进行处理\n\n#### 选项与参数分割符\n在Linux中，有些命令同时包含了参数和选项，为了方便将二者区分开来，Linux使用一个特殊标记符：双短线<span class=\"tips strong\">-&zwnj;-</span>表示选项列表结束，参数列表开始。该符号可以用于提醒命令和脚本，-&zwnj;-符号后的都为命令(脚本)参数，该符号主要有两个使用场景：\n\n+ 选项输入结束，参数输入开始。如：test -a -b -c -&zwnj;- value1 data2;使用-&zwnj;-可以很清晰的划分出命令选项和参数的界限\n+ 如果参数中包含-号，可能会被解析为选项，此时使用-&zwnj;-分割可以防止参数被解析错误。如：创建名为-rTest的文件，如果使用touch -rTest会将-r解析为选项，因而返回错误，而执行 touch -&zwnj;- -rTest可成功创建该文件\n\n\n\n#### 简单选项处理\n表面上看，命令行选项紧跟在脚本名之后，就跟命令行参数一样。因此对于简单的选项，可以像处理命令行参数一样处理命令行选项\n<div class=\"show\">#!/bin/bash \nwhile [ -n \"$1\" ] \ndo \n case \"$1\" in \n -a) echo #添加-a的脚本功能 ;; \n -b) echo #添加-b的脚本功能 ;; \n -c) echo #添加-c的脚本功能;; \n *) echo \"无 ${1} 该选项\" ;; \n esac \n shift #移动参数，依次处理\ndone</div>\n\n如果选项中同时含有选项和参数，可以使用-&zwnj;-符号分隔\n<div class=\"show\">该方法适合类似./test.sh -c -a -b -- data1 data2 选项和参数分开的情况\n#!/bin/bash \n# extracting options and parameters \necho \nwhile [ -n \"$1\" ] \ndo \n case \"$1\" in \n -a) echo 这是一个选项;; \n -b) echo 这是一个选项;; \n -c) echo 这是一个选项;; \n --) shift \n break ;; #选项结束，退出循环\n *) echo \"$1 is not an option\";; \n esac \n shift \ndone \n# \ncount=1 \nfor param in $@ \ndo \n echo \"Parameter #$count: $param\" \n count=$[ $count + 1 ] \ndone\n</div>\n\n当选项和参数混合时，需要对选项做进一步处理\n<div class=\"show\"> 处理./testing.sh -a data1 -b -c -d data2此类参数和选项混合的情况\nwhile [ -n \"$1\" ] \ndo \n case \"$1\" in \n -a) echo \"Found the -a option\";; \n -b) param=\"$2\" \n echo \"Found the -b option, with parameter value $param\" \n shift ;; \n -c) echo \"Found the -c option\";; \n --) shift \n break ;; \n *) echo \"$1 is not an option\";; \n esac \n shift \ndone \n# \ncount=1 \nfor param in \"$@\" \ndo \n echo \"Parameter #$count: $param\" \n count=$[ $count + 1 ] \ndone\n</div>\n\n#### getopt与getopts命令\n上述方法不太方便处理选项合并输入等情况(如：-alh)，事实上Linux提供了专门用于处理选项输入的命令——getopt，而bash也提供了更高级的内建命令——getopts\n\n##### getopt命令\ngetopt命令用于解析命令行参数和选项，其命令格式为\n\n<span class=\"strong\">getopt [选项] 解析的选项 需要解析的参数表列</span>\n\ngetopt命令的选项有：\n+ -o 单个字符：指定命令短选项的字符串(如：-v)，表示脚本支持的短选项(单个字符选项)\n+ -&zwnj;-long 字符串1,字符串2...：指定命令长选项的字符串(如：-&zwnj;-version)，表示脚本支持的长选项(多字符选项)\n+ -n 替代字符串：指定一个名字来代替默认命令名称\"getopt\"\n+ -q：不生成错误信息(用户输入了指定选项之外的字符时)\n+ -s chars：指定分隔选项参数的字符集，通常用于指定选项和其参数之间的分隔符，默认是空格。\n+ -l：输出选项的字符串表示形式。\n+ -options：将选项和非选项分开，选项在参数列表的前面，非选项在参数列表的后面\n\n指定命令解析的选项指该命令有效的选项字母，并指定选项需不需要参数值，如果需要则在选项后加上<span class=\"tips\">:</span>号，随后getopt命令会根据指定的选项，解析getopt命令最后跟随的参数\n\n<div class=\"show\">e.g.该命令的用法解析\n<code>getopt ab:cd  -a -b test1 -cde test2 test3</code>\n该命令中，getopt命令定义了四个有效选项字母：a、b、c和d。字母b后有一个冒号(:)，表示b选项需要一个参数值。当getopt命令运行时，它会检查提供的参数列表（-a -b test1 -cde test2 test3），并基于提供的optstring进行解析。注意，它会自动将-cde选项分成三个单独的选项，并插入双破折线(--)来分隔行中的选项和参数，因此，输入的参数会被解析为以下形式：\n -a -b 'test1' -c -d -e -- 'test2' 'test3'\n但由于getopt命令只指定了abcd四个有效选项，而用户输入了选项e，因此默认情况下，getopt命令会产生一条错误消息：\ngetopt: invalid option -- e\n此时，可以添加为getopt命令添加-q选项来忽略错误消息：\n getopt -q ab:cd -a -b test1 -cde test2 test3\n</div>\n\n\nshell脚本中使用getopt命令，可以搭配set命令使用，set命令可以将其接收的参数按空格分割，并赋值给位置参数，可以将getopt解析出来的值作为set命令的输入参数，此后就可以使用$位置值的方式调用getopt命令解析出来的值\n\n<div class=\"show\">e.g.写一个名为testGetopt.sh脚本，脚本需要支持输入选项：-a选项和-b选项(完整选项名为-aaa和-bbb)，这两个选项需要提供一个参数，选项-c、-ccc、-d不需要提供参数，可以提供任意数量的参数在脚本中调用\n分析：\n a:b:cd -&zwnj;-long aaa:,bbb:,ccc为解析的选项\n $@为用户输入到该脚本中的参数，也是getopt命令需要解析的参数表列\n 通过-&zwnj;-分隔getopt命令的选项和参数部分，更为清晰\n 如果用户执行: bash getoptPra.sh -a 100 -b 200 -cd --ccc lua ajax\n 则该命令被getopt命令解析后，$args的值为：\n -a '100' -b '200' -c -d --ccc -- 'lua' 'ajax'\n getopt命令帮我们分割好了选项和参数，此时将该串字符串作为set命令的参数输入，set命令会以空格为分隔符，将该串字符串分割并依次存储在$1、$2、$3等位置变量中，方便后续依次判断和调用\n通过case命令和shift命令依次为各选项写功能，选项处理完毕，最后的剩余的参数另作处理\n执行\n</div>\n<pre><code>#! /bin/bash\n# 对用户输入的选项和参数进行处理\n  args=$(getopt -o a:b:cd --long aaa:,bbb:,ccc -- $@)\n  if [ $? -ne 0 ] \n     then\n\t     echo\"解析错误\"\n        exit 1 \n  fi\n# 查看getopt命令解析出来的选项和参数\n echo \"---------\"\n echo $args\n echo \"---------\"\n set -- $args\n# 遍历所有选项，给与不同的功能\n while true\n   do\n    case $1 in\n      -a|--aaa) echo \"输入了-a或-aaa选项,参数值为$2\" ; shift 2 ;;\n      -b|--bbb) echo \"输入了-b或-bbb选项,参数值为$2\" ; shift 2 ;;\n      -c) \t  echo \"输入了-c选项\" ; shift ;;\n      -d)\t  echo \"输入了-d选项\" ; shift ;;\n      --ccc)    echo \"输入了--ccc长选项\" ; shift; break ;;\n      --) \t  shift; break ;;\n    esac\n   done\n# 选项外的参数另作处理\n echo \"额外的输入参数有：$@\"\n</code></pre>\n\n##### getopts命令\ngetopts命令是bash shell的内建命令，为了弥补getopt命令的不足(如：不好处理带空格和引号的参数)，它提供了一些高级功能。\n\ngetopts命令与getopt命令不同，每次调用getopts命令，它只处理命令行上检测到的一个参数，因此往往需要循环调用，处理完所有的参数后，它会退出并返回一个大于0的退出状态码。getopts命令的格式与getopt命令相似：\n<div class=\"apiBox\">getopts 解析的选项 变量</div>\n\n同样，解析选项中可以指定命令需要识别的有效字母选项，如果该选项需要参数，就加一个冒号。如果需要getopts命令忽略错误信息，可以在整个解析选项字符串前加个冒号，相当于getopt命令的-q选项。getopts命令会将输入的参数表列保存在指定的变量中，方便遍历。\n\n<div class=\"show\">e.g.脚本支持选项abc，其中-b选项需要跟随一个参数。\ngetopts :ab:c opt\n# ab:c前的:表示让getopts命令忽略错误(如：用户输入abc以外的选项)\n</div>\n\ngetopts命令还预定义了两个环境变量：如果选项需要跟随一个参数值，<span class=\"tips\">OPTARG</span>环境变量会保存该值，而变量<span class=\"tips\">OPTIND</span>变量保存了参数列表中getopts正在处理的参数位置。\n\ngetopts命令有以下特点：\n+ 该命令不直接支持长选项，但处理单字母选项很方便\n+ 解析命令行选项时该命令会移除开头的单破折线，所以在case定义中不用单破折线\n+ 该命令支持在参数值中包含空格，只需要将带空格的参数值用双引号包裹即可\n+ 可以将选项字母和参数值放在一起使用，而不用加空格，如：-abvalue，命令可以根据case定义的字符正确解析出-a和-b选项，以及value参数值\n\n<div class=\"show\">e.g.脚本需要支持-a、-b、-c命令，选项ab需要输入参数\n#!/bin/bash\nwhile getopts \":a:b:c\" opt; do\n    case $opt in\n        a) echo \"输入了选项-a，其参数值为$OPTARG\" ;;\n        b) echo \"输入了选项-b\" ;;\n        c) echo \"输入了选项-c\" ;;\n        *) echo \"未定义的选项\" ;;\n    esac\ndone\n#使用shift命令和OPTIND变量处理剩余的参数\nshift $[ $OPTIND - 1 ]\necho \"剩余的参数：\"\nfor param in $@\n do\n    echo $param\ndone\n</div>\n\n#### 选项标准化\n部分选项在Linux中有一些墨守成规的用途，遵守这些规定会让脚本看起来更友好一些\n\n<div class=\"table\">\n\n选项|说明|选项|说明\n----|-----|----|-----\n-a |显示所有对象|-n |使用非交互模式（批处理）\n-c |生成一个计数|-o |将所有输出重定向到的指定的输出文件\n-d |指定一个目录|-q |以安静模式运行\n-e |扩展一个对象|-r |递归地处理目录和文件\n-f |指定读入数据的文件|-s |以安静模式运行\n-h |显示命令的帮助信息|-v |生成详细输出\n-i |忽略文本大小写|-x |排除某个对象\n-l |产生输出的长格式版本|-y |对所有问题回答yes\n</div>\n\n### 数值声明与数值运算\n\n默认情况下，Bash中的变量会被声明为字符串类型，如：num=22，Bash会将22作为字符串处理，诸如11+22的式子也会被识别为字符串，想要进行数值运算，需要使用特殊声明语句和运算方式\n#### 数值声明\n该语句用于特殊声明变量类型，使变量不再只限于字符串类型\n<span class=\"strong\">declare [+或-] [选项] 变量名</span>\n\n+ -&emsp;给变量设置类型属性\n+ +&emsp;取消变量的类型属性\n+ -i&emsp;将变量声明为整形(integer)\n+ -x&emsp;将变量声明为环境变量\n+ -p&emsp;查看变量的类型\n\n<div class=\"show\">declare -i num1=11+22</div>\n\n#### 数值运算\n进行数值运算可以使用以下几种方式：\n##### 1.通过\"$(())\"或\"$[]\"运算式\n+ <span class=\"strong\">变量名=$((运算式))</span>\n+ <span class=\"strong\">变量名=$[运算式]</span>\n\n<div class=\"shell\">示例：\n[root@localhost ~]# num1=$((11+22))\n[root@localhost ~]# num2=$[11+22]\n</div>\n\n##### 2.通过declare -i声明\n<span class=\"strong\">declare -i 变量名</span>\n<div class=\"shell\">示例：\n[root@localhost ~]# declare -i num1=11+22\n</div>\n\n#### 浮点数运算的解决方案\nz shell提供了完整的浮点数运算操作，但在bash shell中，需要借助内建的bash运算器——<span class=\"strong\">bc</span>\n\n### 输入输出\n#### 用户输入read\n<span class=\"strong\">read [选项] [变量名]</span> 从键盘(默认)读取一行数据，然后将输入的数据分解成字段，并将字段分别赋值给这些变量\n\n+ -p \"提示信息\" &emsp;输出提示信息(prompt 提示)\n+ -t 秒数 &emsp;read命令只等待指定时间(timeout 超时)，如果超时未输入，read命令会以非零状态码退出\n+ -n 字符数&emsp;read命令只接收指定数量字符\n+ -s &emsp;隐藏输入的内容(silent 沉默)\n+ -i 文本&emsp;将指定文本作为默认输入值\n+ -a 数组名&emsp;将输入的数据赋值给数组变量\n+ -d 字符&emsp;指定一个定界符，当入户输入该字符时，read命令将停止读取输入(delimit 划定界限)\n+ -e&emsp;允许用户使用Readline功能，该功能允许用户使用快捷键进行快速操作(如快速跳转到本行开头)\n+ -r&emsp;禁用转义，\\不再会被解析为转义字符\n+ -u 文件描述符&emsp;从指定的文件描述符中读取，如标准输入设备的文件描述符为0\n+ -c&emsp;在读取输入时不需要按回车确认，即实时输入\n+ 如果在命令中不指定变量，则read读入的数据会保存在环境变量<span class=\"tips\">REPLY</span>中\n\n<div class=\"shell\">示例：\n#!/bin/bash\nread -t 30 -p \"input name:\" name    #30s内输入姓名并赋值给name\nread -s -t 30 -p \"input password:\" passwd    #30s内隐藏输入密码并赋值给passwd\n</div>\n\nread也支持一次输入多个数据，数据之间用空格隔开，然后赋值给多个变量。如果输入的数据个数多于变量个数，则多出来的数据连同空格会被赋值给最后一个变量。read命令也支持将多个数据直接存入数组中，如果数据间的分隔符是,或者其他符号，也可以通过<span class=\"tips\">IFS</span>变量修改分隔符(Linux中分隔符默认为空格、制表符、换行符)，方便从文件中读入数据并作处理\n<div class=\"show\">1. 可以一次读取多个数据\nread data1 data2 \n输入10 20 30，则data1=001，data2=20 30，空格会视为第一个数据输入完毕,多余数据赋值给最后一个变量\n2. 对于使用其他符号分隔的数据，可以重新定义分隔符\nread -p \"输入数据，以逗号隔开\" data\necho \"当前数据\" $data\nIFS=','  #修改IFS变量的值，将分隔符改为,号\nread -a data_array <<< $data\necho \"处理完的数组为：\" ${data_array[@]}\n3. read命令可以从文件中读取数据，每次调用read命令，都将从文件中读取一行文本，当文件中没有内容时，read命令会退出并返回非零状态码。读取文件时，可以借助cat命令和管道符\ncat test.txt | while read content\n do\n   echo $content #内容被保存到content变量中\ndone\n</div>\n\n#### 终端输出\n<span class=\"strong\">echo [选项] [输出内容]</span> 用于向终端输出文本信息\n\n+ -e&emsp;启用转义字符\\，可以输出如换行符(\\n)、制表符(\\t)等，也可以修改输出文字的样式\n+ -E&emsp;禁用转义字符，原样输出文本\n+ -n&emsp;不换行输出文本，输出完毕后光标停留在同一行\n\n<div class=\"show\">1. echo输出字符串文本时默认情况下可以不需要引号\necho Hello World\n2. 但如果字符串中有单引号/双引号，则字符串需要使用另外一种引号包裹(字符里有单引号，就用双引号包裹，反之亦然)\necho 'he said:\"One day you will leave..\"' #单引号用于划定字符串，不会输出显示\n3. echo也可以一次性输出多个变量，变量间用空格分隔\necho \"当前值为：\" $num1 $num2 #输出文本后输出变量num1和num2\n</div>\n\n\n\n### 输入输出重定向\n#### 文件描述符与标准输入输出设备\nLinux系统将每个对象当作文件处理，并使用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，bash shell保留了前三个文件描述符(0、1和2)作为标准输入、标准输出、标准错误输出的文件描述符，每个进程一次最多可以有九个文件描述符。\n\n<div class=\"table\">\n\n设备|Linux文件名|文件描述符|类型\n---|---        |----     |---\n键盘|/dev/stdin|  0     |标准输入\n显示器|/dev/stdout|1    |标准输出\n显示器|/dev/stderr|2    |标准错误输出\n</div>\n\n#### 输出重定向\n一般情况下，Linux输出信息时默认的输出位置为屏幕，可以用重定向符将命令的输出重定向到文件等地方，而不再显示到屏幕上。如果重定向位置为文件而该文件不存在，则会新建文件\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>类型</th><th>符号</th><th>作用</th></tr>\n</thead>\n<tbody>\n<tr><td rowspan=\"2\">标准输出重定向</td>\n<td>&gt;</td><td>以覆盖方式将正确命令返回内容输出到指定文件或设备中</td></tr>\n<tr><td>&gt;&gt;</td><td>以追加方式将正确命令返回内容输出到指定文件或设备中</td></tr>\n<tr><td rowspan=\"2\">标准错误输出重定向</td><td>2&gt;</td><td>以覆盖方式将错误命令返回内容输出到指定文件或设备中</td></tr>\n<tr><td>2&gt;&gt;</td><td>以追加方式将错误命令返回内容输出到指定文件或设备中</td></tr>\n      <tr>\n      <td rowspan=\"5\">同时输出正确和错误命令返回信息</td>\n      <td>&&gt;</td>\n      <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>&&gt;&gt;</td>\n         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>命令&&gt;文件 2&gt;&1</td>\n         <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>命令&&gt;&gt;文件 2&gt;&1</td>\n         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>命令&gt;&gt;文件1 2&gt;&gt;文件2</td>\n         <td>把正确命令返回信息追加到文件1中，错误命令返回信息追加到文件2中</td>\n      </tr>\n      <tr><td>在脚本中输出错误消息(输出到stderr)</td>\n      <td>&gt;&2</td>\n      <td>在脚本中自定义一个消息作为错误输出</td></tr>\n      <tr><td>批量重定向</td>\n      <td></td>\n      <td></td></tr>\n   </tbody>\n</table>\n</div>\n\n##### 1.标准输出与标准错误输出的重定向\n标准输出是指程序执行正确时，会向用户输出普通信息流(如：程序的执行结果、信息或数据等)。标准错误输出则用来显示错误信息，当程序遇到错误或异常时，它会将错误信息发送到标准错误输出流。默认情况下，标准输出和标准错误输出的输出位置都为屏幕，但可以使用重定向命令将程序的正确执行结果或错误执行结果输出到屏幕以外的地方。\n\n单独输出正确信息时，可以在重定向符中省略文件描述符1，但如果同时重定向了标准输出和标准错误输出，则需要加上文件描述符\n\n<div class=\"show\">1. 输出命令正确执行信息到文件中\neg:将/usr/bin目录文件信息保存到以log.日期为文件名的日志文件中，%y%m%d表示提取日期中两位数的年月日，如：log.240522\ntoday=$(date +%y%m%d)\nls /usr/bin -al <span class=\"text-red\">&gt; log.$today </span>\n2. 输出命令错误执行信息到文件中\ne.g.文件test不存在时\nls -al test.txt <span class=\"text-red\">2&gt; fail.log</span>\n3. 将正确信息和错误信息输出到不同文件时，需要明确添加文件描述符\nls -a test1 test2 <span class=\"text-red\"> 1&gt;success.log 2&gt;fail.log</span>\n4. 将正确信息和错误信息输出到同一文件\nls -a test1 test2 <span class=\"text-red\">&&gt; message.log </span>\n</div>\n\n##### 2.输出错误信息\n如果需要在脚本中输出错误信息，则可以将输出信息重定向到STDERR文件描述符，语法为：<span class=\"tips\">输出信息 &gt;&2</span>。在终端中输出语句时看起来和正常echo语句无区别，但对系统而言明确了这是一个错误输出信息\n\n<div class=\"show\">e.g.在脚本中输出一个错误消息\necho \"程序抛出一个异常\" <span class=\"text-red\"> &gt;&2</span>\n</div>\n\n#### 输入重定向(不常用)\n将文件等内容重定向到命令，下列命令省略了文件描述符0\n\n<div class=\"table\">\n\n类型|符号|作用\n----|-----|----\n输入重定向|&lt;|将文件或设备内容重定向到命令\n内联输入重定向|&lt;&lt;|在命令行中指定多个文本输入内容\n</div>\n\n如：使用wc命令统计文件中的字符\n\n<div class=\"show\"># wc < test\n统计输出test文件内容的行数、单词数、字节数</div>\n\n内联输入重定向(inline input redirection)用于从命令行输入多行数据。在使用时，必须指定一个文本用于标记输入数据的开始和结尾，因此准确的使用语法为：\n<div class=\"apiBox\">命令 &lt;&lt; 标记文本\n输入的数据\n...\n标记文本\n</div>\n<div class=\"show\">$ wc &lt;&lt; EOF  #指定标记文本，开始输入\n&gt; data1\n&gt; data2\n&gt; data3\n&gt; EOF #遇到标记文本，终止输入\n</div>\n\n#### 批量重定向\n当脚本中有大量信息需要重定向，如果为每个命令都进行一次重定向过于繁琐，此时可以搭配<span class=\"tips\">exec</span>命令指定shell将脚本执行期间的信息都重定向到某个位置。exec会替换当前shell的执行上下文环境，将标准输出输入和错误输出重定向到指定位置\n\n<div class=\"show\"><span class=\"strong\">重定向输出</span>\n1. 将所有的标准输出重定向后，依旧可以指定将某个语句输出到指定位置\ne.g.将所有命令执行正确的信息输出到文件out.txt，而将部分指定的错误消息输出到屏幕\nexec 1&gt;out.txt\necho \"正常输出到out.txt文件\"\necho \"将该错误输出显示到屏幕\" &gt;&2\n2. 也可以将标准输出、标准错误输出都完全重定向\nexec 1&gt;out.txt\nexec 2&gt;error.txt\necho \"输出到out.txt\"\necho \"输出到error.txt\" &gt;&2\nls -a test.txt  #若test文件存在，输出信息到out，若不存在，输出到error\n<span class=\"strong\">输入重定向</span>\n1. 将标准输入重定向到文件后，read等命令将从文件中读取数据\nexec 0&gt; test.txt\nwhile read data\ndo\n  echo $data\ndone\n</div>\n\n#### 同时输出到显示器和文件\nLinux提供了一个特殊命令<span class=\"tips\">tee</span>，用于将输出同时发送到标准输出(显示器)和文件，而不用重定向多次：\n\n<div class=\"apiBox\">tee [选项] 文件1 文件2...</div>\n\n+ 默认情况下，如果指定的文件不存在，则会新建该文件，如果文件存在，tee命令会覆盖原文件内容\n+ -a 将数据追加到文件中\n+ -i 忽略中断信号，例如通过 Ctrl+C 触发的信号\n\ntee命令会重定向STDIN输入的数据，并同时发往两处：STDOUT和tee命令指定的文件，因此可以搭配管道符使用。\n\n<div class=\"show\">e.g.将某个数据同时发送到屏幕和test文件\necho \"数据\" | tee test</div>\n\n#### 丢弃命令输出\n如果需要某个输出既不显示到屏幕上，也不保存到文件中，可以将其重定向到一个名为<span class=\"tips\">null</span>的特殊文件中。Linux中该文件的位于<span class=\"tips\">/dev/null</span>路径下，所有重定向到该文件中的数据都会被丢弃，该文件中无任何内容。因此也可以在输入重定向中将其作为输入文件，可以用来快速清空文件内容，将该文件变为空白文件，常用于日志文件中清除内容(也可以删除再创建)\n\n<div class=\"show\">1. 丢弃信息\nls -al test.txt &gt; /dev/null\nls -al test.txt 2&gt; /dev/null\n2.快速清空文件\ncat /dev/null &gt; test.txt\n</div>\n\n#### 自定义重定向\n在shell中最多可以有9个打开的文件描述符。除了标准输入0，标准输出1和标准错误输出2，其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们\n\n##### 创建文件描述符\n可以直接使用<span class=\"tips\">exec</span>命令直接给输入、输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件\n描述符分配给一个文件，这个重定向就会一直有效，直到其被重新分配。\n\n<div class=\"show\">e.g.分配一个文件描述符3，并重定向到test3文件\n#!/bin/bash\nexec 3&gt;&gt;test3 \necho \"正常输出到屏幕\" \necho \"将被追加到文件test3\" &gt;&3 \n</div>\n\n##### 恢复文件描述符的指向\n通过exec命令重定向的文件描述符会在整个脚本运行期间指向指定的位置，如果需要将其恢复到原来的指向位置，可以创建一个文件描述符作为一个缓存变量，并在代码功能执行完后将需要恢复的文件描述符重定向到新建的文件描述符\n\n<div class=\"show\">e.g.恢复标准输出的指向\n#!/bin/bash\n<span class=\"text-blue\">exec 3&gt;&1</span>\n<span class=\"text-blue\">exec 1&gt;out.txt</span>\necho \"输出内容到out.txt\"\n<span class=\"text-blue\">exec 1&gt;&3</span></div>\n\n<div class=\"show\">e.g.标准输入也类似\n#!/bin/bash \n<span class=\"text-red\">exec 6<&0 </span>\n<span class=\"text-red\">exec 0< testfile</span>\ncount=1 \nwhile read line \ndo \n echo \"Line #$count: $line\" \n count=$[ $count + 1 ] \ndone \n<span class=\"text-red\">exec 0<&6</span></div>\n\n##### 同时读写的文件描述符(了解)\nshell也支持打开单个文件描述符来作为输入和输出，即可以用同\n一个文件描述符对同一个文件进行读写。shell会维护一个内部指针，指明在文件中的当前位置，任何读或写都会从文件指针上次的位置开始，因此可能出现内容被错误读写的问题，不太好用\n<div class=\"show\">#!/bin/bash \nexec 3&lt;&gt; testfile \nread line &lt;&3 \necho \"Read: $line\" \necho \"This is a test line\" &gt;&3</div>\n\n##### 关闭文件描述符\nshell会在脚本退出时自动关闭文件描述符，若要手动关闭文件描述符，则需要将该文件描述符重定向到特殊符号<span class=\"tips\">&-</span>，文件描述符关闭后，如果输出数据shell将抛出错误\n\n<div class=\"show\">e.g.关闭文件描述符3\n#!/bin/bash \nexec 3&gt; test.txt\necho \"输出数据到test文件\" &gt;&3 \n<span class=\"text-red\">exec 3&gt;&-</span>\n</div>\n\n#### 列出打开的文件描述符\nlsof命令会列出整个Linux系统打开的所有文件描述符。由于该命令会向非系统管理员用户提供Linux系统的信息，因此在很多Linux发行版中隐藏了该命令。普通用户要想运行该命令，必须使用全路径来引用该命令：<span class=\"strong\">/usr/sbin/lsof</span>\n\n管理员用户可以直接使用：\n<div class=\"apiBox\">lsof [选项]</div>\n\n+ -p PID：指定对应进程PID所打开的文件描述符\n+ -d 值：指定需要显示的文件描述符编号\n+ -a 对上述两个选项结果进行布尔AND运算\n\n<div class=\"show\">可以结合环境变量$$(当前shell的PID)来查看当前shell进程打开的文件描述符\n/usr/sbin/lsof -a -p $$ -d 0,1,2\n</div>\n\n该命令返回信息包括：\n<div class=\"table\">\n\n参数|说明\n----|------\nCOMMAND| 正在运行的命令名的前9个字符\nPID| 进程的PID \nUSER| 进程属主的登录名\nFD| 文件描述符号以及访问类型（r代表读，w代表写，u代表读写）\nTYPE| 文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）\nDEVICE| 设备的设备号（主设备号和从设备号）\nSIZE| 如果有的话，表示文件的大小\nNODE| 本地文件的节点号\nNAME| 文件名\n</div>\n\n\n返回值结果举例\n<div class=\"shell\">COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME \nbash 3344 rich 0u CHR 136,0 2 /dev/pts/0 \nbash 3344 rich 1u CHR 136,0 2 /dev/pts/0 \nbash 3344 rich 2u CHR 136,0 2 /dev/pts/0</div>\n\n由于STDIN、STDOUT和STDERR文件描述符都指向终端，因此其文件类型是字符型，输出文件的名称就是终端的设备名，且所有3种标准文件都支持读和写。\n\n### 条件判断\n在bash shell中，if 语句的判断依据为命令的退出状态码，不能像其他语言一样直接用 if 语句判断条件语句，但bash shell提供了两个用于条件判断的方法：\n+ test 命令\n+ [  ] 使用中括号测试条件\n\n#### test命令与[ ]\ntest命令可用于做数值比较、字符串比较和文件比较，当test命令中列出的条件成立，test命令就会正常退出并返回退出状态码0，这样if等语句就可以正常工作了。此外，test命令有一种替代形式，可以直接将条件语句写于中括号[ ]中，注意，<span class=\"text-red\">第一个中括号后和第二个中括号前都必须加上一个空格</span>，否则将报错。如果test命令后或者中括号中不写条件语句，则它们都将视为条件不成立，二者的语法类似：\n+ <span class=\"strong\">test 条件语句</span>\n+ <span class=\"strong\">[ 条件语句 ]</span>\n\n<div class=\"show\">e.g.检测某个变量是否存在且不为空，提示：返回值在终端上可以用$?查看\n<code>str=\"\"\nif test $str\n then \n   echo \"该变量存在\"\n else\n   echo \"该变量不存在\"\nfi</code>\n或\n<code>if [ $str ] #取变量值$str前后均有空格\n then \n   echo \"该变量存在\"\n else\n   echo \"该变量不存在\"\nfi</code></div>\n\n#### 文件相关\n上述两个方法用于测试文件或目录是否满足相关要求时的语法为：\n+ <span class=\"strong\">test 选项 文件/目录名</span>\n+ <span class=\"strong\">[ 选项 文件/目录名 ]</span>\n\n##### 文件类型\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n-e file |判断file是否存在\n-d file |判断file是否存在，且是否为目录\n-f file |判断file是否存在，且是否为为文件\n-b file |判断file是否存在，且是否为块设备文件(如：硬盘设备文件)\n-c file |判断file是否存在，且是否为字符设备文件(如：鼠标、键盘设备文件)\n-O file |判断file是否存在并属于当前用户所有\n-G file |判断file是否存在并默认组与当前用户相同\n-L file |判断file是否存在，且是否为链接文件\n-p file |判断file是否存在，且是否为管道文件\n-s file |判断file是否存在，且文件大小是否大于0(非空)，非空为true\n-S file |判断是否为套接字文件\n-N file |判断file是否存在，且文件在上一次读取之后被修改过(mtime比atime新)，则为true\n</div>\n\n<div class=\"show\">e.g.在使用某个文件或目录之前，先检查其是否存在是一个好的编程习惯\n<code>location=$HOME\nfile_name=\"myFile\"\nif [ -e $location ]\nthen\n  if [ -e $location/$file_name ]\n  then\n      echo \"文件存在\"\n      echo \"写入数据\"\n      date &gt;&gt; $location/$file_name\n   else\n      echo \"文件不存在\"\n   fi\nelse\n   echo \"目录不存在\"\nfi\n</code></div>\n\n##### 文件权限\n检测读(写/执行)权限时，文件所有者、所属组、其他任意拥有读(写/执行)权限都将返回true\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n-r file|判断file是否存在，且是否拥有读权限\n-w file|判断file是否存在，且是否拥有写权限\n-x file|判断file是否存在，且是否拥有执行权限\n-u file|判断file是否存在，且是否拥有SUID权限\n-g file|判断file是否存在，且是否拥有SGID权限\n-k file|判断file是否存在，且是否拥有SBit权限\n</div>\n\n##### 两个文件比较\n在比较文件之前，应该确认两个文件确实存在，或用脚本验证文件是否存在并作错误处理，否则比较操作可能会返回错误的结果。\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n文件1 -nt 文件2 |判断文件1的修改时间是否比文件2新\n文件1 -ot 文件2 |判断文件1的修改时间是否比文件2旧\n文件1 -ef 文件2 |判断文件1和文件2的i节点(Inode)是否一致，即判断是否为同一文件，常用于判断是否为硬链接\n</div>\n\n#### 整数比较\nbash shell只支持整数进行比较，这里的整数可以是变量，也可以是正值或负值常量\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n整数1 -eq 整数2 |判断整数1与整数2是否相等\n整数1 -ne 整数2 |判断整数1与整数2是否不相等\n整数1 -gt 整数2 |判断整数1是否大于整数2\n整数1 -lt 整数2 |判断整数1是否小于整数2\n整数1 -ge 整数2 |判断整数1是否大于等于整数2\n整数1 -le 整数2 |判断整数1是否小于等于整数2\n</div>\n\n#### 字符串判断\n<span class=\"text-red\">注意！以下比较符号=、!=、\\\\&lt;、\\\\&gt; 前后都需要有一个空格</span>\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n-z str |字符串str长度为0，则为true(字符串为空字符串，未定义的变量也视为空)\n-n str |判断字符串str长度是否为非0(非空)\nstr1 = str2 |判断str1和str2是否相等\nstr1 !=s tr2 |判断str1和str2是否不相等\nstr1 \\\\&lt; str2|判断str1是否比str2小(根据ASCII码)\nstr1 \\\\&gt; str2|判断str1是否比str2大(根据ASCII码)\n</div>\n\n在比较字符串是否比另外一个字符串小/大时，大于号和小于号需要进行转义，否则会当做重定向符号处理。在比较时，会依次判断字母在ASCII中的出现位置，因此大写字母会小于小写字母(sort命令使用的是系统的本地化语言设置中定义的排序顺序，小写字母出现顺序位于大写字母前，与之相反)\n\n<div class=\"show\">e.g. 比较字符Test和test\n<code>str1=\"Test\"\nstr2=\"test\"\nif [ str1 \\\\&lt; str2 ]\n  then\n    echo \"Test小于test\"  #由于ASCII中T小于t，所以输出该语句\n  else\n    echo \"Test大于test\"\nfi\n</code></div>\n\n#### 多重判断\n\n<div class=\"table\">\n<table>\n<thead><th>测试选项 </th><th>作用</th></thead>\n<tbody>\n<tr><td>判断1 -a 判断2</td><td>逻辑与，判断1和判断2都成立，结果为真</td></tr>\n<tr><td>判断1 -o 判断2</td><td>逻辑或，判断1和判断2任意一个成立，结果为真</td></tr>\n<tr><td>! 判断 </td><td>结果取反</td></tr>\n<tr><td>[ 判断1 ] && [ 判断2 ]</td><td>判断1和判断2都成立，结果为真</td></tr>\n<tr><td>[ 判断1 ] || [ 判断2 ]</td><td>判断1和判断2任意一个成立，结果为真</td></tr>\n</tbody></table></div>\n\n<div class=\"show\">e.g.判断a是否有值，并且判断a是否大于20，都成立输出 true，否则输出 false\n<code>a=10\n[ -n \"$a\" -a \"$a\" -gt 20] && echo \"true\" || echo \"false\"</code></div>\n\n### 判断语句\n#### if语句\n其他语言中的if语句，会判断if语句后式子的求值结果，并根据结果的true或false值进行对应处理。但bash shell中的if语句有所不同，bash会执行if语句后的命令，如果该命令的退出状态码是0，则会执行then部分的代码体，如果该命令的退出状态码是其他值，则执行else语句(没有else则不执行)，if语句的语法为：\n\n<div class=\"show\"><div class=\"apiBox\"> if 命令行\n   then\n     程序体\n   fi\n</div></div>\n<div class=\"show\">e.g. 查询是否存在某个用户，如果存在则输出该用户的HOME目录\n<code>userName=shiwivi\nif grep $userName /etc/passwd\nthen\n   echo \"找到该用户：\"\n   ls -a /home/$userName/.b*\nfi</code></div>\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n在部分脚本中，该语句会被写成\n<div class=\"apiBox\">if 命令;then\n   程序体\nfi</div>\n形式，即如果then和if写于同一行，需要加上;号，这样它会与其他一些语言的语法类似，如果if和then不写在同一行上，则;号可要可不要\n</div>\n\n此外，bash shell也支持if-then-else语句和if嵌套语句，但注意，嵌套的if语句中的else-if被简化为了elif\n<div class=\"show\"><span class=\"text-red\">if-then-else语句：</span>\n<div class=\"apiBox\">if 命令 \n      then\n            条件成立执行\n      else\n            条件不成立时执行\n   fi\n</div><span class=\"text-red\">多分支if语句：</span>\n<div class=\"apiBox\">if 命令1 \n      then\n            条件成立执行\n   elif 命令2\n      then\n            条件成立时执行\n   (.....)\n   else\n         上述所有条件不成立时执行\n   fi\n</div></div>\n\n#### case命令\ncase语句类似于其他语言中的switch...case语句，用于匹配多个同类型的条件，其语法为：\n<div class=\"show\"><div class=\"apiBox\">case 变量 in\n   值1 | 值2)\n         程序1 ;;\n   值3)\n         程序2 ;;\n   .....\n   *)\n         上述条件都不满足，执行该程序;;\nesac\n</div></div>\n\ncase中的条件可以使用或符号同时设置多个条件，最后的星号会捕获所有与已有条件不匹配的值，相当于switch语句中的default\n<div class=\"show\">e.g.查询多个用户\n<code>case $USER in\nJayChou | EasonChan)\n      echo \"歌手\";;\nKenThompson)\n      echo \"程序员\";;\n*)\n      echo \"未知用户\";;\nesac\n</code></div>\n\n### 循环语句\n#### for命令\nfor语句遍历时，默认使用空格分割需要遍历的值，如果值本身包含空格，则需要使用双引号将值包裹，此时for语句不会将双引号作为值的一部分\n<div class=\"show\"><div class=\"apiBox\">for 变量 in 值1 值2 值3.....\n   do \n      程序\n   done</div></div>\ndo可以和for语句放在同一行，只需要在值列表之后加上一个分号即可。\n<div class=\"show\">1. for需要遍历的数据使用空格隔开\nfor value in data1 data2 data3\ndo\n   echo \"数据依次为$value\"\ndone\n2. 如果数据中包含单引号等特殊字符，可以使用双引号包括数据，或使用转义符\n#使用转义符表示\\'，或使用双引号包裹\"this'll\"\nfor test in I don\\'t know if \"this'll\" work \ndo \n echo \"word:$test\" \ndone\n3. 数据中包含空格，也需要使用双引号包裹数据\nfor test in Nevada \"New Hampshire\" \"New Mexico\" \"New York\" \ndo \n echo \"Now going to $test\" \ndone\n4. for遍历的数据，可以是一个变量，也可以是一个命令的输出\nfile=\"/myData/map\" \nfor state in $(cat $file) \ndo \n echo \"Visit beautiful $state\" \ndone\n5. for也可以用来读取目录\nfor file in /home/user1/test/*\ndo\n   if [ -d \"$file\"]    #将file用双引号包裹，避免文件名中含有空格时产生错误\n   then\n      echo \"这是一个目录\"\n   elif [ -f \"$file\" ]\n   then\n      echo \"这是一个文件\"\n   fi\ndone\n</div>\n\n此外，bash shell还支持一种C语言风格的for语句，但需要注意：\n+ 使用双括号\n+ 变量不以美元符$\n+ 迭代过程的算式不需要用expr命令格式\n<div class=\"show\"><div class=\"apiBox\">for((初始值;条件;变量变化))\n   do\n     程序\n   done</div></div>\n\n<div class=\"show\">e.g.这种形式的for语句也支持遍历多个变量\nfor (( a=1, b=10; a <= 10; a++, b-- )) \ndo \n echo \"$a 与 $b\" \ndone\n</div>\n\n#### while命令\n<div class=\"show\"><div class=\"apiBox\"> whlie 命令\n      do\n         程序\n      done</div></div>\n注意：while命令允许在while语句行定义多个测试命令，只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。\n<div class=\"show\">e.g.只有最后一个命令[ $num2 -ge 0 ]的退出状态码决定while语句何时结束\nnum1=5\nnum2=10\nwhile echo \"-------\"\n    [ $num1 -ge 0 ]\n    [ $num2 -ge 0 ]\ndo\n    echo 这是第${num2}次循环\n    echo num1为${num1}，num2为${num2}\n    num1=$[ $num1 - 1 ]\n    num2=$[ $num2 - 1 ]\ndone\n</div>\n\n#### until命令\nuntil命令和while命令工作的方式相反，until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。即：while命令在条件满足时执行，until命令在条件满足时退出。同样，until也像while一样允许多个测试命令，但只有最后一个命令有效\n<div class=\"apiBox\">until 命令\n   do\n     程序\n   done\n\n</div>\n\n#### break终止循环\nbreak的用法与其他语言类似，即可以终止当前的循环，但bash shell提供了一个更高级功能，可以通过<span class=\"strong\">break 值</span>的方式跳出多重循环(如果不指定值，默认为1)，如：在两层for语句嵌套中，break 2 可以直接停止外层for语句的循环\n<div class=\"show\">e.g.当b为4时，终止2个for语句的循环\nfor (( a = 1; a < 4; a++ )) \ndo \n   echo \"Outer loop: $a\" \n    (( b = 1; b < 100; b++ )) \n   do \n   if [ $b -gt 4 ] \n   then \n   break 2 #终止外部for语句的循环，如果命令为break则只能终止内部循环\n   fi \n   echo \" Inner loop: $b\" \n done \ndone\n</div>\n\n#### continue跳过循环\ncontinue可以跳过本次循环，continue之后的命令将不再执行而开始下一次循环，与break类似，在多层循环中，bash shell中的continue提供跳过多层循环的功能，其语法为<span class=\"strong\">continue 值</span>，值默认为1\n\n<div class=\"show\">for (( var1 = 1; var1 < 15; var1++ )) \ndo \n if [ $var1 -gt 5 ] && [ $var1 -lt 10 ] \n then \n continue #如果有多层for，可以指定一个值跳过外层的循环\n fi \n echo \"Iteration number: $var1\" \ndone\n</div>\n\n#### 处理循环的输出\n在shell脚本中，可以在done命令后添加管道符或重定向符来处理循环的输出\n<div class=\"show\">e.g.将循环的语句\"值为xx\"写入到文件test.txt中而不显示到终端上，等循环语句写入完毕在终端上显示\"数据写入完毕\"提示语句\nfor (( a = 1; a < 10; a++ )) \ndo \n echo \"值为 $a\" \ndone > test.txt \necho \"数据写入完毕\"\n</div>\n\n### 字段分隔符\n环境变量IFS，叫作内部字段分隔符（internal field separator）。\nIFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字\n符当作字段分隔符：\n+ 空格\n+ 制表符\n+ 换行符\n如果bash shell在数据中看到了这些字符中的任意一个，它就会假定这表明了列表中一个新数据字段的开始。在处理可能含有空格的数据（比如文件名）时，这会非常麻烦\n要解决这个问题，可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段分隔符的字符。一般会在修改IFS值前保存原来的默认值，使用完后再恢复它\n\n<div class=\"show\">e.g.文件file每一行保存了一个数据，且数据中可能包含空格和制表符，要使用for循环遍历这些数据，则需要先将IFS修改为换行符，使bash shell忽略空格和制表符，将每一行当作一个整体处理\nfile=\"data\"\n IFS.OLD=$IFS  #保存旧的IFS值\n IFS=$'\\n' \nfor data in $(cat $file) \ndo \n echo \"数据：$data\" \ndone\n IFS=$IFS.OLD  #恢复IFS值\n</div>\n如果要指定多个IFS字符，只要将它们在赋值行串起来就行。\nIFS=$'\\n':;\" \n这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用IFS字符解析数据没有任何限制。\n\n<pre><code>#!/bin/bash \n# 提取/etc/passwd文件每个字段的内容\nIFS.OLD=$IFS \nIFS=$'\\n' \nfor entry in $(cat /etc/passwd) \ndo \n echo \"当前用户整体信息：$entry\" \n IFS=: \n for value in $entry \n do \n echo \" $value\" \n done \ndone\n</code></pre>\n\n### (())双括号命令\n双括号命令(( ))在shell中用于进行数学运算和条件判断，并提供了更灵活和方便的方式来处理数值计算和逻辑操作\n\n#### 数学运算\n双括号命令除了基本的数学运算外，还支持以下运算，且双括号中还支持使用变量\n\n<div class=\"table\">\n\n符号|描述\n----|-----\nnum++、++num|前置/后置的自增\nnum--、--num|前置/后置的自减\n!           |逻辑取反\n~           |按位取反\n**          |冥运算\n&lt;&lt;    |左位移\n&gt;&gt;    |右位移\n&           |位布尔和\n&#124;      |位布尔或\n&&          |逻辑和\n&#124;&#124;|逻辑或\n</div>\n\n<div class=\"show\">(( result = 5 * (3 + 2) ))\necho \"Result of arithmetic operation: $result\"</div>\n\n#### 逻辑判断\n双括号命令也常用于if-then等语句的逻辑判断，双括号命令支持<span class=\"tips\">&lt;</span>、<span class=\"tips\">&gt;</span>、<span class=\"tips\">&lt;=</span>、<span class=\"tips\">&gt;=</span>、<span class=\"tips\">==</span>、<span class=\"tips\">!=</span>运算符\n<div class=\"show\">if (( result > 10 )); then\n    echo \"The result is greater than 10\"\nelse\n    echo \"The result is not greater than 10\"\nfi\n</div>\n\n### [[]]双方括号命令\n双方括号命令提供了针对字符串比较的高级特性，双方括号命令里的表达式支持模式匹配，可以定义正则表达式来匹配字符串，因此该命令在比较字符串时功能很强大：\n+ 支持<span class=\"tips\">&lt;</span>、<span class=\"tips\">&gt;</span>、<span class=\"tips\">==</span>、<span class=\"tips\">!=</span>、<span class=\"tips\">-gt</span>等比较符\n+ 支持<span class=\"tips\">!</span>、<span class=\"tips\">&&</span>、<span class=\"tips\">||</span>等逻辑组合\n+ 支持<span class=\"tips\">-f</span>等文件测试，如：检测文件是否存在，是否为目录等\n+ 支持使用<span class=\"tips\">*</span>、<span class=\"tips\">?</span>等通配符，并使用<span class=\"tips\">=~</span>结合正则表达式进行匹配\n\n<div class=\"show\">#!/bin/bash \nif [[ $USER == r* ]] #r*使用模式匹配规则\nthen \n echo \"Hello $USER\" \nelse \n echo \"未知用户\" \nfi\n</div>\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nbash shell支持双方括号命令，但部分shell可能不支持该命令</div>\n\n### 脚本控制\n脚本在执行时，终端可以通过kill命令或Ctrl+C等方式发起信号进行进程的暂停、终止操作，这些信号中有一些是可以通过脚本捕获并作相应处理的(如：在被终止时将数据写入文件做好保存，或者无视终止命令继续执行脚本)\n\n#### 捕获信号\n\n<div class=\"apiBox\">trap 捕获时执行的命令 信号1 信号2 ...</div>\n\n+ 信号可以是信号值或信号名，但需要是可被捕获的Linux信号\n+ trap命令也会捕获以下特殊的伪信号\n\n<div class=\"table\">\n\n信号名(信号值)|说明\n-------------|----\nEXIT(0)|会在脚本退出时执行\nDEBUG|会在每个命令后都执行一次\nERR  |当某个命令以非零状态退出时，执行一次(非零状态来自if,while,until语句时不会执行)\n</div>\n\n<div class=\"show\">e.g.用户执行Ctrl+C发起SIGINT信号中断脚本执行时，输出信息并继续脚本执行，下下述代码中，echo语句包含空格，所以需要使用双引号引用整个echo语句，其他命令同理。如果命令中包含空格(如：rm -f)则也需要双引号\n#!/bin/bash\ntrap \"echo '无法通过Ctrl+C停止脚本执行'\" SIGINT\ncount=1 \nwhile [ $count -le 10 ] \ndo \n echo \"循环次数： $count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone\n</div>\n\n#### 修改信号捕获\n如果需要在脚本某个阶段修改前面设置的信号捕获语句，只需要重新使用一次trap命令即可\n\n<div class=\"show\">#!/bin/bash \ntrap \"echo '捕获到SIGINT信号执行功能1'\" SIGINT \ncount=1 \nwhile [ $count -le 5 ] \ndo \n echo \"Loop #$count\" \n sleep 1 \n count=$[ $count + 1 ] \ndone \ntrap \"echo '此时捕获到SIGINT信号修改为执行功能2'\" SIGINT</div>\n\n#### 删除信号捕获\n如果脚本在某个阶段不再需要进行信号捕获了，则可以移除信号捕获，语法为<span class=\"tips\">trap -&zwnj;- 信号</span>\n\n<div class=\"show\">#!/bin/bash\ntrap \"echo '捕获信号SIGINT'\" SIGINT\n.\n. #脚本功能\n.\ntrap -&zwnj;- SIGINT #移除信号捕获\n</div>\n\n### 函数\n#### 创建与调用函数\nshell脚本中创建函数的方法有两种：\n<div class=\"apiBox\">function 函数名 {\n   #函数体\n}</div>\n或\n<div class=\"apiBox\">函数名( ) {\n   #函数体\n}</div>\n\n注意，使用第一种方式定义函数时，函数名和{之间必须有一个空格，否则{可能会被当作函数名的一部分从而报错。调用函数与其他语言类似，只是不需要括号，直接执行函数名即可，同样，shell中的函数需要在调用前的代码中创建，否则抛出command not found错误。函数可以同名，后面的函数会覆盖前面的函数，函数调用方法为：\n<span class=\"strong\">函数名 参数1 参数2 ...</span>\n\n\n#### 变量的作用域\n在shell中，变量也分为全局变量和局部变量\n\n##### 全局变量\n与其他语言有所不同，shell中的全局变量作用域为定义之后的整个脚本代码，即使是函数内部定义的变量，在函数外依旧有效。若无特殊声明，脚本中定义的变量默认为全局变量。\n\n<div class=\"show\">e.g.函数内定义的变量，函数外也可以访问\n#! /bin/bash\nfunction test {\n   string=\"手写的从前\"\n}\ntest\necho \"函数外也可以获取全局变量：$string\"\n</div>\n\n##### 局部变量\nshell中的局部变量需要使用<span class=\"tips\">local</span>关键字声明。局部变量如果在函数内部声明，则其作用域只在函数中，如果函数外部存在一个同名变量，二者互不干扰\n\n<div class=\"show\">e.g.想要变量作用域为局部，需要使用local关键字声明\n#! /bin/bash\nfunction test {\n   local string=\"手写的从前\"\n   echo \"函数内可以获取到变量值：$string\"\n}\ntest\necho \"函数外无法获取该变量：$string\" #为空值\n</div>\n\n\n#### 函数返回值与输出\n##### 默认退出状态码\nbash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。与其他命令一样，在函数执行结束后，可以用shell中的预定义变量<span class=\"tips\">$?</span>来确定函数的退出状态码。默认情况下，函数的退出状态码是函数中<span class=\"tips\">最后一条命令</span>返回的退出状态码。注意，函数的默认退出状态码只看最后一条命令的退出状态，其他命令执行正确与否无法获悉，因此该方法应用场景有限。此外，就像脚本的返回值可以使用exit修改一样，函数的返回值可以使用return语句修改\n\n<div class=\"show\">e.g.函数func的退出状态码为最后一条命令ls的退出状态码，如果none.txt文件不存在，则函数的退出状态码为1，该状态码可以用$?调用\n#!/bin/bash\nfunc() { \n echo \"执行函数\" \n ls -l none.txt \n}\nfunc\necho \"该函数的退出状态码为 $?\" #none.txt文件不存在，输出值为1\n2. 可以使用return修改该返回值，即便ls命令未正确执行\n#!/bin/bash\nfunc() { \n echo \"执行函数\" \n ls -l none.txt \n return 0\n}\nfunc\necho \"该函数的退出状态码为 $?\" #此时return语句才是脚本最后一条命令，$?将输出为0\n</div>\n\n##### return命令修改状态码\nshell支持使用<span class=\"tips\">return</span>命令来返回指定的退出状态码，状态码支持<span class=\"tips\">0-255</span>之间的整数值，该状态码同样可以使用<span class=\"tips\">$?</span>获得。与exit命令指定的脚本退出状态码类似，如果return命令指定的退出状态码大于255，会输出该值被256取模后的结果\n\n<div class=\"show\">e.g.如果函数返回值大于255，则会返回一个错误的值\n#!/bin/bash\nfunction getDouble {\n   read -p \"输入一个值：\" value #输入200\n   return $[ $value * 2]\n}\ngetDouble\necho \"函数的返回值为 $?\" #输出值为144：400%256=144\n</div>\n\n##### 函数输出\nshell支持将命令的输出赋值给变量，同样也支持将函数的输出值赋值给变量，通过该方法我们可以将任何类型的数据作为函数输出，然后通过反引号<span class=\"tips\">``</span>或<span class=\"tips\">$( )</span>调用函数，并将获取的函数输出值保存到变量中，该方法相比于return语句功能更加强大。但注意，通过该方法从函数中输出的值并不会作为函数的退出状态码，也无法被<span class=\"tips\">$?</span>捕获\n\n<div class=\"show\">e.g.函数中read等命令的提示语句并不会作为函数输出一部分\n#!/bin/bash\nfunction getDouble { \n read -p \"输入值：\" value #不输出提示语句给result变量\n echo $[ $value * 2 ] #输入10\n}\nresult=$(getDouble)\necho \"函数输出值为 $result\" #输出result为20\necho \"函数的退出状态码为$?\" #输出状态码为0\n</div>\n\n#### 函数传参\n由于bash shell会将函数当作小型脚本来对待，因此可以像命令传参一样给函数传入参数，并使用<span class=\"tips\">$1、$2</span>等位置变量来读取传入函数的参数。\n\n由于函数内部也使用$1、$2等变量来引用函数的参数，因此脚本中的$1、$2等位置变量无法在函数内部使用，即函数中无法直接通过位置变量来读取脚本传入的参数。要在函数中使用脚本传入的参数，则需要在调用函数时手动将它们传过去\n\n<div class=\"show\">e.g.为脚本test传入两个参数，并在函数中进行求和\n#!/bin/bash\nfunction add { \n   if [ $# -ne 2 ] #判断函数参数数量\n   then \n   echo -1 \n   else\n   echo $[ $1 + $2 ] #这是函数的位置变量$1 $2\n   fi\n}\nvalue=$(<span class=\"text-red\">add $1 $2</span>) #这是脚本的位置变量$1 $2\necho \"函数计算结果为：$result\"\n执行该脚本时\n./test 10 20\n</div>\n\n#### 传递数组参数\nshell中，给函数传递数组，不能像C语言一样直接传递数组名(数组首地址)，这样只会传递第一个值。需要使用<span class=\"tips\">${数组名[@]}</span>将所有数组元素传递过去，然后在函数中使用<span class=\"tips\">$@</span>获取所有的数组元素\n\n理论上通过<span class=\"tips\">${数组名[\\*]}</span>也可以传递数组元素，或用<span class=\"tips\">$\\*</span>接收，但<span class=\"tips\">$\\*</span>会将所有数组元素视为一个整体，在使用for-in等语句遍历时可能出现问题\n\n<div class=\"show\">e.g.传递数组\n#! /bin/bash\nfunction test {\n echo '$@的值为'$@\n for value in $@\n do\n   echo \"当前值为：$value\"\n done\n}\narray=(10 20 30 40)\ntest ${array[@]}\ne.g.如果使用$*，所有数组元素会被视为一个整体\nfunction test {\n<span class=\"text-red\">#使用该语句，依旧会把元素一个一个遍历出来，这是因为即便$*使用空格作为元素分隔符，for语句会自动识别空格分隔的数据并遍历\n for value in $*</span>\n<span class=\"text-blue\">#使用双引号包裹$*，for语句就只执行一次了\nfor value in \"$*\"</span>\n<span class=\"text-green\">#而对于$@，无论加不加双引号，for语句都会依次遍历出数组里的元素\nfor value in \"$@\"</span>\n do\n   echo \"当前值为：$value\"\n done\n}\narray=(10 20 30 40)\ntest ${array[*]}\n</div>\n\n#### 返回数组\n从函数返回数组时，也不能直接返回数组地址，而是需要通过<span class=\"tips\">echo</span>语句输出<span class=\"tips\">${数组名[@]}</span>(数组元素)，然后通过<span class=\"tips\">命令替换</span>等方式在脚本中调用函数，并在命令替换时在外层加上<span class=\"tips\">( )</span>将其转换为一个数组\n\n<div class=\"show\">e.g.传入一个数组，反序输出\n<code>#! /bin/bash\nfunction test {\n#echo \"函数开始执行----------\" \n local newArray\n  local index=$[$#-1] #获取函数接收的参数个数并-1\n  for value in $@\n   do\n    newArray[$index]=$value\n    index=$[${index}-1]\n   done\necho ${newArray[@]}\n}\narray=(10 20 30 40 50)\n<span class=\"text-red\">result=($(test ${array[@]}))</span>\necho \"返回值result $result\"</code>\n注意：\n1.bash在使用命令替换时，会将捕获的结果作为一个字符串返回。上述代码中，命令替换外层加了个小括号()，在没有括号的情况下，result存储的是一个字符串，添加小括号后，result存储的结果将被转换为数组\n2. bash在使用命令替换时会捕获所有命令的标准输出，如果在test函数中有除了输出数组元素以外的语句，也会被捕获，并被赋值给result。由于shell支持不同类型的数据都作为同一数组的元素，因此所有输出信息都将作为数组元素，这可能会对之后使用该数组造成影响，因此，返回数组的函数，尽量不要输出多余的信息。如：如果test函数第一行被注释的echo语句正常输出，则该语句信息将作为result的数组元素\n3. 命令替换会捕获所有标准输出语句，且不显示到屏幕上，因此执行result=($(test ${array[@]}))语句时，虽然函数被执行了，但不会有任何屏幕输出，这些输出信息会在使用echo输出result的结果时，才会被输出到屏幕上\n</div>\n\n#### 创建库\n如果需要在多个脚本中频繁使用同一段代码，可以将这段代码封装为函数库，然后在多个脚本中调用该库文件。但在shell中，如果直接调用或执行该文件，shell会创建一个新的shell并在其中执行该库文件中的代码，而函数的作用域仅限于定义它的shell会话，因此在其他脚本中将无法调用这些函数。\n\nshell提供了<span class=\"tips\">source</span>命令用于解决该问题，source命令会在当前shell上下文中执行命令，这样脚本就可以使用库中的函数了。source命令有个快捷别名，称为<span class=\"tips\">点操作符</span>，命令也可以用<span class=\"tips\">.</span>号代替，语法格式为：\n<span class=\"strong\">. 库文件路径</span>\n\n<div class=\"show\">e.g.在myfunc.sh定义了两个函数，在test.sh中调用这两个函数\n<span class=\"strong\">文件路径：/myShell/myfunc.sh</span>\n<code>#!/bin/bash\nfunction add {\n if [ $# -ne 2 ]\n  then\n  echo \"参数输入错误\"\n else\n  echo $[$1+$2]\n fi\n}\nfunction sub {\n if [ $# -ne 2 ]\n  then\n  echo \"参数输入错误\"\n else\n  echo $[$1-$2]\n fi\n}</code>\n<span class=\"strong\">文件路径：/myShell/test.sh</span>\n<code>#!/bin/bash\n<span class=\"text-red\">#注意：无论使用.号还是source，命令后都需要添加一个空格，路径用相对路径或绝对路径均可</span>\n<span class=\"text-blue\">. ./myfunc.sh</span>\n<span class=\"text-green\">source /myShell/myfunc.sh</span>\necho \"求和运算：$(add 10 20)\"\necho \"求差运算：$(sub 20 10)\"</code>\n</div>\n\n#### 在命令行中使用函数\n函数也可以在命令行中创建和调用，命令行中创建的函数可以在整个系统中被调用，直到当前shell退出。<span class=\"tips\">注意，如果命名时函数名和shell的内建命令同名，则内建命令的功能会被函数功能覆盖！</span>\n\n在命令行中定义函数的方法有两种：\n1. 以单行方式定义，需要在每个命令后都加上分号<span class=\"tips\">;</span>，以便shell区分命令的起止\n<div class=\"show\">定义：\nfunction test { pwd; ls; echo $[ $1 / $2 ]; }\n调用：\ntest 100 50\n</div>\n\n2. 以多行方式定义，定义时，bash会使用次提示符提示输入更多命令，该方式不需要在命令后添加分号，直接回车即可，最后输入花括号<span class=\"tips\">}</span>告知shell函数输入完毕\n<div class=\"show\">定义：\nfunction add { \n&gt; echo $[ $1 + $2 ] \n&gt; } \n调用：\nadd 2 5\n</div>\n\n#### 在.bashrc文件中定义函数\n在命令行中定义的函数，在shell退出时函数也会随之失效，如果希望某个函数在shell启动时也随之被加载进内存，方便在全局调用，则可以将该函数写入<span class=\"tips\">$HOME/.bashrc</span>文件，一般情况下，bash以登录交互式shell启动，或以非登录交互式shell启动都会载入该文件。绝大部分Linux发行版都已经在.bashrc文件中定义了一些函数，注意小心修改，将新添加的函数写于文件末尾即可。也可以将新写的函数写于一个单独的文件中，然后在.bashrc文件中使用source命令载入。\n\n通过该方式从.bashrc文件载入的函数，可以在命令行中全局调用，但无法在脚本中使用，这是由于脚本执行时启动的非交互式shell不会读取.bashrc文件，函数也不会从父shell中继承。如果需要某个函数在脚本中也可以被直接调用，可以用以下方法：\n+ 在脚本中使用source命令引入.bashrc文件\n+ 如果不想引入.bashrc文件，则在.bashrc文件中定义完函数后，可以用<span class=\"tips\">export -f</span>命令将函数导出为环境变量，这样执行脚本时创建的非交互式shell将能从父shell继承该函数，然后在脚本中直接调用\n\n<div class=\"show\">e.g.为了避免修改$HOME/.bashrc，因此将某个常用的函数定义于$HOME/myfunc文件中，然后在$HOME/.bashrc引入，然后尝试在某个脚本中直接调用。这里直接以root账户举例\n<span class=\"strong\">创建文件/root/myfunc用于存放自定义函数</span>\n<code>function myTest1 {\n echo \"函数myTest1被调用\"\n }\n function myTest2 {\n echo \"函数test2被调用\"\n }\nexport -f myTest1 #导出其中一个函数</code>\n<span class=\"strong\">在文件/root/.bashrc末尾引入myfunc文件</span>\n<code>if [ -f /root/myfunc ];then\n        . /root/myfunc\nfi</code>\n<span class=\"strong\">/myShell/test.sh</span>\n<code>#!/bin/bash\necho \"脚本开始执行\"\nmyTest1 #被导出的函数可以在非交互式shell执行的脚本中直接使用\nmyTest2 #未被导出为环境变量的函数则提示command not found</code>\n</div>\n\n### 脚本合集\n#### 判断发行版\n\n<pre><code>#!/bin/bash  \n\nos_name=\"undefined\"\nos_version=\"0.0\"\n\n# 检查 /etc/os-release 文件是否存在  \nif [ -f /etc/os-release ]; then  \n    . /etc/os-release  \n    os_name=$NAME\n    os_version=$VERSION\n    echo \"发行版: $NAME\"  \n    echo \"版本: $VERSION\"  \nelse  \n    # 作为替代，检查其他可能的文件  \n    if [ -f /etc/lsb-release ]; then  \n        . /etc/lsb-release  \n\tos_name=$DISTRIB_ID\n\tos_version=$DISTRIB_RELEASE\n        echo \"发行版: $DISTRIB_ID\"  \n        echo \"版本: $DISTRIB_RELEASE\"  \n    elif [ -f /etc/debian_version ]; then  \n        os_name=\"Debian\"\n\techo \"发行版：Debian\"\n        echo \"版本未知，以下为/etc/debian_version文件内容:\"\n        cat /etc/debian_version\t\n    elif [ -f /etc/centos-release ]; then  \n\tos_name=\"CentOS\"\n        echo \"发行版：CentOS\"  \n        cat /etc/centos-release  \n    elif [ -f /etc/redhat-release ]; then\n\tos_name=\"redhat\"\n        echo \"发行版：redhat或centOS\"\n    else\t    \n        echo \"未知发行版\"  \n    fi  \nfi</code></pre>\n","tags":["Linux","shell"]},{"title":"Shell介绍与使用","url":"/blog/2021/12/29/LinuxShell介绍与使用/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n由于Bash是最常用的shell，本文将bash的内容放到了最前面方便查询命令，完整文档请查阅GUN官方的Bash文档：<a href=\"https://www.gnu.org/software/bash/manual/bash.html\">Bash Reference Manual</a></div>\n\n### Bash的内建命令\n#### bash常用快捷键与字符\n<div class=\"table\">\n\n快捷键|说明\n------|---\nctrl+a|将光标跳转到命令行开头\nctrl+e|将光标跳转到命令行末尾\nctrl+左箭头|光标向左(前)跳转一个单词，esc+b也可以\nctrl+右箭头|光标向右(后)跳转一个单词，esc+f也可以\nctrl+u|剪切光标到行首之间的内容(也用来快速删除一整行命令)\nctrl+k|剪切光标到行尾之间的内容\nctrl+y|粘贴剪切的内容\nclear |清屏\nctrl+l|清屏，同clear命令\nexit  |退出当前终端\nctrl+d|退出当前终端，同exit命令\nctrl+c|强制终止当前任务\nctrl+z|暂停当前任务并放入后台\nctrl+r|反向搜索执行过的历史命令\n#|root用户的命令提示符\n\\$|非root用户的命令提示符\n&gt;|次提示符\n\\\\|延续字符\n</div>\n\n修改快捷键请参考stty命令\n\n#### history历史命令\n在bash中执行过的命令会被缓存在内存中，方便重复调用，当shell退出或用户登出时会被写到用户对应的<span class=\"tips\">.bash_history</span>历史命令记录文件中\n\n<span class=\"strong\">history [选项] [历史命令保存文件]</span>查看使用过的命令，可以在后面加一个值指定显示n条命令\n\n+ -c 清空历史命令\n+ -w 把缓存的历史命令写入历史命令保存文件~/.bash_history中\n+ -a 将缓存的历史命令追加到历史命令保存文件中\n+ -d 值 删除该条历史命令记录\n+ -s 字符串  将该字符串添加到当前会话的命令历史中，但不执行\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n每个用户都有独立的历史命令保存文件，一般在用户家目录下，该文件默认隐藏，用户执行过的命令会先缓存在内存中，等登出账户后再写入bash_history文件中，历史命令默认保存1000条，用户可在环境变量配置文件/etc/profile中的HISTSIZE选项自行修改</div>\n\n##### 调用历史命令\n+ <span class=\"strong\">可通过上下箭头调用之前执行的命令</span>\n+ <span class=\"strong\">!!</span>再次执行上一次执行的命令\n+ <span class=\"strong\">!n</span>再次执行第n条历史命令(序号以history列出的序号为准)\n+ <span class=\"strong\">!字符串</span>再次执行最后一次以该字符串开头的命令\n\n#### alias自定义命令名\n<span class=\"strong\">alias</span>查看所有自定义的命令\n\n<span class=\"strong\">alias 别名='原命令'</span>自定义命令名，原命令依旧可用\n\n使用命令定义的命令名只能临时生效，且只在当前shell中生效，系统重启后将丢失，要永久生效需将自定义的命令添加到文件<span class=\"tips\">/用户名/.bashrc</span>中\n\n删除自定义的命令:\n\n<span class=\"strong\">unalias 别名</span>\n\n#### type查询命令类型\n查看所指定的命令是shell 内建命令、外部可执行文件，还是其他类型\n\n<span class=\"strong\">type [选项] 命令</span>\n\n+ -a 查看所有可能的命令类型，有的命令可能同时有shell内建、外部二进制文件、用户别名等多种类型，该选项会列出所有情况\n+ -t 只显示命令类型，而不显示命令路径，返回类型可能有：lias(别名)、builtin(内建命令)、file(外部命令)、function(定义的函数)、keyword(shell保留的关键字)\n+ -p 只显示命令路径，如果命令是shell内建命令或别名，使用此选项不会有输出\n+ -P 在PATH中查找该命令，无论该命令是何种类型，都返回其路径\n+ -f 不在shell函数中查找，即不将命令视为函数来查找\n\n#### exec命令\nexec命令的主要功能有两个\n\n##### 替换当前shell进程\n<div class=\"apiBox\">exec [选项] 执行命令</div>\n\n+ -c 清除所有环境变量(除了HOME、SHELL、PATH、TERM、MAIL、USER和LOGNAM)\n+ -l 启动一个新shell执行对应的命令，该shell以登录shell的身份工作\n\n当使用exec命令执行命令或可执行文件时，新执行的程序会替换当前的shell进程。exec命令会将指定的命令或程序加载到当前shell进程的内存空间中，并替换 shell 进程的执行上下文，包括内存代码段、数据段、堆栈中的数据等，同时，新进程会继承原进程的大部分环境和信息，包括进程PID、环境变量、当前工作目录、打开的文件描述符、用户和用户组ID、进程优先级、以及对进程的资源限制(如内存限制、文件大小限制)等信息，这样可以在不创建新进程的情况下，执行新的功能和程序，极大程度上节省了用于创建新进程消耗的系统资源，可以有效减少进程数量并简化进程管理。\n\n该命令可用于在不创建新进程或子shell的情况下切换shell并替换当前的shell进程，通过exec命令切换，Linux会保持shell的PID、用户和用户组ID、当前工作目录等环境不变，也不会创建子shell消耗更多的系统资源\n\n<div class=\"show\">e.g.从bash切换到sh\nexec /bin/sh\n</div>\n\n该命令也可以用其他程序替换当前的shell进程，例如，在脚本的最后一行使用 exec 来启动一个长期运行的程序，当脚本即将运行结束，shell的使命也即将完成，通过exec命令让新的程序替换shell进程，而不再需要创建新的进程，可以有效节约系统资源\n<div class=\"show\">#!/bin/bash\n# 通过shell执行脚本功能\n# 即将运行结束，让新进程替换shell进程\nexec /path/to/long_running_application\n</div>\n\n此外，exec命令还被用于以下场景：\n+ 当某个进程认为自己不能再为系统和用户作出任何贡献时，就可以调用exec命令让新的进程替代自己，如：一些守护进程，或用于系统初始化启动的进程，当系统完成启动，这些进程的使命已经完成，exec命令可以使新进程接管自己的初始化环境，减少进程间的通信和数据拷贝，提高系统性能\n+ 在一些特定环境中，使用exec命令可以保证某个关键任务完全接管当前进程，而不会有多余的 shell 进程存在\n+ 可以用于动态加载新程序和脚本，在其环境不变的情况下执行新脚本，而无需额外创建进程\n+ 在某些需要严格控制权限的环境中，用 exec 替换当前进程可以确保新的进程继承当前进程的所有权限和环境，使进程在受限的环境中启动并继承了相应权限\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n注意！如果使用远程终端在登录shell中使用exec命令，如：执行 exec ls -l，ls命令会替换当前shell进程，这会导致远程shell会话终止，远程连接断开。因此如果要在远程连接时执行该命令，最好在子shell中使用，在登录shell中使用会导致ssh连接断开</div>\n\n\n##### 修改文件描述符\n<div class=\"apiBox\">exec 重定向命令</div>\n\nexec 命令还可以用来重定向文件描述符。在这种用法中，exec 并不会替换当前的 shell 进程，而是会替换脚本的执行环境，该命令可用来重定向整个脚本的标准输入输出文件，或者关闭不需要的文件描述符\n\n<div class=\"show\">e.g.将脚本的所有标准输出信息重定向到out.txt文件\nexec 1&gt;out.txt\ne.g.关闭文件描述符3\nexec 3&gt;&-\n</div>\n\n\n### 环境变量\nbash shell使用环境变量(environment variable)来存储有关shell的会话和工作环境，并将这些信息存储在内存中，以便程序或shell脚本能够轻松访问到这些数据，一般情况下，环境变量均使用大写的变量名\n\n#### 全局环境变量\n全局环境变量该shell和其创建的子shell中均有效，以下为查询全局环境变量的命令\n\n+ <span class=\"strong\">printenv</span>查看所有全局环境变量\n>>+ -0 每行输出末尾输出空字符(null)，而不是换行符，以便其他程序解析输出\n+ <span class=\"strong\">env</span>查看所有全局环境变量\n+ <span class=\"strong\">printenv 变量名</span>查看指定环境变量\n+ <span class=\"strong\">echo $变量名</span>查看指定环境变量\n\n定义全局环境变量需要使用export关键字\n+ <span class=\"strong\">export 变量名=值</span>&emsp;定义全局环境变量\n+ <span class=\"strong\">unset 变量名</span>&emsp;删除变量\n\n父shell中创建的全局环境变量在子shell中也有效，且如果此时在子shell中修改该变量的值，不会影响其在父shell中的值，修改后的值只在子shell中有效\n\n<div class=\"show\">e.g.定义一个普通全局变量，在子shll中修改值，然后返回父shell读取值\n$ my_variable=\"I am Global now\" \n$ export my_variable #声明为全局变量\n$ bash   #切换到子shell\n$ echo $my_variable #子shell可以访问该变量\nI am Global now\n$ my_variable=\"Null\"  #在子shell中修改变量值\n$ export my_variable  #即便用export命令也无法修改其在父shell中的值\n$ echo $my_variable \nNull  #该值在子shell中有效\n$ exit \nexit \n$ \n$ echo $my_variable #父shell中值不变\nI am Global now\n</div>\n\n<div class=\"show\">e.g.环境变量支持数组\nmyArray=(one two three four five)\necho ${myArray[2]}\necho ${myArray[*]}\nunset myArray #删除数组\n</div>\n\n#### 局部环境变量\n局部环境变量只能在定义它们的shell中有效，父shell中的局部环境变量无法在子shell中访问到。Linux中没有只显示局部环境变量的命令，但可以通过<span class=\"strong\">set</span>命令查看所有环境变量，包括局部变量、全局变量以及用户定义变量\n\n定义局部环境变量的方法和定义局部自定义变量的方法一样，不需要加export关键字，只需要将变量名大写用于识别该变量是一个环境变量即可\n<div class=\"show\">MY_PORT=2021\necho $MY_PORT\nbash #切换到子shell\necho $MY_PORT  #无法访问该变量</div>\n\n#### Bash中的环境变量\n以下为bash shell种已经定义好的环境变量，可以直接调用，有些环境变量的值为空，因此执行set命令时不一定会列出所有变量\n\n<div class=\"table\">\n\n变量名|说明\n------|-------------\nHOME| 当前用户的主目录\nUID| 当前用户的真实用户ID（数字形式）\nEUID| 当前用户的有效用户ID（数字形式）\nIFS| shell用来将文本字符串分割成字段的一系列字符\nMAIL| 当前用户收件箱的文件名\nMAILPATH| 冒号分隔的当前用户收件箱的文件名列表\nOPTARG| getopts命令处理的最后一个选项参数值\nOPTIND| getopts命令处理的最后一个选项参数的索引号\nPATH| shell查找命令的目录列表，由冒号分隔\nPS1| shell命令行界面的主提示符\nPS2| shell命令行界面的次提示符\nCDPATH| cd命令的搜索路径，切换路径时，cd命令会先尝试在当前目录下查找指定目录并切换过去，如果当前目录下并没有指定的目录，则cd命令会前往该变量设置的路径下查找并切换，可以指定多个路径用冒号分隔\nBASH| 当前shell实例的全路径名\nBASH_ALIASES| 含有当前已设置别名的关联数组\nBASH_ARGC| 含有传入子函数或shell脚本的参数总数的数组变量\nBASH_ARCV| 含有传入子函数或shell脚本的参数的数组变量\nBASH_CMDS| 关联数组，包含shell执行过的命令的所在位置\nBASH_COMMAND| shell正在执行的命令或马上就执行的命令\nBASH_ENV| 设置了的话，bash脚本会在执行前读取变量中的文件，读取文件中设置的变量，并执行其中的命令\nBASH_EXECUTION_STRING| 使用bash -c选项传递过来的命令\nBASH_LINENO| 含有当前执行的shell函数的源代码行号的数组变量\nBASH_REMATCH| 只读数组，在使用正则表达式的比较运算符=~进行肯定匹配（positive match）时，包含了匹配到的模式和子模式\nBASH_SOURCE| 含有当前正在执行的shell函数所在源文件名的数组变量\nBASH_SUBSHELL| 当前子shell环境的嵌套级别（初始值是0）\nBASH_VERSINFO| 含有当前运行的bash shell的主版本号和次版本号的数组变量\nBASH_VERSION| 当前运行的bash shell的版本号\nBASH_XTRACEFD| 若设置成了有效的文件描述符（0、1、2），则'set -x'调试选项生成的跟踪输出，可被重定向。通常用来将跟踪输出到一个文件中\nBASHOPTS| 当前启用的bash shell选项的列表\nBASHPID| 当前bash进程的PID \nCOLUMNS| 当前bash shell实例所用终端的宽度\nCOMP_CWORD| COMP_WORDS变量的索引值，后者含有当前光标的位置\nCOMP_LINE| 当前命令行\nCOMP_POINT| 当前光标位置相对于当前命令起始的索引\nCOMP_KEY| 用来调用shell函数补全功能的最后一个键\nCOMP_TYPE| 一个整数值，表示所尝试的补全类型，用以完成shell函数补全\nCOMP_WORDBREAKS| Readline库中用于单词补全的词分隔字符\nCOMP_WORDS| 含有当前命令行所有单词的数组变量\nCOMPREPLY| 含有由shell函数生成的可能填充代码的数组变量\nCOPROC| 占用未命名的协进程的I/O文件描述符的数组变量\nDIRSTACK| 含有目录栈当前内容的数组变量\nEMACS| 设置为't'时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止\nENV| 如果设置了该环境变量，在bash shell运行之前会读取该变量指定路径中的文件，如果未设置，Bash 会默认读取用户的\"HOME/.bashrc\"文件以设置环境变量，该变量方便用户自定义bash启动时的环境变量(仅用于当bash shell以POSIX模式被调用时)\nFCEDIT| 供fc命令使用的默认编辑器\nFIGNORE| 在进行文件名补全时可以忽略后缀名列表，由冒号分隔\nFUNCNAME| 当前执行的shell函数的名称\nFUNCNEST| 当设置成非零值时，表示所允许的最大函数嵌套级数（一旦超出，当前命令即被终止）\nGLOBIGNORE| 冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名\nGROUPS| 含有当前用户属组列表的数组变量\nhistchars| 控制历史记录扩展，最多可有3个字符\nHISTCMD| 当前命令在历史记录中的编号\nHISTCONTROL| 控制哪些命令留在历史记录列表中\nHISTFILE| 保存shell历史记录列表的文件名(默认是.bash_history)\nHISTFILESIZE| 最多在历史文件中存多少行 \nHISTTIMEFORMAT| 如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳 \nHISTIGNORE| 由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略\nHISTSIZE| 最多在历史文件中存多少条命令\nHOSTFILE| shell在补全主机名时读取的文件名称\nHOSTNAME| 当前主机的名称\nHOSTTYPE| 当前运行bash shell的机器\nIGNOREEOF| shell在退出前必须收到连续的EOF字符的数量（如果这个值不存在，默认是1）\nINPUTRC| Readline初始化文件名（默认是.inputrc）\nLANG| shell的语言环境类别\nLC_ALL| 定义了一个语言环境类别，能够覆盖LANG变量\nLC_COLLATE| 设置对字符串排序时用的排序规则\nLC_CTYPE| 决定如何解释出现在文件名扩展和模式匹配中的字符\nLC_MESSAGES| 在解释前面带有$的双引号字符串时，该环境变量决定了所采用的语言环境设置\nLC_NUMERIC| 决定着格式化数字时采用的语言环境设置\nLINENO| 当前执行的脚本的行号\nLINES| 定义了终端上可见的行数\nMACHTYPE| 按“CPU-公司-系统”（CPU-company-system）格式定义的系统类型\nMAPFILE| 一个数组变量，当mapfile命令未指定数组变量作为参数时，它存储了mapfile所读入的文本\nMAILCHECK| shell查看新邮件的频率（以秒为单位，默认值是60）\nOLDPWD| shell之前的工作目录\nOPTERR| 设置为1时，bash shell会显示getopts命令产生的错误\nOSTYPE| 定义了shell所在的操作系统\nPIPESTATUS| 含有前台进程的退出状态列表的数组变量\nPOSIXLY_CORRECT| 设置了的话，bash会以POSIX模式启动\nPPID| bash shell父进程的PID \nPROMPT_COMMAND| 设置了的话，在命令行主提示符显示之前会执行这条命令\nPROMPT_DIRTRIM| 用来定义当启用了\\w或\\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换\nPS3| select命令的提示符\nPS4| 如果使用了bash的-x选项，在命令行之前显示的提示信息\nPWD| 当前工作目录\nRANDOM| 返回一个0～32767的随机数（对其的赋值可作为随机数生成器的种子）\nREADLINE_LINE| 当使用bind –x命令时，存储Readline缓冲区的内容\nREADLINE_POINT| 当使用bind –x命令时，表示Readline缓冲区内容插入点的当前位置\nREPLY| read命令的默认变量\nSECONDS| 自从shell启动到现在的秒数（对其赋值将会重置计数器）\nSHELL| bash shell的全路径名\nSHELLOPTS| 已启用bash shell选项列表，列表项之间以冒号分隔\nSHLVL| shell的层级；每次启动一个新bash shell，该值增加1 \nTIMEFORMAT| 指定了shell的时间显示格式\nTMOUT| select和read命令在没输入的情况下等待多久（以秒为单位）。默认值为0，表示无限长\nTMPDIR| 目录名，保存bash shell创建的临时文件\n</div>\n\n#### 环境变量配置文件\n用户登录shell时，shell程序会读取环境变量配置文件作为初始化环境，用户可以修改这些文件来指定shell启动时自动执行的任务，以及指定一些环境变量值\n\n##### 全局配置文件\n对所有用户生效\n+ <strong>/etc/profile</strong>&emsp;主要的配置文件，也是用户登录时最先读取的文件，用于保存全局环境变量和shell参数，并调用其他配置文件\n+ <strong>/etc/profile.d/.sh后缀文件</strong>&emsp;由profile调用\n+ <strong>/etc/bashrc</strong>&emsp;用于保存bash相关的全局环境变量、函数、命令别名，如PS1等bash终端的环境\n\n/etc/profile配置文件是最主要的配置文件，其中几个常见变量的作用：\n<div class=\"table\">\n\n变量| 作用\n---- |-----\nUSER   |当前用户\nLOGNAME|当前用户名，配置文件中LOGNAME=$USER，因此同USER\nMAIL   |用户邮箱\nHOSTNAME|主机名\nHISTSIZE|历史命令保存条数 \numask   |设置文件默认权限\n</div>\n\n##### 用户配置文件\n只对单一用户生效，每个用户都有自己的配置文件，root用户位于/root下，普通用户位于/home/用户名下，默认隐藏，需要使用ls -a命令才能看见文件\n\n+ $HOME/.bash_profile &emsp; 用户个人的/etc/profile文件，保存用户自定义的环境变量，该文件会在用户登录时读取，且一般会在文件中调用其他配置文件(如下面的.bashrc)\n+ $HOME/.bashrc &emsp;写有用户自定义的命令别名、函数等，该文件会在打开一个新的交互式bash时都读取一次\n+ $HOME/.bash_logout &emsp;用户注销时执行的环境变量配置文件，可以写一些我们希望系统关机时执行的操作，如备份日志等\n+ $HOME/.bash_history &emsp;记录用户执行过的命令\n\n部分Linux发行版还可能会提供如：$HOME/.bash_login、$HOME/.profile等文件，其作用一般和$HOME/.bash_profile一样，shell一般会优先执行$HOME/.bash_profile\n\n##### 不重启就使配置文件生效\n直接执行任一命令\n+ <span class=\"strong\">source 文件名</span>\n+ <span class=\"strong\">.配置文件名</span>\n\n#### 不同启动方式读取的配置文件\n日常使用时，启动bash一般分为3种方式，每种方式都会读取不同的配置文件\n1. 登录用户账户时作为默认启动的交互式shell\n2. 通过bash等命令切换创建的非登录交互式子shell\n3. 执行脚本或任务启动的非交互式shell，如：执行脚本、使用at、cron等命令后台执行定时任务、通过脚本或()等方式启动的子shell\n\n\n作为默认登录shell启动时，bash会依次读取全局/etc/profile文件，以及用户的$HOME/.bash_profile文件，而绝大多数Linux发行版用户$HOME/.bash_profile文件会调用$HOME/.bashrc文件，而$HOME/.bashrc文件又会调用/etc/bashrc文件，因此一般情况下，登录shell会依次加载<span class=\"tips\">/etc/profile、$HOME/.bash_profile、$HOME/.bashrc、/etc/bashrc</span>文件\n\n而作为非登录shell启动时，它不会访问/etc/profile、$HOME/.bash_profile等文件，而只会依次读取<span class=\"tips\">/etc/bashrc、$HOME/.bashrc</span>文件，$HOME/.bashrc文件虽然包含了对/etc/bashrc的调用，但依旧会首先加载/etc/bashrc文件，$HOME/.bashrc文件对/etc/bashrc的再次调用并不会引起异常。由于非登录shell是从父shell启动的，因此/etc/profile、$HOME/.bash_profile文件中的全局环境变量也会从父shell中继承下来。\n\n作为非交互式shell启动时，bash shell会检查<span class=\"tips\">BASH_ENV</span> 环境变量，如果该变量指定了文件，shell会执行该文件里的命令，并读取里面设置的变量。但在绝大多数Linux发行版中，这个变量一般为空，因此非交互式shell一般不会读取配置文件。但该方式启动的shell，若脚本直接将当前shell作为脚本的执行shell，则所有当前shell中已加载的局部变量和全局变量，都可以在脚本中使用。如果脚本中通过诸如进程列表等方式创建了子shell，而其父shell在其加载的/etc/profile、$HOME/.bashrc等(具体加载哪些文件取决于该父shell的启动方式)文件中使用export声明了全局变量，用于执行脚本的子shell会继承这些变量。\n\n#### 环境变量的持久化\n通过赋值方式创建的变量保持于内存中，如果退出shell这些变量会失效，可以将这些环境变量写于配置文件中实现变量的持久化。\n\n对于所有用户都可能用到的环境变量，尽量避免将全局的环境变量放在<span class=\"tips\">/etc/profile</span>文件中，该文件会在系统升级时被覆盖，可以在<span class=\"tips\">/etc/profile.d</span>目录中创建一个.sh结尾的文件，将全局环境变量放在该文件中，然后再在profile文件中加载该目录下的内容。\n\n对于个人用户，可以将环境变量存放于<span class=\"tips\">$HOME/.bashrc</span>文件中，但注意，如果需要在脚本中调用某些自定义环境变量，由于脚本启动的一般是非交互式shell，所以需要先检查是否设置了<span class=\"tips\">BASH_ENV</span> 环境变量，如果有则需要将环境变量存放在对应的文件中；如果没有，则考虑在其父shell会读取的文件中将环境变量声明为export或在脚本中设置一个新的。\n\n### 终端样式控制\n#### 前言\n为了控制终端的显示和行为，ANSI标准定义了一系列用于控制终端输出选项的字符序列，称为ANSI转义字符序列(Escape Sequence)，其中包括了常见的控制字符(Control characters)。该转义字符序列中ASCII码表中0到31之间用于终端控制的字符称为C0控制字符。但原有的控制字符功能并不全面，后来，为了实现更多的终端控制功能，ASCII码表扩展出了以ESC字符（\\x1b）开头的C1控制字符(ASCII码表128-159)，C1控制字符被广泛应用于控制光标、屏幕和进行字符渲染，这部分转义字符序列又称为CSI(Control Sequence Introducer)，Bash也将其作为终端的控制字符。\n\nC1控制字符以<span class=\"tips\">ESC</span>开头，并紧接一个<span class=\"tips\">[</span>(代表CSI)，将ESC转换为ASCII码后，控制字符在代码中常写为<span class=\"tips\">\\x1b[</span>或<span class=\"tips\">\\033[</span>，完整的C1控制语句为：\n<span class=\"strong\">\\x1b[参数1;参数2;参数3函数名</span>\n+ \\x1b[ 为转义字符引导头\n+ 中间参数部分可以由0个或多个数字组成，多个数字间用分号分隔\n+ 函数名为需要调用的CSI函数功能名称\n\n\n\n<div class=\"show\">如：<span class=\"strong\">\\x1b[0;4;34m</span>\n# \\x1b[ 为转义字符引导头\n# m为函数名\n# 0;4;34为函数参数，相当于 m(0,4,34)\n</div>\n\n#### 函数\nCSI提供了很多用于光标控制、屏幕控制、字符渲染的函数\n##### 光标控制\n<div class=\"table\">\n\n函数|举例|功能\n----|---|------\nA   |\\033[nA|光标上移n行(默认1)\nB   |\\033[nB|光标下移n行(默认1)\nC   |\\033[nC|光标左移n行(默认1)\nD   |\\033[nD|光标右移n行(默认1)\nE   |\\033[nE|光标下移n行(默认1)，非标准\nF   |\\033[nF|光标上移n行(默认1)，非标准\nG   |\\033[nG|光标移动至当前行的n列，非标准\nH   |\\033[x;yH|光标移动到x行y列\ns   |\\033[s|保存光标位置\nu   |\\033[u|取出光标位置\nl   |\\033[?25l|隐藏光标\nh   |\\033[?25h|显示光标\n</div>\n\n##### 屏幕控制\n<div class=\"table\">\n\n函数|举例|功能\n----|---|------\nJ   |\\033[nJ|清除指定范围内的屏幕，0为光标位置到屏幕末尾，1为光标位置到屏幕开头，2为全屏幕\nK   |\\033[nK|清除该行的指定范围，0为光标到行尾，1为光标至行头，2为整行\nS   |\\033[nS|整页向上滚动n行，非标准\nT   |\\033[nT|整页向下滚动n行，非标准\n</div>\n\n#### 修改字体样式\n终端中最为常用的转义序列还是用于修改终端字体颜色、背景颜色和显示效果的函数和参数，即SGR(Set graphics mode)函数<span class=\"tips\">m</span>，常用于配合echo语句输出不同样式的提示信息，修改终端样式的转义字符序列一般为：\n<span class=\"strong\">\\033[参数m</span>\n\n<div class=\"show\">如：输出红色字符串 \"RedColor\"\n# echo -e \"\\e[31mRedColor \\e[0m\"\n# 末尾的\\e[0m用于删除所有设置的属性(包括颜色、加粗、闪烁等效果)使后续输出内容恢复默认属性\n# \\033可替换为\\e或\\x1B\n</div>\n\n##### 恢复默认\n<span class=\"strong\">\\e[0m</span>表示取消所有设置的属性(包括颜色、加粗、闪烁等效果)，使后续输出内容恢复默认属性\n\n##### 文字效果\n<div class=\"table\">\n\n设置效果代码 | 效果 |取消效果代码\n------|--------|-------\n1|加粗高亮|21\n2|变暗(未被广泛支持)|\n3|斜体(未被广泛支持)|\n4|下划线|24\n5|缓慢闪烁,低于每分钟150次|25\n6|快速闪烁，每分钟150次以上(未被广泛支持)\n7|反转背景色和前景色|27\n8|隐藏，常用于密码(未被广泛支持)|28\n9|划掉文字(未被广泛支持)\n10|默认字体\n11-19|替代字体\n20|尖角体\n</div>\n\n\n##### 字体颜色\n<div class=\"table\">\n\n代码 | 颜色 |代码|颜色\n------|------|----|----\n39|默认颜色\n30|黑色|90|深灰\n31|红色|91|红色\n32|绿色|92|浅绿色\n33|黄色|93|淡黄色\n34|蓝色|94|浅蓝\n35|品红|95|浅洋红色\n36|青色|96|浅青色\n37|浅灰|97|白色\n</div>\n\n##### 字体背景色\n\n<div class=\"table\">\n\n代码 | 颜色 |代码|颜色\n------|------|----|----\n49|默认颜色\n40|黑色|100|深灰\n41|红色|101|红色\n42|绿色|102|浅绿色\n43|黄色|103|淡黄色\n44|蓝色|104|浅蓝\n45|品红|105|浅洋红色\n46|青色|106|浅青色\n47|浅灰|107|白色\n</div>\n\n##### 修改文件目录颜色\n想在使用ls命令后使各种不同类型文件显示不同颜色，参考dircolors命令\n\n### shell介绍\n#### shell简介\nshell意为层壳，区别于操作系统Kernel(内核)，shell是一个命令行解释器，主要用来与用户交互，将用户的命令解释给操作系统，是用户与操作系统内核交互的桥梁，它提供文件操作、进程控制、环境变量设置、管道和重定向等各种功能，因此，Shell 也是许多脚本和自动化任务的基础。此外，shell还有一套自己的编程语法，用于编写shell脚本，shell脚本支持直接调用Linux系统命令\n\n常见的类Unix操作系统中的Shell程序包括：\n+ sh(Bourne Shell)：是Unix系统上最早的shell，由Stephen Bourne于1977年在AT&T贝尔实验室开发。尽管现在有许多更现代的shell可以使用，但许多Unix系统命令和脚本仍然使用sh作为默认解释器\n+ Bash(Bourne-Again SHell)： bash是Bourne Shell的增强版，兼容sh的命令和脚本，并结合了ksh、csh的有用功能。作为GNU项目的一部分，它具有强大的功能和灵活性，支持命令历史、自动补全、脚本编程等功能，是许多Linux系统的默认Shell\n+ Csh(C Shell)：csh是基于C语言语法的shell，它提供了类似于C语言的语法结构和编程特性，由Bill Joy于1978年开发\n+ Tcsh（TC Shell）：Tcsh是C Shell的改进版本，提供了更多的功能和灵活性\n+ Fish（Friendly Interactive Shell）：Fish是一个用户友好的交互式shell软件，具有直观的语法和自动补全功能，还提供了颜色高亮和语法提示等功能，被广泛包含于如 Debian、Ubuntu、Fedora、Gentoo、Arch 等操作系统中\n+ Ksh(Korn Shell)：由贝尔实验室的David Korn在1983年基于Bourne shell的源码开发，它结合了Bourne Shell和C Shell的特性，并引入了许多新的功能\n+ Zsh(Z Shell)：由普林斯顿大学的Paul Falstad开发，它包含了 bash，ksh，tcsh 等其他shell中许多优秀功能，可以作为bash的替代品，它也是macOS 10.15及新版系统的默认shell\n\n在这些众多的shell中，有一些shell软件有类似的语法和特性，由此形成了两大家族：Bourne Shell家族：通常为Linux的默认使用终端，包括sh、ksh、Bash、psh、zsh。以及C Shell家族：包括csh、tcsh，语法与C语言类似，主要用于BSD版Unix系统。\n\n#### 切换shell\n查看<span class=\"tips\">/etc/shells</span>文件可获取当前Linux支持的shell列表，绝大多数Linux发行版默认使用Bash作为命令解释器，直接输入其他shell名可进行切换，通过<span class=\"tips\"><strong>exit</strong></span>命令返回默认的Bash终端\n\n#### 父子shell\n默认情况下，系统会在用户登录时根据<span class=\"tips\">/etc/passwd</span>文件第7字段的设置启动用户的默认shell，这是一个<span class=\"text-blue\">父shell</span>，如果此时输入bash或其他shell的启动命令，会创建一个新的shell程序，这个shell程序是一个<span class=\"text-blue\">子shell</span>。\n\n创建子shell可以保持父子进程环境的纯洁性，创建子shell时，只有部分父进程环境会被复制到子shell中，因此子shell会在一个相对纯洁的环境中执行任务，但这也会造成父shell中的一些变量(如用户自定义的局部变量)无法被子shell中继承使用。在子shell中执行一些独立任务，或者修改一些环境也不会影响到父进程的执行。但是创建子shell成本不菲，它会显著占用一部分系统资源\n\n以下操作会创建一个子shell：\n+ 通过<span class=\"tips\">bash</span>等命令显式调用shell解释器，会启动一个新的子shell\n+ 通过<span class=\"tips\">bash filename.sh</span>或<span class=\"tips\">./filename.sh</span>方式执行shell脚本时，会创建一个子shell执行该脚本。相对的，通过source filename.sh或.filename.sh方式执行脚本，会在当前shell中执行而不会创建子shell\n+ 在命令中使用管道符<span class=\"tips\">|</span>时，shell会创建子shell，管道两边的命令都会在单独的子shell中执行。\n+ 使用反引号<span class=\"tips\">\\` \\`</span>或<span class=\"tips\">$()</span>执行命令替换时，命令会在子shell中执行\n+ 将命令放到<span class=\"tips\">( )</span>中，所有括号中的命令会在子shell中执行，这是最直接创建子shell的方式，通常用来执行多个需要在同一个shell环境中执行的一组命令\n+ 使用<span class=\"tips\">&</span>将任务放到后台执行时，为了不阻塞当前shell执行其他任务，bash会在后台创建子shell执行命令\n\n##### 查看父子shell的创建关系\n子shell也可以创建另一个子shell，产生嵌套，通过<span class=\"tips\">ps -f</span>命令查看shell程序的PPID来查找其父进程\n<div class=\"shell\">UID        PID  PPID  C STIME TTY          TIME CMD\nroot     27576 27573  0 15:11 pts/0    00:00:00 -bash #父shell\nroot     27602 27576  0 15:11 pts/0    00:00:00 bash  #子shell，父进程PID为27576\nroot     27619 27602  0 15:11 pts/0    00:00:00 ps -f\n</div>\n也可以通过<span class=\"tips\">ps -&zwnj;-forest</span>命令查看子shell的嵌套结构\n<div class=\"shell\">  PID TTY          TIME CMD\n27576 pts/0    00:00:00 bash\n27602 pts/0    00:00:00  \\_ bash\n27923 pts/0    00:00:00      \\_ bash\n27939 pts/0    00:00:00          \\_ bash\n28000 pts/0    00:00:00              \\_ ps\n</div>\n\n也可以通过输出环境变量<span class=\"tips\">BASH_SUBSHELL</span>来查看当前bash有没有生成子shell，如果该命令返回0，则表明没有子shell，返回1或其他更大的值，就表明有相应数量的子shell。但该命令需要在父shell环境下执行，因此一般在命令分组并形成进程列表时使用\n<div class=\"shell\">(pwd;ls;echo $BASH_SUBSHELL)</div>\n\nbash shell程序可使用命令行选项修改shell启动方式，以下为bash中可用的命令行参数\n\n<div class=\"table\">\n\n参数|说明\n----|-----\n-c string | 从string中读取命令并进行处理\n-i|启动一个能够接收用户输入的交互shell \n-l|以登录shell的形式启动\n-r|启动一个受限shell，用户会被限制在默认目录中\n-s|从标准输入中读取命令\n</div>\n\n##### 父子shell的使用场景\n如果命令或脚本需要在一个纯净的隔离环境下执行，或者希望执行某个操作但不改变当前的shell环境，创建子shell十分有用，但需要注意创建子shell带来的资源占用问题\n\n<div class=\"show\">1.前往tmp目录并创建一个新文件，但不切换当前目录\n(cd /tmp && touch newfile) #不会切换当前父shell的工作目录\n2. 临时更改环境变量，使子shell在某个新的环境变量下工作，但不影响父shell\n(export PATH=/custom/path && test.sh)\n3. 通过( )创建多个子shell时，这些子shell会被依次创建，只有执行完第一个子shell中的任务，才会创建第二个\n如：创建文件test.sh并写入以下命令\n(sleep 3)  # 3 seconds\n(sleep 2)  # 2 seconds\n(sleep 1)  # 1 second\n使用time()函数计算脚本执行时间\ntime(bash test.sh) #大约需要6s\n但通过&创建子shell，这些任务会被放入后台，子shell会并行创建并执行\n如：将文件test.sh修改为\nsleep 3 &  # 3 seconds\nsleep 2 &  # 2 seconds\nsleep 1 &  # 1 second\nwait\n然后计算执行时间\ntime(bash test.sh) #大约需要3s，取决于执行时间最长的子shell\n</div>\n\n### 内建命令与外部命令\n#### 外部命令\n外部命令，又被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中，可以使用<span class=\"tips\">which</span>或<span class=\"tips\">type -a</span>命令找到命令位置。执行外部命令时，会创建一个该命令对应的子进程，相对于内建命令来说，外部命令需要花费时间和资源来设置新子进程的环境\n<div class=\"shell\"># which ps\n/bin/ps</div>\n\n#### 内建命令\n内建命令不需要使用子进程来执行，它们已经和shell编译成了一体，在执行时速度更快，消耗的资源更少。常见的内建命令有<span class=\"tips\">cd、echo、pwd、history、alias、continue、exit、jobs、kill</span>等\n\n可以使用<span class=\"tips\">type</span>命令来查看某个命令是否为内建命令\n<div class=\"shell\"># type cd\ncd is a shell builtin\n</div>\n\n有些命令有多种实现方式，如：echo和pwd既有内建命令又有外部命令，默认使用内建命令，如果需要使用外部命令，则指定命令的具体路径即可。可以用<span class=\"tips\">type -a</span>命令查看命令的不同实现\n<div class=\"shell\"># type -a echo \necho is a shell builtin \necho is /bin/echo</div>\n\n#### 命令的执行优先级\n+ 第一顺位执行通过绝对路径或相对路径执行的命令\n+ 第二顺位执行自定义的命令别名\n+ 第三顺位执行bash内部命令\n+ 第四顺位执行$PATH环境变量定义的第一个命令\n\n#### 命令分组执行\n可以在一行中指定多个命令，命令之间使用分号(;)分隔，称为<span class=\"tips\">命令列表</span>，这些命令会依次执行\n<div class=\"show\">$ pwd ; ls ; cd /etc ; pwd ; ls</div>\n\n可以使用大括号或小括号将这些命令组合在一起，以便在特定情况(如在if-then语句中)一起执行，这称之为<span class=\"tips\">命令分组</span>，主要有两种不同的命令分组：\n+ 使用大括号{ }将多个命令组合在一起，可以在当前shell环境中执行，该方法也可用于shell脚本中if-then语句的结构控制\n<div class=\"show\">{ pwd ; cd /etc ; ls }</div>\n\n+ 如果将命令列表写在括号里，则shell会创建一个子shell执行这些命令，称为<span class=\"tips\">进程列表</span>，这样可以使用多个子shell进行多进程处理\n<div class=\"show\">创建1个子shell，输出值为1\n(pwd ; ls ; cd /etc ; pwd ; ls ; echo $BASH_SUBSHELL)\n括号可以嵌套，创建多个子shell进行多进程处理，创建了2个子shell(父shell创建子shell，子shell又创建了它的子shell)，输出值为2\n( pwd ; (echo $BASH_SUBSHELL))\n</div>\n\n#### 创建协程\nshell中的协程用于在后台创建一个子shell，并在该shell中执行命令，其实就相当于使用&将命令置入后台模式，但其有点在于我们可以为该协程命名，并且该协程创建时会自动创建一个匿名管道，并将子shell的输入输出重定向到这个管道，实现在 Bash 脚本中并发地执行子进程，并与该子进程进行双向数据通信的功能\n\n协程的创建需要使用命令<span class=\"tips\">coproc</span>，其语法为：\n\n<span class=\"strong\">coproc 协程名 { 命令1; 命令2; }</span>\n\n如果不指定协程名，则默认为COPROC，之后命令会被置入后台模式，返回后台作业号和进程ID\n\n<div class=\"show\">coproc my_process { echo \"子进程开始\"; sleep 2; echo \"子进程执行完毕\"; }\n# 读取子进程的输出\nwhile read -u \"${my_process[0]}\" output; do\n    echo \"父进程获得子进程输出: $output\"\ndone\nwait # 等待后台进程结束\necho \"父进程执行完毕\"</div>","tags":["Linux"]},{"title":"Linux常用工具命令","url":"/blog/2021/12/29/Linux常用工具命令/","content":"### curl\n#### curl介绍\ncurl(client url)是一个强大且开源的数据传输工具，它支持通过URL上传或下载数据，适合用来执行上传或下载文件、执行API请求、提交表单数据等任务，curl支持以下协议：DICT、FILE、FTP、FTPS、GOPHER、GOPHERS、HTTP、HTTPS、IMAP、IMAPS、LDAPS、MQTT、POP3、POP3S、RTMP、RTMPS、RTSP、SCP、SFTP、SMB、SMBS、SMTP、SMTPS、TELNET、TFTP、WS、WSS。\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\ncurl官方文档：<a href=\"https://curl.se/docs/manpage.html\" target=\"_blank\">https://curl.se/docs/manpage.html</a></div>\n\n\n#### curl命令\n<div class=\"apiBox\">curl [选项] URL1 URL2 ...</div>\n\n+ 默认情况下，curl会将接收到的数据(如：html文件、json文件)写到stdout，即直接打印在屏幕上\n+ 如果curl接收到的数据被-o选项或重定向符输出到stdout以外的地方，则curl默认会显示一个<span class=\"text-blue\">进度表</span>，进度表会显示传输数据量、传输速度和估计剩余时间\n+ -#或-&zwnj;-progress-bar 显示一个<span class=\"text-blue\">进度条</span>，使用进度条替换进度表\n+ -s 静默模式(silent)，不显示进度和错误信息，但仍会显示HTTP响应的内容，如返回的html、json等数据\n+ -q 完全安静模式(quiet)，完全阻止所有输出，包括进度信息、错误信息、返回的响应信息\n+ <span class=\"strong\">-&zwnj;-retry 值：</span>设置重试次数，该值默认为0，curl默认只会在响应超时、FTP返回4xx或HTTP返回408、429、500、502、503或504时进行重试，该选项可以搭配以下选项：\n>>+ -&zwnj;-retry-all -errors：出现任何错误时均重试，包括HTTP 404等情况\n>>+ -&zwnj;-retry-delay 值：每一次重试前的延迟时间，单位为秒\n>>+ -&zwnj;-retry-max-time 值：最大总重试时间，单位为秒，到达该时间后，即使还有剩余重试次数，也停止重试\n\n+ 如果URL中不指定协议，curl会尝试解析主机名，如果主机名不包含任何协议，则默认使用http\n+ <span class=\"strong\"> -o /路径/文件名</span>：将接收到的数据以<span class=\"tips\">新文件名</span>保存到指定位置，文件不存在则会新建，文件存在则会覆盖\n+ -O 将接收到的数据在当前路径下以<span class=\"tips\">原文件名</span>保存(不会保存路径)，文件不存在则会新建，文件存在则会覆盖\n+ -&zwnj;-no-clobber (7.83.0版本以上支持)使用-o等选项将传输的数据保存到本地时，如果文件已经存在原文件会被覆盖。该选项可以避免覆盖已经存在的文件，如果文件已经存在，curl会在新保存的文件名后加上一个点和一个数字(如：test.1)来生成不同的文件名，这只支持生成到test.100，之后curl将不创建任何文件\n+ -k 默认情况下，curl 建立的连接都会进行验证(如验证TLS 证书)，此选项会让curl跳过验证步骤，这可能引发安全问题\n+ -f 当请求的URL返回4xx响应码时，http服务一般会返回一个404页面文本，该选项可以禁止curl输出该数据，而是提前返回http错误码22，这在脚本中比较有用，脚本获取一个404相关的页面数据也没什么用，可以提前抛弃掉\n+ -&zwnj;-fail-early 在指定多个URL时，curl会依次执行这些传输任务，默认情况下，curl命令的执行结果只取决于最后一个URL是否成功传输，如果中间的某个URL返回错误代码也会被覆盖。该选项会让curl在遇到第一次传输失败时就返回一个错误，方便捕捉错误\n+ -:或-&zwnj;-next：用来重置所有本地选项，指定多个URL时如果要为不同的URL指定不同的选项，可以使用该选项重置之前指定的选项，该选项不会重置全局选项\n+ -I 只获取响应头\n+ -L 跟随重定向，当curl遇到服务器返回3XX响应码时，会前往重定向的新位置重做请求\n+ <span class=\"strong\">-x [请求方法]</span> 指定HTTP请求方法（GET、POST、PUT、DELETE 等）\n+ <span class=\"strong\">-T [文件]</span> 上传文件到指定URL\n\n\n\n<div class=\"show\">1. 默认情况下，curl会将下载的数据打印到屏幕\ncurl test.shiwivi.com/mobileTest.html\n打印的html文件：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;&lt;head&gt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;title&gt;shiwivi&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\n...\n&lt;/body&gt;&lt;/html&gt;\n2. curl命令自带下载进度表，用来显示传输的数据量、传输速度和估计剩余时间等，并且会默认打印到stdout，但如果下载的数据也被输出到stdout，curl会自行禁用进度表，以免进度数据和下载数据都打印到stdout造成混乱。如果使用-o选项或重定向符将数据输出到了stdout以外的位置，stdout将显示进度表\ncurl -o index.html test.shiwivi.com/mobileTest.html\n进度表的显示参数：\n% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   184    0   184    0     0    351      0 --:--:-- --:--:-- --:--:--   352\n</div>\n\n#### url通配\ncurl支持允许使用<span class=\"tips\">大括号{}</span>、<span class=\"tips\">中括号[]</span>来指定一个URL地址范围，此时需要使用<span class=\"tips\">双引号\"\"</span>来包裹URL地址，避免shell等程序解析这些字符\n\n<div class=\"show\">1.支持使用{ }指定多个地址\ncurl \"http://test.{one,two,three}.com\"\n2.支持使用[ ]来指定一个域名或文件名范围\n\"http://test.example.com/file[1-100].txt\"\n\"http://test.example.com/file[a-z].txt\"\n可以为这个范围指定步进值\n\"http://test.example.com/file[1-100:10].txt\"\n\"http://test.example.com/file[a-z:2].txt\"\n3.括号不能嵌套，但能并列使用多次\n\"http://{css,js,img}.example.com/file[1-20:2].txt\"\n{ }适合用来指定多个没有任何联系的离散独立值，[ ]适合用来指定一个范围值\n4.如果需要为每个下载的文件都另存并指定文件名，可以使用#加数字的形式来引用正在获取的URL字符串\ncurl \"http://{css,js,img}.example.com/file[1-20:2].txt\" -o \"file_#1_#2\"\n也可以依次指定-o选项\ncurl -o a.txt example1.com -o b.txt example2.com\n</div>\n\n\n### wget\n#### 介绍\nwget(World Wide Web Get)是一个功能强大的命令行工具，用于从网络上下载文件和数据。它可以处理HTTP、HTTPS、FTP等协议，支持断点续传、递归下载、限速等功能，相较于curl，wget更像是一种专门用来下载文件的软件\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nGNU社区的wget文档：<a href=\"https://www.gnu.org/software/wget/manual/wget.html\">https://www.gnu.org/software/wget/manual/wget.html</a></div>\n\n#### 命令\n<span class=\"strong\">wget [选项] URL</span>\n\n+ 默认情况下，wget命令会将文件保存到当前目录。下载时，wget命令会打印文件总大小、下载速度、下载进度等信息到stdout，且wget命令会默认自动处理HTTP重定向\n+ -q 静默模式，不输出任何信息\n+ <span class=\"strong\">-o 文件名</span> 将下载的文件以新文件名保存到指定位置\n+ <span class=\"strong\">-O 文件名</span> 将wget命令输出的下载信息日志保存到指定文件，而不再打印到屏幕\n+ <span class=\"strong\">-p 目录名</span>将文件下载到指定目录\n+ -c 启用断点续传，继续下载暂停或中断的文件\n+ -r 递归下载网站或目录中的所有文件\n+ <span class=\"strong\">-l 值</span>设置递归下载的深度，通常和-r选项搭配使用，如：-r -l 1表示只下载当前目录的文件\n+ -N 仅下载比本地文件新的文件(根据时间戳判断)，适合用来同步文件\n+ -nd 不创建目录结构，将所有下载的文件都保存到当前目录\n+ <span class=\"strong\">-i 文件名</span>从文件中读取URL，并依次下载\n+ <span class=\"strong\">-&zwnj;-wait=值</span>设置文件下载的时间间隔，避免对服务器造成过大负载\n+ -&zwnj;-random-wait 设置随机等待时间，模拟更自然的用户行为\n+ <span class=\"strong\">--tries=值</span> 设置下载失败后的重试次数，默认为20次\n\n<div class=\"show\">1. 正常下载文件\nwget http://example.com/file.zip\n默认情况下，wget命令会打印以下信息：\n--2021-08-31 00:12:34--  http://shiwivi.com/\nResolving shiwivi.com (shiwivi.com)... 170.196.108.153\nConnecting to shiwivi.com (shiwivi.com)|170.196.108.153|:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 3355 (3.3K) [text/html]\nSaving to: ‘index.html.1’\n100%[===================>] 3,355       --.-K/s   in 0.1s    \n2021-08-31 00:12:37 (23.3 KB/s) - ‘index.html.1’ saved [3355/3355]\n2. 静默模式\nwget -q http://example.com/file.zip\n</div>\n\n\n\n\n### bc计算器\nbash主要是用来处理文本命令的，数值运算能力较差，只支持一些基本的整形运算，进行浮点数运算通常要借助bc计算器。bc(Basic Calculator)是一个外部命令，通常位于<span class=\"tips\">/usr/bin/bc</span> 或 <span class=\"tips\">/bin/bc</span>路径下，一般情况下大多数 Linux 发行版默认都会包含这个工具，同时它也是一种编程语言，支持在命令行中进行浮点数运算，该语法支持：\n+ 基本算术运算：支持加、减、乘、除和取余等基本运算\n+ 浮点运算：默认情况下，bc执行整数运算，但通过设置小数点精度，可以进行浮点运算\n+ 简单的变量和数组\n+ 注释，以#和/* */为注释\n+ 逻辑和条件操作：支持逻辑运算符如<, >, ==, !=等，可以在脚本中使用if条件语句\n+ 循环：支持while和for循环，可以用来编写较为复杂的计算脚本\n+ 自定义函数\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nGNU社区的bc文档：<a href=\"https://www.gnu.org/software/bc/manual/html_mono/bc.html\">https://www.gnu.org/software/bc/manual/html_mono/bc.html</a></div>\n\n\n#### 命令\n<span class=\"strong\">bc [选项] [文件]</span>\n\n+ 默认情况下，bc命令进行整数运算，通过scale变量可以指定小数位数，进行浮点数运算，并且打开bc时默认会打印版本信息\n+ -q 安静模式，不打印版本信息、GNU提示信息，其长选项为-&zwnj;-quiet\n+ -l 加载数学库，可以使用sin、sqrt等数学函数\n\n#### 变量\nbc内部预定义了几个变量：\n##### 预定义变量\n\n<div class=\"table\">\n\n变量名|说明\n------|------\nscale|小数位数，默认为0\nibase|输入数值的进制，默认为10，该变量支持的值为2-16，输入的数字支持0-9和A-F，字母必须大写，小写用于声明变量名\nobase|输出数值的进制，默认为10\nlast |上一个打印的数值(GNU拓展)\n</div>\n\n##### 自定义变量\n+ 变量名以字母开头，后面可以是任意数量的字母、数字、下划线\n+ 变量名必须小写，大写字母被用来识别十六进制的数值输入\n\n\n#### 使用\n<div class=\"show\">1. 在命令行下，我们可以直接输入bc命令唤起bc计算器，通过<span class=\"tips\">quit</span>命令退出\n<div class=\"shell\">$ bc \nbc 1.06.95 \nCopyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc. \nThis is free software with ABSOLUTELY NO WARRANTY. \nFor details type 'warranty'. \n12 * 5.4 \n64.8</div>\n2. 在进行浮点数运算时，尤其进行除法运算，需要先设置内置变量<span class=\"strong\">scale</span>的值，它决定了计算结果保留的小数位数，默认为0\n<div class=\"shell\">$ bc -q \n3.44 / 5 \n0 #未设置scale值，导致运算结果无小数\nscale=4 \n3.44 / 5 \n.6880 \nquit</div>\n3. bc也支持<span class=\"strong\">变量</span>和<span class=\"strong\">print输出语句</span>\n在脚本中，可以使用命令替换来运行bc，常用格式如下：\n<span class=\"strong\">$(echo \"变量1;变量2..; 表达式\" | bc)</span>\n<div class=\"shell\">e.g.计算100/30并保留4位小数\nvar1=100\nvar2=30\nvar3=$(echo \"scale=4; $var1 / $var2\" | bc)\necho \"计算结果为：\" $var3\n</div>\n4. 如果需要大量运算，则可以借助内联重定向，一次输入多个数据，语法格式为：\n<div class=\"apiBox\">变量=$(bc &lt;&lt; EOF\n   变量1\n   变量2\n   运算1\n   运算2\n...\nEOF\n)</div>\n<div class=\"shell\">e.g.进行多项运算\nvar1=10.46 \nvar2=43.67 \nvar3=33.2 \nvar4=71 \nvar5=$(bc << EOF \nscale = 4 \na1 = ( $var1 * $var2) \nb1 = ($var3 * $var4) \na1 + b1 \nEOF \n) \necho \"最终结果为：\" $var5\n</div></div>\n\n### mkpasswd密码生成\nmkpasswd有两个同名软件，一个用来生成随机密码，一个用来加密用户密码\n\n#### 生成随机密码\nexpect 包中mkpasswd 用来生成指定长度的随机密码，可以指定密码中数字、大小写英文字母和特殊字符的个数\n##### 安装\nmkpasswd 是 expect 包中的一个脚本，使用前需要安装expect包\n\n+ Red Hat系列操作系统\n<pre><code>sudo yum install expect</code></pre>\n+ Debian系列操作系统\n<pre><code>sudo apt-get install expect</code></pre>\n\n##### 命令\n<span class=\"strong\">mkpasswd [选项]</span>\n+ -l 值：指定生成的密码长度，默认值为9\n+ -d 值：指定数字个数，默认值为2\n+ -c 值：指定小写字母的个数，默认值为2\n+ -C 值：指定大写字母的个数，默认值为2\n+ -s 值：指定特殊字符的个数，默认值为1\n\n<div class=\"show\">1. 随机生成一个20位的密码\nmkpassed -l 20\n2. 随机生成一个20位的密码，包含4位数字\nmkpasswd -l 20 -d 4\n</div>\n\n#### 加密用户密码\n whois 包中的 mkpasswd 是一个在 Linux 和 Unix 系统中生成加密密码的工具。它常用于加密用户密码，特别是在涉及到 /etc/shadow 文件或其他需要加密密码的场景下。mkpasswd 工具可以生成各种哈希算法加密的密码，如 MD5、SHA-256、SHA-512 等。\n\n##### 安装\n在一些 Linux 发行版中，mkpasswd 是 whois 包的一部分。如果系统上没有 mkpasswd，可以通过包管理器安装 whois 包：\n+ 基于 Red Hat 的系统（如 CentOS、Fedora）\n<pre><code>sudo yum install whois\n</code></pre>\n\n+ 基于 Debian 的系统（如 Ubuntu）\n<pre><code>sudo apt-get install whois</code></pre>\n\n##### 命令\n<span class=\"strong\">mkpasswd [选项] [密码] [盐值]\n</span>\n\n+ 可以输入一个需要加密的明文密码\n+ 盐值可选，可以添加到密码中以增强哈希的安全性\n+ 默认使用MD5算法\n+ -m 算法：指定一个加密算法，如：sha-512，sha-256，md5等\n\n<div class=\"show\">1. 使用 SHA-512 生成加密密码\nmkpasswd -m sha-512 mypassword\n2. 生成一个使用 SHA-512 加密的密码，并指定一个盐值\nmkpasswd -m sha-512 \"password123\" \"randomsalt\"\n</div>\n\n### time\nlinux中的time命令通常提供了两个，一个是bash内置的time命令，用来查看目录所消耗的时间。还有一个为外部工具，命令路径为<span class=\"tips\">/usr/bin/time</span>，功能更为强大，可以查看命令所消耗的资源，包括内存使用情况\n\n通过type命令可以看到两个命令的来源\n<div class=\"shell\">[root@Linux ~]# type -a time\ntime is a shell keyword\ntime is /usr/bin/time\n</div>\n\n#### bash内建的time\n<span class=\"strong\">time [选项] 命令</span>\n+ -o 文件名：将输出写入指定文件，如果已有该文件则覆盖\n+ -a 配合-o使用，将命令输出追加到文件末尾，而不是覆盖\n+ -p 以POSIX标准格式输出时间信息\n\n<div class=\"show\">查看ls命令所消耗的时间\ntime ls\n输出值为：\nreal\t0m0.002s  #真实时间\nuser\t0m0.002s  #用户时间\nsys\t0m0.000s      #系统时间\n</div>\n\n#### 外部time工具\n\n<span class=\"strong\">/usr/bin/time [选项] 命令</span>\n+ -o 文件名：将输出写入指定文件，如果已有该文件则覆盖\n+ -a 配合-o使用，将命令输出追加到文件末尾，而不是覆盖\n+ -p 以POSIX标准格式输出时间信息\n+ -v 详细输出命令所消耗的时间、内存等信息\n\n<div class=\"show\">查看命令所消耗时间的输出信息与bash内置的time命令一样，但bin目录下的time工具额外提供了-v选项用来详细输出系统资源消耗\n/usr/bin/time ls\n输出值通常包括时间、最大内存使用、进程数量、页面错误、退出状态码等\nCommand being timed: \"ls\"\n\tUser time (seconds): 0.00\n\tSystem time (seconds): 0.00\n\tPercent of CPU this job got: 100%\n\tElapsed (wall clock) time (h:mm:ss or m:ss): 0:00.00\n\tAverage shared text size (kbytes): 0\n\tAverage unshared data size (kbytes): 0\n\tAverage stack size (kbytes): 0\n\tAverage total size (kbytes): 0\n\tMaximum resident set size (kbytes): 1116\n\tAverage resident set size (kbytes): 0\n\tMajor (requiring I/O) page faults: 0\n\tMinor (reclaiming a frame) page faults: 336\n\tVoluntary context switches: 1\n\tInvoluntary context switches: 1\n\tSwaps: 0\n\tFile system inputs: 0\n\tFile system outputs: 0\n\tSocket messages sent: 0\n\tSocket messages received: 0\n\tSignals delivered: 0\n\tPage size (bytes): 4096\n\tExit status: 0\n</div>","tags":["Linux"]},{"title":"Linux信息检索与处理","url":"/blog/2021/12/29/Linux信息检索与处理/","content":"### 数据处理\n#### grep数据查找\ngrep命令用于在指定内容或文件中查找满足匹配模式的字符的行，其输出是满足匹配模式的字符串行。该命令功能强大，支持Unix风格的正则表达式，是最常用的命令之一。\n\n<span class=\"strong\">grep [参数] 匹配模式 [文件]</span> 找到或排除字符串所在行，然后输出内容\n\n+ -i &emsp;不区分大小写\n+ -v &emsp;排除指定字符串\n+ -n &emsp;显示匹配内容的行号\n+ -c &emsp;显示有多少行满足匹配\n+ -e &emsp;指定多个匹配条件\n\n<div class=\"show\">示例:\n# grep man /etc/file\n找到/etc/file文件中含有man的行并输出\n# grep -v ^# /etc/inittab\n显示/etc/inittab中除了#开头的所有行内容(#开头的内容为被注释了的内容，不想看注释)\n</div>\n\n\n#### sort排序处理\n默认情况下，sort命令按照会话指定的默认语言的排序规则对文本数据行排序，且数字也会被当作字符处理(如果要按数值排序，使用-n选项)\n<span class=\"strong\">sort [选项] [文件名]</span>\n将文件或命令结果进行排序，默认以每行第一个字母为依据，按字母顺序排序\n\n+ -f&emsp;忽略大小写\n+ -n&emsp;将数字作为值处理，按数值大小进行排序\n+ -r&emsp;反向排序\n+ -t&emsp;指定分隔符为分段依据\n+ -M&emsp;按月份排序，常用于日志文件排序\n+ -k n,m&emsp;指定字段为排序依据，若不指定m则判断依据为以n字段开始到本行末\n\n<div class=\"show\">示例：\nsort /etc/passwd\n按passwd文件每行首字母进行排序显示\nsort -n -t \":\" -k 3,3 etc/passwd\n指定字段以:分隔，按第3字段(UID)值大小进行排序显示\n</div>\n\n以下为可能用到的完整命令选项及其缩写\n<div class=\"table\">\n\n命令缩写|完整命令|说明\n-------|--------|--------\n-b|-&zwnj;-ignore-leading-blanks|排序时忽略起始的空白\n-c|-&zwnj;-check |检查输入的数据或文件是否已排序，如果未全部排序，则打印第一个未排序的行，并以状态码1退出\n-C|-&zwnj;-check=quiet |检查输入的数据或文件是否已排序，如果未全部排序，以状态码1退出，但不打印未排序的行内容\n-d|-&zwnj;-dictionary-order |以通讯录方式排序，只考虑空白字符、字母、数字进行排序，忽略其他所有字符\n-f|-&zwnj;-ignore-case |默认情况下，大写字母排于小写字母前，这个选项会忽略大小写\n-g|-&zwnj;-general-number-sort |按数字排序(GNU建议只有别无选择时再使用该选项)，该选项会将每行数字前缀部分转换为双精度浮点数，按照：非数字开头的行、NaNs(Not a Number)、负数、正数的顺序排序(该选项处理速度比-n选项慢得多，且可能在转换浮点数时丢失信息)\n-h|-&zwnj;-human-numeric-sort|按照人类可读的数字格式排序，即该选项会识别KMGTPEZYRQ等数值单位，如:1023M将排序于1G之前\n-i|-&zwnj;-ignore-nonprinting |在排序时忽略非打印字符\n-k pos1,pos2|-&zwnj;-key=POS1[,POS2] |排序从POS1位置开始；如果指定了POS2的话，到POS2位置结束\n-M|-&zwnj;-month-sort| 用三字符月份名按月份排序，如：Jan,Feb,Mar\n-m|-&zwnj;-merge |合并多个多个已排序的文件，合并后的文件也是按顺序排序的，该选项会视为原文件已经排序好，只负责两个文合并时的归并排序，而不会会文件重排，速度更快\n-n|-&zwnj;-numeric-sort |按字符串数值来排序（并不转换为浮点数）\n-o|-&zwnj;-output=file |将排序结果写出到指定的文件中\n-R|-&zwnj;-random-sort |对输入的值进行哈希处理，按生成的哈希值排序\n 无 |-&zwnj;-random-source=FILE |指定-R参数用到的随机字节的源文件\n-V|-&zwnj;-version-sort|按版本号排序，字母加数字组合将识别为版本号，且排序方法将与小数排序有所不同，如：v1,v1.4,v1.12,v1.40,v2\n-r|-&zwnj;-reverse |反序排序（升序变成降序）\n-S|-&zwnj;-buffer-size=SIZE| 指定使用的内存大小\n-s|-&zwnj;-stable |禁用最后重排序比较\n-T|-&zwnj;-temporary-directory=DIR |指定一个位置来存储临时工作文件\n-t|-&zwnj;-field-separator=SEP |指定一个用来区分键位置的字符\n-u|-&zwnj;-unique |和-c参数一起使用时，检查严格排序；不和-c参数一起用时，仅输出第一例相似的两行\n-z|-&zwnj;-zero-terminated |用NULL字符作为行尾，而不是用换行符\n</div>\n\n#### shuf随机排列(shuffles)\n该命令可以用来随机输出指定的文本，也可以用来生成随机值\n\n<span class=\"strong\">shuf [选项] [文件]</span>\n\n+ -e 将每个输入的参数都视为一个本文行\n+ -i 最小值-最大值：随机生成该区间之间的值(无符号整数)\n+ -n 值：指定输出次数，默认为输入多少个文本，就输出多少次\n+ -o 文件名：将输出结果写入到文件中，而不打印到屏幕\n+ -r 生成的随机行可以重复\n+ -z 行结束符为NUL，而非默认的换行符\n\n<div class=\"show\">1.抽奖系统(根据名单)\nshuf &gt;&gt;EOF\nname1\nname2\nname3\nEOF\n该命令等价于\nshuf -e name1 name2 name3\n以上命令会将输入的字符串按随机顺序输出，如果限制为只输出1个，则命令修改为：\nshuf -n 1 -e name1 name2 name3\n2. 随机抛5次硬币\nshuf -r -n 5 -e \"正面\" \"反面\"\n3.随机2-10之间的值\nshuf -i 2-10\n</div>\n\n#### uniq删除邻近重复行(uniquify)\n该命令用来用于从输入中删除相邻的重复行，只保留一个副本\n\n<span class=\"strong\">uniq [选项] [输入文件] [输出文件]</span>\n\n+ 默认情况下，命令会打印输入的行，如果有相邻的重复行，则只输出一次，如果未指定输出文件，默认打印到屏幕\n+ -c 在每行开头打印该行重复次数\n+ -d 只打印邻近重复的行，但每行只打印一次\n+ -D 只打印邻近重复的行，该行重复几次就打印几次\n+ -f 值n：跳过对每行前n个字段的比较，忽略每行前n个字段的重复\n+ -i 忽略大小写\n+ -s 值n：跳过对每行前n个字符的比较\n+ -u 只打印非重复的行，包括两个重复，但不相邻的行\n+ -z 将行结束符替换为NUL，而非默认的换行符\n+ -w 值n：只对每行前n个字符进行比较\n\n#### comm逐行比较两个排序好的文件\n\n<span class=\"strong\">comm [选项] 文件1 文件2</span>\n\n+ 默认情况下，命令会生成三列输出，第一列为文件1独有的行，第二列为文件2独有的行，第三列为文件1和文件2共有的行\n+ -1或-2或-3选项，可以禁止打印对应的列\n+ -&zwnj;-check-order 检查输入的文本行是否是已经排序过的，如果任一文件排序错误则报错并退出\n+ -&zwnj;-nocheck-order 不检查文件是否排序\n+ -&zwnj;-output-delimiter=\"字符串\":替换所输出三列信息之间的分隔字符串，默认为Tab\n\n### 区域操作\n#### cut打印文本行的指定部分\n<span class=\"strong\">cut [选项] [文件名]</span>\n\n+ 以下选项的值可以为单个数字，也可以为范围(如：2-5)，也可以为不完整的范围，如：-m表示1-m，n-表示该行第n个到该行结束\n+ -b 值：仅打印行中指定字节的内容\n+ -c 值：仅打印行中指定个数的字符内容\n+ -f 值：仅打印行中指定字段的内容\n+ -d 字符：指定输入内容的字段分隔符，默认为Tab\n+ -s 搭配-f使用，不打印不包含字段分隔符的行，默认情况下会打印\n+ -&zwnj;-output-delimiter=\"字符\"：搭配-f使用，指定输出内容的字段分隔符\n+ -n 不要拆分多字节字符\n+ -&zwnj;-complement 搭配-b、-c、-f选项使用，不打印这些区间之间的内容\n\n<div class=\"show\">1. 打印第2-5个字符\ncut -c2-5 test.txt\n2. 打印前3个字符\ncut -c-3 test.txt\n</div>\n\n#### paste合并文件行\n<span class=\"strong\">paste [选项] [文件名1] [文件名2]...</span>\n\n+ 默认情况下，该命令会将多个文件的第一行都粘贴到第一行，第二行都粘贴到第二行，以此类推，同一行内容之间使用tab分隔\n+ -s 将文件1的内容都粘贴到第一行，文件2内容粘贴到第二行，以此类推\n+ -d \"字符1字符2..\"：使用指定的字符作为内容分隔符，可以指定多个字符，文件合并后的内容将写为：文件1字符1文件2字符2\n\n<div class=\"show\">e.g.文件num.txt内容为\n1111\n2222\n3333\n文件test.txt内容为\nAAAA\nBBBB\n1. 合并文件num.txt与test.txt\npaste test.txt num.txt\n合并后为：\nAAAAA\t1111\nBBBBB\t2222\n\t    &emsp;&emsp;3333\n2. -s选项\nAAAAA\tBBBBB\n1111&emsp;\t2222\t3333\n3. -d选项\npaste -d \"%-\" test num test\n合并后为：\nAAAAA%1111_AAAAA\nBBBBB%2222_BBBBB\n%3333_\n</div>\n\n#### join 按字段合并文件\n以某个字段作为合并依据，合并两个文件的内容，默认是按第一个字段进行匹配，通常会先使用 sort 对文件进行排序再进行合并\n\n<span class=\"strong\">join [选项] 文件1 文件2</span>\n\n+ 默认情况下，命令会比较两个文件中的第一个字段的内容，如果两个文件第一个字段内容相同，则合并输出该行的剩余部分，输出默认使用空格分隔\n+ -1 字段号：修改文件1作为匹配依据的字段，默认是第一个字段\n+ -2 字段号：修改文件2作为匹配依据的字段，默认是第一个字段\n+ -j 字段号N：等价于-1 N -2 N\n+ -o 字段号：指定输出哪些字段，0代表整行\n+ -t 分隔符：指定字段分隔符，默认为空格\n+ -i 比较时忽略大小写\n+ -a 1或-a 2：输出文件1或文件2中未匹配到的行\n+ -e \"字符串\"：指定在某个字段缺失时，用哪个字符串代替\n+ -v 1或-v 2：仅显示文件1或文件2中未匹配的行\n+ -&zwnj;-check-order：如果任一输入文件排序错误，则失败并显示错误消息\n+ -&zwnj;-nocheck-order：不检查两个输入文件是否按排序顺序排列(默认)\n+ -&zwnj;-header：将输入文件的第一行视为标题行，并合并打印到第一行\n\n<div class=\"show\">e.g.文件file1：\na 1\nb 2\ne 5\n文件file2：\na X\ne Y\nf Z\n1. 输出第一个字段相同的行\njoin file1 file2\n输出值：\na 1 X\ne 5 Y\n2. 指定哪些字段需要输出，0表示整行都输出\njoin -o 1.2 2.2 file1 file2\n3. 输出没有匹配到的行。如果使用 -a 1，将输出文件1中所有未匹配到的行\njoin -a 1 file1 file2\n</div>\n\n### sed流编辑器\n#### 简介\nsed被称为流编辑器（stream editor），是Linux和Unix系统中一个强大的文本处理工具。它被设计用于大批量的文本处理，可以逐行读入文本，并根据命令进行字符串的查找、筛选、移动、替换、添加和删除等操作。sed非常适合对大量文本进行批处理，也适合在脚本中进行自动化文本处理。\n\n与交互式编辑器(如vim)不同，vim等编辑器适合用来进行交互式编辑和细粒度的文本修改，而流编辑器适合用来进行大批量的非交互式文本处理，适合执行自动化文本处理任务，如进行批量文件修改、数据清洗、日志文件分析等。\n\n##### sed的工作流程\n\nsed强调逐行处理文本，默认情况下，sed编辑器会基于换行符的位置将文本流分成行，以一行文本作为一个处理单位，sed编辑器对文本的处理会在一个名为<span class=\"tips\">模式空间</span>(pattern space)的临时缓冲区中进行，sed编辑器在工作时会依次执行以下流程：\n+ <span class=\"strong\">读取</span>：sed首先会从文件、管道、标准输入等输入流中读取一行内容并存储到模式空间\n+ <span class=\"strong\">执行</span>：根据用户提供的命令在行中匹配数据，并按照命令增删改查，默认情况下，所有sed操作命令会在模式空间中按顺序执行\n+ <span class=\"strong\">打印</span>：字符串行在模式空间中被处理完后，默认会将结果输出到屏幕，然后清空模式空间，然后读取下一行文本\n\n具体执行过程为：sed首先会从输入流中(可以是来自文件、管道、标准输入设备的文本流)读取一行内容并存储到模式空间，然后按照命令顺序对满足要求的文本进行处理，不满足要求的文本也会被读入模式空间，但sed不做任何处理，随后这些文本会被发送到输出流显示给用户，sed编辑器会随之清空模式空间中的内容，然后读取下一行文本重复执行上述操作，直到文本流中的所有行被处理完毕。默认情况下，sed命令会对所有行都生效，但可以通过指定行号、模式匹配等方式指定命令只对某些行生效，sed编辑器默认会将所有文本行输出到屏幕，即便编辑器没有修改任何原文本的内容(如：指定某个命令只对第2行文本生效，但其他行的内容依旧会被sed编辑器打印到屏幕上)，且sed命令的文本处理操作都是在缓冲区中进行的，默认不会对原文件内容进行修改。sed编辑器还支持将操作命令存储于一个单独的文件(通常拓展名为<span class=\"tips\">.sed</span>)中，然后从文件中批量加载命令。\n\n#### sed命令\n<span class=\"strong\">sed [选项] '文本处理命令' [处理的文件]</span>\n\n+ -e 命令：指定多个命令\n+ -f 文件名：从该文件中载入处理命令\n+ -n 不打印命令的默认输出\n+ -i 直接修改原文件，不输出到终端\n+ -r 支持拓展的正则表达式，某些版本中为-E，具体可以man sed查看支持哪一个选项\n+ 如果不指定处理文件，sed会从标准输入STDIN读取数据\n+ 文本处理命令如果直接在命令行中指定，则需要加上一对单引号<span class=\"strong tips\">' '</span>，这样shell就不会将其解析为shell的特殊字符或命令，并且shell会将其视为sed命令的单个参数，允许文本处理命令的长度超过一行，如果写于文件中则不需要使用单引号。如果sed文本处理命令中需要调用外部变量，也可以使用双引号<span class=\"tips\">\"\"</span>\n\n##### 文本处理命令\n文本处理命令是sed命令的关键部分，告诉sed编辑器要处理哪些文本，以及如何处理文本。sed可以输入单个命令，也支持一次性指定多个命令，它会依次执行这些命令。\n\n<span class=\"strong\">单行模式</span>下，多个命令之间使用分号<span class=\"tips strong\">;</span>分隔即可\n<div class=\"show\">e.g.文件test.txt包含以下内容，使用字符串\"周杰伦\"替换\"Jay Chou\"，使用\"陈奕迅\"替换\"Eason Chan\"\nThese are my favorite singers Jay Chou and Eason Chan\nThese are my favorite singers Jay Chou and Eason Chan\nThese are my favorite singers Jay Chou and Eason Chan\n单行模式下指定多个命令，命令之间使用分号分隔\n<span class=\"text-red\">sed 's/Jay Chou/周杰伦/; s/Eason Chan/陈奕迅/' test.txt</span>\n也可以使用<span class=\"tips\">-e</span>选项，分开指定命令，使命令更具可读性和清晰度\n<span class=\"text-green\">sed -e 's/Jay Chou/周杰伦/' -e 's/Eason Chan/陈奕迅/' test.txt</span>\n</div>\n\n<span class=\"strong\">多行模式</span>下，命令之间的分号可以省略\n<div class=\"show\">多行模式下指定多个命令，可以不使用分号，但单引号必须保留\n<span class=\"text-blue\">sed '\n&gt;s/Jay Chou/周杰伦/\n&gt;s/Eason Chan/陈奕迅/' test.txt</span>\n</div>\n\n<span class=\"strong\">从文件调用：</span>如果处理命令较多或需要反复调用，可以将这些命令写于一个命令文件中，每条命令写一行，sed编辑器会将每行都识别为一个单独的命令。存放sed命令的文件通常使用<span class=\"tips\">.sed</span>作为文件扩展名，然后通过<span class=\"tips\">-f</span>选项输入sed编辑器，命令之间的分号可以省略，且命令不使用单引号包裹\n\n<div class=\"show\"><span class=\"text-red\">sed -f script.sed test.txt</span>\n<span class=\"strong\">script.sed文件内容：</span>\ns/Jay Chou/周杰伦/\ns/Eason Chan/陈奕迅/\n</div>\n\n\n##### 文本输入方式\n不指定处理文件时，sed会从标准输入STDIN读取数据，在输入完sed命令后按下回车，sed编辑器会开始等待文本输入，每输入一行文本sed编辑器就处理一行，并实时打印处理结果，直到使用Ctrl+D结束输入，或使用Ctrl+C终止任务。\n\n<div class=\"show\">e.g.将所输入字符串中的A替换为a\nsed 's/A/a/' <span class=\"text-red\">(回车)</span>\nAjax   <span class=\"text-blue\">#用户输入</span>\najax   <span class=\"text-green\">#sed编辑器输出结果</span>\nAPACHE <span class=\"text-blue\">#用户输入</span>\naPACHE <span class=\"text-green\">#sed编辑器输出结果</span>\n<span class=\"text-red\">(Ctrl+D结束输入，退出sed编辑器)</span>\n</div>\n\n也可以通过管道符<span class=\"tips\">|</span>将文本输入sed编辑器\n\n<div class=\"show\">如果直接在sed命令行输入文本，sed编辑器会将其识别为文件名，然后返回错误：No such file or directory\n因此，通过以下语句输入文本到sed编辑器中的方法都是错误的：\nsed 's/A/a/' Ajax\nsed 's/A/a/' \"Ajax\"\n如果需要直接用sed编辑器处理单行或多行文本，可以考虑使用管道符：\ne.g.使用s命令将输出中的old替换为not old，s命令的功能是使用斜线后的第二个字符串替换第一个字符串\necho \"This is old song\" | sed 's/old/not old/'\n</div>\n\n当需要处理大量文本时，可以将文本写入文件中，sed命令会以每行作为一个单位，依次读取文件内容并处理，<span class=\"tips\">但注意：默认情况下，Sed编辑器只会将模式空间中处理完毕的数据发送到屏幕STDOUT，而不会修改原文件中的数据</span>\n\n<div class=\"show\">e.g.从文件test.txt读取内容并进行文本操作\nsed 's/A/a/' test.txt\n</div>\n\n#### 字符转义\n由于在sed命令中，斜线<span class=\"tips\">/</span>被用作命令字符串的分隔符，因此如果在命令中包含了诸如文件路径等需要用到斜线的参数，需要使用转义字符<span class=\"tips\">\\\\</span>对其进行转义。此外，sed编辑器也支持使用其他字符作为替换命令中的字符串分隔符，如使用<span class=\"tips\">?</span>、<span class=\"tips\">!</span>等\n\n<div class=\"show\">e.g.用C shell替换/etc/passwd文件中的bash shell\nsed -n 's?/bin/bash?/bin/csh?p' /etc/passwd\n或\nsed -n 's!/bin/bash!/bin/csh!p' /etc/passwd\n也可以使用转义字符\nsed -n 's/\\/bin\\/bash/\\/bin\\/csh/p' /etc/passwd\n</div>\n\n#### 在sed中调用外部变量\n如果在使用sed时需要调用环境变量，或者在shell脚本中，sed要调用脚本中定义的变量，需要注意以下：\n+ 由于单引号中无法调用变量，因此sed的命令部分需要使用双引号<span class=\"tips\">\"\"</span>来包裹，这样才能使用<span class=\"tips\">$变量名</span>来调用变量\n+ 如果变量中包含<span class=\"tips\">/</span>等字符，需要将sed命令的分隔符修改为其他字符\n\n<div class=\"show\">e.g.需要在sed命令中调用PATH变量\n由于PATH环境变量的值包含/，如：\nPATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin\"\n如果直接执行命令：\nsed \"s/aaa/${PATH}/\" config.json\nsed会将PATH值中的/解析为命令字符串分隔符，从而出错，需要将sed命令修改为：\nsed \"s|aaa|${PATH}|\" config.json\n</div>\n\n#### 通过-i选项修改文件\n相较于awk，sed编辑器提供了<span class=\"tips\">-i</span>(in-place)选项可以直接修改原文件内容，完整的语法格式为：\n<span class=\"strong\">sed -i[备份文件名] '文本处理命令' 原文件</span>\n+ 指定-i选项后，所有sed处理完的文本流将被重定向到文件中，而不再打印到屏幕。此时即便再添加p等打印命令，也不会输出任何内容到屏幕，反而会多输出一行相同内容到文件，因此修改文件时不要使用p等打印命令，除非明确需要打印行号等信息到文件\n+ -i选项可以接收一个字符串参数，此时sed会将原文件以<span class=\"tips\">原文件名备份文件名</span>作为文件名，进行一次备份，然后再修改原文件\n\n<div class=\"show\">e.g.将原文件data.txt备份一份为data.txt.bak，然后修改data.txt文件中的aaa为bbb，\nsed -i.bak 's/aaa/bbb/g' data.txt\ne.g.修改配置文件中的端口号\n<span class=\"strong\">config.json文件：</span>\n{\n        \"ip\": \"88.77.99.88\"\n        \"port\": 2100,\n}\n<span class=\"strong\">modifyPort.sh文件：</span>\n#!/bin/bash\nconfigFile=\"/usr/local/myServer/config.json\"\nnewPort=2200\nif [ -f \"${configFile}\" ];then\nsed -i[.bak] \"/port/s/\\([^0-9]*\\)[0-9]*\\(.*\\)/\\1${newPort}\\2/\" ${configFile}\nfi\n</div>\n\n#### 行寻址\n默认情况下，sed编辑器的命令会作用于文本数据的所有行。如果只想将命令作用于某些特定行，则可以用行寻址，行寻址的方式有两种：\n+ 用数字指定行号\n+ 使用正则表达式进行模式匹配\n\n两种方式的语法都相同，直接将行地址加于命令前即可：\n<span class=\"strong\">sed '<span class=\"text-blue\" style=\"margin:0;\">行地址</span><span class=\"text-green\" style=\"margin:0;\">命令</span>' [文件名]</span>\n如果需要为某个地址指定多个命令，可以使用大括号进行分组：\n<span class=\"strong\">sed '<span class=\"text-blue\" style=\"margin:0;\">行地址</span>{<span class=\"text-green\" style=\"margin:0;\">命令1</span>;<span class=\"text-green\" style=\"margin:0;\">命令2</span>;.....}' [文件名]</span>\n\n##### 使用数字指定行号\nsed编辑器会将文本的第一行的行号设定为1，随后依次递增，可以直接使用行号指定命令在哪些行生效。可以直接使用单个行号，也可以通过<span class=\"tips\">起始行,终止行</span>的方式选定一个区间，如果不清楚某个文件到底有多少行，可以使用<span class=\"tips\">起始行,$</span>方式选定从某行开始的所有行。\n\n<div class=\"show\">e.g.替换data.txt文件中第二行的指定字符串\nsed '2s/AAA/替换内容/' data.txt\n替换2到4行的匹配字符串\nsed '2,4s/AAAA/替换内容/' data.txt\n替换第2开始的所有行中的匹配的字符串\nsed '2,$s/AAAA/替换内容/' data.txt\n</div>\n\n##### 使用正则表达式匹配行\n使用行号只能选取特定位置的行，如果需要根据内容筛选出对应行，如查找包含指定内容的行，并对该行进行处理，则需要使用正则表达式筛选出指定行，其语法为：\n<span class=\"strong\">sed '<span class=\"text-blue\" style=\"margin:0;\">/正则表达式/</span><span class=\"text-green\" style=\"margin:0;\">命令</span>'</span>\n\n也可以指定一个区间：\n<span class=\"strong\">sed '<span class=\"text-blue\" style=\"margin:0;\">/正则表达式1/,/正则表达式2/</span><span class=\"text-green\" style=\"margin:0;\">命令</span>'</span>\n\n命令会在正则表达式1匹配到内容时，从该行开始执行(开启命令执行)，直到正则表达式2匹配到内容的行为止(关闭命令执行)，如果只匹配到正则表达式1(开启)，而正则表达式2无匹配的行，那么文件该行以后的所有行都将执行该命令(无关闭)\n\n\n<div class=\"show\">e.g.选取data.txt文件中包含2222字符串的行，并替换该行中AAAA字符串为替换内容\nsed -n '/2222/s/AAAA/替换内容/p' data.txt</div>\n\n<div class=\"show\">e.g.文件data.txt含以下内容\n1111AA\n2222AA\n3333AA\n4444AA\n5555AA\n6666AA\n替换含字符串22行开始，到含字符串44行为止，中间所有行中的AA字符串为aa\nsed '/22/,/44/s/AA/aa/' data.txt\n输出为：\n1111AA\n2222aa\n3333aa\n4444aa\n5555AA\n6666AA\n如果将开始行和末尾行替换，命令将从第4行开始，一直执行到文件末\nsed '/44/,/22/s/AA/aa/' data.txt\n输出为：\n1111AA\n2222AA\n3333AA\n4444aa\n5555aa\n6666aa\n</div>\n\n<span class=\"strong tips\">命令分组：</span>如果为指定的行要执行多个命令，则可以使用大括号<span class=\"tips\">{ }</span>将命令分组\n\n<div class=\"show\">e.g.替换data.txt文件中的多个不同内容\nsed '2,${\n&gt; s/AAAA/替换内容/\n&gt; s/BBBB/OvO/\n}' data.txt\n</div>\n\n#### 打印命令p、=、l\nsed提供了3个打印命令用于打印不同的信息：\n+ <span class=\"strong\">p</span>：打印文本行\n+ <span class=\"strong\">=</span>：打印行号\n+ <span class=\"strong\">l</span>：(小写L)打印文本和非打印字符(如制表符等)\n\n##### 打印文本\n打印命令p用于打印匹配到的字符串行。默认情况下，sed命令也会将模式空间中的内容打印到屏幕，因此通常将p命令与sed命令的-n选项搭配使用。先使用-n选项禁止sed命令的默认输出，再执行p命令打印匹配的字符串，这样终端上就只会显示我们需要的信息。\n\n<div class=\"show\">e.g.打印包含指定字符串的行\n<span class=\"strong\">data.txt文件内容：</span>\n1111AAA111\n2222AAA222\n3333333333\n如果直接执行命令\nsed '/AAA/p' data.txt\n则会输出显示以下内容：\n1111AAA111 #p命令打印\n1111AAA111 #sed编辑器默认打印\n2222AAA222 #p命令打印\n2222AAA222 #sed编辑器默认打印\n3333333333 #sed编辑器默认打印\n内容会被重复打印，即便文件第3行不包含字符串AAA，不满足命令执行要求，该行内容依旧会被sed编辑器读入模式空间，然后被默认打印出来，而满足执行要求的第一第二行文本则会打印两遍(p命令打印+sed默认打印)，因此，p命令通常会和-n选项搭配使用，使用-n取消sed编辑器的默认打印行为，然后使用p命令打印满足要求的字符串行：\nsed -n '/AAA/p' data.txt\n这样，sed编辑器输出值就是满足命令处理要求被筛选过的字符串行：\n1111AAA111 \n2222AAA222\n</div>\n\n\n\n<div class=\"show\">e.g.打印文件的某几行\nsed -n '2,3p' data.txt\n打印文件中包含某字符串的行\nsed -n '/AAA/p' data.txt\n通过p命令可以先打印字符串行被修改前的样子，再打印一次被修改后的养样子，方便比较\nsed -n '/AAA/{\n&gt;p\n&gt;s/AAA/aaa/p\n&gt;}' data.txt\n</div>\n\n##### 打印行号\n等号命令<span class=\"tips\">=</span>会打印行在数据流中的当前行号。行号由数据流中的换行符决定。每次数据流中出现一个换行符，sed编辑器会认为一行文本结束了，行号默认从1开始。\n\n<div class=\"show\">e.g.打印包含某字符串的行号，及其该行的完整内容\nsed -n '/AAA/{\n&gt;=\n&gt;p\n}' data.txt\n</div>\n\n##### 打印非打印字符\n列出命令<span class=\"tips\">l</span>(list)会打印数据流中的所有文本和不可打印的ASCII字符，这些非打印字符会以C语言转义字符的形式显示(如：\\t水平制表符)，或显示其八进制ASCII码值，并会在前面添加反斜线。\n\n<div class=\"show\">e.g.打印文件data.txt，文件内容包含\\\n<span class=\"strong\">data.txt文件内容：</span>\n1111    1111\n2222 \\  2222\n命令l会将制表符、\\等需要转义的字符在文本中输出为转义字符形式，并使用$表示末尾换行\nsed 'l' data.txt\n输出形式为：\n1111\\t1111$\n2222\\\\2222$\n</div>\n\n#### 替换命令s\n替换命令<span class=\"tips\">s</span>可以将文本行中的指定字符串替换为其他字符串，语法格式为：\n<span class=\"strong\">sed '[行地址]s/替换前的字符串/替换后的字符串/标记符' </span>\n\n##### 匹配数量\n默认情况下，s命令只会替换每行中出现的第一个匹配字符串。要想让编辑器处理当前行中其他位置的字符串，需要使用标记符：\n\n<spa class=\"tips\">命令/匹配字符串/替换字符串/标记符</spa>\n\n标记符可以为以下字符：\n+ 数字：表示替换该行中的第几处匹配的字符串\n+ g：表示替换该行中所有字符串\n+ p：打印替换过的内容到屏幕\n+ w 文件名：将修改完的字符串行另存到文件中，只会保存匹配到的行\n\n<div class=\"show\">e.g.假设文件data.txt中有以下内容\n<span class=\"strong\">data.txt</span>\n111AAA111BBB111AAA\n222AAA222BBB222AAA\n333AAA333BBB333AAA\nso live a life you will remember\n1. 替换文件中每行第2个字符串AAA为替换内容\nsed 's/AAA/替换内容/2' data.txt\n2. 默认情况下，上述命令会将替换完的完整文件内容输出到屏幕，包括第4行没有AAA内容的文本，如果只想输出匹配到行，则需要搭配-n选项和p标记符\nsed -n 's/AAA/替换内容/2p' data.txt\np标记符用于输出匹配到的字符串行，如果没有-n选项，由于sed命令本身默认就会输出完整文件内容，加上p选项输出的匹配内容，因此会输出完整文件内容+匹配内容，匹配到的部分会输出两遍，因此需要使用-n取消掉sed命令的默认输出，只输出内容被修改的部分\n3. 如果要先输出一行原文件内容，再输出一行被替换的内容，二者一上一下以作比较，可以使用以下命令\nsed -n -e 's/AAA/&/p' -e 's/AAA/替换内容/p' data.txt\n4. 将替换的内容另存到另外一个文件\nsed 's/AAA/替换内容/w result.txt' data.txt\n上述命令依旧会输出默认的完整文件到屏幕，但w标记符只会将替换过到的第1，2，3行保存到文件，没有AAA字符串的第4行将不被另存\n</div>\n\n#### 删除行d\nsed编辑器中的<span class=\"tips\">d</span>(delete)命令用于删除特定的行，它会根据匹配到的信息删除对应行，并且支持寻址。注意，如果d命令没有指定任何匹配内容，则默认会删除所有行。同样，d命令不会修改原文件，只是将经过删除处理后的文本内容打印到屏幕。d命令的语法为：\n<span class=\"strong\">sed '地址d' [文件名]</span>\n\n<div class=\"show\">e.g.文件data.txt中包含以下内容\n<span class=\"strong\">Line 1 AAAAAA</span>\nLine 1 AAAA\nLine 2 BBBB\nLine 3 CCCC\nline 4 AAAA\nline 5 DDDD\nmore line\n1. 可以通过行号删除指定行\nsed '2,4d' data.txt\n2. 也可以根据正则表达式匹配内容删除指定行\nsed '/AAAA/d' data.txt\n3. d命令可以通过两个正则表达式来指定一个区间，然后删除区间之间的行。这是d命令的特殊用法，注意，使用该功能时，指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能\nsed '/Line 1/,/Line 3/d' data.txt #删除第1，2，3行\n如果d命令再次匹配到满足要求的行，删除功能会再次打开，<span class=\"text-red\">如果没有匹配到关闭删除的字符串，d命令有可能会删除后续整个文件内容！</span>\nsed '/AAAA/,/CCCC/d' data.txt\n# sed会首先删除匹配到的包含AAAA到CCCC之间的行，即第1，2，3行，而后第4行再次匹配到了AAAA，于是删除功能再次打开，由于后续再无匹配到CCCC，删除功能一直继续，直到将文件内容删除完\n</div>\n\n#### 插入和附加行i&&a\nsed编辑器也支持加入新的行，两个操作分别为：\n+ <span class=\"tips\">i</span>(insert)命令会在指定行前插入一个新行\n+ <span class=\"tips\">a</span>(append)命令会在指定行后增加一个新行\n两个命令的语法都为：\n<div class=\"apiBox\">sed '[地址] 命令\\新增行的内容' [文件名]</div>\n也可以同时插入多行，每行内容使用反斜线分隔：\n<div class=\"apiBox\">sed '[地址] 命令\\\n&gt;新增的第一行\\\n&gt;新增的第二行' [文件名]</div>\n\n对诸如echo语句等单行命令前插入内容时，可以不指定地址。而在文件中插入新行，需要使用行号或正则表达式为其指定一个插入位置，但不支持地址区间，即只能将新增的行插入和附加到单个行前或行后，而不支持插入某个区间前后\n\n<div class=\"show\">e.g.如果在单行命令中插入文本，可以不指定地址\necho \"这是一段文本\" | sed 'i\\插入的新行'\n在文件第一行前插入内容\nsed '1i\\新增行内容' data.txt\n在文件最后一行后附加内容\nsed '$a\\新增行内容' data.txt\n也可以使用正则表达式匹配包含指定内容的行，这会将内容插入所有满足要求行的前后\nsed '/AAAA/i\\新增的行' data.txt\n也可以同时插入多行内容\nsed '3a\\\n&gt;第一行\\\n&gt;第二行\\\n&gt;第三行' data.txt\n</div>\n\n#### 修改行c\n命令<span class=\"tips\">c</span>(change)命令用来修改整行文本的内容，其语法和插入、附加命令类似：\n<div class=\"apiBox\">sed '地址c\\\n&gt; 修改后的第一行内容\\\n&gt; 修改后的第二行内容' [文件名]</div>\n\nc命令支持使用地址区间，将该区间的行修改为指定的内容，但它只会将所有行修改为一个(单行或多行)指定内容，而不会每行修改一次，地址可以使用行号，也可以使用正则表达式匹配\n\n<div class=\"show\">e.g.根据行号修改指定行内容\nsed '1,2c\\\n&gt;修改的内容1\\\n&gt;修改的内容2' data.txt\n根据正则表达式匹配行并修改内容\nsed '/AAAA/c\\修改的内容' data.txt\n</div>\n\n#### 转换命令y\nsed编辑器中，转换命令<span class=\"tips\">y</span>(yank v.急速抽取,猛拉)是唯一一个可以处理单个字符的命令，其语法格式为：\n<sapn class=\"strong\">[地址]y/转换前的字符串str1/转换后的字符串str2/</sapn>\n\n转换命令会将两个字符串一一对应，str1中的第一个字符会被转换为str2中的第一个字符，依此类推，如果两个字符长度不同，sed编辑器会抛出一条错误消息。\n\n<div class=\"show\">e.g.文件data.txt包含以下内容\n111ABC111\nABC222ABC\n333AAA333\n444BBB444\n555DDD555\n转换命令会单独解析每个字符，只要包含任意字符就会被转换并且作用于所有行，且同一行有多个匹配的字符也会被转换，而不会像s命令一样只替换第一个\n<span class=\"text-blue\">sed 'y/ABC/abc/' data.txt</span>\n111abc111\nabc222abc\n333aaa333\n444bbb444\n555DDD555\n也可以用地址限定只在某行生效，以下命令只修改第一行中的ABC\n<span class=\"text-blue\">sed '1y/ABC/abc/' data.txt</span>\n也支持使用正则表达式定位某行\n<span class=\"text-blue\">sed '/22/y/ABC/abc/' data.txt</span>\n</div>\n\n#### 写入文件w\n<span class=\"tips\">w</span>命令会将匹配的行写入文件(另存)，如果文件不存在，则会自行创建，如果文件存在且文件中已有内容，则该内容会被覆盖，w命令语法格式为：\n<div class=\"apiBox\">[地址]w 文件名</div>\n\n文件名可以包含文件的绝对路径或相对路径，但执行该命令的用户需要拥有对该文件的写权限\n\n<div class=\"show\">e.g.将data文件的第1，2行写入test文件\nsed '1,2w test.txt' data.txt\n将文件包含字符串AAAA的行写入文件\nsed '/AAAA/w test.txt' data.txt\n</div>\n\n#### 读取文件r\n<span class=\"tips\">r</span>(read)读取命令会从指定文件读取所有文本内容，并插入到指定的地址，该命令的语法格式为：\n<div class=\"apiBox\">[地址]r 文件名</div>\n\n文件名可以包含文件的绝对路径或相对路径，指定地址时，只能指定一个单独的行号，而不能是一个区间，也可以是通过正则表达式匹配的行\n\n<div class=\"show\">e.g.将文件test中的所有内容插入到文件data末\nsed '$r test.txt' data.txt\n该功能常用于一些模板文件，这些模板文件(如信件模板)会在文件中用一个占位符预留空间，然后从另外一份文件导入字符串替换占位符，这样模板文件可以方法使用。如：文件customer写有顾客名单，文件Invitation为顾客姓名预留了位置\n<span class=\"strong\">customer.txt文件内容：</span>\n丹尼斯里奇,       肯汤普森\n詹姆斯高斯林,     林纳斯\n<span class=\"strong\">Invitation.letter文件内容：</span>\n邀请的嘉宾：\n    NAME\n....#邀请说明内容....\n可以将占位符NAME删除，并在该位置填入邀请名单\n<span class=\"text-red\">sed '/NAME/{\n&gt;r customer.txt\n&gt;d\n&gt;}' Invitation.letter</span>\n</div>\n\n#### 多行文本的处理\n默认情况下，sed编辑器会基于换行符的位置将数据分成行，以一行文本作为一个处理单位，如果处理的数据分布在两行或多行上，则sed编辑器可能返回错误的结果。\n\nsed编辑器为了解决该问题，提供了三个命令用于处理多行文本：\n+ <span class=\"strong\">n</span>(next)：读取数据流中的下一行内容并覆盖当前模式空间中的内容\n+ <span class=\"strong\">N</span>(next)：将数据流中的下一行追加到当前模式空间中\n+ <span class=\"strong\">D</span>：删除多行组中的一行\n+ <span class=\"strong\">p</span>：打印多行组中的一行\n\n##### next命令\nnext命令分为两个，命令<span class=\"tips\">n</span>会读入数据流中的下一行内容并覆盖当前模式空间中的内容，而命令<span class=\"tips\">N</span>会将下一行内容追加到当前模式空间中一起处理，二者有不同的用途。\n\n命令n可用来通过字符串定位某行后，基于此行处理之后的每一行的内容。这些字符串在文件中出现的位置(行号)可能是随机的，因此只能通过字符串来定位，然后通过命令n读入下一行的内容并做处理。\n<div class=\"show\">e.g.找出文件data中的uuid\n<span class=\"strong\">data文件内容</span>\nAAAAAA\nBBBBBB\nuuid:\na3d187a8-3b92-11ef-89d3-610452174e68\nCCCCCC\nuuid:\na3d187a9-3b92-11ef-89d3-610452445a10\nDDDDDD\n输出uuid\n<span class=\"text-blue\">sed -n '/uuid/{n;p}' data</span>\ne.g.删除文件data.txt中第一行后的空白行\n<span class=\"strong\">data.txt文件内容：</span>\nthis is first line.</br>\nthis is second line.</br>\nthis is last line.\n如果使用命令 sed '/^$/d' data.txt，文件中的所有空白行都会被删除，如果只想删除第一行后的空白行，则可以先定位到第一行，然后通过 n 命令读入下一行并覆盖第一行内容，然后通过删除命令删除该行即可，命令为：\n<span class=\"text-blue\">sed '/first/{n; d}' data.txt</span>\n#通过first字符串定位第一行，然后通过命令n读入第一行后的空白行，再通过命令d删除该空白行\n</div>\n\n命令N会将数据流中的两个文本行合并到同一个模式空间中，文本行仍然用换行符分隔，但sed编辑器现在会将两行文本当成一行来处理。当文本信息(如一个短语)被分隔到了不同的行，需要统一处理时，则可以使用该命令。\n<div class=\"show\">如果对一个文件执行N命令，N命令的工作方式为：\n先读入第一行文本，执行N命令，sed编辑器会立即读入第二行文本，并将二者作为一行文本处理，文本中的换行符\\n会保留\n随后读入第三行文本，继续执行N命令，读入第四行文本进行合并，以此循环\n因此如果文件是偶数行，则所有文本都会两两作为一行进行处理\n如果文件是奇数行，则执行到最后一行文本时，N命令会被sed编辑器叫停，最后一行文本单独作处理\ne.g.文件data.txt中有以下内容：\nAA AAAA\nBB BBBB\n执行命令<span class=\"text-blue\">sed 'N;l' data.txt</span>，命令会打印出：\nAA AAAA\\nBB BBBB$\n即模式空间中，两行内容会被当作一行保留了\\n字符的单行字符串进行处理，因此，对被分割到了两行的字符串进行处理时，可以使用以下方法：\ne.g.替换文件data.txt中的\"周杰伦\"为\"陈奕迅\"\n<span class=\"strong\">data.txt文件内容</span>\n1111 11 11周\n杰伦 22 2222\n3333 33 周杰\n伦44 44 4444\n5555 55 周杰伦\n考虑到字符串有不同的换行可能，需要考虑所有换行情况，但如果直接执行：\n<span class=\"text-blue\">sed 'N\n&gt;s/周杰伦/陈奕迅/\n&gt;s/周\\n杰伦/陈\\n奕迅/\n&gt;s/周杰\\n伦/陈奕\\n迅/\n&gt;' data.txt</span>\n文件最后一行中的\"周杰伦\"将没有被替换，这是因为先执行了N命令，而对文件最后一行，由于没有下一行可读，编辑器会叫停N命令，导致最后一行中的字符串无法被匹配到，因此，正确的命令应该为：\n<span class=\"text-blue\">sed '\n&gt;s/周杰伦/陈奕迅/\n&gt;N\n&gt;s/周\\n杰伦/陈\\n奕迅/\n&gt;s/周杰\\n伦/陈奕\\n迅/\n&gt;' data.txt</span>\n即先查找字符串都在同一行上的情况，然后执行N命令，开始查找字符串不在同一行的情况\n</div>\n\n<div class=\"show\">N命令可以多次调用，来实现三行、四行等多行的合并处理，但需要注意最后一行是否会被合并到之前的行中，如果最后一行被孤立，其中的内容可能会无法被正确处理\n<span class=\"strong\">data.txt文件包含以下内容</span>\nAA AA AAAA\nBB BB BBBB\nCC CC CCCC\nDD DD DDDD\n只调用一次N命令时：\nsed -n 'N;l' data.txt\n返回值为\nAA AA AAA\\nBB BB BBB$\nCC CC CCC\\nDD DD DDD$\n调用两次N命令时：\nsed -n 'N;N;l' data.txt\nsed编辑器读入第一行后，执行第一个N命令读入第二行，执行第二个N命令读入第三行，执行l命令输出，然后清空模式空间。并读入第四行，开始重新执行指定的命令，但执行到第一个N命令后，由于文件已经读取到最后一行，于是sed编辑器会叫停命令执行，于是第四行由于没有执行到l命令，所以输出中将缺少第四行：\nAA AA AAA\\nBB BB BBB\\nCC CC CCC$\n类似的，调用3次N命令，将使整个文件作为同一个行进行处理，输出值为：\nAA AA AAA\\nBB BB BBB\\nCC CC CCC\\nDD DD DDD$\n</div>\n\n#### 多行文本的删除D\n在使用N命令时，数据流中的两行或多行文本会被当作同一行来处理，因此如果在N命令后使用d命令，将会同时删除多行文本。如果只需要删除第一行，可以使用<span class=\"tips\">D</span>命令。它只会删除模式空间中的第一行，删除内容包括从第一行开头到换行符（含换行符）为止的所有字符，这个命令常用来删除目标数据字符串所在行的前一文本行。\n \n<div class=\"show\">e.g.需要搜索的关键词被分割于两行上，需要使用N命令合并搜索，但只删除其中的第一行内容\n<span class=\"strong\">data.txt文件内容：</span>\n1111 11 11周\n杰伦 22 2222\n3333 33 周杰伦\n如果使用d命令，则包含字符串的两行都会被删除\nsed 'N;/周\\n杰伦/d' data.txt\n输出值为：\n3333 33 周杰伦\n只删除第一行，需要使用D命令\nsed 'N;/周\\n杰伦/D' data.txt\n输出值为：\n杰伦 22 2222\n3333 33 周杰伦\n</div>\n\n#### 多行打印P\n与多行删除类似，如果将打印命令p(小写)与N命令一起使用，则p命令会同时输出所有匹配到的多行的内容。如果只想输出多行中的第一行内容，则需要使用<span class=\"tips\">P</span>(大写)命令。同样，该命令只会输出模式空间中第一行开始到换行符之间的内容\n\n<div class=\"show\">e.g.打印上个例子中文件data.txt的指定字符串\n小写的命令p会输出包含该字符串的多个行\nsed -n 'N;/周\\n杰伦/p' data.txt\n输出：\n1111 11 11周\n杰伦 22 2222\n大写的命令P只输出模式空间中的第一行\nsed -n 'N;/周\\n杰伦/P' data.txt\n输出：\n1111 11 11周\n</div>\n\n#### 排除命令!\n在命令前加上行地址可以指定命令只在这些行生效，而如果想命令在这些行中不生效，直接在行地址后加上<span class=\"tips\">!</span>即可。排除命令<span class=\"tips\">!</span>可以用来指定命令在某些行中不生效，而对文本剩下的其他行均生效。\n\n<div class=\"show\">e.g.文件data.txt含以下内容\n1111 AA\n2222 AA\n3333 AA\n4444 AA\n输出文本内容，包含字符串2222的行除外\nsed -n '/2222/!p' data.txt\n输出值为：\n1111 AA\n3333 AA\n4444 AA\n将文本行中的AA替换为BB，2,3行除外\nsed '2,3!s/AA/BB/' data.txt\n输出值为：\n1111 BB\n2222 AA\n3333 AA\n4444 BB\n</div>\n\n#### 命令跳转b\n排除命令可以用来指定某个命令对哪些行不生效，当有大量的命令都要求对这些行不生效时，如果需要为每个命令都加上<span class=\"tips\">!</span>过于繁琐。为此，sed提供了分支命令<span class=\"tips\">b</span>(branch)，用来帮助这些匹配的行跳过一整组命令，branch命令的格式为:\n\n<span class=\"strong\">[行地址]b [跳转位置]</span>\n\n在文本处理命令中可以使用<span class=\"tips\">: 位置标识符</span>(位置标识符最长可以为7个字符)来指定一个branch命令跳转的位置。注意：这里的跳转位置是指在命令行中的跳转位置，而不是跳转到文本流的哪个位置。行地址参数决定了branch命令触发的条件以及branch在哪些行生效，当在匹配的行执行到branch命令时，sed编辑器会跳转到位置标识符所在命令位置，并略过branch命令与位置标识符之间的所有命令。如果没有为branch命令指定跳转位置，则branch命令会跳过所有在它之后的命令，直接结束本行文本的处理。\n\n\n<div class=\"show\">命令的常见用法：\n处理某文本流时，对于包含内容AA的行只执行命令3，命令4，其他行命令1，2，3，4均执行，就可以使用branch命令\n<span class=\"text-blue\">sed '<span class=\"text-red\">/AA/b jump;</span>命令1;命令2;<span class=\"text-red\"> :jump; </span>命令3;命令4' data.txt</span>\n</div>\n\n<div class=\"show\">e.g.文件data.txt含以下内容\n1111 AA BB CC\n2222 AA BB CC\n3333 AA BB CC\n4444 AA BB CC\n1. 不指定跳转位置，文本处理命令会跳转到命令末尾\n<sapn class=\"text-red\">sed '2,3b;s/AA/aa/;s/BB/bb/;s/CC/cc/' data.txt</sapn>\n由于没有指定命令跳转位置，对于第二，第三行，b命令会跳过后面的两个s命令，但对于其他行，b命令不生效，所有命令不跳过，输出值为：\n1111 aa bb cc\n2222 AA BB CC\n3333 AA BB CC\n4444 aa bb cc\n2. 指定跳转位置，文本处理命令会跳转到位置标识符开始的地方\n<span class=\"text-blue\">sed '2,3b jump1\n&gt;s/AA/aa/\n&gt;s/BB/bb/\n&gt; :jump1\n&gt;s/CC/cc/' data.txt</span>\n定义了一个位置跳转符 jump1，文本执行到第二，第三行时，s/AA/aa;s/BB/bb/命令会被跳过，跳转到jump1开始执行，因而s/CC/cc会正常执行\n1111 aa bb cc\n2222 AA BB cc\n3333 AA BB cc\n4444 aa bb cc\n该命令等价于：\n<span class=\"text-blue\">sed '2,3!{s/AA/aa/;s/BB/bb/};s/CC/cc/' data.txt</span>\n</div>\n\n注意，命令在进行跳转时有可能形成循环，如果branch命令触发条件没写好，可能形成死循环\n<div class=\"show\">e.g.删除文本中的所有感叹号\necho \"乌！蒙！山！外！连！着！山！\"| sed ':jump;s/!//1p;/!/b jump';\nsed会依次删除感叹号，直到所有感叹号删除完毕退出循环：\n乌蒙！山！外！连！着！山！\n乌蒙山！外！连！着！山！\n乌蒙山外！连！着！山！\n乌蒙山外连！着！山！\n乌蒙山外连着！山！\n乌蒙山外连着山！\n乌蒙山外连着山\n乌蒙山外连着山\n</div>\n\n#### 测试命令t\n测试命令<span class=\"tips\">t</span>(test)也可以实现命令的跳转，其跳转的条件是t命令前的替换命令如果成功匹配并替换了一个字符串，测试命令就会跳转到指定的位置标识符，如果替换命令没有匹配到指定的模式，测试命令就不会跳转。注意，t 命令只能基于替换命令的成功与否触发跳转，而不能直接基于其他命令的结果。测试命令的语法格式与分支命令相同：\n\n<span class=\"strong\">[行地址]t [跳转位置]</span>\n\n与分支命令类似，如果跳转条件满足而没有为t命令指定跳转位置，则sed会跳到命令结束的位置。\n\n<div class=\"show\">测试命令的工作模式类似于if-then语句\ne.g.如果匹配到AA就替换为aa，此时由于没有指定跳转位置，t命令会跳转到命令末尾，第二个替换命令将不会执行。相反，如果第一个替换命令没有执行，则t命令不跳转，会尝试执行第二个替换命令\nsed 's/AA/aa/;t;s/BB/bb/' data.txt\ne.g.去除文本中的所有感叹号\necho \"乌！蒙！山！外！连！着！山！\"| sed '\n&gt;:jump\n&gt;s/!//1p\n&gt;t jump '\n</div>\n\n#### 退出命令q\n退出命令<span class=\"tips\">q</span>可以用来退出sed编辑器，注意，执行该命令后sed编辑器将直接退出而不再读取后续文本行，当然也不再执行后续命令，该命令也常用来退出由<span class=\"tips\">b</span>命令和<span class=\"tips\">t</span>命令形成的循环\n\n<div class=\"show\">e.g.文件data.txt包含以下内容\n1111AA1111\n2222AA2222\n3333AA3333\n4444AA4444\n5555AA55BB\n6666AA6666\n替换文本行中的AA，直到第四行\nsed '4q;s/AA/aa/' data.txt\n执行到第四行后，命令停止执行，后续文本也不再读入\n1111aa1111\n2222aa2222\n3333aa3333\n4444AA4444\ne.g.一直读入文本行，直到遇到BB字符串，并将包括带有BB字符串的行及其之前的文本行合并为一行，q命令用于终止循环\nsed ':start;/BB/q;N;s/\\n/ /;b start' data.txt\n返回值为\n1111AA1111 2222AA2222 3333AA3333 4444AA4444 55AA55BB55\n</div>\n\n\n\n#### 保持空间\nsed对文本的操作都是在名为模式空间的缓冲区进行的，除了模式空间外，sed还有一个名为<span class=\"tips\">保持空间</span>(hold space)的缓冲区，用来辅助模式空间工作。当模式空间中在处理文本行时，保持空间可用来临时存储一些行，有5条命令可以用来操作保持空间：\n\n<div class=\"table\">\n\n命令|  命令来源 |说明\n----|----------|--------\nh   |hold space|将模式空间中的内容复制到保持空间\nH   |hold space|将模式空间中的内容追加到保持空间\ng   |get from get space|将保持空间中的内容复制到模式空间\nG   |get from get space|将保持空间中的内容追加到模式空间\nx   |exchange|交换模式空间和保持空间的中内容\n</div>\n\n<strong>保持空间的运用</strong>\n巧妙使用保持空间可以实现一些有趣的功能，如实现文件的反序处理。默认情况下，sed编辑器会从文本流的第一行开始读取，第一行处理完毕才会载入第二行文本并作处理，但通过保持空间，我们可以将文本第一行暂存到保持空间，让sed编辑器先处理第二行，然后再从保持空间读出第一行文本进行处理，实现文本的反序处理，修改sed编辑器的默认处理流程。\n\n<div class=\"show\">e.g.实现文件的反序输出，即最先输出最后一行，然后依次从后到前输出文件内容\n实现思路为：\n1. 等sed编辑器读入第一行内容到模式空间后，使用h命令将内容复制到保持空间\n2. 等sed编辑器读入第二行内容后，使用G命令将保持空间中的内容追加到模式空间中，此时第一行文本将排于第二行文本之后，然后再使用h命令将此时模式空间中的内容都存储到保持空间\n3. sed编辑器读入第三行，继续使用G命令将保持空间中的内容追加到模式空间，此时文本行顺序为：第三行、第二行、第一行。再次使用h命令将其保持到保持空间\n4. 重复上述步骤，直到文本行都被读取完毕，此时所有行都会反序存储于保持空间中\n5. 读取并打印文本行\n<span class=\"strong\">文件data.txt内容：</span>\n1111\n2222\n3333\n4444\nsed编辑器会在每次执行完一次命令，都会自行读入下一行，因此只需要使用G命令将保持空间中的内容追加到模式空间即可。但刚开始模式空间读入文本流第一行时，保持空间为空，因此对于第一行，不需要将保持空间追加到其之后，可以用排除命令!解决：\n1!G\n将文本行反序后，需要将此时模式空间的内容存储到保持空间：\nh\n等到sed编辑器读取到文本最后一行，并执行完G命令，说明文本流的反序已经完成，此时打印模式空间中的内容即可：\n$p\n完整的命令为：\n<span class=\"text-red\">sed -n '1!G;h;$p' data.txt</span>\n</div>\n\n#### 模式引用&\n当sed匹配到了字符串时，可以在后续的命令中使用<span class=\"tips\">&</span>引用匹配到的字符串\n\n<div class=\"show\">e.g.查找文本中以at结尾的单词，并在该单词外加上双引号\"\"\n echo \"The cat sleeps in his hat.\" | sed 's/*at/\"<span class=\"text-red\">&</span>\"/g'\n 文本会替换为：\n The \"cat\" sleeps in his \"hat\".\nsed替换命令中，替换后的字符串不能使用*等通配符，因此上述语句改为以下命令将不会正常完成替换工作：\necho \"The cat sleeps in his hat.\" | sed 's/*at/\"*at\"/g'\n文本会被替换为：\nThe \"*at\" sleeps in his \"*at\".\n</div>\n\n#### 部分引用\n&符号会引用匹配到的整个字符串，如果只想引用字符串的一部分，需要使用一些特殊的方法：\n\nsed编辑器可以使用<span class=\"tips\">圆括号( )</span>在替换模式中定义子模式，然后在替换后的字符串中使用<span class=\"tips\"> \\数字 </span>的形式来引用每个子模式，数字表示子模式的位置。sed编辑器会将第一个子模式分配为\\1，第二个子模式分配为\\2，依此类推。注意！在使用圆括号定义子模式时，<span class=\"tips\">需要使用转义字符将圆括号标识为分组字符</span>，否则sed编辑器会将其识别为普通的圆括号。\n\n<div class=\"show\">在使用部分引用时，将字符串中需要保留的部分使用<span class=\"tips\">\\(字符串\\)</span>的形式定义为子模式，然后在替换后的字符串中使用<span class=\"tips\">\\数字</span>的形式引用需要保留的部分\ne.g.文件data.txt含以下内容：\n<code>最常用的是Java语言和SpringBoot框架</code>\n替换Java但保留后缀\"语言\"，替换SpringBoot但保留后缀\"框架\"\nsed -n 's/Java\\(语言\\)和SpringBoot\\(框架\\)/JavaScript\\1和Vue\\2/p'\n输出值为：\n最常用的是JavaScript语言和Vue框架\n</div>\n\n<div class=\"show\">在使用替换命令时，由于在指定替换后的字符串时不能使用通配符，而又需要在替换后的字符串中引用部分匹配到的字符串时，就可以很方便地以子模式的形式引用\ne.g.文件data.txt含以下内容\nfurry cat\nfurry hat\nfurry dog\n在替换后的字符串中不能使用通配符时，可以用该方法引用所匹配到字符串中的一部分，相当于替换后的字符串中也使用了通配符\nsed 's/furry \\(.at\\)/pretty \\1/'\n输出值：\npretty cat\npretty hat\nfurry dog\n</div>\n\n#### 在shell脚本中使用sed\n默认情况下，sed编辑器会将命令结果打印到屏幕上，因此在脚本中使用sed命令时，需要对其输出结果进行重定向，常用的方法是使用$()将其结果重定向到一个变量中，方便后续处理。以外是一些可能用到的sed脚本示例：\n\n##### 格式化数值\n<div class=\"show\">e.g.输入一个值计算其阶乘，然后将计算结果以1,000,000格式输出\n计算部分很简单，重点在于使用sed处理计算结果时，需要从个位开始每3位添加一个逗号，处理命令为：\nsed '\n&gt;:start\n&gt;s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/\n&gt;t start'\n关键在于正则表达式部分，它定义了两个子模式：\n.*[0-9]\n[0-9]{3}\n第一个子模式中的 .* 组合会匹配任意长度的除回车和换行符外的任意字符，[0-9]代表该子模式匹配的字符串必须以数字结尾，二者结合，该子模式会匹配任意长度以数字结尾的字符串\n第二个子模式会匹配三位数字\n此外，该sed命令每一次只会在字符串中插入一个逗号，因此使用了跳转命令t形成了一个循环，它会一直循环直到t命令前的s命令语句无法插入逗号为止\n当为该sed命令输入字符串12345678时\n<span class=\"strong\">第一次循环：</span>\n正则表达式.*[0-9][0-9]{3}中的.*[0-9]需要为[0-9]{3}预留3位数字，然后*[0-9]本身匹配任意多数字结尾的字符串，所以：\n.*[0-9]匹配字符串：12345\n[0-9]{3}匹配字符串：678\n然后s命令会在两个子模式间插入逗号，因此第一次循环执行结果为：\n12345,678\n<span class=\"strong\">第二次循环：</span>\n输入值为：12345,678\n如果[0-9]{3}匹配了\"678\"，.*[0-9]会匹配到\"12345,\"，不满足以数字结尾的要求。因此在字符串\"12345,678\"只有\"12345\"部分满足正则表达式要求。后面的\",678\"在s替换命令中作为不匹配的字符串原样保留，替换作用对其不生效\n因此，第二次循环，\"12345\"被替换为了\"12,345\"，再加上原字符串保留的\",678\"，最后的输出结果为12,345,678，这样数值会以方便阅读值的格式输出，整个脚本完整的代码如下：\n</div>\n\n<pre><code>#!/bin/bash\nresult=1\ncounter=$1\nwhile [ $counter -gt 1 ]\n do\n  result=$[ $result * counter ]\n  counter=$[ $counter - 1]\n done\noutputValue=$(echo $result | sed '\n:start\ns/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/\nt start')\necho \"计算结果为：$outputValue\"</code></pre>\n\n<div class=\"show\">将上述代码保存于test.sh文件，然后执行\nbash test.sh 20\n计算20的阶乘，最后输出结果为：\n计算结果为：2,432,902,008,176,640,000\n</div>\n\n##### 加倍行距\n\n<div class=\"show\">我们可以向文本文件的行间插入空白行，使得文本行看起来没那么密集\nThis is the header line. </br>\nThis is the first data line.</br>\nThis is the second data line.</br>\nThis is the last line.\n插入空白行可以从以下几点出发考虑：\n1.如果文件本身已经有一些空白行，如果再加入空白行每两行文本之间可能会有多个空白行，因此应该先删除原文件的空白行(除非文本本身需要刻意保留这些空白行)\n2.最后一行文本之后不需要空白行\n3.默认情况下，sed编辑器保持空间就是一个空白行，可以使用G命令将其追加到模式空间内容之后\n由此，加倍文件行距的命令为：\n<span class=\"text-blue\">sed '/^$/d;$!G' data.txt</span>\n通过^$匹配文件原有空白行然后删除，通过$!G命令给除最后一行以外的行添加空白行\n</div>\n\n##### 给文本添加行号\n<div class=\"show\">通过 = 命令可以打印行号，但行号会打印在文本内容上方，因此需要使用N命令合并，然后删除其中的换行符\n<span class=\"text-blue\">sed '=' data.txt | sed 'N;s/\\n/ /'</span>\n预览效果为：\n1 This is the header line. \n2 This is the first data line. \n3 This is the second data line. \n4 This is the last line.\n</div>\n\n##### 查看文件末尾10行\n用sed实现一个类似于tail命令的效果，读取文件最后10行，由此脚本可以任意魔改实现查看文件末尾n行\n\n<div class=\"show\">由于sed会从第一行开始读取文本，而我们需要文件最后的10行，因此在使用N命令读入下一行的同时，需要不断删除模式空间最顶部的那一行，直到模式空间中保留文件的末尾10行\n<span class=\"text-blue\">sed '{\n&gt;:start\n&gt;$q\n&gt;N\n&gt;11,$D\nb start}' data.txt</span>\n命令中，$q只会在读取文件最后一行时执行，q命令会退出sed编辑器，这里用来退出循环，而11,$D命令只会在读取文件第11行到最后一行之间的行时执行\n执行流程为：\nsed读入第一行，不执行$q，读入第二行，不执行11,$D\n读入第二行后依旧不执行$q和11,$D\n直到读入第11行，此时sed保持空间中已经有了11行内容，由于读入第11行内容，11,$D命令生效删除保持空间的第一行(也是文件第一行)，让保持空间中只保留10行文本\n之后的行类似，新加入保持空间中的行会替换掉保持空间顶部的行，保障保持空间中保留的是位于文件底部的行\n直到读入文件最后一行，$q生效退出sed编辑器，退出前sed会默认打印此时保持空间中的内容，即文件的最后10行\n可以在此基础上修改命令，任意指定查看行数，如：查看文件末尾3行：\nsed ':start;$q;N;4,$D;n start' data.txt\n</div>\n\n##### 删除空白行\n###### 1.删除文件开头的空白行\n<div class=\"show\"><span class=\"strong\">删除文件开头的空白行</span>\n<span class=\"text-blue\">sed '/./,$!d' 文件名</span>\n地址区间 /./,$ 表示从有任意字符的行开始到文件末，而/./,$!d表示地址区间的行不执行删除命令，即删除文件开头无字符的空白行\n</div>\n\n###### 2.删除文件末尾的空白行\n<div class=\"show\"><span class=\"strong\">删除文件末尾的空白行</span>\n<span class=\"text-blue\">sed ':start ; /^\\n*$/{$d ; N ; b start}' data.txt</span>\n与打印文件末的文本行类似，删除文件末的空白行会有点麻烦，需要使用循环来判断空白行位于文本之间还是文件末。正则表达式^\\n*$会匹配空行和只包含换行符的行，然后执行大括号中的命令组，$d表示如果该行位于文件最后一行则删除，此时由于文件处于最后一行，N命令不执行。如果不是最后一行，则$d不执行，N命令会读入下一行附加到模式空间中，然后命令跳转回开头重新执行。\n假设文件data.txt包含以下内容(为方便分析，文件末尾有两个空行)：\n1111\n2222<br>\n4444<br><br>\n7777<br><br>\n根据命令，sed编辑器首先读入第一行，不满足/^\\n*$/，编辑器不做任何操作，输出第一行\n然后sed载入第二行，同样不满足/^\\n*$/，第二行原样输出\nsed载入第三行，该行为空行，满足正则表达式/^\\n*$/中*为0的情况，执行{ }中的命令组，由于该行不为文件最后一行，$d不执行，N命令会读入下一行，此时保持空间中的内容为\"\\n4444\"，然后命令跳转回开头，此时保持空间中的字符串不再满足/^\\n*$/，sed输出该内容然后读取下一行\nsed读取的第五行也为空行，满足/^\\n*$/，执行命令时同样不执行$d命令，但执行N命令，读入的第六行也为空行，此时模式空间内容为\"\\n\\n\"，命令跳转到回开头重新执行，此时模式空间中的内容依旧满足/^\\n*$/，再次执行命令N，读入第七行，此时模式空间内容为\"\\n\\n7777\"，跳转命令后，不满足/^\\n*$/，sed将输出该字符串\nsed读入第八行，该行为空白行，sed执行命令组，随后sed通过N命令读入第九行，也为空白行，此时保持空间中的字符串\"\\n\",然后命令进行跳转，再次进行正则匹配，由于\"\\n\"满足/^\\n*$/，开始执行命令组，此时sed已经读取到文件末，所以$d执行，删除最后一行(且由于此时两个空白行被N命令合并为了一行，两个空白行会被一起删除)，执行到N命令时由于无下一行，sed会退出，此时文件末尾的所有空白行被删除完毕\n执行命令sed -n ':start;/^\\n*$/{$d;N;l;b start}' data.txt，可以清晰看到保持空间中合并过的内容：\n\\n4444$\n\\n\\n7777$\n\\n$\n该命令只会删除文件末的空白行，不会去删除文本之间的空白行，只删除文件末的空白行时可以使用此命令\n</div>\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n在多行文本中，文本行末尾虽然隐式地在带有\\n，但是是无法用正则表达式/\\n/匹配的，但如果sed中使用了命令N来读入下一行文本，则当前文本和下一行文本之间会显式地写入\\n，此时则可以使用/\\n/来匹配。空白行同理，多个空白行虽然隐式地在末尾带有\\n，但无法用正则表达式/^\\n$/匹配空白行，而要使用/^$/来匹配，当使用命令N读入两个空白行时，sed编辑器保持空间中的内容将变成\"\\n\"，此时可以使用/\\n/匹配到。该例子中，/^\\n*$/刚好能完美匹配空白行未被读入时/^$/的形式，也能匹配保持空间中存在多个空白行时/\\n*/的形式。\n</div>\n\n<div class=\"show\">e.g.文件data.txt包含以下内容\n1111\n2222\n3333<br>\n5555<br><br>\n8888\n9999\n未使用N命令时，无法匹配到\\n\nsed -n '/\\n/l' data.txt\n当使用了N命令时，\\n会被显式写入文本中，因此可以被正则表达式匹配到\nsed -n 'N;/\\n/p' data.txt\n会返回文件带\\n的行(但由于文件是奇数行，最后一行无法执行N而导致sed退出，也就不会执行后续的p命令，无输出)\n1111\n2222\n3333<br>\n5555<br><br>\n8888\n通过输出命令l更能清晰看出文本行在保持空间中的具体存储方式\n1111\\n2222$\n3333\\n$\n5555\\n$\n\\n8888$\n</div>\n\n###### 3.删除文件中连续的空白行\n\n<div class=\"show\"><span class=\"strong\">删除文件中连续的空白行</span>\n<span class=\"text-blue\">sed '/./,/^$/!d' 文件名</span>\n文件中数据行之间的多个空白行会被删除，只保留一个空白行。该命令的关键在于，创建包含一个非空白行和一个空白行的地址区间，如果sed编辑器匹配到了这个区间，它不会删除行。但对于不匹配这个区间的行（两个或更多的空白行），它会删除这些行。\n</div>\n\n##### 删除HTML标签\n\n<div class=\"show\">如果需要删除html文件或xml文件中的标签，只留下标签之间的内容，通过sed也可以轻松实现\n如果使用命令：\nsed 's/<.*>//g' index.html\n/&lt;.*&gt;/首先会匹配该行中最开始遇到的&lt;，此后由于.*会进行贪婪匹配，*会匹配尽可能多的字符，&gt;将匹配闭合标签中最末尾的&gt;，这会导致标签中的文本也被替换掉，如：\n&lt;div&gt; test &lt;/div&gt;\n该正则表达式会匹配高亮的两个尖括号：\n<span class=\"text-red\">&lt;</span>div&gt; test &lt;/div <span class=\"text-red\">&gt;</span>\n这会导致整个标签，包括标签中的内容也会被替换掉，因此，正确的删除标签的命令是：\n<span class=\"text-blue\">sed 's/<[^>]*>//g' 文件名</span>\n正则表达式<[^>]*>表示匹配以 '&lt;' 开头，后面跟任意数量的非 '&gt;' 字符，并以 '&gt;' 结束的字符串，这正是一个HTML标签的形式。这样它会单独匹配双标签中的前半部分，由于使用了全局匹配g，标签的后半部分也会被匹配到，且对单标签也生效\n<span class=\"text-red\">&lt;</span>div<span class=\"text-red\">&gt;</span> test &lt;/div&gt;\n这样，标签会被依次替换删除，只留下标签中的字符串部分\n</div>\n\n### awk\n#### 简介\nawk 是一种强大的文本处理工具，广泛用于 Linux 和 Unix 系统中。它的名字来源于其三位创建者 Alfred V. Aho、Peter J. Weinberger 和 Brian W. Kernighan的首字母。相较与sed，awk提供的是一种类编程语言而不仅仅只是编辑器命令，它支持算术运算、数组运算、自定义变量、自定义函数、结构化编程语句(如：循环,判断)、模式匹配等，且awk本身提供了大量的内部函数和内部变量用于进行字符串处理、数值计算、时间处理等。与sed编辑器一样,awk会为每一行文本都执行一次指定的awk程序，不同的是，sed编辑器更注重以行为处理单位，处理列数据的能力较弱，而awk支持将行中的数据提取为字段，并提供了许多内建变量和函数用于调用和处理这些字段，处理列数据的能力远要比sed强，因此，awk被广泛用于格式化文本、运算和过滤数据，快速生成报告等领域。\n\nLinux中主要使用的是awk的GNU版本——gawk，它是 awk 的扩展实现，由 GNU 项目开发，提供了许多扩展功能和增强特性，同时保持了与传统 awk 的兼容性。在大多数 Linux 发行版中，预装的都是gawk，awk命令通常是gawk的一个符号链接，通过awk命令和gawk命令启动的都是gawk编辑器。\n\n##### awk的工作流程\nawk会依次执行以下流程：\n+ awk首先会执行BEGIN代码块中的内容，因此该代码块通常用来初始化变量、设置环境或打印初始信息\n+ 随后awk会逐行读取数据，并根据普通代码块中的模式-动作对进行匹配和处理，如果代码块中没有指定任何命令，awk会默认执行{ print $0 }，即打印当前文本行\n+ 在处理完所有数据后，awk会执行END代码块中的命令，该代码块可用于打印最终结果、清理资源\n\n#### 命令格式\nawk程序的基本格式如下：\n<div class=\"apiBox\">awk 选项 '{程序体}' 文件1 文件2 ...</div>\n\n+ -F 字符：将字段分隔符修改为指定字符\n+ -f 文件名：从指定的文件中读取程序\n+ -v 变量名=值：定义一个awk变量并赋值，一个-v选项只能定义一个变量，但可以多次使用-v选项，通过-v选项定义的变量可以在BEGIN程序块中读取到\n+ -mf 值：指定要处理的数据文件中的最大字段数\n+ -mr 值：指定数据文件中的最大数据行数\n+ -w 关键字：指定awk的兼容模式或警告等级\n+ awk默认支持拓展正则表达式，不需要像sed一样使用额外选项\n+ awk的程序体用一对大括号<span class=\"tips\">{ }</span>定义，并且当程序是在命令行中指定时需要放到单引号<span class=\"tips\">' '</span>中，这样shell会将其视为字符串，而不会去尝试解析awk程序，如果从文件中调用awk程序，则不需要单引号\n\n</br>\n\n通常情况下，awk程序包含模式和命令两个部分，命令部分使用大括号包裹，模式或命令部分可以省略其中一个，但不能两个都省略。如果省略模式，则会对所有输入的行都执行命令。如果省略命令(包括大括号在内的命令部分)，则会默认打印所有与模式匹配的行。\n<div class=\"show\">e.g.打印data.txt文件中所有包含\"li\"字符串的行\nawk '/li/{print $0}' data.txt\n如果省略命令，则根据awk的默认行为，同样会打印匹配的行\nawk '/li/' data.txt\n如果保留大括号，但不写命令，则awk会进行空操作，不执行任何动作(也不打印任何内容)\nawk '/li/{}' data.txt\n</div>\n\n\n##### 程序定义方式\nawk程序通常分为多个<span class=\"tips\">语句块</span>，语句块使用大括号<span class=\"tips\">{ }</span>包裹，同一个语句块允许定义多条命令，<span class=\"strong\">单行模式</span>下，命令之间使用分号<span class=\"tips\">;</span>分隔即可\n<div class=\"show\">echo \"java c python go\" | awk '{print $1<span class=\"tips strong\">;</span>print $2}'\n输出值为：\njava\nc\n</div>\n\n<span class=\"strong\">多行模式</span>下，可以不使用分号\n<div class=\"show\">echo \"java c python go\" | awk '{ \n&gt; print $1 \n&gt; print $2 }' \n</div>\n\n<span class=\"strong\">从文件中调用：</span>awk也支持将程序存储于文件中，然后在命令行中通过<span class=\"tips\">-f</span>选项调用，跟sed编辑器一样，awk程序会对文件中的每行文本都执行脚本\n<div class=\"show\"><span class=\"strong\">script.awk</span>\n{print $1; print $2}\n在命令行中使用<span class=\"tips\">-f</span>选项调用\necho \"java c python go\" | awk -f script.awk \n</div>\n\n<span class=\"strong\">awk可执行程序：</span>awk程序写于文件中也可以像shell脚本一样通过'#!'来指定文件的执行器，在赋予相应执行权限后直接通过文件路径直接执行。注意，与shell不同的是在指定awk解释器的时候，需要将选项<span class=\"tips\">-f</span>作为参数传入awk\n\n<div class=\"show\"><span class=\"strong\">script.awk</span>\n#!/bin/awk -f\nBEGIN {print \"Hello World\"}\n然后赋给文件权限：\nchmod +x script.awk\n之后通过文件路径可以直接执行：\n./script.awk\n或\n/myAwk/script.awk\n</div>\n\n\n##### 文本输入方式\n与sed编辑器相同，当命令行未指定输入的文本文件时，awk默认会从STDIN读取输入，每输入一行，awk会处理一行并即时打印处理结果，直到使用<span class=\"tips\">Ctrl+D</span>结束输入，或使用<span class=\"tips\">Ctrl+C</span>终止程序\n\n<div class=\"show\">awk '{print \"输入为：\"$0}'\n10                 #用户输入\n输入为：10          #awk输出\nGNU/Linux          #用户输入\n输入为：GNU/Linux   #awk输出\n</div>\n\n也可以使用管道符<span class=\"tips\">|</span>将文本输入awk程序\n<div class=\"show\">echo \"java c python go\" <span class=\"tips\">|</span> awk '{print $1;print $2}'</div>\n\n文本也可以从文件中大量读取\n\n<div class=\"show\">文本较多时，可以写于文件中，awk可以从文件读取文本\nawk '{print $1;print $2}' data.txt</div>\n\n#### 在处理数据前/后执行脚本BEGIN与END\nawk允许数据处理前，或数据处理后执行某些特定的功能。默认情况下，awk会先从输入读入一行文本，然后对该文本执行对应脚本。如果需要在数据处理前执行某个功能(如：脚本执行前打印提示)，则可以使用<span class=\"tips\">BEGIN</span>关键字来定义脚本，同样，awk还提供了<span class=\"tips\">END</span>关键字用于在数据处理完毕后执行脚本，BEGIN和END是用来在读取数据流之前或之后执行命令的特殊模式。\n\n<div class=\"show\">awk 'BEGIN { print \"程序启动\" }\n&gt; {print \"执行程序体\"}\n&gt; END { print \"程序执行完毕\"}' data.txt\n</div>\n\n使用该功能可以生成漂亮且清晰的信息报告\n\n<div class=\"show\">e.g.文件script.awk中的程序\nBEGIN {\nprint \"当前Linux的用户列表和默认登录shell\"\nprint \"用户名\\t\\t默认登录shell\"\nprint \"--------------------\"\nFS=\":\"\n}\n{\nprint $1 \"\\t\\t\" $7\n}\nEND {\nprint \"----------------\"\nprint \"信息来自/etc/passwd文件\"\n}\n执行命令\n<span class=\"text-red\">awk -f script.awk /etc/passwd</span>\n生成的信息报告(只展示一部分用户信息)：\n<code>当前Linux的用户列表和默认登录shell\n用户名\t\t 默认登录shell\n------------------------\nroot\t\t&emsp; /bin/bash\nbin\t\t    /sbin/nologin\ndaemon\t\t /sbin/nologin\nadm\t\t    /sbin/nologin\nlp\t\t     /sbin/nologin\n-----------------------\n信息来自/etc/passwd文件</code>\n</div>\n\n#### 使用模式\n与sed相似，awk支持使用模式来过滤数据，使awk程序只作用于某些满足要求的行，BEGIN与END是两个awk预定义的特殊模式\n##### 使用正则表达式\nawk支持基础正则表达式（BRE）和扩展正则表达式（ERE），通过正则表达式可以筛选出满足匹配的行，正则表达式之后语句块中的awk程序将只对这部分行生效\n\n<div class=\"show\">e.g.找出包含字符串\"AA\"的行，并打印这些行的第一个字段\nawk '/AA/{print $1}' data.txt\n</div>\n\n##### 匹配操作符\n正则表达式会在每一行的所有内容中进行匹配，如果需要限定正则表达式只能在某个字段内进行匹配，可以使用匹配操作符<span class=\"tips\">~</span>，语法为：\n<div class=\"apiBox\">字段~正则表达式{ 程序体 }</div>\n\n<div class=\"show\">e.g.文件data.txt包含以下内容\n11AA 11AA\n22BB 22AA\n33CC 33AA\n44DD 44AA\n列出字段1中包含\"AA\"的行\nawk '$1~/^AA/{print $0}' data.txt\n输出值：\n11AA 11AA\n</div>\n\n##### 排除操作符\n正则表达式的匹配结果可以使用<span class=\"tips\">!</span>来进行排除，该排除操作符可以扩展为<span class=\"tips\">!~</span>来根据字段匹配来进行排除，awk会选定除满足正则表达式外的其他所有行\n\n<div class=\"show\">e.g.打印不包含\"22\"的行\nawk '!/22/{print $0}' data.txt \n输出值为：\n11AA 11AA\n33CC 33AA\n44DD 44AA\n打印第一个字段不包含\"AA\"的行\nawk '$1!~/AA/{print $0}' data.txt \n输出值为：\n22BB 22AA\n33CC 33AA\n44DD 44AA\n</div>\n\n##### 使用数学表达式\n在进行模式匹配时支持使用数学表达式进行比较，比较类型可以是数值，也可以是字符串，awk支持以下常用的比较符：\n\n<div class=\"table\">\n\n表达式|示例\n------|------\n==    |$1==\"root\"\n!=    |$3!=0\n&lt;  |$1&lt;10\n&lt;= |$1&lt;=10\n&gt;  |$1&gt;=10\n&gt;= |$1&gt;=10\n</div>\n\n<div class=\"show\">e.g.列出所有超级管理员(UID为0)的用户名\nawk -F: '$3==0{print $1}' /etc/passwd\n</div>\n\n#### 内建变量\n##### 字段相关内建变量\n\n<div class=\"table\">\n\n变量 | 说明\n-----|--------\n$n | $0代表整行文本，$n代表第n个字段\n$NF| 表示最后一个字段(可以在不知道总共有几个字段，无法使用$n表示时使用)\nFS | 输入字段分隔符\nOFS| 输出字段分隔符\nRS | 输入记录分隔符\nORS| 输出记录分隔符\nFIELDWIDTHS | 由空格分隔的一列数字，定义了每个数据字段确切宽度\n</div>\n\n##### 字段数据变量\n默认情况下，awk会将每一行文本使用字段分隔符划分为多个数据字段，并自动给每个字段分配一个变量，awk默认使用空白字符(如：空格、制表符)作为字段分隔符，数据字段可以使用相应的变量来引用，也可以通过修改变量来修改字段：\n\n+ <span class=\"strong\">$0</span>代表整个文本行\n+ <span class=\"strong\">$n</span>代表第n个数据字段\n+ <span class=\"strong\">$NF</span>代表最后一个字段，其中NF表示最后一个字段的索引值(也代表了该记录一共有几个字段)\n\n<div class=\"show\">1.可以通过字段数据变量引用和修改字段\necho \"java c python go \" | awk '{$2=\"c++\" ; print $0}'\n修改后的文本变为：\njava c++ python go\n2. 有时无法确切得知该行一共有多少个字段，$NF可以在不知道字段数量的情况下获取最后一个字段的数据，同时NF也表示该行一共有多少个字段\necho \"AA　BB　CC DD EE\" | awk '{print NF,$NF}'\n输出为：\n5 EE\n</div>\n\n##### 输入字段分隔符FS与输出字段分隔符OFS\n变量FS和OFS决定了awk如何处理数据流中的数据字段。其中变量FS决定了awk根据什么字符来分割输入的数据流，默认情况下，FS的值是空白字符，因此awk默认会根据空格、制表符等字符的位置来分割数据流。而某些文件有它独特的字段分割符，如：/etc/passwd 文件默认使用<span class=\"tips\">:</span>为字段分割符，在处理这些文件时，我们可以在将awk程序中FS的值修改为<span class=\"tips\">：</span>，方便awk程序正确分割passwd文件的字段信息。\n\n变量OFS决定了输出字段时，这些字段间的分隔符，在输出字段值时，print命令会自动将OFS变量的值放置在输出中的每个字段间。\n\n<div class=\"show\">e.g.文件data含以下内容\n10,20,30,40\nAA,BB,CC,DD\njava,c,python,go\n文件内容由<span class=\"tips\">,</span>隔开，因此FS值为<span class=\"tips\">,</span>，将字段使用----分隔后输出，注意print语句中字段变量之间的逗号只是用来指定多个变量，并不会输出到字段之间\n<span class=\"text-red\">awk 'BEGIN{FS=\",\";OFS=\"----\"}{print $1,$2,$3,$4}' data</span>\n输出信息：\n10----20----30----40\nAA----BB----CC----DD\njava----c----python----go\n</div>\n\n##### 根据数据宽度分隔字段FIELDWIDTHS\n有时文件中的数据并没有很规律地使用某个字符分隔，甚至部分信息是粘合在一起的，此时可以使用FIELDWIDTHS变量来定义一串值，以决定每个字段的字符长度，awk程序会根据这串值将文本分割为字段。FIELDWIDTHS变量能更精确地处理每个字段的宽度，很适合用来处理那些已经严格按照固定宽度格式化的数据。FIELDWIDTHS定义字段宽度的语法为：<span class=\"tips\">FIELDWIDTHS=\"值1 值2 值3....\"</span>\n\n<div class=\"show\">e.g.命令ls -lh列出的文件信息，文件所有者、所属组、其他用户权限是合并在一起写的，可以按字符长度将其分割出来\n(1)ls -lh命令输出信息为：\ntotal 24K\n-rw-r--r-- 1 root root  258 Jul 19 12:58 data.txt\n-rw-r--r-- 1 root root  185 Jul 19 13:40 script.awk\ndrwxr-xr-x 2 root root 4.0K Jul 16 05:40 test\n即首行会输出目录的总大小，可以通过sed命令'1d'删除第一行，然后将剩下信息用awk来处理，这里只分析文件的权限部分\n ls -lh | sed '1d' | awk '\n&gt; BEGIN {\n&gt; print \"文件类型\\t用户权限\\t用户组权限\\t其他用户权限\"\n&gt; print\"---------\\t--------\\t----------\\t------------\"\n&gt; FIELDWIDTHS=\"1 3 3 3\"\n&gt; }\n&gt; {\n&gt; print $1\"\\t\\t\"$2\"\\t\\t\"$3\"\\t\\t\"$4\n&gt; }'\n输出值为：\n<div class=\"table-show\" style=\"letter-spacing:normal\">\n\n文件类型|用户权限|用户组权限|其他用户权限\n-------|--------|---------|-----------\n\\-\\-\\-\\-|\\-\\-\\-\\-|\\-\\-\\-\\-\\-|\\-\\-\\-\\-\\-\\-\\-\n\\-|rw-|r--|r--\n\\-|rw-|r--|r--\nd |rwx|r--|r-x\n</div></div>\n\n##### 记录分隔符RS与ORS\n默认情况下，awk以一行为一个处理单位，awk会对所有行都执行一次程序，因此awk会将一行视为一个独立的数据记录。但有时，一个对象的不同数据可能会分布于多行，如一个用户的用户名，账号，Email地址等数据各占一行，这些多行数据共同构成一个用户的数据记录。我们不希望awk为每一行都执行一次程序，而是需要将这些多行视为一个处理单位(一个记录)，此时就需要用RS和ORS变量来指定awk程序的记录分隔符，以便字段变量能正确分配到数据值，其中，RS为输入记录分割符，ORS为输出记录分割符，默认情况下，它们的值都是换行符\n\n<div class=\"show\">e.g.文件data.txt含以下内容\nRiley Mullen \n123 Main Street \nChicago, IL 60601 \n(312)555-1234 <br />\nFrank Williams \n456 Oak Street \nIndianapolis, IN 46201 \n(317)555-9876 <br />\nHaley Snell \n4231 Elm Street \nDetroit, MI 48201 \n(313)555-4938\n数据中的每一组包含了一个用户的用户名，地址，电话信息，如果使用默认的FS和RS变量，awk会通过空格来分割字段，通过换行符来分割记录，导致数据被错误解析，对于该文件，一行是一个字段，数据记录通过空白行分割，因此FS变量应当是换行符，RS变量为空字符串：\n<span class=\"text-red\">awk 'BEGIN{FS=\"\\n\";RS=\"\"}{print $1,$4}' data.txt </span>\n输出值为：\nRiley Mullen  (312)555-1234 \nFrank Williams  (317)555-9876 \nHaley Snell  (313)555-4938\n通过ORS可以修改输出记录分隔符\nawk 'BEGIN{FS=\"\\n\";RS=\"\";ORS=\"======\"}{print $1,$4}' data.txt \n输出值：\nRiley Mullen  (312)555-1234 ======Frank Williams  (317)555-9876 ======Haley Snell  (313)555-4938======\n</div>\n\n#####　记录计数FNR和NR\nawk命令允许一次输入多个文件进行处理，在处理多文件时，<span class=\"tips\">FNR</span>变量表示当前数据文件中已处理过的记录数，<span class=\"tips\">NR</span>变量则含有已处理过的记录总数，FNR变量每处理完一个文件就会重置一次，而NR变量则会基于上一个文件的统计值继续增加。\n\n<div class=\"show\">e.g.处理两个文件,统计处理的记录数\nawk ' \n&gt; BEGIN {FS=\",\"} \n&gt; {\"FNR=\"FNR,\"NR=\"NR}' data1.txt data2.txt \nFNR=1 NR=1 #开始处理data1.txt\nFNR=2 NR=2 \nFNR=3 NR=3 \nFNR=1 NR=4 #开始处理data2.txt\nFNR=2 NR=5 \nFNR=3 NR=6\nFNR=4 NR=7\n</div>\n\n#### 其他内建变量\nawk还提供了一些用于提取shell环境变量，命令执行参数等信息的内建变量\n<div class=\"table\">\n\n变量名|说明\n------|-------\nARGC| 命令行参数个数(Argument Count的缩写)\nARGV| 命令行参数的值，以数组形式存储(Argument Vector的缩写)\nARGIND| awk处理的当前文件在ARGV中的位置\nCONVFMT| 数字的转换格式（参见printf语句），默认值为%.6 g\nENVIRON| 当前shell环境变量及其值组成的关联数组\nERRNO| 当读取或关闭输入文件发生错误时的系统错误号\nFILENAME| 用作gawk输入数据的数据文件的文件名\nFNR| 当前数据文件中的数据行数\nIGNORECASE| 设成非零值时，忽略gawk命令中出现的字符串的字符大小写\nNF| 数据文件中的字段总数\nNR| 已处理的输入记录数\nOFMT| 数字的输出格式，默认值为%.6 g\nRLENGTH| 由match函数所匹配的子字符串的长度\nRSTART| 由match函数所匹配的子字符串的起始位置\n</div>\n\n##### 提取命令行参数\n<span class=\"tips\">ARGC</span>和<span class=\"tips\">ARGV</span>变量用来从shell中获得命令行参数的个数以及参数的值，其中，ARGV是一个数组，存储了命令行中所有参数的值，其索引从0开始。注意，awk不会将awk程序当作命令行参数的一部分。awk命令也可以指定多个输入文件，awk会依次处理这些文件中的内容，而<span class=\"tips\">ARGIND</span>变量就用来获取当前awk程序处理的文件在ARGV数组中的索引\n\n<div class=\"show\">1.awk不会将程序部分视为命令行的参数  \nawk 'BEGIN{print ARGC,ARGV[0]}' data.txt config.json \n该命令行有3个参数，ARGV数组会存储这些参数，它们的值分别是：awk，data.txt，config.json。因此该命令输出值为：\n3 awk\n2.提取的参数只包含awk命令部分，如果shell命令包含其他部分，这些变量不会获取它们，如：\nls -lh | sed '1d' | awk 'BEGIN{print ARGC,ARGV[0]}'\nARGC和ARGV只会提取awk命令部分的参数个数和参数值\n1 awk\n3.ARGIND变量用来获取awk程序当前处理的文件在ARGV数组中的索引\nawk 'BEGIN{print ARGC,ARGV[2]}{print ARGIND}' data.txt config.json \n每读取一行文件内容，awk程序会执行一遍(BEGIN和END指定的除外)，因此文件data.txt和config.json有多少行，print ARGIND语句就会执行多少次，输出值为：\n3 config.json \n1\n1\n2\n2\n2\n</div>\n\n##### 获取shell环境变量\nawk程序中也可以获取shell的环境变量，awk提供了一个关联数组<span class=\"tips\">ENVIRON</span>用于存储shell环境变量，我们可以通过<span class=\"tips\">ENVIRON[\"环境变量名\"]</span>的方式来提取环境变量的值\n\n<div class=\"show\">e.g.在awk程序中获取环境变量HOME和PATH的值\nawk 'BEGIN{\n&gt;print ENVIRON[\"HOME\"]\n&gt;print ENVIRON[\"PATH\"]}'\n输出为：\n/root\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n</div>\n\n#### 自定义变量\nawk允许像shell一样自定义变量，且声明变量的方法与shell类似，直接声明<span class=\"tips\">变量名=值</span>即可，不需要var，int等关键字，变量名可以由字母、数字、下划线组成，且不能以数字开头，严格区别大小写。在awk中调用变量值时，<span class=\"tips\">不需要$</span>\n\n##### 在程序中声明变量\nawk在程序中声明变量时，直接像shell变量一样声明使用即可\n\n<div class=\"show\">1.变量值可以是字符串，调用变量时不需要$符号\nawk 'BEGIN{ name=\"Linux\"; print name }'\n2.变量值也可以是数值，并且支持包括加减乘除、取余(%)、冥运算(^或**)在内的数学运算\nawk 'BEGIN{ x=10; x=x*10+20; print x }\n</div>\n\n###### 变量的作用域\nawk程序是按顺序执行的，因此变量也将按语句生效生效，且awk程序中的大括号语句块并不会限制变量的作用域，如果在变量生效前调用该变量不会有任何输出值。\n\n<div class=\"show\">1.由于BEGIN语句块是最先执行的，因此剩下的语句块都可以调用BEGIN语句块中定义的变量\nawk 'awk 'BEGIN{ x=2 }{ print \"普通语句块：\"x }END{ print \"END语句块:\"x }' data.txt\n输出值为：\n普通语句块：2 #data文件有多少行，普通语句块就执行多少次\n普通语句块：2\n普通语句块：2\nEND语句块:2\n2.END语句块是最后执行的，因此END语句块中定义的变量无法在其他语句块中调用\nawk 'BEGIN{print \"BEGIN语句块：\"x}{print \"普通语句块：\"x}END{x=2}' data.txt\n输出值为：\nBEGIN语句块：\n普通语句块：\n普通语句块：\n普通语句块：\n3. 普通语句块中定义的变量，可以在END和位于该语句块之后的普通语句块中调用\nawk 'BEGIN{print \"BEGIN语句块：\"x}{x=2}{print \"第二个普通语句块：\"x}END{print \"END语句块:\"x}' data.txt \n输出值为：\nBEGIN语句块：\n第二个普通语句块：2\n第二个普通语句块：2\n第二个普通语句块：2\nEND语句库:2\n4.如果后面的普通语句块中定义了变量，前面的普通语句块在第一次执行程序时无法调用变量，但从第二次开始，由于该变量在第一次执行时会被存入，因此此后该变量就可以在前面的语句块中也读取到\nawk 'BEGIN{print \"BEGIN语句块：\"x}{print \"第一个普通语句块：\"x}{x=2}END{print \"END语 句块：\"x}' data.txt \n输出值为：\nBEGIN语句块：\n第一个普通语句块：   #第一次执行x并不存在\n第一个普通语句块：2  #awk读入文件第二行，程序再次执行，此时x存在\n第一个普通语句块：2\n第一个普通语句块：2\nEND语句块：2\n</div>\n\n\n##### 在命令行中声明变量\n变量也可以在命令行中赋值，尤其是当awk程序被写于文件中时，程序变量在文件中不方便修改，此时可以在命令行中定义或修改变量，能十分方便地在每次执行命令时指定不同的值。awk使用第一个非选项参数作为awk的程序，因此定义变量时，变量要写于awk程序之后，否则将报错\n\n<div class=\"show\">1.awk变量可以直接在命令行上定义，下述语句会输出data文件每行的第一个字段\nawk '{print $x}' x=1 data.txt\n2. 但通过该方式定义的变量无法在BEGIN代码块中访问到\nawk 'BEGIN{print \"begin代码块：\"x};{print \"普通代码块：\"x}' x=10 data.txt\n输出值为\nbegin代码块：    #输出的x值为空\n普通代码块：10\n普通代码块：10\n3. 通过-v选项定义的变量，则可以在BEGIN代码块访问到\nawk -v x=10 'BEGIN{print \"begin代码块：\"x};{print \"普通代码块：\"x}' data.txt\n输出值为：\nbegin代码块：10    #此时x的值可以访问到\n普通代码块：10\n普通代码块：10\n4. 不使用选项定义变量时，变量不能写于awk程序前\nawk x=10 'BEGIN{print x}' data.txt\n该语句将报错\n</div>\n\n#### 数组\nawk中使用的数组是关联数组，在定义和使用时需要加上数组的索引值\n\n##### 定义数组\n数组变量赋值语法格式为：\n<div class=\"apiBox\">数组名[索引值]=变量值</div>\n\n<div class=\"show\">数组索引可以为数值，也可以是字符串\nawk 'BEGIN{\n&gt;myArray[0]=10\n&gt;myArray[1]=20\n&gt;myArray[\"name\"]=\"awk\"\n&gt;}{\n&gt;print myArray[0]+myArray[1]\n&gt;print myArray[\"name\"]\n&gt;}' data.txt\n输出值为：\n30\nawk\n</div>\n\n##### 遍历数组\n由于用户无法提前得知数组的索引值是什么，因此awk提供了一个for语句可以用来获取awk的索引，用户可以在for语句中定义一个变量，for语句会将数组的索引赋值给该变量，然后就可以使用该变量作为索引获取到数组元素值，for语句语法格式为：\n<div class=\"apiBox\">for (变量名 in 数组名)\n{\n    循环体\n}</div>\n\n<div class=\"show\">awk 'BEGIN {\n&gt;array[\"name\"]=\"awk\";\n&gt;array[\"age\"]=18;\n&gt;array[\"system\"]=\"GNU/Linux\";\n&gt;for(something in array){\n&gt;print something     #数组索引\n&gt;print array[something] #数组值}\n&gt;}'\n</div>\n\n##### 删除数组元素\n删除数组元素的命令为：\n<div class=\"apiBox\">delete 数组名[索引值]</div>\n\n<div class=\"show\">数组元素删除后无法再调用\ndelete array[\"name\"]\n</div>\n\n\n#### 结构化命令\nawk中的条件和循环语句与shell语法差别很多，更像是C语言的语法，循环语句支持使用<span class=\"tips\">break</span>和<span class=\"tips\">continue</span>语句跳出或跳过循环\n##### if-else语句\nawk中的if-else语句不需要then：\n<div class=\"apiBox\">if(条件语句){\n    #程序体\n}else{\n   #程序体\n    }</div>\n\n<div class=\"show\">e.g.文件data包含以下内容\n11 11AA 11AA\n22 22BB 22AA\n33 33CC 33AA\n44 44DD 44AA\n如果字段1大于30，则输出字段2，否则输出字段3\nawk '{if($1>30){ print \"大于30\";print $2}else {print \"小于30\"; print $3}}' data.txt\n使用多行模式代码更为清晰\n awk '{\n&gt; if($1>30)\n&gt; {\n&gt; print \"大于30\"\n&gt; print $2\n&gt; }else\n&gt; {\n&gt; print \"小于30\"\n&gt; print $3\n&gt; }}' data.txt\n</div>\n\n##### while语句\n<div class=\"apiBox\">while(条件语句)\n{\n    # 循环体\n   }</div>\n\n<div class=\"show\">\nawk 'BEGIN{\n&gt;i=1\n&gt;total=0\n&gt;while(i&lt;5)\n&gt;{\n&gt;total+=$i  #求字段1,2,3,4的和\n&gt;i++\n&gt;}\n&gt;print total}'\n</div>\n\n##### do-while语句\n\n<div class=\"apiBox\">do\n{\n    # 循环体\n   }while(条件语句)</div>\n\n##### for语句\nawk支持的for语句有两种，一种是C语言风格的for循环：\n<div class=\"apiBox\">for(变量定义; 循环条件; 迭代语句)\n{\n    # 循环体\n}\n</div>\n\n一种是用于数组迭代的for-in循环(详见数组部分)：\n<div class=\"apiBox\">for (变量名 in 数组名)\n{\n    # 循环体\n}</div>\n\n<div class=\"show\">e.g.计算0-9的和\n&gt; awk 'BEGIN{\n&gt; total=0\n&gt; for(i=0;i&lt;10;i++)\n&gt; {\n&gt;  total+=i;\n&gt; }\n&gt; print total }' \n</div>\n\n#### 格式化打印printf\n<span class=\"tips\">print</span>语句只能进行基本的打印工作，如果要进行格式化打印需要使用<span class=\"tips\">printf</span>语句，awk支持像C语言一样使用格式化打印命令，只是语法有略微不同：\n<div class=\"apiBox\">printf \"格式控制语句\",变量1,变量2...</div>\n\n与C语言一样，printf语句支持以下控制字符：\n\n<div class=\"table\">\n\n控制字符|说明\n-------|-----------\n%c     |输出一个字符，支持将0~255内的整数输出为ASCII码对应字符\n%s     |输出字符串\n%d或%i |输出整数\n%f     |输出浮点数\n%e     |用科学计数法(规格化指数形式)输出数值\n%g     |根据数值大小自动选择使用%f或%e形式，保证输出宽度最小，不输出无意义的0\n%o     |以八进制形式输出整型\n%x     |以十六进制(字母小写)形式输出整型\n%X     |以十六进制(字母大写)形式输出整型\n</div>\n\n另外，printf也支持：\n+ 指定字宽，如：\"%5d\"，输出宽度为5的整数\n+ 指定小数位数，如：\"%6.2\"，输出包括小数点在内的6位数据，只保留2位小数(如果原数据小数部分超过两位，则四舍五入)\n+ 使用<span class=\"tips\">-</span>来指定数据左对齐(默认情况下，数据会进行右对齐)\n+ 使用\\t(制表符)、\\n(换行符)等转义字符\n\nawk中printf语句的用法完全可以参考C语言printf()函数用法，这里只写简单示例\n<div class=\"show\">1.整齐输出每个字段的数据\nawk '{printf \"数据：%s\\t%s\\t%s\\n\",$1,$2,$3}' data.txt\n输出值：\n数据：11\t11AA\t11AA\n数据：22\t22BB\t22AA\n数据：33\t33CC\t33AA\n数据：44\t44DD\t44AA\n<br />2.输出浮点数，保留两位小数\nawk 'BEGIN{printf \"%6.2f\",10.175}\n输出6位，因此左边会补两个空格\n  10.18\n</div>\n\n#### 内置函数\nawk提供了一些内建函数，用于处理字符串、时间等信息，以及进行数学运算\n\n##### 数学函数\n在进行数学运算时，值不能太大，awk无法处理一些过大的数据\n<div class=\"table\">\n\n   函数|说明\n----------|------\nsin(x)    |正弦函数，x为弧度值\ncos(x)    |余弦函数，x为弧度值\natan2(x,y)|x/y的反正切，x和y为弧度值\nexp(x)    |e<sup>x</sup>\nlog(x)    |以e为底的对数，即log<sub>e</sub>x或ln x\nsqrt(x)   |x的平方根，即 x<sup>1/2</sup>\nint(x)    |取x的整数部分，抛弃小数，不进行四舍五入\nrand()    |生成0-1(不包括0和1)之间的随机浮点数\nsrand(x)  |以x为种子值，生成随机数\n</div>\n\n<div class=\"show\">e.g.生成0-9之间(包括0和9)的随机整数\nx= int (10 * rand())\n</div>\n\n##### 字符串函数\nawk提供了一些用于处理字符串的函数，以下函数方括号中的参数是可选项，如果直接给函数输入字符串时，注意添加双引号\n\n<div class=\"table\">\n\n函数        |说明\n------------|------\nindex(s,t) |返回字符串t在字符串s中的索引值，如果没找到的话返回0\nlength([s])| 返回字符串s的长度；如果没有指定的话，返回$0的长度\ntolower(s) |将s中的所有大写字符转换成小写\ntoupper(s) |将s中的所有小写字符转换成大写\nasort(s [,d])|将数组s按元素值排序，索引值会被替换成从1开始的连续数字，原索引被覆盖。如果指定数组d，则排序后的数组会被存储在数组d中，原数组s保持不变\nasorti(s [,d])|将数组s按索引值排序，并使用索引值作为元素值，原数组元素值被覆盖，而数组的索引值会使用从1开始的连续数字替换。如果指定d，则排序后的数字存储于数组d中，原数组s保持不变\ngsub(r, s [,t])|从$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果找到了，就全部替换成字符串s\ngensub(regexp, replacement, how [, target])|使用正则表达式regexp匹配字符串，然后使用replacement替换匹配到的文本，replacement中可以使用\"\\1\",\"\\2\"等形式引用匹配的到的字符串，how用来指定替换方式，如果为\"g\"表示替换所有匹配项，如果为数字表示匹配第几个，target(可选)用来指定要应用替换的字符串，如果省略，则默认为$0\nmatch(s, r [,a])|返回字符串s中正则表达式r出现位置的索引。如果指定了数组a，它会存储s中匹配正则表达式的那部分\nsplit(s, a [,r])|将s用FS字符或正则表达式r（如果指定了的话）分开放到数组a中，返回字段的总数\nsprintf(format, variables)|用提供的format和variables返回一个类似于printf输出的字符串\nsub(r, s [,t])|在变量$0或目标字符串t中查找正则表达式r的匹配。如果找到了，就用字符串s替换掉第一处匹配\nsubstr(s, i [,n])|返回s中从索引值i开始的n个字符组成的子字符串。如果未提供n，则返回s剩下的部分\n</div>\n\n<div class=\"show\">1. index(s,t)函数返回字符串t从另一字符串s的哪个位置开始，它会将字符串s的每个字符(包括空格)都视为一个占位的字符，然后返回的是子字符串t是从字符串s的第几个字符位置开始\nawk 'BEGIN{print index(\"aa bb cc dd\",\"cc\")}'\n输出值为：7\n</div>\n<div class=\"show\">2. length([s])函数如果不指定字符串s，则会返回$0的长度\n如：输出data文件每行内容的文本长度(包含字段间的空格)\nawk '{print length()}' data.txt\n</div>\n<div class=\"show\">3. asort(s [,d])函数会按照数组元素在ASCII中的顺序对数组元素进行排序，大致排序类型为：数值(从小到大)->首字母大写的数组元素->首字母小写的数组元素，使用该函数进行排序时注意两点：\n(1)如果数组元素有数值，也有字符串，数值会按其大小正常排序，而不会将其转换为字符串进行处理\n(2)排序完的数组使用for-in遍历会乱序输出，无法正确看到被排序后的数组结果\n(3)关联数组的索引会被替换为从1开始的连续数字，索引从1开始而非0\n如：将下述代码写于文件script.awk中\n#!/bin/awk -f\nBEGIN {\narr[\"shell\"] = \"bash\"\narr[\"number1\"] = 2\narr[\"number2\"]=10\narr[\"name1\"] = \"Awk\"\narr[\"name2\"] = \"awk\"\narr[\"char\"] = \"2\"\nfor(some in arr){\n print some\"-------\"arr[some]\n}\nasort(arr);\nprint \"---------------\\n\"\n#使用for-in遍历关联数组输出顺序是随机的，想要数组按顺序输出则想要从索引1开始遍历，而不能用for-in\nfor(i=1;i&gt;6;i++){   \nprint i\"-------\"arr[i]\n}}\n给与script.awk文件执行权限后，执行./script.awk命令后输出值为：\nchar-------2     #for-in语句输出顺序随机\nname1-------Awk\nshell-------bash\nname2-------awk\nnumber1-------2\nnumber2-------10\n---------------\n1-------2    #数值按其大小正常排序，而不会将其作为字符按其ASCII码排序(否则10的首字母为1应该排于2前)\n2-------10   \n3-------2    #字符串类型的2排序于数值后\n4-------Awk  #首字母大写排于小写前\n5-------awk\n</div>\n\n##### 位运算\nawk支持以下位运算\n\n<div class=\"table\">\n\n函数    |说明\n--------|-----\nand(x,y)|将x与y按位进行<span class=\"text-red\">与</span>运算\nor(x,y) |将x与y按位进行<span class=\"text-red\">或</span>运算\nxor(x,y)|将x与y按位进行<span class=\"text-red\">异或</span>运算\ncompl(x)|对x进行补运算(按位取反)\nlshift(x,count)|将x左移count位\nrshift(x,count)|将x右移count位\n</div>\n\n##### 时间函数\nawk包含一些用来处理时间的函数\n\n<div class=\"table\">\n\n函数            |说明\n----------------|------\nsystime( )|返回当前时间的UNIX时间戳\nmktime(\"YYYY MM DD HH MM SS\")|将一个按YYYY MM DD HH MM SS格式指定的日期转换成UNIX时间戳，如果输入的日期时间无效，则返回 -1\nstrftime(\"时间格式\" [,time])|将时间time(如果未指定time则使用系统当前时间)以指定格式输出(格式需要为系统函数date允许的格式)\n</div>\n\n<div class=\"show\">1.systime( )会输出系统当前时间的UNIX时间戳，即返回系统当前时间到1970年1月1日以来的秒数，\nawk 'BEGIN { print systime() }'\n输出值：1580788800\n2.mktime()函数会将指定的时间转换为UNIX 时间戳，该函数常用来计算时间间隔\nawk '\n&gt;BEGIN {\n&gt;    t1 = mktime(\"2000 01 01 12 00 00\")\n&gt;    t2 = mktime(\"2020 07 31 12 00 00\")\n&gt;    diff = t2 - t1\n&gt;    print \"秒数差:\", diff\n&gt;}'\n3.strftime()函数用来格式化时间，常用来将时间输出为指定格式\nawk 'BEGIN { print strftime(\"%Y-%m-%d %H:%M:%S\") }'\n输出格式为：2020-11-02 16:30:05\n也可以指定一个时间戳\nawk 'BEGIN{time=systime();print strftime(\"%Y/%m/%d %H:%M:%S\",time)}'\n输出值：2020/07/31/24 20:33:20\n</div>\n\n#### 自定义函数\n##### 函数定义与调用\n在awk中定义、调用函数与C语言类似，但注意，在awk中需要将函数定义于代码块外，且必须出现在所有代码块之前(包括BEGIN代码块)，且awk中的自定义函数也支持传参与返回值：\n<div class=\"apiBox\">function 函数名(形参)\n{\n    #函数体\n  return 值   \n}</div>\n\n<div class=\"show\">e.g.对文件data.txt中的字段1和字段2求和\nawk '\n&gt;function add(num1,num2){\n&gt;return num1+num2\n&gt;}\n&gt;BEGIN{ print \"程序启动\" }\n&gt;{\n&gt;    result=add($1,$2)\n&gt;    print result\n&gt;}' data.txt \n</div>\n\n##### 函数库的创建与使用\n可以将多个函数写于一个库文件中，然后在awk命令中使用-f选项调用，如果awk程序也要从文件中加载，可以使用多个-f选项\n\n<div class=\"show\">e.g.库文件funclib定义了多个函数\nfunction myfunc1()\n{\n    ....\n}\nfunction myfunc2()\n{\n    ....\n}\n使用时在加载程序之前加载库文件即可：\nawk -f funclib -f script.awk data.txt\n</div>\n\n#### 调用外部变量\n在shell脚本中使用awk时，可能需要在awk中调用变量，有以下两种方法\n<div class=\"show\">通过-v选项定义一个awk变量，然后将shell变量值赋值给该awk变量，如：\nnewPort=8080\nawk -v port=\"$newPort\" '{gsub(8000, port); print}' config.json\n</div>\n\n<div class=\"show\">通过双引号与单引号的巧妙使用来获取变量\n<span class=\"text-red\">awk 'BEGIN{print \"'\"$变量名\"'\"}'</span>\n如：\nawk 'BEGIN{print \"'\"$LANG\"'\"}'\n输出值：en_US.UTF-8\n<span class=\"strong\">解析：</span>\nawk程序由单引号来包裹，因此需要通过一对单引号来关闭awk程序，即初始的命令形式为：\nawk 'BEGIN{print ' $LANG '}'\n该命令中，'BEGIN{print '为一部分，'}'为另一部分，$LANG左侧的'号关闭了awk程序，将控制权重新交给shell，shell解析$LANG获取到变量值en_US.UTF-8，然后$LANG右侧的'号重新开启了awk程序，\n此时命令相当于awk 'BEGIN{print en_US.UTF-8 }'，awk会将en_US.UTF-8视为变量，从而报错\n因此需要在外层加上一对双引号，将shell程序解析结果作为字符串交给awk程序，即命令修改为：\nawk 'BEGIN{print \"' $LANG '\"}'\n为什么不加在里面写出：awk 'BEGIN{print '\"$LANG\"'}'\n这是因为''中的为shell需要解析的部分，对于shell来说，$LANG和\"$LANG\"是相同的，都会获取变量，这就相当于执行echo $LANG和echo \"$LANG\"都一样。如果写出这种形式，shell处理完变量，awk解析的命令依旧为：awk 'BEGIN{print en_US.UTF-8 }'，依旧会由于变量en_US.UTF-8不存在而报错\n而双引号加在外面相当于awk执行：awk 'BEGIN{print \"en_US.UTF-8\"}'，它会直接输出字符串\n通常情况下，awk 'BEGIN{print \"' $LANG '\"}'也可以获取到变量值\n但如果变量值本身包含空格或引号，这依旧可能造成awk工作错误，因此通常会在$LANG两边再加上一对双引号，将LANG变量的值完全作为一个整体值获取，命令优化为：\nawk 'BEGIN{print \"'\"$LANG\"'\"}'\n\"'\"$LANG\"'\"中最外层的双引号用来保证awk会将值作为字符串处理，最内层的双引号保证变量值会被作为整体处理\n</div>\n\n#### 修改文件\nawk 没有直接提供类似sed的 -i 的选项来修改原文件内容，通常是先备份原文件，然后将awk的处理结果重定向到临时文件或原文件的方式来实现这一功能\n\n<div class=\"show\">e.g.修改文件data.txt中的字符串old_text为\nnew_text，然后将awk处理结果重定向到临时文件temp中，处理完毕后修改其文件名为data.txt进行覆盖(在此之前应该先备份好data.txt)\nawk '{gsub(/old_text/, \"new_text\"); print}' data.txt > temp && mv temp data.txt\n</div>","tags":["Linux"]},{"title":"Linux文本处理","url":"/blog/2021/12/29/Linux文本操作/","content":"### 输出文本\n#### echo打印文本\necho命令通常有多个版本，默认情况下通常会优先使用shell的内置版本，这里的命令语法是GNU coreutils包中的语法，但通常shell内置的echo命令也支持以下语法，如果需要使用GNU coreutils包中的echo命令，可以使用env(env echo...)来调用\n\n<span class=\"strong\">echo [选项] [字符串]</span>\n\n+ 默认情况下，指定多个字符串时，每个字符串之间会有一个空格，所有字符串输出完毕后会有一个换行符\n+ -n 不输出最后的换行符\n+ -e 启用转义字符\n\necho支持以下转义字符：\n<div class=\"table\">\n\n字符|说明\n----|-----\n\\a|警告铃\n\\b|退格\n\\c|终止输出，所有该转义字符之后的字符串将不被输出，类似于ctrl+c\n\\e|表示esc(Escape Character)，常用来引导控制终端输出格式\n\\f|换页\n\\n|换行\n\\r|回车\n\\t|水平制表符\n\\v|垂直制表符\n\\\\\\\\|输出反斜线\n\\0nnn|八进制数nnn(0-3位八进制数字)\n\\nnn|八进制数nnn(1-3位八进制数字)\n\\xhh|十六进制数hh(1位或2位十六进制数)\n</div>\n\n#### print格式化打印文本\n<span class=\"strong\">printf \"格式\" 参数(常量或变量)...</span>\n\nprintf命令支持的格式字符串和C语言基本一致，有略微不同：\n+ 命令会根据需要重复使用格式，并赋予所有参数，如：printf %.4d 1 2，参数1和2都会被给予格式%.4d，即便%.4d只指定了一个，输出为：00010002\n+ 如果指定了格式但没有给参数，命令会根据上下文将参数赋值为null(字符串)或0(数值)，如：printf \"aa%sbb%dcc\"，输出为aabb0cc，对于格式%s填充值为null(不打印任何字符)，对于格式%d填充值0\n\n<div class=\"show\">1. 输出字符串\nprintf \"%s %s\" aa bb\n2. 输出变量\nprintf 用户目录：%s $HOME\n</div>\n\n### wc统计字数/字节数/行数\n<span class=\"strong\">wc [选项] [文件1 文件2 ...]</span>\n\n+ -m 统计字符数\n+ -c 统计字节数\n+ -w 统计单词数，一个单词定义为由空白、换行符等分隔的字符串\n+ -l 统计行数，命令会统计换行符的数量作为行数\n+ -L 打印最长行的长度\n+ 如果给定多个文件，wc命令会依次打印每一个文件的数据，最后再打印一行这些文件的总合，并以total作为文件名\n\n<div class=\"show\">1.wc命令默认会依次显示行数、单词数、字节数、文件名\nwc test.txt\n输出为：\n  36   80 1012 test.txt\n2.查看指定的选项\nwc -l test.txt\n输出为：36 test.txt\n3.如果不想输出文件名，可以用重定向符\nwc -l &lt; test.txt\n</div>\n\n### 字符操作\n#### tr替换/删除匹配字符\ntr命令用来逐字符处理字符流，对字符串进行删除、替换等操作。tr命令本身不接收要处理的字符串，因此需要通过管道符或重定向符将要处理的字符串输入给tr命令。由于是逐字符处理，因此tr命令在处理大文件时可能较慢，适合用来进行简单字符转换和清理，相当于简化版的awk\n\n<span class=\"strong\">tr [选项] 'str1' ['str'2]</span>\n\n+ -d 删除指定字符，如果所输入字符串中出现了str1，删除所有str1\n+ -s 删除重复字符，如果所输入字符串中有相邻的重复字符，则删除到只保留一个该字符，常用来删除连续空白字符\n+ 如果同时指定了str1,str2，但无选项，默认是将所输入字符串中所有str1替换为str2\n+ -c或-C 需要指定str2，将所输入字符串中所有str1以外的字符替换为str2\n+ -t 将str1截断到和str2的长度\n\n\n<div class=\"show\">1. 将输入中的所有小写字母转换为大写字母\necho \"hello world\" | tr 'a-z' 'A-Z'\n2. 删除输入中的所有数字\necho \"abc123def456\" | tr -d '0-9'\n3.将多个连续的空格压缩为一个空格\necho \"hello    world\" | tr -s ' '\n4. 将所输入字符串中所有非字母字符替换为 *\necho \"hello 123 world!\" | tr -c 'a-zA-Z' '*'\n输出值：\nhello***world*\n</div>\n\n#### cut文本截取\ncut命令用于从文本文件或标准输入中按列截取部分文本\n<span class=\"strong\">cut [选项] [文件]</span>\n\n+ -b 截取范围：按字节截取指定文本\n+ -c 截取范围：按字符个数截取指定文本\n+ -d \"分隔符\"：指定字段分隔符，默认为制表符\n+ -f 截取范围：按字段截取指定文本\n+ -&zwnj;-complement：提取除指定部分以外的所有内容\n\n<div class=\"show\">1.截取第2-5个字符\necho \"abcdefg\" | cut -c 2-5\n输出：bcde\n2. 截取第2个字段\necho \"apple,banana,cherry\" | cut -d ',' -f 2\n输出：banana\n3. 截取文件的第二列\n假设文件data.txt中有以下内容\n1,John,Doe\n2,Jane,Smith\n执行命令：\ncut -d ',' -f 2 data.txt\n输出值：\nJohn\nJane\n</div>\n\n### 生成指定字符\n#### seq生成连续数字队列\nseq 用来生成一系列连续的数字，它可以指定数字生成的格式、增量，方便用户在脚本和命令行中，不使用循环就生成具有一定规律的数字，常用来搭配其他信息生成一些连续的字符串作为文件名等\n\n<span class=\"strong\">seq [选项] [起始值] [增量] 结束值</span>\n\n+ 默认情况下，每个数字都将被单独打印一行\n+ 如果不指定起始值或增量，则默认为1\n+ 增量的值不能为0，需要重复输出某个值应当使用yes命令\n+ 起始值、增量、结束值可以为inf，表示一个无穷大的值\n+ 当当前数字与增量相加，值大于结束值时，命令输出会结束，因此：seq 5 5将输出5，而seq 10 5将不会有任何输出\n+ -w 将数字格式化为等宽，前补0\n+ -f \"格式字符串\"：使用指定的格式输出数字，格式可以参考C语言print语句的输出格式要求\n+ -s \"分隔字符\"：指定输出序列中的分隔符(默认为换行符\\n)\n\n<div class=\"show\">1.生成 0 到 10 的序列，增量为5，且数字宽度相同\nseq -w 0 5 10\n输出值为：\n00\n05\n10\n2. 生成从 1.0 到 2.0，步长为 0.2 的小数序列\nseq 1 0.2 2\n输出值：\n1\n1.2\n1.4\n1.6\n1.8\n2\n3. 可以通过-f选项像C语言一样指定输出格式\nseq -f \"%.2f\" 1 0.3 2\n输出值：\n1.00\n1.30\n1.60\n1.90\n4. 可以搭配其他字符串\nseq -f \"No.%d\" 1 3\n输出值：\nNo.1\nNo.2\nNo.3\n5.可以通过-s选项指定字符分隔符\nseq -s \", \" 1 5\n输出值：\n1, 2, 3, 4, 5\n</div>\n\n#### yes持续输出字符串\n<span class=\"strong\">yes [字符串]</span>\n\n+ 默认情况下，该命令会一直输出字符'y'，后接一个换行符，直到命令被终止\n+ 如果指定了一个字符串，则会持续输出该字符串\n\n<div class=\"show\">该命令可以用于以下场景\n1. 某些命令在执行时需要用户重复输出y或n来确认操作，可以直接使用yes命令直接给与确认操作，避免手动输入\nyes | rm -ri /mydir\n2. 批量输出某个内容相同的字符串，输出10个指定字符串\necho $(yes \"别刷屏\" | head -n 10 | tr -d '\\n')\n3. 快速生成大文件以测试磁盘或某些工具的处理能力\nyes \"某个数据\" | head -n 1000 &gt; test_file.txt\n</div>\n\n### sleep延时\n\n<span class=\"strong\">sleep 时间值</span>\n\n+ 单位默认为s(秒)，可以使用m(分钟)、h(小时)、d(天)\n+ sleep inf 表示无限期延时\n\n### 格式控制\n#### numfmt格式化输出数字\nnumfmt命令用于格式化输出数字，它可以将具体数值转换为易读格式(如：4000000000输出为4G)，或者从易读格式转换为纯数字格式(如：4G输出为4000000000)\n\n<span class=\"strong\">numfmt [选项] [数字]</span>\n\n+ 如果未指定数字，命令将默认从stdin读取\n+ -d 字符：使用指定字符作为字段分隔符，默认为空格\n+ -&zwnj;-format=\"格式字符串\":使用printf支持格式作为输出格式，格式字符串必须包含一个<span class=\"tips\">%f</span>\n+ -&zwnj;-suffix=字符串：为输出的数字添加后缀，如添加单位符号，并且允许输入的数字中也携带该后缀\n+ -&zwnj;-grouping 根据当前区域设置分组规则(如：是否添加千分位分隔符<span class=\"tips\">,</span>)\n+ -&zwnj;-header=值n：前n行不转换格式，直接输出\n+ -&zwnj;-invalid=工作模式：当输入的数字出现错误时，可以使用该选项指定numfmt的工作模式，工作模式可以取以下值：\n>>+ abort：(默认)如果有错误的输入，立即退出命令，并返回状态码2\n>>+ fail：如果有错误的输入，打印其警告而不是立即退出命令，继续格式化其他数字，命令最后执行完时以状态码2退出\n>>+ warn：如果有错误的输入，打印其警告，命令最后执行完时以状态码0退出\n>>+ ignore：无视错误的输入，不打印警告信息，命令最后执行完时以状态码0退出\n+ -&zwnj;-padding=值n：通过添加空格将输出数字填充到 n 个字符。如果 n 为正数，则数字将右对齐。如果 n 为负数，则数字将左对齐\n+ -&zwnj;-round=方法：当值从易读格式转换为纯数字格式时，指定数字四舍五入的方法，方法可以取以下值：\n>>+ up：向上取整\n>>+ down：向下取整\n>>+ from-zero ：(默认)远离零的方向舍入，不论数字是正数还是负数，都会向绝对值更大的方向舍入。即对于正数，它会向上舍入；对于负数，它会向下舍入(即变得更负)\n>>+ towards-zero：向零的方向舍入，不论数字是正数还是负数，都会向绝对值更小的方向舍入。即对于正数，它会向下舍入；对于负数，它会向上舍入（即变得更接近零）\n>>+ nearest：四舍五入\n+ -&zwnj;-from=unit标准:将输入单位转换为相应数值，如果输入的值中包含K、M等单位，需要指定该选项，命令无法解析将返回错误,unit的取值参考下一个选项\n+ -&zwnj;-to=unit标准：将输出值转换为相应单位，如果输出的值需要转换为K、M等单位，需要指定该选项，unit的取值如下:\n>>+ none：不执行任何转换\n>>+ si：使用国际单位制SI进行转换，K、M、G等单位是以1000为基底的转换\n>>+ iec：使用国际电工委员会(IEC)标准进行转换，K、M、G等单位是以1024为基底的转换，大于1024的值将被四舍五入，这不是完全标准，但被经常使用\n>>+ iec-i：使用国际电工委员会(IEC)标准进行转换，Ki、Mi、Gi等单位是以1024为基底的转换，大于1024的值将被四舍五入\n>>+ auto：只能用于-&zwnj;-from选项，当输入值后单位为K、M等字符时，解析为SI标准，输入值后单位为Ki、Mi等双字母字符时，解析为IEC标准\n\n<div class=\"show\">1.将值转换为附带单位形式\nnumfmt --to=si 500000\n输出：500k\n2.将值转换为纯数字形式\nnumfmt --from=si 1M\n输出：1000000\n</div>\n\n#### expand将制表符转换为空格\n<span class=\"strong\">expand [选项] [文件名]</span>\n\n+ 默认情况下，命令会将所有制表符替换为8个空格\n+ -t 值：指定替换后的空格数量，默认为8。值可以指定多个，使用逗号分隔，如：-t 2,4,8 表示一行中的多个制表符依次替换为指定数量的空格\n+ -i 仅将每行行首的制表符转换为空格，忽略其他地方的制表符\n\n#### unexpand将空格转换为制表符\n<span class=\"strong\">unexpand [选项] [文件名]</span>\n\n+ 默认情况下，命令只会转换每行开头的空格(非空白字符之前的空格)，每8个空格会被转换为一个制表符，不足8个则不进行转换\n+ -t 值：指定转换的空格数量，默认为8，可以指定多个值，如：-t 2,4,8 表示一行中的多个不同数量的空格依次替换为制表符\n+ -a 转换所有空格，包括非行首的空格和不足连续8个的连续空格\n\n","tags":["Linux","File"]},{"title":"Linux服务与系统资源管理","url":"/blog/2021/12/29/Linux服务与系统资源管理/","content":"\n### 进程管理\n#### ps查看进程\n该命令来自<span class=\"tips\">procps-ng</span>包\n\n1. <span class=\"strong\">ps aux</span>&emsp;使用BSD(unix)标准格式显示进程\n\n+ a &emsp;显示所有前台进程\n+ x &emsp;显示所有后台进程\n+ u &emsp;显示进程由哪个用户产生\n\n<div class=\"show\">BSD格式的进程信息：\nUSER：该进程由哪个用户产生\nPID：进程的ID号\n%CPU：进程占用的CPU百分比\n%MEM：进程占用的物理内存百分比\nVSZ：进程占用的虚拟内存，单位为KB\nRSS：进程占用的物理内存大小，单位为KB\nTTY：进程在哪个终端运行，？为由Linux系统运行，tty1-tty6为本地字符界面终端，tty7为图形终端，pts/0-255为远程登录虚拟终端\nSTAT：进程状态，常见的状态字符有：R运行(runnable)，S睡眠(sleeping)，s包含子进程，+位于后台的进程组，T停止，&lt;优先级高的进程，N优先级低的进程，l多线程，Z僵尸进程，D无法中断的休眠进程(通常为IO进程)\nSTART：进程启动时间\nTIME：进程占用CPU时间\nCOMMAND：产生进程的命令名\n</div>\n2. <span class=\"strong\">ps -le</span>&emsp;使用Linux标准格式显示进程\n\n+ -l &emsp;显示详细信息\n+ -e &emsp;显示所有进程\n+ -C命令&emsp;显示指定命令的状态\n\n<div class=\"show\">Linux格式的进程信息：\nUID：产生进程的用户ID\nPID：进程的ID号\nPPID：父进程ID\nC：进程占用CPU百分比\nSTIME：进程启动时间\nTTY：进程在哪个终端运行，参数同上\nCMD：产生进程的命令名\n</div>\n\n#### pstree查看进程树\n<span class=\"strong\">pstree [选项]</span>\n\n+ -p &emsp;显示进程PID\n+ -u &emsp;显示进程所属用户\n\n#### lsof查看进程调用的文件\n<span class=\"strong\">lsof [参数]</span>\n\n+ -c 字符串 &emsp;只列出以字符串开头的进程打开的文件\n+ -u 用户名 &emsp;只列出某个用户所启动进程打开的文件\n+ -p pid   &emsp;只列出某个PID进程打开的文件\n\n\n\n#### top监控系统资源占用状态\n<span class=\"strong\">top [参数]</span>\n\n+ -d 秒数 &emsp;指定每几秒更新系统状态，默认是3秒\n\n显示当前系统的内存、CPU占用情况，显示状态下通过下列按键进行交互\n+ ?或h &emsp;显示交互帮助\n+ P &emsp; 根据CPU占用率显示进程顺序，默认\n+ M &emsp; 根据内存占用率显示进程顺序\n+ N &emsp; 根据PID显示进程顺序\n+ q &emsp; 退出top监控\n\n<div class=\"shell\">系统资源显示信息：\ntop - 15:40:11 up 41 days, 15:45,  2 users,  load average: 0.04, 0.05, 0.01\nTasks:  78 total,   1 running,  45 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :   492280 total,    15964 free,    74408 used,   401908 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.   375944 avail Mem\n\nPID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND  \n  1 root      20   0   51704   4948   3660 S  0.0  1.0  10:45.34 systemd\n</div>\n\n<div class=\"table\" style=\"text-align:left;\">\n\n|内容             |说明           |\n|:-----------     |:---            |\n|15:40:11         |系统当前时间\n| up 41 days,15:45|系统运行时间，已运行41天15小时45分|\n| 2 users         |当前登录用户数量|\n|load average: 0.04, 0.05, 0.01|系统在1分钟、5分钟、15分钟前的平均负载，根据主机内核数量判断负荷情况，如 8核，超过8表明已超负荷运行|\n|Tasks|Tasks后分别为 系统中的总进程数、正在运行的进程、睡眠进程、停止的进程、僵尸进程|\n| %Cpu(s)|us为CPU被用户占用的比率，sy为系统占用比例，ni为修改过优先级的用户进程CPU占用比率，id为CPU空闲的比率，wa为等待输入、输出的进程占用CPU的比率，hi为硬中断请求服务占用CPU比率，si为软中断请求服务占用CPU比率，st为有虚拟机时，虚拟CPU等待实际CPU的时间百分比|\n|  Mem |物理内存总大小、空闲内存大小、使用内存大小、正在缓冲的内存大小|\n| Swap |交换分区总大小、空闲部分、使用部分、有效大小|\n\n</div>\n\n#### vmstat按指定次数监控系统资源\n<span class=\"strong\">vmstat 刷新延迟 监听次数</span>\n\n输出进程数、内存状态、交换分区状况、硬盘输入输出状况、CPU状态\n<div class=\"show\"># vmstat 3 4\n每3秒监听一次系统资源，输出4次</div>\n\n#### free查看内存信息\n<span class=\"strong\">free [参数]</span>\n\n+ -b &emsp;以字节单位显示内存大小\n+ -k &emsp;以KB单位显示内存大小(默认)\n+ -m &emsp;以MB单位显示内存大小\n+ -g &emsp;以GB单位显示内存大小\n\n#### 中止进程\n##### 系统信号\n\n<span class=\"strong\">kill -l</span>查询可用的进程信号(选项为L的小写字母非I)\n\nLinux定义了64种信号，这些信号可由用户发起，也可由操作系统发起，信号在使用时可以使用其编号，也可以使用其名称，也可以是去除了<span class=\"tips\">SIG</span>前缀的信号名，以下为部分信号的作用：\n\n<div class=\"table\">\n\n代号|名称   |    说明           \n--- |----  | -------\n0   | |不发送有效信号，仅用来测试进程是否存在，以及用户是否有权限向该进程发送信号\n1   |SIGHUP|挂起进程，常用于通知进程重新加载配置文件或重启\n2   |SIGINT|中断进程(可通过ctrl+C发起)，常用于进程执行到一半中途停止，<span class=\"text-blue\">该信号可以被捕获</span>\n3   |SIGQUIT|退出进程(可通过Ctrl+\\\\发起)，并保存进程当前的内存映像生成core文件，用于调试\n4   |SIGILL |非法指令，表示进程可能在试图执行一个不符合操作系统或CPU架构规范的指令\n5   |SIGTRAP|跟踪/断点陷阱，通常用于在设置断点进行调试时，将进程设为跟踪模式\n6   |SIGABRT|异常终止，表示进程发生了致命错误导致进程终止\n7   |SIGBUS |总线错误，表示进程尝试执行无效的内存访问(如：尝试写入只读内存)\n8   |SIGFPE |浮点异常，表示进程执行了错误的浮点运算，如除以零或结果超出浮点数表示范围等\n9   |SIGKILL| 强制终止进程，进程将被立即终止而不给予进程保存文件、写入日志等操作时间，<span class=\"text-red\">该信号无法被捕获</span>\n10  |SIGUSR1| 用户自定义信号1\n11  |SIGSEGV| 段错误\n12  |SIGUSR2| 用户自定义信号2\n13  |SIGPIPE| 写到已关闭的管道\n14  |SIGALRM| 闹钟\n15  |SIGTERM| 正常终止进程，kill命令的默认信号，进程将被允许进行保存文件等操作后正常退出，<span class=\"text-blue\">该信号可以被捕获</span>\n16  |SIGSTKFLT|栈溢出\n17  |SIGCHLD| 子进程结束\n18  |SIGCONT| 继续停止的进程执行，即恢复通过信号19和20所暂停的进程执行\n19  |SIGSTOP| 强制暂停进程，由系统层面发出，<span class=\"text-red\">该信号无法被捕获</span>\n20  |SIGTSTP| 暂停进程(可通过Ctrl+Z发起)并放到后台，可以通过<span class=\"tips\">fg</span>命令将其恢复到前台继续执行，或通过<span class=\"tips\">bg</span>命令在后台继续执行，<span class=\"text-blue\">该信号可以被捕获</span>\n</div>\n\n##### kill向进程发送信号\n\n<span class=\"strong\">kill [-信号] [进程PID1,PID2...]</span> \n\n+ 默认情况下，如果不指定信号，命令将发送SIGTERM(15)信号\n+ 信号可以使用<span class=\"tips\">代号</span>形式，也可以使用<span class=\"tips\">信号名</span>形式，也可以是去除了<span class=\"tips\">SIG</span>前缀的信号名形式\n+ <span class=\"strong\">-s 信号</span>：指定信号，该选项可以直接缩写为<span class=\"tips\">-信号</span>形式，该选项完整形式为<span class=\"tips\">-&zwnj;-signal 信号</span>\n+ <span class=\"strong\">-l [信号]</span>：默认查看所有信号，如果指定了信号则只输出该信号的信号名或信号代号\n+ 不同的PID值，kill命令有不同作用：\n>>+ 如果PID为正值，则将信号发送给该PID对应的进程\n>>+ PID为<span class=\"tips\">0</span>，则信号会被发送给所有与当前shell或进程同属一个进程组的所有进程，这通常用于终止与当前进程或脚本有关的所有进程，而不仅仅是一个单一的进程\n>>+ PID为<span class=\"tips\">-1</span>，则信号会被发送给所有当前用户有权限发送的进程。对于普通用户，信号会被发送给该用户有权控制的所有进程，对于root用户，<span class=\"text-red\">这可能会影响系统的所有进程！</span>，一次性关闭所有进程，应当谨慎使用\n>>+ PID为<span class=\"tips\">-1以外的负值</span>，信号会被发送给所有进程组ID(PGID)=|PID|(绝对值)的进程组中的所有进程\n\n\n<div class=\"show\">1. 发送信号时，以下几个语句等价，都表示发送SIGTERM信号给PID为1234的进程\nkill -SIGTERM 1234 #完整的信号表示\nkill -TERM 1234    #省略SIG前缀\nkill -15 1234      #使用信号编号形式\nkill -s SIGTERM 1234 #使用-s选项\nkill -s 15 1234\nkill 15 1234       #使用信号编号时也可以省略-\n2. 测试PID为1234的进程是否存在，以及当前用户是否有权访问它\nkill -0 1234\n返回<span class=\"tips\">0</span>，表示进程存在且用户有权访问\n返回<span class=\"tips\">ESRCH</span>，表示进程不存在\n返回<span class=\"tips\">EPERM</span>，表示进程存在，但用户无权访问\n3. 终止当前进程组中的所有进程\nkill -TERM 0\n4. 终止进程组ID为456的进程组中的所有进程\nkill -KILL -456\n</div>\n\n\n##### killall命令\n<span class=\"strong\">killall [参数][信号代号] [进程名]</span> 根据进程名中止进程\n+ -i &emsp;询问是否杀死某进程\n+ -I &emsp;忽略进程名大小写\n\n##### pkill命令\n<span class=\"strong\">pkill [参数][信号代号] [进程名]</span>\n\n+ -t 终端号 &emsp;按终端号关闭用户的连接(踢出用户)\n\n<div class=\"show\"># pkill -9 -t tty1\n关闭终端号为 tty1 用户的连接\n</div>\n\n### 工作管理\n#### 将程序转入后台运行/暂停\n<span class=\"strong\">在命令后添加 <span class=\"tips\"> & </span>，可使该命令在后台执行</span>，后台执行的任务如果有输出语句依旧会显示于屏幕上(STDOUT和STDERR的消息)\n<div class=\"show\">如：\n# tar -zxf test.tar.gz &\n会在方括号中返回该任务在后台进程的作业号，并返回进程的PID\n[1] 3231\n然后将会在后台解压缩 test.tar.gz文件，执行完会提示Done并显示任务号\n[1] Done\n</div>\n\n<span class=\"strong\">在命令运行时执行<span class=\"tips\"> Ctrl + Z </span> 是将当前工作暂停后转入后台</span>\n<div class=\"show\">如：\n# top\n执行Ctrl + Z会将监视系统资源的top程序设为stopped(暂停)状态后转入后台\n</div>\n\n#### jobs查看后台的工作\n<span class=\"strong\"> jobs [-l]</span>\n\n+ -l &emsp;显示进程的PID和作业号\n+ -p &emsp;只显示进程PID\n+ -r &emsp;只显示运行中的进程\n+ -s &emsp;只显示停止的进程\n\n<div class=\"shell\">[1]   Stopped                 top\n[2]-  Stopped                 top\n[3]+  Stopped                 top</div>\n\n[3]代表工作序号，“+”号代表最后一个放入后台的工作，“-”号代表倒数第二个放入后台的工作，恢复时默认使用出栈方式从最后一个放入后台的工作开始恢复\n\n#### fg将后台暂停的工作恢复到前台执行\n<span class=\"strong\"> fg [%工作序号]</span>\n\n+ %可省略，如果不添加工作序号，则默认从后放入的工作开始恢复\n\n#### bg将后台暂停的工作恢复到后台执行\n<span class=\"strong\"> bg [%工作序号]</span>\n\n+ %可省略，如果不添加工作序号，则默认从后放入的工作开始恢复\n\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\ntop，vi等服务于前台的命令，不能恢复到后台执行。</div>\n\n#### chroot指定新根目录并运行命令\n\nchroot命令的作用是指定一个目录将其设置为虚拟的根目录，使后续命令在该虚拟根目录下执行。该命令通常用于创建一个受限的文件系统环境，使某些进程无法访问真实的系统文件。这个“根目录变更”行为类似于为进程设置一个“虚拟根目录”，这样进程就只能看到新根目录下的文件结构，从而增强系统的隔离和安全性，该命令可用于以下场景：\n+ 构建隔离环境：构建受限环境 (jail)，限制用户或进程只能够访问特定目录下的资源，防止其对主系统产生影响\n+ 测试与开发：受限环境中测试软件或脚本，而不影响真实系统\n+ 运行旧版或兼容软件：创建一个虚拟环境来运行旧版软件或与当前操作系统不兼容的软件\n+ 系统修复：当系统因配置错误或损坏而无法启动时，可以使用 chroot 命令进入系统的根文件系统并进行修复操作\n\n<span class=\"strong\">chroot [选项] 新的根目录 [命令]</span><span class=\"tips\">该命令需要root权限</span>\n\n+ 如果未指定命令，则将启动一个新的shell(具体哪一个shell取决于SHELL环境变量或/bin/sh)\n+ 新目录中需要有shell或所执行命令的二进制文件，否则将报错command not found\n+ -&zwnj;-userspec=用户名或ID[:组名或组ID]：以指定的用户身份，用户组身份执行命令\n+ -&zwnj;-groups=组名或组ID：将该组作为命令进程的附加组\n\n<div class=\"show\">  由于chroot命令会将执行环境限制到新的根目录中，因此所有需要使用的资源(包括命令的二进制文件、依赖等)都需要复制一份到新根目录中。如果不为chroot命令指定所要执行的命令，chroot会在该受限环境中启动一个新的shell，同样需要将shell的二进制文件、依赖提前复制到该新目录中，否则，所有命令都将因为找不到命令的二进制文件而提示command not found\ne.g.1要将/mnt/my_chroot设置为新的虚拟根目录，且在该目录下执行ls命令\n1.查看ls命令的依赖\nldd /bin/ls\n输出：\nlinux-vdso.so.1 (0x00007ffc0865f000)\nlibselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x000075e890fcf000)\nlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x000075e890c00000)\nlibpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x000075e890f35000)\n/lib64/ld-linux-x86-64.so.2 (0x000075e89102a000)\n2.将这些依赖和/bin/ls复制到/mnt/my_chroot中，并且文件结构要相同\n3.随后才能执行chroot命令\nsudo chroot /mnt/my_chroot ls\ne.g.2.如果不为chroot指定具体要执行的命令，chroot命令将在/mnt/my_chroot中启动一个子bash，同样需要使用上述步骤将bash的程序和依赖复制到/mnt/my_chroot目录下，才能启动bash，对于该bash以及在bash中执行的命令来讲，/mnt/my_chroot将是它们的根目录/，它们将无法访问/mnt/my_chroot及其子目录以外的资源\n</div>\n\n#### env在修改后的环境中运行命令\n<span class=\"strong\">env [选项] [环境变量=值] [命令]</span>\n\n+ 默认输出当前用户的所有环境变量，如果指定了环境变量赋值语句和命令，则该命令会在新的环境变量中执行\n+ -i 清除所有继承的环境变量，在一个干净环境中执行命令\n+ -u 变量名：删除指定的变量，再执行命令\n+ -C 文件名：在指定目录下运行命令，而不改变当前的工作目录\n\n<div class=\"show\">1.在添加了新环境变量后，在新环境中执行命令\nenv MY_VAR=hello bash -c 'echo $MY_VAR'\n2. 在删除了某个变量的环境中执行命令\nenv -u MY_VAR bash -c 'echo $MY_VAR'\n3.在在/tmp目录下执行ls命令，但不改变当前Shell的工作目录\nenv -C /tmp ls\n4.从file.env文件中批量加载环境变量并通过env命令输出验证\nsource file.env && env\n5.在脚本首行指定解释器路径\n#!/usr/bin/env python3\n如果直接使用 #!/usr/bin/python3，在某些系统中，python3可能并不位于/usr/bin目录下，可能导致系统无法找到解释器，而使用#!/usr/bin/env python3，系统会尝试前往环境变量的PATH中查看python3的位置，提高脚本的通用性\n</div>\n\n#### nohub退出终端时继续执行命令\n当命令或脚本正在运行时，如果此时退出了当前用户或shell终端，那么这些从该终端启动的进程也会随之退出(shell终端会向它们发送SIGHUP信号)。如果希望这些进程在退出用户或shell后仍能继续运行，则需要用一个特殊的命令<span class=\"tips\">nohup</span>来阻断所有发送给该进程的SIGHUP信号，这样命令或脚本在shell退出时会继续运行，其语法为：\n\n<div class=\"apiBox\">nohub 命令或脚本</div>\n\n<div class=\"show\">e.g.该命令也可以和&一起用，使脚本在后台执行并在终端退出时继续执行\nnohub ./test.sh &\n</div>\n\n我们使用的脚本和命令都是都和终端会话（pts/0）联系在一起的(可以通过ps命令查看该命令由哪个终端发起)，退出终端时，如果存在被停止的进程或后台未执行完的进程，大部分终端会提醒还有后台任务正在进行。在使用nohub命令后，该命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。为了保存脚本或命令产生的输出，nohup命令会在当前路径下创建一个名为<span class=\"tips\">nohup.out</span>的文件，并将STDOUT和STDERR的消息重定向到该文件中。如果当前路径下无法创建或写入<span class=\"tips\">nohup.out</span>，则会尝试创建<span class=\"tips\">$HOME/nohup.out</span>，如果这两个文件都无法创建，命令将不执行。也可以将其输出重定向到<span class=\"tips\">nohup.out</span>以外的文件\n\n<div class=\"show\">nohup ls &gt; make.log</div>\n\n#### timeout限制命令执行时间\n如果命令在到达指定时间后仍在运行，则将其终止，防止命令或脚本长时间挂起或无限循环的进程持续占用系统资源\n\n<span class=\"strong\">timeout [选项] 时间 命令</span>\n\n+ 时间后缀可以为<span class=\"tips\">s(秒)、m(分钟)、h(小时)、d(天)</span>\n+ -s 信号名或信号编号：超时后发送指定的信号，默认为SIGTERM\n+ -&zwnj;-preserve-status 超时后返回被终止命令的退出状态码，而不是timeout命令的退出状态码\n+ -&zwnj;-foreground 让目标命令在前台运行，即使timeout在后台调用\n+ -k 时间time：默认情况下，timeout命令会在到达指定时间后向命令发出SIGTERM信号或-s选项指定的信号，但这些信号可能会被捕获，或者由于需要保存数据进程会保留一段时间。-k选项可以给与一个额外的时间time，如果进程在收到第一个信号后的time时间，仍然没有关闭，则timeout命令会发送SSIGKILL信号(不可捕获)来强制关闭进程，time也可以使用s、m、h、d为后缀\n\n<div class=\"show\">1.指定命令的最长执行时间\ntimeout 10s ping google.com\n2. 让vim在前台运行，并且只能运行30s\ntimeout --foreground 30s vim\n3. 限制tail -f命令运行10秒，在10s后发送SIGTERM信号\n如果tail命令在收到SIGTERM信号后2秒内仍未退出，则 timeout 会发送SIGKILL信号，强制杀掉该进程\ntimeout -k 2s 10s tail -f /var/log/syslog\n</div>\n\n#### 调整谦让度\nLinux是多任务操作系统，进程在调用系统资源和占用CPU时间有不同的优先级，称之为调度优先级(scheduling priority)，调度优先级由系统内核负责分配，nice命令可以通过调整niceness的值，影响调度程序计算程序的调度优先级。但注意，niceness只是给调度器的建议，调度器可以自由选择是否忽略它，即nice命令只能一定程度影响调度器的优先级计算方式，不直接作用调度优先级。\n\n默认情况下，普通进程的niceness值为0，为正常优先级，niceness的取值范围为-20(最高优先级)到+19(最低优先级)，<span class=\"tips\">注意！值越小优先级越高</span>，\n\n##### nice指定调度优先级\n通过<span class=\"tips\">nice</span>命令可以查看当前进程的优先级，如果要指定命令或脚本的调度优先级，可以使用下述语法：\n\n<span class=\"strong\">nice [选项] [命令]</span>\n\n+ 默认给与的niceness值为10\n+ -n 值：给与指定的值，而不是默认的10\n+ <span class=\"tips\">只有root用户才能将进程的优先级值设置为负值，即只有root用户能提高进程的优先级，但允许所有用户降低进程的优先级</span>\n\n<div class=\"show\">nice命令中，-n选项可以直接替换为-值的形式\nnice -n 10 ./test4.sh\nnice -10 ./test4.sh\n调整优先级后，可以通过ps命令在NI一列查询到进程优先级\n#ps -o pid,ppid ni,cmd\nPID  PPID NI CMD \n4993 4721 10 /bin/bash ./test4.sh\n</div>\n\n\n##### renice修改调度优先级\n如果要调整已运行命令的优先级，可以使用renice命令(需要通过进程PID修改)：\n\n<span class=\"strong\">renice -n 值 -p 进程PID</span>\n\n+ 只能对属于该用户的进程执行renice\n+ 普通用户只能通过renice降低进程的优先级\n+ root用户可以通过renice来任意调整进程的优先级\n\n#### stdbuf调整命令的I/O缓冲\nstdbuf命令用于临时更改命令的标准输入(stdin)、标准输出(stdout)和标准错误(stderr)的缓冲模式，缓冲模式有三种：\n+ 行缓冲(line buffered)：每一行数据写入或读取时刷新缓冲区（遇到换行符时刷新），适合用于交互式命令行工具\n+ 完全缓冲(fully buffered)：缓冲区填满后再输出或输入，通常用于非交互式操作，提高性能\n+ 无缓冲(unbuffered)：数据立即写入或读取，不经过缓冲\n\nstdbuf适用于那些使用C标准库(glibc) I/O函数(如fread()和 fwrite())来处理标准输入、标准输出或标准错误的程序，如：cat、grep、sed、awk、cut、sort、head、tail、echo、printf、ls、read(作为 shell内置命令时，可能不生效，但作为外部命令时有效)、tee、tr、find、xargs、cut、wc，stdbuf无法处理那些直接使用系统调用(read()和write())作为I/O处理的函数，如：dd命令\n\n<span class=\"strong\">stdbuf 选项 命令</span>\n\n+ -i 模式：调整标准输入流的缓冲\n+ -o 模式：调整标准输出流的缓冲\n+ -e 模式：调整标准错误流的缓冲\n+ 模式可以取以下值：\n>>+ 0:无任何缓冲，此模式下数据会被立刻输出\n>>+ L：使用行缓冲模式，此模式下，输出数据会被合并，直到输出换行符，该选项对标准输入无效\n>>+ 值size：使用完全缓冲模式并指定缓冲区大小，size的值可以使用K、KB等单位\n\n<div class=\"show\">e.g.假设 echo 命令通常是按行缓冲的，当重定向到文件或管道中时，它可能会变成全缓冲。为了使 echo 在管道中也能立即输出，可以使用\nstdbuf -o0 echo \"Hello, World!\" | cat\n-o0 表示标准输出为无缓冲\n</div>\n\n\n## 软件安装\nLinux中的软件安装包一般分为两种：源码包和二进制包\n<p>源码包：一般是使用C语言编写但未经过编译的包，安装时需要编译，所以时间长且安装步骤多，容易报错，但方便程序员阅读和修改源码</p>\n<p>二进制包：源码包经过编译后形成二进制包，安装简单，安装速度快，但依赖性强，需要安装其他环境。二进制包通常有两大主流的管理系统：\n\n+ RPM 包管理系统：即Red-Hat Package Manager(红帽软件包管理器)，大多数 Linux 发行版默认的包管理方式，如 Fedora、CentOS、SuSE 操作系统。\n+ DPKG 包管理系统：为 “Debian” 专门开发的套件管理系统，主要应用在 Debian 和 Ubuntu 上</p>\n\nRPM包安装的默认路径为：\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>路径</th>\n<th>文件</th>\n<tr>\n</thead>\n<tbody>\n<tr><td>/etc/</td><td>配置文件</td></tr>\n<tr><td>/usr/bin/</td><td>可执行命令安装目录</td></tr>\n<tr><td>/usr/lib/</td><td>程序使用的函数库保存位置</td></tr>\n<tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr>\n<tr><td>/usr/share/man</td><td>帮助文件保存位置</td></tr>\n</tbody>\n</table>\n</div>\n因此通过RPM包安装的软件，服务启动时会自动去默认路径下寻找可执行命令，红帽系列的操作系统可通过系统服务管理命令<span class=\"tips\">service、systemctl</span>命令管理\n\n\n\n\n<p>源码包安装路径自定义，一般安装在<span class=\"tips\"> /usr/local/软件名/</span>路径下</p>\n\n\n#### 源码包安装\n由于未经过编译，源码包安装一般需要先安装gcc编译器。源码包的安装一般要经过\n1. 通过tar命令解压\n2. 进入解压缩的目录下\n3. 阅读INSTALL文件，INSTALL一般为安装说明\n4. 执行<span class=\"strong\"> ./configure</span>设置安装在默认路径下，也可以使用<span class=\"strong\"> ./configure --prefix=/usr/local/路径</span>自定义安装路径，执行完会根据配置项生成 Makefile 文件\n5. 执行<span class=\"strong\">make</span> 命令进行编译。如果报错，除错后执行<span class=\"strong\">make clean</span>删除编译产生的临时文件即可。\n6. 执行<span class=\"strong\">make install</span> 命令进行安装\n7. 源码包的卸载只需删除安装目录即可，不会遗留任何垃圾文件。\n\n#### RPM包安装\nRPM包安装需要提前安装好软件的依赖环境\n##### RPM包\nRPM包全名类似于 httpd-2.2.3-29.el5.i386.rpm ，其命名规则为\n1. 包名\n2. 版本号，格式通常为“主版本号.次版本号.修正号”\n3. 发布次数，表示RPM包是第几次编译后发布的\n4. 适合的Liunx平台，如el5表示支持RHEL 5.x/CentOS 5.x下安装\n5. 适合的硬件平台，目前RPM支持的平台有：i386、i586、i686、sparc和alpha，noarch为支持所有硬件平台。\n6. 后缀名，.rpm是编译好的二进制包，可用rpm命令直接安装；.src.rpm表示是源码包，需要编译以后才能安装\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n在安装软件时，有些命令后使用的是包的全名，有些命令使用的是包名，二者混用会导致软件无法安装</div>\nrpm模块依赖查询网站：<span class=\"tips\"> www.rpmfind.net </span>\n\n##### 安装升级与卸载\n1. <span class=\"strong\">rpm -[i或U]vh 包全名</span>&emsp;安装或升级软件\n\n+ -i &emsp;安装(install)\n+ -U &emsp;升级(upgrade)\n+ -v &emsp;显示详细信息(verbose)\n+ -h &emsp;显示进度(hash)\n+ -&nbsp;-nodeps &emsp;不检测依赖性(通常仅用于实验测试)\n\n2. <span class=\"strong\">rpm -e 包名</span>&emsp;卸载软件\n\n+ -&nbsp;-nodeps &emsp;不检测依赖性\n    \n\n##### 查询包信息\n###### 1. 查询是否安装了某个包\n<span class=\"strong\">rpm -q 包名</span>\n\n+ -q &emsp;查询(query)\n\n###### 2. 列出所有已经安装的rpm包\n<span class=\"strong\">rpm -qa&emsp;</span>\n\n+ -a &emsp;所有(all)\n\n###### 3. 查询rpm包详细信息\n<span class=\"strong\">rpm -qi 包名</span>\n\n+ -i &emsp;查询信息(information)\n+ -p &emsp;添加-p查询未安装包的信息(package)，对于未安装的包，包名应为完整包名\n\n###### 4. 查询包文件安装位置\n<span class=\"strong\">rpm -ql 包名</span>\n\n+ -l &emsp;列表(list)\n+ -p &emsp;未安装包的信息(package)，包名应为完整包名\n\n###### 5. 查询某个系统文件属于哪个rpm包\n<span class=\"strong\">rpm -qf 文件名</span>\n\n+ -f &emsp;系统文件(file)\n\n###### 6. 查询rpm包的依赖环境\n<span class=\"strong\">rpm -qR 包名</span>\n\n+ -R &emsp;查询包的依赖(requires)\n+ -p &emsp;未安装包的依赖(package)，包名应为完整包名\n\n##### 包校验\n<span class=\"strong\">rpm -V 已经安装的包名</span>\n<p>校验包中的文件是否正确，会返回包的验证信息</p>\n\n##### 包文件提取\n\n<span class=\"strong\">rpm2cpio 包全名 | cpio -idv 文件绝对路径</span>\n<p>cpio：标准工具，用于创建档案文件和从档案文件中提取文件</p>\n<p>rpm2cpio命令用于将rpm包转换为cpio格式</p>\n<div class=\"show\">示例：\nrpm2cpio coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls\n该命令可用于 /bin 目录下的 ls 目录被误删除，因而无法使用 ls 命令时，从 coreutils-8.4-19.el6.i686.rpm 包中提取 ls 目录到 bin 目录下，修复 ls 命令</div>\n\n### yum操作\nyum是一个由RedHat社区开发，基于RPM包管理的Shell前端软件包管理器，被广泛用于Fedora、RedHat以及CentOS中。yum能自动从指定的服务器下载RPM包并且安装，并自动处理依赖性关系\n#### 配置网络yum源\n网络yum源的配置文件路径为<span class=\"tips\"> /etc/yum.repos.d/CentOS-Base.repo </span>，配置信息类似于：\n<div class=\"shell\">[base]\nname=CentOS-$releasever - Base - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/\n        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n#additional packages that extend functionality of existing packages\n[centosplus]\nname=CentOS-$releasever - Plus - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/\n        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</div>\n\n配置信息中各项配置解析：\n+ [base] &emsp;容器名称，放在[]中\n+ name &emsp;容器说明，自由写\n+ mirrorlist &emsp;镜像站点\n+ baseurl &emsp;yum源服务器地址，默认为CentOS官方地址，国内可使用阿里云镜像地址\n+ enabled &emsp;该容器是否失效，enable=0为不生效，enable=1为生效但会略写。\n+ gpgcheck &emsp;为1则RPM的数字证书失效，0为不生效\n+ gpgkey &emsp;数字证书公钥文件保存位置\n\n#### yum安装软件\nyum命令中的包名不需要包的全名\n##### 查询包\n<span class=\"strong\">yum list &emsp;列出所有可用的软件包</span>\n\n<span class=\"strong\">yum search 关键字&emsp;搜索服务器上所有和关键字相关的包</span>\n\n##### 安装与升级\n<span class=\"strong\">yum -y install 包名</span>\n\n\n+ -y &emsp;对询问自动回答yes\n\n\n##### 升级、卸载\n+ yum -y update 包名\n+ yum -y remove 包名\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n升级时必须写包名，否则会升级所有包，包括Linux内核，会直接导致服务器崩溃。而卸载时会卸载包和包的所有依赖，但依赖可能还是其他包的依赖，因此可能导致其他软件功能失效，因此这两条命令慎用</div>\n\n#### yum安装软件包组\n+ <span class=\"strong\">yum grouplist &emsp;列出所有可用软件组</span>\n+ <span class=\"strong\">yum groupinstall 软件组名&emsp;安装软件组</span>\n+ <span class=\"strong\">yum groupremove 软件组名&emsp;卸载软件组</span>\n\n### 服务管理\n通过源码包安装的程序，所有文件会统一放置于如 /usr/local/ 目录下，而通过RPM包安装的程序，不同文件会放在不同目录下，如：可执行命令文件放在 /usr/bin 目录下，配置文件放在 /etc目录下。通过RPM包安装的软件服务，可以通过脚本文件启动，也可以通过service或systemctl命令直接启动，当执行该命令时，Linux会默认前往/usr/bin 目录下寻找相关文件。而通过源码包安装的服务由于安装路径不同，就无法通过该命令直接启动，但也可以将启动命令文件生成链接放置在/usr/bin目录下，这样源码包安装的服务也可以通过该命令启动了。\n\n卸载软件时，通过源码包安装的程序直接删除对应文件即可，而通过RPM包安装的软件，由于文件散列分布，因此需要rpm -e 命令来卸载。\n\n#### 服务查询\n查询服务开机自启动状态\n##### 1. RPM包安装的应用服务\n<span class=\"strong\">chkconfig -&zwnj;-list</span>\n\n查询所有RPM包安装的应用服务启动状态，会标出int0-6哪个级别系统启动状态下，服务会自启动。通过管道符可以查询指定服务的启动状态，如: chkconfig | grep nginx查看nginx服务的启动状态，在Centos7以后，该命令只能查看应用服务自启动情况，不包括系统本地服务，查看本地服务可以使用<span class=\"strong\">systemctl list-unit-files</span>命令，使用管道符可以只查看指定服务的启动状况。\n\n\n\n##### 2. 源码包安装的服务\n查看安装位置下对应服务的配置文件，一般位于<span class=\"tips\"> /usr/local/</span>路径下。\n\n#### RPM服务管理\n##### 独立服务管理\n常用文件路径\n<div class=\"table\">\n\n|    路径    |  说明     |\n|:---------:|:---------:|\n|/etc/init.d|启动脚本位置|\n|/etc/xinetd.d|基于xinetd 服务的启动脚本|\n|/etc/sysconfig|初始化环境配置文件|\n|/etc           |配置文件位置   |\n|/etc/xinetd.conf|xinetd 配置文件|\n|/var/lib       |放置服务产生的数据|\n|/var/log       |日志           |\n\n</div>\n\n##### 独立服务命令\n+ <span class=\"strong\">/etc/init.d/服务名&emsp;start/stop/status/restart </span>\n\n+ <span class=\"strong\">service/systemctl&emsp;服务名&emsp;start/stop/status/restart </span>&emsp;红帽系列系统专属\n\n##### 独立服务自启动\n+ 将启动程序的命令写入<span class=\"tips\"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令\n+ chkconfig 服务名 on/off &emsp;开启、关闭自启动，默认在2345运行级别下自启动\n\n\n##### 基于xinetd(超级守护进程)服务\nxinetd负责管理系统中不频繁使用的服务，这些服务程序在有请求时才由xinetd服务负责启动运行，一旦完成服务请求服务程序结束运行，以减少对系统资源的占用。\n\n基于 xinetd 的服务没有自己独立的启动脚本程序，需要依赖 xinetd 的启动脚本来启动。xinetd 本身是独立的服务，启动xinetd 服务的方法和启动独立服务的方法一致。\n\n基于 xinetd 的服务只需修改 <span class=\"tips\"> /etc/xinetd.d/服务名 </span> 文件下的 <span class=\"tips\"> /disable</span>为 <span class=\"tips\"> no</span>，然后重启xinetd 服务即可\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nxinetd常用于红帽系列的操作系统，需要用户自行安装</div>\n\n#### 源码包安装的服务管理\n##### 服务启动\n源码包安装的服务一般通过绝对路径下的脚本启动，具体路径需查看安装说明INSTALL文件。\n\n##### 自启动\n将启动程序的命令写入<span class=\"tips\"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令\n\n#### 查看开机时服务启动顺序\nLinux开机或关机时的服务启动/关闭顺序写于文件<span class=\"tips\"> /etc/rc.d/</span>路径下的对应文件中， <span class=\"tips\"> rc0-rc6 </span>文件中分别书写有系统不同启动级别下服务启动顺序。如 rc3 中，S85nginx表示系统启动时，nginx将是第85个启动的服务，K15nginx表示系统关机时，nginx将是第15个关闭的服务。\n\n\n###  alternatives工具\n#### alternatives简介\nalternatives工具常用于指定默认软件、默认配置，或者某一软件的默认版本。\n\n如：在Linux中，yum等工具一般使用python2作为命令解释器，而一些较新的软件依赖较新版的python3。因此有时我们不得不同时安装python2和python3。如果使用 python3 作为默认的python版本，使用yum会抛出错误，这是因为使用了python3解析yum中python2的语法，同理，一些较新的软件也无法使用python2解析。此时，我们就需要使用alternatives来控制软件的默认版本。\n\nalternatives的使用方法是：给定两个软件或多个软件的路径，然后将它们注册为一个组，为这个组建立一个软链接，之后调用软件将直接从这一软链接调用\n\n#### alternatives命令\n##### 注册组\n<span class=\"strong\">alternatives -&zwnj;-install &lt;link> &lt;name> &lt;path> &lt;priority></span>\n\n+ -&zwnj;-install 注册(新增)需要管理的命令/软件\n+ link：注册路径，会在该路径下生成一个软链，此后由该软链启动命令\n+ name：组名\n+ path：软件/命令的路径，将该路径下的命令加入alternatives管理组\n+ priority：权值，在自动模式下，权值越高，软件优先级越高\n\n##### 其他命令\n+ <span class=\"strong\">alternatives -&zwnj;-config &lt;name></span> 修改默认配置(将进入交互模式，并切换为手动模式)\n+ <span class=\"strong\">alternatives -&zwnj;-set &lt;name> &lt;path></span> 修改默认配置(将切换为手动模式)\n+ <span class=\"strong\">alternatives -&zwnj;-auto &lt;name></span> 切换为自动模式\n+ <span class=\"strong\">alternatives -&zwnj;-display &lt;name></span> 显示对应组的配置信息(包括自动/手动模式，路径，权值)\n+ <span class=\"strong\">alternatives -&zwnj;-remove &lt;name> &lt;path></span> 删除组中对应路径的软件\n+ <span class=\"strong\">alternatives -&zwnj;-list</span> 列出所有组的信息(组名、自动/手动模式、当前默认软件路径)\n\n\n#### 示例\n##### 1. 注册组\n在<span class=\"tips\">/usr/bin</span>目录下有python2.7与python3.7的启动命令，我们可以新建python组，将python2和python3的启动路径加入到该组中，并指定python3为默认版本，此后直接执行<span class=\"tips\">python</span>命令将唤醒python3，而不用再指定明确的版本号，且将默认唤醒python3，该默认值是可以随时更改的\n<div class=\"shell\"><code># alternatives --install /usr/bin/python python /usr/bin/python2.7 10\n# alternatives --install /usr/bin/python python /usr/bin/python3.6 20\n</code></div>\n\n上述命令\n+ 将在 <span class=\"tips\">/usr/bin</span> 目录下新建名为 <span class=\"tips\">python</span> 的软链接，该软链接指向<span class=\"tips\">/etc/alternatives/python</span>，该链接又指向<span class=\"tips\">/usr/bin/python3.6</span>\n\n<div class=\"show\">即 /usr/bin/python --> /etc/alternatives/python --> /usr/bin/python3.6</div>\n\n+ 修改默认值，修改的是/etc/alternatives/python的指向，即默认值为python2.7时，/etc/alternatives/python链接指向将修改为/usr/bin/python2.7\n+ python3.6的权值为20，python2.7的权值为10，自动模式下，alternatives将优先调用python3.6\n+ 生成链接名可以任意自定义，并且调用命令也将相应修改，如：\n<div class=\"shell\"><code>alternatives --install /usr/bin/py ppyy /usr/bin/python3 10</code></div>\n调用命令将变为py:\n<div class=\"shell\">py --version #同python3 --version命令</div>\n\n###### 2. 修改默认值\n<div class=\"shell\"><code>alternatives --config python</code></div>\n将进入交互模式，让你输入序号选择版本\n<div class=\"shell\">There are 2 programs which provide 'python'.\n  Selection    Command\n-----------------------------------------------\n   1           /usr/bin/python2.7\n*+ 2           /usr/bin/python3.6\n\nEnter to keep the current selection[+], or type selection number: \n</div>\n\n+号为当前生效的版本，*为新增版本\n\n###### 3. 查看python组信息\n<div class=\"shell\"><code>alternatives --display python</code></div>\n<div class=\"shell\">python - status is manual. #python处于手动模式\n link currently points to /usr/bin/python3.6 #当前默认使用python3.6版本\n/usr/bin/python2.7 - priority 10  #可选版本信息\n/usr/bin/python3.6 - priority 20\nCurrent `best' version is /usr/bin/python3.6.\n</div>\n\n###### 4. 从组中删除python3.6版本\n<div class=\"shell\"><code>alternatives --remove python /usr/bin/python3.6</code></div>\n从python组中移除3.6版本，将只剩2.7版本可选\n\n\n### 定时任务\n#### at命令\nat命令用于预设脚本或命令的运行时间，at命令的守护进程atd会以后台模式运行，检查作业队列来运行作业。大多数Linux发行版会在启动时运行此守护进程，atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60秒检查一下这个目录，并获取作业预定的运行时间。at命令的语法为：\n\n<span class=\"strong\">at [选项] 时间</span>\n\n+ 默认情况下，输入at+时间后，at命令会进入交互模式开始接收需要执行的命令，输入完毕后通过Ctrl+D完成输入\n+ 如果已经错过指定时间，则命令会在第二天的同一时间再执行\n+ -f 文件名：到指定时间执行该脚本\n+ -q 字母：指定队列字母\n+ -M 屏蔽脚本或命令的输出信息\n\nat命令支持的时间格式很多，包括：\n+ 具体的精确时间，如：at 10:30、at 2pm、at 2024-06-21 15:00\n+ 相对时间，如：at now + 1 hour、at now + 2 days、at 3pm tomorrow、at 10:30am + 1 week\n+ 特定命名时间，如：at now(立即执行)、at noon(中午12:00)、at midnight(午夜12:00)、at teatime(下午茶时间4:00)、\n+ AM/PM指示符，如：at 10:15PM\n+ 标准日期格式(MMDDYY、MM/DD/YY或DD.MM.YY)\n+ 文本日期，比如Jul 4或Dec 25，加不加年份均可\n\n<div class=\"show\">e.g.在一分钟后执行ls命令\nat now + 1 minute\nat&gt; ls      #进入交互模式接收命令\n(Ctrl+D结束输入)\n或\necho \"ls\" | at now + 1 minute\ne.g. 执行脚本\nat -f ./test.sh \n</div>\n\n在使用at命令时，该作业会被提交到作业队列（job queue）。作业队列会保存通过at命令提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a-z和大写字母A-Z来指代，作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的作业会被提交到a作业队列。如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。\n\n当作业在Linux系统上运行时，作业中的输出将不显示到屏幕上。取而代之的是，Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给该用户，这需要Linux安装了sendmail应用程序。如果未安装该程序，或者不需要脚本输出信息，应当做好重定向工作，或使用<span class=\"tips\">-M</span>选项屏蔽作业产生的输出信息。\n\n##### 查询at定时任务\n\n<span class=\"strong\">atq</span> 查询at命令设置的作业\n\n该命令会返回了作业号、系统运行该作业的日期和时间及其所在的作业队列(字母)\n<div class=\"show\">e.g.返回信息类似于\n20 2015-07-14 13:03 = Christine \n18 2015-07-15 13:03 a Christine \n17 2015-07-14 16:00 a Christine \n19 2015-07-14 13:30 a Christine\n</div>\n\n##### 删除at定时任务\n\n<span class=\"strong\">atrm 作业号</span> 删除指定的作业\n\n普通用户只能删除自己提交的作业，无法删除其他用户的作业\n\n#### crond服务\ncron即计划任务，而crond则是一个常驻服务，在Linux中用于周期性执行某个任务，该服务的配置文件位于<span class=\"tips\">/etc/crontab</span>\n\n##### 查看crond服务运行情况\n<span class=\"strong\">ps aux | grep crond</span>查看crond进程是否在运行，红帽系列的操作系统可使用<span class=\"strong\">service status crond</span>或<span class=\"strong\">systemctl status crond</span>(centos7+)\n\n##### 查看crond服务是否开机自启动\n<span class=\"strong\">chkconfig -&zwnj;-list | grep crond</span>或<span class=\"strong\">systemctl list-unit-files | grep crond</span>(centos7+)\n\n#### 设置crond定时任务\n可通过修改<span class=\"tips\">/etc/crontab</span>文件来设置定时任务，同路径下还有 cron.daily，cron.weekly等对应时间记录crond任务的文件。也可以通过命令来修改crontab文件，语法为:\n\n<span class=\"strong\">crontab [参数]</span>\n\n+ -e &emsp;编辑crontab定时任务\n+ -l &emsp;查询crontab定时任务\n+ -r &emsp;删除当前用户所有crontab任务\n\n##### cron语法\n编辑定时任务时会打开vi编辑器，编辑语法格式需遵循cron语法，基本格式为：<span class=\"tips\"><strong>***** 命令</strong></span>\n\n+ <span class=\"strong\">第一个*表示一小时当中的第几分钟，范围为0-59</span>\n+ <span class=\"strong\">第二个*表示一天当中的第几个小时，范围为0-23</span>\n+ <span class=\"strong\">第三个*表示一个月当中的第几天，范围为1-31</span>\n+ <span class=\"strong\">第四个*表示一年当中的第几个月，范围为1-12</span>\n+ <span class=\"strong\">第五个*表示一周当中的星期几，范围为0-7(0和7都代表星期日)</span>\n\n<div class=\"table\">\n\n|特殊符号|含义|\n|:--    |:--|\n|*      |代表任何时间|\n|,      |代表不连续的时间|\n|-      |代表连续的时间范围|\n|*/n    |代表隔多久执行一次|\n</div>\n\n<div class=\"show\">示例：\n30 23 * * * 命令      //每天的23：30执行对应命令\n0 1 1,15 * * 命令    //每个月1号和15号凌晨1:00执行命令\n30 2 * * 1-3 命令   // 每周一到周三凌晨2点30执行命令\n*/10 4 * * * 命令   //每天凌晨4点，每隔10分钟执行一次命令，执行6次(即小时数超过4时就停止)\n0 0 1,15 * 1 命令   //每个月1号，15号和每周一凌晨00:00执行一次命令\n0 2 1 * * /sbin/shutdown -r now 每个月1号凌晨2：00重启Linux\n</div>\n\n### 日志服务\n#### rsyslog服务\nSyslog(系统日志协议)是在一个IP网络中转发系统日志信息的标准，syslogd服务被广泛用于老版Unix/Linux系统中负责记录系统日志，RSyslog是syslog的多线程增强版，CentOS6以后系统默认使用Rsyslogd服务记录系统日志。\n\n##### 查询rsyslog服务是否在运行\n可使用命令<span class=\"strong\">ps aux | grep rsyslogd</span>查看rsyslog进程是否在运行，红帽系列可使用命令<span class=\"strong\">systemctl status rsyslog</span>查看\n\n##### 查看rsyslog服务是否开机自启动\n+ <span class=\"strong\">chkconfig --list |grep rsyslog</span>\n+ <span class=\"strong\">systemctl list-unit-files | grep rsyslog</span>(centos7)\n\n#### 日志文件\n系统日志默认保存在 <span class=\"tips\">/var/log</span> 路径下，对应文件的作用:\n<div class=\"table\">\n\n文件          |        说明|\n----          |         ----|\n/var/log/cron |定时任务相关日志\n/var/log/cups|打印系统的日志|\n/var/log/dmesg|开机内核自检的信息，使用dmesg命令就是读取了该文件|\n/var/log/btmp|错误登录日志，二进制文件，需通过<span class=\"tips\">lastb</span>命令查看|\n/var/log/lastlog|记录所有用户最后一次登录系统的日志，二进制文件，需通过<span class=\"tips\">lastlog</span>命令查看|\n/var/log/mailog|邮件日志|\n/var/log/message|记录系统所有重要事件信息\n/var/log/secure|记录所有涉及用户账户和密码的信息，如：用户登录，添加用户，切换用户，sudo授权，修改密码等|\n/var/log/wtmp|永久记录所有用户的登录、注销、系统启动、重启等信息，二进制文件，需使用<span class=\"tips\">last</span>命令查看|\n/var/log/utmp|记录当前登录的用户信息，并且随着用户注销、切换不断变化，使用w,who,users等命令查看\n\n</div>\n\n使用RPM包安装的服务也会默认把日志文件放在<span class=\"tips\">/vat/log/服务名</span> 路径下，但其日志由自身服务管理，而不归rsyslogd服务管理\n\n使用源码包安装服务的日志文件位于用户指定的安装路径下，一般位于 /usr/local路径下\n\n#### rsyslog日志格式\n日志文件通常由以下内容按顺序书写：\n+ 事件产生时间\n+ 服务器主机名\n+ 产生事件的服务名\n+ 事件的具体信息\n\n#### rsyslog日志配置文件\n该配置文件位于<span class=\"tips\">/etc/rsyslog.conf</span>，配置文件决定了日志系统记录哪些级别的日志信息，文件的格式为 <span class=\"tips\"><strong>服务名[连接符]日志等级&emsp;&emsp;日志记录位置</strong></span>\n\n##### 服务名\n<div class=\"table\">\n\n服务名称 | 说明\n----    |-----\nauth    |安全和认证相关信息\nauthpriv|安全和认证相关信息(私有信息)\ncron    |系统定时任务cront和At产生的日志\ndaemon  |守护进程相关的日志\nftp     |ftp守护进程相关日志\nkern    |内核产生的日志\nlocal0-local7|为本地预留的服务项\nlpr     |打印系统产生的日志\nmail    |邮件日志\nnews    |新闻服务器相关日志\nsyslog  |rsyslog服务产生的日志\nuser    |用户等级类别产生的日志\nuucp    |uucp(数据传输协议)子系统的日志\n\n</div>\n\n##### 连接符\n\n<div class=\"table\">\n\n连接符|说明\n----|----\n.   |表示比后面所写等级高(包含该等级)的日志都记录下来\n.=  |只记录指定等级的日志\n.!  |除了该等级，其余等级都记录\n</div>\n\n##### 日志等级\n\n<div class=\"table\">\n\n等级   |说明\n----  |----\n<strong>*</strong>     |所有等级\nnone  |与*相反，不记录任何日志\n debug|调试信息\n info |通知信息，反馈系统状态\n notice|提醒信息，程序可能存在潜在错误，但不影响运行\n warning|警告信息，程序发现错误，暂且不影响运行\n err    |错误信息，服务出错停止运行，需要修复\n crit   |临界状态信息，服务宕机，且可能无法修复\n alert  |警报信息，服务宕机，影响系统运行\n emerg  |紧急信息，系统疼痛等级，系统濒临崩溃甚至已经崩溃\n</div>\n\n##### 日志记录位置\n日志记录位置可以是以下值:\n+ 路径，写于本机指定位置，如:/var/log/lastlog\n+ 系统设备，写于U盘或者通过打印机打印日志，如:/dev/lp0\n+ 转发到远程主机或日志服务器，如:@192.168.0.100:514\n+ 用户名，发送给指定用户，如:root\n+ 忽略或丢弃日志，如：~ ，直接丢弃\n\n##### 示例\n以下示例来源于centos7系统默认配置\n<div class=\"shell\">cron.*                                                  /var/log/cron\n所有等级的cron日志写于/var/log/cron文件中\n*.emerg                                                 :omusrmsg:*\n出现疼痛等级的日志时，发送给所有用户\n*.info;mail.none;authpriv.none;cron.none                /var/log/messages\n不记录任何私人身份验证消息\nuucp,news.crit                                          /var/log/spooler\n将uucp,news服务crit和更高级别的日志信息保存在指定文件中\n</div>\n\n\n#### 日志轮替\n日志轮替用于用新日志覆盖旧日志，其配置文件位于<span class=\"tips\">/etc/logrotate.conf</span>，需要相关功能只需在配置文件中添加对应参数就即可。\n\n<div class=\"table\">\n\n参数                |说明\n-------             |--\ndaily/weekly/monthly|日志轮替周期\nrotate 数字         |保留日志文件的个数，0为不备份\ncompress           |日志轮替时，对旧日志进行压缩\ncreate 权限值 所有者 所属组|建立新日志，并指定日志文件的权限、所有者、所属组\nmail address       |日志轮替时，日志内容发送到指定邮箱，如:mail 11@gmail.com\nmissingok           |日志不存在时，忽略该日志的警告信息\nnotifempty          |如果日志文件为空，则不进行轮替\nmaxsize 大小        |当日志文件到达指定大小，无论是否到轮替时间，都进行一次轮替，未到达指定大小但到达轮替周期，也进行轮替\nminsize 大小        |到达轮替时间时，如果日志文件达到该最小值时就进行轮替，否则不进行轮替\nsize 大小           |时间周期设置无效，只有当日志文件大于指定大小才进行轮替\ndateext             |使用日期作为日志轮替文件名\n\n</div>\n\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n<span class=\"tips\">dateext</span>参数用于指定当前日期作为日志文件后缀名，如:secure-20210211。如果配置文件中没有该参数，则日志文件将以.1，.2作为文件名名后缀。如：当前日志文件为secure，进行轮替后该文件改名为secure.1，secure.1改为secure.2，而将新的日志文件命名为secure。</div>\n\n##### 配置文件内容\n通过RPM包安装的服务其日志会被自动识别配置轮替，通过源码包安装的服务需要自行添加配置，配置格式同本地配置的基本格式。\n\n<div class=\"shell\"># see \"man logrotate\" for details\n# rotate log files weekly\nweekly\n\n\\# keep 4 weeks worth of backlogs\nrotate 4\n\n\\# create new (empty) log files after rotating old ones\ncreate\n\n\\# use date as a suffix of the rotated file\ndateext\n\n\\# uncomment this if you want your log files compressed\n#compress\n\n\\# RPM packages drop log rotation information into this directory\ninclude /etc/logrotate.d\n\n\\# no packages own wtmp and btmp -- we'll rotate them here\n/var/log/wtmp {\n    monthly\n    create 0664 root utmp\n\tminsize 1M\n    rotate 1\n}\n/var/log/btmp {\n    missingok\n    monthly\n    create 0600 root utmp\n    rotate 1\n}\n本地配置格式(若某参数同时设置了本地配置和全局配置，则本地配置生效)\n日志路径 {\n  配置参数\n}\n如：\n/usr/local/apache/logs/access_log {\n  daily      //每天进行日志轮替\n  create    //日志轮替时新建日志，文件权限、所有者等信息默认\n  rotate 30 //保留30份日志文件(即保留30天)\n}\n</div>\n\n##### 手动进行日志轮替\n<span class=\"strong\">logrotate [参数] 配置文件名</span>\n\n不添加任何参数时，将按配置文件进行轮替\n+ -v 显示日志轮替的过程\n+ -f 无论是否达到轮替配置要求，强制进行日志轮替\n\n### 备份与恢复\n#### 备份\n<strong>完全备份：</strong>即把所有需要备份的数据全部备份， 在Linux 中，完全备份指将根目录下的所有文件进行备份。\n\n<strong>增量备份：</strong>指第一次进行完全备份，服务器运行一段时间后，比较当前数据和第一次备份数据之间的差异，只备份有差异的数据，之后的每次备份都只备份与上一次备份有差异的数据。\n\n##### 一般需备份的数据\n+ <strong>/root/</strong>&emsp;管理员账户根目录\n+ <strong>/home/</strong>&emsp;普通用户家目录\n+ <strong>/var/spool/mail</strong>&emsp;邮件\n+ <strong>/etc/</strong>&emsp;重要服务的配置文件\n+ <strong>/var/log</strong>&emsp;常用服务的日志\n+ <strong>数据库数据、账户资料....</strong>\n\n#### dump文件备份系统\n##### 1. 安装dump\n+ <strong>yum -y install dump</strong> (redhalt系列)\n+ <strong>apt-get install dump</strong> (debian系列)\n\n##### 2. dump命令\n<span class=\"strong\">dump [参数] 备份后文件名 原文件或目录</span>\n\n+ -[0-9级别]&emsp;可选0-9备份级别\n+ -f 文件名&emsp;指定备份后的文件名\n+ -u&emsp;备份成功后，把备份时间、备份级别等信息记录在 /etc/dumpdates 文件中\n+ -v&emsp;显示备份过程中更多的输出信息\n+ -j&emsp;调用 bzlib 库压缩备份文件，其实就是把备份文件压缩为 .bz2 格式，默认压缩等级为2\n+ -W&emsp;显示允许被 dump 的分区的备份等级及备份时间\n\n##### 3.备份操作\n对于某个文件或不是分区的目录，dump只能使用 0 级别进行完全备份。而备份分区或整块硬盘时，dump 通过“备份级别”实现增量备份，其中，0 级别是完全备份，1-9为增量备份。\n\n当我们备份数据时，第一次备份应该使用 0 级别，dump会把所有数据完全备份一次；第二次备份就可以使用 1 级别了，它会和 0 级别进行比较，把 0 级别备份之后变化的数据进行备份；第三次备份使用  2 级别，2 级别会和 1 级别进行比较，把 1 级别备份之后变化的数据进行备份，以此类推。\n\n###### 备份目录\n<div class=\"show\"># dump -0uj -f /new/home.bak.bz2 /home/\n完全备份home目录到/new/home.bak.bz2路径下\n</div>\n\n###### 备份分区\n<div class=\"show\">#df -h \n查看分区信息\n# dump -0uj -f /root/boot.bak.bz2 /boot/\n第一次备份进行完全备份，记录备份信息\n# dump -1uj -f /root/boot.bak1.bz2 /boot/\n第二次开始使用增量备份\n# dump -W\n查询分区的备份时间及备份级别(需要备份的时候添加u参数)\n</div>\n\n#### restore还原dump备份的文件\n<span class=\"strong\">restore [模式选项] [-f 文件名]</span>\n\n-f用于指定备份文件文件名，模式选项有四个，只能选一个模式\n\n+ -C&emsp;比较模式，比较备份数据和现有数据的不同并返回(只能检测出数据修改或减少的部分，如果新增了数据不会被检测到)\n+ -i&emsp;交互模式，手动选择需要恢复的文件\n+ -t&emsp;查看模式，用于查看备份文件中拥有哪些文件和目录\n+ -r&emsp;还原模式，用于数据还原(如果是增量备份，则需先还原首次完全备份的数据)\n\n<div class=\"show\"># restore -r -f /root/boot.bak.bz2\n先还原增量备份中首次备份的数据\n# restore -r -f /root/boot.bak.bz2\n再还原第二次开始增量备份的数据\n</div>\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n一般使用<span class=\"tips\">bak</span>作为系统备份文件名后缀</div>","tags":["Linux","command"]},{"title":"Linux用户与权限管理","url":"/blog/2021/12/29/Linux用户与权限管理/","content":"### 用户\nLinux系统是一个多用户多任务的分时操作系统，用户可以属于一个或多个组方便系统管理员控制用户权限，默认有一个root管理员组并且root账户属于该组。可以使用<span class=\"tips\">logout</span>登出当前用户账户。\n#### 查看用户信息\n##### 1. id查看用户信息\n<span class=\"strong\">id [选项] [用户]</span>\n\n+ 默认打印当前用户信息，返回用户号(uid)、组号(gid)、所属组名\n+ 用户可以通过ID或用户名指定，优先会查找用户名，可以使用<span class=\"tips\">+ UID</span>形式让命令直接查找ID\n+ -u 仅打印用户ID\n+ -g 仅打印组ID\n+ -G 打印组ID和附加组ID\n+ -n 在指定了u、g、G选项时，打印对应的用户名或组名，而不是ID号\n+ -r 在指定了u、g、G选项时，打印有效ID号，而不是实际ID\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n\n+ 有效ID：当用户使用su命令切换身份，或使用sudo执行命令时，用户的当前有效ID会修改为对应用户的ID，以便于临时获得其他用户的权限\n+ 实际ID：用户在创建账户时分配的真实ID\n</div>\n\n##### 1. logname查看当前登录用户名\n<span class=\"strong\">logname</span> 查看用户的原始登录用户名，如果用户使用su命令等切换用户身份，也不会修改该命令的输出，该命令的输出值通常来自/var/run/utmp或/etc/utmp文件\n\n##### 2. whoami查看当前有效用户名\n<span class=\"strong\">whoami</span>查看当前的有效用户名，使用su、sudo等命令切换了用户身份时，该命令的输出会随着修改\n\n##### 3. who查看当前已登录用户的具体信息\n主要用来查看哪些用户正在使用系统，以及他们登录时使用的终端设备、IP 地址和登录时间等\n\n<span class=\"strong\">who [选项] [文件名] [am i]</span>\n\n+ 默认打印所有已登录用户的信息，包括登录用户名、登录终端(tty表示本地登录终端，pts一般为远程登录)、登陆时间(如果是远程登录显示IP地址，如果是本地登录显示为(:0))\n+ 如果添加了<span class=\"tips\">am i</span>参数，则只打印当前会话的用户信息\n+ 该命令的输出值默认来自/var/run/utmp或/etc/utmp文件，用户可以手动指定其他文件，如 /var/log/wtmp\n+ -a 显示所有信息，包括包括运行级别、系统启动时间等\n+ -b 显示上次系统启动(引导)的日期和时间\n+ -d 显示已终止的记录(登录结束的会话)，即状态为 DEAD_PROCESS 的记录\n+ -H 显示输出结果时，首行添加该列的标题，解释该列是什么信息\n+ -l 只显示等待登录的进程记录，即 LOGIN_PROCESS 类型的记录\n+ -m 只打印当前会话的用户信息，等价于who am i\n+ -q 只显示已登录的用户名和总用户数，不显示其他详细信息\n+ -r 显示当前系统的运行级别（runlevel）\n+ -s 简单模式，只显示用户名、终端和登录时间(默认)\n+ -T 显示每个用户终端是否允许接收消息的状态（+表示允许接收消息，-表示不允许接收消息，?表示未知）\n+ -t 显示最后一次系统时间变化(通常是更改系统时间或重新启动时)\n+ -u 显示已登录用户的详细信息，包括空闲时间、登录进程 ID 以及会话进程的启动时间，<span class=\"tips\">.</span>表示用户在最后一分钟处于活动状态，<span class=\"tips\">old</span>表示用户已空闲超过 24 小时\n+ -&zwnj;-lookup 显示远程登录用户的IP地址\n\n<div class=\"shell\"># 默认情况下，who命令的输出如下\nroot     pts/0        2022-10-08 16:54 (192.168.1.10)\n</div>\n\n##### 4. w查看用户详细登录信息\n该命令来源于<span class=\"tips\">procps-ng</span>包，它会返回更详细的登录信息，包括当前系统上所有用户及其活动的进程\n\n <span class=\"strong\">w</span>\n\n<div class=\"show\">w命令返回值解析：\n15:20:10 up 25 days, 15:25,  1 user,  load average: 0.00, 0.00, 0.00\nUSER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT\nroot     pts/0    180.129.129.129  10:09    0.00s  0.04s  0.04s -bash\n第一行为登录时间，up后为linux运行时间，用户数量，服务器负载情况\n第二行IDLE为用户已经空闲时间，JCPU为用户累计CPU占用时间，PCPU为用户当前命令操作占用CPU时间，WHAT为用户操作\n</div>\n\n##### 5. users查看当前已登录的所有用户\n<span class=\"strong\">users [文件名]</span>\n\n+ 命令会列出当前登录了系统的所有用户的用户名\n+ 该命令的输出值通常来自/var/run/utmp或/etc/utmp文件，用户可以手动指定其他文件，如 /var/log/wtmp\n\n##### 6. pinky打印有关用户的信息\n该命令的输出信息比上述命令详细，输出包括主目录、默认shell、\n\n<span class=\"strong\">pinky [选项] [用户名]</span>\n\n+ -s 以短格式输出信息，显示用户名、终端、登录时间和远程主机名(默认)\n>>+ -w 以短格式打印时省略用户的真实姓名\n>>+ -i 以短格式打印时，不显示用户真实姓名和远程主机\n>>+ -q 以短格式打印时，省略用户的全名、远程主机和空闲时间\n>>+ -f 以短格式打印时，不显示首行的标题\n+ -l 生成长格式信息，必须指定至少一个用户名，输出信息包括用户名、用户真实姓名、用户主目录、shell，如果用户指定了，通常还可能包含远程主机、登录时间、空闲时间、邮件状态和计划\n>>+ -b 以长格式输出信息时，省略用户主目录和shell\n>>+ -h 以长格式打印时省略用户的工程文件\n>>+ -p 以长格式打印时省略用户的计划文件\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\npinky输出的用户真实姓名来自<span class=\"tips\">/etc/passwd</span>文件中的用户说明字段，某些用户可能会以<span class=\"tips\">用户姓名,办公室地址,办公室号码,个人号码</span>形式在用户说明中标注个人信息，pinky命令会获取这些信息并输出\n</div>\n\n#### 用户管理\n##### 1. useradd添加用户\n<span class=\"strong\">useradd [选项] 用户名</span> \n\n会在/home 目录下默认生成一个以用户名命名的文件夹作为用户的主文件夹，并且会生成一个与用户名同名的用户组\n\n+ -c 注释 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;为用户添加一段注释性描述\n+ -d /路径/目录名&emsp;&emsp;&emsp;自定义用户的主目录，即不使用与用户名同名的默认目录,如果该目录不存在，则可以同时使用-m参数来新建文件夹指定为主目录\n+ -g 用户组 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户所属的初始用户组\n+ -G 用户组，用户组 &emsp;指定用户所属的附加用户组\n+ -s Shell文件 &emsp;&emsp;&emsp;&emsp;指定用户的登录Shell\n+ -u 用户号 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户的用户号，可以添加-o选项来重复使用与其他用户相同的标识号\n+ -D 查看添加用户时的默认设置值(如默认shell，用户密码过期是否禁用账户等)\n+ -e YYYY-MM-DD 指定账户过期日期\n+ -f 值 指定该账户密码过期多少天后禁用账户，0表示一过期就禁用，1表示禁用该功能\n<div class=\"show\">示例：\n# useradd yg\n新增用户yg，同时会新建一个组yg\n# useradd -g gumu lmc\n新增用户lmc，并且将lmc添加到gumu组\n# useradd -d /somedir/user2dir -m user2\n新建用户user2，在 /somedir 文件夹下新建user2dir并将其主目录指定为user2dir (somedir文件夹必须存在，无法用上述命令直接新建)\n</div>\n\n##### 2. userdel删除用户\n只能在root账户下删除用户\n+ <span class=\"strong\">userdel 用户名</span>&emsp;删除用户但保留用户的主目录(避免用户主目录有其他程序调用的重要数据)\n+  <span class=\"strong\">userdel -r 用户名</span>&emsp;删除用户且不保留用户主目录\n\n##### 3.usermod修改用户信息\n<span class=\"strong\">usermod [选项] 用户名</span>\n\n+ -l&emsp;修改用户登录名\n+ -u UID &emsp;修改用户UID\n+ -c 用户说明 &emsp;修改用户说明信息\n+ -G 组名 &emsp; 修改用户附加组\n+ -L &emsp;&emsp;临时锁定用户\n+ -U &emsp;&emsp;解锁用户\n\n#### 用户密码管理\n##### 1.passwd添加/修改密码\n<span class=\"strong\">passwd [选项] [用户名]</span>\n不写用户名则会修改当前账户密码，输入密码时不会显示在终端上,选项：\n\n+ -l &emsp;锁定口令，禁止用户自行修改(参数为小写L)\n+ -u &emsp;解锁口令，允许用户自行修改\n+ -S &emsp;显示密码信息\n+ -d &emsp;删除账户口令\n+ -f &emsp;强迫用户下次登录时必须修改口令\n+ -x &emsp;指定口令最长存活期\n+ -k &emsp;\t保留即将过期的用户在期满后能仍能使用\n+ -&zwnj;-stdin &nbsp;允许从管道中输入口令\n\n##### 2.chage修改用户密码状态\n<span class=\"strong\">chage [选项] 用户名</span>\n\n+ -l  &emsp;&emsp;列出用户详细密码状态\n+ -d 日期 &emsp;修改密码最后一次修改日期(修改shadow文件字段3)\n+ -m 天数 &emsp; 两次密码修改间隔(字段4)\n+ -M 天数 &emsp;&emsp;密码有效期(字段5)\n+ -W 天数 &emsp;&emsp;密码过期前警告天数(字段6)\n+ -I 天数 &emsp;&emsp;密码过期后宽限天数(字段7)\n+ -E 日期 &emsp;&emsp;账号失效时间(字段8)\n<div class=\"show\">使用：\n# chage -d 0 user1\n强制用户user1下次登录修改密码\n</div>\n\n#### su切换用户\n\n<span class=\"strong\">su [选项] 用户名</span>\n从权限高的账户切换到权限低的用户不需要输入密码，反之需要。切换完用户后，可通过 <span class=\"tips\">exit</span> 命令返回原来的用户\n\n+ 如果不指定用户，默认切换到root\n+ <span class=\"strong\">-或-l或-&zwnj;-login</span>切换用户时会以该用户登录shell方式启动新shell，这会加载.bash_profile、.bashrc等配置文件，并且加载新用户的环境变量，连带切换用户环境，如:家目录，用户邮箱等\n+ -c 命令：仅使用指定用户身份执行一次-c后的命令，执行完毕后切换回原用户身份\n+ -s shell路径：切换用户后使用指定的shell，而不使用passwd文件指定的用户默认shell\n+ -m或-p： 保留当前用户的环境变量，而不是使用目标用户的环境变量\n+ -w 变量1 变量2...：切换用户时，保留这些变量\n+ -g 用户组ID：切换用户并加入到指定的用户组\n+ -G 用户组ID1,用户组ID2...：切换用户并加入到多个指定的用户组\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nsu命令由util-linux 软件包提供，使用时仅执行<span class=\"text-green\">su 用户名</span> 不会切换用户环境，在很多使用场景中会报错，推荐使用<span class=\"text-blue\">su - 用户名</span>命令</div>\n\n\n#### 用户的相关文件\n##### 1. 用户的信息文件\n文件位于<span class=\"tips\">/etc/passwd</span>，每一行代表一个用户，并且以\n<div class=\"show\"><span class=\"tips\">用户名:密码标识:用户UID:用户初始组GID:用户说明:用户HOME目录:登录默认Shell</span></div>\n格式书写用户信息\n\n+ 密码标识中，有 X 表示用户有密码，用户登录时linux会前往/etc/shadow查找密码\n+ 用户UID：0 为超级管理员用户，1-999为系统用户，系统用户为ftp等由linux调用的用户，无法登录，修改可能会导致系统无法启动，1000及1000以上为普通用户(旧版本的linux可能1-500为系统用户)\n+ 用户说明可以为空\n+ 用户登录shell一般默认为/bin/bash，系统用户为/sbin/nologin,可以将普通用户的shell更改为/sbin/nologin来禁止用户登录\n\n##### 2. 用户的密码文件\n文件位于<span class=\"tips\">/etc/shadow</span>，保存了加密后的用户密码等信息，每一行代表一个用户，如：\n<div class=\"show\">swv:$6$hPQczrTV$urGtx/wXaOtfIKdyuD/aUO.tHogxBM7uie4ioSbyVgcpNS3Po.:19032:0:99999:7:::</div>\n\n+ 字段一：用户名\n+ 字段二：加密后的密码，如果为\"!!\"或\"*\"表示没有密码，无法登录\n+ 字段三：密码最后一次修改日期，以1970年1月1日作为标准时间，每天+1\n+ 字段四：允许的两次密码修改间隔，如：10为只允许每10天修改一次密码\n+ 字段五：密码有效期，多少天后必须修改密码\n+ 字段六：密码到期提前警告时间\n+ 字段七：密码到期后仍然可使用时间，如：3为还可以使用3天，其中0代表到期立马失效，禁用账户，-1代表到期后仍然能永久使用\n+ 字段八：账号失效时间，使用时间戳(到期时间与1970-1-1的间隔天数)表示\n+ 字段九：保留字段(未使用)\n\n##### 3. 用户的邮箱文件\n文件位于<span class=\"tips\">/var/spool/mail/用户名/</span>，Linux用户可以相互发送内部邮件\n\n##### 4. 用户模板目录\n文件位于<span class=\"tips\">/etc/skel/</span>，用于制作一个模板文件，在新注册用户时会在用户家目录下自动生成该文件。如：给每个账户生成一个用户操作手册。\n\n### 用户组\n#### 用户组管理\n用户组方便系统对同一类型的用户进行管理，对用户组的修改实际上就是对/etc/group文件的更新。\n##### 1. 增加组\n<span class=\"strong\">groupadd [选项] 组名</span>\n选项：\n+ -g GID &emsp;指定新用户组的组标识号（GID）\n+ -o &emsp;&emsp;&emsp;一般与-g参数同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n##### 2.修改用户组\n<span class=\"strong\">groupmod [选项] 组名</sapn>\n\n+ -g GID &emsp;修改组ID\n+ -n 新组名&emsp;修改组名\n\n##### 3. 删除用户组\n<span class=\"strong\">groupdel 组名</span>\n如果组中有初始用户，该组无法删除(以避免用户不属于任何一个组，想删除该组可以先删除该初始用户的账户)，若组中都为附加用户则可以删除。\n\n##### 4. 把用户添加入组或从组中删除\n<span class=\"strong\">gpasswd 必选参数 组名</sapn>\n\n+ -a 用户名&emsp;把用户加入组中\n+ -d 用户名&emsp;把用户从组中删除\n\n##### 5.查看指定用户所在组\n<span class=\"strong\">groups [用户名]</span>\n\n+ 默认查看当前用户，等价于id -Gn命令\n\n#### 用户组的配置文件\n##### 1. 用户组的信息文件\n组信息文件位于<span class=\"tips\">/etc/group</span>，信息格式为：\n<div class=\"show\"><span class=\"tips\">组名:组密码标识:组GID:组中的附加用户</span></div>\n字段说明同用户配置文件类似\n\n##### 2. 组密码文件\n文件位于<span class=\"tips\">/etc/gshadow</span>，密码文件书写格式为：\n<div class=\"show\"><span class=\"tips\">组名:组密码:组管理员用户名:组中的附加用户</span></div>\n配置如上,该文件不常用\n\n### 文件与目录权限管理\n以下命令在指定用户、用户组时，可以使用用户名(组名)，也可以使用用户ID(组GID)\n#### 权限管理中的参数\n<div class=\"table\">\n\n符号|含义|对文件|对目录\n----|----|----|------\nr   |读权限|可以查看文件内容|可以列出目录中的文件，查看目录中文件的详细信息\nw   |写权限|可以修改文件内容|可以在目录中创建、删除、重命名文件\nx   |执行权限|可以执行文件|可以进入目录(包括使用cd命令进入目录，或通过路径/path/dir1/file造访目录)，允许通过路径操作目录中的文件\n\\-   |无权限|无权限|无权限\n</div>\n\n+ <span class=\"tips\">删除某个文件需要对包含该文件的父目录拥有w权限，对文件拥有w权限只能修改文件内容而不能进行删除</span>\n+ <span class=\"tips\">许多命令需要通过路径来操作目录中的文件，因此往往需要同时拥有对目录的w和x权限才能完成操作</span>\n\n#### 递归选项-R与参数\n以下命令都可以添加-R选项进行递归操作，该选项会对目录下的所有文件都进行递归处理，如果递归时遇到了软链接，而该软链接又指向了另外一个目录，是否对软链接指向的目录也进行遍历取决于以下选项：\n+ -p 不遍历任何软链接指向的目录(默认)\n+ -H 只遍历在命令行中显式指定的链接文件所指向的目录\n+ -L 遍历所有链接文件指向的目录，无论是否在命令行中指定\n\n<div class=\"show\">e.g.以chown命令为例\n目录dir1下有软链接link1和link2，它们都指向不同目录\ndir1/\n  ├── link1 -> /path/to/dirA/\n  ├── link2 -> /path/to/dirB/\n  └── file\n默认情况下，-R选项不会前往软链接所指向的源目录进行递归操作，以下命令只会修改dir1目录中文件的所有者\nchown -R user1 dir1\n如果要遍历link1指向的dirA目录，并修改该目录中的文件属性，需要添加-H选项，并将link1显式指定在命令行中\nchown -R -H user1 dir1/link1 dir1\n该命令将遍历link1所指向的目录，并修改dirA目录下所有文件的所有者\n</div>\n\n#### chown更改文件所有者(change file ownership)\n<span class=\"strong\">chown[选项] [用户] 文件或目录1 文件或目录2...</span>\n\n+ 用户值可以写为<span class=\"tips\">用户:组</span>形式，其中用户、冒号、组都可以只指定其中某一部分：\n>>+ 如果只指定了用户(如user1)，则将修改这些文件的所有者为指定用户\n>>+ 如果同时指定了用户与组(如user1:group1)，则将同时修改文件的所有者和所属组\n>>+ 如果指定了用户并添加了冒号(如user1:)，则文件所有者修改为该用户，所属组修改为该用户的默认登录组\n>>+ 如果指定了组并且有冒号(如:group1)，则只修改文件所属组，功能和chgrp命令相同\n>>+ 如果只指定了冒号(:)，则不进行任何修改\n+ -R 以递归方式修改目录和目录下所有文件的所有者\n+ -c 仅打印修改的部分，在指定了多个文件时，部分文件修改前后所有者一样，则不会打印这部分消息\n+ -f 静默模式，通常用于指定多个文件时，不打印某个文件无法修改所有权时的错误信息\n+ -v 详细输出每个信息\n+ -&zwnj;-dereference 如果文件为软链接文件，则修改其指向的源文件或目录的所有者，而不是软链接文件本身(默认)\n+ -h 如果文件为软链接文件，则修改软链接文件本身的所有者，而不是链接指向的源文件或目录\n+ -&zwnj;-reference=文件名R：将文件的所有者和组修改为与文件R相同的用户和组，如果文件R是软链接，则引用其源文件的用户和组，而不是链接文件本身\n+ -&zwnj;-from=owner1：如果文件当前属于owner1，执行修改操作，如果文件当前属于其他用户，则不修改\n+ -H、-L、-p选项参考通用选项\n\n<p><span class=\"tips\">只有文件所有者用户和root用户才能更改文件的所有者属性</span></p>\n\n#### chgrp更改文件所属组(change file group ownership)\n默认情况下，文件的所属组是文件所在目录，该目录的所属组，文件创建时，所属组将设置为和父目录相同的组\n\n<span class=\"strong\">chgrp [选项] [用户组] 文件或目录1 文件或目录2...</span>\n\n+ -R 以递归方式修改目录和目录下所有文件的所属组\n+ -c 仅打印修改的部分，在指定了多个文件时，部分文件修改前后所属组一样，则不会打印这部分消息\n+ -f 静默模式，通常用于指定多个文件时，不打印某个文件无法修改所属组时的错误信息\n+ -v 详细输出每个信息\n+ -&zwnj;-dereference 如果文件为软链接文件，则修改其指向的源文件或目录的属性，而不是软链接文件本身(默认)\n+ -h 如果文件为软链接文件，则修改软链接文件本身的所属组，而不是链接指向的源文件或目录\n+ -&zwnj;-from=owner1：如果文件当前属于owner1，执行修改操作，如果文件当前属于其他用户，则不修改\n+ -H、-L、-p选项参考通用选项\n\n<span class=\"tips\">只有文件所有者、root用户以及拥有sudo权限、ACL权限的用户才能更改文件所属组</span>\n\n#### chmod更改权限(change the permissions mode of a file)\n<span class=\"strong\">chmod [选项] <span class=\"text-red\" style=\"margin:0;\">用户</span><span class=\"text-blue\" style=\"margin:0;\">操作</span><span class=\"text-green\" style=\"margin:0;\">权限</span> 文件名或目录名</span>\n\n<span class=\"strong\">chmod [选项] <span class=\"text-red\">权限值</span> 文件名或目录名</span>\n\n+ 只有root用户与文件所有者才能修改文件的权限\n+ -R 递归修改，修改目录及其所有子文件的权限\n+ -c 仅打印修改的部分，在指定了多个文件时，部分文件修改前权限一样，则不会打印这部分消息\n+ -&zwnj;-dereference 如果文件为软链接文件，则修改其指向的源文件或目录的权限，而不是软链接文件本身的权限(默认)\n+ -h 如果文件为软链接文件，则修改软链接文件本身的权限，而不是链接指向的源文件或目录\n+ -f 静默模式，通常用于指定多个文件时，不打印某个文件无法修改其权限时的错误信息\n+ -v 详细输出每个信息\n+ -&zwnj;-reference=文件名R：将文件权限修改为与文件R相同，如果文件R是软链接，则引用其源文件的权限，而不是链接文件本身\n+ -H、-L、-p选项参考通用选项\n\n##### 以符号方式指定权限与用户\nchmod命令接受通过符号来指定用户和权限，该符号参数的组成为：<span class=\"text-red\" style=\"margin:0;\">用户</span><span class=\"text-blue\" style=\"margin:0;\">操作</span><span class=\"text-green\" style=\"margin:0;\">权限</span>\n\n+ <span class=\"text-red\">u</span>为文件所有者，<span class=\"text-red\">g</span>为文件所属组，<span class=\"text-red\">o</span>为其他用户，<span class=\"text-red\">a</span>为所有用户(等价于ugo组合)\n+ <span class=\"text-blue\">+</span>为添加权限，<span class=\"text-blue\">-</span>为取消权限，<span class=\"text-blue\">=</span>为修改权限为等号所指(如果等号右边为空则表示删除其所有rwx权限，如：og=等价于og-rwx)\n+ <span class=\"text-green\">r</span>为读权限，<span class=\"text-green\">w</span>为写权限，<span class=\"text-green\">x</span>为执行权限，<span class=\"text-green\">s</span>为SetUID或setGID权限(为u用户添加s权限即添加SetUID权限，为g用户组添加s权限即添加SetGID权限)，<span class=\"text-green\">t</span>为粘着位(Sticky BIT)权限\n+ <span class=\"text-green\">X</span>为条件性执行权限，X权限符只会为目录或已有执行权限的文件设置执行权限。该符号用于在批量或递归赋予x权限时，如果为所有文件都添加x权限会导致系统会将这些文件都视为可执行文件，即便他们无法执行，这些文件后续也可能会被恶意或误改为实际可执行文件(比如注入恶意代码)，从而带来安全风险。X权限符只会为目录或原本就拥有x权限的文件添加可执行权限，对于原本就拥有x权限的文件而言，使用X再次添加可执行权限无任何意义，只是用来避免为普通文件也添加可执行权限，对于目录，该权限符可以用来批量为目录添加x权限，方便用户获得进入目录以及使用路径的权限。\n+ 同时修改ugoa中的多个可以使用<span class=\"tips\">,</span>号分隔\n\n<div class=\"show\">e.g.1.添加文件所属组写权限，取消文件其他用户的读权限\nchmod g+w,o-r file\n2.将所有人权限都修改为 rwx\nchmod a=rwx file\n</div>\n\n##### 以权限值方式为用户指定权限\nchmod命令也接受权限值作为指定用户权限的参数，权限值通常为3位或4位八进制的权限值：<span class=\"tips\">[特殊权限][所有者权限][所属组权限][其他用户权限]</span>，特殊权限不需要时可以省略，只写3位权限值\n\n文件所有者、所属组、其他用户的权限值组成为：\n+ r 值为4\n+ w 值为2\n+ x 值为1\n+ rwx值为7，rw-值为6(4+2)，r-x值为5(4+1)，依此类推\n\n特殊权限的权限值组成为：\n+ setUID 值为4\n+ setGID 值为2\n+ Sticky Bit值为1\n+ SetUID+SetGID+StickyBit 值为7，SetUID+SetGID值为6，依此类推\n\n<div class=\"show\">e.g.1.修改权限为rw-r-----\nchmod 640 index.html\n2.添加setUID权限，用户拥有读写执行权限，用户组和其他用户只拥有读和执行权限\nchmod 4755 modifyPort.sh\n</div>\n\n#### umask更改新建文件时的默认权限设置(the user file-creation mask)\n+ <span class=\"strong\">umask -S</span>&emsp;显示新建目录时权限的默认设置\n+ <span class=\"strong\">umask</span>&emsp;显示默认权限值\n+ <span class=\"strong\">umask  权限值</span>&emsp;修改默认权限\n\n文件的umask值代表了给与该文件的默认权限，但它只是个掩码，它会屏蔽掉不想授予该安全级别的权限，实际赋给权限时需要进行一定的异或运算(对于值来说可视为减法运算)\n\n<div class=\"show\">root执行umask显示默认权限值一般为0022(普通用户为0002)，第一位0代表特殊权限，022为默认的权限与777权限异或后的权限值\n    777 rwx rwx rwx\n    022 --- -w- -w-\n  ===============\n    755 rwx r-x r-x(默认权限)\n因此需要修改默认权限时，需要先异或操作计算出权限值，如想把默认权限改为rwx --- ---，则先计算权限值\n    777 rwx rwx rwx\n    700 rwx --- ---\n  =================\n    077 --- rwx rwx\n然后执行\numask 077\n即可，同样，如果创建的是一个文件，Linux会在默认权限基础上取消所有用户的x权限\n</div>\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n新建的文件相较于新建的目录所有用户会少一个x权限，这是因为Linux会取消新建文件的可执行权限以防止危害系统的可执行程序运行</div>\n\n### 特殊权限\n这里的特殊权限指除了读、写、执行外，为了方便文件共享设计的一些额外特殊控制权限，包括三种：<span class=\"tips\">SUID</span>、<span class=\"tips\">SGID</span>、<span class=\"tips\">粘着位</span>权限，与读写执行类似，它们的八进制权限值分别为4、2、1，即1代表仅增加/减少粘着位权限，3代表同时增加/减少粘着位权限和SGID权限，依此类推。\n\n\n#### 1. SetUID权限\nSUID权限只用于可执行的脚本文件、命令文件等，它指定用户在执行该文件时，是以文件所有者的身份执行而非当前用户来执行。这意味着用户可以执行特定程序并且具有该程序所有者的权限，而不是当前用户的权限，程序运行完毕后会收回所有者身份。进程的用户ID也将设置为该文件所有者的ID，而非启动该进程的用户ID。\n\n对于目录，在该目录中创建文件时，文件的所有者将被设置为与目录所有者相同的用户，无论该文件是谁创建的。\n\n该权限通常用于需要以特定用户的权限来执行的程序，例如系统管理工具或安全敏感的程序，如：普通用户对 /etc/shadow 文件的权限为 0 ，即无法查看无法修改，但通过执行passwd命令，普通用户会获得临时的所有者即root权限，可以修改密码。\n\n+ <span class=\"tips\">只有可执行的二进制程序才能设置SUID权限</span>\n+ <span class=\"tips\">要求命令执行者要对该程序拥有x(执行)权限</span>\n+ 命令执行者在运行该程序时会临时获得文件所有者身份\n+ SUID权限只在该程序执行时有效，程序执行完毕权限失效\n\n##### 设置SUID权限\n4代表SUID\n\n+ <span class=\"strong\">chmod 4755 文件名</span>&emsp;755为权限值可任意，但要保证用户有x权限\n+ <span class=\"strong\">chmod u+s 文件名</span>\n\n##### 取消SUID权限\n<span class=\"strong\">chmod 755 文件名</span>\n\n<span class=\"strong\">chmod u-s 文件名</span>\n\n<div class=\"show\">说明：\n当设置SUID权限后，该文件权限标识中所有者的可执行权限x会被修改为s\n-rwsr--r--  1 root root 174 Jan 23 18:56 file\n如果该标识为大写S，则说明文件设置了SUID权限，但用户没有x权限，SUID权限无法生效，权限报错\n</div>\n\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nSUID权限可能会导致安全风险，容易造成权限滥用，Linux中默认只有/usr/bin/passwd 等少数文件有SUID权限，禁止为 vi 等命令设置该权限，否则所有用户在使用 vi 命令时都将获得 root 权限。应定时检查系统中是否有除默认以外的文件设置了SUID权限</div>\n\n#### 2. SetGID权限\nSGID权限常用于目录，一般用于在大范围环境中与人共享文档。当一个目录被设置了SGID权限后，该目录内所有新建的文件和子目录将继承该目录的所属组，而不再是创建者的所属组。因此SGID权限通常用于需要多个用户共享访问的目录，以确保目录内的文件和子目录都属于同一个特定组，让所有用户共享相同的所属组，确保文件和目录的一致性和权限的控制\n\n对文件\n+ 只有可执行的二进制程序才能设置SGID权限\n+ 要求命令执行者要对该程序拥有x(执行)权限\n+ 命令执行者在运行该程序时，组身份会临时升为文件所属组身份\n+ 进程的组ID将设置为文件所属组的组ID，而不是启动该进程用户的组ID\n+ SGID权限只在该程序执行时有效，程序执行完毕权限失效\n\n<div class=\"show\">说明：\n当设置SGID权限后，该文件权限标识中所属组的可执行权限x会被修改为s，如 locate 命令的权限为\n-rwx--s--x  1 root root 174 Jan 23 18:56 usr/bin/locate\n</div>\n\n对目录\n\n+ 要求用户必须拥有此目录的 r 和 x 权限\n+ 普通用户进入该目录时，用户的组会升为此目录的所属组\n+ 如果用户对目录有w权限，新建文件的默认组 将变为目录的所属组，而非创建者的所属组\n\n##### 设置SGID权限\n2代表SGID\n\n+ <span class=\"strong\">chmod 2755 文件名</span>&emsp;755为权限值可任意，若为文件要保证拥有x权限，为目录则拥有r和x权限\n+ <span class=\"strong\">chmod g+s 文件名</span>\n\n##### 取消SGID权限\n<span class=\"strong\">chmod 755 文件名</span>\n\n<span class=\"strong\">chmod g-s 文件名</span>\n\n#### 3. Sticky BIT(粘着位权限)\n\n+ 只对目录有效\n+ <span class=\"tips\">要求用户对目录拥有w和x权限</span>\n+ 没有设置粘着位权限时，用户拥有w权限后可以删除目录下的所有文件，包括其他用户创建的文件。设置粘着位后，用户只能删除自己创建的文件，root用户不受此规则影响\n\n<div class=\"show\">说明：\n当设置SBIT权限后，文件权限标识中其他用户的可执行权限x会被修改为t，如\ndrwxrwxrwt  1 root root 174 Jan 23 18:56 /dir/\n</div>\n\n##### 设置SBIT权限\n1代表SBID\n\n+ <span class=\"strong\">chmod 1755 目录名</span>&emsp;755为权限值可任意，要保证用户拥有w和x权限\n+ <span class=\"strong\">chmod o+t 目录名</span>\n\n##### 取消SBIT权限\n<span class=\"strong\">chmod 755 目录名</span>\n\n<span class=\"strong\">chmod o-t 目录名</span>\n\n### ACL权限\nACL权限用于给文件所有者(u)、所属组(g)、其他用户(o)以外的用户提供权限\n\n#### 查看ACL权限\n<span class=\"strong\">getfacl 文件名</span>\n<div class=\"show\">设置了ACL权限的文件，使用 ls -l 命令查看文件时权限标识后带有+号，如：\n-rw-r-xr--+ 1 root root  174 Jan 23 18:55 index.html\n使用 getfacl 命令查看具体ACL权限，会多一组拥有ACL权限的 user或group 并标明用户名或组名，如：\n# file: index.html\n# owner: root\n# group: root\nuser::rw-\nuser:sw:r-x     //sw用户拥有ACL权限r-x\ngroup::r--\nmask::r-x\nother::r--\n</div>\n\n#### 设置mask权限\nmask权限用于指定最大的权限，防止给与用户ACL权限时权限过大。用户最终得到的权限是ACL权限于mask权限相与以后得到的权限。\n<span class=\"strong\">setfacl -m m:组名:权限 文件名</span>\n\n#### 设置ACL权限\n<span class=\"strong\">setfacl 参数 文件名</span>\n\n+ -m &emsp;设定ACL权限\n+ -x &emsp;删除指定ACL权限\n+ -b &emsp;删除文件所有ACL权限\n+ -d &emsp;设定默认ACL权限\n+ -k &emsp;删除默认ACL权限\n+ -R &emsp;递归设置ACL权限\n\n##### 1. 设置ACL权限\n+ <span class=\"strong\">setfacl -m u:用户名:权限 文件名</span>给用户设置ACL权限\n+ <span class=\"strong\">setfacl -m u:用户名:权限 -R 文件名</span>递归设置，给用户设置目录下所有子文件的ACL权限\n+ <span class=\"strong\">setfacl -m g:组名:权限 文件名</span>给组设置ACL权限\n+ <span class=\"strong\">setfacl -m g:组名:权限 -R 文件名</span>递归设置，给组设置目录下所有子文件的ACL权限\n<div class=\"show\">示例：\nsetfacl -m u:lm:r-x index.html\n给与用户lm对index.html的读和执行权限\n</div>\n\n##### 2. 删除ACL权限\n<span class=\"strong\">setfacl -x [u或g]:[用户名或组名] 文件名</span>\n\n删除对应用户或组的ACL权限\n\n<span class=\"strong\">setfacl -b 文件名</span>\n\n删除对应文件所有ACL权限\n\n##### 3. 设置默认ACL权限\n设置默认ACL权限的作用是给父目录设置ACL权限后，父目录中创建的所有子文件都会继承父目录的ACL权限，但执行命令前的文件不会拥有权限。与递归设置的区别是，递归设置的ACL权限只会给当前已经存在的子目录给与ACL权限，新建的后来文件不会拥有权限。\n+ <span class=\"strong\">setfacl -m d:u:用户名:权限 文件名</span>设置默认ACL权限\n+ <span class=\"strong\">setfacl -m k:u:用户名:权限 文件名</span> 删除默认ACL权限设置\n\n\n可以添加-R参数递归给子目录的子文件也设置默认ACL权限，但执行命令前创建的文件依旧不会有ACL权限。\n\n<span class=\"strong\">setfacl -m d:u:用户名:权限 -R 文件名</span>\n\n\n\n### 文件系统属性权限chattr权限\n\n<span class=\"strong\">chattr&emsp;[+-=][i或a]&emsp;文件或目录名</span>\n\n+ +为增加权限，-为删除权限，=为设置为指定权限\n+ i &emsp;对文件：不允许删除、改名、添加内容或修改文件内容操作\n&emsp;对目录：只能修改目录下文件的内容，不允许新建和删除文件\n<span class=\"tips\">对root用户生效！</span>\n\n+ a &emsp;对文件：只能添加新内容，不能删除、修改已有内容(并且只允许使用echo添加，不能使用vi等编辑器添加)\n&emsp;对目录：只能新建和修改文件，不能删除文件\n<span class=\"tips\">对root用户生效！</span>\n\n<div class=\"show\">示例：\nchattr +i test\n给文件test添加i属性，锁定文件，防止误操作</div>\n\n##### 查看chattr权限方法\n该权限无法使用 ls 命令查看，而需要使用：\n\n<span class=\"strong\">lsattr [参数] 文件名</span>\n\n+ -a 显示所有文件和目录\n+ -d 若为目录，则显示目录属性，而非子文件属性\n\n### sudo\nsudo命令允许系统管理员root临时提高普通用户的权限，让用户可以以其他身份(包括root)执行某些命令，最常见的用法是授权普通用户使用原本只有root用户才能使用的系统命令。sudo 是通过软件包提供支持的，因此它并非在所有的 Linux 发行版中默认安装(如：Arch Linux默认不安装)，但在大多数现代的 Linux 发行版中，特别是面向桌面和服务器用途的发行版，sudo 通常会默认安装并配置好\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nsudo官方说明文档：<a href=\"https://www.sudo.ws/docs/man/sudo.man\">https://www.sudo.ws/docs/man/sudo.man</a></div>\n\n#### sudo命令\n<span class=\"strong\">sudo [选项] [命令]</span>\n\n+ 默认情况下，sudo命令会以root用户身份执行命令，且默认会在当前环境下执行命令，不会加载新的环境\n+ <span class=\"strong\">-u 用户名</span> 指定以哪个用户的身份执行命令，如果不指定，默认以root用户执行，也可以使用<span class=\"strong\">-u #用户ID</span>来指定用户，在某些Linux发行版中#号需要使用\\\\#转义\n+ -s 以指定用户的交互式非登录shell身份执行命令，载入shell环境(如：shell中定义的变量、环境变量)但不加载登录shell配置文件\n+ -i 以指定用户的交互式登录shell身份执行命令，这会加载新的shell环境以及登录shell需要加载的.profile、.bash_profile等配置文件\n+ 默认情况下，首次执行sudo命令需要输入当前用户密码(不是-u选项指定用户的密码)，该密码认证有效期默认为5分钟，5分钟后需要重新认证，如果是高权限用户身份(如root)向低权限用户身份切换，则不要输入密码\n+ -v 延长5分钟(默认)密码认证的有效时间\n+ -k 重置sudo的授权时间戳，强制下次执行sudo时必须重新输入当前账户密码\n+ -l 列出(list)当前用户可以使用sudo权限执行的命令，执行命令后Linux系统会要求输入当前账户密码\n+ -b 在后台执行命令，用户可以继续使用终端\n+ -e 文件：以指定身份使用默认编辑器编辑文件\n+ -D 目录：前往指定目录下运行命令但不切换当前工作目录，如果用户没有该目录的权限，则返回错误(仅高版本sudo支持)\n+ -R 目录：切换当前工作目录到指定目录，再执行命令，如果用户没有该目录权限则返回错误(仅高版本sudo支持)\n+ -H 将HOME环境变量设置为指定用户的主目录\n+ -E 保留当前环境变量，避免被清除\n\n<div class=\"show\">1. 以root身份安装nginx\nsudo apt install nginx\n2. 以user1身份编辑该用户home目录下的index.html文件\nsudo -u user1 vim /home/user1/index.html\n3. 以user1登录shell方式执行命令ls，由于直接指定了一个命令，ls命令执行完毕后sudo会自动退出，并返回到原始的用户会话中\nsudo -u user1 -i ls\n如果不指定命令，sudo会启动一个新的shell会话后等待用户输入，后续终端所有输入的命令都将以user1的身份执行，直到通过exit命令退出该shell，相当于创建了一个user1的登录shell\nsudo -u user1 -i\n4. 列出当前用户可以用sudo执行的命令\nsudo -l\n5. 延长当前授权的有效期\nsudo -v\n6. 重置sudo的授权时间戳，下次执行sudo时需要重新输入密码\nsudo -k\n</div>\n\n\n#### visudo命令与sudoers文件\n<span class=\"strong\">visudo</span>命令用来指定用户可以使用sudo提权执行哪些命令，visudo命令会打开<span class=\"tips\"> /etc/sudoers </span>文件让管理员进行编辑，文件配置格式为：\n\n<span class=\"tips\">用户名  主机地址=(赋予的身份) 授权命令1的绝对路径, 命令2的绝对路径.....</span> \n\n给组添加相关权限格式类似，组名前加上%号即可。通过vi /etc/sudoers命令虽然也可以编辑该文件，但通过该修改方法容易出现语法错误从而导致配置出错，使用visudo命令虽然也会打开编辑软件，但该命令会阻止多个用户并发编辑等操作，可以在安全环境下编辑文件，并且该命令在退出时会对文件进行语法检查，避免配置出错\n\n<div class=\"show\">e.g.文件自带了root用户的配置，即root用户在所有主机上，允许执行所有命令。类似地，wheel组也可以在所有主机上执行所有命令\nroot    ALL=(ALL)       ALL  \n%wheel  ALL=(ALL)       ALL \n添加允许user1用户使用sudo进行关机操作的配置项\nuser1      ALL=/sbin/shutdown -r now\n</div>\n\n<div class=\"show\">sudoers文件的常用配置语法：\n1. sudoers提供了4种类型的别名\n+ User_Alias用来创建用户别名\n+ Host_Alias用来创建主机别名\n+ Cmnd_Alias用来创建命令别名\n+ Runas_Alias用来创建身份别名\n用上述类型可以分别创建用户、主机、命令、运行环境的别名，方便批量管理，这些别名相当于一个变量名，别名由大写字母、数字和下划线字符组成，必须以大写字母开头，如：\nUser_Alias     ADMINS = alice, bob, carol\nHost_Alias     FILE_SERVERS = fs1, fs2, fs3\nCmnd_Alias     REBOOT_CMDS = /sbin/reboot, /sbin/shutdown\nRunas_Alias    OP = root, admin\n如果添加\nADMINS ALL=(root) REBOOT_CMDS\n表示alice, bob, carol用户可以以root身份执行/sbin/reboot和/sbin/shutdown命令\n2. NOPASSWD 选项可以让用户运行特定命令时不需要输入密码\nuser1     ALL = (root) NOPASSWD: /bin/kill, /usr/bin/killall\n表示用户user1可以以root身份执行/bin/kill和/usr/bin/killall命令，且不需要输入密码\n3. 可以使用!来禁止特定的命令\nuser1 ALL=(ALL) ALL, !/usr/bin/passwd\n允许用户user1执行所有命令，除了/usr/bin/passwd命令\n</div>\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n授予命令越简单，权限越大，因此命令应该尽量详细</div>\n\n### 给用户发送消息\n##### 1. write 给某个在线用户发送信息\n<span class=\"strong\">write 用户名 信息</span>\n<p>给已经登录Linux的用户发送消息，<span class=\"tips\">Ctrl+D</span>结束输入并发送，需要用户在线，可以使用<span class=\"tips\">w</span>查询在线的账户。\n</p>\n\n##### 2. wall 给所有在线用户发送信息(write all)\n<p><span class=\"strong\">wall 信息</span></p>\n给所有在线用户发送广播信息\n\n\n#### mail 发送邮件\n<span class=\"strong\">mail 用户名</span>\n<p>当用户未登录无法使用上述命令发送消息时，可以发送邮件给Linux用户。</p>\n<div class=\"show\">邮件发送:\n# mail 用户名 \nSubject : 邮件标题  //输入邮件\n邮件内容           //输入邮件内容，输入完毕<span class=\"tips\">Ctrl+D</span>发送\n\n邮件接收：\n~ mail          //查看邮件箱\n收到的邮件将以New标识(是否已读)、序号、发送用户、发送时间、邮件标题的格式列出\n-> N 1 root                  Sun Feb 20 12:38  18/532   \"test\"\n~ 1             //直接输入序号查看对应邮件\n~ h             //列出所有邮件\n~ d1            //d+序号删除对应邮件\n~ q             //退出邮件查看系统</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nLinux会通过mail给root用户发送一些邮件反映服务器错误信息等</div>","tags":["Linux"]},{"title":"Linux文件操作","url":"/blog/2021/12/29/Linux文件操作/","content":"\n### 查看文件与目录信息\n####  ls查看文件与目录信息(list)\n<span class=\"strong\">ls [选项] [文件或目录]</span>\n\n+ 如果不指定文件或目录名，操作对象为当前目录，默认情况下，命令会列出该目录中文件的文件名，且会省略以<span class=\"tips\">.</span>开头的文件，列出的文件默认按文件名a-z排序\n+ -a (all)显示所有文件，包括隐藏文件(以.开头的文件)以及.(表示当前目录)和..(表示上一级目录)\n+ -A (almost-all)显示所有文件，包括以.开头的文件，但忽略.和..\n+ -B (ignore-backups)列出文件信息时，忽略以<span class=\"tips\">~</span>结尾的文件，这类文件通常是备份文件\n+ -l (long)显示详细信息，默认情况下ls命令只显示当前目录包含文件的文件名，该选项会详细显示文件所有信息，但文件大小只以byte形式显示，命令可以直接简写为 ll\n+ -d (directory)查看当前目录信息而非展示目录所含文件\n+ -h (human-readable)常与l参数一起使用，文件大小会被换算为KB、MB等人类方便读的单位，但该选项会将文件大小四舍五入输出，如：2000bytes输出为2k(2048bytes)，1536bytes输出为1.5k，需要准确字节数应当使用-l选项或其他命令(stat、du等)\n+ -H 在查看链接文件时，显示链接的原文件信息而不是链接文件本身的信息\n+ -I 模式：忽略与模式相匹配文件名的信息，这里的模式指shell支持的模式，而非所有正则表达式语法，如：ls -I '.[^.]' 表示忽略所有以.号开头，文件名长度为2个字符的文件\n+ -i (iNode)查看文件i节点，并打印于最左侧\n+ -F (classify)对不同文件进行特殊标识，该标识会添加于文件名后，/表示目录，*表示可执行文件，@表示链接文件，|表示管道文件，=表示套接字文件，普通文件不添加任何标识\n+ -&zwnj;-time-style='+时间格式'：按指定格式输出文件的时间信息，时间格式参考date命令\n+ -R (recursive)递归显示，列出目录下的子目录和子文件，输出较长\n+ -c 显示文件元信息(文件权限、所有者、硬链接等)最后被修改的时间，需要搭配-l使用，默认情况下，ls -l命令显示的时间是文件内容最后被修改的时间，-c选项会将该时间替换为文件元信息最后被修改的时间\n+ -u (use) 需要搭配-l使用，类似于-c，将时间替换为文件最后被访问的时间(但许多文件系统为了优化性能，只会在某些情况下更新文件最后访问时间atime，以减少对磁盘的写入，因此默认情况下文件系统很少记录atime，该选项输出信息可能是错误的)\n+ -&zwnj;-time=birth 打印文件的创建时间，需要搭配-l使用，类似于-u，该时间可能不会被记录\n+ -t (time)按文件最后被修改时间(默认)顺序排序，最新的在前，如果命令有-c、-u、-&zwnj;-time=birth选项，则排序依据修改为对应的记录\n+ -S (size)按文件大小排序，大的排前\n+ -U 不进行任何排序，按文件在目录中的存放顺序列出文件，如果目录中有大量文件，ls默认按文件名排序时可能消耗时间，该选项可以加快命令执行\n+ -&zwnj;-sort=width 按文件名长短排序，短的排前\n+ -X 按文件的扩展名(最后一个.号之后的字符视为扩展名)排序\n+ -r (reverse)反向排序，以上排序相关的输出信息都可以用该选项反序输出\n\n<div class=\"show\">示例：\n1. 列出当前目录所含非隐藏文件或文件夹\n ls\n该命令会返回当前目录下的非隐藏文件和文件夹\nconfig.json  data  modifyPort.sh\n2. 列出当前目录所含非隐藏文件或文件夹详细信息\nll #该命令等价于ls -l\n该命令会输出目录总大小，以及每个目录和文件的详细信息\ntotal 12\n-rw-r--r-- 1 root root   52 Aug 18 14:14 config.json\ndrwxr-xr-x 2 root root 4096 Aug 18 14:15 data\n-rwxr-xr-x 1 root root  869 Aug 18 14:15 modifyPort.sh\n3. 列出当前目录的详细信息，而非当前目录所包含文件的信息\nls -ld\n当前目录以.号表示\ndrwxr-xr-x 3 root root 4096 Aug 18 14:15 .\n4. 列出当前目录的详细信息，包括隐藏文件，文件的大小换算为KB、MB等单位，并标识出可执行文件、目录等\n#ls -alhF\n./表示当前目录，../表示上一级目录，文件名后添加*表示该文件是可执行文件，文件名后添加/表示这是一个目录，且会用不同的颜色高亮显示\ntotal 20K\ndrwxr-xr-x   3 root root 4.0K Aug 18 14:15 ./\ndr-xr-xr-x. 20 root root 4.0K Aug 18 14:13 ../\n-rw-r--r--   1 root root   52 Aug 18 14:14 config.json\ndrwxr-xr-x   2 root root 4.0K Aug 18 14:15 data/\n-rwxr-xr-x   1 root root  869 Aug 18 14:15 modifyPort.sh*\n</div>\n\nls命令还可以搭配一些正则表达式只显示自己想看的文件信息\n<div class=\"show\">1.使用?表示一个字符，*表示零个或多个字符，如输出my_开头的文件信息\n# ls -l my_*\n2. 使用[ ]包裹多个字符，如：查看是否有fall,fbll,fcll,fdll文件\n# ls -l f[a-d]ll\n3. 使用!排除不需要的内容，如不查看fall，但查看其余的文件\n# ls -l f[!a]ll\n</div>\n\n#### ls命令的输出信息\n使用<span class=\"tips\">ls -l</span>等命令列出文件详细信息，文件信息格式类似于\n<div style=\"text-align:center;\"><span class=\"tips\">&emsp;drwxr-xr-x.  &nbsp;6&nbsp; root&nbsp; root&nbsp; 4.0K &nbsp;Feb&nbsp;  9&nbsp; 11:53&nbsp; home&emsp;</span></div>\n\n###### 字段一\n<strong>第1位</strong>\n\n第1位表示文件类型\n+ -为普通文件\n+ b为块设备文件，如：硬盘、光盘等（Block Device）\n+ c为字符设备文件，如：鼠标、键盘设备文件（Character Device）\n+ C为连续存储文件，支持高性能读写\n+ d为目录\n+ D为门文件，一种特殊的进程通信机制，Linux中不常见，常见于Solaris系统\n+ l为链接文件\n+ M为已离线迁移的文件，表示文件已经被迁移到离线存储(如磁盘)，如果需要访问需要恢复到在线存储，该文件类型常见于超级计算机\n+ n为特殊的网络文件\n+ s为套接字文件，一般用于数据连接，常见于 /var/run目录\n+ p为管道文件(FIFO)，用于解决多个程序同时存取一个文件所造成的错误（Named Pipe, FIFO）\n+ s为套接字文件（Socket）\n+ ?其他类型的文件\n\n<strong>第2-10位</strong>\n\n3位为一组，分别为文件所有者、所属组、其他用户的读、写、执行权限\n+ r为可读\n+ w为可写\n+ x为可执行\n+ -为无权限\n\n权限除了可以使用rwx表示，在chmod等命令中还可以用权限值来表示：当用户拥有rwx权限时，表示为二进制的111，换算为十进制，其权值为7，当用户拥有r-x权限时，表示为101，权值为5，以此类推，巧妙使用二进制和十进制的转换来更简洁地表示权限\n\n<strong>第11位 .号</strong> \n\n.号为安装有SElinux的系统特有，这个点表示该文件带有“SELinux的安全上下文\"\n\n###### 其他字段\n之后的字段分别表示\n+ 该文件的硬链接总数\n+ 文件所属用户\n+ 文件所属组\n+ 文件大小\n+ 文件最后一次修改时间，无修改则为创建时间\n+ 文件名\n\n#### stat查看文件与文件系统状态\nstat命令以另外一种方式显示文件的详细信息，输出内容包含大小、权限、时间戳、inode 号等，并且可用自定义这些信息的输出样式，此外，它还可以用来查看文件所属文件系统的状态。\n<span class=\"strong\">stat [选项] 文件名1 文件名2...</span>\n\n+ 默认情况下，命令会输出文件的信息，如果文件是链接文件，默认输出链接文件本身的信息\n+ -f 输出文件所属文件系统的状态，而非文件本身信息\n+ -L 输出链接文件所指向的文件的状态，而不是符号链接文件本身的状态\n+ -t 以简洁形式在一行上打印信息，方便其他程序解析。在不同版本的GNU coreutils包中，该选项的输出可能不同，可能输出<span class=\"tips\">文件名、文件大小(字节)、文件占用块数、文件权限(八进制或十六进制)、设备主编号、设备次编号、十六进制设备号、Inode编号、硬链接数、文件所有者UID、文件所属组GID、最近访问时间戳atime、最近修改时间戳mtime、最近文件属性修改时间戳ctime、文件创建的时间戳btime、IO块大小</span>等\n+ -c \"格式字符串\"：按照指定格式显示信息，末尾会自动添加换行，因此如果指定多个文件，则会输出多行信息\n+ -&zwnj;-printf=\"格式字符串\"：按照指定格式显示信息，且不自动添加换行符\n\n格式字符串支持以下字符：\n<div class=\"table\">\n\n格式字符|说明\n----|-------\n%a  |八进制形式显示的文件权限\n%A  |文本形式显示的文件权限（如 -rw-r--r--）\n%s  |文件大小（以字节为单位）\n%n  |文件名\n%N  |文件名，如果是符号链接，则显示指向的文件\n%F  |文件类型（如 \"regular file\"、\"directory\" 等）\n%u  |文件所有者的用户ID\n%g  |文件所有者的组ID\n%y  |最后修改时间\n%z  |文件状态最后更改时间\n</div>\n\n<div class=\"show\">1. 查看文件详细信息\nstat modifyPort.sh \n该命令的输出值通常包含以下内容：\n  File: ‘modifyPort.sh’\n  Size: 869       \tBlocks: 8          IO Block: 4096   regular file\nDevice: fd01h/64769d\tInode: 1572872     Links: 1\nAccess: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2024-08-18 14:15:45.866848485 +0800\nModify: 2024-08-18 14:15:45.866848485 +0800\nChange: 2024-08-18 14:15:45.866848485 +0800\n Birth: -\n其中：\nfile:文件名\nsize:文件大小\nBlocks:文件占用的数据块数量，文件系统中的数据以块的形式存储，块的大小取决于文件系统\nIO Block：文件系统的I/O块大小，也就是读写文件时的块大小\nDevice：文件所在设备的ID号，分别用十六进制和十进制表示\nInode：文件的inode号\nLinks：链接到该inode的文件名数量，值为1表示这个文件没有其他硬链接\nAccess：文件当前权限\nUid：文件所有者的ID号和用户名\nGid：文件所有者所属组GID号和组名\nAccess：文件最后访问时间\nModify：文件最后修改时间\nChange：文件元数据(如文件权限、所有者)最后一次被更改的时间\nBirth：文件的创建时间。某些文件系统不支持记录文件的创建时间，会显示为 -\n2. 可用手动指定文件信息输出形式\nstat -c \"%n:文件大小%s 文件权限%a 文件类型%F 文件修改时间%y\" modifyPort.sh \n输出值：\nmodifyPort.sh:文件大小869 文件权限755 文件类型regular file 文件修改时间2024-08-11 18:06:36.179331522 +0800\n</div>\n\nLinux系统可能挂载了多个文件系统（例如，根文件系统 /、用户主目录 /home、临时文件系统 /tmp 等），而每个文件系统可能具有不同的属性和状态。stat支持通过-f选项确定文件所属的文件系统，从而提供与该文件系统相关的信息\n<div class=\"show\">查看根目录所属文件系统的状态\nstat -f /\n返回值通常包括以下信息：\n File: \"/\"\n    ID: 518e09c078cb0c63 Namelen: 255     Type: ext2/ext3\nBlock size: 4096       Fundamental block size: 4096\nBlocks: Total: 10288203   Free: 9569130    Available: 9093203\nInodes: Total: 2621440    Free: 2556389\n其中：\nFile:所指定的文件名或路径\nID:文件系统的标识符，这个十六进制 ID 对应于特定的文件系统类型\nNamelen:文件系统允许的最大文件名长度(字符数)\nType:文件系统类型的名称，可能为 ext2/ext3等值\nBlock size:文件系统块的大小（以字节为单位）\nFundamental block size:基础块大小，通常与文件系统块大小相同\nBlocks:Total为文件系统中的总块数，Free为文件系统中未分配的块数，Available为当前用户可用的块数（可能会比 Free 少，因为一些块可能被保留给超级用户）\nInodes:Total为文件系统中的总inod 数，每个inode表示一个文件或目录。Free为未使用的 inode 数，意味着还可以创建的文件或目录数量\n</div>\n\n#### dir与vdir列出目录信息\n这两个命令的功能囊括在了ls命令中，选项和ls命令相似，但ls命令功能更为强大，因此这两个命令极少使用\n\n<span class=\"strong\">dir [选项] [目录名]</span>简要列出目录内容，等价于 ls -C -b\n\n<span class=\"strong\">vdir [选项] [目录名]</span>详细列出目录内容，等价于 ls -l -b\n\n#### dircolors设置ls命令的打印样式\n在使用ls、dir等命令输出文件和目录详细信息时，可以将不同类型的文件用不同的颜色进行标识，这些样式被定义于<span class=\"tips\">LS_COLORS</span>环境变量中，在打印文件类型、权限等属性时，shell会根据此变量中的规则为输出着色。<span class=\"tips\">dircolors</span>命令可以用来读取\nLS_COLORS变量当前的系统默认配置，也可以用来生成修改LS_COLORS环境变量的配置字符串。默认情况下，LS_COLORS的值内置于shell中，部分Linux发行版可能会将配置写于<span class=\"tips\">/etc/DIR_COLORS</span>文件中，用户也可以自定义输出样式，写于<span class=\"tips\">~/.dircolors</span>文件中，然后通过dircolors程序解析该配置文件，dircolors程序会更新LS_COLORS变量的值，用户可以在.bashrc中载入该文件，使其在启动shell时生效\n\n<span class=\"strong\">dircolors [选项] [文件名]</span>\n\n+ -b (默认值)输出Bourne shell格式的代码，代码包括LS_COLORS变量的值和export LS_COLORS语句，用户可以在修改LS_COLORS变量值后将该输出写入.bashrc或.bash_profile文件中\n+ 输出 C shell 格式的代码，用于 .cshrc 中\n+ 如果指定了文件，dircolors命令会读取该文件并将其解析为LS_COLORS变量值\n+ -p 输出当前的样式配置，这些配置会输出为方便阅读和修改的格式，通常需要通过dircolors程序解析为LS_COLORS变量值，才能使用\n+ -&zwnj;-print-ls-colors 将LS_COLORS变量的每个颜色设置都打印在单独的行上，并且该行会输出为对应的颜色，方便即时查看当前的颜色设置\n\n<div class=\"show\">正常情况下，LS_COLORS变量的值很长，直接修改变量值极其不方便，因此通常会通过以下步骤修改ls等命令的输出样式\n1. 如果系统本身提供了 /etc/DIR_COLORS 文件，可以直接修改该文件的内容\n如果系统未提供该文件，用户可以通过以下命令生成\ndircolors -p &gt; ~/.dircolors\n该命令会新建.dircolors文件并将当前的默认配置写入该文件中，该文件通常包括以下三部分内容：\n第一部分为终端定义，用于定义哪些终端类型支持颜色显示，并根据终端类型决定是否启用颜色，通常使用系统默认即可，内容示例：\nCOLORTERM ?*\nTERM Eterm\nTERM ansi\n第二部分用来定义不同文件类型的标识样式，用户可以自定义，如：\nDIR 01;34   #目录的标识样式，01表示加粗高亮，34为蓝色\nLINK 01;36  #链接文件的标识样式，01表示加粗高亮，36为青色\n.....\n第三部分为不同后缀文件的输出样式，用户可以自定义，如：\n.tar 01;31  #后缀为.tar的文件标识样式为高亮(01)红色(31)\n....\n.jpg 01;35  #后缀为.jpg的文件标识样式为高亮(01)品红(35)\n....\n<span class=\"text-red\">颜色代码参考终端样式控制</span>\n2. 编辑完.dircolors文件后，在用户的 ~/.bashrc 或 ~/.profile 文件中，添加以下行以应用颜色设置\neval \"$(dircolors ~/.dircolors)\"\n该命令中：\ndircolors ~/.dircolors(等价于dircolors -b ~/.dircolors)命令会生成新的LS_COLORS值，并生成export LS_COLORS语句\neval命令会执行上述生成的命令\n由此，下次终端启动就会使用用户定义的标识样式\n3. 如果需要更改立即生效，可以重新加载配置文件\nsource ~/.bashrc\n</div>\n\n\n\n### 目录操作\n#### mkdir创建目录(make directory)\n<span class=\"strong\">mkdir [参数] 目录名</span>\n\n+ 可以指定多个目录名来同时创建多个目录\n+ -p 递归创建目录，可以在不存在的目录下创建新目录\n+ -m 权限：创建目录同时指定目录的权限，接收的参数支持权限的八进制值表示形式(如755)，也支持符号模式(如：移除组的写权限g-w)\n+ -v 每创建一个目录，打印一条消息\n\n<div class=\"show\">示例：\n# mkdir tmp/test/newdir\n在tmp目录下创建test目录及其子目录newdir，如果tmp目录下没有test目录，将提示无test目录，此时可以用-p参数\n# mkdir -p tmp/test/newdir\n将在tmp下新建test，再在test下新建newdir目录\n# mkdir newdir1 newdir2 newdir3\n在当前路径下新建三个目录\n</div>\n\n#### cd切换目录(change directory)\n<span class=\"strong\">cd 目录名</span>\n\n+ 目录名可以用<span class=\"tips\"> Tab键 </span>补全\n+ Linux中使用<span class=\"tips\"> . </span>表示当前目录，<span class=\"tips\"> .. </span>表示上一级目录，可以使用<span class=\"tips\">cd .. </span>返回上一级目录，必要时可以使用多个双点符来向上切换多层目录\n\n<div class=\"shell\">[root@vultr etc]# cd ../../etc</div>\n\n#### pwd查看当前路径(print working directory)\n<span class=\"strong\"> pwd [选项]</span>\n\n+ -L (默认)输出当前路径(PWD环境变量中存储的值)，该路径中可能存在符号链接\n+ -P 输出实际的物理路径，不含任何符号链接，符号链接会被替换为其所指向源文件的路径\n\n#### rmdir删除空目录(remove empty directory)\n<span class=\"strong\">rmdir [选项] 目录名1 目录名2.. </span>\n\n+ 只能用于删除空目录，系统不允许使用该命令删除有内容的目录\n+ -&zwnj;-ignore-fail-on-non-empty 忽略每次删除非空目录时的失败信息，常用于删除多个目录或递归删除时，避免因为尝试删除某个非空目录失败而命令退出\n+ -p 递归删除目录，如：rmdir -p a/b/c 会依次删除目录c、目录b、目录a，但如果其中一个目录非空，会导致命令失败退出，因此通常搭配-&zwnj;-ignore-fail-on-non-empty选项\n+ -v 每成功删除一个目录就打印其消息\n\n#### rm删除文件与目录(remove)\n<span class=\"strong\"> rm [选项] 文件或目录名</span>\n\n+ 默认情况下，命令不会删除目录，可以指定多个文件同时删除\n+ -d 如果指定的目录是空目录，则删除\n+ -r 删除目录，该选项会递归删除指定的目录及其目录中的内容\n+ -i 询问用户是否删除\n+ -f 强制删除，不再询问用户确认，且如果指定了删除不存在的文件，也不会提示用户\n+ -I 如果使用-r选项，或者删除3个以上文件时，询问用户是否继续执行该命令\n+ -v 在删除每个文件前打印其文件名\n+ -&zwnj;-one-file-system 只删除当前(所指定文件名)文件系统中的内容，该选项用于当使用-r选项进行递归删除时，避免意外删除另一文件系统的内容\n\n<div class=\"shell\">1. 依次进行询问\n# rm -i f?ll\n2. 删除以-开头的文件\nrm -&zwnj;- -filename\n</div>\n\n#### shred覆盖与删除文件\n通过rm命令删除的磁盘文件通常可以通过一些技术手段进行恢复，当需要完全删除文件时，可以使用shred命令，该命令会对删除的文件区域进行重写覆盖，以防止数据恢复。\n\n该命令在一些文件系统中效果可能有限，由于SSD使用了不同的数据存储和垃圾回收机制，该命令在固态硬盘中可能无效\n\n<span class=\"strong\">shred [选项] [文件名]</span>\n\n+ 默认情况下，命令会使用系统随机生成的数据覆盖文件，默认会覆盖3次，覆盖完默认不删除\n+ -n 值：指定覆盖的次数，默认为3\n+ -u 覆盖后删除文件\n+ -z 在进行最后一次覆盖时，使用数据0填充文件，这样文件在删除前看起来像是空的而不是随机数据，可以一定程度隐藏覆盖操作\n+ -v 打印覆盖的详细操作，如覆盖的进度\n+ -&zwnj;-random-source=文件：从指定文件读取随机字节进行覆盖，默认从Linux内核获取随机数据\n+ -s 值：粉碎文件的前指定个字节，默认会粉碎整个文件，可以使用k、M等单位\n\n#### unlink删除文件\n这是系统提供的unlink函数的最小接口，功能和rm命令一样，比较简洁，通常用于C语言等程序\n<span class=\"strong\">unlink 文件名</span>\n\n+ 一次只能删除一个文件，没有功能性选项\n+ 在某些系统中(如：GNU系统)，该命令只能删除文件而不能删除目录\n\n\n#### cp复制文件或目录(copy)\n<span class=\"strong\"> cp [选项] [源文件或目录] [目标文件或目录]</span>\n\n+ 注意！默认情况下，如果cp命令指定目标文件名，而该路径下已经有一个同名文件，则原本存在的文件会被cp命令覆盖\n+ 复制时可以同时指定多个源文件，此时最后一个参数\"目标文件\"需要指定一个已经存在的目录，cp命令不会自行创建目录\n+ -r或-R 递归复制目录，如果目录下有链接文件，则默认只复制链接文件本身\n+ -p 保留文件属性，如文件修改时间、文件所有者、权限等\n+ -a 归档模式，尽可能多地保留原有的文件结构和属性，等价于-dpr\n+ -i 需要覆盖已有文件前询问用户\n+ -f 强制覆盖文件，即使目标文件是只读的，它也会尝试删除后再复制\n+ -b 覆盖已有文件前先备份该已有文件，默认以~作为后缀名，备份方式参考Linux命令的通用备份方案\n+ -S \"字符串\"：备份文件时使用指定的字符串作为文件后缀名\n+ -n 不覆盖已存在的文件\n+ -u 只在原文件比目标文件更新，或目标文件不存在时复制文件\n+ -v 详细模式，详细输出每个复制的文件或目录名\n+ 复制单个链接文件时，命令默认会将链接指向的源文件内容复制到目标文件中，而不会去复制链接文件本身。如果链接文件已经失效(未找到它的源文件)，cp命令会直接报错以避免安全风险。\n+ 在使用-r或-a进行递归复制时，cp命令只会复制链接文件本身，而不会复制链接文件的源文件内容\n+ -d 将链接文件复制为符号链接文件，而不是复制源文件的内容\n+ -H 链接文件名：在使用-r或-a进行递归复制时，复制该链接文件的源文件内容\n+ -l 为文件创建硬链接，相较于ln命令，该选项会保留文件的属性（如时间戳和权限）\n+ -L 复制链接文件时，复制链接指向的目标文件，而不是符号链接本身\n+ -p [值]：保留文件的指定属性，该选项的取值可以是：mode(保留与访问权限相关的属性)、ownership(保留所有者和组，需要为该组成员才有权限)、timestamps(尽可能保留上次访问和上次修改的时间)、links(在目标文件中保留源文件的所有链接)、context(保留文件的 SELinux 安全上下文)、xattr(保留文件的扩展属性)、all(保留所有)\n\n<div class=\"show\">示例：\n# cp /file/test1 /file/test2 /newdir\n复制文件test1和test2到newdir目录中\n# cp -p install.log /tem\n复制install.log文件到tem目录中并保留install.log文件信息(不使用-p参数则文件最后修改时间为执行复制操作的当前时间)\n# cp -r /usr/dir /tem/newdir\n复制目录dir到tem目录下并命名为newdir\n</div>\n\n#### dd按指定块大小复制和处理文件\ndd命令支持按块大小读取和写入数据，并支持格式转换，适合从U盘等设备按块读取数据复制到指定位置，如：将整个分区复制到U盘或者从U盘备份(虽然dd支持该功能，但文件备份通常使用一些专用的备份脚本)\n\n<span class=\"strong\">dd 参数</span>\n\n+ 该命令选项较少，通常使用参数修改命令的行为\n+ if=文件路径：指定输入文件路径，默认从stdin读取\n+ of=文件路径：指定输出位置，默认输出到stdout\n+ ibs=值：设置输入块大小，默认为512bytes\n+ obs=值：设置输出块大小，默认为512bytes\n+ bs=值：指定输入块和输出块大小，这会覆盖ibs和obs的值\n+ count=值：指定块数量\n+ iflag=值：按照指定要求访问输入文件，可取值参考oflag的取值\n+ oflag=值：按照指定要求访问输出文件，值可以为：\n>> + append 以附加形似写入文件，这样即使其他进程正在写入此文件，dd 命令也会将其附加到文件的当前内容，只对oflag有效\n>> + direct 通过I/O直接读取或写入数据，而不使用缓冲区\n>> + noatime 不更新文件的访问时间戳\n>> 更多标志参考GNU文档\n\n<div class=\"show\">\n从/dev/zero文件读取数据，清空磁盘或分区\ndd if=/dev/zero of=/dev/sda bs=1M\n2. 测试磁盘读写速度\ndd if=/dev/zero of=testfile bs=1G count=1 oflag=direct\n</div>\n\n#### install复制程序文件\ninstall用来将文件(通常是程序文件)复制到指定位置，并且可以在复制时指定文件的权限、所有者等属性，该命令通常用来在Makefile中将程序复制到其目标目录中\n\n<span class=\"strong\">install [选项] [源文件] [目标文件]</span>\n\n+ -b 复制时如果目标文件已存在，则覆盖，覆盖前进行备份\n+ -S \"字符串\"：备份时指定文件后缀名\n+ -C 比较源文件和目标文件的内容，如果目标内容、所有者、组、权限和SELinux上下文没有变化，不进行复制，否则复制文件\n+ -g 组ID或组名：设置已安装文件或目录的所属组，默认为当前组\n+ -o 用户ID或用户名：设置已安装文件或目录的所有者，默认为root用户\n+ -m 值：设置文件权限，选项接收的值支持权限的八进制值表示形式(如755)，也支持符号模式(如：所有者增加执行权限u+x，移除组的写权限g-w)\n+ -v 详细模式，详细输出每个复制的文件或目录名\n+ -&zwnj;-preserve-context 保留文件和目录的SELinux安全上下文\n+ -p 设置文件的最后被访问时间和最后被修改的时间，如果不使用该选项，则这两个时间默认为程序文件的安装时间\n\n#### mv移动文件与重命名(move)\n<span class=\"strong\"> mv 原文件或目录 目标文件或目录</span>\n\n+ 注意！如果指定的目标文件路径下已经有同名文件，mv命令默认会直接覆盖该文件，源文件或目录可以有多个来同时移动多个文件\n+ -b 如果目标文件已存在，则进行备份\n+ -S \"字符串\"：指定备份文件的后缀名\n+ -f 目标文件存在时，直接覆盖，不询问用户\n+ -i 目标文件存在时，覆盖前询问用户\n+ -n 目标文件存在时，不覆盖已经存在的文件，视为操作失败\n+ -u 仅当目标文件比目标文件新(做了改动)，或目标文件不存在时移动文件\n+ -&zwnj;-exchange 交换原目录和目标目录中的文件(GNU拓展)\n+ -v 移动文件前打印每个文件的名字\n\n\n### 文件操作\n#### touch创建空文件\n该命令原本是用来修改文件的访问或修改时间戳的，当指定的文件不存在时，命令会创建一个空文件\n\n<span class=\"strong\"> touch 文件名1 文件名2...</span>\n\n+ 默认情况下，命令会将文件最后一次访问时间(atime)和修改时间(mtime)更改为当前时间，如果文件不存在，则会新建一个空文件\n+ 如果文件名中有空格符，需要使用\"\"\n+ -c 如果文件不存在，不新建文件，也不进行警告\n+ -a 仅更改文件最后一次被访问的时间(atime)\n+ -m 仅更改文件最后一次被修改的时间(mtime)\n+ -d 时间：将文件的atime和ctime更改为指定时间，而不是当前时间，该选项接受的时间格式很多，参考date命令，如：-d '2021-07-10 14:20:59 +0800'\n+ -t [[cc]yy]mmddhhmm[.ss]：将文件的atime和ctime更改为指定时间，该选项的格式要求较为严格，要按照指定格式书写\n+ -h 修改链接文件的时间戳\n+ -r 文件：使用该文件的atime和ctime作为更改的数据来源，该选项可以搭配-d选项，如：-r old.txt -s '-60 seconds'表示以old.txt文件的atime和mtime为原点，比该时间早60秒作为指定文件的atime和mtime\n\n<div class=\"show\">示例：\n# touch file1 file2\n创建两个文件file1、file2\n# touch \"fi le\"\n创建一个名为fi le的文件\n</div>\n\n#### 查看文件\n##### cat查看短文件内容\n<span class=\"strong\"> cat [选项] [文件名]</span>\n\n+ -n &emsp;显示行号(从1开始)，包括空白行\n+ -b &emsp;空白行行不显示行号，只为有文本的行添加行号(从1开始)\n+ -s &emsp;删除连续的多个空白行，只显示一行空白行\n+ -T &emsp;使用^T替换所有制表符\n从头到尾正常显示文件\n\n##### tac反向查看短文件内容\n<span class=\"strong\"> tac [选项] [文件名]</span>\ncat反写，从尾到头显示文件(文件末行为第一行)\n+ -s \"分隔符\"：指定分隔符，默认是换行符\n+ -b 将分隔符添加到记录开头\n+ -r 将分隔符字符串识别为正则表达式\n\n<div class=\"show\">这里只示例指定分隔符的情况，假设test.txt文件内容为\nAAAA,BBBB,CCCC\n执行命令：tac -s \",\" test.txt\n输出为：\nCCCC       #由于原文件CCCC后有换行符，因此这里CCCC之后也输出一个换行符\nBBBB,AAAA,\n执行命令：tac -b -s \",\" test.txt\n输出为：\n,CCCC     #分隔符将被添加到记录开头\n,BBBBAAAA\n</div>\n\n##### more查看长文件内容\n该命令来源于util-linux软件包\n<span class=\"strong\"> more [文件名]</span>\n分页显示文件，一般用于查看长文件\n\n+ 空格或f &emsp;向下翻页\n+ b     &emsp;&emsp; &emsp;&nbsp;向上翻页\n+ Enter  &emsp;&emsp;换行\n+ q或Q &emsp;&emsp;退出\n\n<span class=\"strong\"> less [文件名]</span>\n该命令来源于less软件包，其命令名来源于\"less is more\"，因此也比more提供了更多高级功能，如使用上下箭头翻页，它同样会分页显示文件，一般用于查看长文件，支持关键字搜索\n\n+  空格或f或PageDown&emsp;向下翻页\n+ b或PageUp&emsp;&emsp;&emsp;&emsp;&emsp;向上翻页\n+ 上下方向键&emsp;&emsp;&emsp;&emsp;&emsp;逐行翻动\n+ 可以使用<span class=\"tips\"> /关键字 </span>进行关键字搜索，使用<span class=\"tips\"> n </span>跳转到下一个高亮显示的关键字\n+ q或Q &emsp;&emsp;退出\n\n##### head&tail仅查看前几行或后几行\n<span class=\"strong\"> head [选项] 文件1 文件2....</span>查看文件前几行内容\n\n+ 默认显示前10行\n+ 如果指定多个文件，在输出每个文件内容前会以<span class=\"tips\">==&gt;文件名&lt;==</span>形式输出文件名\n+ -c [-]num：显示前num个字节，如果num值前添加了-，则输出每个文件除了最后num个字节以外的所有内容，可以使用K(KiB)、KB、MB、GB、GiB等单位\n+ -n [-]num：显示前num行内容，如果num值前添加了-，则输出每个文件除了最后num行以外的所有行\n+ -q 不打印文件名\n+ -z 一些二进制文件或特殊文本文件会以空格作为数据分隔符，该选项用于处理这类文件时，以空格作为字段分隔符(默认是以换行符作为分隔符)，如<span class=\"tips\">head -z -n 2</span>会输出文件的前两个以空格分隔的字段，而不是前两行\n\n<span class=\"strong\"> tail [选项] 文件名</span>\n\n+ -n 行号：仅仅查看文件末几行，不使用 -n 指定行号，默认显示后10行\n+ -c 字节数：查看文件最后几个字节\n+ -f 动态显示文件末尾，常用于查看日志文件实时变更(-&zwnj;-follow)\n+ -q 不输出文件名\n\n##### nl显示行号与内容(number line)\n<span class=\"strong\"> nl [选项] [文件名]</span>\n用于给文本文件内容添加行号并输出到屏幕，如果不指定文件名，nl命令会从标准输入读取内容\n\n+ -b 样式：指定行号的样式(-&zwnj;-body-numbering=style)，样式支持以下值：\n>>+ a 对所有行编号\n>>+ t 只对非空行进行编号\n>>+ n 不对行进行编号\n+ -w 值：指定行号的宽度，默认为6位\n+ -i 值：设置行号的递增值，可以为负数,默认为1\n+ -l 值：将连续的空行视为一个空行，并只对最后一个空行添加行号，如果连续空行的数量少于该值，则不进行编号(这里的空行指不含任意字符的行，甚至不包括空格、制表符的行)\n+ -n 格式：指定行号的格式(-&zwnj;-number-format=format)，格式支持以下值，默认为rn:\n>>+ ln 左对齐，无前导0\n>>+ rn 右对齐，无前导0\n>>+ rz 右对齐，有前导零\n+ -s 字符串：指定一个字符串添加到行号与文本行之间(默认为tab)\n常用组合选项：\n+ -bt:对非空的文本行进行标号，包含注释行(仅限于使用#号注释的行，一些编程语言里的注释方式不会被识别)，空行除外(默认)\n+ -ba:对所有行都进行标号\n+ -bn:不标出行号，但文本左侧仍会为行号预留空格\n+ -nln:行号左对齐，无前导0\n+ -nrn:行号右对齐，无前导0(默认)\n+ -nrz:行号右对齐，有前导0\n\n<div class=\"show\">(1) nl data.txt 默认情况下，nl命令会在左侧标出行号，并且行号宽度为6位，空白行将被跳过   \n      1 AAAA\n      2 BBBB<br>\n      3 CCCC\n(2) nl -ba data.txt 会为包括空白行在内的行标出行号\n      1 AAAA\n      2 BBBB\n      3\n      4 CCCC\n(3) nl -nln data.txt 行号会左对齐，无前导0\n1     \tAAAAA\n2     \tBBBBB<br>\n3     \tCCCCC\n(4)nl -nrn data.txt 行号会右对齐，无前导0\n     1\tAAAAA\n     2\tBBBBB<br>\n     3\tCCCCC\n(5)nl -nrz data.txt 行号右对齐，行号前会补0\n000001\tAAAAA\n000002\tBBBBB<br>\n000003\tCCCCC\n(6)nl -ba -i2  data.txt\n     1\tAAAAA\n     3\tBBBBB\n     5\t\n     7\tCCCCC\n</div>\n\n#### 以指定格式打开文件\n##### od以指定进制打开文件(octal dump)\n该命令用于查看二进制文件或文本文件的十六进制、八进制、ASCII等数据表示形式，可以直观地查看文件的非打印字符或二进制内容，以及文件内容在文件中的地址\n\n<span class=\"strong\">od [选项] 文件名</span>\n\n+ -A 进制：指定文件地址的进制表示形式，可以取以下值：\n>>+ n 不显示地址\n>>+ o 以八进制显示地址(默认)\n>>+ x 以十六进制显示地址\n>>+ d 以十进制显示地址\n>>+ a 以字母方式显示地址\n+ -t 格式：指定文件内容的输出格式，可以取一下值：\n>>+ o 以八进制格式显示\n>>+ x 以十六进制格式显示\n>>+ d 以十进制格式显示\n>>+ c 以字符方式显示\n>>+ f 以浮点数格式显示\n+ -N 长度length：显示文件的前length个字节的数据，可以使用MB、GB、KiB、GiB等单位指定字节数\n+ -j 长度skip：跳过文件的前skip个字节，从此处开始显示数据，可以使用MB、GB、KiB、GiB等单位指定字节数\n+ -v 显示所有数据，默认压缩相同的连续行为一行\n\n##### base64解码与编码文件\n将从文件或标准输入读取的数据转换为 base64 编码形式，可以用来将二进制数据转换为可打印的文本数据\n\n<span class=\"strong\">base32 [选项] [文件名]</span>\n\n<span class=\"strong\">base64 [选项] [文件名]</span>\n\n+ <span class=\"strong\">-d</span> 解码数据，不使用该选项为编码数据(-&zwnj;-decode)\n+ -w 值：指定每行输出字符数，达到该长度后换行，默认值为76，值为0则表示不换行(-&zwnj;-wrap=number)\n+ -i 解码时忽略换行符和无法识别的字节，而尝试尽可能解码剩余的字节，数据包在网络中传输时，可能会被分割和损坏，该选项会忽略数据分割形成的换行符和传输损坏的数据\n\n<div class=\"show\">如：/dev/urandom是特殊的设备文件，该文件可以用来生成随机数，但该文件返回值是二进制数据，直接查看会解析成乱码，需要将其转为文本数据\nhead -c 10 /dev/urandom | base64\n输出值为：\nKhXWNVbInIhkxw==\n</div>\n\n##### basenc多格式解码与编码文件\nbasenc是一个较新的命令，可能在部分旧的GNU Coreutils包中没有包含该命令，该命令相较于base64支持更多的编码和解码格式\n\n<span class=\"strong\">basenc [选项] [文件名]</span>\n\n+ -d(解码)、-w、-i选项和base64命令相同\n+ -&zwnj;-base64:使用 Base64 编码或解码数据\n+ -&zwnj;-base32:使用 Base32 编码或解码数据\n+ -&zwnj;-base16:使用 Base16（十六进制）编码或解码数据\n+ -&zwnj;-base32hex：使用拓展十六进制字母表base32形式进行解码或编码\n+ -&zwnj;-base64url:标准的 Base64 编码中，使用了+和/字符，它们在URLs和某些文件系统中可能有特殊含义，该选项会将+替换为-，将/替换为_，去除编码末尾的填充字符=，以此编码或解码为文件和 URL 安全的 base64 格式\n+ -&zwnj;-z85:使用 Z85 编码或解码数据，编码时输入长度必须是 4的倍数;解码时，输入长度必须是5的倍数\n+ -&zwnj;-base2lsbf:编码为二进制形式，每个字节的最低有效位在前\n+ -&zwnj;-base2msbf：编码为二进制字符串形式，每个字节的最高有效位在前\n\n#### 格式化输出内容\n##### fmt格式化行(format)\nfmt命令用来将文件内容按指定的宽度输出，它会拆分太长的句子，并根据选项决定是否保留其原有格式。该命令只能用来格式化处理ASCII文本，无法格式化处理中文等文本。\n\n<span class=\"strong\">fmt [选项] 文件名</span>\n\n+ 默认情况下，该命令每行输出的长度为75个字符(包含换行，因此实际输出长度为74)\n+ -w 长度：指定每行文本的字符长度，该值将包含换行符，实际输出的文本字符为指定的值-1\n+ -s 只拆分长行，而不将短行合并到一起以达到每行输出指定字符的要求，默认情况下会合并短行\n+ -c 保留每行的缩进格式，如：原文件首行缩进2字符，该选项会保留这个缩进\n+ -t 在处理带有标签或行号等段落时，保留这些行的缩进等格式\n+ -u 文本中包含多个连续空格符时，删减到只保留一个空格符\n+ -p \"字符\"：仅格式化以该字符开头的行，如：-p \"#\"将只格式化以#开头的行(如：注释行)\n\n<div class=\"show\">e.g.假设文件test.txt中有以下内容\n1. AAA AA AA A AAAAA\n2. This is a very long line that we want to format using the fmt command. The fmt command is useful for text formatting.\n3. BBB BB BB B BBBBB\n默认情况下，fmt命令会合并行，每行输出75字符\n1. AAA AA AA A AAAAA 2. This is a very long line that we want to format\nusing the fmt command. The fmt command is useful for text formatting.\n3. BBB BB BB B BBBBB\n-w选项可以指定每行的输出字符数量\nfmt -w 30 test.txt\n输出的行包含换行符在内为30个字符\n1. AAA AA AA A AAAAA 2. This\nis a very long line that we\nwant to format using the fmt\ncommand. The fmt command is\nuseful for text formatting.\n3. BBB BB BB B BBBBB\n-s选项可以保留短行不合并，拆分长行\n1. AAA AA AA A AAAAA\n2. This is a very long line that we want to format using the fmt\ncommand. The fmt command is useful for text formatting.\n3. BBB BB BB B BBBBB\n-t选项可以保留编号等格式\nfmt -t test.txt\n输出为：\n1. AAA AA AA A AAAAA\n2. This is a very long line that we want to format using the fmt\n   command. The fmt command is useful for text formatting.\n3. BBB BB BB B BBBBB\n</div>\n\n##### pr文件分页与打印(print)\npr 命令用于将单个或多个文件格式化为打印机打印格式，它可以将文件分成页，并支持添加页眉、页脚功能\n\n<span class=\"strong\">pr [选项] 文件名</span>\n\n+ -l 行数：指定每一页的行数，默认值为66行，如果一页不满足66行，则会填充空白行\n+ -w 宽度：指定每行的字符数，默认值为72个字符，\n+ -d 双倍行距输出，这会在每行之间插入一个空行，更容易阅读\n+ -h \"页眉字符串\":设置页眉，默认情况下，pr命令会在每页顶部显示文件名和日期\n+ -o 缩进数：指定每行的缩进空格数\n+ -n 为每行添加行号\n+ -m 并列显示多个文件的内容。如果提供了多个文件，此选项可以将它们的内容并列显示在同一页上\n+ -t 禁用页眉和页脚输出\n+ -F 在每页末尾添加换页符，适用于需要在打印时进行分页的情况\n\n##### fold强制文本行换行\nfold命令用于强制限制每行文本的输出长度，将文件的每一行按指定宽度分割为多行，相较于fmt命令，fold命令只会强制在固定宽度处换行，不会对文本内容进行任何重新排列或合并\n\n<span class=\"strong\">fold [选项] [文件名]</span>\n\n+ -w 值：指定每行文本的字符数，默认值为80个字符\n+ -s 在空白字符处分割行，而不是在固定宽度处强制换行。这会让文本在自然的空格处换行，而不破坏单词\n+ -b 值：指定每行文本的字节数，该选项按照字节数分割文本行，可用于处理多字节字符(如中文)，可以使用MB、GB、KiB、GiB等单位\n\n##### split文件拆分\nsplit命令用于将文件分割成多个较小的文件，它可以按指定的字节数、行数或其他标准来分割文件，非常适合处理大型数据文件或将文件分割成适合传输的小块，尤其是在需要将其传输至大小受限的环境中时\n\n<span class=\"strong\">split [选项] 文件名 [新文件名前缀]</span>\n\n+ 默认情况下，该命令会为每个文件写入最多1000行文本，默认输出的文件名为xaa,xab.....\n+ 如果指定了新文件名前缀newfile_，输出的文件名为newfile_xaa...\n+ -n 数量：将文件拆分为5个部分\n+ -b 字节数：按指定的字节数拆分文件，该选项不考虑行的完整性，可能会将同一行内容拆分到两个文件中\n+ -C 字节数：按指定的字节数拆分文件，该选项不会拆分行，它会在文件达到指定大小时，寻找下一个换行符进行分割，从而确保每一行都完整保留在同一个文件中\n+ -l 行数：按指定的行数拆分文件\n+ -d:使用数字作为输出文件的后缀，如x00,x01....\n+ -a 值：指定输出文件的后缀长度，如：-a 4表示输出文件名为xaaaa,xaaab...，默认值为2\n+ -&zwnj;-additional-suffix=字符串：为文件名添加后缀\n+ -&zwnj;-numeric-suffixes=值：指定文件的数字后缀从该值开始\n\n<div class=\"show\">e.g.拆分文件test\n1. 每个文件写入100行\nsplit -l 100 test\ntest中的内容会被拆分到以下文件中：xaa xab xac....\n2.指定新文件的文件名，并使用数字作为文件后缀\nsplit -l 100 -d test newFile\n拆分后文件名为：newFile01 newFile02....\n3.指定文件的固定后缀\nsplit -l 100 -d --additional-suffix=.txt test newFile_\n拆分后文件名为：newFile_01.txt newFile_02.txt ....\n</div>\n\n##### csplit按内容拆分文件\ncsplit是一个用于按特定模式或位置分割文件的命令,与split不同，csplit可以根据正则表达式模式匹配或指定行号将文件拆分为多个部分，适合处理需要基于内容分割的场景\n\n<span class=\"strong\">csplit [选项] 文件名 '正则表达式/PATTERN/或行数n' '{重复次数}'</span>\n\n+ 默认情况下，命令会在内容写入文件后打印该文件的大小(字节数)\n+ 如果指定正则表达式，命令会在匹配处分割文件，并且匹配的这一行会写入下一个文件。如果还指定了重复次数，则会继续查找下一次匹配的内容，默认只匹配一次\n+ 如果指定的是行的数量，则从数量对应的该行处分割文件，并且该行写入下一个文件。如果指定重复次数，也会继续进行分割\n+ 分割后生成的文件名默认为xx00，xx01，xx02.....\n+ -f 字符串：指定生成的文件名前缀，默认是xx\n+ -b 格式字符串：指定生成文件名的后缀，默认为%02d(两位数字)\n+ -n 值：指定生成文件名后缀中的数字位数，默认为2\n+ -k 遇到错误，不要删除输出文件\n+ -z 删除大小为 0 的输出文件\n+ -s或-q：不打印每个文件大小\n\n<div class=\"show\">e.g.文件test的内容为：\nAAAA\n1111\nBBBB\nCCCC\n2222\nDDDD\n在文件中包含数字的行处进行分割(默认分割一次)\ncsplit test '/[0-9]/'\n分割以后的文件为：\nxx00文件：  \nAAAA\nxx01文件：   \n1111\nBBBB\nCCCC\n2222\nDDDD\n在文件中包含数字的行处进行分割，并分割任意多次\ncsplit test '/[0-9]/' '{*}'\n分割以后的文件为：\nxx00文件：      \nAAAA               \nxx01文件：         \n1111\nBBBB\nCCCC\nxx02文件：\n2222\nDDDD\n</div>\n\n\n#### file查看文件类型\n<span class=\"strong\">file [选项] 文件名</span>查看文件类型\n+ -i 显示文件的MIME 类型，而不是传统的文件类型描述，如：text/plain; charset=us-ascii\n+ -b 显示结果去掉文件名，只显示文件信息\n\nfile命令会检查文件内容的特征，而不仅仅通过文件扩展名来识别文件的实际类型，这对于处理没有扩展名或扩展名不正确的文件特别有用，命令可以识别文本文件(文本文件还可以识别它的编码格式)、可执行文件、图像文件、压缩文件等多种类型\n<div class=\"show\">file命令可以帮助我们提前探测文件内容，并返回具体类型，如：\nfile my_file\n返回：\nASCII text说明该文件是ASCII编码的文本文件\ndirectory说明是一个目录\nsymbolic link to 'data_file'说明是一个软链接文件并链接到了data_file文件\nBourne-Again shell script, ASCII text executable说明该可执行程序编译或执行所面向的平台或库\n</div>\n\n#### sync将缓存写入磁盘\n立即将内存缓冲区中的所有数据写入磁盘中，该命令常用于：\n+ 对重要数据进行修改后，立即保存修改到磁盘\n+ 卸载文件系统(移除U盘等设备)前，确保所有数据写入完毕\n+ 进行系统更新和维护前，确保数据安全保存完毕\n\n<span class=\"strong\">sync [选项] [文件名]</span>\n\n+ 如果不指定任何参数和选项，命令会将所有挂载文件系统中内存缓冲区的数据同步到磁盘\n+ -d 只同步该文件数据，而不刷新文件的元数据(例如文件权限、所有者、时间戳等)\n+ -f 将包含该文件的整个文件系统同步到磁盘，而不仅仅是该文件的数据部分\n\n#### truncate扩大或缩小文件大小\n<span class=\"strong\">truncate 选项 文件1 文件2...</span>\n\n+ 默认情况下，如果所指定的文件不存在，将创建该文件，如果未指定-s选项，则新建的文件大小为0字节\n+ -c 不创建不存在的文件\n+ -s 值size：将文件大小调整为指定值，默认以字节为单位，值支持使用K/KiB(1024bytes)、KB(1000bytes)等单位，值之前也支持使用以下前缀：\n>>+ \\+在当前文件大小基础上扩大size字节\n>>+ \\-在当前文件大小基础上缩小size字节\n>>+ &lt;将文件大小调整到小于该值\n>>+ &gt;将文件大小调整到大于该值\n>>+ / 将文件大小缩小为size的倍数\n>>+ % 将文件大小扩大为size的倍数\n+ -r 文件名：以该文件大小作为参考值进行修改\n+ -o 将-s指定size视为文件I/O块数，而不是字节数\n\n该命令用来将文件扩大/缩小到指定大小。如果文件小于指定大小，则命令会使用空字符(\\0)填充文件末尾，空字符在文本编辑器中不可见，但文件实际大小会被改变；如果文件大于指定大小，则文件末尾会被截断，多余的数据会丢失。该命令可以用于以下场景：\n+ 创建大文件用于测试：可以快速创建特定大小的文件，用于测试磁盘写入速度或其他场景。\n+ 调整日志文件大小：对日志文件进行大小调整时，可以使用 truncate 来截断多余数据。\n+ 快速清空文件：将文件大小设置为 0 来清空文件内容\n\n<div class=\"show\">1. 创建一个1G文件\ntruncate -s 1G myfile.bin\n2. 将example.txt调整为5M大小\ntruncate -s 5M example.txt\n3.在当前文件大小基础上增大1M\ntruncate -s +1M example.txt\n4.将文件大小缩小为512的倍数\n如果文件example.txt原大小为1000bytes，将缩小为512bytes\ntruncate -s /512 example.txt\n5.将文件大小扩大为512的倍数\n如果文件example.txt原大小为1000bytes，将扩大为1024bytes\ntruncate -s %512 example.txt\n</div>\n\n\n### 链接文件\n\n链接文件是Linux文件系统的一个优势。当需要在系统上维护同一文件的两份或多份副本时，除了保存多份单独的物理文件副本之外(复制文件)，还可以采用保存一份物理文件副本和多个虚拟副本的方法(链接文件)，这种虚拟的副本就称为链接。Linux文件系统有两种链接文件：\n+ <span class=\"strong\">软链接</span>：也称为符号链接或软连接，相当于文件的快捷方式。为了方便跨分区指向，软链接文件拥有独立的inode号，是一个单独的文件，但文件本身只包含指向原文件或原目录的路径，而不包含实际的文件内容，所有对软链接的读取、执行等操作都是基于原文件。当原文件删除，软链接文件也将失效，因此可视为软链接只是一个指向原文件的指针\n+ <span class=\"strong\">硬链接</span>：是一个被创建出来的独立虚拟文件，其中包含了原文件的信息及位置。但是硬链接文件和原文件本质上是同一个文件，inode号相同，删除原文件并不会造成硬链接文件的失效，也不会造成文件内容丢失，因为此时仍然还存在一个可以访问文件存储区域的通道(硬链接文件)\n\n二者区别:\n+ 生成的软链接权限都为 rwxrwxrwx，实际权限取决于原文件权限\n+ 硬链接文件 inode 节点与原文件相同，软链接不同\n+ 硬链接指向不能跨分区，软链接可以\n+ 不能给目录生成硬链接，软链接可以\n\ninode(索引节点)：是Linux文件系统中的一个概念，用于存储文件的元数据信息。每个文件在文件系统中都有一个对应的inode，它包含了文件的具体信息，如文件类型、文件大小、权限信息、所有者、访问时间、修改时间、链接数等。在Linux文件系统中，文件内容被存储于数据块中，而inode存储了文件的元数据信息和指向文件数据块的指针。当用户创建一个文件时，系统会分配一个inode给这个文件，并记录文件的元数据信息。每个inode都有一个唯一的索引号，即文件或目录的inode编号，它是一个用于标识的唯一数字，这个数字由内核分配给文件系统中的每一个对象。要查看文件或目录的inode编号，可以使用ls -i命令，文件系统可以通过该索引号来找到对应的inode和文件。硬链接文件和源文件共享相同的inode，即它们指向同一个文件的元数据信息，因此在inode中会有一个链接计数器，记录有多少个目录项指向这个inode，这样系统可以正确处理不同目录下的链接关系。\n\n对于硬链接，硬链接和原始文件本质上是同一个文件，它们共享相同的inode。当用户创建一个硬链接时，实际上是在创建一个指向相同inode的新目录项，使得该文件在文件系统中有多个名称。因此，删除源文件时，不会影响到已经创建的硬链接文件，因为这其实只是减少了一个指向该inode的目录项，而硬链接文件依然指向这个inode，因此硬链接文件会继续存在。只有当所有指向该inode的目录项都被删除后，文件系统才会释放该inode及其对应的数据块，这时硬链接文件也会被删除。\n\n对于软链接(Symbolic Link)，它是一个特殊的文件，用于指向另一个文件的路径。和硬链接不同，软链接创建了一个新的inode来存储软链接文件的元数据信息。软链接和原始文件是两个独立的文件，它们可能位于不同的文件系统中。因此，软链接需要有自己的inode来存储自己的元数据信息，以确保其独立性。软链接的实现方式是通过存储目标文件的路径信息，而不是直接指向目标文件的inode。这样做的好处是可以在文件系统中创建指向不同文件系统的软链接，而硬链接只能在同一文件系统中有效。软链接文件的存储内容是指向另一个文件的路径，而不是具体的文件内容，因此即便源文件很大，软链接文件依旧可能很小。而所有通过vim等软件修改软链接内容，实际是在修改源文件的内容，所有对软链接的读取、执行等操作都会基于源文件，软链接只是一个指向源文件的指针，当源文件删除，软链接文件也将失效。\n\n#### link创建硬链接\n该命令只能创建硬链接\n<span class=\"strong\">link 源文件 硬链接名</span> \n\n#### ln创建链接文件\n<span class=\"strong\">ln 源文件 目标文件</span>\n\n+ 默认会创建硬链接，如果指定路径下已有与目标文件同名的文件，则返回错误\n+ -s 创建软链接\n+ -b 创建链接时如果已有同名文件，则备份该文件，参考通用的备份方案\n+ -S \"字符串\"：指定备份文件的后缀名\n+ -f 强制创建链接文件，有同名文件直接覆盖\n+ -i 有同名文件时，询问用户是否覆盖\n+ -v 打印每个创建链接的文件名\n+ -L 当源文件是软链接文件时，创建的新链接指向该软链接所指向的文件，该选项会创建硬链接\n+ -P 当源文件是软链接文件时，创建的新链接指向该软链接本身(默认)\n+ -r 创建基于相对路径(默认为绝对路径)的软链接，这在目录结构整体发生移动时，链接仍然有效，该选项需要搭配-s选项\n\n<div class=\"show\">示例:\n# ln /etc/issue /tmp/issue.hard\n为/etc/issue创建硬链接\n# ln -s /etc/issue /tmp/issue.soft\n为/etc/issue创建软链接\n</div>\n\n#### readlink查看软链接的源文件\n<span class=\"strong\">readlink [选项] 文件名</span> 查看软链接所指向的实际文件路径\n\n+ 默认情况下，命令会直接输出符号链接文件本身所存储的源文件的文件路径，这个路径可能是绝对路径，也可能是相对路径，这取决于软链接创建时的选项\n+ -f 输出符号链接所指向的文件或目录的绝对路径。如果符号链接指向另一个符号链接，则会继续解析直到找到最终的源文件或目录。即使路径中的某些目录或文件不存在(这些文件未来可能会由其他程序创建)，也返回该路径而不报错\n+ -e 输出符号链接所指向的文件或目录的绝对路径，这些路径必须是存在的，否则返回空并报错，该选项适用于要保证整个路径都真实存在的情况\n+ -m 类似于-m选项，如果路径中的某个目录或文件不存在，命令会直接将其视为目录，然后返回完整的绝对路径\n+ -n 输出的路径末尾不添加换行符，方便与其他命令结合使用\n+ -s或-q 静默模式，禁止显示大多数错误消息(默认)\n+ -v 输出错误消息\n\n### 管道文件\n管道(pipe)是一种在不同进程之间进行数据传输的通信机制，它允许一个进程写入数据，另一个进程按顺序读取数据，从而实现进程间的通信。管道中的数据是以\"流\"的形式进行传输，管道的使用能够有效地实现数据流的连接，使得用户能够将多个命令串联起来，形成一个复杂的命令执行流程。管道通信有以下特点：\n+ 先进先出：先写入的数据会被先读取，遵循\"First In, First Out\"原则。\n+ 双进程通信：管道允许两个进程之间进行数据传输，一个进程写入数据，另一个(或多个)进程读取数据，读与写可以同步进行\n+ 流式数据：管道中的数据被存储于内存的内核缓冲区，数据是一次性传输的，被读取一次后就会消失，是一种流式数据\n+ 阻塞行为：为了保证进程间数据传输的有序性和同步性，管道通过阻塞读写操作来协调数据的传输。进程在写入数据时，如果缓冲区已满，进程的写入操作会被阻塞，直到另一个进程从管道中读取数据，腾出缓冲区空间，写操作才会继续。类似的，读操作也会被阻塞，当进程从管道中读取数据时，如果缓冲区为空，进程的读操作会被阻塞，直到有数据写入。如果写入进程已经终止(写端关闭)，且管道内的数据已被读完，则读操作会立即返回<span class=\"tips\">EOF</span>(End Of File)，表示管道结束。\n\n#### 匿名管道\n匿名管道的创建完全基于内存，不会在文件系统中生成任何文件或路径，在创建时不分配名称，它只能在有关系的进程(如父子进程)间使用，而不能在任意进程之间通信。匿名管道的生命周期与创建它的进程相关，当创建这个管道的进程结束时，管道也会被关闭，匿名管道只能通过文件描述符来访问。\n\n在C语言中，可以使用系统调用pipe()来创建匿名管道，在命令行中使用管道符<span class=\"tips\">|</span>创建的也是匿名管道，此时shell会创建子shell，管道符两侧的命令都将在独立的子shell中并行执行，虽然子shell中运行的命令是独立的进程，但他们是在同一个父shell上下文中执行的，因此它们可以通过管道完成通信。\n\n#### mkfifo创建命名管道(管道文件)\n命名管道(named pipes)通常被直接称为FIFO(First In, First Out的缩写)，它会被显式地创建在文件系统中，称为管道文件。管道文件是一种特殊的文件，它虽然在文件系统中拥有文件路径，但数据的存储位置依旧位于内存缓冲区，管道文件本身并不存储数据，管道文件可以通过以下命令创建：\n\n<span class=\"strong\">mkfifo [选项] 文件名</span>\n\n+ -m 权限：为创建的管道文件指定权限，接收的参数支持权限的八进制值表示形式(如755)，也支持符号模式(如：移除组的写权限g-w，默认为a=rw，即允许所有人读写，可以基于此权限进行删减)\n\n#### mknod创建设备文件或管道文件\n该命令用于让用户手动创建特殊文件，比如字符设备、块设备以及命名管道\n\n<span class=\"strong\">mknod [选项] 文件名 文件类型 [参数]</span>\n\n+ -m 权限：为创建的管道文件指定权限，接收的参数支持权限的八进制值表示形式(如755)，也支持符号模式(如：移除组的写权限g-w，默认为a=rw，即允许所有人读写，可以基于此权限进行删减)\n+ 文件类型有：p(命名管道文件)、c(字符设备文件，如：键盘设备)、b(块设备文件，如：U盘设备)\n\n<div class=\"show\">1.创建一个命名管道文件\nmknod newpipe p\n2.创建块设备文件\nmknod /dev/myblockdevice b 8 1  #8是主设备号，1是次设备号\n</div>\n\n### 临时文件\nLinux系统提供了一个特殊的目录<span class=\"tips\">/tmp</span>，用于存放临时文件。大多数Linux发行版会在系统在启动时自动删除tmp目录下的所有文件，或会周期性清理长期不访问的临时文件，且系统上的任何用户账户都有权限读写tmp目录中的文件，这为用户创建临时文件提供了便利，且不用担心清理工作\n\n#### 创建临时文件\n<div class=\"apiBox\">mktemp [选项] [文件名模版.XXXXXX]</div>\n\n+ 使用该命令时，通常会指定一个文件名模板，文件名模板末尾必须包含<span class=\"tips\">至少3个</span>(通常6个)<span class=\"tips\">X</span>(必须为大写X)，mktemp命令在创建该文件时会使用随机字符替换X，以保证临时文件的唯一性。默认情况下，如果文件名模板前未指定路径，命令会在当前目录中创建临时文件或目录，如果指定了路径，则前往指定路径下创建\n+ 如果不指定文件名模板，命令将使用默认模板'tmp.XXXXXXXXXX'(10个随机字符)，且默认会在/tmp目录下创建临时文件，而不管当前路径如何\n+ -p 路径：在指定路径下创建临时文件或目录\n+ -t 在 $TMPDIR 环境变量指定的目录中创建文件或目录。如果未设置 $TMPDIR，则在/tmp路径下生成临时文件或目录，返回完整路径名\n+ -d 创建临时目录\n+ -q 在无法创建临时文件或目录时不产生错误信息\n+ -&zwnj;-suffix=\"字符串\"：为生成的文件添加指定后缀\n\n<div class=\"show\">1.在当前目录下创建临时文件\n$ mktemp testing.XXXXXX\ntest.Oa6cx4\n2. 在tmp目录下创建临时文件，会返回完整路径\n$ mktemp -t testing.XXXXXX\n/tmp/test.Nhy8Ym\n</div>\n\n#### 临时文件的清理\nLinux中的临时文件主要位于两个路径下：\n+ /tmp：用于存放短期临时文件\n+ /var/tmp：用于存放长期的临时文件，默认情况下，文件可能保留30天或更久\n\n大多数现代Linux发行版使用systemd-tmpfiles来管理临时文件，部分系统可能使用cron定时任务来进行清理。systemd-tmpfiles的配置文件通常位于<span class=\"tips\">/usr/lib/tmpfiles.d/tmp.conf</span>或<span class=\"tips\">/etc/tmpfiles.d/</span>路径下。如：配置文件 /usr/lib/tmpfiles.d/tmp.conf 中的内容可能如下：\n\n<div class=\"shell\"># Clear tmp directories separately, to make them easier to override\nD /tmp 1777 root root 30d\nD /var/tmp 1777 root root 30d\n</div>\n\n该配置表示：\n+ /tmp 目录中超过 10 天未被访问的文件会被清理\n+ /var/tmp 目录中超过 30 天未被访问的文件会被清理\n\n#### 脚本中临时文件的使用\n在脚本中创建临时文件时，使用touch、echo等命令创建临时文件有可能带来文件名冲突等问题，且所创建的文件容易受到符号链接攻击，使用mktemp命令创建临时文件是一种更安全的推荐方法\n\n<div class=\"shell\">#!/bin/bash\n# 创建一个临时文件\ntempfile=$(mktemp myfile.XXXXXX)\n...\n# 脚本功能\n...\n# 在脚本退出时删除临时文件\ntrap \"rm -rf $tempdir\" EXIT\n</div>\n\n\n### 处理文件路径\n这些命令不会去验证所指定的文件或路径是否存在，只是单纯返回所给定的路径字符串中的某个部分\n\n#### basename提取文件名\n该命令用于从文件路径中删除路径和文件后缀，提取纯净的文件名或目录名，方便使用干净的文件名进行重命名或备份\n\n<span class=\"strong\">basename 文件路径 [要删除的文件后缀]</span>\n\n<span class=\"strong\">basename [选项] 文件路径</span>\n\n+ 默认情况下，命令会去除文件或目录的路径部分\n+ -a 在指定多个路径时需要使用该选项，该选项会将每个参数视为一个文件路径，而不是要删除的文件后缀\n+ -s 后缀字符串：指定需要删除的文件后缀，该选项适合第二种命令，GNU版本的basename命令，使用-s选项会默认隐式启用-a选项\n+ -z 在每行输出末尾输出空字符(null)，而不是换行符\n\n<div class=\"show\">1. 删除路径和后缀(命令会隐式启用-a选项以解析多个路径)\nbasename -s .txt /home/user/file1.txt /home/user/file2.txt\n输出：\nfile1\nfile2\n2. 处理目录\nbasename /home/user/documents/\n输出：documents\n3.一次性处理多个路径\nbasename -a /path/file1.txt /path/file2.html /path/file3.sh\n输出：\nfile1.txt\nfile2.html\nfile3.sh\n</div>\n\n#### dirname提取路径\n该命令与basename命令相反，它会获取文件路径而去除文件名\n\n<span class=\"strong\">dirname [选项] 文件路径</span>\n\n+ 可以同时指定多个路径而不需要任何选项\n+ 如果指定一个文件而不包含/路径，则返回的路径为.(当前目录)\n+ -z 在每行输出末尾输出空字符(null)，而不是换行符\n\n<div class=\"show\">1. 获取文件路径\ndirname /path/to/file1.txt /home/user1/test.sh\n输出：\n/path/to\n/home/user1\n2. 获取目录的路径\ndirname /myshell/new/checkOS/ \n输出：/myshell/new\n3. 单个文件的路径为.\ndirname checkOS.sh \n输出：\n.(当前目录)\n</div>\n\n#### pathchk检查文件名是否有效\npathchk命令通常用于验证路径名是否符合当前系统的文件命名规则(比如文件名长度限制或字符限制)，帮助用户在创建文件或目录之前，或在不同系统之间移动文件之前，检测出潜在的问题，避免因路径名不合法而导致的操作失败。在POSIX标准中，所有路径组件的长度不能超过255个字节，总路径名的长度不能超过4096个字节\n\n<span class=\"strong\">pathchk [选项] 文件路径</span>\n\n+ 默认情况下，所指定的路径中有任一目录无搜索(x)权限，或文件名长度、文件路径总长度大于系统支持的最大值，命令将返回错误\n+ 默认情况下，所指定的文件名不存在不视为错误\n+ -p 满足以下任何条件，打印错误：\n>>+ 文件名为空\n>>+ 文件路径包含字母、数字以及._-/以外的字符(这几个是POSIX可移植文件名字符)\n>>+ 文件名长度、文件路径总长度大于POSIX的可移植性最低限制\n+ -P 如果文件名为空，或文件路径中的任一目录名或文件名以-开头，则报错\n\n#### realpath获取绝对路径与相对路径\nrealpath命令可以用来获取文件的绝对路径、文件之间的相对路径、符号链接所指向目标的真实路径等，通常用来在脚本中标准化路径，避免路径混淆，使脚本更具可移植性和可靠性\n\n<span class=\"strong\">realpath [选项] 文件1 文件2...</span>\n\n+ 默认情况下，命令会输出所给定文件的绝对路径，如果文件是一个符号链接，则输出其指向源文件的绝对路径\n+ -e 只解析存在的文件或目录路径，如果所指定的路径中任一文件或目录不存在，立即报错\n+ -m 如果所指定的路径中有文件或目录不存在，将其视为目录，并返回标准化路径，而不报错\n+ --relative-to=目录名DIR：输出realpath命令指定的文件1(文件2...)与目录DIR之间的相对路径\n+ --relative-base=目录名DIR：以该DIR路径作为解析时的基准起始点，如果文件1、文件2...在DIR路径下的子目录中，则输出相对路径，如果文件1、文件2...在DIR目录以外的位置，输出绝对路径\n+ -s 不解析符号链接\n+ -P (默认)解析路径中所有的符号链接，返回它们的真实路径(源文件的路径)，如：/home/user/link-to-dir/file中link-to-dir是一个符号链接，该选项会找出它所指向的源文件的路径，并替换到要输出的路径中\n+ -L 不解析父目录中的符号链接，路径中任何中间部分的符号链接将被保留，只有在最终文件或目录是符号链接时解析，如：/home/user/link-to-dir/file中link-to-dir是符号链接，由于它属于父目录，因此该链接文件不会被解析。如果最终目标文件file是符号链接时，则会解析file所指向源文件的路径\n+ -q 禁止显示错误信息\n+ -z 在每行输出末尾输出空字符(null)，而不是换行符，方便将输出交给其他程序解析\n\n<div class=\"show\">e.g.有以下文件结构\n/mydir\n├── index.html\n├── source\n│     └──css/index.css\n│     └──js/main.js\n└── public    \n      └──link_js --> /mydir/source/js\n      └── config.json\n假设当前位于/mydir路径下\n1. 输出指定文件的绝对路径，默认情况下，符号链接会解析为其源文件或目录\nrealpath index.html source/css/index.css public/link_js\n输出：\n/mydir/index.html\n/mydir/source/css/index.css\n/mydir/source/js  # 符号链接指向的目录\n2.输出config.json相对js目录的相对路径\nrealpath --relative-to=source/js public/config.json\n输出：\n../../public/config.json\n3.输出config.json与main.js文件的相对路径\nrealpath --relative-to=source/js/main.js public/config.json\n输出：\n../../../public/config.json\n<span class=\"text-red\">当计算相对路径的对象为文件时，通常会输出一个额外../(main.js到js目录，js到source目录，source到mydir目录，三个../)</span>\n3.以/mydir/source为基准(路径起点)，输出指定文件的路径\nrealpath --relative-base=source source/css/index.css index.html public/link_js public/config.json\n如果文件属于基路径的子目录下，输出相对路径，该基目录以外的文件，输出绝对路径\ncss/index.css\n/mydir/index.html\njs\n/mydir/public/config.json\n4. 同时使用--relative-to和--relative-base\n以/mydir/source为基准(路径起点)，输出其他文件相对于source/css目录的相对路径\nrealpath --relative-base=source --relative-to=source/css source/css/index.css index.html public/config.json public/link_js\n类似的，如果文件属于基路径的子目录下，输出相对于--relative-base的相对路径，该基目录以外的文件，输出绝对路径\nindex.css\n/mydir/index.html\n/mydir/public/config.json\n../js\n</div>\n\n\n### 文件校验\n##### sum计算文件占用的磁盘块数与校验和\nsum命令会为每个给定文件计算一个16位校验和(checksum)，以及文件占用的块大小，该命令是为了与旧Unix系统兼容而提供的，GNU更推荐使用cksum命令\n\n<span class=\"strong\">sum [选项] 文件</span>\n+ -r 使用BSD算法计算校验和，块大小为1024byte\n+ -s 使用systemV算法计算校验和，块大小为512byte\n\n##### cksum计算文件校验和\ncksum命令会为每个给定文件计算 32 位循环冗余校验(CRC)校验和，并输出文件字节数，可以用来验证文件在传输或复制过程中是否被损坏或修改\n\n<span class=\"strong\">cksum [选项] 文件名</span>\n\n+ 命令会默认输出文件的校验和、文件大小(字节数)、文件名三个信息\n+ 命令默认使用CRC-32 算法，生成32位校验和，输出时通常以十进制形式表示，通常输出10位\n+ 该命令主要用于检测随机性错误，安全性相较于md5sum、sha256sum 等哈希命令会较低\n+ -a '算法'：使用指定的摘要算法计算校验和，支持sysv,bsd,crc,md5,sha1,sha224,sha256,sha384,sha512,blake2b,sm3等\n+ -b 以二进制数据形式读取文件\n+ -c 文件名：从指定文件中读取校验和与文件名(可以包含路径)，并检查校验和与文件是否匹配，以下选项需要与-c选项搭配使用：\n>>+ -&zwnj;-ignore-missing 忽视缺失的文件，在大批量校验文件时，可能会有部分文件缺失，该选项用来禁止在文件缺失时报错\n>>+ -&zwnj;-quiet 静默模式，只输出校验失败的文件信息，默认情况下，校验成功和经验失败都会输出信息\n>>+ -&zwnj;-status 只在文件打开失败时输出错误信息\n>>+ -&zwnj;-strict 严格模式，任意一个文件校验失败，就立即打印错误信息并以非0状态码0退出命令，适合多文件处理时，所有文件都必须校验通过的场景\n\n##### md5/b2/sha1校验文件\n以下为cksum命令各选项的独立版本，他们拥有与cksum相似的选项和参数：\n\n<span class=\"strong\">md5sum [选项] [文件名]</span>打印或检查 MD5 摘要\n\n<span class=\"strong\">b2sum [选项] [文件名]</span>打印或检查 BLAKE2 摘要\n\n<span class=\"strong\">sha1sum [选项] [文件名]</span>打印或检查 SHA-1 摘要\n\n<span class=\"strong\">sha224/256/384/512sum [选项] [文件名]</span>打印或检查SHA-2摘要，可以选择几种(224、256、384、512)不同长度的校验和位数\n\n+ -t 以文本模式读取文件\n+ -c 文件名：从指定文件中读取校验和与文件名(可以包含路径)，并检查校验和与文件是否匹配，以下选项需要与-c选项搭配使用：\n>>+ -&zwnj;-ignore-missing 忽视缺失的文件，在大批量校验文件时，可能会有部分文件缺失，该选项用来禁止在文件缺失时报错\n>>+ -&zwnj;-quiet 静默模式，只输出校验失败的文件信息，默认情况下，校验成功和经验失败都会输出信息\n>>+ -&zwnj;-status 只在文件打开失败时输出错误信息\n>>+ -&zwnj;-strict 严格模式，任意一个文件校验失败，就立即打印错误信息并以非0状态码0退出命令，适合多文件处理时，所有文件都必须校验通过的场景\n\n<div class=\"show\">1. 生成校验和\ncksum test.txt  #命令用法大致相同\n会输出文件的校验和、文件大小、文件名，可以通过校验和与文件大小来判断文件是否被修改\n3647810268 85 test.txt\n2. 校验文件\n通常，文件的校验和信息会存储于一个专门的校验和文件中，如：checksums.md5文件中有以下内容\nd41d8cd98f00b204e9800998ecf8427e  /home/user/file1.txt\n098f6bcd4621d373cade4e832627b4f6  /home/user/file2.txt\n执行校验命令：\nmd5sum -c checksums.md5\n命令会逐行读取checksums.md5文件内容，然后根据内容前往文件相应路径下打开该文件并计算其校验和，再与checksums.md5文件所记录的校验和进行对比，最后逐行输出每个文件的校验结果\nfile1.txt: OK     #校验成功\nfile2.txt: FAILED #校验失败\n</div>\n\n\n### 文件查找\n#### find文件查找\n文件查找会占用大量的系统资源，尽量避免在系统使用高峰期使用文件查找命令，文件查找范围应该尽可能小。\n##### 1. 根据文件名查找\n<span class=\"strong\">find [查找路径] [参数] [文件名]</span>\n\n+ -name&emsp;根据文件名查找\n+ -iname&emsp;根据文件名查找(文件名不区分大小写)\n+ 搜索范围应尽可能小，尽量避免在根目录下搜索\n+ 只使用文件名为精确搜索，可以使用通配符(*匹配任意数量字符，一个?匹配一个字符)来模糊查找\n<div class=\"show\">示例:\n# find /etc -name init\n在/etc目录下查找init文件\n# find /etc -name *init*\n在/etc目录下查找所有文件名带init的文件\n# find /etc -name init???\n在/etc目录下查找所有文件名init开头，后面跟3个字符的文件\n</div>\n\n##### 2. 根据文件大小查找\n<span class=\"strong\">find [查找路径] [参数] [文件大小]</span>\n\n+ -size &emsp;根据文件大小查找\n+ 文件大小中，可以使用+表示大于，-表示小于，直接写数值表示等于\n<div class=\"show\">示例:\n# find / -size +100M\n查找服务器中大于100MB的文件\n</div>\n\n##### 3. 根据文件所有者、所属组查找\n<span class=\"strong\">find [查找路径] [参数] [用户名或组名]</span>\n\n+ -user &emsp;根据根据文件所属用户查找\n+ -group&emsp;根据文件所属组查找\n<div class=\"show\">示例:\n# find /home -user shw\n查找/home目录下属于shw用户的文件\n</div>\n\n##### 4. 根据时间属性查找\n<span class=\"strong\">find [查找路径] [参数] [时间]</span>\n\n+ -amin &emsp;根据根据文件访问时间\n+ -cmin &emsp;根据文件属性被修改时间\n+ -mmin &emsp;根据文件内容被修改时间\n+ 时间参数中，使用+表示超过该时间范围，-表示小于该时间内，直接写数值表示等于\n<div class=\"show\">示例:\n# find /etc -amin -5\n查找/etc目录下5分钟内被访问过的所有文件\n</div>\n\n##### 5. 根据文件类型查找\n<span class=\"strong\">find -type [文件类型]</span>\n\n+ f &emsp;文件\n+ d &emsp;目录\n+ l &emsp;链接文件\n<div class=\"show\">示例:\n# find /etc -type f\n查找/etc目录下的所有普通文件\n</div>\n\n##### 6. 多个条件同时查找\n如果需要查找同时满足多个条件的文件，可以添加下面的参数\n+ -a &emsp;两个条件同时满足\n+ -o &emsp;两个条件任意满足一个\n<div class=\"show\">示例:\n# find /etc -size +100MB -a -size -200MB\n查找大于100MB而小于200MB的文件\n</div>\n\n##### 7. 对找到文件的执行其他命令\n如果在找到文件后需要对其进行相应操作，可以添加下述命令\n+ -exec 命令 {}\\; &emsp;找到文件后直接执行命令\n+ -ok 命令 {}\\; &emsp;找到文件后会每个文件逐一询问是否执行命令\n<div class=\"show\">示例:\n# find /etc -name init* -a -type f -exec ls -l {} \\;\n找到/etc目录下所有init开头的文件并列出具体文件信息\n# find /home -size +100MB -a -user shw -ok rm {} \\;\n找到/home目录下属于shw用户且大于100MB的文件，然后依次询问是否删除找到的文件\n</div>\n\n##### 根据i节点查找\n<span class=\"strong\">find [查找路径] -inum i节点值</span>\n在知道某文件i节点值的情况下根据i节点查找，如：用于查找某个文件的硬链接(文件i节点值与文件硬链接i节点值相同)\n\n#### locate \nlocate为一个文件查找工具，可以从yum源安装\nfind命令为在指定目录下遍历查找，会占用大量系统资源，而且查找速度较慢，locate会建立文件资料库，然后在资料库中查找，反应速度快。\n<span class=\"strong\">locate [-i] 文件名</span>\n\n+ -i&emsp;不区分大小写\n+ locate会定期更新资料库，但实时新建的文件可能会找不到，可以在root下使用 updatedb 命令手动更新资料库\n+ locate 不会将/tmp等临时缓存文件收录到资料库中，因此临时文件使用locate找不到\n\n\n### 查看帮助 (manual)\n#### 1. 查看完整帮助man\n<span class=\"strong\">man [命令或配置文件]</span>\n\n+ 查看配置文件的帮助时，直接写文件名，不能加上文件路径，使用文件路径会直接显示文件内容而不是该配置文件的使用说明\n\nman命令返回的手册页一般包括以下信息，但不一定包括所有节，信息通过分页程序显示，分页程序可以通过<span class=\"tips\">PageUp</span>和<span class=\"tips\">PageDown或空格</span>上下翻页，也可以通过上下方向键逐行滚动，或者使用<span class=\"tips\">回车键</span>逐行向下查看，查看完毕后可以通过<span class=\"tips\">q</span>键退出\n\n<div class=\"table\">\n\n节|内容\n--|------\nName |显示命令名和一段简短的描述\nSynopsis |命令的语法\nConfi guration |命令配置信息\nDescription |命令的一般性描述\nOptions| 命令选项描述\nExit Status |命令的退出状态指示\nReturn Value |命令的返回值\nErrors |命令的错误消息\nEnvironment| 描述所使用的环境变量\nFiles |命令用到的文件\nVersions |命令的版本信息\nConforming To |命名所遵从的标准\nNotes |其他有帮助的资料\nBugs |提供提交bug的途径\nExample |展示命令的用法\nAuthors |命令开发人员的信息\nCopyright |命令源代码的版权状况\nSee Also |与该命令类型的其他命令\n</div>\n\n对于命令，man 有多个不同类型的帮助文档，并使用数字区分这些区域(通常为1-9)，可以使用 <span class=\"tips\">whereis 命令</span>查看该命令在man目录下有几种类型，如果有多个类型，可以使用<span class=\"tips\">man [值] [命令]</span>来查看对应帮助。如：1为通常为解释该命令如何使用，5通常为命令对应的说明文档如何阅读。即：使用<span class=\"tips\">man 命令</span>和<span class=\"tips\">man 1 命令</span>为查看命令的帮助，<span class=\"tips\">man 5 命令</span>为查看命令说明文档的帮助(具体区域号视命令而定)，以下为不同类型内容所包含的内容\n\n<div class=\"table\">\n\n区域号|所含内容\n------|--------\n1|用户命令和可执行程序的帮助手册\n2|系统调用和内核函数的帮助手册 \n3|C库函数的帮助手册 \n4|设备文件和特殊文件的帮助手册\n5|配置文件的格式和约定的帮助手册\n6|游戏的帮助手册 \n7|杂项（如宏包、约定等）的帮助手册 \n8|系统管理员手册和管理命令的帮助手册\n9|内核例程的帮助手册\n</div>\n\n#### 2. 查看简短帮助 \n+ <span class=\"strong\">what 命令</span>&emsp;只显示命令帮助文档中NAME部分的内容\n+ <span class=\"strong\">apropos 配置文件</span>&emsp;简短查看配置文件作用\n\n#### 3. 查看命令的选项\n只查看命令的可选参数选项，不需要查看命令完整帮助信息\n<p><span class=\"strong\">命令 --help</span></p>\n\n#### 4. 查看shell内置命令\n有些命令是bash(shell)内置命令而不是Linux的命令，使用上述命令查看不到帮助，可以使用\n<p><span class=\"strong\">help 命令</span></p>","tags":["Linux","File"]},{"title":"Linux文件系统","url":"/blog/2021/12/29/Linux文件系统/","content":"### 文件与目录管理\n#### 常见的文件类型\n1. <span class=\"tips\"><strong>普通文件：</strong></span>最为常见的文件类型，包括纯文本文件(ASCII)，二进制文件(binary)，数据文件(data)等\n2. <span class=\"tips\"><strong>目录：</strong></span>即文件夹，用于包含更多目录和文件\n3. <span class=\"tips\"><strong>块设备文件：</strong></span>将硬盘、光盘等存储设备以文件形式供用户操作\n4. <span class=\"tips\"><strong>字符设备文件：</strong></span>将串行端口的接口设备，如键盘、鼠标等以文件形式供用户操作\n5. <span class=\"tips\"><strong>套接字文件：</strong></span>又称为数据接口文件，用于网络数据连接\n6. <span class=\"tips\"><strong>管道文件：</strong></span>用于解决多个程序同时存取一个文件所造成的错误\n7. <span class=\"tips\"><strong>链接文件：</strong></span>分为硬链接和软链接，类似于快捷方式\n\n#### Linux目录\n##### 指令集\n+ <strong>/bin</strong> &emsp; Binaries的缩写，存放普通用户可使用的系统命令,如:ls\n+ <strong>/sbin</strong>&emsp;Super user Binary的缩写，存放只有系统管理员才能使用的系统命令，如:shutdown、reboot\n+ <strong>/usr/bin</strong>&emsp;存放安装软件后，普通用户可以使用的软件命令，如:c++、make、wget等\n+ <strong>/usr/sbin</strong>&emsp;存放系统管理员用户安装使用的高级管理程序和系统服务程序，如:httpd、netconfig、tcpd等\n\n\n##### 系统文件\n+ <strong>/etc</strong>&emsp;Etcetera(其他)的缩写，这个目录用来存放所有系统管理所需要的<strong>配置文件</strong>和子目录\n+ <strong>/var</strong>&emsp;存放一些经常被修改、扩充的文件，如各种日志文件\n+ /boot&emsp;存放引导启动Linux时使用的核心文件,如镜像文件等\n+ /sys&emsp; Linux2.6内核新增的文件系统sysfs，sysfs文件系统集成了3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统\n+ /lib&emsp;存放系统所需要的动态链接库(如C++库)，相当于windows的dll文件\n+ /dev&emsp;Device的缩写, 将Linux主机的硬件以文件形式存储并提供访问，相当于Windows的设备管理器\n+ /usr/src&emsp;内核源代码、说明文档等默认放置目录\n+ /opt&emsp;默认为空，常用于安装额外软件\n+ /proc&emsp;Processes(进程)的缩写，虚拟的目录，用于管理内存空间，是系统内存的映射，我们可以直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里\n+ /selinux&emsp;全称为security-enhanced linux，该目录是 Redhat/CentOS 所特有的目录，是Redhat/CentOS的安全子系统\n+ /srv&emsp;service缩写，存放一些服务启动后需要提取的数据\n\n\n##### 用户\n+ <strong>/root</strong>&emsp;系统管理员的账号主目录\n+ <strong>/home</strong>&emsp;存放普通用户的相关文件，Linux会在home目录下为每一个用户生成一个以用户账号命名的目录\n+ <strong>/usr</strong>&emsp;Unix Software Resource(共享资源)的缩写,放置用户的应用程序和文件，类似于windows下的program files目录\n+ <strong>/usr/local</strong>&emsp;软件安装目录，一般通过源码编译安装方式安装的软件都会存放于该目录下\n+ /usr/include&emsp;放置如c/c++等程序语言的头文件(header)与包含档(include)\n+ /usr/lib&emsp;放置各应用软件的函式库、目标文件等，如果使用的是X86_64的Linux系统，则可能会生成/usr/lib64文件夹\n\n##### 外部文件\n+ <strong>/media</strong>&emsp;挂载U盘、光驱等设备的目录，类似于windows的其他设备\n+ /mnt&emsp;让用户挂载其他的文件系统，如将Windows上的某个目录挂载在/mnt下，可用于共享文件等\n\n#### 临时文件\n+ /lost+found&emsp;一般情况下为空目录，用于存放系统非法关机或者发生意外错误后，fsck(磁盘修复)过程修复的部分文件\n+ /tmp&emsp;用于存放临时文件\n+ /run&emsp;一个临时文件系统，存放存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。\n\n\n### 文件系统\n#### 简介\n与Windows不同，Linux在路径中不使用驱动器盘符。Windows将物理磁盘驱动器分为盘符(如C盘、D盘)，每个盘都会有自己的目录结构，并通过诸如<span class=\"tips\">C:\\Users\\ Administrator \\Documents</span>等方式访问文件。\n\nLinux则采用了一种不同的方式，Linux内核采用虚拟文件系统（Virtual File System，VFS），内核将所有安装在PC上的存储设备的文件纳入单个目录结构中，这个目录被称为虚拟目录（virtual directory）。Linux虚拟目录结构只包含一个称为根（root）目录的基础目录。根目录下的目录和文件会按照访问它们的目录路径一一列出，并使用<span class=\"tips\">正斜线 /</span>(windows使用反斜线\\\\)来做路径划分。\n\nLinux文件系统结构是从Unix文件结构演进过来的，并遵守文件系统层级标准（filesystem hierarchy standard，FHS），它确定了Linux系统中每个目录的用途和应该包含的内容，并保证不同Linux发行版之间的文件布局是一致的\n\nLinux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统外，Linux还支持从其他操作系统（比如Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持。以下为Linux系统用来读写数据的标准文件系统\n\n<div class=\"table\">\n\n文件系统|说明\n-------|----------\next| Linux扩展文件系统，最早的Linux文件系统\next2 |第二代扩展文件系统，在ext的基础上提供了更多的功能\next3 |第三代扩展文件系统，支持日志功能\next4 |第四代扩展文件系统(Fourth Extended File System)，支持高级日志功能，目前Linux主流的文件系统\ntmpfs|一种临时文件系统，常见于类Unix操作系统，使用内存(RAM)作为文件存储区，适合需要高速读写和不需要持久存储的数据情况\ndevtmpfs|临时设备文件系统，常见于类Unix操作系统，该文件系统会在内存中创建一个区域，用于管理/dev目录下的设备文件，方便动态管理硬盘、网络接口、终端等物理设备，可以简化设备管理，提高系统启动速度\nFAT16|用于微软的ms-dos操作系统，Windows最初是作为MS-DOS的一个图形用户界面(GUI)扩展而开发的，但随着技术的进步，Windows操作系统逐渐发展成一个独立的操作系统，从Windows NT 4.0 开始，Windows不再依赖于MS-DOS\nVFAT |FAT32的扩展版本，在FAT32的基础上加入了长文件名支持功能，名称上实际仍称为FAT32。FAT32是windows98等旧版本windows的主要文件系统，现在广泛用于相机SD卡、U盘等，最大支持的单个文件大小为4GB，最大分区大小为2TB\nNTFS |全称为New Technology File System，目前windows主要使用的高级文件系统，广泛用于windows7、10，支持数据加密，文件权限控制，日志记录与恢复等功能，最大支持的单个文件大小为16TB(取决于分区大小)，分区大小可达到256TB或更高\nhpfs |OS/2高性能文件系统\njfs |IBM日志文件系统\niso9660 |标准CD-ROM文件系统，主要用于CD\nminix |MINIX文件系统\nncp |Netware文件系统\nnfs |网络文件系统\nproc |访问系统信息\nReiserFS |高级Linux文件系统，能提供更好的性能和硬盘恢复功能\nsmb |支持网络访问的Samba SMB文件系统\nsysv| 较早期的Unix文件系统\nufs |BSD文件系统\numsdos |建立在msdos上的类Unix文件系统\nXFS |高性能64位日志文件系统\n</div>\n\n#### 文件系统的架构\nLinux 文件系统采用了层次化的设计，通常分为以下几层：\n+ 虚拟文件系统（Virtual File System，VFS）：虚拟文件系统是操作系统内核的一部分，它为不同类型的文件系统提供了统一的接口，屏蔽了底层文件系统的差异性，使Linux能够同时挂载各种文件系统\n+ 实际文件系统（File System Implementation Layer）：该层实现了具体的文件系统，如 ext4、XFS、Btrfs、FAT32 等，每种文件系统都有其独特的数据结构和实现方式，但它们都通过 VFS 提供一致的接口，向上层应用程序隐藏具体细节\n+ 存储设备层（Storage Device Layer）：该层包括实际的存储设备（如 HDD、SSD、USB 闪存盘等）及其驱动程序，管理设备的物理 I/O 操作。文件系统将逻辑数据映射到这些物理设备上，通过块设备接口（如 /dev/sda）来访问硬盘的块（block）数据\n\n<div class=\"shell\">简单预览：\n+--------------------+\n|    应用程序层      |  <---- 用户通过命令或程序操作文件\n+--------------------+\n|    系统调用层      |  <---- 系统调用（如 `open`、`read`、`write`）\n+--------------------+\n|   虚拟文件系统 (VFS)|\n+--------------------+\n|   实际文件系统层   |  <---- ext4, XFS, Btrfs, FAT32, NFS 等\n+--------------------+\n|   存储设备层      |  <---- 硬盘、SSD、USB 驱动器\n+--------------------+\n</div>\n\nLinux文件系统都有以下几个重要组成部分：\n+ 超级块（Superblock）：超级块包含了文件系统的元数据，比如文件系统的大小、块大小、inode 数量、已用和可用的 inode 及数据块等信息。超级块是文件系统的控制信息，通常被加载到内存中，用于文件系统的管理和访问。\n+ 索引节点（Inode）：Inode是每个文件或目录的描述符，每个文件都有唯一的inode标识符，在文件系统中，文件通过inode号来唯一标识，inode包含文件的元数据，如：\n>>+ 文件类型（普通文件、目录、符号链接等）\n>>+ 文件大小\n>>+ 所有者（用户 ID 和组 ID）\n>>+ 访问权限（读、写、执行）\n>>+ 时间戳（创建时间、修改时间、访问时间）\n>>+ 指向数据块的指针\n+ 数据块（Data Block）：数据块是文件的实际内容存储区域。每个数据块大小通常为4KB，文件系统通过 inode 中的指针（direct 和 indirect pointers）来定位文件的数据块\n+ 目录（Directory）：目录是一种特殊类型的文件，它包含了其他文件或子目录的列表。每个目录项包含文件名和对应的inode号。当用户查找一个文件时，系统会先根据目录文件中的inode号找到对应的 inode，再通过inode中的指针找到数据块。\n+ 日志（Journaling）：大多数现代Linux文件系统（如 ext3、ext4、XFS）都使用日志机制来提高数据可靠性。日志记录文件系统中所有的元数据变化操作，确保在系统崩溃或突然断电时，可以通过重播日志恢复文件系统的完整性。\n\n#### 文件系统的工作\n+ 文件查找： 当用户要访问某个文件时（如 /home/user/file.txt），系统会按照以下步骤进行查找：\n>>1. 从根目录 / 开始，找到 home 目录的 inode。\n>>2. 根据 home 目录 inode 中的数据块指针，找到 user 目录的 inode。\n>>3. 最终找到 file.txt 的 inode，然后通过该 inode 访问文件的数据块。\n+ 文件读操作： 当文件被读取时（例如使用 cat 命令），系统会：\n>>1. 根据目录结构找到文件的 inode。\n>>2. 读取 inode 中指向的数据块指针。\n>>3. 从数据块中读取文件内容，并将其返回给用户。\n+ 文件写操作： 当文件被修改或创建时（例如使用 echo 命令），系统会：\n>>1. 为新文件分配一个 inode，设置文件的元数据（所有者、权限等）。\n>>2. 分配新的数据块，并写入文件内容。\n>>3. 更新 inode 中的指针，使其指向新的数据块。\n>>4. 更新文件系统的超级块信息（例如可用 inode 和数据块数量）。\n+ 元数据更新和日志记录：为了防止数据丢失，文件系统通常会先将元数据更新写入到日志区域中，然后再进行实际操作。这种机制被称为 “Write Ahead Logging”。在日志写入成功后，再进行实际的文件写操作，确保在系统故障时能够快速恢复文件系统。\n\n#### 文件的信息\n##### 时间信息\n在 Linux 系统中，文件的时间戳主要包括以下三种类型：\n+ <span class=\"strong\">访问时间(Access Time，atime)</span>：文件上次被读取的时间，使用cat、less、head等命令读取文件内容，或通过bash script.sh执行脚本文件，都会更新atime。但认情况下，为了提升性能，大多数 Linux 文件系统（如 ext4）会使用relatime挂载选项，这意味着只有在 atime 比 mtime 或 ctime 旧时，atime 才会更新。因此，某些文件访问操作不会立即反映到atime中\n+ <span class=\"strong\">修改时间(Modification Time，mtime)</span>：文件内容上次被修改的时间，通过echo、vim、nano和重定向符修改文件内容都会更新mtime\n+ <span class=\"strong\">更改时间(Change Time，ctime)</span>：文件的元数据(如权限、所有者、文件名等文件属性)上次被更改的时间，通过chmod、chown、chattr修改文件属性，使用mv命令移动、重命名文件都会更新ctime，使用vim，nano修改文件时，编辑器可能会创建临时文件，并使用新文件覆盖原文件，也会更新ctime\n+ <span class=\"strong\">创建时间(Birth Time或Creation Time，btime)</span>：表示文件首次被创建时的时间，这是一个教新引入的时间戳，因此，一些传统的文件系统不支持该时间戳，一些新的文件系统(如 ext4)也默认不保存创建时间，需要特定文件系统(如 btrfs)或内核版本支持才可以查看\n\n#### df查看文件系统空间使用情况\nGNU提示：df命令仅安装在拥有挂载表的系统上，因此跨平台可移植脚本不应该依赖该命令\n\n<span class=\"strong\">df [参数] [挂载点]</span>\n\n+ 默认情况下，命令会输出所有当前已挂载文件系统的信息\n+ -a &emsp;显示所有文件系统信息，包括特殊文件系统，这些文件系统通常无法直接访问，因此默认不显示\n+ -h &emsp;将磁盘大小单位换算为KB、MB等单位，以1024作为基数进行换算\n+ -H &emsp;等价于-&zwnj;-si选项，换算单位为K、M等单位，以1000作为基数进行换算\n+ -m &emsp;以MB为单位显示容量\n+ -k &emsp;以KB为单位显示容量，默认值\n+ -T &emsp;显示文件系统类型\n+ -i &emsp;列出 inode 使用情况信息，而不是块使用情况\n+ -l &emsp;只列出本地文件系统，默认情况下还会列出远程文件系统\n+ -&zwnj;-output=项目：只列出指定项目，指定多个项目可以用逗号分隔(如-&zwnj;-output=source,target)，接收的参数有：source(挂载来源，通常是设备)、target(挂载点)、fstype(文件系统类型)、itotal(inode总数)、iused(已用inode数量)、iavail(可用inode数量)、ipcent(iused除以 itotal的百分比)、size(块总数)、used(已使用的块数)、avail(可用的块数)、pcent(used除以size)、file(文件名，需要在命令行指定)\n+ -t 文件系统：只显示某个文件系统的信息，可以指定多个-t选项\n\n<div class=\"show\">df命令会输出以下信息：\n1.设备的设备文件位置(挂载源)\n2.能容纳多少个1024字节大小的块\n3.已用了多少个1024字节大小的块\n4.还有多少个1024字节大小的块可用\n5.已用空间所占的比例\n6.设备挂载到了哪个挂载点上(挂载点)\n如：\nFilesystem     1K-blocks    Used Available Use% Mounted on\ndevtmpfs          234280       0    234280   0% /dev\ntmpfs             246136       0    246136   0% /dev/shm\ntmpfs             246136   29192    216944  12% /run\ntmpfs             246136       0    246136   0% /sys/fs/cgroup\n/dev/vda1        9778432 3429132   5808684  38% /\ntmpfs              49228       0     49228   0% /run/user/0\n</div>\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\ndf命令会统计包括一些磁盘碎片在内的空间，而该类空间是被程序占用后释放的碎片空间，需要Linux整理后才能使用，因此df命令统计结果也往往比du命令统计结果大，但更能正确反映系统可用的空间大小</div>\n\n#### du显示目录或文件大小\n通过df命令发现磁盘空间快满时，可以通过du命令查看是哪些文件占用了较大的存储空间\n\n<span class=\"strong\">du [参数] [目录或文件名]...</span>\n\n+ 默认情况下，命令会显示当前目录以及每个子目录的磁盘使用情况，该行为会递归进行，即会打印子目录的后代子目录信息，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间\n+ -a 打印每个子目录以及子文件的大小\n+ -h 将文件大小单位换算为K、M等单位\n+ -k 以K为单位打印占用空间\n+ -m 以M为单位打印占用空间\n+ -c 在处理完所有文件后，打印总计\n+ -s 只统计总大小，不列出子目录和文件\n+ -d 值depth：只从当前目录向下统计depth层(文件的层次结构)，当前目录为第0层\n+ -&zwnj;-inodes 列出inode的使用情况，而不是块使用情况\n+ -L 显示链接指向的文件或目录的所占用空间大小，而不是链接文件本身\n+ -t 值：如果给定的值为正数，则只打印大于等于该值的目录或文件信息，如果值为负数，则只打印小于等于该值的目录或文件，这里的值可以使用kB、k、KiB等单位\n+ -&zwnj;-time：打印文件或目录的上一次内容修改时间mtime\n+ -&zwnj;-time=ctime：打印文件或目录上一次属性修改时间ctime\n+ -&zwnj;-time=atime：打印文件或目录上一次访问时间atime\n+ -&zwnj;-exclude=正则pattern：递归统计时，跳过与pattern匹配的子目录或文件，如du -&zwnj;-exclude='*.o' 排除以.o结尾的文件\n+ -X 文件名：从该文件中获取需要排除的文件或目录，每一行表示一个或一类文件，可以使用正则表达式，如果文件名为-，表示从标准输入获取\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\nls命令只统计目录下一级子文件和子目录文件信息大小，而不统计子目录下属文件大小，du命令更能准确统计出子文件、子目录和子目录所含文件的数据大小</div>\n\n#### 文件系统修复\n<span class=\"strong\">fsck [参数] 分区设备名</span>\n\n+ -a &emsp;不显示用户提示，自动修复文件系统\n+ -y &emsp;功能同-a，部分文件系统仅支持-y\n\n#### 文件系统挂载与卸载\nLinux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前(如载入U盘等)，需要把它放到虚拟目录下，这个步骤称为挂载(mounting)\n##### 查询挂载信息\n<span class=\"strong\">mount</span>显示已经挂载的设备\n+ -l显示卷标\n\n<div class=\"show\">mount命令提供如下四部分信息：\n1.媒体的设备文件名\n2.媒体挂载到虚拟目录的挂载点\n3.文件系统类型\n4.已挂载媒体的访问状态\n如：/dev/vda1 on / type ext4 (rw,relatime,data=ordered)\n/dev/vda1为设备文件名，该设备挂载在根目录下 /，文件系统为ext4，其余为该设备的访问状态\n</div>\n\n##### 自动挂载\n在桌面版Linux中，默认会自动挂载设备，也可以通过命令完成自动挂载，自动挂载会根据文件<span class=\"tips\">/etc/fstab</span>中指定的文件系统完成挂载\n\n<span class=\"strong\">mount -a</span>根据配置文件 /etc/fstab 自动挂载\n+ -a 挂载所有未挂载的文件系统\n+ -aF 会同时挂载所有文件系统\n+ -aO 可以在/etc/fstab中为某个文件系统指定特定的挂载选项，并应用这些选项\n\n##### 手动挂载\n<span class=\"strong\">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span>\n\n+ -t 文件系统：挂载指定文件系统，如 ext4、iso9660\n+ -L 卷标名：自定义卷标的名字\n+ -f 模拟挂载设备，但并不真的挂载\n+ -s 忽略该文件系统不支持的挂载选项\n+ -r 将设备挂载为只读的\n+ -w 将设备挂载为可读写的（默认参数）\n+ -v 详细模式，详细说明挂在设备的每一步\n+ -n 挂载设备，但不注册到/etc/mtab已挂载设备文件中\n+ -s 忽略该文件系统不支持的挂载选项\n+ -o 特殊选项：指定挂载的额外选项，以下是几个常用的选项：\n\n<div class=\"table\">\n\n参数|说明\n----|-----\nro|以只读方式挂载，\nrw|以可读写方式挂载\nuser/nouser|是否允许普通用户挂载文件系统，默认为不允许\ncheck=none|挂载文件系统时不进行完整性校验\nloop|挂载一个文件\natime/noatime|访问分区文件时是否更新文件访问时间\nexec/noexec|是否允许文件系统中的可执行程序可以运行，默认为exec允许\nremount|重挂载已经挂载的文件系统，一般用于修改特殊权限后重挂载\n</div>\n\n<div class=\"show\">示例：\n# mount -o remount,noexec /home/\n禁止 /home/分区中的所有可执行程序执行，包括root用户\n</div>\n\n##### 硬件设备文件名\n通过文件名可以判断该设备文件对应的设备，以下说常用的设备文件名\n\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>硬件</th>\n<th>设备文件名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IDE硬盘</td>\n<td>/dev/hd[a-d]</td>\n</tr>\n<tr>\n<td>SCSI/SATA/USB硬盘</td>\n<td>/dev/sd[a-p]</td>\n</tr>\n<tr>\n<td>光驱</td>\n<td>/dev/cdrom 或 /dev/sr0</td>\n</tr>\n<tr>\n<td>软盘</td>\n<td>/dev/fd[0-1]</td>\n</tr>\n<tr>\n<td>打印机(25针)</td>\n<td>/dev/lp[0-2]</td>\n</tr>\n<tr>\n<td>打印机(USB)</td>\n<td>/dev/usb/lp[0-15]</td>\n</tr>\n<tr>\n<td>鼠标</td>\n<td>/dev/mouse</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n##### 挂载光盘\n为方便文件查找，一般将光盘挂载于根目录下的 /media  ，U盘挂载于/mnt目录下，iso9660为光盘默认文件系统，因此-t iso9660 可以省略\n\n<span class=\"strong\">mount -t iso9660 /dev/cdrom /media</span>\n\n\n##### 挂载U盘\n1. <span class=\"strong\">fdisk -l</span>查看U盘设备文件名\n\n2. <span class=\"strong\">mount -t &emsp;文件系统 &emsp;/dev/U盘设备文件名 &emsp;/mnt</span>\n\nlinux默认不支持NTFS文件系统(大部分移动硬盘设备使用NTFS文件系统)，但可以通过插件提供支持\n\n\n##### 卸载设备\n注意，如果有任何程序正在使用设备上的文件，系统就不允许卸载，而是会提示 device is busy，注意命令不是un开头，没有n\n<span class=\"strong\">umount 设备文件名或挂载点目录名</span>卸载设备\n\n如果在卸载设备时，系统提示设备繁忙，无法卸载设备，通常是有进程还在访问该设备或使用该设备上的文件。这时可用lsof命令获得使用它的进程信息，然后在应用中停止使用该设备或停止该进程。如：lsof /path/to/device/node，或者lsof /path/to/mount/point\n\n### 压缩与解压缩\n#### 文件的压缩与解压(.gz格式)\n<span class=\"tips\">.gz</span>是GNU gzip软件的压缩格式，与windows不同，下述命令只能压缩与解压缩文件，不能处理文件夹，并且压缩完只保留压缩文件，不保留原文件\n+ <span class=\"strong\">gzip 文件名</span>&emsp;压缩(GUN zip)\n+ <span class=\"strong\">gunzip 文件名</span>&emsp;解压缩(GUN unzip)\n+ <span class=\"strong\">gzcat 文件名</span>&emsp;原来查看压缩过的文本文件内容\n\n<div class=\"show\">e.g.可以在命令中指定多个文件名，或使用通配符一次压缩多个文件，每个文件单独生成一个.gz压缩文件\n$ gzip my* #压缩所有my开头的文件</div>\n\n#### 文件的打包、压缩与解压(.tar.gz格式)\n##### 打包与压缩\ntar命令用于文件的归档打包，它将指定的文件或目录以指定的方式进行组织和存储，包括文件的权限、所有者、时间戳等信息，并打包成一个单独的文件，打包后的文件格式一般为<span class=\"tips\">.tar</span>，打包后的文件可以用<span class=\"strong\">gzip</span>命令压缩，生成<span class=\"tips\">.tar.gz(或.tgz)</span>格式的压缩包文件，<span class=\"strong\">tar</span>命令也支持直接将文件重定向给<span class=\"strong\">gzip</span>命令，一次性完成打包、压缩操作，打包压缩后的文件名可以不写.tar.gz等后缀，但不方便用户识别\n\n<span class=\"strong\">tar [参数] [打包后文件名] [打包文件/目录]</span> 打包文件或目录\n\n+ <span class=\"strong\">-c(-&zwnj;-create)</span> &emsp;打包为一个新的归档文件 \n+ <span class=\"strong\">-z</span> &emsp;将输出重定向给gzip命令，即打包后压缩(需要和-c等参数一起使用)\n+ -r(-&zwnj;-append) &emsp;追加文件到已有tar归档文件末尾\n+ -A(-&zwnj;-concatenate) &emsp;将一个已有tar归档文件追加到另一个已有tar归档文件\n+ -d(-&zwnj;-diff) &emsp;检查该文件和其在归档文件中的不同之处，如果被修改则标记为changed，被删除标记为deleted，该文件未被打包到归档文件中则标记为added\n+ -&zwnj;-delete &emsp;从已有tar归档文件中删除\n+ -u(-&zwnj;-update) 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中\n+ -p 保留所有文件权限\n+ -v &emsp;显示详细信息\n+ -t(-&zwnj;-list) 列出已有tar归档文件的内容\n+ -f &emsp;指定文件名(该参数必须)\n\n<div class=\"show\">示例:\n# tar -cvf test1.tar test1\n打包test1文件夹中文件为test1.tar文件，并显示详细信息\n# tar -zcf test.tar.gz test1\n打包并压缩test1文件夹为test.tar.gz\n</div>\n\n##### 解压\n<span class=\"strong\">tar [参数] [解压缩的文件]</span>\n\n+ -x &emsp;解包，提取文件\n+ -v &emsp;显示详细信息\n+ -f &emsp;指定解压缩的文件(该参数必须)\n+ -z &emsp;解包后解压缩(需要和x参数一起使用)\n<p>最常用的是解压一个.tar.gz文件，因此大多数情况下-zxf为必用参数</p>\n<div class=\"show\">示例:\n# tar -zxvf test.tar.gz \n解压缩test.tar.gz文件，并显示详细信息\n</div>\n\n#### .zip格式的压缩与解压\n<span class=\"strong\">zip [选项] [-r] [压缩后文件名] [压缩文件或目录]</span>\n\n- -r&emsp;压缩目录\n<p>.zip格式为Linux和windows通用格式，zip命令会保留原文件，并且一个命令就可以处理文件与文件夹</p>\n\n<span class=\"strong\">unzip [解压的文件名]</span>\n<p>解压文件</p>\n\n#### .bz2、.tar.bz2格式的压缩与解压\n##### 1. 压缩\n###### 对文件(格式为.bz2)\n<span class=\"strong\">bzip2 [参数] [-k][文件]</span>\n\n+ -k &emsp;压缩后保留原文件\n\n###### 对文件夹(格式为.tar.bz2)\n<p><span class=\"strong\">tar -jcf [压缩后文件名] [压缩目录]</span></p>\n<p>即将tar中的z参数改为j参数就是压缩为.tar.bz2格式</p>\n\n##### 2. 解压\n###### 对文件(格式为.bz2)\n<span class=\"strong\">bunzip2 [-k] [解压文件]</span>\n\n+ -k &emsp;解压缩后保留原文件\n\n###### 对文件夹(格式为.tar.bz2)\n<p><span class=\"strong\">tar -jxf [解压文件]</span></p>\n<p>同样将tar中的z参数改为j参数就是解压.tar.bz2格式</p>","tags":["Linux","File"]},{"title":"Linux 系统与设置","url":"/blog/2021/12/29/Linux系统与设置/","content":"### 介绍\n#### 简介\n<div class=\"contentFolded\">\n20世纪60年代，计算机技术还处于起步阶段，此时的计算机不仅体积庞大，而且造价不菲，通常情况下，一台计算机只能被单一用户独占使用。随着计算机技术的发展，人们开始设想一种能够同时服务多个用户的计算系统。\n\n1964年，美国国防部委托麻省理工学院 (MIT)、贝尔实验室 (Bell Labs) 和通用电气 (GE) 开发了一种名为 Multics (Multiplexed Information and Computing Service) 的\"多路复用信息与计算服务\"系统。该项目旨在研发一个革命性的多用户操作系统，并首次提出了分时操作、虚拟内存、模块化内核设计、层级文件系统以及用户权限控制等创新技术，这些技术后来影响了几乎所有后续操作系统的设计理念。然而，Multics 项目的目标过于宏大，系统架构极其复杂，导致研发过程困难重重，进度缓慢。\n\n随着 Multics 项目的推进，贝尔实验室的研究人员开始意识到该系统过于复杂，且维护成本高昂，最终决定退出 Multics 项目。曾参与 Multics 项目的肯·汤普森 (Ken Thompson)、丹尼斯·里奇 (Dennis Ritchie) 等人决定在一个规模较小的新项目中重新开发一个操作系统。1969 年，汤普森和里奇在缺乏完整文档支持的情况下，凭借出色的编程技巧和对计算机科学的热爱，成功开发出了 Unix 系统。该操作系统最初使用汇编语言和 B 语言编写，并迅速在贝尔实验室内部流行起来。1972 年，贝尔实验室的丹尼斯·里奇基于 B 语言设计了 C 语言，C 语言不仅保留了 BCPL 和 B 语言的优点，还克服了它们无数据类型等缺点，简练且接近硬件。1973 年，汤普森和里奇使用 C 语言重写了 UNIX 第四版操作系统，极大提升了其可移植性。加上 Unix 系统简洁、模块化的设计，使其迅速在学术界和工业界广泛传播。\n\n在 Unix 的早期发展阶段，贝尔实验室的母公司 AT&T 以低廉甚至免费的许可将 Unix 源码授权给学术机构用于研究和教学。许多机构在此基础上对源码进行了扩充和改进，形成了各种“Unix 变种”，其中最著名的是由加州大学伯克利分校开发的 BSD Unix。BSD Unix 在 Unix 的历史发展中具有重大影响力，被许多商业厂商采用，并成为众多商用 Unix 系统的基础。进入 1990 年代，Unix 和类 Unix 系统越来越受欢迎，并成为全球 90% 最快的 500 台超级计算机的首选操作系统。2000年，苹果公司发布了Darwin系统，这也是一个 Unix 系统，并成为 Mac OS X 操作系统的核心，后来更名为 macOS。\n\n随着 Unix 的广泛应用和影响力不断扩大，AT&T公司逐渐意识到了 Unix 的商业价值，开始停止向学术机构授权Unix源码，并对之前的 Unix 及其变种声明了版权。这引发了一系列版权争议和诉讼，其中包括与加州大学伯克利分校之间关于 BSD Unix的版权纠纷。AT&T公司的这种行为引起了许多开发者和用户的不满，1983年，麻省理工学院人工智能实验室的计算机科学家Richard Stallman公布了一项计划，该计划旨在发展出一套完整的开放源代码操作系统来替换Unix，他给该计划起名为GNU(GNU's Not Unix)，以此讽刺GNU不会像unix一样成为一个垄断的专有技术。Richard Stallman认为，软件应当像科学知识一样，能够被自由地分享、修改和传播。为了实现这个宏伟的目标，Stallman 于1985年成立了自由软件基金会 (FSF)，为GNU计划提供技术、法律以及财政支持。1989年，Stallman起草了 GNU 通用公共许可证(GPL)，这是一种确保软件和其衍生作品永远保持自由的法律工具。在GNU计划下，许多重要的工具和软件组件被开发出来，比如GNU编译器（GCC）、GNU Emacs编辑器、GNU C库（glibc）等。然而，尽管这些组件逐渐完善，GNU计划仍缺少一个关键的部分：内核。\n\nUnix的限制使用也为当时操作系统的学习和教学带来了许多困难。1987年，阿姆斯特丹自由大学的教授Andrew S. Tanenbaum为了方便教学，借鉴Unix的设计模式开发出了Minix操作系统，这是一个专为教学设计的类Unix操作系统，主要是作为计算机专业学生的学习工具。命运的齿轮开始转动，1991年，一位名为Linus Torvalds的芬兰学生在大学里学习操作系统课程，并接触到了Minix。他对操作系统的原理产生了浓厚的兴趣，但发现Minix有些局限性。于是，Linus决定自己编写一个类似Unix的操作系统。1991年9月，Linus发布了他的第一个操作系统内核，并邀请其他程序员测试和改进，Linux最初的版本仅有几千行代码，但随着世界各地开发者的加入，Linux 逐渐成为了一个功能强大的、开源的操作系统内核。开源社区的蓬勃发展成为了连接Linux内核和GNU组件的纽带，社区的开发者们发现，GNU社区拥有功能强大的工具，但缺少一个内核，Linux内核不正是GNU计划所缺少的一环。这些开发者将 Linux 内核与 GNU 项目提供的系统组件整合在一起，形成了一个完整的操作系统环境——GNU/Linux。\n</div>\n\n#### 常见的发行版\n<div class=\"contentFolded\">\n\n+ <span class=\"strong\">Debian</span>：一个完全由社区驱动的Linux发行版，由全球的开发者协作开发，以较长的稳定支持和保守的软件更新策略著称。Debian支持x86、arm、mips、ppc等多种架构，使用APT和dpkg作为软件包管理工具，提供大量开源免费的软件包，是许多其他发行版(如 Ubuntu)的基础\n+ <span class=\"strong\">Ubuntu</span>：一款基于Debian的桌面发行版，由Canonical公司开发并提供技术支持。Ubuntu本身开源免费，且拥有庞大的自由软件社区支持，此外Canonical公司也提供付费的商业支持\n+ <span class=\"strong\">RHEL</span>：全称“Red Hat Enterprise Linux”，是Red Hat公司专门为企业设计的商业版Linux\n+ <span class=\"strong\">Fedora</span>：一款由Fedora项目社区开发维护的开源自由的操作系统，提供桌面版、服务器版、物联网专用等版本，该社区由 Red Hat公司赞助，因此也通常被用作测试RHEL新功能的实验平台\n+ <span class=\"strong\">CentOS</span>：一个开源免费的Linux发行版，基于Red Hat公司的RHEL源代码构建，但去除了RHEL的品牌标识和付费的专有软件，并交由CentOS社区提供支持。但从2020年底开始，CentOS项目开始以CentOS Stream作为主要开发分支，而CentOS Stream本身更多是为 RHEL 提供测试和创新平台，因此不再适合作为生产环境的操作系统使用，其最后一个稳定版本CentOS 8也于2021年底失去了官方支持\n+ <span class=\"strong\">Arch Linux</span>：一个由社区驱动开源高度可定制的操作系统，以其简洁、轻量和高度可定制而著称。Arch Linux只提供最小化的基础系统，默认不会安装多余的软件，用户需要自行手动分区、配置网络、安装引导程序、选择安装和配置软件，因此Arch Linux更适合有一定Linux经验的高级用户和开发者使用。Arch Linux默认使用pacman作为软件包管理器\n+ <span class=\"strong\">open SUSE</span>：由德国的SuSE Linux AG公司发行维护的开源免费的Linux发行版，提供openSUSE Leap和openSUSE Tumbleweed两个版本。openSUSE Leap是基于 SUSE Linux Enterprise(SLE)的稳定版本，适合生产环境和需要高稳定性的用户。openSUSE Tumbleweed是滚动发布的版本，适合喜欢尝试新技术的用户。此外，SUSE公司还提供企业版的付费系统——SUSE Linux Enterprise(SLE)。由于openSUSE 提供了一流的桌面体验，因此桌面版openSUSE也十分流行，openSUSE 默认使用 Btrfs 文件系统和Zypper 作为其包管理器\n+ <span class=\"strong\">Kali Linux</span>：一款基于Debian的Linux发行版，由Offensive Security公司开发和维护。Kali Linux使用了一个定制的Linux内核，支持更多的无线设备并内置了数百种安全工具，涵盖渗透测试的各个领域，包括信息收集、漏洞分析、无线攻击、网络渗透、密码破解、数字取证和逆向工程等，是一个专门为信息安全专业人员设计的用于渗透测试和网络安全评估的操作系统\n</div>\n\n### Linux命令\n#### Linux命令格式\n许多主流Linux系统默认使用的Shell(终端程序)是Bash(GNU Bourne-Again Shell)解释器，可以通过<span class=\"tips\">上下方向键</span>来调取之前执行过的Linux命令，可以使用<span class=\"tips\">Tab键</span>来补全命令、参数或文件名。常见的Linux命令的格式为：\n<span class=\"strong\">命令  [选项] [参数]</span>\n\n+ 有多个短选项时，可以写在一起，如：ls -alhF\n+ 选项可以用长格式(完整的选项名)并使用\"-&zwnj;-\"作为前缀，也可以用短格式（单个字母的缩写）使用\"-\"作为前缀。如：<span class=\"tips\">-&zwnj;-help</span>和<span class=\"tips\"> -h</span>，但有时短格式与长格式表示的不是同一个参数，如：shutdown -&zwnj;-help会显示shutdown命令的帮助信息，shutdown -h则为系统关机命令，-h表示为halt而非help\n+ Linux命令使用<span class=\"strong\">-&zwnj;-</span>作为选项和参数的分隔符，-&zwnj;-除了作为长选项的前导符，它在单独使用时也是选项和参数的分隔符，命令行中-&zwnj;-后的参数将作为命令的操作数而不是命令选项，即便之后的参数带着-或-&zwnj;-\n+ 在很多shell中，如果命令在一行内写不下，可以使用延续字符<span class=\"strong\">\\</span>在下一行中继续输入命令(该字符由shell定义，不是Linux系统本身提供的)\n\n\n<div class=\"show\">e.g.用tar命令创建一个压缩档案\ntar --create --file=archive.tar -- --exclude=*.tmp /path/to/directory\n该命令中\n--create和--file是命令选项\n--exclude是命令参数\n</div>\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n命令、参数与命令对象字母严格区分大小写</div>\n\n#### 命令类型\nLinux中使用的命令主要分为以下几种类型：\n\n+ <span class=\"strong\">shell内建命令：</span>由shell程序提供，这些命令已经和shell编译成了一体，在执行时速度更快，消耗的资源更少。常见的内建命令有<span class=\"tips\">cd、echo、pwd、history、alias、continue、exit、jobs、kill</span>等\n\n+ <span class=\"strong\">可执行文件命令：</span>由软件包提供，这些命令是系统中的可执行文件，通常位于/bin、/sbin、/usr/bin、/usr/sbin目录下，每次执行这些命令时，系统都会启动一个新的进程来运行对应的程序。常见的软件包有：\n>>+  coreutils(GNU Core Utilities)包：由GNU社区开发和维护，是 Linux 系统中的最基础的工具包，提供了大量常用的可执行文件命令，如：<span class=\"tips\">ls、cp、mv、rm、cat、echo、chmod、chown、date、df、du、ln、mkdir、touch、uname 等</span>\n>>+ util-linux包：由Linux内核社区负责开发和维护，提供一些常见的系统管理命令，如：<span class=\"tips\">mount、kill、date、su、getopt、more等</span>\n>>+ inetutils包：由GNU社区维护，提供了基本的网络工具，如：<span class=\"tips\">ping、hostname、ftp、telnet等</span>\n>>+ net-tools包：托管于GitHub，由其团队维护，提供了提供了基础的网络配置和监控工具，如：<span class=\"tips\">ifconfig、netstat、route、arp等</span>\n>>+ findutils包：由GNU社区维护，提供一些文件查找和操作工具，如<span class=\"tips\">find、locate、xargs等</span>\n>>+ procps包：托管于GitHub，由其社区维护，提供系统进程和资源管理工具，如：<span class=\"tips\">ps、top、vmstat、killall、free等</span>\n>>+ shadow-utils包：托管于GitHub，由其团队维护，提供用户和密码管理工具，如：<span class=\"tips\">useradd、passwd、chage等</span>\n>>+ 独立的软件包：一些大型功能是独立的软件包提供的，由其独立的社区或团队开发或维护，如：<span class=\"tips\">vim(vim社区)、sed(GNU社区)、awk(GNU社区)、grep(GNU社区)、sudo(sudo社区)、yum(Red Hat 社区)、systemd(Red Hat社区)、wget(GNU社区)、curl(curl社区)</span>\n\n+ <span class=\"strong\">脚本命令：</span>通常由用户的shell脚本，python脚本来提供，Linux系统也提供了一些服务管理脚本，如/etc/init.d目录下的脚本\n\n###### 查找命令来源\n查找命令来源通常可以使用以下几种方法：\n+ 使用<span class=\"tips\">type</span>命令：type命令是shell内建命令，它可以用来查询某个命令是来源于shell内部，还是来源于外部的二进制文件，type命令用法参考shell内建命令\n+ 使用<span class=\"tips\">-&zwnj;-version</span>选项：该选项用来查看命令的版本号，通常也会同时返回命令所属包的版本号\n+ 使用<span class=\"tips\">dpkg</span>或<span class=\"tips\">yum</span>包管理器查询\n\n<div class=\"show\">1. 可以使用type -a命令来查看一个命令是shell内建命令，还是可执行文件命令。有的命令可能会提供两个版本，如：echo命令，shell提供了一个内建的版本，也有一个可执行文件版本，此时，shell会优先执行内建的版本\ntype -a echo\necho is a shell builtin\necho is /usr/bin/echo\n2.可以使用-&zwnj;-version查看该命令来源哪个包，以及该包的版本号\nps -&zwnj;-version\n输出：ps from procps-ng 4.0.4  #来自procps-ng包\n3.对于可执行文件命令，可以通过以下方法查看该命令来源于哪个软件包\n在 Debian/Ubuntu 系列系统中：\ndpkg -S $(which cat)\n返回值如：coreutils: /usr/bin/cat\n在 Red Hat/Fedora 系列系统中：\nrpm -qf $(which cat)\n返回值如：coreutils-8.22-24.el7_9.2.x86_64\n</div>\n\n###### 查找命令路径\n\n+ <span class=\"strong\">which 命令</span>&emsp;查找命令所在路径，同时可以查看命令的别名\n+ <span class=\"strong\">whereis 命令</span>&emsp;查找命令所在路径，同时可以查看命令帮助文档所在路径\n\n<div class=\"show\">示例:\n# which rm\nLinux返回:\nalias rm='rm -i' \n\t/usr/bin/rm\n查看rm命令所在路径，rm -i为rm命令全写\n#whereis rm\nLinux返回:\nrm: /usr/bin/rm /usr/share/man/man1/rm.1.gz\n返回信息为rm命令所在路径和rm命令帮助文档所在路径\n</div>\n\n#### 退出状态码\n绝大多数命令命令在执行完毕或执行失败时都会返回一个退出状态码(exit status)，通常情况下，退出状态码为<span class=\"strong\">0</span>表示命令成功执行，执行失败则会返回一个<span class=\"strong\">非零</span>值，这个状态码可以在命令退出后使用<span class=\"strong\">$?</span>查看，注意，$?永远只会保留上一个命令退出时的状态码\n\n#### coreutils包命令的通用选项\n##### 文件的备份\n<span class=\"tips\">mv</span>、<span class=\"tips\">cp</span>、<span class=\"tips\">install</span>、<span class=\"tips\">ln</span>等命令将旧文件移动、复制、重命名到新位置时，该位置可能已经有了一个同名的文件，这些命令通常会直接覆盖该文件，这可能造成数据丢失，因此这些命令提供了一些通用的备份选项：\n\n+ -b 如果有同名文件，则为该同名文件进行备份，该选项等价于-&zwnj;-backup=existing\n+ -&zwnj;-backup=值 该选项是-b选项的完整名称，但-b选项不接受参数，该选项接受参数，参数值可以为：\n>>+ none或off 不进行备份(默认)\n>>+ numbered或t 备份为编号形式，备份后文件名为：file.txt\\~1\\~(第一次备份)、file.txt\\~2\\~ (第二次备份)，该选项适用于希望保留所有历史版本备份的情况\n>>+ existing或nil 如果检测到文件备份已经存在且格式为编号形式(如：file.txt.\\~1\\~)，则继续使用编号形式创建新的备份(新的备份文件将命名为file.txt.\\~2\\~)；如果没有编号备份，则使用simple选项的备份方式\n>>+ simple或never 进行简单备份，备份文件名为：file.txt\\~，由于该选项每次生成的备份文件名都为file.txt\\~，因此它只会保留最后一次备份的文件\n+ -S \"字符串\"：指定备份文件的文件名后缀，如果未指定此选项，则使用SIMPLE_BACKUP_SUFFIX环境变量的值。如果未设置 SIMPLE_BACKUP_SUFFIX，则默认值使用~作为后缀名\n\n##### 存储单位规范\n1kB表示 1 kilobyte，即 1 kB = 1000 Bytes\n\n1KiB表示 1 kibibyte，即 1 KiB = 1024 Bytes，POSIX标准也使用k(或K)来表示KiB，因此有以下等式：\n<div class=\"show\">1kB=1000 Bytes\n1K=1KiB=1024 Bytes\n</div>\n\n其余单位<span class=\"tips\">M</span>、<span class=\"tips\">G</span>、<span class=\"tips\">T</span>、<span class=\"tips\">P</span>、<span class=\"tips\">E</span>、<span class=\"tips\">Z</span>、<span class=\"tips\">Y</span>、<span class=\"tips\">R</span>、<span class=\"tips\">Q</span>以此推算\n\n##### 禁止高危操作\n<span class=\"tips\">rm</span>、<span class=\"tips\">chgrp</span>、<span class=\"tips\">chmod</span>、<span class=\"tips\">chown</span>等命令通常会拒绝对根目录<span class=\"tips\">/</span>的操作，这是因为这些命令通常默认启用<span class=\"tips\">-&zwnj;-preserve-root</span>选项\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n如果确实要对根目录进行操作，可以为命令添加-&zwnj;-no-preserve-root选项，但这是高危操作</div>\n\n### 系统启动与关闭\n#### 系统运行级别\nLinux系统的开机过程流程为：加载BIOS，进入Boot Loader，加载系统内核，进行内核初始化，启动初始化进程init。\n\n可以使用<span class=\"tips\">init 运行级别</span>在系统运行级别之间切换，使用<span class=\"tips\">runlevel</span>查询当前运行级别。\n<div class=\"table\">\n\n运行级别(runlevel) | 说明\n-------|------\n0|系统关机，禁止设置为系统默认运行级别\n1|单用户状态，只启动系统核心，用于系统修复和维护\n2|多用户状态，禁用NFS(网络文件系统)和网络服务，可用于停机维护\n3|完全多用户状态，具有完整的功能\n4|系统未使用，保留\n5|GUI模式，桌面版Linux专属\n6|系统重启，禁止设置为系统默认运行级别\nemergency|用于系统救援\n</div>\n\n在路径<span class=\"tips\">/etc/rc.d</span>下存放有7个对应系统运行级别的目录<span class=\"tips\">/rc0.d——rc6.d</span>，目录中列出了该运行级别下会启动/关闭的服务，init.d目录下存放有用户可以开机启动的脚本，对于以K(Kill)开头的文件，系统会关闭对应的服务，以S(Start)开头的文件，系统将启动对应的服务，并且启动/关闭次序为S/K之后的值。<span class=\"tips\">rc.local</span>文件用于配置用户开机执行的命令，系统在启动后将自动执行该文件中的所有命令。\n\n在一些旧版本的Linux中，/etc/rc.d路径下还含有<span class=\"tips\">/etc/inittab</span>文件，文件中可以设置系统默认运行级别。centos7之后的系统将不再支持该方式修改默认级别，而使用target替代了sysvinit的运行级。\n<div class=\"table\">\n\nSys v init runlevel | systemd target\n-------|------\n0|poweroff.target\n1|rescue.target\n2|multi-user.target\n3|multi-user.target\t\n4|multi-user.target\n5|graphical.target\n6|reboot.target\nemergency|emergency.target\n</div>\n<div class=\"show\">系统默认以启动runlevel3启动\n# systemctl set-default multi-user.target\n系统默认以启动runlevel5启动\n# systemctl set-default graphical.target\n查看当前运行级别\n# systemctl get-default\n</div>\n\n#### Linux的关闭与重启\n##### 1. sync 保存数据\n<span class=\"strong\">sync</span>&emsp;将内存数据存储到磁盘，<span class=\"tips\">关机或重启Linux前应当执行该命令防止数据丢失</span>\n\n<span class=\"strong\">sync [选项] [文件名]</span>\n\n+ 如果不指定任何参数和选项，命令会将所有挂载文件系统中内存缓冲区的数据同步到磁盘\n+ -d 只同步该文件数据，而不刷新文件的元数据(例如文件权限、所有者、时间戳等)\n+ -f 将包含该文件的整个文件系统同步到磁盘，而不仅仅是该文件的数据部分\n\n##### 2.shutdown 命令(推荐使用)\nshutdown命令用于关闭/重启Linux，命令格式为\n<p> <span class=\"strong\">   shutdown [选项] [时间] [警告消息]</span></p>\n常用选项\n<ul>\n<li><span class=\"strong\">-t 值</span>&emsp;设置在几秒后关机</li>\n<li><span class=\"strong\">-h</span>&emsp;关机</li>\n<li><span class=\"strong\">-r</span>&emsp;重启</li>\n<li><span class=\"strong\">-c</span>&emsp;取消已经设置的关机/重启命令</li>\n<li>- m&emsp;强制杀死所有执行中的程序,然后关机(不调用init进程)</li>\n<li>-k &emsp;不关机，仅把警告讯息传送给所有登录的用户</li>\n<li>-f &emsp;强制略过fsck磁盘检测(unbuntu独有参数)</li>\n<li>-F &emsp;强制进行fsck磁盘检测(unbuntu独有参数)</li>\n<li>-w &emsp;测试使用，系统不会重启，但会把重新开机的数据写入/var/log目录下的wtmp记录文件</li>\n<li>-H 或 --halt&emsp;&emsp;&emsp;相当于halt</li>\n<li>-P 或 --poweroff&emsp;相当于poweroff</li>\n<li>--no-wall &emsp;&emsp;&emsp;&emsp;系统在重启、关闭时不发送信息给登录的用户</li>\n</ul>\n<div class=\"show\">示例：\n# shutdown -t 30        30s后关机\n# shutdown -h now       马上关机\n# shutdown -h 12:30     12:30关机，会占用终端\n# shutdown -h 12:30 &   12:30关机，关机命令会在后台处理不占用终端\n# shutdown -h 10 \"System will shutdown after 10 minutes\"    10分钟后关机并发送消息给用户\n# shutdown -r +10       10分钟后重启\n# shutdown -fr now      马上重启并强制略过fsck磁盘检测\n# shutdown -c           取消已设置的关机/重启命令\n</div>\n\n##### 3.halt 关机\n<span class=\"strong\">halt [选项]</span>\n\n可选选项\n+ -d &emsp;不把关机记录写到 /var/log/wtmp 文件里\n+ -n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)\n+ -w &emsp;不会真的关机,只是把关机记录写到 /var/log/wtmp 文件里\n+ -f &emsp;强制关机，不调用shutdown命令\n+ -i &emsp;关机前关闭所有网络接口\n+ -p &emsp;关机后关闭电源(poweroff)\n\n##### 4.reboot 重启\n<span class=\"strong\">reboot [选项]</span>\n\n可选选项\n+ -d &emsp;不把重启记录写到 /var/log/wtmp 文件里\n+ -n &emsp;重启前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)\n+ -w &emsp;不会真的重启,只是把重启记录写到 /var/log/wtmp 文件里\n+ -f &emsp;强制重启，不调用shutdown命令\n+ -i &emsp;重启前关闭所有网络接口\n\n##### 5.poweroff 关机并切断电源\n<span class=\"strong\">poweroff [选项]</span>\n\n可选选项\n+ -d &emsp;不把关机记录写到 /var/log/wtmp 文件里\n+ -n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)\n+ -w &emsp;不会真的关机,只是把关闭记录写到 /var/log/wtmp 文件里\n+ -f &emsp;强制关闭\n+ -i &emsp;关机前关闭所有网络接口\n+ -h &emsp;关机前将系统中所有的硬件设置为备用模式\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n除了上述命令，还可以通过设置系统运行级别进行关机、重启。使用 <span class=\"tips\">init 0 </span>关机，使用<span class=\"tips\">init 6 </span>重启。\n</div>\n\n### 系统设置\n#### arch查看系统架构\n<span class=\"strong\">arch </span>查看系统架构\n\n64位Linux通常为<span class=\"tips\">x86_64</span>架构，32位Linux通常为<span class=\"tips\">i686</span>，在某些系统上，arch 命令可能是 uname -m 的别名\n\n#### uname查看系统信息\n<span class=\"strong\">uname [选项]</span>\n\n+ -a 查看系统所有信息，输出的信息依次为：内核名(-s)、主机名(-n)、内核版本(-r)、内核发行日期(-v)、硬件架构名(-m)、处理器信息(-p)、硬件平台名称(-i)、操作系统名称(-o)\n+ -i 查看硬件平台名称，如：x86_64、PC等，某些系统可能还返回硬件平台类型，如：generic(常规硬件平台)、PC(PC硬件)\n+ -p 查看处理器信息，如：x86_64、Intel、AMD等，某些系统还可能返回CPU的厂商信息、处理器家族等\n+ -m 查看系统硬件架构，如：x86_64、i686、arm64等\n+ -n 查看主机在当前网络中的主机名，如：VM-0-4-ubuntu\n+ -s 查看系统内核名称，通常是Linux\n+ -o 查看操作系统名称，如：GNU/Linux\n+ -r 查看系统内核版本号，如：6.8.0-40-generic\n+ -v 查看系统内核的发行编号、发行时间等，如：#40-Ubuntu SMP PREEMPT_DYNAMIC Fri Jul  5 10:34:03 UTC 2024\n\n\n#### dmesg查看开机时检测的系统内核信息\n<span class=\"strong\">dmesg</span>\n\n会输出非常详细的CPU(如型号、主频、核心数....)、网卡、硬盘等主机开机检测的信息，一般通过管道符只查看某部分具体信息，如: dmesg | grep CPU 查看CPU详细信息\n\n#### 查看CPU信息\n开机检测后，检测到的信息会按格式写于<span class=\"tips\">/proc/cpuinfo</span>文件中，通过该文件查看CPU信息更为清晰\n\n#### nproc查看可用处理器的数量\n<span class=\"strong\">nproc [选项]</span>\n+ 默认打印可用的处理器数量\n+ -&zwnj;-all 打印系统上所有已安装的处理器数量，部分处理器可能已安装但不可用\n\n#### 查看当前Linux操作系统的发行版本\n使用cat命令查看 <span class=\"tips\">/etc/system-release</span>或 <span class=\"tips\">/etc/os-release</span>文件即可，redHat系列操作系统可以查看<span class=\"tips\">/etc/redhat-release(红帽专属)</span>文件\n\n#### hostname查看或设置系统名称\n<span class=\"strong\">hostname [系统名]</span>\n+ 默认情况下打印当前系统名，通常可能为uname -n的输出值\n+ 可以指定一个字符串，将当前主机系统名称修改为指定名字，这需要适当权限\n\n#### hostid查看主机的数字标识\n<span class=\"strong\">hostid</span>\n\n以十六进制形式打印当前主机的数字标识，此命令不接受任何参数\n\n#### arp查看与修改arp缓存\nARP 缓存保存着 IP 地址与对应的物理 MAC 地址之间的映射关系，用于网络通信时将 IP 地址解析为 MAC 地址\n\n<span class=\"strong\">arp [选项] </span>\n+ -a 查看系统中所有缓存的 IP 地址和 MAC 地址的映射\n+ -s IP地址 MAC地址：添加一个IP地址到MAC地址的映射到 ARP 表\n+ -d IP地址：从 ARP 表中删除指定的 IP 地址条目\n+ -i 接口：如果系统有多个网络接口，指定接口\n\n<div class=\"show\">1. 通过arp -a查看所有缓存的 IP 地址和 MAC 地址的映射\ngateway (172.168.63.253) at ee:ff:ff:ff:ff:ff [ether] on eth0\nIP地址：172.168.63.253\nMAC地址：ee:ff:ff:ff:ff:ff\n2. 手动添加arp条目\nsudo arp -s 192.168.1.100 00:1A:2B:3C:4D:5E\n3. 删除 ARP 条目\nsudo arp -d 192.168.1.100\n4. 指定接口，只显示 eth0 接口上的 ARP 缓存\narp -i eth0 -a\n</div>\n\n#### uptime查看系统已运行时间和负载\n<span class=\"strong\">uptime</span>\n\n打印系统当前时间、系统的正常运行时间、登录用户数和系统在过去 1 分钟、5 分钟和 15 分钟内的平均负载，这些信息也是<span class=\"tips\">top</span>命令的首行输出信息\n\n#### last 查看用户登录系统时间与系统重启时间\n<span class=\"strong\">last </span>\n列出目前与过去所有登入过系统的用户信息，并列出了系统何时重启过\n<p><span class=\"strong\">lastlog </span></p>\n列出用户上次登录系统的时间(包括系统用户)\n<p><span class=\"strong\">lastlog -u UID</span></p>\n仅列出指定用户上次登录系统的时间\n\n\n### tty终端设备\ntty这一名称源自早期的电传打字机(Teletypewriter)，它是一种用于与计算机交互的硬件设备。现代的tty通常指的是终端设备的抽象，这些设备可以是物理终端、虚拟终端或串口设备。这些设备直接与输入(如键盘)和输出(如显示器)相关联，为用户提供与计算机交互的输入输出接口。当用户从键盘输入命令时，输入由TTY设备接收，然后交由shell执行，shell执行完毕后，同样将先命令执行结果输出给TTY设备，再由TTY设备发送到显示器。\n\ntty设备挂载路径通常位于<span class=\"tips\">/dev</span>目录下，如/dev/tty1，/dev/tty2... 代表不同的虚拟控制台。用户可以通过 Ctrl + Alt + F1 到 Ctrl + Alt + F7 以切换不同的虚拟终端\n\n<span class=\"tips\">/dev/pts/</span>目录下的设备文件表示伪终端(pseudo-terminal)，如：/dev/pts/0，通常用于SSH、图形终端模拟器等。在使用 Xshell 等终端模拟器远程连接Linux时，远程服务器会为本次会话分配一个伪终端(如：/dev/pts/0)，SSH服务会将终端模拟器映射到所分配的伪终端上，然后交由用户进行后续操作。\n\n#### tty查看终端设备的文件名\n\n<span class=\"strong\">tty [选项]</span>\n\n+ 查看连接到standard input的终端的文件名\n+ -s 检查当前终端是否连接到一个有效的终端设备，不打印任何内容，返回exit状态码，0表示当前为标准输入(stdin)是一个终端，1表示当前输入不是一个终端(可能被重定向，或者通过管道输入)，2表示命令中使用了无效参数，3表示写入错误\n\n#### stty修改终端设置\n##### 1.查看当前stty终端设置\n\n<span class=\"strong\">stty [选项]</span>\n\n+ -a 查看当前终端所有设置和状态，包括终端的波特率，终端窗口每页支持的最大行数和最大列数，快捷键、各项输入输出设置的值\n+ -F 终端设备文件：查看指定终端的设置，而不是当前终端的设置\n+ -g (-&zwnj;-save) 输出保存当前设置\n\n<div class=\"show\">1. 查看当前终端的设置\nstty -a\n输出：\nspeed 38400 baud; rows 29; columns 71; line = 0;\nintr = ^C; quit = ^\\   ......\n上述信息表示当前终端的波特率为38400(每秒传输38400个码元)，当前终端窗口单个页面最多输出29行，每行最多输出71个字符，line=0 表示终端使用的是默认的线路控制模式(N_TTY 模式)，中断字符为ctrl+c，退出字符设置为 Ctrl+\\\n2.输出保存当前的设置，方便后续恢复或复用\n-a选项是以方便人类阅读的形式输出终端设置，-g选项是以方便被tty设备识别的形式输出信息\nsettings=$(stty -g) #保存当前设置\n..... #进行某些操作\nstty \"$settings\"  #恢复设置\n</div>\n\n##### 2.修改stty终端设置\n这些设置只在本次会话有效\n\n<span class=\"strong\">stty [选项] [设置值]</span>\n\n+ -F 终端设备文件：修改指定终端的设置，而不是当前终端的设置\n+ 如果终端异常，可以通过<span class=\"tips\">stty sane</span>来恢复默认的终端设置\n+ 以下设置值支持在前面添加<span class=\"tips\">-</span>来关闭该设置\n\n<div class=\"table\">\n\n值  |说明   \n----|------------------\necho|开启回显；-echo会禁用回显，输入字符不显示，常用于密码输入\ncread|允许接受输入；-cread会禁用输入，这会导致tty终端无法接收任何键盘输入，如果是虚拟终端，可以关闭当前会话重置设置，如果是物理终端，执行前请确认其他方式能够访问该终端\nignbrk|忽略换行符\ninlcr|将换行符替换为回车\nigncr|忽略回车\niutf8|假设输入字符采用 UTF-8 编码\niuclc|将输入的大写字符转换为小写\nolcuc|将输出的小写字符转换为大写\nflusho|丢弃输出\n</div>\n\n<div class=\"show\">1. 控制回显\nstty -echo #所有输入字符不显示，但输出或正常显示\nstty echo #显示输入的字符\n2. 禁用输入\nstty -cread \n<span class=\"text-red\">这会导致TTY设备不接受任何后续输入，因此也无法通过命令来恢复该设置！</span>\n如果是远程虚拟终端，可以关闭此次会话，Linux会回收分配给当前SSH服务的设备文件，在下次会话时分配一个新的，此时可以正常输入命令\n</div>\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n如果不想每次会话都修改设置，可以将stty命令写入.bashrc文件中，使终端设置在下次启动shell时自行生效。<span class=\"text-red\">请不要将stty -cread写入.bashrc文件！！！</span></div>\n\n##### 3.修改stty快捷键\n可以通过<span class=\"strong\">stty 控制字符 快捷键</span>命令更改命令快捷键\n\n<div class=\"table\">\n\n控制字符|\t说明|\t命令示例\n--------|--------|------------\nintr|\t中断字符，通常是 Ctrl+C\t|stty intr ^C\nquit|\t退出字符，通常是 Ctrl+\\\t|stty quit ^\\\nerase|\t删除字符，通常是 Backspace\t|stty erase ^H\nkill|\t行删除字符，通常是 Ctrl+U\t|stty kill ^U\neof\t|文件结束字符，通常是 Ctrl+D\t|stty eof ^D\nsusp|\t暂停字符，通常是 Ctrl+Z\t|stty susp ^Z\nstart|\t启动字符，通常是 Ctrl+Q\t|stty start ^Q\nstop|\t停止字符，通常是 Ctrl+S\t|stty stop ^S\nlnext|\t直接发送字符，通常是 Ctrl+V\t|stty lnext ^V\nwerase|\t单词删除字符\t|stty werase ^W\n</div>\n\n\n### locale区域设置\nlocale用于定义系统的区域设置，修改系统语言、日期与时间显示格式、字符串排序顺序、货币表示格式、地址(国家、城市、街道等)表示格式、度量衡单位(如使用公制还是英制单位)、名字格式(先名还是先姓)等系统设置，方便系统能够根据用户所处地区和语言习惯对以上信息进行调整\n\n#### locale命令\n<span class=\"strong\">locale [区域环境变量名]</span>\n\n+ 默认情况下，该命令会输出系统当前所有区域相关的环境变量和值\n+ 指定一个环境变量用于输出该变量的值\n+ -a 列出系统当前支持的所有语言区域\n+ -m 列出系统当前支持的所有字符编码映射，如：ANSI_X3.4-1968(ASCII字符集)、UTF-8(最常用Unicode字符集)\n+ -c 在指定了区域环境变量时，用于在输出前打印该区域环境变量名\n+ -k 在指定了区域环境变量时，用于显示所指定区域环境变量生效的内容和这些内容的关键字\n\n<div class=\"show\">1. 只执行locale命令，该命令会打印当前区域相关的环境变量和值\nlocale\n输出值：\nLANG=en_US.UTF-8\nLC_CTYPE=\"en_US.UTF-8\"\nLC_NUMERIC=\"en_US.UTF-8\"\n......\n2.locale命令可以跟随一个区域环境变量参数，用来打印该变量在当前设置下的支持的输出内容，如：LC_TIME用于定义日期输出格式，当LC_TIME的值为\"en_US.UTF-8\"(该值一般继承自LANG变量)时，打印其支持的输出内容\nlocale LC_TIME\n命令会输出LC_TIME生效的内容：\nSun;Mon;Tue;Wed;Thu;Fri;Sat\nSunday;Monday;Tuesday;Wednesday;Thursday;Friday;Saturday\nJan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec\n......\n此时将LANG的值设置为\"zh_CN.UTF-8\"(LC_TIME也将继承为\"zh_CN.UTF-8\")\nLANG=\"zh_CN.UTF-8\"\nlocale -ck LC_TIME\n相应的日期输出内容也将变为：\nLC_TIME\nabday=\"日;一;二;三;四;五;六\"\nday=\"星期日;星期一;星期二;星期三;星期四;星期五;星期六\"\nabmon=\"1月;2月;3月;4月;5月;6月;7月;8月;9月;10月;11月;12月\"\nmon=\"一月;二月;三月;四月;五月;六月;七月;八月;九月;十月;十一月;十二月\"\nam_pm=\"上午;下午\"\nd_t_fmt=\"%Y年%m月%d日 %A %H时%M分%S秒\"\nd_fmt=\"%Y年%m月%d日\"\nt_fmt=\"%H时%M分%S秒\"\nt_fmt_ampm=\"%p %I时%M分%S秒\"\n.......\n3. 在打印区域环境变量的生效内容时，通常搭配使用-c和-k选项，用来查看这些内容的关键字\nlocale -ck LC_TIME\n输出值：\nLC_TIME     # -c选项会在打印信息前标识这些信息是哪一个区域环境变量的信息\nabday=\"Sun;Mon;Tue;Wed;Thu;Fri;Sat\"   #-k选项会打印这些值的关键字，该行为日期支持的星期缩写\nday=\"Sunday;Monday;Tuesday;Wednesday;Thursday;Friday;Saturday\"  #日期支持的星期全写\nabmon=\"Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec\"\nmon=\"January;February;March;April;May;June;July;August;September;October;November;December\"\nam_pm=\"AM;PM\"\n.....\n</div>\n\n\n#### 常见的Locale变量\nLocale变量曾经是C语言中定义的宏，后来被继承到了Linux中。以下变量中，LANG变量的值可以被其他变量继承，因此一般情况下，Linux中的以下变量很多都没有为其设置一个单独的值，而是让其从LANG变量继承，因此很多变量并使用echo语句是获取不到变量值的，只能使用locale命令隐式地获取到。如果这些变量被指定了一个值，那么这个值会覆盖从LANG变量继承而来的值。以下各变量的优先级：<span class=\"tips\">LC_ALL&gt;LC_*&gt;LANG</span>\n\n<div class=\"table\">\n\n变量名|说明\n------|-------\nLANG|指定系统的默认语言和区域设置，如果其他变量没有设置值时，则使用该值作为默认值，它的值优先级也是最低的\nLC_ALL|用来覆盖所有其他LC_*变量，强制使用特定的locale设置，该变量值优先级最高，但一般为空\nLC_CTYPE|定义字符处理，如字符分类和字符转换\nLC_NUMERIC|定义数字表示方式（小数点、千位分隔符等）\nLC_TIME|定义日期和时间格式\nLC_COLLATE|定义字符串的比较和排序规则\nLC_MONETARY|定义货币符号和格式\nLC_MESSAGES|定义系统消息的语言和格式，如输出系统提示信息、错误信息所使用的语言\nLC_PAPER|定义默认纸张大小尺寸，在打印时有用\nLC_NAME|定义姓名的书写格式\nLC_ADDRESS|定义地址书写格式\nLC_TELEPHONE|定义电话号码书写格式\nLC_MEASUREMENT|定义度量衡表达方式\nLC_IDENTIFICATION|对locale自身信息的概述\n</div>\n\nlocale变量的值一般由三部分组成，修正值极少用，书写规则为：\n\n<span class=\"strong\">语言[_地区][.字符集编码][@修正值]</span>\n+ 语言使用两个小写字母表示，如：en(英语)、zh(中文)、fr(法语)、de(德语)\n+ 地区为可选项，由两个大写字母表示，如：CN(中国)、US(美国)、GB(英国)、FR(法国)\n+ 字符集编码为可选项，常见的有：UTF-8(多语言字符编码)、GB2312(国标简体中文编码)、ISO-8859-1(西欧常用的一种字符编码)\n+ 修正值为可选项，用来进一步指定某些特殊变体，如：@latin表示使用拉丁字母的变体\n\n<div class=\"show\">1.同一种语言，不同地区有不同用语习惯，因此会有不同组合值\nzh_CN.UTF-8  #中国大陆的简体中文UTF-8字符集\nzh_HK.UTF-8  #香港地区的繁体中文UTF-8字符集\nzh_SG.UTF-8  #新加坡的简体中文UTF-8字符集\nzh_CN.GB18030  #中国大陆的简体中文国标GB2312字符集\n可以使用<span class=\"tips\">locale -a</span>命令查看系统当前支持的区域值\n2. 修改区域往往修改LANG变量的值即可\nLANG=zh_CN.utf8  #UTF-8或utf8写法通常都可以\n3.如果只想指定某类信息的输出方式，也可以修改对应变量\nexport LC_TIME=zh_CN.utf8 \n通常可以将该变量值写于~/.bashrc等配置文件中使之永久生效\n</div>\n\n### date时间与日期\n#### 关于时间的常见概念\n<span class=\"strong\">秒的定义：</span>1967年，国际度量衡大会将铯-133原子跃迁9,192,631,770 次所需要的时间定义为1秒，铯原子钟有极好的稳定性，它能保证运行大约3170万年才产生一秒的误差\n\n<span class=\"strong\">国际原子时(TAI)：</span>TAI全称为Temps Atomique International，是全球统一的原子时间标准，由国际计量局（BIPM）收集多个原子钟的时间数据平均得出\n\n<span class=\"strong\">地球自转时间(UT1)：</span>基于地球自转的时间标准，用于反映地球自转的实际时间。UT1的测量是通过观测宇宙中遥远的“类星体”来完成的，‌这些观测帮助科学家监测地球自转的速度。但由于地球的自转速度并不完全均匀，会受潮汐、地球内部变化等因素的影响，因此UT1的时间长度会有微小的变化，UT1时间一天的实际长度可能稍长或稍短于24小时\n\n<span class=\"strong\">格林尼治时间(GMT)</span>：旧译格林威治标准时间，格林尼治标准时间的正午是指当太阳横穿本初子午线的时间，由英国伦敦郊区的皇家格林尼治天文台根据地球自转测量给出。由于地球每天的自转是不规则的，而且正在缓慢减速。所以，格林尼治时间已经不再被作为标准时间使用，而是转而使用协调世界时(UTC)作为标准时间。\n\n<span class=\"strong\">协调世界时(UTC)：</span>UTC全称为Coordinated Universal Time，是国际公认的世界标准时间，世界各地的时区都是基于 UTC 设定的，如：北京时间是 UTC+8，表示比UTC早8个小时。UTC时间是在TAI基础上修正计算得出的，从而保证了时间的精准性。TAI是一种稳定的时间尺度，严格定义的24小时等于永恒精确的24小时。然而，人类的生产活动基于地球的昼夜周期的，需要依赖地球的自转、光照等因素，人类所依赖的天文时间(略长或略短于24小时)与TAI时间之间有微小的差值，如果直接使用TAI时间，随着时间的推移，UT1和TAI之间的差值会越来越大，日出和日落的时刻会逐渐与人们的日常时间表不一致。为了既保证时间的精确性，又能满足人类生产需要，国际计量局(BIPM)和国际电信联盟(ITU)会根据地球自转的实际情况，结合国际地球自转服务组织(IERS)发布的结果，在TAI的基础上增加或删除<span class=\"strong\">闰秒</span>，以此计算出UTC时间，作为全球统一的世界标准时间，使得原子时(TAI)和地球自转时间(UT1)之间的差值保持在0.9秒以内。\n\n<span class=\"strong\">闰秒：</span>一个用于协调国际原子时（TAI）和世界时（UT1）的调整措施，闰秒的使用由国际地球自转服务组织（IERS）负责，他们监测地球自转速率与原子时间的差异，并在必要时宣布闰秒的插入或删除。BIPM通过收集和处理全球多个国家的原子钟数据来计算TAI，然后根据IERS发布的闰秒决定调整UTC，当 UT1 慢于 原定的UTC 时，需要在 UTC 时间系统中增加一秒，通常，这个额外的秒数会在6月30日或12月31日的最后一秒加上，此时，秒数会从00-59变成00-60，闰秒的插入可能会让一些默认每分钟60秒的程序出现故障，而一些程序会对其做特殊处理。因此，一些文档中关于秒的计量范围可能为00-59，而一些文档可能为00-60用来处理闰秒(如：GNU社区的date命令文档)\n\n<span class=\"strong\">北京时间(CST)：</span>又称中国标准时间(China Standard Time)，由位于陕西省渭南市蒲城县的中国科学院国家授时中心发播，因此北京时间并不是北京当地的时间，而是东经120°的地方时间\n\n<span class=\"strong\">Unix时间戳(POSIX 时间戳)：</span>是指自协调世界时（UTC）1970年1月1日00:00:00以来的秒数(不包括闰秒)，在Java等编程语言中，时间戳的单位可能是毫秒\n\n<span class=\"strong\">公元(AD)：</span>AD是Anno Domini的缩写，意为\"主的年份\"。公元纪年系统由6世纪的斯基泰僧侣狄奥尼修斯·埃克西古斯（Dionysius Exiguus）创建，他被基督教教会委托确定复活节的日期，以替代当时常用的以罗马皇帝迪奥克莱先为基准的纪年系统。基督教使用耶稣诞生的年份作为基督教的时间基准，公元1年即是耶稣诞生的年份。随着基督教在欧洲的传播，公元纪年逐渐成为西方世界普遍采用的历法标准，随后随着欧洲的殖民扩张和文化传播，逐渐在全球范围内被广泛接受和使用。如今，公元纪年系统已成为国际标准\n\n<span class=\"strong\">儒略日(Julian Day):</span>又称为朱利安日，代表从公元前4713年1月1日（儒略历）的正午开始到某个指定时间所经过的天数，有点类似于Unix时间戳，儒略日是一个不计年份和月份的计时系统，只计算某个时间距离公元前4713年1月1日过去了几天。如：2021年6月22日12:00的Julian Day是2459388。这个数值表示自公元前4713年1月1日正午以来，已经过去了2459388天。该日期系统主要用于天文领域，天文现象通常涉及非常长的时间跨度，如果使用公历日期系统(年、月、日)作为日期计数非常繁琐，Julian Day系统将日期换算为一个连续的数字，只计算天数，使得日期计算变得更加简洁，特别是在计算天体运动或两个日期之间的时间间隔时。选取公元前4713年1月1日作为Julian Day的起始时间是因为该时间节点是太阳周期(28年为一个周期)、月亮周期(19年为一个周期)、罗马征服日历(15年一个周期，古罗马帝国用于税务和行政管理的日期系统)的共同起点，这个日期是由天文学家约瑟夫·斯卡利杰（Joseph Scaliger）于1583年设定，斯卡利杰计算了这三个周期的最小公倍数，公元前4713年1月1日这天，这三个计时系统都渡过了一个周期并开始了一个新的周期，将拥有一个共同的起点。并且该时间点距离现代足够遥远，在研究绝大多数历史事件和天文事件时，Julian Day的数值都是正数，可以避免在计算中出现负数日期，方便计算和记录。\n\n<span class=\"strong\">ISO周日历系统：</span>ISO年份是国际标准化组织(ISO)规定的一种日期表示方式，在日常生活中，不同地区的人对于日期的解读方式不一致，如：01/06/21在有些地区解读为2021年1月6日，有些地区解读为2021年6月1日，也有可能被解读为2001年6月21日。为此，ISO组织制定了ISO 8601标准‌以确保了全球范围内日期表示的一致性，ISO 8601标准提供的标准日期格式为<span class=\"tips\">\"YYYY-MM-DD\"</span>形式，如：‌2021-06-01。‌此外，不同文化和地区对一周的起始时间定义不同，亚洲国家通常以星期一作为一周的第一天，而一些西方国家会以星期日作为一周的第一天，因为在基督教的传统中，‌周日是耶稣复活的日子，‌具有特殊的宗教意义。‌为了避免因地区和文化差异带来的日期混淆，ISO 8601标准还提供了\"ISO周编号系统\"，该系统中周、年份的计算方式与常见的公历有所不同：\n\n+ 公历年份从1月1日开始，到12月31日结束。而ISO年份不一定从1月1日开始，ISO标准中第一周被定义为包含1月4日的那一周，另一判别方法为：包含1月1日的那一周，有四天或四天以上的天(一周过半的时间)是属于上一年的，那么该周是属于上一年的，并且该周中剩余以1月开头的日期也属于上一年(该规则也被称为\"四天规则\")。因此，ISO年份可能会比普通年份早开始几天或者晚结束几天\n\n+ 公历中不同地区对于一周第一天的定义不同，ISO规定每周从星期一开始，星期日结束。每年有52或53个完整的ISO周，ISO年的第一周必须包含当年1月4日。\n\n<div class=\"show\">例如，2022年的最后一周从12月26日(星期一)开始，到2023年1月1日(星期日)结束，在公历中1月1日已经属于2023年，但在ISO年份中，由于1月1日是上一周的最后一天，属于上一周的一部分，所以1月1日在ISO年份中属于2022年，2023年从1月2日开始，1月2日-1月8日属于2023年的第一周\n<div class=\"table\"><table>\n<thead>\n<tr><th>一</th><th>二</th><th>三</th><th>四</th><th>五</th><th>六</th><th>日</th></tr>\n</thead>\n<tbody>\n<tr><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>31</td><td>1</td>\n</tr>\n<tr><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>\n</tr></tbody></table></div>绝大部分语言和命令提供了公历和ISO周日历两种标准中的日期计算结果，如：使用date命令处理2023-01-01这个日期\n1. 用%G和%V来返回其ISO年份和ISO周数，会返回2022年，第52周\ndate -d \"2023-01-01\" \"+%G--%V\"\n返回值为：2022--52\n2. 而用%Y和%W返回其公历年份和周数，由于当天为周日，新年第一个周一之前的日期属于第0周，因此会返回2023年第0周\ndate -d \"2023-01-01\" \"+%Y--%W\"\n返回值为：2023--00\n3. 如果返回周数时使用%U，使用西方计算一周的习惯，当天刚好为周日，因此属于2023年第一周\ndate -d \"2023-01-01\" \"+%Y--%U\"\n返回值为：2023--01\n在不同使用场景，可以使用不同选项\n</div>\n\n#### date命令\n\n<span class=\"strong\">date [选项] </span> 输出或修改系统时间和日期\n\n+ 默认情况下，date命令会按照locale区域设置的格式输出系统当前时间\n+ \"+日期格式字符串\"：可以指定日期时间输出格式\n+ -s 修改系统时间和日期\n+ -d 日期:输出指定的时间和日期，常用来格式化日期输出，如果指定输入的日期之间有空格，则需要使用引号包裹\n+ -f 文件名：从文件中批量载入日期，并格式化输出\n+ -r 文件名：输出文件最后被修改时间\n\n<div class=\"table\">\n\n常用格式|说明\n----|-----\n%H|以24小时制(00-23)输出小时\n%<strong style=\"font-family:Serif\">I</strong>|以12小时制(01-12)输出小时\n%M|输出分钟(00-59)\n%S|输出秒(00-60)(60为闰秒)\n%p|输出'AM'或'PM'\n%Z|输出时区，如北京时间为：CST\n%Y|输出年，如：2021\n%m|输出月(01-12)\n%d|输出日(01-31)\n</div>\n\n##### 输出当前系统时间\n<div class=\"show\">1.如果直接使用date命令且不指定时间日期输出格式，则date命令会按照locale默认格式(通常使用\"en_US.utf8\"格式，也是C语言默认格式)，以'+%a %b %e %H:%M:%S %Z %Y'格式输出系统当前时间，输出值类似于：\nSun Aug  4 14:36:21 CST 2021\n2. 可以使用+号引导时间格式字符串，让date命令以指定格式输出时间和日期\ndate +%m%d    #8月4日输出为0804\n3.如果格式字符串中包含空格，或者需要在输出时间时添加其他字符串内容，则需要添加单引号或双引号\ndate \"+%Y %m %d\" # 2021 08 04\ndate '+今天是%Y年%-m月%-d日'   #今天是2021年8月4日\n</div>\n\n##### 修改系统时间\n修改系统时间需要用户拥有root权限\n<div class=\"show\">1. 通过<span class=\"tips\">-s \"时间\"</span>或--set=\"时间\"选项修改系统时间，可以灵活指定时间的输入格式，它支持的时间输入方式很多，与该命令的-d选项类似\ndate -s \"2021-08-04 12:34:00\"\ndate -s \"12:34 Aug 04, 2021\"\ndate -s \"2024-08-04\"\n2.也可以在date命令后以<span class=\"tips\">MMDDhhmm[[CC]YY][.ss]</span>格式指定一个数字字符串以修改系统时间，格式大致排序为'月日时分[年][.秒]'，其中月日时分秒需要写两位值，不足两位的前补0，年可以写完整的4位，也可以写年份的后2位，年与秒可以不指定，时间日期数据需要严格按照该格式书写，该方法适合在脚本中指定一个精确时间\n如：设置当前系统时间为2021年8月4日12时34分05秒：\ndate 080412342021.05\n</div>\n\n##### 格式化输出一个指定的时间和日期\n<span class=\"tips\">-d</span>选项可以指定一个时间和日期，然后让date命令根据格式字符输出为指定形式，方便在代码中以统一格式输出时间信息。该选项十分强大，它能识别各种不同的日期输入方式，所输入的日期可以是具体值，也可以为相对时间\n\n<div class=\"show\">1.查看2016年6月6日是周几\ndate -d \"2016-06-06\" \"+%F %A\"\n返回值：2016-06-06 Monday\n2. 一年后的今天的日期和星期\ndate -d \"+1 year\" \"+%F %A\"\n返回值：2022-08-04 Thursday\n3.查看21天前的日期\n date -d \"21 days ago\" \"+%F %A\"\n输出值：2021-07-14 Wednesday\n4.查看2016年6月7日两周(14天)后的日期\ndate -d '2016/6/7 +2 weeks'\n输出值：Tue Jun 21 00:00:00 CST 2016\n5. 查看东11区时间为2022-12-31 23:59:59时，本地时间为多少\ndate -d '2022-12-31T23:59:59+11:00'\n东11区时间为：23:59:59\n则UTC标准时间为23:59:59-11:00=12:59:59\n然后date命令会从/etc/localtime文件获取时区信息，然后计算出本地时间，如：东八区的计算机会返回\nSat Dec 31 20:59:59 CST 2022\n</div>\n\n\n<div class=\"show\">-d选项能识别的时间/日期输入方式包括但不限于以下格式：\n1.日期的输入：\n2022-11-14     # ISO 8601标准格式\n22-11-14      \n11/14/2022     \n14 November 2022\n14 Nov 2022    \nNovember 14, 2022\n14-nov-2022\n14nov2022\n11/14  #如果没有指定过年份，将使用系统当前年份\nnov 14\n2.时间输入方式：\n20:02:00.000000 #秒可以精确到小数，但太高的精确值会被丢弃\n20:02\n8:02pm\n20:02+0800 #指定时区\n3. 时间与日期的组合表示，可以使用字符T或者空格隔开时间与日期\n2022-09-24T20:02:00-05:00\n2022-12-31T23:59:59+11:00\n1970-01-01 00:00Z\n4.相对时间表示方法\n1 year\n1 year ago\n2 days\ntomorrow\nyesterday\nnow \ntoday\n2022-12-31 -1 month\n5.通过<span class=\"tips\">@时间戳</span>的方式来表示一个时间节点，如：@1483228799表示 2016-12-31 23：59：59，该表示方法通常会忽略闰秒\n</div>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n具体说明详见GNU文档：<a href=\"https://www.gnu.org/software/coreutils/manual/html_node/Date-input-formats.html\">GNU程序支持的日期输入样式</a>\n</div>\n\n#### 时间与日期的格式\n时间和日期格式字符串通过<span class=\"tips\">+</span>号来引导，格式之间可以添加，如果格式字符串中包含空格则需要使用引号包裹。<span class=\"tips\">时、分、秒、月、日</span>等单位默认情况下会输出两位，在值只有一位时会前补0，可以在其格式字符前加上<span class=\"tips strong\">_</span>将其修改为前补空格，也可以在格式字符前加上<span class=\"tips strong\">-</span>将其修改为既不前补0也不前补空格。\n\n<div class=\"show\">1.格式字符通过+号引导，%号转义\ndate -d 2021/6/1 +%Y%m%d  #20210601\n2.格式字符串间可以添加其他字符，这些字符会被原样输出，如果带有空格需要使用引号\ndate -d 2021/6/1 \"+%Y %m %d\"   #2021 06 01\ndate -d 2021/6/1 \"+日期：%Y年%m月%d日\"    #日期：2021年06月01日\n3.前补格式可以任选\ndate -d 2021/6/1 \"+%Y年%m月%d日\"\"    #2021年06月01日\ndate -d 2021/6/1 \"+%Y年%_m 月%_d日\"  #2021年 6月 1日\ndate -d 2021/6/1 \"+%Y年%-m 月%-d日\"  #2021年6月1日\ndate -d 2021/6/1 \"+%Y-%-m-%-d\"      #2021-6-1\n</div>\n\n<div class=\"table\">\n\n时间格式符|说明              \n------|-----------------\n%H|以24小时制('00'-'23')显示小时，值只有一位时前补0\n%<strong style=\"font-family:Serif\">I</strong>|以12小时制('01'-'12')输出小时，值只有一位时前补0\n%k|以24小时制('&emsp;0'-'23')输出小时，但值只有一位时不前补0，而是前补空格，等价于\"%_H\"(GNU扩展格式)\n%<strong style=\"font-family:Serif\">l</strong>|与%k类似，以12小时制('&emsp;1'-'12')输出小时，值只有一位时前补空格，等效于\"%_<strong style=\"font-family:Serif\">I</strong>\"(GNU扩展格式)\n%M|输出分钟('00'-'59')\n%s|输出自 1970-01-01 00：00 UTC 以来的秒数\n%S|输出秒('00'-'60')\n%N|输出纳秒(GNU拓展格式)\n%p|显示'AM'或'PM'\n%R|输出24小时制的小时和分钟，等价于\"%H:%M\"\n%T|输出24小时制的小时、分钟、秒，等价于\"%H:%M:%S\"\n%x|根据用户本地环境自动决定显示格式，如：美国默认显示为MM/DD/YY，而欧洲一些地区可能显示为DD/MM/YYYY\n%z|显示四位数的时区，如：中国东八区：+0800\n%Z|显示时区名字，常见的时区名有：UTC(协调世界时间)、CST(北京时间或中国标准时间)、PST(太平洋标准时间)、GMT(格林威治时间)、CET(中央欧洲时间)\n</div>\n\n<div class=\"table\">\n\n日期格式符|说明              \n------|-----------------\n%a|星期的缩写，如：Sun\n%A|星期的全写，如：Sunday\n%b|月份的缩写，如：Jan\n%B|月份的全写，如：January\n%c|根据用户本地环境自动决定时间和日期显示格式，如：Sat 03 Aug 2021 10:17:38 AM CST\n%C|显示年份的前两位，如：2021显示为20，可以用来和%y搭配将年份拆分为两部分处理(GNU文档中说返回世纪，真实的世纪应该在此基础上+1，计算机习惯从0计数说世纪应该也没错？)\n%d|显示日期，值只有一位时前补0\n%D|以%m/%d/%y形式显示日期，如：06/20/2021\n%e|显示日期，值只有一位时前补空格，等同于\"%_d\"\n%F|以标准ISO 8601格式显示日期，格式为：YYYY-MM-DD，如：2023-10-01\n%g|输出年份的后两位数，这里的年份是基于ISO 8601周历的年份，而非公历(详见对ISO的解释部分)，如：2023/01/01返回22\n%G|%g的四位数版本，输出完整的四位数年份，年份也是基于ISO 8601周历的年份，如：2023/01/01返回2022\n%h|与%b相同，显示月份的缩写\n%j|显示某个日期当天为一年中的第几天，值为001-366\n%m|显示数字形式的月份(01-12)，值只有一位时前补0\n%q|显示一年中的第几个季度(1-4)\n%u|显示数字形式的星期(1-7)，1对应周一\n%U|显示某个日期为一年的第几周(00-53)，新年中第一个星期日之前的天数属于第零周\n%V|显示ISO周数，即某个日期为ISO年的第几周(01-53)，详见对ISO的解释部分\n%w|显示数字形式的星期(0-6)，0对应于星期日\n%W|显示某个日期为一年的第几周(00-53)，新年中第一个星期一之前的天数属于第零周\n%x|根据用户本地环境自动决定日期显示格式，相较于%c它只显示日期，如：12/31/2016\n%y|显示年份的后两位数字(00-99)，如：2021年显示为21\n%Y|显示完整四位数的年份，也是常用的年份显示方式，如：2021\n</div>\n\n<div class=\"table\">\n\n特殊转义字符|说明\n-----------|-------\n%%|输出%\n%n|换行符\n%t|制表符\n</div>\n\n<!-- #### 基于NTP协议更新系统时间\n虽然通过date -s命令可以手动设置系统时间，但通常情况下服务器会选择通过NTP(网络时间协议)来更新系统时间\n\n##### chrony\nchrony 是一个开源的网络时间协议(NTP)的通用实现项目，它可以保持系统时间与NTP时钟服务器的同步，chrony也可以作为服务端软件为其他计算机提供时间同步服务。chrony 包含两个程序：chronyd——后台守护进程，chronyc——命令行界面程序。\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nchrony官网：<a href=\"https://chrony-project.org\">https://chrony-project.org</a></div> -->\n\n### 系统网络\n#### ping 测试网络\n<span class=\"strong\">ping [-c 次数] IP地址</span>\n\n+ -c &emsp;指定发送次数\n\n测试网络是否联通，如果不添加-c参数，则会无终止进行ping操作，直至 ctrl+c 停止\n\n#### ifconfig 网卡设置\n<span class=\"strong\">ifconfig [网卡名称] [IP地址]</span>\n<p>查看和设置网卡</p>\n  <div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>直接使用 ifconfig 为查看网卡，不同发行版的Linux网卡标识不同，Centos7中网卡名以eth+数字标识，其中lo为回环网卡，用于本地通信与测试\n</div>\n\n#### traceroute 查看与目标主机间的网路节点\n<span class=\"strong\">traceroute 网址或IP地址</span>\n<p>显示当前主机与目标主机之间的所有网络节点的IP地址、延迟等信息，节点为***表示该节点信息被加密</p>\n\n#### 查看网络状态\n<span class=\"strong\">netstat [参数]</span>\n查看当前主机的网络连接状态，包括端口号、IP地址等\n+ -t &emsp;TCP协议\n+ -u &emsp;UDP协议\n+ -l &emsp;监听\n+ -r &emsp;路由\n+ -n &emsp;显示IP地址和端口号\n+ -a &emsp;所有\n+ -p &emsp;列出相关程序名\n\n常用\n+ <span class=\"strong\">netstat -tulnp &emsp;查看本机监听的TCP和UDP端口并列出相关程序</span>\n+ <span class=\"strong\">netstat -an &emsp;查看本机的所有网络连接</span>\n+ <span class=\"strong\">netstat -rn &emsp;查看本机所有路由表</span>\n\n#### setup 配置网络(redhat系列操作系统专有)\n<span class=\"strong\">setup</span>\n调出GUI界面设置IP地址、子网掩码等信息，setup是redhat开发的用于配置网络IP地址、子网掩码等网络信息的GUI工具，只有部分redhat发行的操作系统中有该工具。\n\n\n\n\n\n","tags":["Linux","command"]},{"title":"vim笔记","url":"/blog/2021/06/15/vim编辑器/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n第一次接触到vim时连字都不会打...后来在某管乱逛的时候看到两个Google的<del> 秃头 </del>工程师用vim花式结对编程时，vim就深深折服了我，那效率真是芜湖~，谁不想有个这样的<del> jiyou </del>普通朋友来次愉快的多线程交流呢<span  style=\"white-space: nowrap;\">๑乛◡乛๑</span>\n</div>\n\n### vi 与 vim 简介\n<span class=\"strong\">vi:</span>为 visual interface 的简称，是<span class=\"tips\">Linux</span>操作系统中最经典的文本编辑器。\n<p><span class=\"strong\">vim:</span>全称为vi improved，从vi 发展而来的文本编辑器，支持代码补全、编译、错误跳转等功能。在很多Linux发行版中，直接预装有vim编辑器，vim本身也发布了支持Windows、Unix、MacOS等不同操作系统的编辑器版本，并且很多优秀的IDE都有支持vim的插件，因此使用vim命令可以在各种操作系统环境下高效编辑代码/文本。</p>\n<p><span class=\"tips\">vim官方网站：<a href=\"https://www.vim.org/\" target=\"_blank\">https://www.vim.org/</a></span></p>\n<ul>\nvim的特点:\n<li>熟练掌握vim以后可以极大地提高编辑速率</li>\n<li>所有操作可以靠键盘完成，免去了键盘鼠标来回切换的时间</li>\n<li>甚至于在部分终端中不支持鼠标操作，无UI界面，所有操作靠命令</li>\n<li>无花里胡哨的排版功能，但有很多花里胡哨的的插件可以玩</li>\n<li>命令操作一切</li>\n<li>大多数服务器默认安装</li>\n</ul>\n\n### vim 的三种工作模式\n不同文档对命令、工作模式的翻译可能不同，不过在vim中操作是一样的\n##### 命令模式\n\n打开文件会首先进入命令模式，是 vim 使用的入口。该模式下可对文件内容进行基本的快捷操作，如：定位、翻页、复制、粘贴、删除等\n\n<p>在命令模式下输入<span class=\"tips\">i</span>进入编辑模式，进入编辑模式后按下<span class=\"tips\">esc</span>返回命令模式</p>\n<p>在命令模式下输入<span class=\"tips\">:</span>进入末行模式，进入末行模式后按下<span class=\"tips\">esc</span>返回命令模式</p>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n使用I、o、a等命令也可进入编辑模式，具体用法详见插入命令。</div>\n\n##### 末行模式\n在vim最底部输入命令的模式，也是vim 的出口，当要退出 vim 返回控制台时，需要在末行模式下输入命令。该模式下可对文件整体进行基本的操作，如：保存、退出、另存、搜索与替换等操作。\n<p>末行模式下输入<span class=\"tips\">wq</span>可快速保存并关闭文件</p>\n\n##### 编辑模式\n用于编辑文件具体内容的模式\n\n##### 此外\n还有<span class=\"tips\">可视模式</span>、<span class=\"tips\">替换模式</span>两个用于选取字符、替换内容等具体操作的模式\n\n### 基本命令\n#### 打开与新建文件\n<ul>\n<li><span class=\"strong\">vim 文件名</span> 打开/新建文件</li>\n<li><span class=\"strong\">vim 文件名 +行号</span> 打开文件并跳转到对应行号</li>\n<li><span class=\"strong\">vim 文件名 +</span>打开文件并跳转到文件末尾</li>\n<li><span class=\"strong\">vim 文件名1 文件名2 ... </span>同时打开多个文件</li>\n</ul>\n<p>使用命令时，若文件名对应的文件存在，则会用vim编辑器打开该文件，若文件不存在，则会新建一个文件。打开多个文件时，默认显示第一个文件，可以通过命令<span class=\"tips\">:ls</span>让vim列出所有打开的文件，使用<span class=\"tips\">:b数字</span>来使对应序号的文件显示在屏幕上。</p>\n\n#### 保存与退出(末行模式下)\n需要先切换到末行模式下，因此下述命令前的<span class=\"tips\"> : </span>号用于换到末行模式\n<ul>\n<li><span class=\"strong\">:w </span>保存</li>\n<li><span class=\"strong\">:w! </span>强制保存</li>\n<li><span class=\"strong\">:q </span>退出，如果没有保存则不允许退出</li>\n<li><span class=\"strong\">:q! </span>不保存，强制退出</li>\n<li><span class=\"strong\">:wq </span>保存并退出</li>\n<li><span class=\"strong\">:x </span>保存并退出</li>\n</ul>\n<p>更多末行模式下的命令在末行模式下的命令小节</p>\n\n#### 异常退出\n如果 vim 异常退出，会为当前编辑但尚未保存的文件创建一个后缀名为<span class=\"tips\">.swp</span>的<span class=\"tips\">交换文件</span>,该文件默认隐藏，下次打开未保存的文件会询问如何进行操作，可以根据vim提示选择恢复、直接编辑等操作。\n\n\n### 常用命令\n\n#### 移动光标与选取文本\n\n##### 上上下下左左右右 BABA\n\n<ul>\n<li><span class=\"strong\">h&emsp;&emsp;向左</span></li>\n<li><span class=\"strong\">j &emsp;&emsp;向下</span></li>\n<li><span class=\"strong\">k&emsp;&emsp;向上</span></li>\n<li><span class=\"strong\">l &emsp;&emsp;向右</span></li>\n</ul>\n\n##### 行内移动\n\n<ul>\n<li><span class=\"strong\">w&emsp;&emsp;移动到下一个单词开头</span>(word)</li>\n<li><span class=\"strong\">b &emsp;&emsp;向前移动一个单词</span>(back)</li>\n<li><span class=\"strong\">0 &emsp;&emsp;行首</span></li>\n<li><span class=\"strong\">^ &emsp;&emsp;行首，第一个不是空白的字符位置</span></li>\n<li><span class=\"strong\">$ &emsp;&emsp;行尾</span></li>\n<li><span class=\"strong\">g_ &emsp;&emsp;行尾,最后一个不是空白的字符位置</span></li>\n<li>&nbsp; e &emsp;&emsp;下一个单词结尾</li>\n<li>&nbsp; f字符&emsp;&emsp;下一个对应字符位置</li>\n<li>&nbsp; nf字符&emsp;&emsp;下n个对应字符位置</li>\n<li>&nbsp; F字符&emsp;&emsp;上一个对应字符位置</li>\n<li>&nbsp; nF字符&emsp;&emsp;上n个对应字符位置</li>\n<li>&nbsp; t字符&emsp;&emsp;下一个该字符的前一个字符位置</li>\n<li>&nbsp; nt字符&emsp;&emsp;下n个该字符的前一个字符位置</li>\n<li>&nbsp; T字符&emsp;&emsp;上一个该字符的后一个字符位置</li>\n<li>&nbsp; nT字符&emsp;&emsp;上n个字符的后一个字符位置</li>\n</ul>\n<p>当使用f、F、t、T关键字跳转时，使用 ; 可以快速跳转到下一个指定字符，使用 , 可以跳转到上一个指定字符。</p>\n\n##### 行间移动\n\n<ul>\n<li><span class=\"strong\">gg&emsp;&emsp;&emsp;&emsp;跳转到文件第一行行首</span></li>\n<li><span class=\"strong\">G &emsp;&emsp;&emsp;&emsp;&nbsp;跳转到文件最后一行行首</span></li>\n<li><span class=\"strong\">数字gg&emsp;&emsp;跳转到数字对应行数</span></li>\n<li><span class=\"strong\">数字G &emsp;&emsp;&nbsp;跳转到数字对应行的行首</span></li>\n<li><span class=\"strong\">: 数字 &emsp;&emsp;&emsp;跳转到数字对应行数</span></li>\n</ul>\n\n##### 屏幕内移动\n\n<ul>\n<li><span class=\"strong\">Ctrl+b&emsp;&emsp;&emsp;向上翻页</span>(back)</li>\n<li><span class=\"strong\">Ctrl+f &emsp;&emsp;&emsp;向下翻页</span>(forward)</li>\n<li><span class=\"strong\">H &emsp; &emsp;&emsp;&emsp;&emsp;当前屏幕第一行行首</span>(Head)</li>\n<li><span class=\"strong\">M&emsp; &emsp;&emsp;&emsp;&emsp;屏幕中间</span>(Middle)</li>\n<li><span class=\"strong\">L &emsp; &emsp; &emsp;&emsp;&emsp;屏幕底部</span>(Low)</li>\n<li><span class=\"strong\">zt &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕顶部</span></li>\n<li><span class=\"strong\">zz &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕中央</span></li>\n<li><span class=\"strong\">zb &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕尾部</span></li>\n</ul>\n\n##### 段落切换\n\nvim 中以<span class=\"tips\">空白行</span>来区分段落，开发程序时将同一个功能相关的代码写在一起，不留空行。而在不同功能间留下空白行方便切换。\n\n<ul>\n<li><span class=\"strong\">{&emsp;&emsp;上一个段落</span></li>\n<li><span class=\"strong\">}&emsp;&emsp;下一个段落</span></li>\n</ul>\n\n##### 括号间切换\n用于在程序中出现频率很高的<span class=\"tips\">( )</span>、<span class=\"tips\">[ ]</span>、<span class=\"tips\">{ }</span>间切换，需要先把光标移动到其中一个括号上，然后使用%可切换到与其匹配的另外一边括号\n\n<ul>\n<li><span class=\"strong\">%&emsp;&emsp;括号匹配及切换</span></li>\n</ul>\n\n##### 添加标记与跳转\n在开发时，某段代码可能需要稍后处理，此时可用标记功能并在稍后快速跳转。\n<ul>\n<li><span class=\"strong\">m字母&emsp;&emsp; &emsp; &emsp;添加标记，字母可用a-z或A-Z间的任意字母</span>(mark)</li>\n<li><span class=\"strong\">' 标记的字母&emsp;&emsp;跳转到该字母标记的行首</span>(英文单引号)</li>\n<li><span class=\"strong\">`标记的字母&emsp;&emsp;跳转到该字母标记处</span>(esc下的撇号)</li>\n<li><span class=\"strong\">:marks&emsp;&emsp;列出所有标记</span></li>\n<li><span class=\"strong\">:delmarks 标记名 标记名....&emsp;&emsp;删除对应标记名</span>(可单个删除可多个删除)</li>\n<li><span class=\"strong\">:delmarks!&emsp;&emsp;删除所有小写字母标记</span></li>\n</ul>\n<p><span class=\"tips\">大写字母标记符可以实现文件间的跳转,因此大写字母通常用于文件间的标记</span></p>\n<p><span class=\"tips\">如果添加标记的行被删除，标记也将被删除。</span></p>\n<p><span class=\"tips\">如果其他行添加了同名标记，之前添加的标记将被替换掉。</span></p>\n\n##### 选中文本(可视模式)\n\n在命令模式下使用下列命令可切换到<span class=\"tips\">可视模式</span>，vim 有三种可视模式。\n\n<p>可视模式通过与光标移动命令搭配使用来选取文本，如：<span class=\"tips\">ggVG</span>可用于选中所有文本，选取的文本可通过<span class=\"tips\">esc</span>放弃选中并返回命令模式。</p>\n<ul>\n<li><span class=\"strong\">v(常规可视模式)&emsp;&emsp; &emsp;选中光标经过的所有文本</span></li>\n<li><span class=\"strong\">V(可视行模式)&emsp;&emsp;&emsp;&emsp;整行选中光标经过的所有文本</span></li>\n<li><span class=\"strong\">Ctrl+v(可视块模式)&emsp;&emsp;垂直方向选中文本</span>(类似于vscode的shift+Alt+鼠标点击，用于多行输入/删除)</li>\n</ul>\n\n#### 编辑命令\n\n##### 撤销与恢复撤销\n\n用于撤销错误的编辑操作，或者恢复撤销的命令,<span class=\"tips\">可用多次使用!</span>\n\n<ul>\n<li><span class=\"strong\">u&emsp;&emsp; &emsp; &emsp;撤销上一个命令</span>(undo)</li>\n<li><span class=\"strong\">Ctrl+r&emsp;&emsp;恢复撤销的命令</span>(redo)</li>\n</ul>\n\n##### 删除文本\n\n<ul>\n<li><span class=\"strong\">x&emsp; &emsp; &emsp; &emsp; &emsp;删除光标所在字符或选中的文本</span>(cut)</li>\n<li><span class=\"strong\">d移动命令&emsp;&emsp;删除移动命令对应的内容</span>(delete)</li>\n<li><span class=\"strong\">dd&emsp;&emsp;&emsp;&emsp; &emsp;删除光标所在行</span></li>\n<li><span class=\"strong\">D&emsp; &emsp; &emsp;&emsp; &emsp;删除光标至行尾间的内容</span></li>\n<li><span class=\"strong\">:n1,n2d&emsp;&emsp;&emsp;多行删除,n1为起始行号，n2为结束行号</span>(末行模式下)</li>\n</ul>\n<p>删除命令与移动命令的常用组合</p>\n<ul>\n<li>dw &emsp; &emsp;&emsp; 从光标位置删除到单词末尾</li>\n<li>dnw &emsp; &emsp;&emsp; 删除n个单词</li>\n<li>df字符 &emsp; &emsp;从光标处删除到下一个该字符处</li>\n<li>d$ &emsp; &emsp;&emsp; 删除光标到本行末尾</li>\n<li>d0 &emsp; &emsp; &emsp;从光标位置删除到该行起始位置(光标前该行的所有内容)</li>\n<li>d} &emsp; &emsp; &emsp; 从光标位置删除到段落结尾</li>\n<li>ndd &emsp; &emsp;&emsp;从光标位置向下连续删除 n 行</li>\n<li>d行号G &emsp;&emsp;删除光标所在行到指定代码行之间的所有内容</li>\n<li>d'标记符&emsp;&emsp;从光标所在行删除到标记符之间的所有代码</li>\n<li>dH &emsp; &emsp;&emsp; 删除屏幕第一行到光标所在行</li>\n<li>dG &emsp; &emsp;&emsp; 删除光标所在行到文件结束</li>\n</ul>\n\n##### 复制粘贴\nvim提供一个用于保存被复制、删除文本的缓冲区\n<p> <span class=\"tips\">复制</span>命令会将选中的文字保存在该缓冲区<p>\n<p> <span class=\"tips\">删除</span>命令会将删除内容保存在该缓冲区<p>\n<p> <span class=\"tips\">粘贴</span>命令会将缓冲区内容插入光标所在位置<p>\n<ul>\n<li><span class=\"strong\">y移动命令&emsp;&emsp;复制</span>(copy)</li>\n<li><span class=\"strong\">yy &emsp;&emsp;&emsp;&emsp;&emsp;复制一行,nyy会复制n行</span>(copy)</li>\n<li><span class=\"strong\">y$ &emsp;&emsp;&emsp;&emsp;&emsp;复制光标到本行结尾</span></li>\n<li><span class=\"strong\">yH &emsp;&emsp;&emsp;&emsp;&emsp;复制屏幕第一行到光标所在行</span></li>\n<li><span class=\"strong\">yG &emsp;&emsp;&emsp;&emsp;&emsp;复制光标所在行到文件结束</span></li>\n<li><span class=\"strong\">p &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之后</span>(paste)</li>\n<li><span class=\"strong\">P &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之前</span>(paste)</li>\n</ul>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nvim中的文本缓冲区只有一个，后续做过复制、删除命令操作后，之前缓冲区中的内容会被替换</div>\n\n##### 输入替换(替换模式)\n<span class=\"tips\">r</span>命令用于轻量级修改,不需要进入替换模式\n<p><span class=\"tips\">R</span>可进入替换模式，修改完成后通过<span class=\"tips\">esc</span>返回命令模式</p>\n<ul>\n<li><span class=\"strong\">r &emsp;&emsp;替换当前字符</span>(replace)命令模式</li>\n<li><span class=\"strong\">R&emsp;&emsp;替换当前行光标后的所有字符</span>(replace)替换模式</li>\n</ul>\n\n##### 缩排和重复执行\n用于编排代码格式\n<ul>\n<li><span class=\"strong\">&gt;&gt; &emsp;&emsp;向右增加缩进</span>(增加4个空格)</li>\n<li><span class=\"strong\">&lt;&lt; &emsp;&emsp;向左减少缩进</span>(减少4个空格)</li>\n<li><span class=\"strong\"> . &emsp;&emsp;&emsp;重复上次命令</span></li>\n</ul>\n<p>在<span class=\"tips\">可视模式</span>下，缩排命令只需一个<span class=\"tips\">&gt;</span>、<span class=\"tips\">&lt;</span>即可。缩排一次后，用<span class=\"tips\"> . </span>命令执行多次缩排快速进行排版</p>\n\n##### 查找\n###### 1.指定字符查找\n<ul>\n<li><span class=\"strong\">/字符 &emsp;&emsp;查找指定的字符</span></li>\n</ul>\n<p>输入查找内容后回车，vim会高亮找到的内容，此时可使用<span class=\"tips\">n/N</span>命令跳转</p>\n<ul>\n<li><span class=\"strong\">n &emsp;&emsp;查找下一个</span>(next)</li>\n<li><span class=\"strong\">N &emsp;&emsp;查找上一个</span>(next)</li>\n</ul>\n\n###### 2.快速匹配单词\n<ul>\n<li><span class=\"strong\">* &emsp;&emsp;向后查找光标所在单词</span></li>\n<li><span class=\"strong\">N &emsp;&emsp;向前查找光标所在单词</span></li>\n</ul>\n<P></P>\n直接按上述键，vim会识别当前光标所在的单词，然后查找相同的单词\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\nvim会高亮显示查找到的内容，若想取消高亮显示，使用<span class=\"tips\">/字符</span>命令查找一个不存在的字符串将取消高亮显示。<span class=\"tips\">搜索支持正则表达式 !</span></div>\n\n##### 查找并替换\n替换指定的内容，vim中查找并替换命令需要在<span class=\"tips\">末行模式</span>下执行，语法组成为<span class=\"tips\">:作用范围s/替换内容/新内容/标识符</span>,标识符可由下列3类自由组成。\n<p><span class=\"tips\">i</span>表示大小写不敏感查找</p>\n<p><span class=\"tips\">I</span>表示大小写敏感查找</p>\n<p><span class=\"tips\">g</span>指定区域中找到的所有目标</p>\n<p><span class=\"tips\">c</span>替换前需确认</p>\n\n###### 1.仅替换第一个目标\n<ul>\n<li><span class=\"strong\">:s/替换内容/新内容&emsp;&emsp;仅替换当前行中的第一个目标内容</span></li>\n<li><span class=\"strong\">:%s/替换内容/新内容&emsp;&emsp;替换文件中所有行的第一个目标内容</span></li>\n</ul>\n\n###### 2.文件全局替换\n<ul>\n<li><span class=\"strong\">:%s/替换内容/新内容/g&emsp;&emsp;全局替换</span></li>\n</ul>\n一次性替换整个文件中的所有指定内容\n\n###### 3.局部替换\n<ul>\n<li><span class=\"strong\">:s/替换内容/新内容/g&emsp;&emsp;替换当前行中的所有目标内容</span></li>\n<li><span class=\"strong\">:行号1,行号2s/替换内容/新内容/g&emsp;&emsp;替换行号1到行号2之间的所有目标内容</span></li>\n</ul>\n\n###### 4.在选取内容中替换(可视模式下)\n只替换选中区域中的指定内容，需要在可视模式下先选中需要替换的区域，选取区域后输入<span class=\"tips\">:</span>,vim会自动补全为<span class=\"tips\">:'<,>'</span>，完整语法为:\n<ul>\n<li><span class=\"strong\">:'<,>'s/替换内容/新内容/g&emsp;&emsp;替换选择区域中的所有目标</span></li>\n</ul>\n\n###### 5.确认替换(使用标识符c时)\n进行替换操作时会依次询问每一个内容是否要替换，可依次选择每个目标是否替换然后退出，或执行全部替换。\n<ul>\n<li><span class=\"strong\">:s/替换内容/新内容/gc&emsp;&emsp;确认替换</span>(comfirm)</li>\n</ul>\n<p>确认/取消替换命令:</p>\n<ol>\n<li><span class=\"strong\">y&emsp;&emsp;替换</span>(yes)</li>\n<li><span class=\"strong\">n&emsp;&emsp;不替换</span>(no)</li>\n<li><span class=\"strong\">a&emsp;&emsp;替换所有</span>(all)</li>\n<li><span class=\"strong\">q&emsp;&emsp;退出替换</span>(quit)</li>\n<li> l &emsp;&emsp;最后一个，并把光标移动到行首(last)</li>\n<li>^E&emsp;&emsp;向下滚屏</li>\n<li>^Y&emsp;&emsp;向上滚屏</li>\n</ol>\n\n##### 插入命令\n用于进入编辑模式\n<ul>\n<li><span class=\"strong\">i&emsp;&emsp;在当前字符前插入文本</span>(insert)</li>\n<li><span class=\"strong\">I&emsp;&emsp;在行首插入文本</span>(insert)</li>\n<li><span class=\"strong\">a&emsp;&emsp;在当前字符后插入文本</span>(append)</li>\n<li><span class=\"strong\">A&emsp;&emsp;在行末插入文本</span>(append)</li>\n<li><span class=\"strong\">o&emsp;&emsp;在当前行后插入一个空行</span></li>\n<li><span class=\"strong\">O&emsp;&emsp;在当前行前插入一个空行</span></li>\n<li><span class=\"strong\">s&emsp;&emsp;删除光标所在字符然后插入文本</span></li>\n<li><span class=\"strong\">S&emsp;&emsp;删除光标所行然后插入文本</span></li>\n<li><span class=\"strong\">cw&emsp;&emsp;删除光标所在单词然后插入文本</span></li>\n</ul>\n\n##### 大小写转换\n<ul>\n<li><span class=\"strong\">~&emsp;&emsp;改变光标所在字母大小写</span></li>\n<li><span class=\"strong\">n~&emsp;&emsp;改变光标开始的n个字母大小写</span></li>\n<li><span class=\"strong\">g~~&emsp;&emsp;改变当前行字母大小写</span></li>\n<li><span class=\"strong\">gUU&emsp;&emsp;将当前行字母改成大写</span></li>\n<li><span class=\"strong\">guu&emsp;&emsp;将当前行字母改成小写</span></li>\n<li><span class=\"strong\">ngUU&emsp;&emsp;将光标所在行开始的后n行改成大写</span></li>\n<li><span class=\"strong\">gUw&emsp;&emsp;将光标所处单词改成大写</span></li>\n<li><span class=\"strong\">guw&emsp;&emsp;将光标所处单词改成小写</span></li>\n</ul>\n\n\n\n### 重复执行命令\n##### <span class=\"tips\">数字+命令的组合会让部分命令执行指定次数</span>\n\n\n<div class=\"code\">如：\n10x  删除光标后的10个字符\n10>>  让光标后的10行文本进行缩进\n10yy  复制10行内容</div>\n\n<div class=\"show\">如：输入10个相同的字符串\n执行步骤\n1. 在命令模式下输入10\n2. 输入i进入编辑模式\n3. 输入需要重复的字符串\n4. 输入完毕后esc返回命令模式，vim会把输入字符这个命令执行10次\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n以上原因，在进入编辑模式前，尽量不要触碰数字，否则可能导致命令的重复执行</div>\n\n##### <span class=\"tips\">执行某个命令后使用 . 号可重复执行该命令</span>\n<div class=\"code\">如：\ndd 删除光标当前所在行后\n之后每使用一次 . 会删除一行</div>\n\n##### 运用举例\n\n<div class=\"show\">利用可视块将多行文本改为注释(注释符号为:#)\n执行步骤\n1. 移动光标到要添加注释的第一行代码，使用^定位到行首\n2. 使用Ctrl+v进入可视块模式\n3. 使用I进入编辑模式,并输入#。注：可视块模式下使用i插入无效\n4. 输入完毕后esc返回命令模式，vim会把选中的每一行文本前都插入#\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\">注意</div>\n重复执行只对部分命令有效，而对如 u(撤销)命令无效，vim依旧会重复执行u 命令前执行的命令。</div>\n\n### 末行模式下的命令\n#### 文件操作\n末行命令主要用于文件的保存、退出、搜索与替换，以及浏览、新建、另存文件等操作\n<ul>\n<li><span class=\"strong\">:e.&emsp;&emsp;打开内置文件浏览器，浏览当前目录下的文件</span></li>\n<li><span class=\"strong\">:e 文件名&emsp;&emsp;打开另外一个文件并切换到其中</span>(edit)</li>\n<li><span class=\"strong\">:e!&emsp;&emsp;放弃对所有文件的修改，恢复文件到上次保存的位置</span></li>\n<li><span class=\"strong\">:n 文件名&emsp;&emsp;新建文件</span>(new)</li>\n<li><span class=\"strong\">:w 文件名&emsp;&emsp;保存当前文件修改到对应文件中(没有时会新建)</span>(write)</li>\n<li><span class=\"strong\">:saveas 文件名 &emsp;另存为新文件</span></li>\n<li><span class=\"strong\">:bn&emsp;切换到上一个文件</span>(打开多个文件时)</li>\n<li><span class=\"strong\">:bp&emsp;切换到下一个文件</span>(打开多个文件时)</li>\n</ul>\n<p>切换文件时若当前文件未保存时不能切换，但可用!强制执行。文件另存为操作不会将编辑界面跳转到新另存的文件里，依旧会在当前文件编辑界面中。</p>\n<p>输入文件名时，输入部分文件名后按下<span class=\"tips\">Tab</span>键，vim会提示文件名</p>\n\n#### 设置\n<ul>\n<li><span class=\"strong\">:set nu&emsp;&emsp;显示行号</span></li>\n<li><span class=\"strong\">:set nonu&emsp;&emsp;取消行号显示</span></li>\n<li><span class=\"strong\">:数字&emsp;&emsp;定位到对应的行</span></li>\n<li><span class=\"strong\">:set ic&emsp;&emsp;不区分大小写</span></li>\n<li><span class=\"strong\">:set noic&emsp;&emsp;区分大小写</span></li>\n</ul>\n\n\n### 分屏命令\n#### 分屏打开多个文件\n<ul>\n<li><span class=\"strong\">vim -On 文件名1 文件名2 ...&emsp;&emsp;横向分屏打开文件，从左到右依次显示</span></li>\n<li><span class=\"strong\">vim -on 文件名1 文件名2 ...&emsp;&emsp;竖向分屏打开文件，从上到下依次显示</span></li>\n</ul>\n\n#### 拆分当前屏幕\n方便同时编辑、浏览多个文件\n<ul>\n<li><span class=\"strong\">:sp [文件名]&emsp;&emsp;增加横向分屏</span>(split)</li>\n<li><span class=\"strong\">:vsp [文件名]&emsp;&emsp;增加竖向分屏</span>(vertical split)</li>\n</ul>\n<p>可以不跟文件名，当无文件名时分屏命令会将当前文件也显示在分屏上。输入文件名忘记全称时，使用<span class=\"tips\">Tab</span>键，vim会提示文件名</p>\n<p>上述命令不添加文件名时，功能同如下两个命令，但下面两个命令使用前需先执行<span class=\"tips\">Ctrl+w</span>命令</p>\n<ul>\n<li>s&emsp;&emsp;上下屏幕同时显示当前文件</li>\n<li>v&emsp;&emsp;左右屏幕同时显示当前文件</li>\n</ul>\n\n#### 切换分屏窗口\n切换分屏窗口都是基于<span class=\"tips\">Ctrl+w</span>命令，使用下述命令前都要先执行该命令。\n##### 光标在分屏窗口中切换\n<ul>\n<li><span class=\"strong\">w&emsp;&emsp;按顺序切换到下一个窗口</span>(window)(从上到下从左到右)</li>\n<li><span class=\"strong\">W&emsp;&emsp;逆顺序切换到下一个窗口</span>(window)(从下到上从右到左)</li>\n<li><span class=\"strong\">h&emsp;&emsp;切换到左边的窗口</span></li>\n<li><span class=\"strong\">l&emsp;&emsp;切换到右边的窗口</span></li>\n<li><span class=\"strong\">j&emsp;&emsp;切换到下面的窗口</span></li>\n<li><span class=\"strong\">k&emsp;&emsp;切换到上面的窗口</span></li>\n</ul>\n\n##### 移动分屏窗口\n<ul>\n<li><span class=\"strong\">r&emsp;&emsp;按顺序互换窗口</span>(reverse)</li>\n<li><span class=\"strong\">R&emsp;&emsp;逆顺序互换窗口</span>(reverse)</li>\n<li><span class=\"strong\">H&emsp;&emsp;将当前分屏移动到左边</span></li>\n<li><span class=\"strong\">L&emsp;&emsp;将当前分屏移动到右边</span></li>\n<li><span class=\"strong\">J&emsp;&emsp;关将当前分屏移动到下面</span></li>\n<li><span class=\"strong\">K&emsp;&emsp;将当前分屏移动到上面</span></li>\n</ul>\n<p>以从上到下的窗口分布为例，将7个窗口比作7个楼层，按顺序互换窗口指顶楼7楼变6楼，6楼变5楼，依次往下，而1楼移动到7楼变成顶楼。而当4楼还分割了左右多个窗口时，无法将窗口上下移动，使用命令vim报错。但仍可以将光标切换到4楼以后，在4楼内部移动4楼分割的左右窗口。</p>\n<p>窗口左右分布时类似，窗口可以在左右间移动，而某个窗口内部还分割了上下窗口时，使用命令报错。逆顺序类似，移动方向相反。</p>\n\n##### 关闭分屏\n<ul>\n<li><span class=\"strong\">c&emsp;&emsp;关闭当前窗口，只剩一个时无法使用</span>(close)</li>\n<li><span class=\"strong\">q&emsp;&emsp;关闭当前窗口，只剩一个时退出vim</span>(quit)</li>\n<li><span class=\"strong\">o&emsp;&emsp;关闭其他窗口</span>(other)</li>\n</ul>\n\n### 标签(tab)\n标签类似于在浏览器中打开多个网页,会在窗口顶部列出各个标签,标签相当于一个vim\n<ul>\n<li><span class=\"strong\">:tabnew [标签名]&emsp;&emsp;创建一个对应名字的新标签</span>(标签名省略时创建一个无名标签)</li>\n<li><span class=\"strong\">:tabc&emsp;&emsp;关闭当前标签</span></li>\n<li><span class=\"strong\">:tabn&emsp;&emsp;切换到下一个标签</span></li>\n<li><span class=\"strong\">:tabp&emsp;&emsp;切换到上一个标签</span></li>\n<li><span class=\"strong\">:tabs&emsp;&emsp;查看一共有几个标签</span></li>\n<li><span class=\"strong\">gt&emsp;&emsp;依次在标签间切换</span>(在命令模式下)</li>\n<li><span class=\"strong\">数字gt&emsp;&emsp;切换到对应顺序的标签中</span></li>\n</ul>\n\n\n### 执行Linux命令\n<ul>\n<li><span class=\"strong\">:!Linux命令&emsp;&emsp;让vim执行Linux命令</span>(执行完Enter会返回文件)</li>\n<li><span class=\"strong\">:r&nbsp;!Linux命令&emsp;&emsp;让vim执行Linux命令并添加执行结果到光标处</span></li>\n</ul>\n\n### 定义字符串快捷输入(ab)\n用于需要频繁输入某个长字符串时，使用一个较短的字符串快速打出该长字符串\n<ul>\n<li><span class=\"strong\">:ab 短字符 长字符串&emsp;&emsp;定义一个长字符串快捷输入</span></li>\n</ul>\n<div class=\"show\" style=\"word-break: break-all;\"><code>如：当需要频繁输入邮箱时，可以用一个短字符串定义邮箱地址\n:ab gmail sheiyoubingbayouxiangxiezhemechang@Gmail.com\n之后只需输入gmail空格或者回车，vim会自动补全该长字符串</code></div>\n\n### 使用寄存器\n使用复制粘贴时，vim是将内容缓存在寄存器中。用户可以自定义寄存器，vim中使用<span class=\"tips\">\"字母</span>来定义一个该字母(大小写均可)命名的寄存器，寄存器后往往加上具体命令，空定义寄存器无效。\n<ul>\n<li><span class=\"strong\">\"字母yy&emsp;&emsp;复制当前行到该寄存器中</span></li>\n<li><span class=\"strong\">\"字母p&emsp;&emsp;从该寄存器中取出内容并粘贴</span></li>\n<li><span class=\"strong\">:reg&emsp;&emsp;列出所有寄存器</span></li>\n<li><span class=\"strong\">:reg 字母&emsp;&emsp;查看对应寄存器中内容</span></li>\n<li><span class=\"strong\">“”&emsp;&emsp;定义一个无名寄存器</span>(使用复制粘贴时vim启用的是该寄存器)</li>\n</ul>\n\n### 定义快捷键\n自定义一个用于某个操作的快捷键\n<ul>\n<li><span class=\"strong\">:map key value&emsp;&emsp;使用快捷键key快速执行value的步骤</span></li>\n</ul>\n快捷键通常使用<span class=\"tips\">Ctrl+某个不冲突的按键</span>，而定义时该组合按键时需要通过<span class=\"tips\">Ctrl+v+该按键</span>来输入\n\n<div class=\"show\" style=\"word-break: break-all;\"><code>如：将某行代码注释掉\n输入的命令为 :map Ctrl+v+/ I#&lt;esc&gt;\n命令就会定义Ctrl+/为快捷键,执行的操作为:在行首插入(I的功能)#号,然后esc退出编辑模式,即以后只需要按下Ctrl+/就可以在当前行首插入#号把当前行注释掉(同vscode里的注释快捷键)</code></div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n:map 命令的应用很广</div>\n\n### 结语\nvim还有其他诸如宏定义、运用插件等能显著提升效率和编程体验的功能，再展开文章就显得有点冗长了，边写边设计样式人麻了，文中可能存在错误。","tags":["Linux","vim"]},{"title":"听歌软件推荐-Spotify","url":"/blog/2021/06/01/spotify推荐/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nSpotify官方信息可能随时会变化，本文部分信息可能过时，请以官方信息为准，但是注册、使用步骤都是大同小异的</div>\n<h3>关于Spotify</h3>\n<p>Spotify创立于瑞典，是目前全球最大的在线音乐流服务商,得到了华纳音乐集团、环球音乐集团、索尼音乐娱乐、Kakao M和腾讯音乐娱乐集团等唱片公司的合作授权，所以曲库非常齐全。Spotify暂未进入中国大陆市场，不过不妨碍软件的正常使用。</p>\n<h3>与国内音乐软件比对</h3>\n<p>先来说说Spotify的优点吧</p>\n<h5>1. 齐全的曲库</h5>\n<p>国内的歌很容易出现版权被某家平台买断的情况，想听喜欢的歌可能得好几个平台才能找齐，听歌时还得好几个APP切来切去，甚至要在好几个平台开VIP。平台自己的恶性竞争还要消费者来买单，这能惯着他们？\n另外一方面，国内的音乐也很容易出现被人恶意举报而惨遭下架的情况。比如说嘻哈音乐，在diss某些流量idol后，会出现被其粉丝恶意举报后惨遭下架的情况。\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n“DISS不过是种切磋但那些明星雇佣的水军总想方设法要把对方逼死”</div>\n<p>对于Spotify就不存在这个问题了，很多国内下架的专辑你仍然可以在Spotify上找到，拥有极为齐全的版权和曲库。如果你是嘻哈音乐，欧美音乐爱好者，Spotify绝对不会让你失望。当然，Spotify本身没有进入大陆市场，很多小众的华语音乐还是只能在国内APP上找到。</p>\n<h5>2. 开通Premium后就不用再买专辑</h5>\n<p>Premium相当于开通Spotify的VIP，国内在开通VIP后，很多专辑还需要单独付费购买才能听，在Spotify中无需再购买专辑，专辑费用不用额外出了。</p>\n<h5>3. 优秀的音乐推荐算法</h5>\n<p>Spotify的音乐推荐算法也是网上经常被人称赞的闪光点，它会定期制作made for you歌单推荐音乐，国内的音乐软件也有类似的功能，但国内的推荐老会有奇奇怪怪的歌混在里面，感觉Spotify的推荐算法更精准点。</p>\n<h5>4. 支持手机端和PC端相互操控</h5>\n<p>当使用电脑听歌时，打开手机端的Spotify会同步电脑端的状态，反过来也如此。你可以使用手机来控制电脑端进行切歌，调节音量等操作，有些鸡肋，可能我没学会正确的打开方式......在家搞家务使用电脑的音箱外放时，就不用跑到电脑面前切歌了。</p>\n<h5>5. 没有乱七八糟的直播、短视频推送</h5>\n<p>作为音乐软件，Spotify拥有的就是安安静静听歌，没有什么直播、小视频、商店等乱七八糟的功能，也不会有那些乱七八糟的主播推荐。不过不开VIP的话每隔15分钟会推送一次广告，这个后面详细说付费和免费的区别。</p>\n<h5>6. 舒适的UI界面</h5>\n<p>不得不说，歪果仁对于UI设计、无障碍设计还是很有心得的，Spotify的界面用的是真的很舒服。</p>\n<h6>其他优点自己去体验一下吧，接下来再说说用惯了国内的软件可能会觉得不习惯的点</h6>\n<h5>1. 部分地区不支持显示歌词</h5>\n<p>日区、港区可以显示歌词，但是美区账号没有歌词显示功能，只能借助Musixmatch、LyricsX等软件，Musixmatch会自动识别Spotify当前播放的音乐自动匹配歌词。Musixmatch本身是免费的，付费版支持更多花里胡哨的歌词显示方式，1美元可以永久解锁付费版。</p>\n<h5>2. 不支持评论</h5>\n<p>不能到点上号开哭了。</p>\n<h5>3. 注册、登录账号时需要魔法工具加持</h5>\n<p>Spotify没有进入大陆市场，而且注册账号时官方使用的是谷歌的人机验证，而国内的网络无法加载谷歌的服务，所以注册账号的时候会有点麻烦，但注册完以后听歌是全程可以用国内的网络环境的。</p>\n<h5>4. 官方开通Premium贵</h5>\n<p>印度、菲律宾等东南亚区的账号开通Premium比较便宜，美区账号每个月的费用是$9.99美刀，折合人民币大约64.4元每个月，情侣套餐包含两个账号12.99美元一个月，折合人民币83.7元一个月，一个账号就是42块左右，家庭组包含6个账号15.99美元每个月，折合人民币103元每个月，一个账号均摊下来17块左右，另外有学生套餐，但是天朝的学生不能用。这价格相较于国内的平台来说就有点贵了。</p>\n<p>所以很多人一般都是开通的东南亚国家的Premium，开通美区账号一般都是组队开家庭组。</p>\n<h3>注册与使用</h3>\n\n<h5>1. 注册账号</h5>\n<p>因为Spotify没有进入大陆的市场，所以注册时需要魔法工具，如果不使用魔法工具当他检测到你的IP地址是来源于中国大陆，就会提示<span class=\"tips\"> \"Spotify is currently not available in your country\"</span>，所以需要魔法将我们的IP地址伪装成其他地区，国内香港、澳门、台湾都行，国外随便一个国家都行。</p>\n<p>传送过去后，登录Spotify的官网 <a href=\"https://www.spotify.com\" target=\"_blank\">https://www.spotify.com</a>，然后点右上角的Log in，然后点击注册一个账号，填写邮箱、密码、用户名、生日等信息(生日可以乱填但记得填18岁以上，不然有些带脏标的歌会听不了)，填完有个google的reCAPTCHA人机验证，这个服务的域名在国内是被墙的，同样需要魔法工具才能打开。网上好像也有不需要魔法工具就能打开reCAPTCHA的教程，我没自己试过，不知道在Spotify里有没有效，没有魔法工具的找身边有的人帮忙注册一下。去Spotify的贴吧、豆瓣小组好像有好心人帮人免费注册，但注意防骗，要钱的就不要理了。最省事的方法就是某宝某多买个号(基本上去他们那里买Premium就会送号)，然后改邮箱就行，注意防骗！！！！！</p>\n<p>注册后官方会发一封邮件验证邮箱,点一下<span class=\"tips\"> CONFIRM YOUR ACCOUNT </span>完成认证即可，注册完的账号有7天体验期可以任意听歌、切歌。</p>\n<p>在使用魔法工具时，有些魔法工具会被提示Spotify检测到正在使用代理工具，要求关闭代理再进行操作。这估计是以前有哪个憨皮拿这个IP批量注册过Spotify账号，IP被官方记录了，把工具切换到全局模式再试试，或者把广播IP地址换成原生IP，如果还是不行那只能换个IP了。</p>\n<h5>2. 分区</h5>\n<p>Spotify为全球很多国家和地区提供服务，所以他的账号是分区的，国内常用的区域有美区、日区、港区、菲律宾区、俄区、马来西亚、印度的一些东南亚的区,账户区域不同，曲库内容、歌单、界面UI、付费价格也不同。</p>\n<p>注册账号时，如果挂的美国的代理，就会进美区的官网，其他同理。具体进了什么区看页面语言，或者地址栏URL路径就可以了，如美区URL为：\n<div class=\"code\">https://www.spotify.com/us/</div>\n<p>但这个后期可以改的，所以注册时哪个区都无所谓，但是买Premium时，买完就不能改了，所以想好买哪个区的Premium，给个常用的几个区对比：</p>\n</p>\n<ul>\n<li><h6>曲库</h6>\n美区的曲库相对较全，但如果喜欢ACG音乐、日语歌那肯定去日区，其他同理。但Spotify的曲库判定有点迷，有些日语歌或者韩语歌你无法在日区找到，但是美区或其他区却有，不过这毕竟还是少数。\n</li>\n<li><h6>歌词</h6>\n美区是没有歌词的，得借助其他软件，日区、港区、俄区还有一些东南亚区有歌词。</li>\n<li><h6>订阅价格</h6>\n下面是部分区折算成人民币后的价格，一般东南亚区的比较便宜\n <div class=\"table\">\n    <table>\n        <thead>\n            <tr>\n                <th>区</th>\n                <th>个人</th>\n                <th>家庭组(6个账号)</th>\n            </tr>\n        </thead>\n        <tbody>\n          <tr>\n              <td>香港</td>\n              <td>51元</td>\n              <td>77.5元</td>\n          </tr>  \n          <tr>\n            <td>美区</td>\n            <td>65元</td>\n            <td>102.5元</td>\n        </tr>\n        <tr>\n            <td>日区</td>\n            <td>63元</td>\n            <td>95元</td>\n        </tr>\n        <tr>\n            <td>菲律宾</td>\n            <td>17元</td>\n            <td>26元</td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n\n   <div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n仅作参考，实际价格以Spotify官网发布的价格为准</div>\n</li>\n</ul>\n<h5>2. 关于Premium</h5>\n<p>即付费版，新注册的账号有7天的付费版体验期。如果第一次开Premium则会送一个月的体验期，免费版和付费版的区别在于\n<ul>\n<li>手机端免费版只能随机播放，而且只能切6次歌，即你不能想听啥就点啥听，只能听它随机播放的，听一半不想听了想点下一曲只有6次机会，6次以后就只能等它放完(不知道那个天才想出来的设定，真想给他寄点土特产)，网页版和PC端的好一点，能切歌但只能随机播放(老式收音机)，付费版可以任意播放、切换歌</li>\n<li>免费版在听歌过程中会有广告，付费版没有</li>\n<li>音质有区别，免费版比特率在160kbit/s，付费版的比特率在320kbit/s</li>\n</ul></p>\n<h5>3. 开通Premium的小tips</h5>\n<p>直接开个人账号太贵了，常见的方法就是去贴吧、豆瓣小组找人一起开家庭组，这里常年会有车队等着拉人，注意防骗！！！因为一个家庭组里有一个管理员账号，他可以随时把家庭成员踢出去，交了钱隔天就被踢很常见。要是周围用的人多，熟人约好几个人一起开稳妥一点。</p>\n<p>还有一个方法就是去某宝续费，注册有问题的也可以直接在他们手上买号，然后把邮箱换成自己的，同样要注意防骗问题。费用大概是15、20块三个月这样，每家店都不一样。</p>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n一定要去开店年份较高，回头客多的店铺买，开店时间短、评论没几个那种很有可能是以前跑路了，开家新店铺再来割一波韭菜，指不定哪天就找不到店家了</div>\n<h5>4. 踩过的坑</h5>\n<p>某宝的方法也是拉家庭组，然后利用绑信用卡免费1个月等官方优惠赚取差价。但是经常会遇到你买完以后没几个星期就把你踢出家庭组，然后商家跑路，连店铺都找不到那种.....所以在某宝续费，要选那些开店年份长的的店铺，至少说明人家不跑路。</p>\n<p>跑路的最坏结果就是，如果你多次买了家庭组，然后被踢，又买再被踢，官方检测到你的账号短期内加入了众多不同的家庭组，可能会被封禁。并且有些店家的家庭组，是盗取了国外的账号然后拉你进家庭组，一旦国外的号主发现了，向官方反馈后可能直接会被封禁。\n我的上一个账号就是在某宝续费之后，某天登录时提示无效的账户，去某宝看店家已经跑路了，汤都没留一口.......找Spotify客服客服表示需要提供付费账单才能提供帮助......可是我的付费都付给了某个天萨的卖家，哪有什么账单.......无奈只能放弃那个账号了，可惜了收藏多年的广场舞神曲。。</p>\n\n### 总结\n注册：\n1.自己有魔法工具自己注册；\n2.没有魔法工具就去贴吧、豆瓣看看能不能找人帮忙注册；\n3.或直接去某宝、某多直接买Premium让店家帮忙注册；\n4.都不行可以写邮件给我，让我看看是谁这么笨；\n可以先注册用一个星期体验一下，spotify有一个星期的新号体验期，觉得好用再去某宝开Premium或去贴吧、豆瓣找人合作开家庭组。\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n注册或者使用中有啥问题，可以去Spotify贴吧，或者去豆瓣小组找找攻略，需要帮忙可以给我写邮件</div>\n","tags":["life","Music"]},{"title":"一款毫米波不等分功分器","url":"/blog/2021/05/29/5G功分器/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n和普通的微波器件相比，5G通讯系统中微波器件的结构参数都是毫米级的，改一点点模型参数结果就完全不一样了，带宽又难做大，每一个参数需要重复优化很久才能满足5G通信的需求。\n</div>\n\n### 5G通讯系统\n现在有越来越多的数字终端接入到移动网络中，比如手机、平板、车载AI、远程监控设备等等，全球对移动通信的需求和要求也越来越高了。为了满足未来的更多需求，5G通讯系统中，毫米波成为了传输高质量数据流的主要载体，毫米波频段在30GHz到300GHz之间，世界无线电通信大会提议使用24GHz—86GHz之间的频段作为5G通信频率。\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n数据来源：Hidayat Ullah. Further Notice of Proposed Rulemaking in the Matter of Use of Spectrum Bands Above 24 GHz for Mobile Radio Services [C]. Int. Telecommun. Union-Radiocom Sector. 2016.</div>\n<p>但是，毫米波能实现高速率传输带来的代价就是，由于其频率高、波长短等特性，其对应的微波器件尺寸很小，微小的尺寸差异都会为通信系统带来巨大影响，因此用在毫米波通讯系统中的器件对设计要求和加工工艺要求都很高。并且，毫米波在传播过程中损耗很大，信号衰减较快，并且易受阻挡，地形、建筑物、丛林甚至于雨水都会使毫米波的传输产生很大的衰减，因此5G天线的设计既要有大带宽保证通讯速率，还要有高增益保证毫米波的有效传输，并满足其他电参数性能。如此苛刻的要求，单独的天线单元往往是做不到的，现实生活中通讯系统中的天线往往由天线阵列组成。一款5G手机中的天线数量往往多达十多根，用于负责蓝牙、WLAN、NFC、2-5G等不同频段的通讯，而负责5G通讯的天线也往往是一组天线阵列，将手机信号传输到天线阵列就需要用到功分器的设计了。</p>\n\n### 功分器\n功分器是一种主要用于无线电技术领域的无源设备，在微波、射频电路中，有时需要将功率按一定的比例分成两路或多路输出，此时就需要用功率分配器来实现。功率分配器的技术指标主要包括工作频率范围、分配损耗、插入损耗、隔离度等，这几个常用参数的大致定义如下：\n\n<span class=\"strong\">分配损耗：</span>定义P<sub>in</sub>为功分器的输入功率，P<sub>out</sub>为功分器某一输出端口的输出功率，则该端口的分配损耗为:\n<div class=\"formula\">A<sub>d</sub>=10 lg(P<sub>in</sub>/P<sub>out</sub>)</div>\n<p><span class=\"strong\">插入损耗：</span>由输入端驻波比带来的损耗，一般是由于微带线导体介质不理想等因素造成的，设实际测量值为A，则插入损耗A<sub>i</sub>为:</p>\n<div class=\"formula\">A<sub>i</sub>=A-A<sub>d</sub></div>\n<p><span class=\"strong\">隔离度：</span>一般情况下，若信号从支路端口的输入，应当从主路端口输出，若大部分能量能从主路端口输出出来，说明功分器的隔离度较好。i端口与j端口的隔离度定义为：</p>\n<div class=\"formula\">A<sub>ij</sub>=10 lg(P<sub>ini</sub>/P<sub>outj</sub>)</div>\n<p><span class=\"strong\">驻波比：</span>电压驻波比指驻波波腹电压与波节电压幅度之比，又称为驻波系数。当驻波比等于1时，表明端口输入输出阻抗匹配，此时高频能量完全输入到了电路中，没有能量的反射损耗，一般为理想情况，实际的驻波比应尽量接近1。</p>\n\n### 威尔金森功分器\n在微波电路中，阻抗不匹配会导致信号反射，反射的信号会干扰其他正常信号的传输，比如1端口的信号会反射到2端口来，影响2端口的信号传输，衡量这一现象的参数是上面提到的隔离度，1-2端口隔离度越好，说明这个两个端口越不容易相互干扰。一般的功分器结构隔离度有可能不太理想，而威尔金森功分器就是为了解决这一问题而设计出来的，功率分配器可由不同的元件组合成不同的形式，威尔金森功分器的原始模型是同轴线形式，因具有良好的隔离度在微带和带状线结构上得到了广泛应用，如下为两路威尔金森功分器示意图：\n\n<img data-src=\"/blog/images/wilkinson.jpg\" src=\"#\" tlt=\"威尔金森功分器\" title=\"威尔金森功分器\">\n<p>威尔金森功分器的设计需要借助微带线尺寸计算工具，根据功分器各部分阻抗值计算各部分的结构尺寸。多路功率分配器的设计，可以直接设计为多路输出，也可以采用两路功率分配器的级联形式，即一分二，二分四……上下两级的功分器之间一般需要加上阻抗匹配元件。</p>\n\n### C语言计算威尔金森功分器尺寸\n对于规模较大的天线阵列，往往需要使用多路威尔金森功分器。为了保证通讯系统的稳定性，阵列的带宽、增益、主瓣宽度、副瓣电平等电性能参数都要满足一定的指标，因此阵列往往需要切比雪夫等算法加持，由此设计出来的激励分布往往也是不等分的，因此相应的功分器分配比也要是不等分的，再使用两路功率分配器的级联形式，组合成功分器网络。\n<p>根据功率分配比计算阻抗的过程需要重复用到威尔金森(Wiljinson)功率分配器的设计步骤和计算过程，计算过程繁杂且容易出错，借助C语言来简化这个过程。</p>\n<pre><code class=\"hljs language-c\">#include&lt;stdio.h&gt;\n#include&lt;float.h&gt;\n#include&lt;math.h&gt;\n#define Z0 50//输入阻抗\ntypedef struct design {\n\tfloat ants[8];//阵列\n\tstruct data {//介质板参数\n\t\tfloat Er;\n\t\tfloat Mur;\n\t\tfloat H;\n\t\tfloat Hu;\n\t\tfloat T;\n\t\tfloat TanD;\n\t};\n }antenna;\n int main(void) {\n\tantenna Yagi;\n\tYagi.Er = 2.2;\n\tYagi.Mur = 1;\n\tYagi.H = 0.254;\n\tfloat num1, num2,k2,k3,result1,z02,z03,R;\n loop:printf(\"输入功率分配比:\\n\");\n\tprintf(\"p1值：\");\n\tscanf_s(\"%f\", &num1);\n\tprintf(\"p2值：\");\n\tscanf_s(\"%f\", &num2);\n\tprintf(\"验算过程：\\n\");\n\tprintf(\"--------------\\n\");\n\tprintf(\"功率分配比：  %.2f:%.2f\\n\", num1, num2);\n\tk2 = num2 / num1;\n\tprintf(\"k方值为:%f\\n\", k2);\n\tresult1 = 1 + k2;\n\tprintf(\"非归一化比值为:%f\\n\", result1);\n\tk3 = (float)pow(k2, 1.5);\n\tprintf(\"非归一化比值验算分母:%f\\n\", k3);\n\tprintf(\"开根:%f\\n\", result1/k3);\n\tz03= (float)(pow(result1 / k3,0.5)) * Z0;\n\tz02= (float)(pow(pow(k2, 0.5) * result1, 0.5)) * Z0;\n\tR = result1 / pow(k2, 0.5) * Z0;\n\tprintf(\"--------------\\n\");\n\tprintf(\"计算得的阻抗值为\\n\");\n\tprintf(\"Z03=%.2fΩ  Z02=%.2fΩ\\n\", z03, z02);\n\tprintf(\"隔离电阻:\");\n\tprintf(\"R=%.2fΩ\\n\", R);\n\tprintf(\"**************************************\\n\");\n\tgoto loop;\n\treturn 0;\n }\n    </code></pre>\n<p>由代码可分别计算出每一级功分器支节的阻抗值与输出端口的输出阻抗，而由阻抗值借助微波仿真软件的微带线尺寸计算工具，可以计算出各级功分器的结构参数，但该结构参数仅作为初始数据，根据初始参数所建模型的仿真测试结果往往和预期目标相差巨大，需要利用仿真软件进行多次迭代优化。为了和阵列结构相匹配，功分器网络的结构需要进行拐角、切角等处理，整体设计完的功分器网络可能长这样</p>\n<img data-src=\"/blog/images/wilkin.jpg\" src=\"#\" alt=\"不等分功分器馈电网络\">\n<p>经过上百次的迭代优化后，利用微波仿真软件查看功分器馈电网络各输出端口的相位，低频时输出端口的相位基本保持一致，高频时会产生部分频偏，但相位偏移不大，并且该部分已经超出天线的有效带宽范围，因此基本能保证功分器输出端口的同相输出。</p>\n<img data-src=\"/blog/images/phase.jpg\" alt=\"相位差\" src=\"#\">\n<p>由于威尔金森功分器加装了隔离电阻，能很好保证各端口间的隔离度基本保持在-15dB以下，所以能确保器件工作时各端口间微波信号的反射干扰不会影响天线阵列的正常工作。</p>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n当初做这个设计的时候，我的一个博士生学长和指导老师都给了我很多帮助，查了很多资料，最后也获得了很不错的成果。\n</div>","tags":["硬件","RF"]},{"title":"正则表达式","url":"/blog/2021/04/13/正则表达式/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n文中所声明对象和语法基于Java和JavaScript</div>\n\n### 正则表达式\n正则表达式，又称为规则表达式（Regular Expression，在代码中常简写为regex、regexp或RE），又称为模式模板(pattern template)，用于描述字符串的某种特殊规则，它可以用来校验某个字符串是否满足该规则，或对符合该规则的字符串进行提取、删除、替换等操作。\n<span class=\"strong\">常见应用</span>\n<ul>\n<li>设置密码时：\"请至少设置8位以上且同时包含数字、大小写字母和特殊字符\"(限制用户所输入字符串的复杂度以提高密码强度)</li>\n<li>从爬虫中提取有效手机号、邮箱号等有效信息</li>\n<li>在Linux中配合sed、awk等命令进行文本处理</li>\n<li>....</li>\n</ul>\n\n#### 正则表达式的类型\n正则表达式是通过正则表达式引擎(regular expression engine)实现的。正则表达式引擎是一套底层软件，负责解释正则表达式模式并对数据进行模式匹配，有两个主流的正则表达式引擎：\n+ 基础正则表达式（basic regular expression，BRE）引擎\n+ 扩展正则表达式（extended regular expression，ERE）引擎\n\n传统的UNIX工具出于速度考虑，只支持BRE引擎规范，如果需要使用拓展正则表达式需要使用特殊选项，如：sed编辑器(根据不同版本使用-r或-E选项启用ERE)，grep命令(使用-E选项启用ERE)\n\n而现代的编程语言和工具基本都提供了支持ERE 语法的工具，如：Java的java.util.regex包、C语言的&lt;regex.h&gt;头文件、JavaScript、MySQL数据库等\n\n\n### 语法\n#### 方括号 [ ]\n方括号用于查找某个范围内的字符，括号内内容是<span class=\"tips\">或</span>的关系\n<div class=\"show\"><code>[a-z]   是否含有任意的小写字母\n[A-Z]   是否含有任意的大写字母\n[A-z]   是否含有任意字母\n[0-9]   任意数字\na[bde]c 检查是否含有abc或adc或aec</code>\n</div>\n\n\n#### 与(&&)、或(|)、非(^)\n逻辑运算符\n##### 与 &&\n单个的<span class=\"tips\">&</span>代表检测字符串中是否含有 \"&\" 这个符号，短路运算符<span class=\"tips\">&&</span>才是将前后两个表达式做与运算\n<div class=\"show\"><code>[a-z&&[def]]  仅匹配d或e或f字符\n[a-z&[def]]  匹配a-z和&字符\n[a-z&&[^m-p]]  a-z且不包含m-p的集合(等同于[a-lq-z])\n</code></div>\n\n##### 或 |\n由于使用<span class=\"tips\">[ ]</span>也表示逻辑或，因此当或符号位于 [ ] 内时 | 可以省略\n\n<div class=\"show\"><code>a|b等同于[ab]   查询字符串内是否含有a或b字符\n(\\d|X|x)等同于[\\dXx]   匹配身份证号最后一位(数字或者X、x)，在Java中由于\\转义，需要写为[\\\\dXx]\n[a-c|e-g]可简写为[a-ce-g],也可写为[a-c[e-g]]\n</code></div>\n\n<div class=\"show\"><code>0[1-9]|1[0-2]  匹配月份01-09,10-12\n0[1-9]|[12]\\d|3[01] 匹配日期01-09,11-29,30,31\n</code></div>\n\n##### 非 ^\n取反运算\n<div class=\"show\"><code>[^abc]  代表abc以外的任意字符\n[a-z&&[^m-p]]  a-z且不包含m-p的集合(等同于[a-lq-z])\n</code></div>\n\n\n### 量词\n#### n? 0个或1个n\nn?匹配只能包含0个或1个n的字符串，字符串中要么没有n，要么只能有一个n\n<div class=\"show\"><code>let reg=/ab?c/;    //只能匹配ac、abc\n</code></div>\n\n#### n*  0个、1个或多个n\nn*匹配包含0个、1个或多个n的字符串，即有无n都可以，相当于<span class=\"tips\">{0,}n</span>\n<div class=\"show\"><code>let reg=/ab*c/;    //匹配ac、abc、abbbbbc等b可有可无，或包含多个b的字符串</code></div>\n\n#### n+ 至少1个n\n匹配包含至少有一个字符n的字符串，相当于<span class=\"tips\">{1,}n</span>\n<div class=\"show\"><code>let reg=/ab+c/;    //匹配abc等b出现1次及1次以上的字符串</code></div>\n\n#### {x} 匹配出现x次的字符串\n指定一个内容出现的次数，注意：它只对它之前的一个内容起作用，多个内容重复应该使用<span class=\"tips\">( )</span>包裹\n<div class=\"show\"><code>let reg=/a{3}/;    //匹配aaa\nlet reg2=/ab{3}/;  //匹配abbb\nlet reg3=/(ab){3}/; //匹配ababab\n</code></div>\n\n#### {x,y} 匹配出现x至y次的字符串\n<div class=\"show\"><code>let reg=/ab{1,3}c/;    //匹配abc、abbc、abbbc</code></div>\n\n#### {x,} 匹配出现的字符串大于等于x次的字符串\n<div class=\"show\"><code>let reg=/ab{3,}c/;    //匹配abbbc等b出现3次及3次以上的字符串</code></div>\n\n### 元字符与转义\n#### 元字符\n元字符即正则表达式中一些用于特殊用途的字符\n<div class=\"table\">\n<table>\n    <thead>\n        <tr>\n            <th>元字符</th>\n            <th>描述</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><span class=\"strong\">.</span></td>\n            <td><span class=\"strong\">查找单个任意字符，除了换行和行结束符</span></td>\n        </tr>\n         <tr>\n            <td><span class=\"strong\">\\w</span></td>\n            <td><span class=\"strong\">查找单词字符</span>(任意字母、数字、下划线_)</td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\W</span></td>\n            <td><span class=\"strong\">查找非单词字符</span>(除字母、数字、下划线_以外的字符)</td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\d</span></td>\n            <td><span class=\"strong\">查找数字</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\D</span></td>\n            <td><span class=\"strong\">查找非数字字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\s</span></td>\n            <td><span class=\"strong\">查找空白字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\S</span></td>\n            <td><span class=\"strong\">查找非空白字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\b</span></td>\n            <td><span class=\"strong\">匹配单词边界</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\B</span></td>\n            <td><span class=\"strong\">匹配非单词边界</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\o</span></td>\n            <td><span class=\"strong\">查找 NUL 字符(字符串结束字符)</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\n</span></td>\n            <td><span class=\"strong\">查找换行符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\f</span></td>\n            <td><span class=\"strong\">查找换页符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\r</span></td>\n            <td><span class=\"strong\">查找回车符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\t</span></td>\n            <td><span class=\"strong\">查找制表符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\v</span></td>\n            <td><span class=\"strong\">查找垂直制表符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\xxx</span></td>\n            <td><span class=\"strong\">查找以八进制数 xxx 规定的字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\xdd</span></td>\n            <td><span class=\"strong\">查找以十六进制数 dd 规定的字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\uxxxx</span></td>\n            <td><span class=\"strong\">查找以十六进制数 xxxx 规定的 Unicode 字符</span></td>\n        </tr>\n    </tbody>\n</table>\n</div>\n\n#### 转义字符\n由于<span class=\"tips\">.*?+|^&\\\\()[]{}</span>字符已作为关键字使用，因此如匹配小数点等功能需要用到转义，正则表达式中使用<span class=\"tips\">&#92;</span>作为转义字符。此外，由于Java中的正则表达式规则以字符串形式表示，而字符串中<span class=\"tips\">&#92;</span>也为转义字符，因此往往需要两个转义字符<span class=\"tips\">\\\\\\\\</span>进行二次转义，如：查找数字 \\d，在Java的正则表达式中需要写为<span class=\"tips\">\\\\\\\\d</span>，其他元字符同理。\n\n\n\n<div class=\"show\"><code>let reg=/\\./;  //使用转义字符匹配字符串中的.号，如匹配小数点</code></div>\n\n### 字符串位置\n#### 常用位置\n<ul>\n<li><span class=\"strong\">^n &emsp;&emsp;匹配以 n 开头的字符串</span></li>\n<li><span class=\"strong\">n$ &emsp;&emsp;匹配以 n 结尾的字符串</span></li>\n<li><span class=\"strong\">^n|n$ &emsp;匹配以n开头或以n结尾的字符串</span></li>\n<li><span class=\"strong\">^n$ &emsp;&emsp;以n开头马上以n结尾,因此只能匹配到\"n\"</span></li>\n<li><span class=\"strong\">?=n &emsp;&emsp;匹配所有其后紧接指定字符串 n 的字符串，但不存储 n 的值</span></li>\n<li><span class=\"strong\">?:n &emsp;&emsp;匹配所有其后紧接指定字符串 n 的字符串，并存储 n 的值</span></li>\n<li><span class=\"strong\">?!n &emsp;&emsp;匹配所有其后没有紧接指定字符串 n 的字符串</span></li>\n</ul>\n\n<div class=\"show\"><code>let str=\"java自从95年问世以来，经历了很多版本，如：Java5,Java6...其中用的最多的是JAva8和JAva11，下一个长期支持版本是JAVA17\";\nlet reg12=/java(?=8|11|17)/ig;\nlet reg13=/java(?:8|11|17)/ig;\nlet reg14=/java(?!8|11|17)/ig;\nconsole.log(str.match(reg12)) //[ 'JAva', 'JAva', 'JAVA' ]\nconsole.log(str.match(reg13)) //[ 'JAva8', 'JAva11', 'JAVA17' ]\nconsole.log(str.match(reg14)) //[ 'java', 'Java', 'Java' ]\n</code></div>\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n^n和n$可理解为开头后紧接字符n,结束前紧接字符n,因此^n$表示开头后紧接这字符n，马上紧接这结束符号，因此只能匹配字符n自己</div>\n\n#### 前瞻断言与后顾断言\n\n+ <span class=\"strong\">x(?=n) &emsp;&emsp;查找n前的x</span><span class=\"tips\">(前瞻)</span>\n+ <span class=\"strong\">(?<=n)x &emsp;查找n后的x</span><span class=\"tips\">(后顾)</span>\n+ <span class=\"strong\">x(?!n) &emsp;&emsp;查找后面不是n的x</span><span class=\"tips\">(负前瞻)</span>\n+ <span class=\"strong\">(?&lt;!n)x &emsp;查找前面不是n的x</span><span class=\"tips\">(负后顾)</span>\n\n<pre><code>import java.util.regex.Pattern;\npublic class RegexTest {\n    public static void main(String[] args) {\n        String str=\"java自从95年问世以来，经历了很多版本，如：Java5,Java6...其中用的最多的是JAva8和JAva11，\" +\n                \"下一个长期支持版本是JAVA17\";\n        String reg1=\"(?i)java(?:\\\\d*)\";\n        String reg2=\"(?i)(?<=java)\\\\d*\";\n        Pattern p1=Pattern.compile(reg1);\n        Pattern p2=Pattern.compile(reg2);\n        Matcher m1=p1.matcher(str);\n        Matcher m2=p2.matcher(str);\n        while(m1.find()){\n            System.out.println(m1.group());//java,Java5,Java6,JAva8,JAva11,JAVA17\n        }\n        System.out.println(\"------------M2\");\n        while(m2.find()){\n            System.out.println(m2.group());// 5,6,8,11,17\n        }\n    }\n}\n</code></pre>\n\n\n\n\n#### 单词边界\n\n+ <span class=\"strong\">\\b</span>&emsp;&emsp;匹配一个单词边界\n+ <span class=\"strong\">\\B</span>&emsp;&emsp;匹配一个非单词边界\n\n\n当一个字符串本身刚好是另外一个字符串一部分时，如：child为children的一部分，需要使用单词边界来进行限定\n\n<div class=\"show\"><code>let reg=/\\bchild\\b/;\nconsole.log(reg.test(\"eg children\")); //false </code></div>\n\n定义中单词的组成可以为字母、数字、下划线，即元字符中的<span class=\"tips\">\\w</span>，非单词为字母、数字、下划线以外的字符，即元字符中的<span class=\"tips\">\\W</span>。而边界为一个抽象的概念，并非实际字符，任意两个字符之间都可以视为一个边界。\n\n+ <span class=\"strong\"><span class=\"tips\">\\b</span>用于匹配左右字符类型不相同的边界，即一边字符为\\w，另一边字符为[^\\w]</span>\n\n+ <span class=\"strong\"><span class=\"tips\">\\B</span>用于匹配左右字符类型相同的边界，即两边都是\\w，或者两边都不是\\w</span>\n\n<div class=\"show\"><code>let string=\" at fat sat ate ato _at %at 9at %at& cate _at_ 0at0 \";\nlet re1=/.\\bat\\b./ig;\nlet re2=/.\\Bat\\b./ig;\nlet re3=/.\\Bat\\B./ig;\nlet re4=/.\\bat\\B./ig;\nconsole.log(string.match(re1)) // [ ' at ', '%at ', '%at&' ]\nconsole.log(string.match(re2)) // [ 'fat ', 'sat ', '_at ', '9at ' ]\nconsole.log(string.match(re3)) // [ 'cate', '_at_', '0at0' ]\nconsole.log(string.match(re4)) // [ ' ate', ' ato' ]\n</code></div>\n\n+ 第一个正则表达式中，第一个\\b由于右侧at属于\\w，因此左侧只能为非\\w的字符(包括空格符)，第二个\\b由于左侧at属于\\w，因此右侧也只能为非\\w的字符\n+ 第二个正则表达式中，表达式中\\B由于右侧at属于\\w，因此左侧也需要为属于\\w的字符，表达式中\\b由于左侧at属于\\w，因此右侧只能为非\\w的字符\n+ 第三个正则表达式中，第一个\\B由于右侧at属于\\w，因此左侧也需要为\\w，第二个\\B由于左侧at属于\\w，因此右侧也需要为\\w\n+ 第四个正则表达式中，\\b由于右侧at属于\\w，因此左侧只能为[^\\w]，\\B由于左侧at属于\\w，因此右侧也需要为\\w\n\n\n其他特殊符号同理\n<div class=\"show\"><code>let string=\" &  a&a 0&0 #&#\"\nlet re1=/.\\b&\\b./ig; //由于&为[^\\w]，因此&两侧都需要为\\w\nlet re2=/.\\B&\\B./ig; //由于&为[^\\w]，因此&两侧都需要为[^\\w]\nconsole.log(string.match(re1)) // [ 'a&a', '0&0' ]\nconsole.log(string.match(re2)) // [ ' & ', '#&#' ]\n</code></div>\n\n### 匹配模式\n 匹配模式可以忽略，默认情况下正则匹配会区分大小写，并且将在匹配到第一个结果后停止匹配并返回结果。正则表达式有六个参数用于指定匹配模式，这些参数既可以单独使用也可以任意顺序一起使用。\n\n <ul>\n <li><span class=\"strong\">g &emsp;&emsp;全局搜索</span></li>\n <li><span class=\"strong\">i &emsp;&emsp;忽略大小写</span></li>\n  <li><span class=\"strong\">(?i) &emsp;&emsp;忽略大小写<span class=\"tips\">(java)</span></span></li>\n <li><span class=\"strong\">m&emsp;&emsp;多行搜索</span></li>\n <li><span class=\"strong\">s &emsp;&emsp;允许<span class=\"tips\">.</span>号匹配换行符</span></li>\n <li><span class=\"strong\">u &emsp;&emsp;使用unicode码的模式进行匹配。</span></li>\n <li><span class=\"strong\">y &emsp;&emsp;执行“粘性”搜索,匹配从目标字符串的当前位置开始。</span></li>\n </ul>\n\n<div class=\"show\"><span class=\"tips\">java支持，而javaScript不支持下述写法</span>\n<code>a(?i)bc   忽略bc的大小写\na((?i)b)c  只忽略b的大小写</span></code>\n</div>\n\n### 贪婪爬取与非贪婪爬取\n<span class=\"strong\">贪婪爬取：</span>尽可能多地爬取数据\n\n<span class=\"strong\">非贪婪爬取：</span>尽可能少地爬取数据，一般情况下\n\nJava、JavaScript均默认为贪婪爬取，我们可以在数量词<span class=\"tips\">+</span>、<span class=\"tips\">*</span>后加上<span class=\"tips trong\">?</span>将爬取模式修改为非贪婪爬取\n<pre><code>package regex;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MainTest {\n    public static void main(String[] args) {\n        String str=\"abbbbbbbbbbbcc\";\n        //贪婪爬取\n        String reg1=\"ab+\";\n        Pattern p1= Pattern.compile(reg1);\n        Matcher m1=p1.matcher(str);\n        while (m1.find()){\n            System.out.println(m1.group());//abbbbbbbbbbb\n        }\n        //非贪婪爬取\n        String reg2=\"ab+?\";\n        Pattern p2= Pattern.compile(reg2);\n        Matcher m2=p2.matcher(str);\n        while (m2.find()){\n            System.out.println(m2.group());//ab\n        }\n    }\n}</code></pre>\n\n<pre><code>let str=\"abbbbbbbccccccccc\";\nlet reg1=/ab+/g;\nlet reg2=/ab+?/g;\nconsole.log(str.match(reg1)); //[ 'abbbbbbb' ]\nconsole.log(str.match(reg2)); //[ 'ab' ]\n</code></pre>\n\n### 捕获分组与非捕获分组\n#### 捕获分组\n在正则表达式中，可以使用<span class=\"tips\">( )</span>将语句分组，组号从1开始，分组以左括号为基准，最左边为第一组，其次为第二组，以此类推。\n\n##### 正则表达式内部调用\n\n在正则表达式内部可以使用<span class=\"tips\">\\组号</span>将数据捕获出来，再次调用\n\n<div class=\"show\"><code>(.+).+\\1  匹配诸如 abc123abc、b45b 之类头尾相同的字符串\n((.)\\2*).+\\1    匹配诸如 aa123aa 之类开头字符完全相同，且结尾字符等同于开头字符的字符串\n</code></div>\n\n##### 正则表达式外部调用\n在正则表达式外部可以使用<span class=\"tips\">$组号</span>再次调用捕获的数据，如：在替换语句中调用捕获的数据，将重复的字符替换为单个字符\n\n<div class=\"code\"><code>package regex;\npublic class outRegex {\n    public static void main(String[] args) {\n        String str=\"abbbccccccccdddddddd\";\n        System.out.println(str.replaceAll(\"(.)\\\\1+\",\"$1\")); //abcd\n    }\n}</code></div>\n\n#### 非捕获分组\n使用<span class=\"tips\">(?:)</span>、<span class=\"tips\">(?:)</span>、<span class=\"tips\">(?:)</span>时，()仅用于囊括数据，无法通过<span class=\"tips\">\\组号</span>、<span class=\"tips\">$组号</span>方式调用本组数据，并且非捕获分组不会占用组号\n\n\n### Java中的正则表达式\nJava中的正则表达式规则以字符串形式表示，因此转义字符往往需要两个<span class=\"tips\">\\\\\\\\</span>。此外，Java还提供了<span class=\"tips\">Pattern类</span>和 <span class=\"tips\">Matcher类</span>用于提供正则表达式支持。\n\n#### String类与正则表达式有关的常用方法\n##### public boolean matches(String regex)\n返回boolean值，检测字符串是否匹配该正则表达式\n\n<div class=\"code\"><code>package regex;\npublic class Matches {\n    public static void main(String[] args) {\n        String str=\"(&\\\\*)\\\\1{2}\\\\d+\";\n        System.out.println(\"aaaa\".matches(str)); //false\n        System.out.println(\"&*22\".matches(str)); //false\n        System.out.println(\"&*&*&*222\".matches(str)); //true\n        System.out.println(\"&*&*211\".matches(str)); //false\n    }\n }  \n</code></div>\n\n##### public String replaceAll(String regex,String replacement)\n返回一个String，将字符中所有满足该正则表达式的子字符串替换为指定内容。\n\n与之类似的还有<span class=\"strong\">public String replaceFirst(String regex,String replacement)</span>，用给定的内容替换字符串中第一个满足该正则的子字符串\n\n<div class=\"code\"><code>//字符去重\npackage regex;\npublic class RegexReplaceAll {\n    public static void main(String[] args) {\n        String str=\"abbbccccccccdddddddd\";\n        System.out.println(str.replaceAll(\"(.)\\\\1+\",\"$1\"));\n    }\n}\n</code></div>\n\n##### public String[] split(String regex)\n返回一个String数组，按正则匹配的内容分割字符串，并将剩余内容返回为一个String数组\n\n#### Pattern类与Matcher类\n这两个类位于<span class=\"tips\">java.util.regex</span>包下\n\n<span class=\"strong\">Pattern</span>(模式)类用于将正则表达式编译为此类的实例，即正则表达式的编译表示，该类的构造方法私有，需要通过调用其静态方法<span class=\"tips\">compile(String regex)</span>来创建对象，将给定的正则表达式编译Pattern对象并返回，该类被final修饰，无法被继承。\n\n<span class=\"strong\">Matcher</span>(匹配器)类用于创建文本匹配器对象，执行匹配操作，该类也没有公共构造方法，需要通过Pattern对象的<span class=\"tips\">matcher(String)</span>方法来获得一个Matcher对象，且该类也被final修饰，无法被继承。\n\nMatcher类下常用的方法\n+ <span class=\"strong\">public boolean find()</span> 搜索与正则匹配的目标字符串，返回boolean值\n+ <span class=\"strong\">public String group()</span> 返回上一个匹配的字符串子序列\n\n<pre><code>package regex;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n/**\n*   爬取所有带有java与其版本的信息\n*/\npublic class PatternAndMatcher {\n    public static void main(String[] args) {\n        String str=\"java自从95年问世以来，经历了很多版本，如：Java5,Java6...其中用的最多的是JAva8和JAva11，\" +\n                \"下一个长期支持版本是JAVA17\";\n        String reg=\"(?i)java(?:\\\\d*)\";\n        Pattern p= Pattern.compile(reg);\n        Matcher m=p.matcher(str);\n        while(m.find()){\n            System.out.println(m.group());//java Java5 Java6 JAva8 JAva11 JAVA17\n        }\n    }\n}</code></pre>\n\n\n### JavaScript中的正则表达式\n#### 创建RegExp正则表达式对象\n ###### 1.字面量\n 由斜杠<span class=\"tips\">/</span>包围，语法：<span class=\"strong\">/正则表达式/匹配模式</span>\n <div class=\"show\"><code>let reg=/ab/i</code></div>\n\n###### 2.利用构造函数\n 由引号<span class=\"tips\">\" </span>包围，语法：<span class=\"strong\">let 变量=new RegExp(\"正则表达式\",\"匹配模式\")</span>\n 匹配模式可直接省略，默认情况下匹配到一个结果就返回\n <pre><code>let reg=new RegExp(\"ab\",\"i\")</code></pre>\n\n###### 构造函数中的转义\n由于构造函数中接收的参数为字符串，而字符串中<span class=\"tips\">&#92;</span>也为转义字符，因此在构造函数中使用<span class=\"tips\">&#92;</span>符号需要进行二次转义。如\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\.\"); //编译后的正则表达式为/\\./,即用于匹配小数点</code></div>\n\n\n##### 匹配字符串中是否有<span class=\"tips\">&#92;</span>\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\\\\\\"); //编译后的正则表达式为/\\\\/</code></div>\n<p>错误的语法</p>\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\\");\n //编译后的正则表达式为/\\/，表达式将\\作为转义符号,转义后面的/符号，从而导致正则表达式缺少完整//符号而报错</code></div>\n<p>测试字符串中是否有<span class=\"tips\">&#92;</span>完整代码</p>\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\\\\\\");\n let str=\"abcd\\\\\";\n console.log(reg); //输出/\\\\/\n console.log(str); //输出abcd\\\n console.log(reg.test(str)); //输出true</code></div>\n\n\n#### RegExp对象的常用方法\n##### test() \n在字符串中查找是否有满足正则表达式的值，有则返回<span class=\"tips\">true</span>,无则返回<span class=\"tips\">false</span>。\n<div class=\"code\"><code>let reg=/hello/;\nconsole.log(reg.test(\"xxhelloxx\")); //true</code></div>\n\n在全局匹配模式下，同语句多次调用test()可能会出现返回的boolean值不同的情况\n<div class=\"show\"><code>let reg=/^1[345678][0-9]{9}$/g;\nconsole.log(reg.lastIndex,reg11.test(\"13456789000\")) //0 true\nconsole.log(reg.lastIndex,reg11.test(\"13456789000\")) //11 false\n</code>这是由于RegRxp的lastIndex属性用于保存索引开始位置，第二个语句中lastIndex指向了11，解决方法为：\n    1. 不使用全局匹配\n    2. 在每次匹配前将lastIndex设置为0\n<code>let reg=/^1[345678][0-9]{9}$/g;\nconsole.log(reg.lastIndex,reg.test(\"13228207602\")) //0 true\nreg.lastIndex=0;\nconsole.log(reg.lastIndex,reg.test(\"13228207602\")) //0 true\n</code></div>\n\n##### exec() \n搜索出字符串中与正则表达式匹配的值，如果找到了，返回一个存放了匹配结果、匹配结果的第一个字符位置等信息的数组，如果未找到返回 null 。该方法不常用，搜索字符串常用String对象的match()方法。\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n更多RegExp对象的属性和方法详见W3C标准或MDN的官方文档</div>\n\n#### String对象支持正则表达式的方法\n##### split() 字符串拆分为数组\n按所写正则表达式表达式规则将一个字符串拆分成数组，拆分处字符将丢弃,该方法即使不指定全局匹配，也会自动进行全局匹配，返回数据类型为<span class=\"tips\">Object数组<span>。\n<div class=\"code\"><code>var str=\"1a2b3c4d\";\nconsole.log(str.split(/[A-z]/));//返回['1','2','3','4']</code></div>\n\n##### search() 搜索匹配值\n搜索字符串是否含有指定内容，有则返回第一次出现的索引值(即使为全局匹配也只返回第一次出现的索引值)，没有则返回-1。返回数据类型为<span class=\"tips\">Number<span>\n<div class=\"code\"><code>var str=\"never forget ever\";\nconsole.log(str.search(/ever/));//返回1\nconsole.log(str.search(/f/));//返回6</code></div>\n\n##### match() 找到一个或多个正则表达式匹配\n将符合正则表达式的内容提取出来,默认情况下找到第一个符合的字符就会返回，因此经常配合全局匹配模式。返回数据类型为<span class=\"tips\">Object数组<span>\n<div class=\"code\"><code>var str=\"1a2b3c4d\";\nconsole.log(str.match(/[a-z]/ig));//返回['a','b','c','d']\nconsole.log(str.search(/[0-9]/g));//返回['1','2','3','4']</code></div>\n\n##### replace() 将符合表达式的字符串替换成指定字符串\n用于屏蔽、替换内容，接收两个参数：被替换的内容、新内容，语法为<span class=\"strong\">replace(字符或正则表达式,\"新内容\")</span>。默认只替换第一个符合表达式的内容。返回数据类型为<span class=\"tips\">String<span>\n<div class=\"code\"><code>var str=\"1a2b3c4d\";\nconsole.log(str.replace(/[a-z]/ig,\"*\"));//返回1*2*3*4*\nconsole.log(str.replace(/[0-9]/g,\"\"));//返回abcd</code></div>\n\n#### JavaScript去除空格\n##### 去除字符串中的所有空格\n表达式：<span class=\"strong\">/\\s/g</span>\n<div class=\"code\"><code>let str=\" xxx  xxx \";\nlet str1=str.replace(/\\s/g,\"\"); //输出xxxxxx</code></div>\n\n##### 去除字符串前后的空格，保留字符之间的空格\n表达式：<span class=\"strong\">/^\\s+|\\s+$/g</span>若只去除前或后的空格，取表达式一半\n<div class=\"code\"><code>let str=\" xxx  xxx \";\nlet str1=str.replace(/^\\s+|\\s+$/g,\"\"); //输出xxx  xxx</code></div>\n\n ### 常用正则表达式\n <div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n来源于网课资料，可能存在错误</div>\n<h5>校验数字</h5>\n<p style=\"white-space:pre-wrap;text-indent:0;\">1. 数字：^[0-9]*$\n2. n位的数字：^\\d{n}$\n3. 至少n位的数字：^\\d{n,}$\n4. m-n位的数字：^\\d{m,n}$\n5. 零和非零开头的数字：^(0|[1-9][0-9]*)$\n6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\n8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\n12. 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$\n13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\n16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\n17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n</p>\n<h5>校验字符</h5>\n<p style=\"white-space:pre-wrap;text-indent:0;\">1. 汉字：^[\\u4e00-\\u9fa5]{0,}$\n2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n3. 长度为3-20的所有字符：^.{3,20}$\n4. 由26个英文字母组成的字符串：^[A-Za-z]+$\n5. 由26个大写英文字母组成的字符串：^[A-Z]+$\n6. 由26个小写英文字母组成的字符串：^[a-z]+$\n7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n11. 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+</p>\n<h5>信息</h5>\n<p style=\"white-space:pre-wrap;text-indent:0;\">1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\n3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n5. 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\n6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n7. 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$\n8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\n12. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$\n15. 金额的输入格式：\n    1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$\n    2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$\n    3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$\n    4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$\n    5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$\n    6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$\n    7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$\n    8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$\n16. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n17. 中文字符的正则表达式：[\\u4e00-\\u9fa5]\n18. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n19. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\n20. HTML标记的正则表达式：<(\\S*?)[^>]*>.*?</\\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n21. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n22. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n23. 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\n24. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)\n25. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))</p>\n","tags":["笔记","regex"]},{"title":"JavaScript异步与AJAX","url":"/blog/2021/04/01/JavaScript异步与AJAX/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n文中所声明对象和语法基于javaScript</div>\n\n\n### 迭代器\n迭代器(iterator)是一种可以为各种不同的数据结构提供统一遍历操作的接口，JAVA、C++、Python、PHP等很多语言都有迭代器的概念，对象只要部署了iterator接口，就可以进行遍历操作(如用for语句进行遍历)。\n \n### 迭代器的遍历\n迭代器遍历的原理是这样的：\n<ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置;</li>\n<li>调用指针对象的next方法，指针指向数据结构的第一个成员;</li>\n<li>重复调用next方法，指针后移动，直至指向最后一个成员;</li>\n</ol>\n<p>以最常见的遍历数组为例：我们可以用for…of等语句对其进行遍历，是因为数组中原生内置了iterator接口。</p>\n<pre><code> const songs=['夜曲','手写的从前','反方向的钟','晴天','最长的电影'];\n    console.log(songs);</code></pre>\n    <img data-src=\"/blog/images/iterator01.jpg\" src=\"#\" alt=\"iterator接口\">\n<p>按照其原理，先定义一个对象来获取该Symbol.iterator属性，找到该对象中包含的next方法。调用这个next()方法，它会返回一个包含done和value属性的对象。</p>\n<pre><code>const songs=['夜曲','手写的从前','最长的电影','晴天','明明就'];\n        // console.log(songs);\n        let iterator=songs[Symbol.iterator]();\n        console.log(iterator);\n        console.log(iterator.next());</code></pre>\n        <img data-src=\"/blog/images/iterator02.jpg\" src=\"#\" alt=\"iterator中的next方法\">\n<p>重复调用next()方法，该方法会依次遍历数组成员并返回多个包含done和value属性的对象，遍历完数组后，再返回一个done属性值为true,value属性值为undefined的对象，表示数组遍历结束。</p>\n<img data-src=\"/blog/images/iterator03.jpg\" src=\"#\" alt=\"遍历结束\">\n<p>在JavaScript中，原生自带iterator接口的数据结构有：<br/>\n<span class=\"tips\">Array</span>、<span class=\"tips\">Map</span>、<span class=\"tips\">Set</span>、<span class=\"tips\">String</span>、<span class=\"tips\">TypedArray</span>、<span class=\"tips\">函数的 arguments 对象</span>、<span class=\"tips\">NodeList 对象</span>\n</p>\n\n### 自定义遍历对象\n对于没有内置iterator接口的数据结构，可以仿照其原理，手写一个iterator接口，并且自定义需要遍历或者允许被遍历的内容。\n<p>按照其原理，添加iterator接口的步骤分为:</p>\n<ol>\n<li>添加Symbol.iterator属性,它是以一个函数的形式包含；</li>\n<li>在其中添加next()方法;</li>\n<li>next()方法会依次返回一个包含done和value属性的对象；</li>\n<li>如果遍历结束，则返回一个done属性值为true,value属性值为undefined的对象;</li>\n</ol>\n完整代码：\n<pre><code> //遍历输出对象的songs属性\n        const Rapper={\n            name:'王以太',\n            shows:['Chengdu','Hangzhou','Shenzhen'],\n            songs:['三思而后行','阿司匹林','童言无忌','目不转睛','人间天堂'],\n            [Symbol.iterator](){\n                let index=0;//索引号\n                return{\n                    next: ()=>{\n                        if(index< this.songs.length){\n                            const result={\n                                value:this.songs[index],\n                                done:false};\n                                index++;\n                                return result;\n                            }\n                            else{\n                                return{\n                                    value:undefined,\n                                    done:true\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n      \t//遍历输出\n\t\tfor(let m of Rapper){\n    \tconsole.log(m);\n    }\n</code></pre>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\npython、C++写个类似的接口也很简单，不过对复杂点的数据结构比较麻烦</div>\n\n### 生成器函数\n生成器函数允许我们定义一个包含自有迭代算法的函数，返回一种称为 Generator 的迭代器，生成器函数需要使用<span class=\"tips\">function *</span>语法声明\n\n<div class=\"show\"> function * gen(){\n            console.log(\"执行生成器\");\n        }\n        const g=gen();//返回一个名为Generator的迭代器，但不执行console.log语句\n        console.log(g);\n        g.next();//需要执行迭代器的next的方法才会执行生成器，才开始执行生成器中的console.log语句\n</div>\n\n#### yield关键字\nyield 关键字用于生成器函数的暂停和恢复，当执行Generator迭代器的next()方法时，开始执行生成器中的代码，一旦遇到 yield 表达式，生成器的代码将被暂停运行，直到生成器的 next() 方法再次被调用，暂停时yield 关键字后面的表达式的值返回给生成器的调用者，类似于一个基于生成器的版本的 return 关键字\n\n<span class=\"strong\">[rv] = yield [expression];</span>\n+ rv 返回传递给生成器的 next() 方法的可选值，以恢复其执行\n+ expression:定义通过迭代器协议从生成器函数返回的值。如果省略，则返回 undefined\n\n<div class=\"show\">function * gen(){\n    console.log(\"第一次执行\");\n    yield 111;\n    console.log(\"第二次执行\");\n    yield 222;\n    console.log(\"第三次执行\");\n    yield 333;\n    console.log(\"第四次执行\");\n    yield 444;\n}\nconst iterator=gen();\nconsole.log(iterator.next());//第一次执行next()方法，输出\"第一次执行\"，并返回第一个yield表达式的值111\niterator.next();//第二次执行next()方法，执行到第二个yield表达式为止\niterator.next();\niterator.next();</div>\n\n#### next()方法传参\n next() 方法接受一个参数用于修改生成器内部状态，传递给 next() 的参数值会被 yield 接收。传递给第一个 next() 的值会被忽略，而传递给第二个 next() 的值会被第一个 yield 接收，依此类推\n\n<div class=\"show\">function * gen(arg){\n    console.log(arg);//生成器函数本身的实参\n    let first=yield 111;\n    console.log(first);//\"BBB\"\n    let second=yield 222;\n    console.log(second);//\"CCC\"\n    let third=yield 333;\n    console.log(third);//\"DDD\"\n    yield 444;\n}\nconst iterator=gen(\"生成器实参\");\niterator.next();//第一个 next() 的实参会被忽略，不传参\niterator.next(\"BBB\");\niterator.next(\"CCC\");\niterator.next(\"DDD\");</div>\n\n#### 异步调用\n由于生成器函数每次执行到yield语句就会暂停，利用这个特性我们可以进行对资源的异步顺序加载，\n\n<div class=\"show\">实现：先加载\"用户数据\"，等待\"用户数据\"加载完毕再加载\"订单数据\"，最后加载\"商品数据\"，案列使用定时器模拟异步环境\nfunction getUsers(){\n    setTimeout(()=>{\n        let user=\"用户数据\";\n        iterator.next(user);//加载完的数据通过next()方法传给生成器函数，并开始加载下一项数据\n    },1000)\n}\nfunction getOrders(){\n    setTimeout(()=>{\n        let order=\"订单数据\";\n        iterator.next(order);\n    },1000)\n}\nfunction getGoods(){\n    setTimeout(()=>{\n        let goods=\"商品数据\";\n        iterator.next(goods);\n    },1000)\n}\nfunction * gen(){\n    let users=yield getUsers();\n    console.log(users);//处理数据\n    let order=yield getOrders();\n    console.log(order);\n    let goods=yield getGoods();\n    console.log(goods);\n}\nconst iterator=gen();\niterator.next();//初次执行next()方法\n</div>\n\n### Promise\nPromise是ES6新增的异步编程解决方案，用于封装异步任务，并且可以根据异步任务的成功/失败，对结果和数据进行灵活处理，此外，Promise支持链式调用，能很好地解决回调地狱问题\n\n#### Promise对象\nPromise本质上是一个函数返回的对象，代表了一个异步操作的成功或者失败，该对象中有两个关键属性：<span class=\"tips\">PromiseState</span>和<span class=\"tips\">PromiseResult</span>\n\n<span class=\"strong\">PromiseState</span> 即Promise的状态，Promise有三种状态:\n+ pending 未决定的\n+ resolved/fulfilled 决定的,符合的(成功)\n+ rejected 拒绝的(失败)\n\n该属性只能被修改一次，并且修改完毕后也只有一个结果(resolved或rejected)和结果数据\n\n<span class=\"strong\">PromiseResult</span>即Promise封装的异步任务成功/失败的结果数据，只能通过<span class=\"tips\">resolve()</span>或<span class=\"tips\">reject()</span>函数修改，并且可以传递给<span class=\"tips\">then()</span>方法，Promise成功时结果数据一般使用value为实参名，失败则使用reason作为实参名\n\n\n#### 实例化\n使用<span class=\"tips\">new</span>关键字进行实例化，实例化时接收一个函数类型的参数，该函数又接收两个函数类型的形参，<span class=\"tips\">resolve()</span>用于异步任务执行成功时调用，<span class=\"tips\">reject()</span>用于异步任务执行失败时调用\n\n<div class=\"show\"><span class=\"strong\" style=\"white-space:pre;\">const p=new Promise((resolve,reject)=>{\n                        //封装异步任务\n                         if(异步任务执行成功){\n                            resolve(data);\n                        }\n                        else{\n                            reject(data);\n                     }\n            });</span></div>\n\n\n当resolve被调用后，Promise状态会被修改为成功，随后执行<span class=\"tips\">then()</span>方法的第一个回调函数。reject则会将Promise状态会被修改为失败，随后执行<span class=\"tips\">then()</span>方法的第二个回调函数\n<div class=\"show\"><span class=\"strong\" style=\"white-space:pre;\">p.then((value)=>{\n            //Promise状态为成功时执行\n    },(reason)=>{\n            //Promise状态为失败时执行\n});</span></div>\n<div class=\"show\"><span class=\"strong\" style=\"white-space:pre;\">p.catch(resaon=>{\n            //只会在Promise状态为失败时执行\n});</span></div>\n此外，Promise状态为失败时也可以使用<span class=\"tips\">catch()</span>方法，该方法被单独封装用于处理失败情况，底层依旧调用了then()方法\n\n#### API\n##### 执行流程\n通过new创建Promise对象，对象初始状态为pending状态，然后执行内部的异步操作，执行成功则调用resolve()函数，将Promise对象状态修改为resolved状态，此时如果调用了then()方法，则将执行then()方法中的第一个回调函数，执行完该回调函数后返回一个新的promise()对象。如果异步任务执行失败，则调用reject()函数，将Promise对象状态修改为rejected状态，此时如果调用了then()方法，则将执行then()方法中的第二个回调函数，执行完该回调函数后返回一个新的promise()对象\n\n##### 构造函数\nPromise((excutor){})\n该构造函数接收一个执行器函数，内部定义了resolve()和reject()函数，这两个函数不属于Promise对象内部，执行器函数会在对象创建后立即执行(同步调用)\n\n##### 快速获取Promise对象\n以下方法属于Promise函数对象，可以直接调用\n+ Promise.resolve(value)\nvalue可以为任意类型的数据，或者一个Promise对象\n返回一个成功的Promise对象，但如果传入了一个Promise对象，则其状态取决于传入对象的状态，如果传入的Promise对象为成功，则返回的对象也为成功状态，反之亦然。该方法用于快速将一个数据转换为一个状态为成功的Promise对象\n<div class=\"show\">\nconst p1=Promise.resolve(100);//\nconst p2=Promise.resolve(new Promise((resolve,reject)=>{\n    reject();//由于传入的Promise对象状态为rejected，依次p2也为rejected状态\n}))\n</div>\n\n\n+ Promise.reject(value)\n永远返回一个rejected状态的Promise对象，即便传入的值是成功状态的Promise\n\n+ Promise.all(promise[])\n参数为一个Promise数组，只有当该数组中的所有Promise对象状态都为resolved时，该方法才返回一个resolve状态的Promise对象，且该对象的PromiseResult为数组中的Promise对象成功结果组成的数组。如果该数组中有任意一个Promise对象状态为rejected，则该方法返回的Promise对象状态将修改为rejected，且该对象的PromiseResult为数组中第一个失败成员的返回的PromiseResult\n<div class=\"show\">let p1=Promise.resolve(123)\n        let p2=Promise.reject(\"aaa\")\n        let p3=Promise.reject({test:0})\n        let p=Promise.all([p1,p2,p3]);\n        console.log(p);//p对象的PromiseResult为\"aaa\"\n        \n        p2.catch(reason=>{});\n        p3.catch(reason=>{});\n        p.catch(reason=>{});</div>\n\n\n否则返回一个rejected状态的Promise\n\n+ Promise.race(promise[])\n参数为一个Promise数组，该方法返回的Promise对象的状态取决中传入数组中第一个执行完异步任务的Promise对象状态，且值也为其PromiseResult\n\n##### 修改Promise状态的方法\n+ resolve函数\n+ reject函数\n+ throw 函数\n\n##### 执行多个回调\nPromise允许指定多个回调，即可以指定多个then()方法\n<div class=\"show\">let p=new Promise((resolve,reject)=>{\n     resolve(\"go\");\n});\np.then(value=>{\n    console.log(\"第一个回调\"+value);\n});\np.then(value=>{\n    console.log(\"第二个回调\"+value);\n});</div>\n\n##### then()方法返回值\nthen()方法会返回一个新的Promise对象，该对象的状态和值取决于then()方法所执行的回调函数\n+ 如果该回调函数返回一个Promise对象，则then()方法返回的Promise对象状态与其相同\n+ 如果该回调函数无return语句(默认返回undefined)，或者返回一个非Promise对象的值(如：返回字符串等)，则总是返回一个fulfilled状态的Promise\n+ 如果该回调函数throw异常，则返回rejected状态的Promise对象\n\n<div class=\"show\">let p=new Promise((resolve,reject)=>{\n            resolve();\n        })\n        let result1=p.then(value=>{throw '异常'});//状态为rejected\n        let result2=p.then(value=>{return 'aaa'});//状态为fulfilled\n        let result3=p.then(value=>{\n            return new Promise((resolve,reject)=>{\n            reject('error');\n        })\n        });//状态为rejected\n</div>\n\n##### 链式调用\n由于then()方法返回了一个新的Promise对象，因此该对象也可以调用then()方法，而该then()方法又返回一个新的Promise对象，又能调用then()方法，因此then()方法可以链式调用\n<div class=\"show\"> let p=new Promise((resolve,reject)=>{\n            resolve('success');\n        })\n        p.then(value=>{\n            console.log(value);//success\n        }).then(value=>{\n            console.log(value);//由于上一个then()无返回值，因此其返回的Promise对象的PromiseResult为undefined，因此输出undefined\n        })</div>\n\n##### 异常穿透\n当then()方法进行链式调用时，只需要在最后进行异常处理，前面的链式调用出现的任何异常，都会被传到最后处理异常的回调函数中进行处理(异常穿透特性)\n\n<div class=\"show\"> let p=new Promise((resolve,reject)=>{\n            resolve('success');\n        })\n        p.then(value=>{\n            console.log(value);\n            throw '异常'  //抛出异常\n        }).then(value=>{\n            console.log(value);//由于上一个Promise状态为rejected，then()方法第一个回调不执行\n        }).then(value=>{\n            console.log(value);//同上，不执行\n        }).then(value=>{\n            console.log(value);//同上，不执行\n        }).catch(reason=>{\n            console.warn(reason);//在链式最后进行异常处理\n        })</div>\n\n##### 中断Promise链\n当then()方法进行链式调用时，如果想在某个节点中断Promise链，只需要在该节点返回一个<span class=\"tips\">pending</span>状态的Promise对象，因为处于pending状态的Promise对象不会触发then()方法的执行，而其他任何返回值、异常抛出等操作都会使链式继续进行。注意：中断以后的Promise链，最后的异常捕获会依旧执行\n<div class=\"show\">let p=new Promise((resolve,reject)=>{\n            resolve('success');\n        })\n        p.then(value=>{\n            console.log(111);//输出111\n            throw 'error'\n        }).then(value=>{\n            return new Promise(()=>{});//返回pending状态的Promise对象\n        }).then(value=>{\n            console.log(222);//上一个Promise对象为pending状态，不执行then()方法\n        }).catch(reason=>{\n            console.warn(reason);//但由于异常穿透，该语句会继续执行\n        })</div>\n\n\n### async与await\n#### async函数\nasync函数可以帮助我们用更简洁的方式写出基于 Promise 的异步行为，用于包裹await表达式，该函数会返回一个Promise对象，对象的状态取决于async函数的返回值：\n+ 如果该函数无return语句(默认返回undefined)，或者返回一个非Promise对象的值(如：返回字符串等)，则返回一个fulfilled状态的Promise对象\n+ 如果该函数返回一个Promise对象，则async函数返回的Promise对象状态与其相同\n+ 如果该函数throw异常，则返回rejected状态的Promise对象\n\n#### await表达式\nawait表达式必须用async函数包裹，其右侧一般为Promise对象，也可以为其他值\n+ 如果为其他值，则await返回值与其相同\n+ 如果为Promise对象，则返回值为该对象fulfilled状态下的PromiseResult属性值\n+ 如果为Promise对象，且状态为rejected，则必须用<span class=\"tips\">try...catch</span>进行异常捕获处理\n\n<div class=\"show\"> async function main(){\n            try{\n                let result=await new Promise((resolve,reject)=>{\n                setTimeout(()=>{\n                    resolve('success')\n                },1000)\n            })\n            console.log(result);\n            }\n            catch(e){\n                console.warn(e)\n            }\n        }\n        main();</div>\n\n### AJAX\n#### 简介\nAJAX为Asynchronous JavaScript And XML的缩写，即异步 JavaScript 和 XML，用于更新数据，而不需要重载(刷新)整个页面\n\n#### XMLHttpRequest对象\nAjax 需要依赖于 XMLHttpRequest 对象，主流浏览器都支持 XMLHttpRequest 对象，只需要new即可\n<span class=\"strong\">let xmlhttp=new XMLHttpRequest();</span>\n\nE5和IE6等低版本IE浏览器不支持XMLHttpRequest 对象，而需要使用ActiveX 对象，因此如果需要兼顾低版本IE浏览器，则需要做兼容性检查\n<div class=\"show\">var xmlhttp;\n       if (window.XMLHttpRequest) {\n            xmlhttp = new XMLHttpRequest();//主流浏览器\n } else {\n         xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");//低版本IE浏览器\n}</div>\n\n#### XMLHttpRequest对象方法\n\n+ <span class=\"strong\">open(请求类型,url,async,user,psw)</span> 书写一个请求\n>>+ 请求类型：GET 或POST\n>>+ url为文件位置\n>>+ async：是否异步，值为true(异步)或 false(同步)\n>>+ user：用户名称(可选)\n>>+ psw: 用户密码(可选)\n+ <span class=\"strong\">send()</span> 发送请求，用于GET请求\n+ <span class=\"strong\">send(string)</span>发送请求，用于POST请求\n+ <span class=\"strong\">abort()</span>取消当前请求\n+ setRequestHeader()  向要发送的报头添加标签/值对\n+ getResponseHeader()\t返回特定的头部信息\n+ getAllResponseHeaders()\t返回头部信息\n\n#### XMLHttpRequest对象属性\n+ <span class=\"strong\">onreadystatechange</span> 定义当 readyState 属性发生变化时被调用的函数\n+ <span class=\"strong\">readyState</span> 表示当前 XMLHttpRequest 的状态\n>>+ 0：UNSET，尚未调用open方法，请求未初始化，\n>>+ 1：OPEND，open方法被调用，服务器连接已建立\n>>+ 2：HEADERS_RECEIVED，send()方法被调用，请求已收到\n>>+ 3：LOADING，正在处理请求，response属性已经包含部分数据\n>>+ 4：DONW，请求已完成且响应已就绪\n+ responseText\t以字符串返回响应数据\n+ responseXML\t以 XML 数据返回响应数据\n+ statusText    返回状态文本（比如 \"OK\" 或 \"Not Found\"）\n+ status        返回请求的状态号\n\n#### 发起请求\n##### 发起get请求\n如果get请求需要携带参数，可以直接在URL地址后以键值对的形式拼接<span class=\"tips\">查询字符串</span>，多个参数使用<span class=\"tips\">&</span>拼接\n<div class=\"show\">xhr.open('GET','http://shiwivi.com')</div>\n<div class=\"show\">xhr.open('GET','http://shiwivi.com?id=1&author=shiwivi')</div>\n\n\n<div class=\"show\"> let xhr=new XMLHttpRequest();\n    xhr.open('GET','http://shiwivi.com')\n    xhr.send();\n    xhr.onreadystatechange=function(){\n        if(xhr.readyState===4&&xhr.status===200){\n            console.log(xhr.responseText)\n        }\n    }</div>\n\n\n\n##### 发起post请求\nAJAX发起post请求主要需要如下流程：\n1. 创建xhr对象\n2. 调用open()方法初始化请求\n3. 设置content-type属性，指定请求头所含数据MIME类型为application/x-www-form-urlencoded，即进行了URL编码的二进制数据\n4. 调用send()方法，并指定请求所需要包含的数据\n5. 监听onreadystatechange事件\n\n<div class=\"show\">var xhr=new XMLHttpRequest();\n    xhr.open('POST','http://shiwivi.com');\n    xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded')\n    xhr.send('id=1&author=shiwivi');\n    xhr.onreadystatechange=function(){\n        if(xhr.readyState===4&&xhr.status===200){\n            console.log(xhr.responseText)\n        }\n    }</div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nURL中只允许出现英文字母、数字、标点符号，在拼接查询字符串时，如果我们在URL中拼接了中文字符，或者其他被预定义的字符，则浏览器会对其进行URL编码，其中中文字符会被编码为%xx%xx%xx形式(x为16进制数)，JavaScript中可以使用encodeURI('字符串')对该字符串进行编码，使用decodeURI('%xx%xx')对该字符串进行解码</div>\n\n#### JQuery中的Ajax\nJQuery对XMLHttpRequest进行了封装\n##### 发起get请求\n<span class=\"strong\">$.get(url,[data],[function(){...}])</span> 发起get请求\n+ url为请求地址，必须\n+ data为请求所携带的参数，非必须，参数也可以以查询字符串的形式拼接到URL后\n+ function可以指定请求成功执行的回调，非必须\n\n<div class=\"show\">$(function(){\n                $.get('http://shiwivi.com',function(res){\n                    console.log(res)//res用于接收返回的数据\n                })\n})</div>\n\n<div class=\"show\">$.get('http://shiwivi.com',{id:1,author:''shiwivi},function(res){...})\n//等价于\n$.get('http://shiwivi.com?id=1&author=shiwivi',function(res){...})\n</div>\n\n##### 发起post请求\n<span class=\"strong\">$.post(url,[data],[function(){...}])</span> 发起post请求\n+ url为提交数据地址，必须\n+ data为所要提交的数据，非必须\n+ function可以指定请求成功执行的回调，非必须\n\n<div class=\"show\"> $(function(){\n             $.post('http://xxxx.com',{name:'shiwivi',type:'blog'},function(res){\n                    console.log(res)\n                })\n        })</div>\n\n##### get与post通用\n<span class=\"strong\" style=\"white-space:pre;\">$.ajax({\n            type:'get/post/put/delete',\n            url:'',\n            data:{ },\n            dataType:'html/text/json/xml/script/jsonp',\n            success:function(res,textStatus,jqXHR){ },\n            error:function(jqXHR,textStatus,error){ }\n})</span> \n\n+ type为请求方式，可选get/post/put/delete，默认get\n+ url为请求地址\n+ data为请求携带的数据\n+ dataType为请求数据类型\n+ success为请求成功执行的回调函数，参数依次为响应内容(根据dataType作了处理)、文本形式的响应状态、jqXHR对象(里面包含状态码等信息)\n+ error为请求失败执行的回调函数，参数依次为jqXHR对象、文本形式的错误信息(eg:error、timeout、abort)、捕获的异常对象(对于http请求为http状态的文本部分eg:Not Found)\n\n<div class=\"show\">$.ajax({\n                type:'GET',\n                url:'http://shiwivi.com',\n                data:{id:1},\n                success:function(res,textStatus,jqXHR){\n                    console.log(res);//服务器返回的数据\n                    console.log(textStatus);//success\n                    console.log(jqXHR.status);//200\n                },\n                error:function(jqXHR,textStatus,error){\n                    console.error(jqXHR.status);//404\n                    console.log(textStatus);//error\n                    console.log(error);//Not Found\n                }\n             })\n        </div>","tags":["javaScript","数据结构"]},{"title":"Git与Github","url":"/blog/2021/03/23/git与github/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n记录一下git的常用命令</div>\n <h3> 1.git与github </h3><p>git是由Linux之父Linus运用c语言开发的一款分布式版本控制工具，支持Linux命令。github是全球最大的社交编程与代码托管网站，托管了数以百万的开源项目。\n                    <ul>\n                    <li>保存所有提交过的文件历史状态</li>\n                    <li>将文件回退到任意历史版本</li>\n                    <li>多人并行修改同一文件，并推送到服务器端</li>\n                    <li>创建多条支线同时推进开发任务</li>\n                    <li>邀请团队外的人员参与开发并进行审核</li>\n                    <li>对团队成员进行权限限制</li>\n                    <li>查看团队成员的修改内容、时间、日志</li>\n                </ul>\n                    </p><h3>2.本地仓库操作</h3>\n              <h4>2.1 初始化 git init</h4>\n              <p>生成.git文件夹(默认隐藏)，文件夹中包含了配置文件等本地库相关的目录和文件，如config文件中包含用户签名等信息</p>\n               <h4>2.2 设置签名</h4> \n               <p>用户名和Email地址可随意，仅用于区分开发者身份</p>\n               <h6>项目级别(仓库级别)：</h6>\n               <p>仅在当前本地仓库范围内有效</p>\n               <div class=\"code\">git config user.name xxx\ngit config user.email xxx@xxx.com</div>\n               <p> 配置文件保存在该项目下.git文件夹中的config里</p>\n               <h6>系统用户级别：</h6>\n               <p>登录当前操作系统的用户范围</p>\n               <div class=\"code\">git config --global user.name xxx\ngit config --global user.email xxx@xxx.com</div>\n               <p>\n                配置文件位于C:\\Users\\Administrator\\.gitconfig\n                当二者用户签名都存在时，会优先使用项目级别的签名。\n               </p>\n               <h4>2.3 git本地操作</h4>\n               <h6>2.3.1 将文件加入暂存区\\从暂存区去除</h6>\n              <ul>\n                  <li>将文件加入暂存区 <span class=\"strong\">git add 文件名</span></li>\n                  <li>将所有文件加入暂存区<span class=\"strong\">git add *</span></li>\n                  <li>将文件从暂存区去除<span class=\"strong\">git rm --cached 文件名</span></li>\n                  <li>查看当前状态<span class=\"strong\">git status</span></li>\n              </ul>\n            <h6>2.3.2 将文件提交到本地库</h6>\n            <ul>\n                <li>将文件快速提交到本地库 <span class=\"strong\">git commit -m \"提交标识语句\" 文件名</span></li>\n                <li>将文件提交到本地库 <span class=\"strong\">git commit 文件名</span> </li>\n                不使用快速提交会打开vim编辑器，要求添加提交标识语句\n            </ul>\n            <h6>2.3.3 查看提交的日志</h6>\n            <ul>\n                <li>完整查看历史记录 <span class=\"strong\">git log</span></li>\n                <li>简洁版 <span class=\"strong\">git log --pretty=oneline</span> </li>\n                <li>简洁版并缩短了哈希值 <span class=\"strong\"> git log --oneline</span></li>\n                <li>在oneline基础上添加了回退版本指针需要移动的次数 <span class=\"strong\">git reflog</span></li>\n            </ul>\n            <h6>2.3.4 版本回退</h6>\n            <ul>\n                <li>基于索引值 <span class=\"strong\">git reset --hard 哈希值</span> </li>\n                <li>基于^符号：只能后退 <span class=\"strong\">git reset --hard HEAD^</span> \n                    一个^表示回退一个版本，n个^即回退n个版本</li>\n                <li>基于~符号：只能后退 <span class=\"strong\">git reset --hard HEAD~回退数</span> </li>\n            </ul>\n            <h6>2.3.5 reset的参数</h6>\n            <ul>\n                <li><span class=\"strong\">--soft  </span> 仅在本地库移动 HEAD 指针,不修改工作区和暂存区内容,工作区和暂存区内容仍为版本回退前的内容,因为本地库和暂存区内容不同了,此时git status会提示有新内容可提交(不常用)</li>\n                <li><span class=\"strong\">--mixed  </span>在本地库移动 HEAD 指针,同时暂存区也会回退到历史版本(不常用)</li>\n                <li><span class=\"strong\">--hard </span>在本地库移动 HEAD 指针，暂存区、工作区也会一同被重置回历史版本</li>\n            </ul>\n            <h6>2.3.6 文件删除与找回</h6>\n            <p>文件删除同样需要git add添加和git commit提交，将删除记录提交到本地库，以备版本回退。</p>\n<span class=\"strong\">找回文件将版本回退到删除前的版本即可</span>\n<p>若删除文件后只添加到了缓存区，没有提交到本地库，此时本地库中是没有提交记录，但可以用<span class=\"strong\"> git reset --hard HEAD </span>命令将暂存区、工作区一起回退到没有删除文件和添加缓存的那个版本。</p>\n\n即：\n<ul>\n    <li>删除操作已经提交到本地库  <span class=\"strong\"> git reset --hard 哈希值</span></li>\n    <li>删除操作未提交到本地库<span class=\"strong\">  &emsp;git reset --hard HEAD</span></li>\n</ul>\n<h6>2.3.7  文件比较</h6>\n<ul>\n    <li>将工作区和暂存区的文件进行比较 <span class=\"strong\"> git diff 文件名</span></li>\n     若无文件名则将比较所有文件\n删除内容将以红色表示，新增文件绿色标识\n    <li>将工作区文件和历史版本进行比较  <span class=\"strong\"> git diff 历史版本 文件名</span></li>\neg：git diff HEAD new1.txt 和当前版本进行比较<br/>\neg：git diff HEAD^^ new1.txt 和上上个版本比较<br/>\neg：git diff 哈希值 new1.txt 和该哈希值对应的版本进行比较\n</ul>\n<h4>2.4 分支</h4>\n<h6>2.4.1 创建与切换分支</h6>\n<ul>\n    <li>创建分支 <span class=\"strong\"> git branch 分支名</span></li>\n    <li>切换分支 <span class=\"strong\"> git checkout 分支名</span></li>\n    <li>这两个代码可以合并，创建并切换到新建的分支 <span class=\"strong\"> git checkout -b 分支名</span></li>\n    <li>不能创建两个同名的分支，使用 <span class=\"strong\"> git checkout -B 分支名 </span>强制创建会重置原有的分支</li>\n    <li>查看所有分支 <span class=\"strong\"> git branch -v</span></li>\n</ul>\n<h6>2.4.2 合并分支</h6>\n<p>1.先切换到需要待修改的分支上  <span class=\"strong\"> git checkout 分支名</span></p>\n<p>2.执行合并 <span class=\"strong\">  git merge 有新内容的分支名</span></p>\n<h6>2.4.3 解决冲突</h6>\n<p>当两个分支同一文件同一内容进行了不同修改，git将提示自动合并失败，打开文件会标识出冲突位置和内容</p>\n<div class=\"code\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD\n当前分支修改内容\n=========\n被合并分支修改内容\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;分支名</div>\n并且状态显示为正在合并，直接打开文件修改冲突内容后保存\n然后使用\n<p> <span class=\"strong\"> git add 文件名</span></p>\n<p> <span class=\"strong\">git commit -m “提交说明”</span></p>\n完成合并<br/>\n注意！！git commit 命令后不跟文件名，否则会提示合并状态下无法进行提交\n\n<h4>2.5 创建标签</h4>\n<p>可以为github的项目添加标签，方便查找不同的版本。较为规范的版本格式应该为<span class=\"tips\">主版本号.次版本号.修订号</span>各版本号应该依次递增，版本号递增应该遵循：</p>\n<ul>\n    <li><span class=\"strong\">主版本号</span>重大调整、大型不兼容的API修改</li>\n    <li><span class=\"strong\">次版本号</span>新增功能、小型功能性修改</li>\n    <li><span class=\"strong\">修订号</span>修复bug</li>\n    <li>每当次版本号递增时，修订号必须归零。每当主版本号递增时，次版本号和修订号必须归零</li>\n    <li>先行版本号可以标注在修订号之后，使用连接号再加上一连串以句点分隔的标识符来修饰，如：1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92</li>\n</ul>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n关于版本控制规范，github上有更详细的说明 <a href=\"https://semver.org/lang/zh-CN/\" target=\"_blank\"> https://semver.org/lang/zh-CN/</a></div>\n<h5>2.5.1 查看tag</h5>\n<p>查看已创建的标签</p>\n<ul>\n    <li>查看所有标签<span class=\"strong\"> git tag </span></li>\n    <li>查看指定版本的标签 <span class=\"strong\"> git tag -l v1.1.*</span></li>\n     <li>显示tag信息 <span class=\"strong\"> git show v1.1.1</span></li>\n</ul>\n<h5>2.5.2 创建tag</h5>\n<ul>\n    <li>轻量级tag，无任何附带信息<span class=\"strong\"> git tag 标签名</span></li>\n    <li>附带说明的tag<span class=\"strong\"> git tag -a 标签名 -m \"说明\"</span></li>\n   <li>带有签名的tag，需要GPG私钥<span class=\"strong\"> git tag -s 标签名 -m \"说明\"</span></li>\n</ul>\n<h5>2.5.3 删除tag</h5>\n<ul>\n    <li>删除本地tag<span class=\"strong\"> git tag -d 标签名</span></li>\n    <li>删除远程tag<span class=\"strong\"> git push origin --delete 标签名</span></li>\n   <li>删除远程tag<span class=\"strong\"> git push origin :refs/tags/标签名</span></li>\n</ul>\n<h5>2.5.4 验证tag</h5>\n拥有GPG私钥时可以验证tag\n<ul>\n    <li>验证tag<span class=\"strong\"> git tag -v 标签名</span></li>\n</ul>\n<h5>2.5.5 推送本地tag到远程仓库</h5>\n<ul>\n    <li>推送指定tag<span class=\"strong\"> git push 远程仓库别名 标签名</span></li>\n    <li>推送所有tag<span class=\"strong\"> git push 远程仓库别名 --tags</span></li>\n</ul>\n\n\n<h3>3.远程仓库</h3>\n<h4>3.1 push与clone</h4>\n在github创建仓库，并复制仓库地址\ngit init 在本地初始化文件夹，建立本地仓库\n<ul>\n    <li>创建远程仓库别名<span class=\"strong\"> git remote add 别名 远程仓库地址</span>(别名常用origin)</li>\n    <li>查看当前所有仓库别名<span class=\"strong\"> git remote -v</span></li>\n    <li>推到远程仓库<span class=\"strong\"> git push 别名 分支名</span></li>\n    <li>克隆到本地<span class=\"strong\"> git clone 远程仓库地址</span></li>\n</ul>\n<h4>3.2 拉取</h4>\n<ul>\n    <li>拉取并直接合并<span class=\"strong\">git pull 别名 远程分支名</span></li>\n    <li>仅拉取远程库<span class=\"strong\">git fetch 别名 远程分支名</span></li>\n    <li>合并<span class=\"strong\">git merge 远程库地址别名 / 远程分支名</span></li>\n    <li>即 pull=fetch+merge</li>\n</ul>\n<h4>3.3 冲突解决</h4>\n<p>  当团队不同成员对同一文件进行了修改，后push 的人会被要求将本地库更新到最新版本，需先 pull 到本地，而当拉取的远程库内容和本地库有冲突时，会直接进入待合并状态，需解决冲突位置。 即如果不是基于Github 远程库最新版本进行的修改，会无法进行push操作</p>\n<h3>4. 跨团队开发与fork操作</h3>\n<p>团队外的成员,可用 Github 中的 fork 将心仪的仓库复制一份到自己的仓库中，fork的仓库会保留来源。 在自己的仓库中编辑完后，可用 Github 中的 Pull requests 将修改提交给原作者。 原作者可通过 Merge pull request 合并代码，书写合并操作日志后 Confirm merge完成合并。</p>\n<h3>5. ssh免密登录设置</h3>\n<h4>5.1 生成.ssh密钥目录</h4>\n<p>1.返回根目录<span class=\"strong\">cd ~ </span></p>\n<p>2.使用命令<span class=\"strong\">ssh-keygen -t rsa -C github账号</span>生成.ssh密钥目录，密钥文件夹在win10中默认路径为C:\\Users\\当前登录win10的用户名\\.ssh</p>\n<p>3. 文件夹中默认生成 id_rsa 和 id_rsa.pub文件,使用命令<span class=\"strong\">cat id_rsa.p </span>或直接用记事本打开id_rsa.pub文件，复制内容</p>\n<p>4. 打开github的头像→Settings→SSH and GPG keys 位置，New SSH Key 后进行粘贴</p>\n<h4>5.2 配置ssh</h4>\n<p>1.创建远程仓库别名 <span class=\"strong\">git remote 别名 远程仓库ssh</span></p>\n<p>2.此时使用<span class=\"strong\">git remote -v </span>查看列表中将新增ssh地址，此时即可用<span class=\"strong\">push ssh别名 远程分支</span>使用ssh进行操作。</p>\n<h3>6. Github常见报错</h3>\n<h4>6.1 无法连接</h4>\n<p>\n    fatal: unable to access 'https://github.com/xxxxx.git/'之类的错误\n</p>\n<p>将链接中的https改为git</p>\n<h4>6.2 git push 时报错 error 10054</h4>\n最常见的问题，有时候是网络问题，还有个原因是push的文件太大，缓存默认只有1M，将缓存改为500M\n<div class=\"code\">git config http.postBuffer 524288000 </div>","tags":["笔记","git"]},{"title":"Markdown语法","url":"/blog/2021/03/22/Markd语法/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n写博客文章、说明文档究极好用的语法，适配最漂亮的写作工具Typora写文档</div>\n<h3>关于Markdown</h3>\n<p>Markdown是一种轻量级标记语言,被广泛用于创建网站、文档、电子书，<span class=\"tips\"> .md </span>文件就是用Markdown语法书写的文件</p>\n<h3>基本语法</h3>\n<h5>标题</h5>\n<p>一共支持六级标题，严格模式下 # 号后需要添加空格符</p>\n<div class=\"code\"># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</div>\n<h5>删除线</h5>\n<p>语法：<span class=\"strong\">\n~~删除线~~\n</span></p>\n<div class=\"show\"><s>&emsp;删除线&emsp; </s></div>\n<h5>斜体</h5>\n<p>语法：<span class=\"strong\">\n*斜体*\n</span></p>\n<div class=\"show\"><i>&emsp;斜体&emsp; </i></div>\n<h5>加粗</h5>\n<p>语法：<span class=\"strong\">\n**加粗**\n</span></p>\n\n<div class=\"show\"><strong>&emsp;加粗&emsp; </strong></div>\n<h5>使用斜体并加粗</h5>\n<p>语法：<span class=\"strong\">\n***文字斜体并加粗***\n</span></p>\n<div class=\"show\"><i><strong>&emsp;斜体并加粗&emsp; </strong></i></div>\n<h5>文本高亮</h5>\n<p>语法：<span class=\"strong\">\n==文本高亮==\n</span></p>\n<div class=\"show\"><span style=\"background-color:#f8f840;\">文本高亮</span></div>\n<h5>下标</h5>\n<p>语法：<span class=\"strong\">\nC~7~H~5~N~3~O~6\n</span></p>\n<div class=\"show\">C<sub>7</sub>H<sub>5</sub>N<sub>3</sub>O<sub>6</sub></div>\n<h5>上标</h5>\n<p>语法：<span class=\"strong\">\ncm^2^\n</span></p>\n<div class=\"show\">cm<sup>2</sup></div>\n<h5>表格</h5>\n<div class=\"code\">表头 | 表头 | 表头\n--- | --- | ---\n单元格 | 单元格 | 单元格</div>\n</br>\n<div class=\"table\">\n <table>\n        <thead>\n            <tr>\n                <th>表头</th>\n                <th>表头</th>\n                <th>表头</th>\n            </tr>\n        </thead>\n        <tbody>\n          <tr>\n              <td>单元格</td>\n              <td>单元格</td>\n              <td>单元格</td>\n          </tr>  \n        </tbody>\n    </table>\n</div>\n\n<p>在表头下的分隔线中加入 <span class=\"tips\"> : </span>可以设置下方单元格对齐方式，并且可以在左右两侧都使⽤ | 来标记单元格边界，并用空格对其单元格使表格看起来更美观，更为美观的语法可以写为</p>\n<div class=\"code\">|  歌手&emsp;|  类型&emsp; | 代表作&emsp; |\n| :------ | :-------: | -------: |\n| 周杰伦   | 流行乐 | 《夜曲》|\n| Jony J  |  嘻哈&emsp; | 《顽家》 |\n</div>\n<div class=\"table\">\n<table>\n        <thead>\n            <tr>\n                <th style=\"text-align:left;\">歌手</th>\n                <th>类型</th>\n                <th style=\"text-align:right;\">代表作</th>\n            </tr>\n        </thead>\n        <tbody>\n          <tr>\n              <td style=\"text-align:left;\">周杰伦</td>\n              <td>流行乐</td>\n              <td style=\"text-align:right;\">《夜曲》</td>\n          </tr>  \n           <tr>\n              <td style=\"text-align:left;\">Jony J</td>\n              <td>嘻哈</td>\n              <td style=\"text-align:right;\">《顽家》</td>\n          </tr>\n        </tbody>\n    </table>\n</div>\n<h5>引用</h5>\n<div class=\"code\">>引用\n>>嵌套的引用\n</div>\n\n<div style=\"margin:10px 0px 5px 10px;border-left:5px solid #dcdde1;padding-left:8px;\">\n引用\n<div style=\"border-left:5px solid #dcdde1;padding-left:8px;\">嵌套引用</div>\n</div>\n<h5>无序列表</h5>\n<p>标识符用<span class=\"tips\">*</span>、<span class=\"tips\">+</span>、<span class=\"tips\">-</span>均可</p>\n<div class=\"code\">* 第一点\n* 第二点\n* 第三点</div>\n<div class=\"show\">\n<ul><li>第一点</li><li>第二点</li><li>第三点</li></ul>\n</div>\n<h5>有序列表</h5>\n<p>以数字与 . 组成</p>\n<div class=\"code\">1. 第一点\n2. 第二点\n3. 第三点</div>\n<div class=\"show\">\n<ol><li> 第一点</li><li> 第二点</li><li> 第三点</li></ol>\n</div>\n<h5>代码块</h5>\n<div class=\"code\">&#96;&#96;&#96; 语言名称\n代码部分\n&#96;&#96;&#96;</div>\n<br/>\n<div class=\"code\"><code>&#96;&#96;&#96; javaScript\n<span style=\"color:#c678dd;\">let</span>&nbsp;<span style=\"color:#ff6b6b;\">dance</span><span style=\"color:#7bed9f;\">=</span>&nbsp;<span style=\"color:#61aeee;\">setInterval</span><span>(()</span><span style=\"color:#c678dd;\">=></span><span>{</span>\n&#96;&#96;&#96;</code></div>\n<h5>行内代码</h5>\n<p>语法：<span class=\"strong\">\n&#96;代码&#96;\n</span></p>\n<div class=\"code\">&#96;void main()&#96;</div>\n&emsp;<span class=\"tips\">\nvoid main()\n</span>\n<h5>分隔线</h5>\n<p>使用三个或三个以上<span class=\"tips\">*</span>、<span class=\"tips\">-</span>、<span class=\"tips\">_</span></p>\n<div class=\"code\">***\n--------\n_________</div>\n<p>分隔线表现为</p>\n<br/>\n<hr/>\n<br/>\n<h5>链接</h5>\n<p>效果同&lt;a&gt;标签</p>\n<div class=\"code\">[链接文字](链接url)</div>\n<div class=\"show\">跳转到\n<a href=\"http://markdown.p2hp.com/\" target=\"_blank\" style=\"text-decoration:underline;\">Markdown中文网</a>\n</div>\n<h5>直接插入链接</h5>\n<p>被&lt;&gt;包裹的邮箱地址、URL会被转为链接</p>\n<div class=\"code\">&lt;url&gt;\n</div>\n<div class=\"show\">Markdown中文网：\n<a href=\"http://markdown.p2hp.com/\" target=\"_blank\" style=\"text-decoration:underline;\">http://markdown.p2hp.com/</a>\n</div>\n<h5>图片</h5>\n\n<div class=\"code\">![图片描述](url)</div>\n<p>其中，感叹号后[]中的内容将会在图片无法加载显示的时候显示出来，相当于&lt;img&gt;标签的<span class=\"tips\">alt</span>属性，但不知道是否如alt属性一样支持无障碍阅读。</p>\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\nMarkdown还有进阶的画图技巧，用它画流程图是真的好用，只是很多Markdown编辑器并不支持。\n</div>\n\n#### 特殊\n在markdown中输出两个连续的短横线，需要在两个短横线中间使用零宽不连字<span class=\"tips\">`&zwnj;`</span>(zero width non joiner) ","tags":["笔记","编辑器"]}]