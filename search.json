[{"title":"C语言","url":"/blog/2023/10/13/C语言回顾/","content":"\n\n\n### 介绍\n#### 发展历史\n<div class=\"contentFolded\">在计算机诞生初期，人们使用<span class=\"strong\">机器语言</span>来编写程序，机器语言的指令由操作码和操作数组成，均使用二进制代码表示，而二进制则通过在纸带上打孔来表示0或1，程序员将编写的机器语言指令打在纸带上并通过纸带机输入计算机中，以此进行运算。机器语言虽然能被计算机直接执行，但对人类来说难以阅读和记忆，不便编写。\n\n为了简化机器语言的编写，1950年代中期，<span class=\"strong\">汇编语言</span>应运而生。它使用助记符（mnemonic）来表示机器指令，极大地提高了程序员的工作效率。即便如此，书写和调试一个程序也需要用很长时间，并且需要程序员详细了解编写代码需要的指令、寄存器和CPU知识。\n\n为了解决这些问题，IBM公司的一个研究小组开始着手研究一门能高效运行且简单易用的编程语言。1956年，IBM公司的John Backus带领他的团队开发出了世界上第一个<span class=\"strong\">高级语言</span><span class=\"tips\">FORTRAN</span>(FORmula TRANslation，意为公式翻译)，在科学和工程计算领域取得了很大成功，但该语言是专门为IBM 704计算机设计的，只能在特定型号的机器上工作。\n\n为了解决这一问题，GAMM(德国应用数学和力学学会)、IBM、Datatron等公司要求ACM评估一种能脱离机器型号限定的“通用编程语言”。1958年5月，在美国计算机科学家Alan Jay Perlis的领导下，ACM、GAMM等代表在苏黎世会议上成立了IAL算法语言委员会，制定了国际算法语言(International Algorithmic Language,IAL)的定义并发布了IAL58语言。随后，ACM推崇IAL作为编程语言的标准，该算法语言由各种不同的“关键字”和“表达式”按照一定的语法规则组成，脱离了指令系统成为更接近人类的语言系统，编写者不必懂得完整的计算机的内部结构和工作原理也可以很好编写程序。\n\n1959年，IAL被重新命名为ALGOL(算法语言)。\n\n1960年，ALGOL算法语言委员会发布了<span class=\"tips\">ALGOL 60</span>，里程碑式地引入了<span class=\"strong\">递归</span>、<span class=\"strong\">布尔类型</span>、<span class=\"strong\">块结构</span>等概念，ALGOL 60也成为了后来所有计算机语言语法的鼻祖，Alan Jay Perlis也因此成为了世界首届图灵奖的获得者，以表彰其在 Algol 58 和 Algol 60 的形成和改进过程中的核心和关键作用。但ALGOL 60最大的缺点就是缺乏标准的输入输出能力，ALGOL 60编写的程序无法兼容不同的计算机外部设备，因此ALGOL 60迎来了进一步的迭代。\n\n1963年，剑桥大学基于ALGOL 60发布了<span class=\"tips\">CPL</span>（Combined Programming Langurage）语言，该语言旨在用于工业控制、数据处理等更为广泛的领域，因此规模宏大而复杂，编译器的编写进度十分缓慢，该语言并未大规模流行。\n\n1967年，英国剑桥大学的Matin Richards对CPL语言做了简化，推出了<span class=\"tips\">BCPL</span>(the Basic Combined Programming Language)语言，该语言是最早使用库函数封装基本输入输出的语言之一，主要用于编写系统和编译器，但BCPL对字符串的支持很差，并且内存管理很糟糕。\n\n1969年，美国贝尔实验室的Kenneth Lane Thompson对BCPL语言做了改进和优化，由此衍生出了<span class=\"tips\">B语言</span>，并用于书写<span class=\"strong\">UNIX</span>系统，该语言的名字取自BCPL中的第一个字母，但此时的B语言过于简单，功能有限。\n\n1972年，贝尔实验室的Dennis MacAlistair Ritchie在B语言的基础上设计出了<span class=\"tips\">C语言</span>(取BCPL的第二个字母作为该语言的名字)，C语言保留了BCPL和B语言的优点，简练而接近硬件，又克服了它们无数据类型等缺点。1973年初， C语言的主体完成，汤普森和里奇使用C语言重写了UNIX操作系统，极大地提升了UNIX操作系统的可移植性，而C语言随着UNIX的广泛使用得到了迅速推广，成为了应用最广泛的计算机语言之一。\n\n1983年，美国国家标准化协会(ANSI)制定了C语言标准——<span class=\"strong\">ANSI C</span>，1987年，ANSI又公布了新的标准<span class=\"strong\">87 ANSI C</span>，该标准于1990年被国际标准化组织(Internation Standard Organization)接受成为C语言国际标准——ISO/IEC 9899,简称<span class=\"strong\">C89/C90</span>标准，是C语言的主流标准，被广泛应用于各个领域。1999年，ISO对C语言进行了大量扩展和改进，加入了如long long等新的数据类型，发布了<span class=\"strong\">C99</span>标准，该标准在部分领域使用广泛，但在工业等领域普及度较低。目前最新标准为2018年发布的C17标准，但尚未被广泛使用。</div>\n\n\n#### 编译流程\nC语言源文件以<span class=\"tips\">.c</span>为文件名后缀，从高级语言转换为机器码程需要经过<span class=\"strong\">预处理</span>、<span class=\"strong\">编译</span>、<span class=\"strong\">汇编</span>、<span class=\"strong\">链接</span>四个过程\n\n###### 预处理\nC语言源文件首先会被预处理，以一个名为hello.c的源文件为例，<span class=\"tips\">hello.c</span>源文件经过预处理器处理，会生成一个<span class=\"tips\">hello.i</span>临时文件，预处理阶段会进行以下工作：\n+ 删除代码中的所有注释\n+ 对宏进行代码扩展，通过<span class=\"strong\">#define</span>等指令定义的常量或表达式，会被替换到文件中，对<span class=\"strong\">#if</span>等条件编译指令限定的代码进行选择性编译\n+ 包含文件，通过<span class=\"strong\">#include</span>指令包含的文件，其内容会被添加到源文件中\n\n###### 编译\n编译器会将临时文件<span class=\"tips\">hello.i</span>编译为汇编文件<span class=\"tips\">hello.s</span>，该阶段编译器会对代码进行语法检查，并返回源代码中存在的语法错误和警告\n\n###### 汇编\n汇编程序将<span class=\"tips\">hello.s</span>汇编文件编译成机器码，在<span class=\"strong\">Windows</span>环境下生成<span class=\"tips\">hello.obj</span>对象文件，在<span class=\"strong\">Linux</span>环境下生成<span class=\"tips\">hello.o</span>目标文件\n\n###### 链接\n链接器会将多个目标文件合并为一个文件，并与库函数文件(.lib)等依赖链接，生成可执行文件，在Windows环境下生成一个可执行文件 hello.exe，在 Linux环境下中生成 hello.out文件\n\n库函数文件由各软件公司编写并已经编译成目标文件(.obj文件)，它们将在链接阶段与源程序编译而成的目标文件(.obj文件)相链接，生成可执行文件。\n\n#### C语言内存模型\n准确来讲，这是Linux的虚拟空间布局的一部分，Linux系统内核进程和用户进程所占的虚拟内存比是1：3，Windows是2：2，以32位Linux系统为例，模拟一个4GB的内存地址块沙盘，其中高地址位的1GB内存为系统内核进程占用的内核空间，低地址位的3GB内存为用于用户内进程的用户空间，内核空间由操作系统负责维护和处理，因此本文只涉及日常开发中C程序可以操控的3GB用户空间部分。\n\n该虚拟沙盘地址通过页表(Page Table)映射到物理内存，其中，蓝色区域会被映射到物理内存的不同内存段，白色区域只用于虚拟内存地址的分析，不会映射到物理内存中，不占用内存空间\n\n<img src=\"#\" alt=\"C语言内存\" data-src=\"/blog/images/20240316041218.png\" style=\"max-width:420px;max-height:470px;\">\n\n##### 保留区(Reserved)\n保留区是系统预留且禁止用户进程访问的地址区域，位于虚拟地址空间的最低部分，不赋予物理地址，一般用于捕捉空指针异常等情况。在大多数操作系统中，极小的地址空间通常都是不允许访问的，如NULL、0等。因此C语言也将无效指针赋值为0，因为0地址在正常情况下是不会存放有效的可访问数据的。\n\n在32位X86架构的Linux系统中，系统将预留128MB的保留区，因此用户进程可执行程序一般从虚拟地址空间0x08048000开始加载内存区域。\n\n##### 代码区(Code/Text)\n用于存放二进制代码，该区域是只读的，以防止恶意程序修改代码区的数据。代码段指令中包括操作码和操作数(操作对象)，如果操作对象是立即数(具体数值)，则该数据将直接包含在代码中；如果是字符串常量、变量中的数据，则将引用该数据地址。\n\n##### 静态区(Static)\n静态区又称全局区，这部分的空间大小在编译时就已经确定，因此是静态的，静态区分为<span class=\"strong\">只读数据段</span>(RO Data，又称为常量区)、<span class=\"strong\">已初始化数据段</span>(又称为读写数据段，RW Data)和<span class=\"strong\">未初始化数据段</span>(又称为BSS段，Block Started by Symbol)三部分\n+ <span class=\"strong\">只读数据段(.rodata)：</span>只读，用于存储字符串常量，以及const修饰的只读全局变量(只读局部变量存储于栈区)、只读字符串变量，只读静态变量\n+ <span class=\"strong\">已初始化数据段(.data)：</span>可读可写，存储已初始化且初值不为0的全局变量和静态局部变量\n+ <span class=\"strong\">未初始化数据段(.bss)：</span>可读可写，存储未初始化或初始化为零的全局变量和静态变量。这些变量在编译阶段会被收集起来放到.bss段中，并在程序初始化时自动赋值为0(对数值型变量)或空字符(对字符变量)。由于.bss段的值全为0，因此这个段只记录段长，在编译-链接生成的可执行文件中不占用物理文件空间(全是0，没必要存储)，能在一定程度上节省磁盘空间。在程序执行(初始化)时，加载器(loader)根据其段长分配相应大小的内存，并将这些内存空间全部初始化为0。因此.bss段不占用物理文件尺寸，但占用内存空间；.data段占用物理文件，也占用内存空间\n\n##### 堆(Heap)\n由程序员分配释放，如果程序员不释放，则操作系统在程序结束时回收，通过<span class=\"tips\">malloc</span>、<span class=\"tips\">realloc</span>、<span class=\"tips\">calloc</span>语句开辟空间，通过<span class=\"tips\">free</span>释放。\n\n堆内存的增长方向为由低地址向高地址增长，其工作方式类似于数据结构中的<span class=\"tips\">链表</span>。在操作系统中有一个记录空闲内存地址的链表，当使用malloc()等语句开辟内存空间时，操作系统会遍历该链表，寻找第一个空间大于等于所申请空间的堆节点，然后将该节点从空闲链表中删除，并将该节点的空间分配给程序，此外，系统会在该空间的首地址处记录所分配的空间大小，以便free语句能正确释放空间。\n\n由于每次分配的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中，频繁的开辟、释放空间势必会造成内存空间的不连续，从而造成大量碎片。\n\n堆空间的大小受限于系统的有效虚拟内存，32位Linux系统中堆内存可达2.9G空间。堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。\n\n\n##### 内存映射段(mmap)\n该区域用于映射可执行文件用到的动态链接库到内存中，方便更快速地读取。\n此外，在Linux中，如果通过malloc()请求一个大的内存空间，C运行库将在该区域创建一个匿名内存映射，而不使用堆内存。\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n内存映射是一种强大的文件I/O技术，用于高效读写文件。它将文件映射到虚拟内存空间中，并且支持按需加载文件，然后通过内存地址来访问文件，从而避免了大量的文件读写操作，比传统的文件读写操作更加快捷方便。\n</div>\n\n##### 栈(Stack)\n栈内存由<span class=\"tips\">编译器</span>负责分配和释放，主要用于存放：\n+ 函数内部定义的局部自动变量(auto类型)，包括const修饰的只读局部变量\n+ 函数参数和返回值\n+ 调用函数时的上下文环境，如函数返回地址等\n+ 暂存一些算术表达式的计算结果\n+ alloca()函数分配的栈内内存\n\n栈内存的增长方向为由高地址向低地址增长，其工作方式与数据结构中的栈相似，即先入后出，且栈分配的内存空间是连续的，不会有碎片化现象。栈是由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多\n\n栈空间的大小由系统预定义(通常默认2M或10M)，当栈剩余空间大于所申请空间时，系统将分配内存，否则将抛出栈溢出(stack overflow)错误\n\n##### 各段生成时间\n在C语言程序编译-链接后生成的映像文件中，将只包含代码段、只读数据段(.rodata)和读写数据段(.data)，双击运行该文件后，程序在初始化时将动态生成未初始化数据段(.bss)，程序的运行过程，将动态生成堆(Heap)和栈(Stack)\n\n<div class=\"show\">char str[]=\"hello\"; //数组末尾会添加'\\0'代表存储结束\nchar * str=\"hello\";\n如果它们都是局部变量，则字符数组会在栈区申请空间，并将字符存储在数组空间中；而指针变量，字符串存储在全局区的只读数据段，栈中的指针变量存储的是其字符串在全局区中的地址\n如果它们声明为全局变量，则字符数组声明在全局\nconst 声明的全局变量存储于静态区\nconst 声明的局部变量存储于栈\nconst 声明的字符串常量存储于静态区只读区 const char* str=\"hello\"\n</div>\n\n### 预处理命令\n预处理命令是C语言源程序中用于改进程序设计环境、提高编程效率的特殊命令，不属于C语言的组成部分，无法进行编译，只会对其在预处理阶段作出相应处理。预处理命令以<span class=\"tips strong\">#</span>开头，且不以分号结尾，以便与一般的C语言语句区分\n\n#### #include文件包含\n<span class=\"strong\">文件包含</span>处理指将一个源文件中的内容包含到另一个源文件中，被包含的文件称为<span class=\"strong\">头文件</span>(或标题文件)，文件名常以<span class=\"tips\">.h</span>作为后缀，也可以以<span class=\"tips\">.c</span>作为后缀甚至没有后缀。在编译的预处理阶段，头文件中的内容会被复制到主文件中，替换掉 #include &lt;xxx.h>语句，得到一个新的源文件，再对该文件进行编译。\n\n+ <span class=\"strong\">#include &lt;文件名></span>一般用于包含系统库函数头文件\n+ <span class=\"strong\">#include \"文件名\"</span>一般用于包含用户自己编写的头文件\n\n<div class=\"show\">eg:C语言中常用的标准输入输出函数头文件\n#include &lt;stdio.h&gt;\n// std：standard(标准)，i为input，o为output，将包含标准输入/输出函数的头文件stdio.h包含到源文件中</div>\n\n注意事项：\n+ 一个#include语句只能包含一个文件，如果要包含多个文件，则只能使用多个语句\n+ 使用<span class=\"tips\">&lt;文件名></span>包含文件时，系统会到存放C语言库函数头文件的路径下寻找该文件，，使用<span class=\"tips\">\"文件名\"</span>包含文件时，系统会首先在用户当前目录中寻找文件，如果没有，再去C语言库函数路径下\n+ 如果A文件包含了B文件，而B文件需要使用C文件中的内容，则可以在A文件中使用两个#include命令同时包含文件B和C，且包含C文件的指令需要出现在包含B文件的指令前。也可以嵌套包含，即B文件包含C文件，A文件包含B文件\n+ A文件包含B文件后，B文件中的内容会在预处理阶段被复制到A文件中，因此B文件中的全局静态变量在A文件中有效，不需要extern声明语句\n+ #include通常用于包含.h头文件，也可以包含其他文本文件，如：源代码文件(.c)、c++的头文件(.hpp或.hxx)、库文件(.lib、.dll、.a等)，甚至可以为.txt文本文件\n\n#### #define 宏定义\n用一个指定的标识符代表一个字符串，在编译预处理阶段，预处理器会对源代码中的宏名进行<span class=\"strong\">宏展开</span>，即将宏名替换成对应的字符串\n\n+ <span class=\"strong\">#define 标识符 字符串</span> 定义无参宏定义\n+ <span class=\"strong\">#undef 标识符</span> 终止宏定义\n+ <span class=\"strong\">#define 标识符(参数表列) 字符串</span> 定义带参数的宏定义\n\n注意事项： \n1. 宏名一般使用<span class=\"strong\">大写字母</span>表示，以便与普通变量名区分\n2. 宏定义只用作字符串替换，与定义普通变量不同，不分配内存空间\n3. 宏定义可以嵌套定义\n4. 宏定义用于定义符号常量，定义完毕后不能再赋值，也不能被修改\n5. 宏定义语句写于函数外，作用范围为宏定义语句之后到本源文件结束，或者到<span class=\"tips\">#undef 宏名</span>行终止\n6. 预处理阶段只对宏名进行字符串替换，不作语法准确性检查。如果宏定义中有错误，只有在宏名被宏展开后的编译阶段，编译器对源程序进行语法检查时才会发现宏定义中存在的错误\n\n\n<div class=\"show\"> //无参数宏定义\n#include &lt;stdio.h>\n#define PI 3.1415926\n#define R 4.0\n#define L 2*PI*R //嵌套定义宏\nint main()\n{\n    float l=L;\n    printf(\"%f\",l);\n    return 0;\n}\n#undef R  //终止R的作用范围\nvoid f1(){....}\n</div>\n<div class=\"show\"> //带参宏定义\n#include &lt;stdio.h>\n#define L(r,s) r+s //带多个参数的宏定义\n#define M(r) 3*r*r \n#define N(r) 3*(r)*(r)\nint main(void){\n int a=1,b=2,result;\n result=L(a,b); //展开为result=a+b;\n result=M(a+b); //展开为result=3*a+b*a+b<span class=\"tips\">注意宏定义时参数不带()可能会被展开为错误形式</span>\n result=N(a+b); //展开为result=3*(a+b)*(a+b);\n return 0;\n}</div>\n\n#### 条件编译\n<span class=\"strong\">条件编译</span>指预处理器根据条件编译指令，选择性将源代码中的部分代码送到编译器进行编译\n\n###### #ifdef宏定义判断\n<span class=\"strong\">#ifdef 标识符\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序1\n&emsp;&emsp;#else\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序2\n&emsp;&emsp;#endif\n</span>\n如果指定的标识符已经被#define定义过，则编译程序1，否则编译程序2，程序1和程序2既可以是C语句，也可以是预处理命令，类似于if...else...语句，#else可以不使用\n<div class=\"show\">#include &lt;stdio.h>\n#define TEST //TEST定义甚至可以为空，也视为被定义过\n#ifdef TEST\n    #define SIZE 32 //TEST被定义过，所以执行该语句\n#else\n    #define SIZE 64\n#endif\n....</div>\n\n###### #ifndef无宏定义判断\n逻辑与#ifdef相反，如果指定的标识符未被#define定义，则编译程序1，否则编译程序2\n<span class=\"strong\">#ifndef 标识符\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序1\n&emsp;&emsp;#else\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序2\n&emsp;&emsp;#endif\n</span>\n\n###### #if表达式判断\n如果表达式值为真，编译程序1，否则编译程序2\n<span class=\"strong\">#if 表达式\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序1\n&emsp;&emsp;#else\n    &emsp;&emsp;&emsp;&emsp;&emsp;程序2\n&emsp;&emsp;#endif\n</span>\n\n<div class=\"show\">#include &lt;stdio.h>\n#define LINUX 1 //可以快速设置编译的目标平台，缩减源代码长度\nint main(void){\n    #if LINUX\n        printf(\"linux专用代码\");\n    #else\n        printf(\"非linux用代码\");\n    #endif\n    .....\n    return 0;\n}</div>\n\n### 变量\nC语言中变量的声明方式如下：\n<span class=\"strong\"><span class=\"text-green\">存储类型</span><span class=\"text-blue\">数据类型 </span> 变量名;</span>\n\n+ 存储类型代表编译器为变量分配内存的方式，如：自动变量内存分配于动态存储器，静态变量和外部变量内存分配于静态存储区，寄存器变量存储位置分配于CPU中的寄存器\n+ 存储类型和作用域(变量定义的位置)决定了变量的生存期\n+ 数据类型指该变量存储的数据类型\n+ 变量名需要满足标识符命名规则\n\n#### 标识符命名规则\n<span class=\"strong\">标识符</span>即C语言中的变量名、符号常量名、函数名、数组名等用来给数据对象命名的字符序列，标识符需要满足以下规则：\n\n+ 只能由英文字母、数字、下划线组成\n+ 不能以数字开头\n+ 不能使用关键字\n+ 严格区分大小写\n\n#### 变量的作用域和生存期\n变量从其作用域区分，分为局部变量和全局变量：\n\n<span class=\"strong\">局部变量</span>：定义在函数内部或{ }包裹的代码块内部，只在本函数或代码块内生效，分为静态局部变量和动态局部变量。默认情况下，局部变量的存储类型为auto(动态局部变量)，变量内存位于动态存储区，代码块内的语句执行完毕变量就会被销毁，释放其内存。可以将局部变量的存储类型定义为static(静态局部变量)，此时变量内存位于静态存储区，整个程序运行期间其内存不会被释放\n\n<span class=\"strong\">全局变量</span>：定义在函数的外部，默认存储类型为extern，有效作用域为变量定义位置开始到本源文件结束，其作用域可以通过extern声明进行拓展。全局变量在程序的整个执行过程都占用内存单元。<span class=\"tips\">习惯上，全局变量的首字母用大写表示</span>，当全局变量名和局部变量名相同时，局部变量有效\n\n变量的生存期是指变量从生成(分配内存)到被销毁(释放内存)的时间段。对于存储在静态存储区中的变量，其内存在编译时就已经确定，是静态的，内存空间在整个程序运行期间不会被释放，变量与程序共存亡。而对于存储在动态存储区中的变量，其内存由操作系统根据程序运行动态分配。变量的存储类型直接决定了变量的生存期。\n\n<div class=\"show\">#include&lt;stdio.h>\nint Number=0;   //全局变量首字母大写\nint main(void){\n    void test();\n    int num=10;\n    int Number=10; //局部变量生效，全局变量被\"屏蔽\"\n    test();\n    return 0;\n}\nvoid test(){\n    Number=100; //全局变量可以被任意函数访问和修改，会降低程序清晰性\n}</div>\n\n#### 变量的存储类型\nC语言提供的存储类型主要有以下几种：\n\n+ 自动变量 auto\n+ 静态变量 static\n+ 外部变量 extern\n+ 寄存器变量 register\n\n\n##### auto自动变量\n又称动态局部变量或局部作用域变量，定义于函数内部，是C语言中极为常用的变量类型，因此C语言把它设计为缺省类型(默认类型)，即auto可以省略不写，反之，如果没有指定局部变量的存储类型，则默认为auto，因此以下两个语句等价\n<div class=\"show\"><code>{\nint num=10;\nauto int num=10;\n}</code></div>\n\n自动变量数据存储在<span class=\"text-blue\">动态存储区</span>中，操作系统会在代码执行到变量定义语句时为其分配内存，退出所属语句块时释放内存。函数形参和函数内定义的变量(未明确声明为static)都属于该类变量。自动变量有以下特点：\n+ 自动变量在定义时不会自动初始化。所以除非程序员显式指定初值，否则自动变量的值是随机的垃圾值\n+ 自动变量在退出函数(语句块)后，其分配的内存立即被释放，再次进入该语句块，该变量被重新分配内存，所以不会保存上一次退出时的值\n\n##### static静态变量\n静态变量分为静态局部变量和静态外部变量，二者用于不同的场景。静态变量在<span class=\"text-blue\">静态存储区</span>分配内存，在整个程序运行期间不会被释放，与程序共存亡。对于已经初始化的静态变量，其内存空间位于静态存储区的.data段，在编译时赋予内存。对于未初始化的静态变量，其内存空间位于静态存储区的.bss段，并在程序初始化时，给变量赋值0(对数值型变量)或空字符(对字符变量)。\n\n###### 静态局部变量\n自动变量的内存会在代码退出函数块后被释放，其值也不会被保留，下次进入该函数块，该变量会被分配新的内存，如果希望变量的值在退出函数语句块后依旧被保留，其占用的存储单元不释放，方便函数基于上一次的运算结果进一步进行计算，此时可以使用static关键字将局部变量定义为静态局部变量。\n\n<div class=\"show\">eg:计算n的阶乘\n<code>int main(void){\n    int i,n;\n    scanf(\"%d\",&n);\n    for(i=1;i&lt;=n;i++){\n        Func(i);\n    }\n    return 0;\n}\nlong Func(int n){\n    static long p=1;\n    return p*n;\n}</code></div>\n\n静态局部变量，有以下特点：\n+ 如果定义静态局部变量时不赋初值，编译器会自动赋为0(对数值型变量)或空字符(对字符变量)\n+ 自动变量(动态局部变量)占据的内存在函数调用结束后会被释放，每次调用都需要重新初始化。而静态局部变量仅在第一次调用函数时被初始化一次，其占据的内存在退出函数后不会被释放，再次调用该函数其值上次退出函数时的值\n+ 虽然静态局部变量在函数调用结束时仍然存在，但其他函数是无法引用它的\n\n###### 静态外部变量\n外部变量默认存储类型为extern，可以被其他文件使用extern声明后引用，如果希望外部变量只限于被本文件使用，而不能被其他文件引用，则可以在声明外部变量时添加static声明，将其声明为静态外部变量，该类变量可以应用于以下场景：\n+ 多人开发时，可以在不同文件中声明同名外部变量而互不干扰\n+ 权限控制，避免其他文件引用或修改外部变量的值\n\n<div class=\"show\"><code>static int Number;\n</code></div>\n\n\n##### extern外部变量\n如果定义在函数之外的变量没有指定其他存储类别，那么它就是一个外部变量，外部变量是全局变量，作用域是从它的定义点到本文件末尾。但如果要在定义点之前或在其他文件中使用它，那就需要使用关键字extern对其进行声明(注意不是定义，编译器不为其分配内存)\n声明语句为:\n<span class=\"strong\">extern 类型名 变量名;</span>\n其中类型名可以省略，因此以下语句等价\n<div class=\"show\"><code>extern int Num1;\nextern Num1;</code>\n注意！\n在定义外部变量时，直接在函数外定义 int Num1;  即可\nint Num1;  是“定义性声明”语句，会给变量分配内存空间，\nextern int Num1;  为“引用性声明”语句，用于拓展外部变量作用域，不会分配内存，不能用来定义一个未初始化的外部变量\n但如果在定义时进行初始化，根据右结合原则，会当作定义了变量，并进行了extern作用域拓展处理\nextern int Num1=200;//既是定义语句，也是extern声明语句\n</div>\n\n###### 在一个文件内声明外部变量\n如果外部变量不在文件开头定义，那么它的作用域就是从它的定义点到本文件末尾。如果在定义点之前想要引用该变量，则需要在引用之前对使用extern对其进行外部变量声明，声明后就可以从声明之处起，合法使用该外部变量\n<div class=\"show\"><code>int main(void){\n    int getMax(int ,int);\n    <span class=\"text-blue\">extern Num1,Num2;</span>//外部变量声明(仅作声明，不分配内存)\n    printf(\"max is:%d\", getMax(Num1,Num2);)//在定义前引用变量\n}\nint Num1=10,Num2=20;//定义外部变量\nint getMax(int x,int y){\n    return x>y?x:y;\n}\n</code></div>\n\n\n\n###### 在多文件中声明外部变量\nC语言程序也可以由多个源文件组成，如果多个文件都需要用到同一个外部变量，不能在多个文件中都同时定义该变量，否则程序在链接阶段会出现“重复定义”错误。正确做法是：在某一个文件中定义外部变量，其他文件中用extern对该变量作“外部变量声明”，将变量的作用域拓展到这些文件中，然后在这些文件中合法引用外部变量。\n<div class=\"show\">eg:文件file1.c中输入变量Num的值，文件file2.c对Num扩大10倍后返回结果\nfile1.c文件:\n<code>#include&lt;stdio.h&gt;\n<span class=\"text-blue\">int Num;</span>//定义外部变量\nint main(void){\n    int getValue(int);\n    printf(\"Input the value of Num:\");\n    scanf(\"%d\",&Num);\n    printf(\"%d\",getValue(10));\n    return 0;\n}</code>\nfile2.c文件:\n<code><span class=\"text-red\">extern Num;</span>//声明A为其他文件已经定义的外部变量\nint getValue(int n)\n{\n    return Num*n;\n}</code></div>\n\n##### register寄存器变量\n对于使用频率较高的变量，可以将其声明为寄存器变量，减少CPU对内存的频繁数据访问，使得程序更小，执行速度更快\n<div class=\"show\"><code>int main(void)\n{\n    int n;\n    long countNum(int);\n    scanf(\"%d\",&n);\n    countNum(n);\n    return 0;\n}\nlong countNum(int n)\n{\n    register long i,f=1;\n    for(i=1;i&lt;n;i++){\n          f=f*i;\n    }\n    return f;\n}\n</code></div>\n\n寄存器变量有以下特点：\n+ 只有局部自动变量和形参可以作为寄存器变量\n+ CPU中的寄存器数量有限，不能定义太多的寄存器变量\n+ 有的系统把寄存器变量当作自动变量处理，在内存中分配存储空间，并非放到寄存器中\n\n现代编译器能自动优化程序，自动把普通变量优化为寄存器变量，并且可以忽略用户定义的寄存器变量，因此一般无需特别声明变量为register，仅作了解。\n\n### 数据类型\n#### 数据类型总览\n##### 基本类型\n<div class=\"table\">\n<table>\n        <thead>\n            <tr>\n                <th colspan=\"2\">分类</th>\n                <th>关键字</th>\n                <th>长度(Bytes)</th>\n                <th>示例</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td rowspan=\"5\">整型</td>\n                <td>短整型</td>\n                <td>short</td>\n                <td>2</td>\n                <td>short a;或\n                    short int a;\n                </td>\n            </tr>\n            <tr>\n                <td>整型</td>\n                <td>int</td>\n                <td>4</td>\n                <td>int a;</td>\n            </tr>\n            <tr>\n                <td>长整型</td>\n                <td>long</td>\n                <td>4</td>\n                <td>long a;或\n                    long int a;\n                </td>\n            </tr>\n            <tr>\n                <td>长长整型</td>\n                <td>long long</td>\n                <td>8</td>\n                <td>long long a;或\n                    long long int a;\n                </td>\n            </tr>\n            <tr>\n                <td>无符号整型</td>\n                <td>unsigned</td>\n                <td>8</td>\n                <td><div>unsigned int a;</div> \n                    unsigned long  a;\n                </td>\n            </tr>\n            <tr>\n                <td rowspan=\"3\">浮点型(实型)</td>\n                <td>单精度</td>\n                <td>float</td>\n                <td>4</td>\n                <td>float a;</td>\n            </tr>\n            <tr>\n                <td>双精度</td>\n                <td>double</td>\n                <td>8</td>\n                <td>double a;</td>\n            </tr>\n            <tr>\n                <td>长双精度</td>\n                <td>long double</td>\n                <td>12或8</td>\n                <td>long double a;</td>\n            </tr>\n            <tr>\n                <td colspan=\"2\">字符型</td>\n                <td>char</td>\n                <td>1</td>\n                <td>char a;</td>\n            </tr>\n            <tr>\n                <td colspan=\"2\">枚举型</td>\n                <td>enum</td>\n                <td>-</td>\n                <td>enum res{yes,no,none};</td>\n            </tr>\n        </tbody>\n    </table>\n</div>\n\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nlong long,unsigned long long,long double是C99标准新增的，部分编译器默认使用C89标准，需要手动指定使用C99标准编译才支持以上数据类型。此外，ANSI C标准对于数据类型所占内存的字节数并无明确定义，因此不同编译器中各数据类型的字节数可能不同</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nC语言中没有string类型，处理字符串一般使用字符数组或指针，也没有bool类型，不能使用true和false逻辑常量</div>\n\n##### 构造类型\n\n<div class=\"table\">\n\n构造类型|关键字|示例\n-----|-----|----\n数组|-| int num[10];\n结构体|struct|\n共用体|union|union{int num;char name[5];}man\n</div>\n\n##### 其他类型\n<div class=\"table\">\n\n数据类型|关键字|示例\n-----|-----|----\n指针|-|int * p;\n无类型|void|void f1(){...}\n</div>\n\n#### 整型\n整型从符号位的归属可分为<span class=\"strong\">有符号整型(signed)</span>和<span class=\"strong\">无符号整型(unsigned)</span>。有符号整型最高位为符号位，0表示该值为正数，1表示该值为负数，而无符号整型的最高位不表示正负，依旧用于储存数值，因此无符号整型只能表示0和正整数，但无符号整型可存储的数值范围要比同位数的有符号整型大2倍，如：signed int数值范围为-32768-32767，而unsigned int 数值范围为0-65535。如果一个整型不声明为unsigned或signed，则默认隐含为signed，因而signed可以省略不写。\n\n对于短整型和长整型，int也可以省略不写(以下[]内的均可省略不写)\n\n<div class=\"table\">\n\n类型|比特位数|取值范围\n------------|-----|----\n[signed] short [int]|16|-2<sup>15</sup>\\~(2<sup>15</sup>-1)\nunsigned short [int]|16|0\\~(2<sup>16</sup>-1)\n[signed] long [int]|32|-2<sup>31</sup>\\~(2<sup>31</sup>-1)\nunsigned long [int]|32|0\\~(2<sup>32</sup>-1)\n</div>\n\n对于整型常量，通常在其数值后加上相应符号表示其具体类型，如：加上<span class=\"tips\">U或u</span>表示无符号整型，加上<span class=\"tips\">L或者l</span>表示长整型\n\n<div class=\"show\">233u或233U为无符号整型\n-1024l或-1024L为长整型\n203lu为无符号长整型</div>\n\n<div class=\"broadcast color-red\"><div class=\"iconfont icon-gantanhao\"></div>如果使用u标识一个负整数,如-12345u，则将取-12345补码对应的无符号整数53191按无符号数存储</div>\n<div class=\"show\">-12345\n原码：1011 0000 0011 1001\n反码：1100 1111 1100 0110\n补码：1100 1111 1100 0111 --->对应无符号数值为53191</div>\n\n#### 浮点型\n浮点数有两种表示方式：\n+ 十进制小数形式，如：0.5,1.3,.95(省略0)\n+ 指数形式，以e或E为底数(其中e代表10)，e的左边为数值部分，e的右边为指数部分(必须为整数)，如：12.3可以表示为1.23e1、0.123e2、123e-1等形式，如果e左边的数值部分，小数点左边有且只有一位非零的数字，则该表示方法称为<span class=\"tips\">\"规范化的指数形式\"</span>，如：1.23e1为规范化的指数形式，而0.123e2、123e-1不是\n\nC语言默认将浮点型常量作为<span class=\"tips\">双精度(double)</span>类型进行处理，如果在常量后加上<span class=\"tips\">f或F</span>将作为float型处理，加上<span class=\"tips\">l或L</span>则作为long double型处理，eg:1.25e-2f，1.25L\n\n#### 字符\n字符常量使用<span class=\"tips\">单引号''</span>包裹，一个字符占用一个字节(中文字符需要两个字节)。字符在内存中以ASCII码形式存储，因此字符型数据和整型数据是通用且可以用于计算的(仅限于0-255之间的整数)，常见的应用为<span class=\"tips\">大写字符+32转换为小写字符</span>\n<div class=\"show\">char a=97;\nint  asciiA=a-32;\nprintf(\"%c\\n\",asciiA)//输出A\nprintf(\"%d\",asciiA)//输出65\n</div>\n\n此外，C语言中还有一些特殊的转义字符，作用如下\n<div class=\"table\">\n\n字符|含义                               |字符|含义\n---|-----------------------------------|----|---\n\\n |换行                               |\\a   |响铃报警提示音\n\\r |回车(不换行)，将光标位置移到当前行开头|\\\\\"   |双引号\n\\0|空操作字符，常用作字符串结束标志          |\\\\'   |单引号\n\\t|水平制表，跳到下一个Tab位置          |\\\\\\\\  |反斜线\n\\v|垂直制表                            |\\\\?   |问号\n\\b|光标位置退一格                               |\\ddd  |1到3位八进制ASCII码代表的字符\n\\f|换页                               |\\xhh  |1到2位十六进制ASCII码代表的字符\n</div>\n\n<div class=\"show\">1. \\ddd和\\xhh是用一个八进制或者十六进制的ASCII码表示一个字符，如：\"\\101\"和\"\\x41\"转换为十进制为65，表示ASCII码值为65的字符A\n2.注意\\r和\\b的使用，会覆盖掉\\r、\\b之前的字符\nprintf(\"abcdefg\\r1234\");//输出1234 fg，光标回到本行开头，1234\\0替换掉abcde(字符串末尾会添加\\0，因此\\0替换e并输出空白字符)\nprintf(\"abcdefg\\b\\b\\b\\b123\");//输出abc 123\nprintf(\"abcdefg\\b\\b\\b\\b\\b\\b\\b123\");//输出123 efg\nprintf(\"abcdefg\\b\\b\\b\\b\\b\\b\\b123\\n\");//输出123defg\n</div>\n\n### 字符串\n字符串常量使用<span class=\"tips\">双引号\"\"</span>包裹，字符串末尾会被加上<span class=\"tips\">'\\0'</span>作为字符串结束的标志。C语言中没有专门的关键字用来声明字符串变量，因此需要使用字符数组或者指针来存储和处理字符串\n\n#### 字符数组\n字符串可以存储于字符数组中，但字符数组中存储的并不一定是字符串，这取决于字符数组最后一个元素是否是字符串结束标志'\\0'，'\\0'也占用一个字节内存，但它不计入字符串的实际长度，只计入数组长度。注意，如果字符数组最后没有'\\0'，系统将无法将该数组当作字符串来处理(如：无法正确被printf(\"%s\",xx)输出)\n<div class=\"show\">对于字符数组，可以像其他数组一样用同样的方式初始化，如：\n<code>char str[6]={'H','e','l','l','o','\\0'};</code>\n如果省略对数组长度的声明，则必须人为在初始化列表中添加'\\0'，否则系统将无法将str当作字符串来处理\n<code>char str[]={'H','e','l','l','o'};//长度为5的普通字符数组\nchar str[]={'H','e','l','l','o','\\0'};//长度为6的字符串</code>\n用printf(\"%s\",str)语句输出上述变量时，第一个变量由于缺少'\\0'，输出语句会在输出完Hello后继续输出乱码，直到遇见'\\0'，而第二个变量会被正常输出\n\n也可以用字符串常量初始化字符数组，这样可以不指定数组大小，且由于字符串常量\"Hello\"末尾自带'\\0'，可以不必人为添加'\\0'\n<code>char str[6]={\"Hello\"};\nchar str[]={\"Hello\"};//数组长度可省略\nchar str[]=\"Hello\";//大括号可省略</code>\n<span class=\"text-red\">但只允许在定义时整体赋值，不允许在赋值语句中整体赋值</span>\n<code>char str[6];\nstr[]={\"Hello\"};//不允许先定义，定义完在赋值语句中整体赋值,Visual Studio报错：不允许使用不完整的类型</code>\n无论用哪种方式初始化字符数组，如果指定数组长度，都要保证预留足够空间以便存储字符串结束标志，即：字符数组大小一定要比字符串的实际字符数大1\n可以使用数组下标访问字符串的单个字符，如：\nstr[1]代表字符'e'</div>\n\n<div class=\"show\">一个字符串可以用一维字符数组存储，多个字符串可以用二维字符数组存储。数组的第一维长度代表要存储的字符串个数，可以省略；第二维长度不能省略，应当设定为最长那个字符串长度+1，eg:\n<code>char weekday[][10]={\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"};</code>\n其中最长的字符串\"Wendesday\"长度为9，因此第二维长度应当为10，对于长度小于10的字符串，其剩余的内存单元会被'\\0'填充\n如果字符串太长，可以拆分为几个小片段写在不同行，其中空格也将占用数组长度和空间\n<code>char longString[]=\"One day you will leave this world behind\"\n\"so live a life you will remember\"</code></div>\n\n#### 字符指针\n字符指针是指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一确定的地址，因此只要将字符串首地址赋值给指针变量，就可以让字符指针指向一个字符串。对于字符串常量，C语言按字符数组处理，在内存中开辟一个字符数组存储该字符串，字符串常量本身就代表存放它的常量存储区的首地址。\n\n<div class=\"show\">1. 以下两个初始化语句等价，均表示将字符串常量在常量存储区中\"Hello\"的首地址赋值给ptr\n<code>char * ptr=\"Hello\";</code>\n等价于\n<code>char * ptr;\nptr=\"Hello\";</code>\n2. 由于字符串常量存储于只读的常量存储区中，因此只可以修改指针变量的指向，不能修改ptr所指向存储单元的内容\n*ptr='a';//错误！写入权限异常，不能修改所指向存储空间的内容\nptr=\"another\";//允许修改指针的指向\n3. 通过指针也可以访问单个字符，如：\n*(ptr+1)代表字符'e'\n也可以修改指针指向位置，使其从所指位置开始输出，直至遇到'\\0'，以此输出字符串的部分内容，如：\n<code>char * sentence=\"Meet you like the wind\";\nsentence=sentence+14;\nprintf(\"%s\",sentence);//输出the wind</code>\n</div>\n\n#### 字符串的输出\n字符串的输出支持以下三种方法：\n<div class=\"show\">1. 依次输出单个字符\n<code>for(int i=0;i&lt;6;i++){\n    printf(\"%c\",str[i]);\n}</code>\n由于字符串长度并不等于字符数组大小，且上述方法无法灵活输出不同长度字符串，因此一般会借助字符串结束标志'\\0'来结束字符串输出，如：\n<code>for(int i=0;str[i]!='\\0';i++){\n    printf(\"%c\",str[i]);\n}</code>\n2. 用格式符s，将字符串作为一个整体输出，同样输出到字符串结束标志为止\n<code><span class=\"text-red\">printf(\"%s\",str)</span></code>\n3. 使用<span class=\"text-blue\">puts()</span>函数(&lt;stdio.h>库函数)，puts()函数用于从括号内的参数给出的地址开始，依次输出存储单元中的字符，直到遇到第一个'\\0'时输出结束，并自动输出一个换行符，缺点是该函数无法如printf()函数一样添加其他字符信息并控制输出格式\n<code><span class=\"text-red\">puts(str)</span></code>\n</div>\n\n字符串指针变量可以指向一个格式字符串，可以替代printf()函数中的格式，作为一种可变格式的字符串输出\n<div class=\"show\"><code>char * format;\nformat=\"a=%d,b=%f\\n\";\nprintf(format,a,b);\n也可以用字符数组实现\nchar format[]=\"a=%d,b=%f\\n\";\nprintf(format,a,b);</code></div>\n\n\n#### 字符串的输入\n与输出相似，字符串的输入支持以下三种方法：\n<div class=\"show\">1. 依次输入单个字符\n<code>for(int i=0;i&lt;6;i++){\n    scanf(\"%c\",&str[i]);\n}</code>\n2. 用格式符s，将字符串作为一个整体输入，直至遇到<span class=\"tips\">空白字符、空格、回车符、制表符</span>为止，注意！<span class=\"text-blue\">由于字符数组名str本身已经代表字符串的首地址，因此str前不能再加上取地址符&</span>，此外，用scanf()不能输入带空格、制表符的字符串，空格、制表符、回车符及其之后的字符会被留在输入缓冲区\n<code><span class=\"text-red\">scanf(\"%s\",str);</span></code>\n3. 使用<span class=\"text-blue\">gets()</span>函数(&lt;stdio.h>库函数)，gets()函数以回车符作为输入终止符，同时将回车符从输入缓冲区读走，但不作为字符串的一部分，因此该函数可用于输入带空格的字符串\n<code><span class=\"text-red\">gets(str);</span></code>\n\n以上方法都有一定的安全隐患，如果输入字符数超过了定义的字符数组大小，多出的字符可能引起缓冲区溢出，带来安全隐患，因此可以使用能限制输入字符串长度的函数\n<span class=\"text-blue\">fgets(str,sizeof(str),stdin)</span>\n该语句表示从标准输入stdin中读取一行长度为sizeof(str)的字符串存储到str为首地址的存储区中，多余的字符舍弃</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n注意！如果使用字符指针输入字符串，必须保证字符指针事先已经指向一个字符数组地址或确定的存储单元，否则可能导致非法内存访问错误！</div>\n<div class=\"show\">使用字符指针输入字符串需要注意以下情况\n<code>char * ptr;//ptr未被初始化\nscanf(\"%s\",ptr);</code>\n上述代码，编译时给指针变量ptr分配了内存单元，但ptr中的值是一个不可预料的垃圾值，该指针指向一个未确定的存储单元，可能指向空白存储区，也可能指向已经存放指令或数据的内存段，在现代编译器中会报错使用了未初始化的局部变量“ptr”，然而在低版本编译器中可能顺利通过编译，带来潜在安全隐患\n因此，推荐使用字符数组输入字符串\n<code>char str[10];\nscanf(\"%s\",str);</code>\n如果使用字符指针输入字符串，则保证该指针指向了确定的地址\n<code> char str[10];\n<span class=\"text-red\">char * ptr=str;</span>\n gets(ptr);</code>\n</div>\n\n### 构造类型\n#### 数组\n##### 一维数组\n定义方式： \n<div class=\"apiBox\">类型 数组名[数组长度]</div>\n\n数组名的命名规则遵守标识符命名规范，数组长度需要使用常量表达式，<span class=\"tips\">不能包含变量</span>，一维数组的初始化可以使用以下方法：\n+ 在定义时赋予全部初值，如：int nums[5]={0,1,2,3,4};\n+ 也可以只给一部分元素赋值，其余元素会被赋0(char类型赋'\\0')，如：int nums[5]={0,1};\n+ 如果全部元素相同，可以只写一个值，如:int nums[5]={0};\n+ 如果对全部元素赋予初值，由数据个数已经确定，可以不指定数组长度，如：int nums[]={0,1,2,3,4};\n\n<div class=\"show\">1. 数组在定义时可以被整体初始化赋值\n<code>int nums[5]={11,22,33,44,55};</code>\n<span class=\"text-red\">但不允许在赋值语句中被整体赋值</span>\n<code>int nums[5];\nnums[]={11,22,33,44,55};//错误</code>\n这是由于数组在定义时，编译系统就会为其分配连续的内存单元，其内存空间大小就已确定，后续的整体赋值语句如果执行，可能会导致内存覆盖或溢出等不可预期的行为，所以需要注意用数组和指针操作字符串时的不同情况\n<code>char str[6];\nstr[]={\"Hello\"};//错误\nchar * ptr;\nptr=\"Hello\";//正确</code>\n2. <span class=\"text-blue\">数组名代表数组首元素的内存地址，即数组的起始地址，是一个地址常量，不能像修改指针变量一样对数组名进行++或--等操作</span>\n<code>int a[10];int *p;\np=a;\np++;//允许，指针指向a[1]\na++;//不允许，a是数组首地址，无法修改</code>\n3. C语言数组无length属性，获取数组长度可借助sizeof()函数\n<code>int nums[] = {1,2,3,4,5};\nprintf(\"%d\", sizeof(nums)/sizeof(nums[0]));</code>\n</div>\n\n##### 二维数组\n定义方式： \n<div class=\"apiBox\">类型 数组名[数组长度][数组长度]</div>\n\n对数组名和数组长度的要求同一维数组，二维数组的初始化可以使用以下方法：\n+ 分行赋值，如：`int nums[3][2]={{1,2},{3,4},{5,6}}`\n+ 也可以一次性统一赋值，但不如第一种赋值方法清晰，如：`int nums[3][2]={1,2,3,4,5,6}`\n+ 可以只给部分元素赋值，同样其余元素会被赋0(char类型赋'\\0')，如：`int nums[3][2]={{1},{},{0,6}}`\n+ 如果对所有元素赋初值，可以不指定第一维的长度，但<span class=\"tips\">第二维的长度声明永远不能省略</span>\n\n### 结构体\n#### 结构体定义\n对于复杂数据对象，仅仅使用几种基本数据类型无法准确反映它们之间的内在联系，也无法做统一处理，于是衍生出了允许用户自定义的数据类型，C语言中称之为构造数据类型(复合数据类型)，结构体就是构造数据类型的典型代表\n\n结构体模板的声明格式如下：\n<div class=\"apiBox\">struct 结构体名\n{\n    结构体成员\n};\n</div>\n\n结构体模板只是声明了一种数据类型，并未声明结构体类型的变量，编译器不为其分配内存，需要再使用以下语句声明结构体变量，编译器才会为结构体变量分配内存：\n<span class=\"strong\">struct 结构体名 结构体变量名;</span>\n\n+ 结构体的名字又称为结构体标签，用于标记用户自定义的结构体类型，struct+结构体名 共同构成一个数据类型，如：下述例子中的struct student是一个类型名，作用同系统提供的标准类型(如int、char等)，因此不为其分配内存\n+ 结构体成员的命名遵从变量的命名规则\n+ 结构体成员也可以为一个结构体，即结构体可以嵌套\n+ 结构体成员名可以与程序其他位置的变量名相同，二者互不干扰\n\n<div class=\"show\">eg:先声明结构体模板，再声明结构体变量\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n};//声明结构体模板，末尾;不可省略\nstruct student stu1,stu2;//声明结构体变量</code></div>\n\n也可以在声明结构体模板时，定义结构体变量：\n<div class=\"apiBox\">struct 结构体名\n{\n    结构体成员\n}变量名1,变量名2...;</div>\n<div class=\"show\">eg:声明结构体模板同时声明结构体变量\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}stu1,stu2;</code>\neg:当结构体模板与结构体变量一起声明时，结构体名是可以省略的，但该方法由于未指定结构体名，无法在程序其他地方再定义结构体变量，因此并不常用\n<code>struct//无结构体名\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}stu1,stu2;</code></div>\n\n关键字<span class=\"strong\">typedef</span>用于为已有数据类型定义一个别名，数据类型别名通常大写，便于区分已有数据类型。定义结构体时可用typedef定义一个结构体别名，便于使用更简洁的形式定义结构体变量\n<div class=\"show\">为结构体定义别名时，以下两个别名定义形式等价：\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n};\n<span class=\"text-blue\">typedef struct student STUDENT;</span>\n与\n<span class=\"text-blue\">typedef</span> struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}<span class=\"text-blue\">STUDENT</span>;</code>\n二者都为struct student类型定义了一个新名字STUDENT，因此以下两条定义结构变量的语句等价：\n<code>STUDENT stu1,stu2;//简洁形式\nstruct student stu1,stu2;</code>\n</div>\n\n#### 结构体变量初始化与成员引用\n结构体变量的成员可以通过将成员初值置于花括号内进行初始化\n<div class=\"show\">eg:在定义结构体变量时初始化\n<code>STUDENT stu1={114604,\"SHIWIVI\",{111,222,333,444}}</code>\n也可以在定义结构体模板和变量同时初始化\n<code>struct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n}stu1={114604,\"SHIWIVI\",{111,222,333,444}}</code></div>\n\n访问结构体变量的成员必须使用<span class=\"tipe\">成员选择运算符</span>(圆点运算符)，访问格式为：\n<span class=\"apiBox\">结构体变量名.成员名</span>\n\n+ C语言规定，不能将结构体变量作为一个整体输入、输出，如：printf(\"%d%s..\",stu1)为非法语句\n+ 只能通过用圆点运算符访问结构体成员的方式来输入输出，如：printf(\"%s\",stu1.studentName)\n+ 成员运算符<span class=\"tips\">.</span>在所有运算符中优先级最高，因此通常可以将stu1.studentName当成一个整体看待\n+ 结构体嵌套时，必须以级联方式访问结构体成员，如：stu1.birthday.year\n+ 结构体成员可以像普通变量一样进行各种运算，如：stu1.birthday.year++\n+ C语言允许对具有相同结构体类型的变量进行整体赋值，如：stu1初始化后，可以通过stu2=stu1对stu2进行初始化，结构体成员会进行逐一顺序赋值\n+ 也可以使用=号对结构体成员进行分开赋值，但注意，当结构体成员为字符数组时，由于<span class=\"text-red\">字符数组名是该数组的首地址，是一个地址常量，不能作为赋值表达式左值</span>，因此对字符数组类型的结构体成员进行赋值时，必须使用字符串处理函数<span class=\"text-blue\">strcpy()</span>\n+ 结构体变量的地址是其所占存储空间的首地址，而结构体成员的地址与该成员在结构体中的所处位置和所占内存字节数有关，可以单独访问成员地址，如：&su1.studentID\n\n<div class=\"show\">\n<code>#include&lt;stdio.h&gt;\ntypedef struct date\n{\n    int year;\n    int month;\n    int day;\n}<span class=\"strong\">DATE</span>;\ntypedef struct student\n{\n    long studentID;\n    char studentName[10];\n    <span class=\"strong\">DATE</span> birthday;\n    int score[4];\n}\nint main(void){\n    STUDENT stu1={114604,\"SHIWIVI\",{1998,10,1},{111,222,333,444}};\n    STUDENT stu2;\n    <span class=\"text-blue\">stu2=stu1;//整体赋值</span>\n    //也可以对结构体成员分开赋值，整体赋值等价于下述赋值语句\n    stu2.studentID=stu1.studentID;\n    <span class=\"text-blue\">strcpy(stu2.studentName,stu1.studentName);</span>\n    stu2.birthday.year=stu1.birthday.year;\n    ...\n    stu2.score[0]=stu1.score[0];\n    ...\n    //通过键盘输入成员值时，单独访问成员变量地址\n    scanf(\"ld%\",&su1.studentID);\n    scanf(\"%s\",stu1.studentName);\n    scanf(\"%d\",&stu1.birthday.year);\n    for(int i=0;i&lt;4;i++){\n        scanf(\"%d\",&stu1.score[i]);\n    }\n    return 0;\n}\n</code></div>\n\n#### 结构体所占内存字节数\n系统为结构体变量分配内存大小时，结构体类型所占字节数，并非是所有成员所占内存字节数的总和，这是因为许多计算机系统为了提高寻址效率，处理器体系为特定的数据类型引入了<span class=\"strong\">内存对齐</span>需求，编译器为了满足处理器的对齐要求，会在较小的成员后加入补位，从而导致结构体实际所占内存字节数会比预计的多出一些字节。\n如：32位计算机体系结构，short型数据从偶数地址开始存放，int型数据则被对齐在4字节地址边界，这样就保证了一个int型数据通过一次内存操作就能被访问到，而读取存储在没有对齐地址处的32位整数，则需要两次读取操作，再从两次读取到的64位数据中提取该32位整数相关的数据，这样会导致系统性能下降\n\n因此计算结构体类型大小时一定要使用<span class=\"text-red\">sizeof()</span>运算符，不能想当然直接对各成员所占内存进行简单求和。\n\n<div class=\"show\"><code>#include&lt;stdio.h>\ntypedef struct sample {\n\tchar c1;\n\tint num;\n\tchar c2;\n}SAMPLE;\nint main(void) {\n\tSAMPLE s = { 'a',10,'b' };\n\tprintf(\"%d\", sizeof(s));//12而非6\n\treturn 0;\n}</code>\n根据内存对齐需求，如下图所示，c1和c2后会被增补3个字节补位，以达到与成员变量num内存地址对齐的要求，因此结构体变量s将占用12个字节的存储单元而非6个字节。如果将int类型改为short，则c1和c2将以short(2字节)为基准，后补1个字节空闲存储单元，s将占用6个字节内存\n\n<canvas width=\"200\" height=\"110\" id=\"canvasStruct\" style=\"display:block;width:200px;height:110px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>const canvasStruct=document.getElementById(\"canvasStruct\");\nconst ctxSt=canvasStruct.getContext('2d');\nctxSt.strokeRect(50, 10, 120, 90);\nctxSt.moveTo(50,40);\nctxSt.lineTo(170,40);\nctxSt.strokeRect(80, 10, 30, 30);\nctxSt.strokeRect(110, 10, 30, 30);\nctxSt.moveTo(50,70);\nctxSt.lineTo(170,70);\nctxSt.strokeRect(80, 70, 30, 30);\nctxSt.strokeRect(110, 70, 30, 30);\nctxSt.stroke();\nctxSt.font=\"600 13px Serif\";\nctxSt.fillText(\"成员1\", 10, 30);\nctxSt.fillText(\"c1\", 60, 30);\nctxSt.fillText(\"成员2\", 10, 60);\nctxSt.fillText(\"num\", 100, 60);\nctxSt.fillText(\"成员3\", 10, 90);\nctxSt.fillText(\"c2\", 60, 90);</script></div>\n\n#### 结构体数组\n与普通数组类似，结构体数组也可以在定义时统一初始化\n<div class=\"show\">eg:在结构体数组定义时初始化数组，如果只初始化部分数组元素，则其余数组元素会被自动赋为0值\n<code>STUDENT stu[3]={{1101,\"LiLin\",11,22,33,44},{1102,\"ZhangKe\",10,20,30,40},{1103,\"MaLong\",15,25,35,45}};//数组长度可以省略不写\n或\nstruct student\n{\n    long studentID;\n    char studentName[10];\n    int score[4];\n} stu[3]={{1101,\"LiLin\",11,22,33,44},{1102,\"ZhangKe\",10,20,30,40},{1103,\"MaLong\",15,25,35,45}};\n访问数组元素的方法与普通数组一样\nprintf(\"%ld\",stu[1].studentID);\n</code></div>\n\n#### 指向结构体的指针\n可以使用一个指针变量p指向一个结构体变量，此时该指针变量的值就是结构体变量的起始地址，随后，就可以使用<span class=\"text-red\">指向运算符</span>(箭头运算符)访问结构体的成员，以下三种访问结构体成员变量的方式等价：\n+ <span class=\"strong\">结构体变量.成员名</span>\n+ <span class=\"strong\">(*p).成员名</span>\n+ <span class=\"strong\">p->成员名</span>\n<div class=\"show\"><code>struct student stu1={1101,\"LiLin\",11,22,33,44};\n<span class=\"text-blue\">struct student * p=&stu1;</span>\nprintf(\"%ld\"，<span class=\"text-red\">stu1.studentID</span>);\nprintf(\"%ld\"，<span class=\"text-red\">(*p).studentID</span>);\nprintf(\"%ld\"，<span class=\"text-red\">p->studentID</span>);\n</code></div>\n\n指针也可以指向结构体数组，操作同指向普通数组类似，对指针进行的++操作会使指针指向下一个结构体数组元素\n<div class=\"show\"><code>STUDENT stu[3]={{1101,\"LiLin\",11,22,33,44},{1102,\"ZhangKe\",10,20,30,40},{1103,\"MaLong\",15,25,35,45}};\nstruct student * p=stu;\nfor(;p&lt;stu+3;p++){\n    printf(\"%s\\n\",p->studentName);\n}\n//p被定义为是指向struct student类型的指针，如果需要将其指向其他类型，可以使用强制类型转换\np=(struct student *)stu[0].studentName;\nprintf(\"%s\",p);//输出stu[0]的studentName\n//但此时p仍然保持原来的类型，p+1将指向stu[1]的studentName\nprintf(\"%s\",p+1);\n</code></div>\n\n### 共用体\n共用体(也称为联合,Union)是将不同类型的数据存放在一起，占用同一段内存的一种构造数据类型，共用体的声明形式与结构体类似：\n<div class=\"apiBox\">union 共用体名\n{\n    共用体成员\n};</div>\n\n+ 共用体类型所占内存大小取决于其成员中所占内存空间最大的成员变量\n+ 共用体同一内存段可以用来存放不同类型的数据，但在同一时间只能存放其中一种类型的成员，也就是说，同一时刻只能有一个成员起作用\n+ 共用体变量中起作用的成员是最后一个被赋值的成员，在存入一个新的成员值后，原有的成员值会被覆盖\n+ 共用体的成员一般单独赋值、调用\n+ 共用体变量的地址和其各成员的地址都是同一个地址\n+ 共用体不能进行比较操作\n+ 共用体不能作为函数参数，也不能作为函数返回值，但可以使用指向共用体变量的指针\n+ 不能只引用共用体变量，需要引用共用体的具体成员\n\n<div class=\"show\"><code>union sample\n{\n    short i;\n    char ch;\n    float f;\n};\nunion sample a;//共用体a中i,ch,f共占一段内存空间，因此a的大小由成员最大数据类型float决定，占用4个字节\na.i=10;//可以给共用体成员单独赋值\na.ch='R';\na.f=11.11;//完成上述3个赋值运算后，只有a.f有效，a.i和a.ch将被覆盖失效\n//如果在定义时初始化共用体的成员初值，C89规定只能对共用体的第一个成员进行初始化，但c99无该限制，允许按以下形式按名设置成员初值\n<span class=\"text-blue\">union sample b={.i=10,.ch='b',.f=22.22};</span>//但也只有f会生效\n</code></div>\n\n共用体可以用来存储程序中逻辑相关但情形互斥的变量，共享内存空间可以节省内存，也避免了操作失误引起的逻辑冲突。如：职工管理系统中，职工的个人婚姻状况只能有三种情况：未婚、已婚、离婚。且这三种情况应当是互斥的，此时可以用共用体来存储该数据\n<div class=\"show\">eg:未婚标识为0，已婚则记录结婚日期、配偶姓名，离婚则记录离婚日期\n<code>struct date\n{\n    int year;\n    int month;\n    int day;\n};\nstruct marriedState //已婚信息\n{\n    struct date marryDate;//记录结婚日期\n    char spouseName[20];//记录配偶姓名\n};\nstruct divorceState //离婚信息\n{\n    struct date divorceDay;//记录离婚日期\n};\n<span class=\"text-blue\">union maritalState</span> //共用体，存储婚姻状况\n{\n    int single;//未婚\n    struct marriedState married;//已婚\n    struct divorceState divorce;//离婚\n};\nstruct person\n{\n    char name[20];\n    char sex;\n    int age;\n    union maritalState marital;\n    int marryFlag; //共用体无法直接看出是哪个成员生效，因此使用一个变量标记婚姻状态\n};\n</code></div>\n\n共用体也可以用来构造混合数据结构，高效使用存储空间，如：需要存储的数据是int和float型数据的混合，可以定义如下共用体：\n<div class=\"show\"><code>typedef union\n{\n    int i;\n    float f;\n}NUMBER;\nNUMBER array[20];//既可以存储int数据，也可以存储float数据</code></div>\n\n### 枚举\n当一个变量只有几种固定的值时，就可以使用枚举表示，枚举类型的定义方法与结构体类似，需要使用enum关键字：\n<div class=\"apiBox\">enum 枚举标签名\n{\n    枚举常量\n}枚举变量名;</div>\n\n+ <span class=\"strong\">枚举常量都是整型常量</span>，除非特别指定，否则其值按顺序为0，1，2....\n+ 允许在定义时明确指定枚举常量的值，如：enum response {no=1,yes=1,none=0}，也可以只指定前几个值，其后的值会自动递增，如：enum month{Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec};\n+ 程序员在花括号内定义的枚举常量只作为标识符使用，并不代表什么含义，其值本质仍是整型常量，不是字符串\n+ 枚举常量可以作为整型值进行比较、输出操作\n+ 可以定义枚举型数组，如：enum response answers[10];\n\n<div class=\"show\"><code>enum response{no,yes,none};\nenum response res1,res2;\n或\nenum response{no,yes,none} res1,res2;\n或\nenum {no,yes,none} res1,res2;//枚举类型和枚举变量一起定义时，枚举标签可省略\n</code></div>\n\n<div class=\"show\"><code>1. 枚举变量的赋值只能从枚举常量中选取\nenum response{no,yes,none} res1,res2;\nres1=yes;//只能赋值no、yes、none中的其中一个\n2. 枚举变量可以用于条件语句，比较规则是按其定义时的整型值进行比较，默认情况下为：no=0,yes=1,none=2\nif(res1==yes)\nif(res1>none)\n3. 枚举常量的值是整型常量，因此只能作为整型值处理，而不能作为字符串来使用\nprintf(\"%d\",res1);//正确，输出res1为1\nprintf(\"%s\",res1);//错误！不能作为字符串使用，无法输出yes\n4. 虽然枚举常量都表示为整型常量，但不能直接将整型常量赋值给枚举变量，因为它们属于不同类型\nres1=2; //错误\n可以进行强制类型转换，相当于将值为2的none赋给res1，2也可以替换为表达式\nres1=(enum response)2;\n</code></div>\n\n### 指针\n#### 指针定义\n<div class=\"table\">\n\n定义|含义\n--------------|-----\nint * p       |指向整型数据的指针变量\nint *p[n]     |指针数组，数组中含n个指针\nint (*p)[n]   |二维数组的行指针，p指向含n个元素的一维数组\nint * p()     |p为返回指针的函数，该指针指向整型值\nint (*p)()    |p为指向函数的指针，该函数返回整型值\nint **p       |p为指向指针的指针，p指向的指针指向整型数据\n</div>\n\n+ <span class=\"strong\">指针</span>：一个变量的地址称为该变量的\"指针\"，反之亦然，变量的指针即变量的地址\n+ <span class=\"strong\">指针变量</span>：专门用于存放地址的变量\n+ <span class=\"strong\">&</span>：取地址运算符\n+ <span class=\"strong\">*</span>：指针运算符，取出指针变量指向的内容，又称为间接寻址运算符\n指针的定义：\n<div class=\"apiBox\">数据类型 * 变量名</div>\n\n<div class=\"show\"><code>int a=10;\nint * p;//定义int *类型的变量p，p只能用于存储地址，*只是表明该变量是指针变量\np=&a;//取出变量a的地址并存储到p中\nprintf(\"%d\",* p);//*p表示取出变量p中地址指向的内容，等价于printf(\"%d\",a)\nprintf(\"%p\",&a);//输出变量a在内存中所占存储空间的首地址，等价于printf(\"%p\",p)</code></div>\n\n使用指针的注意事项：\n+ <span class=\"text-red\">不要使用未初始化的指针变量</span>，未决定指针指向时，可以使指针变量初始化为<span class=\"text-blue\">NULL</span>(stdio.h中定义为零值的宏)\n+ 要永远清楚指针指向哪里，指针必须指向一块有意义的内存\n+ 要永远清楚每个指针指向的对象内容是什么\n\n#### 指针与数组\n使用指针操作数组可以有效提高运行速度，减小内存占用。数组在定义时，编译系统就会为其分配连续的内存单元，相应地，内存首地址也确定了。C语言中，数组名代表数组首元素的内存地址(数组名作形参时除外，此时数组名不占据内存单元)，因此可以直接将数组名赋值给指针变量\n<div class=\"show\">由于\n<ul><li>数组变量名代表数组起始内存地址</li><li>数组首元素地址也是数组起始内存地址</li></ul>因此指针初始化一般可以用两个赋值方法，两个赋值语句等价:\nint a[10]; int * p;\n<span class=\"text-red\">p=a;</span>或\n<span class=\"text-red\">p=&a[0];</span>\n</div>\n\n而后，就可以使用指针引用数组元素。对于指针变量p，p+1将指向数组的下一个元素，即地址跳到<span class=\"text-green\">1*sizeof(基类型)</span>个字节以后，而非对p中的地址进行简单加1，如：如果p指向int类型的数组，p+1会将p中的地址值增加4个字节对应的地址值，使其指向4个字节以后的空间。使用指针引用数组元素有以下特点：\n<div class=\"apiBox\">p+i和a+i均是a[i]的地址\n*(p+i)和*(a+i)均是a[i]的值\n</div>\n\n实际上，读取数组元素a[i]就是通过*(a+i)处理，即在数组首元素地址的基础上加上地址偏移量得到要找元素的地址，然后取出该地址中的数据，由此可得，<span class=\"tips\">[ ]实际上是变址运算符</span>，指向数组的指针变量也可以使用该变址运算符，如：p[i]等价于*(p+i)等价于i[p]\n<div class=\"show\">数组元素a[i]的表示方法有：\n<span class=\"strong\">a[i]</span>、<span class=\"strong\">i[a]</span>、<span class=\"strong\">p[i]</span>、<span class=\"strong\">i[p]</span>、<span class=\"strong\">*(a+i)</span>、<span class=\"strong\">*(p+i)</span>\n</div>\n\n#####  常用的指针变量运算\n+ <span class=\"strong\">\\*p++</span> 右结合，解析为*(p++)，先获得*p的值，再使p+1=>p\n+ <span class=\"strong\">\\*(++p)</span> 先对p加1，使其指向下一个元素，再获得此时*p的值\n+ <span class=\"strong\">(\\*p)++</span> 获得*p的值，并对该值加1\n+ <span class=\"strong\">\\*(p\\-\\-)，\\*(\\-\\-p)，(\\*p)\\-\\-</span> 与上类似\n\n##### 数组元素的遍历\n在遍历数组元素时，通过数组下标或通过数组元素地址遍历，二者执行效率是相同的，C编译系统对nums[i]的处理也是将其转换为*(nums+i)来作处理的，即根据首元素地址重新计算元素偏移地址，再访问该地址\n\n而通过指针变量遍历时，指针变量通过有规律地改变地址值(p++)，直接指向元素，不必每次都重新计算地址，极大提高了执行效率\n<div class=\"show\">遍历数组的三种方法：\nint nums[5]={11,22,33,44,55};\n//1.利用数组下标\nfor(int i=0;i&lt;5;i++){\n    printf(\"%d\",nums[i])\n}\n//2.通过求出数组元素地址，获得值\nfor(int i=0;i&lt;5;i++){\n    printf(\"%d\",*(nums+i))\n}\n<span class=\"strong\">//3.通过指针变量\nfor(int *p=nums;p&lt;(nums+5);p++){\n    printf(\"%d\",*p)\n}</span>\n注意：p++和p+1本质是两个不同的操作，特别对于指针变量而言，p++有赋值操作，会修改p的值从而使p指向下一个元素，而p+1并不改变当前指针的指向\n\n<span class=\"text-red\">数组名nums代表数组元素首地址，是一个指针常量，它的值是固定不变的，因此只能像*(nums+i)一样基于此地址进行计算,不能使用nums++改变该地址值</span>\nfor(int *p=nums;nums&lt;(p+5);nums++){//错误代码\n    printf(\"%d\",*a)\n}</div>\n\n#### 指针与函数传参\n使用指针作为函数参数时，不再是简单的<span class=\"tips\">值传递</span>，而是<span class=\"tips\">地址传递</span>，可以直接修改原参数的值\n\n<div class=\"show\">eg:将一个数组中的值反序存放并输出\n<code>#include&lt;stdio.h>\nint main(void) {\n\tvoid inv(int*, int);\n\tint nums[10] = { 0,11,22,33,44,55,66,77,88,99 };\n\tprintf(\"original array：\");\n\tfor (int* p = nums; p < nums + 10; p++) {\n\t\tprintf(\"%d \", *p);\n\t}\n    <span class=\"text-red\">inv(nums, 10);</span>\n\tprintf(\"\\ninverted array：\");\n\tfor (int* p = nums; p < nums + 10; p++) {\n\t\tprintf(\"%d \", *p);\n\t}\n\treturn 0;\n}\nvoid inv(<span class=\"text-red\">int * p,int n</span>) {//n为数组长度\n\tint temp;\n\tfor (int i = 0; i < n / 2; i++) {\n\t\ttemp = *(p+i);\n\t\t*(p + i) = *(p + n - 1 - i);\n\t\t*(p + n - 1 - i) = temp;\n\t}\n}</code>\n在函数中修改数组值，实参与形参的对应关系一般有以下4中\n1. 形参和实参都用数组名，形参接收实参的数组首地址，因此形参和实参数组共用一段内存空间。定义形参a[]时，可以不指定数组长度，因为编译器实际上是将形参数组名作为指针变量来处理，并不会真的开辟一个数组空间\nvoid inv(int a[],int n)             inv(nums,10)\n2. 实参用数组名，形参用指针变量。形参的指针初始指向数组元素首地址\nvoid inv(int *p,int n)              inv(nums,10)\n3. 实参和形参都用指针变量。实参n先指向数组首地址，再将该地址值传递给形参p，初始时两个指针指向同一个地址\nvoid inv(int *p,int n)              int *n=nums; inv(n,10)\n4. 实参为指针变量，形参为数组名。编译时，编译系统会将形参数组名作为a作为指针变量来处理，同样，初始时两个指针指向同一个地址\nvoid inv(int a[],int n)             int *n=nums; inv(n,10)\n</div>\n\n#### 二维数组与指针\n一维数组可以拓展到二维数组、三维数组等等，以二维数组为例，一个二维数组可以视为是由多个一维数组构成的，即二维数组的数组元素也是一个数组。\n\n<div class=\"show\">设一个3行4列的二维数组\n<code>{% raw %}int a[3][4]={{0,0,0,0},{11,11,11,11},{22,22,22,22}};{% endraw %}</code>\n对于该数组，可以视为数组a中包含3个元素：a[0],a[1],a[2]，而这3个元素每个都是一维数组:\n<span class=\"strong\">a[0]</span>==> a[0][0]、a[0][1]、a[0][2]、a[0][3]\n<span class=\"strong\">a[1]</span>==> a[1][0]、a[0][1]、a[0][2]、a[0][3]\n<span class=\"strong\">a[2]</span>==> a[2][0]、a[0][1]、a[0][2]、a[0][3]\n暂且忽略a[0],a[1],a[2]内部包含的内容，将它们当作普通的数组元素，由此：\n数组a是包含a[0]、a[1]、a[2]三个数组元素的一维数组，其中：\na是数组首元素a[0]的地址(即&a[0])，a+1是a[1]的地址(&a[1])，a+2是a[2]的地址(&a[2])，所以：\n<span class=\"strong\">a=&a[0]，a+1=&a[1]，a+2=&a[2]</span>;\n<span class=\"text-red\">*(a+0)=a[0]，*(a+1)=a[1]，*(a+2)=a[2]</span>;\n\n此时将a[0]、a[1]、a[2]展开，这三个元素每个都是一维数组，在这三个数组内部，a[0]、a[1]、a[2]分别是它们内部一维数组的数组名，又因为C语言中数组名代表数组首元素地址，因此：\na[0]即为a[0][0]的地址，即&a[0][0]，a[0]+1则为a[0][1]的地址 &a[0][1]......\n即：\n<span class=\"strong\">a[0]+0=&a[0][0]，a[0]+1=&a[0][1]，a[0]+2=&a[0][2]，a[0]+3=&a[0][3]</span>\n<span class=\"text-red\">\\*(a[0]+0)=a[0][0]，\\*(a[0]+1)=a[0][1]，\\*(a[0]+2)=a[0][2]，\\*(a[0]+3)=a[0][3]</span>;\n\n由于<span class=\"text-red\">a[0]和\\*a</span>等价，因此\na[0]+0与\\*(a+0)均是a[0][0]的地址，a[0]+1与\\*(a+0)+1均是a[0][1]的地址，其他同理，由此可得：\n<span class=\"text-blue\">\\*(a[0])=\\*(\\*(a+0)+0)=\\*\\*a=a[0][0]，\\*(a[0]+1)=\\*(\\*(a+0)+1)=\\*(\\*a+1)=a[0][1]</span>\n<span class=\"text-blue\">\\*(a[1]+2)=\\*(\\*(a+1)+2)=a[1][2]，\\*(a[2]+3)=\\*(\\*(a+2)+3)=a[2][3]</span>\n<span class=\"text-blue\">其他以此类推</span>\n\n<span class=\"text-red\">注意！\n对于一维数组，a[i]代表一个数组元素，占据内存单元，拥有物理地址，但在二维数组中，a[i]代表一维数组名，只是一个地址(如同一维数组中的数组名只是一个指针常量一样)，务必记住，a[i]和*(a+i)是等价的</span>\n</div>\n\n由上，总结：\n\n表示a[i][j]<span class=\"text-blue\">地址</span>的方法：\n+ <span class=\"text-blue\">a[i]+j</span>\n+ <span class=\"text-blue\">\\*(a+i)+j</span>\n+ <span class=\"text-blue\">&a[i][j]</span>\n\n表示a[i][j]<span class=\"text-red\">值</span>的方法：\n+ <span class=\"text-red\">\\*(a[i]+j)</span>\n+ <span class=\"text-red\">\\*(\\*(a+i)+j)</span>\n+ <span class=\"text-red\">(\\*(a+i))[j]</span>\n+ <span class=\"text-red\">a[i][j]</span>\n\n###### 二维数组的行指针与列指针\n<div class=\"show\">对于二维数组，其地址也可以分为行地址和列地址，如图所示：\n<div class=\"table\"><table><thead>\n<tr><th colspan=\"5\">二维数组存储</th></tr>\n</thead>\n<tbody>\n<tr style=\"color:#fb5b33;\"><td style=\"color:#056efb;\">行/列地址</td><td>a[i]+1</td><td>a[i]+2</td><td>a[i]+3</td><td>a[i]+4</td></tr>\n<tr><td style=\"color:#25ccf7;\">a+0</td><td>a[0][0]</td><td>a[0][1]</td><td>a[0][2]</td><td>a[0][3]</td></tr>\n<tr><td style=\"color:#25ccf7;\">a+1</td><td>a[1][0]</td><td>a[1][1]</td><td>a[1][2]</td><td>a[1][3]</td></tr>\n<tr><td style=\"color:#25ccf7;\">a+2</td><td>a[2][0]</td><td>a[2][1]</td><td>a[2][2]</td><td>a[2][3]</td></tr></tbody></table></div><p>其中，二维数组名a是指向行地址的，因此a+1中的\"1\"代表一个含有4个整型元素的一维数组所占存储单元的字节数，即<span class=\"text-green\">4*sizeof(int)</span>，a+1将指向下一行</p><p>一维数组名a[0]、a[1]、a[2]是指向列元素的，a[0]+1中的1代表一个整型元素所占存储单元的字节数，a[0]+1将指向下一个列元素</p><p>在指向行的指针前加一个*，就转换为指向列的指针，如：指针a和a+1是指向行的，而*a和*(a+1)则是指向列的，它们拓展为*(a+0)+0和*(a+1)+0，分别指向第0行0列元素和第1行第0列。反之，在指向列的指针前加上&，该指针就变成了指向行的指针，如：列指针a[0]指向第0行第0列的元素，而&a[0]等价于&*(a+0)，而&*a等价于a，因此&a[0]是指向第0行的行指针。注意，&a[i]不能理解为a[i]的物理地址，因为二维数组中并不存在a[i]元素，它只是一个地址计算方法，能得到第i行的起始地址。</p>\n练习：\na、a+0、&a[0]代表第0行首地址\n*a、*(a+0),a[0],a[0]+0代表第0行第0列的地址\n&a[0][0]代表第0行第0列元素地址\na[0][0]、**a代表第0行第0列元素值\na+i、&a[i]代表第i行地址\na[i]+j、\\*(a+i)+j,&a[i][j]代表第i行第j列地址\na[i][j]、\\*(\\*(a+i)+j)代表第i行第j列元素值\n</div>\n\n##### 二维数组元素的引用(指针变量)\n###### 通过二维数组的列指针变量引用\n由于列指针指向数组的具体元素，因此定义列指针与定义同类型普通指针相同：\n<span class=\"strong\">int * p</span>\n可以用以下三种等价方法对其进行初始化：\n\n+ <span class=\"strong\">p=a[0]</span>\n+ <span class=\"strong\">p=*a</span>\n+ <span class=\"strong\">p=&a[0][0]</span>\n\n此时，由于需要使用列指针对二维数组元素进行引用，因此可以将二维数组看成一个由m行*n列个元素组成的一维数组，获取第i行j列的元素，则其在一维数组中的索引为i\\*n+j，因此a[i][j]元素的地址为<span class=\"text-blue\">p+i\\*n+j</span>，其值表示方法为<span class=\"text-red\">\\*(p+i\\*n+j)</span>或<span class=\"text-red\">p[i\\*n+j]</span>\n\n注意，此时不能用p[i][j]来表示数组元素，因为给p赋初值时将其赋为了列指针，即是将二维数组作为一维数组来进行处理的，p++将使指针依次指向下一个数组元素。正因如此，在定义二维数组的列指针时，无须指定它所指向的二维数组的列数。因此二维数组的列指针也常常用作函数参数，以实现二维数组的行列数需要动态指定的场合。\n\n<div class=\"show\">eg:使用二维数组列指针引用数组元素\n<code>#include&lt;stdio.h>\nint main(void) {\n\tvoid outputArray(int *,int);\n\tint a[3][4] = { {11,11,11,11},{22,22,22,22},{33,33,33,33} };\n    <span class=\"text-red\">outputArray(a[0], 12);//列指针初始化int *p=a[0]</span>\n\t<span class=\"text-blue\">outputArray(*a, 12);//列指针初始化int *p=*a</span>\n\t<span class=\"text-green\">outputArray(&a[0][0], 12);//列指针初始化int *p=&a[0][0]</span>\n\treturn 0;\n}\nvoid outputArray(int* p, int length) {\n\tfor (int* index = p; index < p + length; index++) {\n\t\tprintf(\"%d,\", *index);\n\t}\n\tprintf(\"\\n\");\n}</code></div>\n\n###### 通过二维数组的行指针变量引用\n由于行指针不再指向数组元素，而是指向一维数组，因此行指针变量比较特殊：\n<span class=\"strong\">int (*p)[4]</span>\n可以用以下方法对其进行初始化：\n\n+ <span class=\"strong\">p=a</span>\n+ <span class=\"strong\">p=&a[0]</span>\n\n说明：定义了一个可指向含有4个元素一维整型数组的指针变量，[4]表示所指一维数组的长度，<span class=\"tips\">在声明变量时必须显式指定，不可省略!</span>该指针可以作为一个指向二维数组的行指针，且它所指向的二维数组的每一行有4个元素。注意：定义该行指针变量时( )也不可省略，因为[ ]优先级高于*，p会优先与[ ]结合，int *p[4]是指针数组的定义方式。\n可以用以下四种等价形式引用a[i][j]的值:\n+ <span class=\"strong\">p[i][j]</span>\n+ <span class=\"strong\">\\*(p[i]+j)</span>\n+ <span class=\"strong\">\\*(\\*(p+i)+j)</span>\n+ <span class=\"strong\">(\\*(p+i))[j]</span>\n\n对于行指针变量，p++将指向二维数组的下一行，即移动4\\*sizeof(int)字节，因此需要显式指定所指一维数组的长度int (\\*p)[4]，否则无法计算指针移动的字节数。\n\n<div class=\"show\">eg:使用行指针读入、输出二维数组元素\n<code>#include&lt;stdio.h>\n#define N 3\nint main(void) {\n    <span class=\"text-red\">//用普通的二维数组方式操作数组\n    void inputArray(int p[][N], int,int);\n    void outputArray(int p[][N], int,int);</span>\n\t<span class=\"text-blue\">//只使用行指针操作数组元素\n    void inputArray(int(*p)[N], int, int);\n\tvoid outputArray(int(*p)[N], int, int);</span>\n\tint a[2][3];\n\tprintf(\"Input 2*3 numbers:\\n\");\n\tinputArray(a, 2,3);//把数组行数和列数也传参\n\toutputArray(a, 2,3);\n\treturn 0;\n}\n<span class=\"text-red\">void inputArray(int p[][N], int rows,int columns) {</span>\n<span class=\"text-blue\">void inputArray(int (*p)[N], int rows, int columns) {</span>\n\tprintf(\"Input numbers:\\n\");\n\tfor (int i = 0; i < rows; i++) {\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n            <span class=\"text-red\">scanf_s(\"%d\", &p[i][j]);</span>\n            <span class=\"text-blue\">scanf_s(\"%d\", *(p+i)+j);</span>\n\t\t}\n\t}\n}\n<span class=\"text-red\">void outputArray(int p[][N], int rows, int columns) {</span>\n<span class=\"text-blue\">void outputArray(int (*p)[N], int rows, int columns) {</span>\n\tprintf(\"Output numbers:\\n\");\n\tfor (int i = 0; i < rows; i++) {\n\t\tfor (int j = 0; j < columns; j++)\n\t\t{\n            <span class=\"text-red\">printf(\"%d,\", p[i][j]);</span>\n            <span class=\"text-blue\">printf(\"%d,\", *(*(p+i)+j));</span>\n\t\t}\n\t}\n}</code>\n</div>\n\n#### 指向函数的指针\n一个函数在编译时被分配一个入口地址，与数组类似，函数名代表该函数的入口地址，函数的入口地址就称为该函数的指针，可以用一个指针变量指向函数，然后通过该指针变量调用该函数，指向函数的指针变量的定义形式为：\n<span class=\"strong\">函数返回值类型 (* 指针变量名)(函数参数)</span>\n\n+ 定义举例：int (*p)(int,int)，表示定义一个指向函数的指针变量p，它可以任意指向同类型的不同函数(该函数应是int类型且有两个int参数)，并非固定指向一个函数\n+ \\*p两侧的括号不能省略，p先与\\*结合表明是指针变量，再与后面的( )结合表明该指针变量指向函数\n+ 对指向函数的指针变量进行p++、p+n等操作是无意义的\n\n<div class=\"show\">eg:\n<code>int main(void){\n    int getMax(int,int);\n    <span class=\"text-blue\">int (*p)(int,int);</span>//定义指向函数的指针\n    int a=10,b=20;\n    <span class=\"text-blue\">p=getMax;</span>//将函数地址赋给p，不涉及实参和形参问题，因此不需要写任何参数\n    int result=<span class=\"text-blue\">(*p)(a,b)</span>;//使用指针调用函数，只需用(*p)替代函数名即可\n    return 0;\n}\nint getMax(int a,int b){\n    return a>b?a:b;\n}\n</code></div>\n\n函数指针变量的用途之一是将函数作为参数传递到其他函数，即实现函数入口地址的传递，常见用法是：调用同一个函数时，在不同情况下实现不同的功能\n<div class=\"show\">eg:多次调用process函数，依次实现求最大值、求和、求积功能\n<code>#include&lt;stdio.h>\nint main(void) {\n\tint getMax(int, int);\n\tint add(int, int);\n\tint multiply(int, int);\n    <span class=\"text-blue\">void process(int, int, int (* fun)(int, int));</span>\n\tint a = 10, b = 20;\n    <span class=\"text-blue\">process(a, b, getMax);\n\tprocess(a, b, add);\n\tprocess(a, b, multiply);</span>\n\treturn 0;\n}\nvoid process(int a,int b,int (* fun)(int,int)) {\n\tint result =<span class=\"text-blue\">(*fun)(a, b)</span>;//fun指向不同函数地址，实现不同功能\n\tprintf(\"%d\\n\", result);\n}\nint getMax(int a, int b) {\n\treturn a > b ? a : b;\n}\nint add(int a, int b) {\n\treturn a + b;\n}\nint multiply(int a, int b) {\n\treturn a * b;\n}</code></div>\n\n#### 返回指针的函数\n函数除了可以返回整型值、字符值等，也可以返回一个指针(返回一个地址)，这种返回指针的函数，定义形式为:\n<span class=\"strong\">类型 * 函数名(参数)</span>\n\n+ 函数定义举例：int * fun(int,int)，定义一个函数fun，该函数返回类型为int \\*，即返回一个指针，该指针指向int类型的数据，函数名fun和\\*两侧没有( )，fun先与(int,int)结合表明fun()是个函数\n+ 通过返回指针，C语言就可以实现返回数组、字符串等数据\n\n<div class=\"show\">eg:拼接两个字符串，返回一个新的字符串\n<code>#include&lt;stdio.h>\nint main(void) {\n\tchar* str1 = \"aaa\", * str2 = \"111\";\n\tchar result[20];//存储拼接后的字符串，空间要足够大\n    <span class=\"text-blue\">char* strCat(char*, char*,char *);</span>\n\tprintf(\"%s\", strCat(result, str1, str2));\n\treturn 0;\n}\nchar* strCat(char * result,char* str1, char* str2) {\n\tchar* p = result;\n\twhile (*str1 != '\\0') {\n\t\t*p = *str1;\n\t\tstr1++;\n\t\tp++;\n\t}\n\twhile (*str2 != '\\0') {\n\t\t*p = *str2;\n\t\tstr2++;\n\t\tp++;\n\t}\n\t*p = '\\0';//拼接后的字符串末尾加上字符串结束标志符\n\treturn result;//返回result数组的初始起始地址\n}</code>\n</div>\n\n#### 指针数组\n一个数组，若其元素均为指针，则该数组为指针数组，一维指针数组的定义形式为：\n<span class=\"strong\">类型名 * 数组名[数组长度]</span>\n\n+ 如：int \\*p[4]，p先与[4]结合，形成p[4]，表明这是一个数组，再与\\*结合，表明该数组是指针类型\n+ 注意区分于int (*p)[4]，这是指向一维数组的指针变量，即指向二维数组指针变量中的行指针\n+ 指针数组可用于指向不等长字符串、不等长数组等场景\n\n<div class=\"show\">指针数组可以指向若干不等长的字符串，如果用二维数组存储字符串，需要指定第二维的长度(一般为最长字符串的长度+1)，相较于二维数组，指针数组更为灵活快捷\neg:将若干字符串按字母顺序排序\n<code>#include&lt;stdio.h>\n#include&lt;string.h>\nint main(void) {\n\tvoid sort(char* ptr[], int length);\n    <span class=\"text-blue\">char* ptr[]</span>= { \"Document\",\"ASCII\",\"Java\",\"CPP\" };\n\t sort(ptr, 4);\n\t for (int i = 0; i < 4; i++) {\n\t\t printf(\"%s\\n\", ptr[i]);\n\t }\n\treturn 0;\n}\nvoid sort(char* ptr[], int length) {\n\tchar* temp;\n\tint i, j, k;\n\tfor (i = 0; i < length-1; i++) {\n\t\tk = i;\n\t\tfor (j = i + 1; j < length; j++) {//内循环找出全部字符串中字符顺序最小的字符串\n\t\t\tif (strcmp(ptr[k], ptr[j]) > 0) {//strcmp()函数，ptr[k]中的字母在ASCII中位置大于ptr[j]，则返回值大于0\n\t\t\t\tk = j;\n\t\t\t}\n\t\t}\n\t\tif (k != i) {//如果找到的字符串不是i，调换顺序\n\t\t\ttemp = ptr[i]; ptr[i] = ptr[k]; ptr[k] = temp;\n\t\t}\n\t}\n}\n</code></div>\n\n#### 指向指针的指针\n指针变量也可以指向一个另一个指针，指向指针的指针变量定义形式为：\n<span class=\"strong\">类型 *** 变量名</span>\n\n+ 如：char **p，指针变量p指向另一个指针变量，被p指向的指针变量指向一个字符型数据\n+ 结合上一节的指针数组，就可以用指向指针的指针操作指针数组中的指针所指向的数据\n+ 理论上指向指针的指针可以无限套娃，如：int \\*\\*\\*\\*\\*p，但多层指针嵌套容易混乱，难以理解\n\n<div class=\"show\">1. eg:用指向指针的指针输出指针数组指向的内容\n<code>#include&lt;stdio.h>\nint main(void){\n    char* ptr[]= { \"Document\",\"ASCII\",\"Java\",\"CPP\" };\n    <span class=\"text-blue\"> char **p;</span>\n    for(int i=0;i&lt;4;i++){\n        p=ptr+i;\n        printf(\"%s\\n\",<span class=\"text-blue\">*p</span>);\n    }\n}</code>\n2. eg:注意输出字符串、数组数据与整型等其他普通类型数据时，指针运算符(间接寻址运算符)需要取到哪一层值(取出的值是地址值还是变量本身的值)\n<code>#include&lt;stdio.h>\nint main(void){\n\tint a = 11, b = 22;\n\tint c = a + b;\n\tint d = a + b + c;\n\tint* nums[] = { &a,&b,&c,&d };\n    <span class=\"text-blue\">int** p=nums;</span>\n\tfor (int i = 0; i < 4; i++,p++) { \n\t\tprintf(\"%d\\n\",<span class=\"text-blue\">**p</span>);\n\t}\n\treturn 0;\n}</code>\n</div>\n\n#### void * 无类型指针\nvoid *称为通用指针或无类型指针，用于声明基类型未知的指针变量，即声明了一个指针变量，但未指定它指向哪一种基类型的数据。它可以指向任意类型的数据，只需要在将它的值赋给其他类型的指针变量时，进行强制类型转换即可。ANSI标准要求动态分配内存的函数(malloc、calloc等)返回类型为void *无类型指针，方便将其转换为其他任意类型的指针变量。\n\n注意区别于<span class=\"tips\">空指针(NULL)</span>，空指针未指向任何有效内存(指向低地址保留区)，而<span class=\"tips\">void *</span>当值不为NULL时，它指向了有效内存空间，只是尚未指定它指向的基类型。\n\n<div class=\"show\">void *和其他类型的指针可以相互转换\n<code>char *str;\nvoid *p;\nstr=(char *)p;\n或\np=(void *)str;</code>\n动态分配内存函数返回值根据指向数据类型需要转换为其他类型\n<code>int * p=(int *)malloc(10*sizeof(int));</code></div>\n\n#### 指针数组与main函数的形参\n一般情况下，main函数一般会写为空参数形式：int main(void)，实际上main函数可以带有参数，如：\n<span class=\"strong\">int main(int argc,char * argv[])</span>\nJava语言中的main默认就为上述形式，argc和argv就是main函数的形参。main函数由操作系统调用，在main所在的.c文件被编译后，会生成可执行文件(windows下后缀为.exe)，在系统命令终端下(如：Linux的shell、windows的cmd)，输入<span class=\"strong\">文件路径/可执行文件名 参数1 参数2...</span>即可调用该可执行文件并将参数传递给main函数\n\n<div class=\"show\">假设main函数写于文件file.c文件中，编译后生成file.out文件\n在该文件所属路径下执行命令：<span class=\"strong\">file.out data1 data2</span>\n对于main函数原型<span class=\"strong\">int main(int argc,char * argv[])</span>\nargc指命令行中的参数个数，argv[]是存储参数字符串首地址的指针数组\n它收到3个命令行参数：file.out，data1，data2 //file.out也算一个参数\n所以argc=3，\"file.out\"、\"data1\"、\"data2\"字符串的首地址构成一个指针数组，存储于argv中：\nargv[0]--->\"file.out\\0\"\nargv[1]--->\"data1\\0\"\nargv[2]--->\"data2\\0\"\n由于并不清楚输入的参数会多长，使用指针数组就可以巧妙解决这个问题\n可以写一个main函数输出执行时传入的参数内容：\n<code>int main(int argc,char * argv[]){\n    while(argc&gt;1){\n         ++argv;\n        printf(\"%s\\n\",*argv);\n        --argc;\n    }\n}</code>\n</div>\n\n### 运算符\n#### 运算符优先级与结合性\n<div class=\"table\">\n<table>\n<thead>\n<tr><th>优先级</th><th>运算符</th><th>名称</th>\n<th>使用</th><th>说明</th><th>结合方式</th></tr>\n</thead>\n<tbody>\n<tr><td rowspan=\"4\">1</td><td>[&nbsp;]</td><td>数组下标</td><td>数组名[]</td><td rowspan=\"4\"></td><td rowspan=\"4\">从左到右</td></tr>\n<tr><td>(&nbsp;)</td><td>圆括号</td><td>(表达式)</td></tr>\n</tr><td>.</td><td>成员选择（对象）</td><td>对象.成员名</td></tr>\n</tr><td>-&gt;</td><td>成员选择（指针）</td><td>对象指针->成员名</td></tr>\n<tr><td rowspan=\"9\">2</td><td>-</td><td>负号</td><td>-表达式</td><td rowspan=\"9\">单目运算符</td><td rowspan=\"9\"><span class=\"tips\">从右到左</span></td></tr>\n<tr><td>(类型)</td><td>类型转换</td><td>(数据类型)表达式</td></tr>\n<tr><td>sizeof(&nbsp;)</td><td>长度运算符</td><td>sizeof(表达式)</td></tr>\n<tr><td>！</td><td>逻辑非</td><td>!表达式</td></tr>\n<tr><td>~</td><td>按位取反</td><td>~表达式</td></tr>\n<tr><td>*</td><td>取值</td><td>*指针变量</td></tr>\n<tr><td>&</td><td>取地址运算符</td><td>&变量名</td></tr>\n<tr><td>++</td><td>自增</td><td>++变量名或\n变量名++</td></tr>\n<tr><td>--</td><td>自减</td><td>--变量名或变量名--</td></tr>\n<tr><td rowspan=\"3\">3</td><td>*</td><td>乘</td><td>表达式*表达式</td><td rowspan=\"3\">双目运算符</td><td rowspan=\"3\">从左到右</td></tr>\n<tr><td>/</td><td>除</td><td>表达式/表达式</td></tr>\n<tr><td>%</td><td>求余</td><td>表达式%表达式</td></tr>\n<tr><td rowspan=\"2\">4</td><td>+</td><td>加</td><td>表达式+表达式</td><td rowspan=\"2\">双目运算符</td><td rowspan=\"2\">从左到右</td></tr>\n<tr><td>-</td><td>减</td><td>a-b</td></tr>\n<tr><td rowspan=\"2\">5</td><td>&lt;&lt;</td><td>左移</td><td>变量&lt;&lt;表达式</td><td rowspan=\"2\">双目运算符</td><td rowspan=\"2\">从左到右</td></tr>\n<tr><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td></tr>\n<tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=</td><td>关系运算(大于，大于等于，小于，小于等于)</td><td>a&lt;b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>7</td><td>==、!=</td><td>是否等于</td><td>if(a==b)</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>8</td><td>&</td><td>按位与</td><td>a&b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>9</td><td>^</td><td>按位异或</td><td>a^b</td>\n<td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>10</td><td>|</td><td>按位或</td><td>a|b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>11</td><td>&&</td><td>逻辑与</td><td>a&&b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>12</td><td>||</td><td>逻辑或</td><td>a||b</td><td>双目运算符</td><td>从左到右</td></tr>\n<tr><td>13</td><td>?&nbsp;:</td><td>条件运算</td><td>a>b?true:false</td><td>三目运算符</td><td><span class=\"tips\">从右到左</span></td></tr>\n<tr><td rowspan=\"2\">14</td><td>=</td><td>赋值运算</td><td>a=10</td><td rowspan=\"2\">双目运算符</td><td rowspan=\"2\"><span class=\"tips\">从右到左</span></td></tr>\n<tr><td>+=、-=、*=、/=、%=、>>=、<<=、&=、^=、|=</td><td>运算后赋值</td><td>a+=10</td></tr>\n<tr><td>15</td><td>,</td><td>逗号运算符(按顺序求值)</td><td>a,b,c</td><td></td><td>从左到右</td></tr>\n</tbody>\n</table>\n</div>\n\n#### 赋值与复合赋值\n静态变量和全局变量的赋值在编译阶段进行，而局部自动变量的赋值在程序运行到该语句时进行。赋值语句遵循<span class=\"tips\">右结合</span>原则(从右向左运算)\n<div class=\"show\">1. 赋值遵循右结合\nint a,b,c;\na=b=c=0;执行过程为a=(b=(c=0))\n2. 复合赋值\nn*=m+1;\n等价于n=n*(m+1)\n3. 复合赋值会即时修改变量值\nint a=3;\na+=a-=a*a;//执行完a=-12\na+=a-=a*=a;//执行完a=0\n</div>\n\n赋值语句需要注意：将字节数长的数据赋值给字节数短的变量，会截取部分数据，也可能造成整个数据错误\n+ 浮点型(float、double)数据赋值给整型变量，将舍弃小数部分\n+ 将double数据赋值给float变量，将截取前7位有效数字\n+ 将int、short、long型数据赋值给char变量，只截取该数据的低8位到char变量中\n+ 将unsigned 数据赋值给有符号整型时，进行高位补0即可，但如果该unsigned 数据的数值超出了有符号整型最大值范围时，会产生数据错误!\n\n将字节数短的数据赋值给字节数长的变量，一般需要进行位拓展\n+ 将整型数据赋值给浮点型变量，数值不变，拓展小数部分为0以浮点数形式进行存储\n+ 将float数据赋值给double，数值不变，拓展有效位数\n+ 将char数据赋值给整型变量，将char的1个字节数据存储到低8位，如果该整型变量为无符号整型(unsigned)，则高8位补0。如果该整型变量为有符号整型，且该char字符最高位为0，则高8位补0，若char字符最高位为1，则高8位补1，以保证char对应的数值不变\n+ 将带符号的int赋值给long型变量，将int的值存入long的低16位，如果int为正整数(最高位为0)，则long的高16位补0，反之补1\n\n#### 自增与自减\n用于对变量进行加1或减1操作，自增和自减运算符都属于一元运算符，只需要一个操作数，且<span class=\"tips\">操作数必须是变量，不能是常量或表达式</span>。自增与自减运算符分为前缀(如++i)和后缀(i++)形式。区别在于前缀是先对变量进行加1操作，再使用变量。后缀形式是先使用变量的当前值，再进行加1操作，自减运算符同理。\n<div class=\"show\">-i++;//应当解析为-(i++)，而非(-i)++，因为自增运算符操作数不能为表达式-i，(-i)++是非法语句\ni+++j;//应当解析为(i++)+j，C编译系统会从左至右尽可能多地将若干个字符组成一个运算符\n</div>\n\n#### 逗号表达式\n<span class=\"strong\">表达式1,表达式2,...表达式n</span>\n用于串联多个表达式，表达式从左至右顺序运算，<span class=\"tips\">整个逗号表达式的值是最后一个表达式的值</span><span class=\"tips\"></span>。多数情况下，逗号表达式仅用来顺序求值，并不一定用到整个逗号表达式的最终值。常见的情况是用于for语句进行多个变量的顺序运算，<span class=\"tips\">逗号表达式的运算优先级是所有运算种最低的</span>。\n\n<div class=\"show\">a=2*5,a*4;//逗号表达式运算优先级最低，所以a=10，整个逗号表达式值等于40\nb=(a=2*5,a*4);//正确获得逗号表达式值的方法，运算结果：a=10,b=40\n(a=3*5,a*4),a+5;//逗号表达式也可以嵌套到其他的逗号表达式中，运算结果：a=15，逗号表达式=20\nfor(i=0,j=0;i&lt;array.length,j&lt;i;i++,j++);//逗号表达式常用于for语句多变量运算\nprintf(\"%d,%d,%d\",a,b,c);//逗号用于间隔函数参数,并不是逗号表达式\nprintf(\"%d,%d,%d\",(a,b,c),b,c);//(a,b,c)是逗号表达式，输出值为c的值\n</div>\n\n#### 位运算\n位运算是直接对二进制位进行运算，<span class=\"tips\">只能用于整型或字符型数据</span>，不能用于浮点型，位运算符常用于编写系统软件。对于需要两个操作数的位运算，如果给的两个操作数长度不同，则系统将给较短的操作数高位补0或1，以保证两个操作数长度相同。如果该数是无符号数或者正数，则高位补0，如果为负数则高位补1。\n###### 取反~\n取反运算为单目运算符，用于将二进制数按位取反,eg:~12=-13\n\n###### 按位与&\n对两个数的二进制码进行按位与，该运算有一些特殊用途：\n+ 数据清零，使之与0相与即可将所有二进制位置为0\n+ 保留或截取一个数中的某些指定位\n\n<div class=\"show\">1. 正数取原码相与，负数取其补码相与\n3&5=1\n   0000 0011\n   0000 0101\n ------------\n   0000 0001  \n2. 若要保留一个数的低4位，将其与0000 1111相与\n  1100 1011\n  0000 1111\n -----------\n  0000 1011 </div>\n\n###### 按位或|\n可用于将指定的二进制位置为1\n\n###### 按位异或^\n\n+ 使指定二进制位翻转\n+ 交换两个值，不使用临时变量\n+ 一个数与0相^，保留原值\n+ 一个数同本身相^，结果为0\n\n<div class=\"show\">1.使0100 1011的低四位翻转，可以与0000 1111相异或\n0100 1011\n0000 1111\n----------\n0100 0100\n2. 异或可以交换两个值，且不使用临时变量\neg:a=3,b=4;交换a与b的值，可以使用：\na=a^b;\nb=b^a;\na=a^b;\n解析：\n由上述语句1,2可得：b=b^a=b^(a^b)=a^b^b=a^0=a;\n即b获得了a的值\n由语句3可得：a=(a^b)^(a^b^b)=a^a^b^b^b=b;\n</div>\n\n###### 左移运算符&lt;&lt;\n将一个数的二进制位左移若干位，高位溢出部分舍弃，低位补0。一个数左移n位，如果左边被舍弃的部分全为0，则该数相当于乘以2<sup>n</sup>\n<div class=\"show\">int result = 30&lt;&lt;2;//result=120</div>\n\n###### 右移运算符&gt;&gt;\n将一个数的二进制位右移若干位，低位溢出部分舍弃，高位补的值取决于该数值本身。如果是无符号数，或者该数符号位为0(该数为正)，则高位补0，如果该数为负数，高位补0还是补1取决于编译器，补0称为\"逻辑右移\"，补1称为\"算术右移\"。\n\n同理，如果右边移除部分均为0，则右移n位相当于该数除以2<sup>n</sup>\n\n###### 位运算赋值运算符\n位运算和赋值运算可以组成复合赋值运算符，如：&=、|=、&lt;&lt;=、&gt;&gt;=、^=等\n<div class=\"show\">a&lt;&lt;=2等价于a=a&lt;&lt;2</div>\n\n#### 关系运算符\n注意，关系运算符的优先级<span class=\"tips\">低于</span>算术运算符，<span class=\"tips\">高于</span>赋值运算符，且关系运算符中<span class=\"tips\">&lt;</span>、<span class=\"tips\">&lt;=</span>、<span class=\"tips\">&gt;</span>、<span class=\"tips\">&gt;=</span>的优先级是高于<span class=\"tips\">==</span>、<span class=\"tips\">!=</span>的\n\n<div class=\"show\">c&lt;a+b等价于c&lt;(a+b)\na=b&gt;c等价于a=(b&gt;c)\na==b&lt;c应当等价于a==(a&lt;c)\n</div>\n\n#### 逻辑运算\n逻辑运算符中优先级顺序为<span class=\"tips\">!高于&&高于||</span>，且&&和||有<span class=\"tips\">短路特性</span>\n\nC语言中没有逻辑常量true和false，编译器在表示逻辑时使用1代表真，0代表假，在表示数值时，以非0代表真，0代表假\n<div class=\"show\">优先计算!，再计算&&，最后计算||\n!a&&b||x>y&&c\n</div>\n\n#### 条件运算(三元表达式)\n<span class=\"strong\">条件判断语句?表达式1:表达式2</span>\n先求解条件判断语句，若为真则执行表达式1，整个条件表达式的值\n为表达式1的值，否则执行表达式2并作为条件表达式的值\n\n<div class=\"show\">1. 条件运算符优先级高于赋值\nmax=a>b?a:b;等价于max=(a>b?a:b);\n2. 条件运算符结合方向为从右至左\na>b?c:d>e?f:g;等价于a>b?c:(d>e?f:g)\n</div>\n\n### 选择与循环控制\n#### 选择语句\n<span class=\"tips\">if()..else</span>、<span class=\"tips\">while()</span>、<span class=\"tips\">do...while()</span>、<span class=\"tips\">for</span>\n\n##### switch多分支选择\n<div class=\"apiBox\">switch(表达式)\n  {\n    case 常量表达式:语句1\n    case 常量表达式:语句2\n    ....\n    default:       语句n\n}</div>\n\n+ case语句只起语句标号的作用，并不是在该处进行条件判断\n+ switch语句表达式的值找到匹配的case入口标号后，会一直执行下去，不再进行判断，直到执行完或遇到break语句\n\n<div class=\"show\">1.满足匹配条件后，将依次执行后面的所有case语句，所以需要及时break。并且由于是依次执行，所以case后面是多个语句也不需要使用{ }括起来\nswitch(num)\n  {\n    case 1:printf(\"get 1\");//如果num=1，则将输出get1、get2\n    case 2:printf(\"get 2\");break;\n    case 3:{printf(\"get 3\");break;}//可以不使用{ }\n    default:printf(\"error\\n\");\n}\n2. 多个分支可以共用一个执行语句\nswitch(num)\n  {\n    case 1:\n    case 2:\n    case 3:printf(\"down\");break;\n    default:printf(\"error\\n\");\n}\n</div>\n\n##### break与continue\nbreak用于终止循环和跳出switch，只能用于循环语句和switch语句。continue用于结束本次循环，代码将继续下一次循环判定。使用goto语句的形成的循环体不能使用这两个语句跳出循环。\n<div class=\"show\">while(i&lt;10){\n    if(i==5) break;\n    .....\n    i++;\n}\nwhile(i&lt;10){\n     i++;\n    if(i==5) continue;\n    .....\n}\n</div>\n\n##### goto语句\ngoto语句为无条件转向语句，语法为：\n<div class=\"apiBox\">goto 语句标号;</div>\n\n语句标号用标识符表示，命名规则同变量，常用于组成循环，或者从循环内部跳出循环，但会导致程序可读性差，结构混乱，应当谨慎使用。\n<div class=\"show\">int i,sum;\ni=sum=0;\nloop:if(i&lt;10){\n    sum+=i;\n    i++;\n    goto loop;\n}\n</div>\n\n### 函数\n#### main函数\n谭浩强书的主函数一般写为void man()，但C语言标准(C99)定义的标准main函数写法为\n<div class=\"apiBox\">int main(void){\n    .....\nreturn 0; \n}\n或者\nint main(int argc,char argv[]){.....return 0;}\n</div>\n\n<div class=\"show\">在C语言中\nint main()表示主函数可以传入任意个数的参数，而int main(void)表示该函数参数为空，不能传入任何参数\n在C++中，int main()和int main(void)等效\n</div>\n\n#### 标准输入输出函数\nC语言本身不提供输入输出语句，输入输出操作由C函数库中的函数提供支持。这是因为输入输出涉及到硬件操作，没有输入输出语句可以让C语言编译器避免在编译阶段处理硬件有关的问题，可以极大地简化编译系统，并提高其通用性和可移植性。\n\nC函数库由各软件公司编写，并已经编译成目标文件(.obj文件)，源程序中的printf()等语句在编译阶段并不会被编译为目标指令，而是等待链接阶段源程序和库函数链接后，在执行阶段直接调用库函数目标文件(.obj文件)中的printf()函数。不同函数库提供的函数名、功能完全不同，但有一些通用的\"标准输入输出函数\"，调用这些函数需要引入头文件<span class=\"tips\">#inculde&lt;stdio.h></span>\n\n##### printf输出函数\n标准输出语句格式为：\n<div class=\"apiBox\">printf(\"格式控制\",输出表列)</div>\n\n输出表列即需要输出的数据，多个输出的数据使用<span class=\"tips\">,</span>分隔，可以为表达式；格式控制需要使用双引号括起来，可以包括两种信息\n+ 普通字符：printf会原样输出普通字符，包括空格、换行符等\n+ 格式字符：由%和格式字符组成，用于指定输出数据的格式\n\n<div class=\"show\">用于输出整型、浮点型、指数的格式字符:\n1.<span class=\"tips\">%d或%i</span>，用于输出int类型(-32768~32767之间)的十进制整数\n2.<span class=\"tips\">%ld</span>，输出长整型。%hd输出short类型，%I64d输出long long类型\n3.<span class=\"tips\">%md</span>,m用于指定宽度，若数据位数大于m则将原数据正常输出，小于m则左补空格\n<code>eg: a=12345,b=123\nprintf(\"%4d,%4d\",a,b);//输出12345, 123(123前补个空格)</code>\n4.<span class=\"tips\">%o,%x,%X</span>，以八进制、十六进制(字母小写)、十六进制(字母大写)形式输出整型(不输出前导符0和0x)，该输出方式会将符号位也作为八进制和十六进制的数值位输出，因此无法输出负数，输出时支持指定输出位数。同样,八进制和十六进制支持用<span class=\"tips\">l</span>(long)、<span class=\"tips\">h</span>(short)、<span class=\"tips\">m</span>(输出位宽)修饰\n5.<span class=\"tips\">%u</span>，输出无符号(unsigned)整型，%lu输出unsigned long类型\n6.<span class=\"tips\">%c</span>，输出一个字符，支持将0~255内的整数输出为ASCII码对应字符，也支持将这些字符输出为整数\n7.<span class=\"tips\">%s</span>，输出字符串\n<ul style=\"white-space: normal;\">\n<li><span class=\"strong\">%ms</span>，指定输出的字符个数，若字符串串长大于m则原样输出字符串，若小于m则左补空格</li>\n<li><span class=\"strong\">%-ms</span>，同上，但是右补空格</li>\n<li><span class=\"strong\">%m.ns</span>，输出m个字符，但只取字符串左端n个字符，右对齐，左补空格</li>\n<li><span class=\"strong\">%-m.ns</span>，同上，但左对齐，右补空格</li>\n</ul><code>eg：\nprintf(\"%5.2s\",\"china\");//输出   ch(左补3个空格)\nprintf(\"%4.2s\",\"china\");//输出  ch(右补2个空格)\nprintf(\"%-5.2s\",\"china\");//输出ch   (右补3个空格)\n</code>\n8.<span class=\"tips\">%f</span>，输出浮点数(包括单、双精度)，输出全部整数部分，并输出6位小数。单精度浮点数有效位数一般为7位，双精度浮点数有效位数一般为16位，给出小数6位。\n<ul style=\"white-space: normal;\">\n<li><span class=\"strong\">%m.nf</span>，输出m列(小数点算一列)，其中保留有n位小数(四舍五入)，左补空格</li>\n<li><span class=\"strong\">%-m.nf</span>，同上，但左对齐，右补空格</li>\n<li><span class=\"strong\">%.nf</span>，省略m，即输出所有整数部分，保留n位小数</li>\n</ul><code>eg：float a=123.456\nprintf(\"%f\",a);//输出123.456001，输出6位小数，有一定存储误差\nprintf(\"%8.2f\",a);//输出  123.46，左补2个空格，保留2位小数，小数四舍五入\nprintf(\"%-8.2f\",a);//输出123.46  ，右补2个空格\nprintf(\"%.2f\",a);//输出123.46，整数部分全部输出，小数部分保留2位 \nfloat x,y;\nx=111111.111,y=222222.222;\nprintf(\"%f\",x+y);//输出333333.328125，只有前7位有效\n</code>\n9. <span class=\"tips\">%e或%E</span>，以规格化指数形式输出小数，e和E分别表示指数e的大小写形式，可以使用<span class=\"tips\">%m.ne或%m.nE</span>形式指定输出位数和数字部分的小数位数，一般默认数字部分的小数数位为6位，指数部分为5位(如：e+002)\n<code>printf(\"%e\",123.456);\nprintf(\"%e\",123.456);//输出1.234560e+002，默认数字部分6位小数\nprintf(\"%10.2E\",123.456);//输出 1.23E+002，左补1个空格，数字部分的小数保留2位，注意：小数点、e、+等字符均占用一个位置</code>\n10.<span class=\"tips\">%g或%G</span>，根据数值大小自动选择使用%f或%e形式，保证输出宽度最小，不输出无意义的0\n11.<span class=\"tips\">%%</span>，输出%\n12.<span class=\"tips\">%p</span>，以十六进制无符号整数形式输出变量或指针变量的地址\n<code>int num = 10;\nint* p;\np = &num ;\nprintf(\"%p\\n\", &num);//输出结果参考:001DFB0C\nprintf(\"%p\\n\", p);</code>\n理解：\n1. &*p等价于&a\n2. *&a等价于a\n3. (*p)++等价于a++，由于++和*同优先级且右结合，因此不能写为*p++，否则会被解析为*(p++)\n</div>\n\n##### scanf输入函数\n标准输入语句格式为：\n<div class=\"apiBox\">scanf(\"格式控制\",地址表列)</div>\n\n格式控制与printf()函数的格式控制类似，如果格式控制中有格式说明以外的字符，则输入数据时需要在对应位置输入相同的字符；地址表列可以为变量地址、字符串首地址，通常需要用取地址符<span class=\"tips\">&</span>加以引导，多个地址参数使用<span class=\"tips\">,</span>分隔。\n\n<div class=\"table\">\n\n格式输入符|说明\n---------|------\n%d或%i   |输入有符号十进制整数\n%I64d    |输入long long类型整数\n%u       |输入无符号十进制整数\n%o       |输入无符号八进制整数\n%x或%X   |输入无符号十六进制整数\n%c       |输入一个字符，空白字符、回车、制表符也视为有效字符\n%s       |输入字符串，输入空白字符、回车、制表符会被认为输入结束，但开头输入空白字符会被系统跳过\n%f       |输入小数，可以用小数形式或指数形式\n%e,%E,%g,%G|与%f相同，大小写作用相同\n%%       |输入一个%\n</div>\n<div class=\"table\">\n\n格式修饰符|说明\n---------|------\nl        |用于输入长整型数据(%ld,%lo,%lx,%lu)和double型数据(%lf,%le)\nh        |用于输入短整型数据(%hd,%ho,%hx)\n域宽m(正整数)|指定输入数据的宽度(列数)，系统根据此宽度自动截取数据\n\\*        |忽略输入修饰符，表示对应的输入项在读入后不赋给相应变量\n</div>\n\n用scanf()输入数据时，遇到以下情况会被认为数据输入结束：\n+ 遇到空格符、回车符、制表符(Tab)\n+ 达到输入域宽\n+ 遇到非法字符输入\n\n<div class=\"show\">1. 格式控制中有普通字符，则输入数据时也要输入对应字符(包括空格)\nscanf(\"a=%d,b=%d\",&a,&b);//输入形式必须为a=10,b=20\n2. 可以指定输入数据所占的列宽，系统会自动截取\nscanf(\"%3d%3d\",&a,&b);//输入123456a1，则123赋值给a，456赋值给b，多余部分a1抛弃\n3. 可以用*跳过指定列数\nscanf(\"%d%*c%d\",&a,&b);//输入123 456，则123赋值给a，456赋值给b，中间的空格符根据%*c跳过\nscanf(\"%2d%*3d%2d\",&a,&b);//输入1234567，则12赋值给a，345被忽略，67赋值给b\n4. scanf()函数的返回值一般为正确读入数据的个数\nscanf(\"%2d%2d\",&a,&b);//输入1234返回值为2\nscanf(\"%2d%2d\",&a,&b);//输入12a,只给a读入了正确值，返回值为1\nscanf(\"%2d%2d\",&a,&b);//输入a，返回值为0\n</div>\n\n##### putchar()与getchar()\n用于输入或输出一个字符，只能用于处理字符\n+ <span class=\"strong\">getchar() 输入一个字符，无参数</span>\n+ <span class=\"strong\">putchar(参数) 输出一个字符，参数可以为字符变量、整型变量，也可以为一个字符常量或转义字符</span>\n\n<div class=\"show\">char a;\na=getchar();\nputchar(a);\nputchar('a');\nputchar('\\n');\n</div>\n\n#### 自定义函数\n##### 函数定义\n自定义函数的定义语法为：\n<div class=\"apiBox\">返回值类型 函数名(类型 形参1,....){\n        /*函数体*/\n}\n</div>\n\n+ 函数返回值只能有一个，返回值类型可以是除数组外的任何类型\n+ 函数无返回值时，返回值类型需要声明为<span class=\"strong\">void</span>，可以不需要return语句，但通常会以 <span class=\"tips\">return;</span>作为程序结束语句，表示程序正常执行结束且返回值为空，这是一种良好的编程习惯\n+ 如果函数返回值和函数定义时声明的返回值类型不同，则将以函数类型为准，系统自动进行数据转换\n+ 在定义函数时如果不指定返回值类型，系统会隐含指定为int型\n+ 函数名的命名规则与变量相同\n+ 形参(形式参数)必须指定类型，但变量名任意\n+ 形参在函数调用前，不占用存储单元，函数调用时才被分配内存，并在执行完后会被回收\n\n##### 函数调用\n函数调用语法：\n<div class=\"apiBox\">函数名(实参1,....)</div>\n\n+ 实参(实际参数)可以为常量，或者有确定值的变量或表达式\n+ 实参和形参的数据类型应该相同，或者<span class=\"tips\">赋值兼容</span>(参考赋值一节的赋值规则，如字符型和整型相互通用)，但应该尽量避免使用赋值兼容\n\n<div class=\"show\"><code>#include&lt;stdio.h>\n//函数定义时不指定返回值类型，隐含为int类型\n//用Visual Studio编译这段代码时，会有提示warning C4013: “getMax”未定义；假设外部返回 int\ngetMax(int a, int b) {\n\treturn a > b ? a : b;\n}\nint main(void) {\n\tprintf(\"%d\", getMax(10, 20));\n\treturn 0;\n}</code>\n</div>\n\n##### 函数声明\n又称<span class=\"strong\">函数原型</span>(Function Prototype)声明，其作用是将函数名、函数类型、形参类型、个数和顺序通知编译系统，以便调用该函数时系统按此进行对照检查。函数声明语法：\n<div class=\"apiBox\">函数类型 函数名(形参1,....)</div>\n\n+ 如果被调用的函数定义在主调函数之前，可以不加声明，编译器会根据函数定义时首部提供的信息对函数调用作准确性检查\n+ 如果被调用函数类型为整型，也可以不加声明\n+ 函数声明可以在文件开头(所有函数前)，也可以在主调函数中\n+ 对于形参，编译器只检查形参类型和个数，不检查参数名，因此参数名任意，也可以省略\n\n<div class=\"show\"><code>#include&lt;stdio.h>\nint main(void) {\n\tint  getMax(int, int);//原型声明\n\tprintf(\"%d\", getMax(10, 20));\n\treturn 0;\n}\nint getMax(int a, int b) {\n\treturn a > b ? a : b;\n}\n</code></div>\n\n#### 内部函数与外部函数\n<span class=\"strong\">外部函数：</span>定义函数时，可以在函数返回值类型前加上<span class=\"text-blue\">extern</span>将其定义为外部函数，extern可以省略，因此如果函数未特意声明为内部函数，则默认隐含为外部函数，即<span class=\"tips\">C语言中，函数默认为外部函数</span>，外部函数可以被其他文件调用，只需要在要调用此函数的文件中，用extern作函数原型声明即可，其中函数原型声明前的extern也可以省略\n\n<span class=\"strong\">内部函数：</span>又称静态函数，定义函数时在函数首部添加<span class=\"text-blue\">static</span>修饰即可定义内部函数，内部函数作用域仅限于本文件，不能被其他文件调用，不同的文件可以有同名的内部函数，互不干扰\n\n<div class=\"show\">eg:文件file1.c调用文件file2.c中的函数\nfile1.c\n<code>#include&lt;stdio.h&gt;\nint main(void)\n{\n    <span class=\"text-blue\"> extern void getStrings(char str[]);</span>//extern可以省略，写为void getString(char str[])\n    <span class=\"text-red\">static void test();</span>//调用内部函数需要static声明\n    char str[50];\n    getStrings(str);\n    printf(\"%s\\n\", str);\n    test();//调用本文件中的test()函数\n    return 0;\n}\n<span class=\"text-red\">static void test()</span>//内部函数，仅供本文件调用\n{\n    printf(\"file1.c\");\n    return;\n}</code>\nfile2.c\n<code>#include&lt;stdio.h&gt;\n<span class=\"text-blue\">extern void getStrings(char str[])</span>//extern 可以省略\n{\n    gets(str);\n}\n<span class=\"text-red\">static void test()</span>//内部函数，可以与file1.c中的test()函数同名\n{\n    printf(\"file2.c\");\n    return;\n}</code></div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n由此可见，声明函数原型的作用除了在调用时作准确性检查，还可以拓展函数作用域到定义本函数的文件之外，只要在所有调用该函数的文件中作一个函数原型声明即可。如：各种库提供的头文件中，就包含了大量函数及其函数原型声明，我们只需要使用#include命令将其包含到我们的c文件中，就可以不需要了解其函数和函数原型，就直接使用该函数。原型声明时extern可以省略，但我们自己编写头文件中的原型声明时应当保留extern关键字来保证代码清晰性。</div>\n\n### 类型限定符\nC语言中，类型限定符用于指定数据的访问属性。常见的类型限定符包括<span class=\"tips\">const</span>(常量)、<span class=\"tips\">volatile</span>(易变的)、<span class=\"tips\">restrict</span>(限定)和<span class=\"tips\">_Atomic</span>(原子)\n#### const\n##### const修饰变量\nconst用于限定变量的值不能被修改，表明变量中存储的值是一个常量，这类变量本质是变量，但又有常量属性，因此又称为\"常变量\"，const修饰的常变量必须在定义的同时赋值，而后其值就不能再改变，任何赋值行为都将引发错误。定义常变量时，const和变量类型位置可以互换，因此以下两个语句等价：\n<div class=\"show\"><code>const int num=100;\nint const num=100;</code></div>\n\n全局常变量存储于静态存储区的.rodata段，而局部常变量存储于栈内存中。对于局部常变量，由于栈内存本身是可读写的，所以即便编译器会对const修饰的局部变量进行内存保护，防止该变量的值被修改，但我们依然可以用其他方法修改该变量的值：\n<div class=\"show\"><code>const int num=100;\nint *p=&num ;\n*p=0;\nprintf(\"%d\",num);//num值被修改为0\n</code></div>\n这种通过指针来间接操作访问和操作指针所指对象值的方法称为指针解引用(dereference)，C语言标准明确指出，通过指针解引用的方式去修改一个const修饰的变量，其行为是未定义的，因此对于局部常变量，我们不应该通过该方法修改其值。对于全局常变量，数据存储于.rodata段，该段内存只有读权限，通过任何方法修改数据都会抛出写入访问权限冲突异常，在某些嵌入式系统中，全局常变量和代码会被一起存入ROM存储介质中无法修改。\n\n##### const修饰数组\n对于数组，由于数组名本身就代表数组起始地址，是一个地址常量，不能被任何限定符修饰，因此const修饰数组时，将用于修饰数组元素，即const修饰数组时，数组元素为常量无法修改\n<div class=\"show\"><code>const int nums[] = { 10,20,30,40,50 };\n<span class=\"text-red\">nums[2] *= 10;//错误！无法修改</span></code></div>\n\n##### const修饰复合类型\nconst修饰结构体、枚举等复合类型时，表示该类型中的所有成员值不能被修改\n<div class=\"show\"><code>struct test {\n\t\tint a;\n\t\tint b;\n\t};\n\tconst struct test num = { 10,20 };\n或\n    const struct test {\n\t\tint a;\n\t\tint b;\n\t} num = {10,20};\n或\nstruct test {\n\t\tint a;\n\t\tint b;\n\t} const num = {10,20};\n初始化完毕成员变量值不能再被修改\n<span class=\"text-red\">num.a=100;//错误！不能修改成员值</span></code></div>\n\n##### 指针与const类型限定符\n指针常用来在函数间传递数据，方便调用者直接对数据进行操作，但有时我们只希望将数据传到函数内部，而不希望它们在函数内被修改，此时，我们可以使用<span class=\"tips\">const</span>对参数进行限定\n<div class=\"show\">const位于声明语句的不同位置，将表示不同的含义，以int类型为例：\n<code>int a,b;</code>\n1. const放在类型关键字前面\n<span class=\"text-blue\">const int * p=&a;</span>\n按从右到左解析为：p是一个指针变量，可指向一个整型常量，*p是一个常量，而p不是。即*p的值是不可修改的，无法用*p=10;等方式重新赋值，但指针变量p的指向是可以被修改的，即p=&b是允许的\n2. const位于类型关键字后*变量名前\n<span class=\"text-blue\">int const *p=&a;</span>\n按从右到左解析为：p是一个指针常量，可以指向一个常量整数，同样*p是一个常量，而p不是，不能用指针变量p去修改这个\"为常量的整数\"，与第一种情况作用相同\n3. const位于*后，变量名前\n<span class=\"text-blue\">int * const p=&a;</span>\n按从右到左解析为：p是一个指针常量，可以指向一个整型数据，它表明p是一个常量，而*p不是。由于p是常量指针，因此不能修改p的指向，p=&b操作是非法的，但*p=20是合法的\n4. 两个const修饰，一个位于类型关键字前，一个位于*后\n<span class=\"text-blue\">const int * const p=&a;</span>\n按从右到左解析为：p是一个指针常量，可指向一个整型常量，它表明p和*p都是常量，是只读的，*p=20和p=&b操作都是非法的\n上述四种用法中，第一种用法较为常用，C语言很多库函数都使用该方法，只允许函数访问该指针指向的内容，不允许修改其内容，如：\n<code>int puts(const char * str);\nint printf(const char * format , ...);</code></div>\n\n对于被const限制的指针变量，不能将普通指针变量赋值给被限制的指针变量，但反过来可以，如：<span class=\"tips\">const char *</span>和<span class=\"tips\">char *</span>是不同的类型，const char *指向的数据只有读取权限，而char *指向的数据有读写权限，因此不能将const char *赋值给char *，但可以将char *类型的数据赋值给const char *类型的变量\n<div class=\"show\">C语言函数库中很多函数参数都被const限制了，但我们仍然可以将非const类型的数据传递给const类型的形参，如对于函数原型\nint puts(const char * str);\n可以直接传递非const类型的数据\nchar * str=\"Hello\";\nputs(str);\n</div>\n\n#### volatile\nvolatile用于声明变量的值是易变的，每次用到该变量的值时都需要去内存中重新读取这个变量的值，而不是读取其在寄存器中的备份。在多线程环境下，volatile 表示变量可能会被多个同时执行的线程修改，存取时无需额外的内存保护，并且防止优化编译器把变量从内存装入寄存器中，因为如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，造成程序的错误执行，volatile的声明方式为：\n<div class=\"show\"><code>volatile int counter;</code></div>\n\n#### restrict\nrestrict是C99标准新增的限定符，该限定符只能用于指针变量，其作用是程序员通过该限定符告知编译器，restrict修饰的指针独占其所指向的内存，所有对该内存的操作都将基于该指针，而不再会有其他任何变量或指针操作该内存，以便让编译器进行一些针对性的优化。这种优化是针对特殊使用场景的，因此可能出现没有任何优化的情况，并且由于restrict指针独占是由程序员来判断并加以限定的，可能会出现误判的情况，因此，restrict一般用于非常需要性能优化，并且已经确认两个指针不会指向同一内存的场景，其定义语法为：\n<div class=\"show\"><code>int * restrict a;</code>\neg:业务上明确得知，某个malloc开辟的空间，只会通过mySpace指针变量进行操作，则可以使用restrict限定符告知编译器，由其进行优化\n<code>int * restrict mySpace=(int *)malloc(10*sizeof(int));</code></div>\n\n#### _Atomic\n_Atomic是C11标准引入的限定符，用于指定原子类型，提供原子性操作。原子操作是指对原子对象的操作是不可被打断的，该操作一旦执行，不会被其他线程或者事件中断，直到操作执行完毕。默认的声明方式为：\n<div class=\"show\"><code>_Atomic int x=0;</code></div>\n\n但在实际使用时，应该使用<span class=\"text-blue\">&lt;stdatomic.h&gt;</span>头文件中已经定义好的原子类型，该头文件还定义了相关的原子操作函数\n<div class=\"show\">一些stdatomic.h头文件定义的原子类型和原子操作举例\n<code>typedef _Atomic int atomic_int;\ntypedef _Atomic char atomic_char;\n...\natomic_init(volatile A* obj, C desired )初始化原子类型变量\n....</code>\neg:定义一个原子类型变量并初始化\n<code>#include &lt;stdio.h>\n#include &lt;stdatomic.h>\nint main(void)\n{\n    atomic_int a;\n    atomic_init(&a,10);\n    return 0;\n}</code></div>\n\n### 动态内存分配\n动态内存分配函数在堆上分配内存，使用前需要包含<span class=\"tips\">&lt;stdlib.h&gt;</span>头文件\n\n#### 内存空间申请与释放\n+ <span class=\"strong\">void *malloc(unsigned int size);</span>\n\n分配长为size字节的内存空间，返回该内存首地址，若无足够内存单元，则返回空指针NULL\n<div class=\"show\"><code>int *p=(int *)malloc(4*sizeof(int))</code></div>\n\n+ <span class=\"strong\">void *calloc(unsigned int num,unsigned int size);</span>\n\n用于给同一类型的数据分配连续的内存空间并赋值为0(数值型)或空(字符型)。它相对于声明了一个一维数组，并且会初始化该数组值为0或空，参数num为所需申请的内存空间数量，相对于数组长度，参数size为每个内存空间的字节数，相对于数组基类型的字节长度。若申请成功，返回该内存空间的首地址，否则返回空指针NULL\n\n<div class=\"show\"><code>int * p=(int *)calloc(10,sizeof(int));\n相对于\nint * p=(int *)malloc(10*sizeof(int));\n但calloc()会将分配的内存自动初始化为0或空，更为安全\n</code></div>\n\n+ <span class=\"strong\">void *realloc(void *p,unsigned int size);</span>\n\n用于改变原来分配的内存，将p所指向的存储空间大小改为size个字节，返回值是新分配的内存空间首地址，与原来分配的首地址不一定相同\n\n\n+  <span class=\"strong\">void free(void *p);</span>\n\n用于释放所申请的内存空间，即p所指向的空间，其中p只能是由malloc()和calloc()申请的内存地址\n\n### 文件操作\n#### 二进制文件与文本文件\nC语言文件有两种类型：<span class=\"text-blue\">文本文件</span>(也称ASCII码文件)和<span class=\"text-blue\">二进制文件</span>。二者的区别在于存储数值型数据的方式不同。二进制文件中，数值型数据是将整个数值转码为二进制形式存储；而在文本文件中，数值型数据的每一位数字作为一个字符以其ASCII码形式存储，每个数字都单独占用一个字节的存储空间。如：对于short int n=123，二进制文件中，变量n为short类型仅占用2个字节存储空间，而在文本文件中占用3个字节存储空间。\n\n二进制文件和文本文件各有优缺点。文本文件可以很方便被其他程序读取，包括文本编辑器、Office办公软件等，且输出内容与字符一一对应，一个字节表示一个字符，便于对字符逐个处理，便于输出字符，但一般占用的存储空间较大，且ASCII码和字符转换需要花费一定时间。二进制文件可以节省空间和转换时间，但不方便其他程序读取，不能直接输出其字符形式。\n\n无论文件内容是什么形式，C语言一律将数据看成由字节构成的序列，即<span class=\"text-blue\">字节流</span>，对文件的存取也是以字节为单位进行的，输入、输出的数据仅受程序控制而不受物理符号(如回车换行符)控制，因此，C语言文件又称为流式文件。\n\nC语言文件系统分为<span class=\"text-blue\">缓冲型</span>和<span class=\"text-blue\">非缓冲型</span>，缓冲型文件系统是指系统自动为每一个正在使用的文件在内存中开辟一个输入/输出文件缓冲区，作为程序和文件之间数据交换的缓冲区域。在读文件时，数据先从磁盘送到缓冲区，再传给C语言程序；在写文件时，数据从C语言程序送到缓冲区，装满缓冲区后再输出到磁盘。缓冲文件系统利用<span class=\"text-red\">文件指针</span>标识文件，不同版本的C语言缓冲区大小不一样，一般为512字节。而非缓冲文件系统不会自动数值文件缓冲区，缓冲区必须由程序员自己设定，它使用称为文件号的整数来标识文件。\n\n在UNIX系统中，缓冲文件系统用来处理文本文件，用非缓冲文件系统来处理二进制文件。用缓冲文件系统进行输入输出的操作又称为高级文件操作，用非缓冲文件系统来处理输入输出的操作又称为低级输入输出操作。ANSI C标准规定只采用缓冲文件系统，即既用缓冲文件系统处理文本文件，也用它处理二进制文件，因此下文主要为高级文件操作函数。\n\n#### 文件指针\n缓冲文件系统中，系统为每个正在使用的文件在内存中开辟了一个缓冲区，用来存放文件的有关信息(如：文件名、文件句柄、文件状态、文件路径等)，这些信息保存在一个结构体变量中，该结构体类型由系统定义，名为<span class=\"text-red\">FILE</span>，stdio.h文件中有该文件类型声明：\n<div class=\"show\"><code>typedef struct\n{   short level;    //缓冲区\"满\"或\"空\"的程度\n    unsigned flags;//文件状态标志\n    char fd;      //文件描述符\n    unsigned char hold;//如果无缓冲区不读取字符\n    short bsize;//缓冲区大小\n    unsigned char *buffer;//数据缓冲区位置\n    unsigned ar *curp;//指针当前指向\n    unsigned istemp;//临时文件指示器\n    short token;//用于有效性检查\n}FILE;\n</code></div>\n\n由此，我们可以定义一个文件类型的指针变量：<span class=\"text-red\">FILE *fp</span>，然后将该指针指向一个文件的结构体变量，从而通过该指针访问该结构体变量中的文件信息，并通过这些信息访问该文件。\n\n#### 文件的打开与关闭\n##### fopen()函数\n函数fopen()用于打开文件，其函数原型如下：\n<div class=\"apiBox\">FILE * fopen(const char * filename,const char * mode)</div>\n\n该函数返回一个文件类型的指针，如果文件打开失败，则返回一个空指针NULL(NULL在stdio.h文件中被定义为0)。fopen()有两个形参，第一个形参filename表示文件名，可以包含<span class=\"strong\">文件路径和文件名</span>两部分，第二个形参mode表示文件的打开方式，取值如下所示：\n\n<div class=\"table\">\n\n字符|含义\n----|------ \nr   |以<span class=\"text-yellow\">只读方式</span>打开<span class=\"text-blue\">文本文件</span>，只能读出而不能写入数据，若文件不存在，则报错\nw   |以<span class=\"text-yellow\">只写方式</span>(新建形式)，创建并打开<span class=\"text-blue\">文本文件</span>，无论文件是否存在，都会创建一个新的文本文件，只能写入数据，已经存在的文件将被覆盖\na   |以<span class=\"text-yellow\">只写方式</span>(追加形式)，打开<span class=\"text-blue\">文本文件</span>，位置指针移到文件末尾，向文件尾部添加新数据，若文件不存在，则会新建一个文件\nb   |与上面的字符串组合，表示打开二进制文件\nrb  |以<span class=\"text-yellow\">只读方式</span>打开<span class=\"text-red\">二进制文件</span>\nwb  |以<span class=\"text-yellow\">只写方式</span>打开<span class=\"text-red\">二进制文件</span>\nab  |以<span class=\"text-yellow\">只写方式</span>向<span class=\"text-red\">二进制文件</span>末尾添加数据\n\\+   |与上面的字符串组合，表示以读写方式打开文本文件，既可以向文件中写入数据，也可以从文件中读取数据\nr+  |以<span class=\"text-green\">可读可写</span>的方式打开<span class=\"text-blue\">文本文件</span>\nw+  |以<span class=\"text-green\">可读可写</span>方式创建一个新的<span class=\"text-blue\">文本文件</span>\na+  |以<span class=\"text-green\">可读可写</span>方式向<span class=\"text-blue\">文本文件</span>末尾追加数据\nrb+  |以<span class=\"text-green\">可读可写</span>的方式打开<span class=\"text-red\">二进制文件</span>\nwb+  |以<span class=\"text-green\">可读可写</span>方式创建一个新的<span class=\"text-red\">二进制文件</span>\nab+  |以<span class=\"text-green\">可读可写</span>方式向<span class=\"text-red\">二进制文件</span>末尾追加数据\n</div>\n\n注意：\n+ 有的C语言编译系统可能不完全提供上述功能，如：有的C语言编译器不支持r+、w+、a+\n+ 输入文本文件时，内容中的回车换行符会被转换为一个换行符，在输出时，则会将换行符转换为回车和换行两个字符。而在输入输出二进制文件时，不会进行这种转换，文件中的数据与内存中的数据完全一致，一一对应\n\n##### fclose()函数\n函数fclose()用来关闭一个由函数fopen()打开的文件，其函数原型如下：\n<div class=\"apiBox\">int fclose(FILE *fp);</div>\n\n函数返回一个整型值，当文件成功关闭时，返回0值，否则返回一个非0值(一般为EOF -1)，可用于判断文件是否关闭成功。当使用fclose()关闭文件后，指针fp将不再指向该文件。\n\n由于操作系统对于同时打开的文件数目是有限制的，所以文件使用结束后必须关闭文件。此外，不建议使用读写方式打开文件，因为读写共用一个缓冲区，每次读写都会改变文件位置指针，很容易写乱，破坏文件内容，并且需要调用文件定位函数才能在读写之间切换。\n\n<div class=\"show\"><code>FILE * fp;\nfp=fopen(\"D:\\\\demo.text\",\"a+\");\nfclose(fp);</code></div>\n\n#### 文件的读写\n##### 按字符读写\n+ <span class=\"strong\">int fgetc(FILE *fp)</span> 从fp所指向文件读取一个字符，并使位置指针指向下一个字符。如果读取成功，则返回该字符，若读取到文件末尾，则返回EOF(stdio定义为-1)\n+ <span class=\"strong\">int fputc(int c,FILE *fp)</span> 将字符c(尽管c定义为int型，但只写入低字节)写到文件指针fp所指向的文件中。若写入错误，则返回EOF，否则返回字符c\n\n<div class=\"show\">在读入文本文件时，可通过fgetc()函数的返回值来判断是否读取到了文件末尾(文件是否读取完毕)，当读入的字符值等于-1(即EOF)时，说明文件已经读取完毕。但在读入二进制文件时，读入的数据可能刚好为-1(EOF)，此时就需要使用feof()函数判断当前文件是否读取完毕。如果文件结束，则feof(fp)的值为1(真)，否则为0(假)\neg:从键盘输入字符，并将这些字符存储到磁盘文件中，直到输入\"#\"为止\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void){\n    FILE *fp;\n    char ch,filename[10];\n    scanf(\"%s\",filename);//输入文件名\n    if((fp=fopen(filename,\"w\"))==NULL){\n        printf(\"文件打开失败\\n\");\n        exit(0);\n    }\n    ch=getchar();//接收执行scanf语句时输入的回车符\n    ch=getchar();\n    while(ch!='#')\n    {\n        <span class=\"text-blue\">fputc(ch,fp);</span>\n        ch=getchar();\n    }\n    fclose(fp);\n        return 0;\n}</code>\neg:从当前路径文件夹下读取名为\"myTest.txt\"的文件，并将内容输出到控制台\n<code>int main(void) {\n\tFILE* fp;\n\tchar ch;\n\tif ((fp = fopen(\"myTest.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败！\\n\");\n\t\texit(0);\n\t}\n\twhile (<span class=\"text-red\">!feof(fp)</span>) {\n\t\tch = fgetc(fp);\n\t\tputchar(ch);\n\t}\n\treturn 0;\n}</code></div>\n\n##### 按字符串读写\n+ <span class=\"strong\">char * fgets(char *s,int n,FILE *fp)</span> 从fp所指向文件中读取最多含n-1个字符的字符串，并在字符串末尾添加'\\0'，然后存入s。当读取到回车换行符、到达文件末尾或者读满n-1个字符时，函数返回该字符串的首地址，即指针s的值；读取失败时返回空指针NULL\n+ <span class=\"strong\">int fputs(const char *s,FILE * fp)</span> 将字符串s写入文件fp，若写入错误，则返回EOF(-1)，否则返回一个非负数\n\n<div class=\"show\">eg:从键盘输入一个字符串，追加到文件末尾\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void){\n    FILE * fp;\n    char str[20];\n    if((fp=fopen(\"demo.txt\",\"a\"))==NULL){\n        printf(\"Failure to open file!\\n\");\n        exit(0);\n    }\n    gets(str);\n    fputs(str,fp);\n    fclose(fp);\n    if((fp=fopen(\"demo.txt\",\"r\"))==NULL){\n        printf(\"Failure to open file!\\n\");\n        exit(0);\n    }\n    fgets(str,20,fp);\n    puts(str);\n    fclose(fp);\n    return 0;\n}\n</code></div>\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n这两个函数与puts()和gets()类似，区别在于，gets()函数从输入缓冲区读取字符串时，会将回车符也从缓冲区读走，但不作为字符串的一部分，而fgets()函数读到换行符时会将换行符作为字符串的一部分读到字符串中来。输出时，puts()函数在向终端输出字符串时，会在字符串输出结束后，自动输出一个换行符，而fputs()函数不会在字符串末尾加上换行符。</div>\n\n##### 按格式读写文件\n+ <span class=\"strong\">int fscanf(FILE *fp,格式字符串,输入表列地址)</span>从指定文件按格式读取数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为输入变量的地址表列\n+ <span class=\"strong\">int fprintf(FILE *fp,格式字符串,输出表列)</span>按指定格式向文件写入数据，第1个参数为文件指针，第2个参数为格式控制字符串，第3个参数为要写入的变量\n\n用函数fscanf()和fprintf()进行文件的格式化读写，读写方便，容易理解，但输入时要将ASCII字符转换为二进制数，输出时要将二进制数转换为ASCII字符，耗时较多。因此，内存和磁盘进行频繁数据交换时，应当尽量避免使用这两个函数，而用fread()和fwrite()函数\n<div class=\"show\"><code>int i=10;\nfloat j=4.5;\nfprintf(fp,\"%d,%6.2f\",i,j);//保存为10,  4.50\nfscanf(fp,\"%d,%f\",&i,&j);//假设文件内容为10,4.5，则i赋值为10，j赋值为4.5</code></div>\n\n##### 按数据块读写文件\n+ <span class=\"strong\">unsigned int fread(void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 从fp所指的文件读取数据块并存储到buffer所指向的内存。buffer是待存入数据块的起始地址，可以是数组起始地址、结构体变量起始地址等，size是每个数据块的大小，count是最多允许读取的数据块个数，函数返回的是实际读取到的数据块个数\n+ <span class=\"strong\">unsigned int fwrite(const void *buffer,unsigned int size,unsigned int count,FILE *fp);</span> 将buffer所指内存中的数据块写入fp所指的文件。同样，buffer是待读出数据块的起始地址，size是每个数据块的大小，count是最多允许写入的数据块个数，函数返回的是实际写入的数据块个数\n块数据读写允许用户以数组、结构体等数据类型整块读写，不再局限于一次只读写一个字符或字符串，可以指定想要读写的内存块大小，最小为1字节，最大可以为整个文件\n\n<div class=\"show\">eg:整块读写数组内容\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void) {\n\tint nums[] = { 11,22,33,44,55,66,77,88,99 };\n\tint numsRead[9];\n\tFILE* fp;\n\tif ((fp = fopen(\"data.txt\", \"w\")) == NULL) {\n\t\tprintf(\"文件打开失败!\");\n\t\texit(0);\n\t}\n    <span class=\"text-blue\">fwrite(nums, 4, sizeof(nums)/4, fp);</span>//将数组nums到文件fp中，数组为int类型，数据块为4Bytes，需要写入9个数据块\n\tfclose(fp);\n\tif ((fp = fopen(\"data.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败!\");\n\t\texit(0);\n\t}\n    <span class=\"text-red\">fread(numsRead, 4, 9, fp);</span>//从fp文件中读取9个4Bytes的数据块，并存储到numsRead数组中\n\tfor (int i = 0; i < 9; i++) {\n\t\tprintf(\"%4d\", numsRead[i]);\n\t}\n    fclose(fp);\n\treturn 0;\n}</code></div>\n\neg:按块文件读写结构体变量，输入每个学生的信息并保存到studentData.txt文件中，并添加从该文件中读出学生信息并打印到控制台的功能\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define MAXSIZE 10\ntypedef struct student {\n\tchar name[10];\n\tlong studentID;\n\tint age;\n\tint classID;\n}STUDENT;\nint main(void) {\n\tvoid writeToFile(STUDENT[], int);\n\tint readFromFile(STUDENT[]);\n\tvoid printToScreen(STUDENT[], int);\n\tSTUDENT stu[MAXSIZE];\n\tint studentNum;\n\tprintf(\"请输入学生数量：\\n\");\n\tscanf(\"%d\", &studentNum);\n\tprintf(\"请输入学生信息：\\n\");\n\tfor (int i = 0; i &lt;studentNum; i++) {\n\t\tscanf(\"%s %ld %d %d\", stu[i].name, &stu[i].studentID, &stu[i].age, &stu[i].classID);\n\t}\n\twriteToFile(stu, studentNum);\n\tstudentNum = readFromFile(stu);\n\tprintToScreen(stu, studentNum);\n\treturn 0;\n}\nvoid writeToFile(STUDENT stu[], int n) {\n\tFILE* fp;\n\tif ((fp = fopen(\"studentData.txt\", \"w\")) == NULL) {\n\t\tprintf(\"文件打开失败！\");\n\t\texit(0);\n\t}\n    fwrite(stu, sizeof(STUDENT), n, fp);\n\tfclose(fp);\n}\nint readFromFile(STUDENT stu[]) {\n\tFILE* fp;\n\tint i;\n\tif ((fp = fopen(\"studentData.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败!\\n\");\n\t\texit(0);\n\t}\n\tfor (i = 0; !feof(fp); i++) {\n\t\tfread(&stu[i], sizeof(STUDENT), 1, fp);\n\t}\n\tfclose(fp);\n\treturn i - 1;\n}\nvoid printToScreen(STUDENT stu[], int num) {\n\tprintf(\"----------------------\\n\");\n\tfor (int i = 0; i &lt; num; i++) {\n\t\tprintf(\"%6s%10ld%4d%4d\\n\", stu[i].name, stu[i].studentID, stu[i].age, stu[i].classID);\n\t}\n}</code></pre>\n\n##### 数字读写putw()和getw()\nputw()和getw()不是ANSI C标准定义的函数，但很多编译器提供这两个函数，有的编译器将其命名为_putw()和_getw()函数(Visual Studio 2019(编译器版本主要支持ANSI C89标准，但其中包含几个Microsoft扩展支持ISO C99的一部分函数)只能用这两个函数名)，因此这两个函数的在不同编译器中函数名可能不同，函数名中的<span class=\"tips\">w</span>是指<span class=\"tips\">word(字)</span>\n+ <span class=\"strong\"> int getw(FILE *fp)</span> 从fp读取一个整数，如果读取成功，返回该整数，读取失败或文件结束，返回-1\n+ <span class=\"strong\">int putw(int w, FILE *fp)</span> 将一个字符或字输出到文件fp，返回值为输出的整数\n\n<div class=\"show\">eg:存储0-9整数到文件test.txt中，读出后输出到控制台\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(void) {\n\tFILE* fp;\n\tint getNum;\n\tif ((fp = fopen(\"test.txt\", \"w\")) == NULL) {\n\t\tprintf(\"文件打开失败!\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < 10; i++) {\n        <span class=\"text-blue\">_putw(i, fp);</span>\n\t}\n\tfclose(fp);\n\tif ((fp = fopen(\"test.txt\", \"r\")) == NULL) {\n\t\tprintf(\"文件打开失败!\\n\");\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < 10; i++) {\n        <span class=\"text-blue\">getNum = _getw(fp);</span>\n\t\tprintf(\"%4d\", getNum);\n\t}\n\tfclose(fp);\n\treturn 0;\n}</code></div>\n\n#### 文件定位\n之前的示例执行的都是顺序文件处理，数据项是依次进行读写的，如果需要读取第5个数据项，按顺序文件处理方法必须先读取前4个数据项。如果要读写指定位置的数据项，则需要使用文件的随机访问，允许在文件中随机定位，并在文件任意位置读写数据。\n\n为了实现文件的定位，每一个打开的文件中，都有一个<span class=\"text-blue\">文件位置指针</span>，用来指向当前文件读写位置。当对文件进行顺序读写时，每读完一个字节，位置指针就会自动指向下一个字节。当需要随机读写时，需要我们人为指定位置指针的指向，C语言提供了几个关于位置指针的函数\n\n##### 重置位置指针rewind()\n<span class=\"strong\">void rewind(FILE *fp)</span> 使fp文件的位置指针指向文件首字节，即重置位置指针到文件开头\n\n<div class=\"show\">eg:打印file1文件内容到控制台，并将其复制到file2，两个任务分开执行。第一次打印完file1文件，文件位置指针位于文件末尾，使用rewind()函数将file1文件位置指针重置到文件开头，执行其他任务\n<code>FILE *fp1=fopen(\"file1.txt\",\"r\");\nFILE *fp2=fopen(\"file2.txt\",\"r\");//应当有文件打开失败的错误处理，这里省略\nwhile(!feof(fp1)){\n    putchar(getc(fp1));\n}\n<span class=\"text-blue\">rewind(fp1);</span>\nwhile(!feof(fp1)){\n   putc(getc(fp1),fp2);\n}\nfclose(fp1);\nfclose(fp2);\n</code></div>\n\n##### 指定指针位置fseek()\n<span class=\"strong\">int fseek(FILE *fp,long offset,int fromwhere);</span>将fp的位置指针从fromwhere移动offset个字节\n\n\noffset是一个偏移量，告诉文件指针跳过多少个字节，ANSI C要求offset是<span class=\"tips\">long</span>类型的(其常量值后面要加L)，这样当文件长度大于64kb时不至于出问题。当offset为正时，位置指针向后移动，为负时向前移动。由于需要指定具体字节数，因此该参数往往需要<span class=\"tips\">sizeof(数据类型)</span>函数来获取相应类型的字节数。\n\nfromwhere用于确定偏移量计算的起始位置，可以取以下三个值：\n\n<div class=\"table\">\n\n起始点      |别名     |值\n-----------|---------|----\n文件开始    |SEEK_SET |0\n文件当前位置|SEEK_CUR |1\n文件末尾    |SEEK_END |2\n</div>\n\n<div class=\"show\">eg:读取studentData.txt中的第k条数据并打印到控制台，k由用户输入\n<code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define MAXSIZE 10\ntypedef struct student {\n\tchar name[10];\n\tlong studentID;\n\tint age;\n\tint classID;\n}STUDENT;\nint main(void) {\n\tvoid searchData(char fileName[],long k);\n\tlong k;\n    printf(\"Input the searching record number:\");\n    scanf(\"%ld\",&k);\n    searchData(\"studentData.txt\",k);\n\treturn 0;\n}\nvoid searchData(char fileName[],long k)\n{\n    FILE* fp;\n    STUDENT stu;\n    if ((fp = fopen(filename, \"r\")) == NULL) {\n        printf(\"文件打开失败!\\n\");\n        exit(0);\n    }\n    <span class=\"text-blue\">fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);</span>\n    <span class=\"text-red\">fread(&stu, sizeof(STUDENT), 1, fp);</span>\n    printf(\"%8s%8ld%4d%4d\", stu.name, stu.studentID, stu.age, stu.classID);\n    fclose(fp);\n}\n</code></div>\n\n##### 返回指针位置ftell()\n<span class=\"strong\">long ftell(FILE *fp)</span>返回当前位置指针相对于文件开头的位移量(字节数)，若函数调用失败则返回-1L\n<div class=\"show\">eg:ftell()返回的文件位置是用字节偏移量表示的，如果要获取记录号(第几条数据)则还要除以sizeof(STUDENT)\n<code>fseek(fp, (k - 1) * sizeof(STUDENT), SEEK_SET);//执行完指针跳转，不确定指针指向哪里，可以用ftell()返回指针位置\nlong num=ftell(fp);//指针相对于文件头的偏移字节数\nint k=num/sizeof(STUDENT);//指针指向的数据序号\n</code></div>\n\n#### 文件状态\n+ <span class=\"strong\">int feof(FILE *fp)</span>检查fp所指向文件是否已经读到文件末尾。当文件位置指针指向文件结束符时，返回非0值，否则返回0值\n+ <span class=\"strong\">int ferror(FILE *fp)</span>检查对文件的输入输出操作是否出错，如果出错返回非零值，如果未出错，返回0。对同一个文件，每调用一次输入输出函数，ferror()函数的值都会更新\n+ <span class=\"strong\">void clearerr(FILE *fp)</span>将fp所指向文件的文件错误标志和文件结束标志置为0\n+ <span class=\"strong\">void perror(const char *str)</span>向标准错误输出字符串str，并随后附上冒号以及全局变量errno代表的错误消息的文字说明，无返回值\n+ <span class=\"strong\">int rename(const char *old,const char *new)</span>将文件名old所指的文件改为new，成功返回0，出错返回1\n#### 输入输出重定向\n在从终端设备输入输出时，系统会自动打开三个标准文件：标准输入、标准输出、标准出错输出。系统为其定义了三个文件指针：stdin、stdout和stderr，分别指向终端输入、终端输出和标准出错输出(也从终端输出)。在默认情况下，标准输入设备是键盘，标准输出设备是屏幕，我们从终端输入、输出时不需要手动打开终端文件，系统会自动打开，同样，如果程序指定从stdin所指的文件输入数据，其实就是指从终端键盘输入数据。\n\n文件读写操作中的很多函数是标准输入输出函数的文件操作版，如：fprintf()是printf()的文件操作版，二者差别在于fprintf()多了一个文件指针类型的参数(FILE * fp)，如果给该参数传递的值是stdout，那么fprintf()就和printf()完全一样了，同理，以下语句是两两等价的：\n<div class=\"show\"><code>putchar(c)等价于fputc(c,stdout)\nputs(str)等价于fputs(str,stdout)\ngetchar()等价于fgetc(stdin)\n以下函数，fgets()比gets()还多了一个参数size\nchar *fgets(char *str,int size,FILE *fp);\nchar *gets(char *str);\n参数size用于限制输入字符串的长度，说明fgets()函数输入缓冲区大小，使读入的字符数不能超过限定的缓冲区大小，从而达到防止缓冲区溢出攻击的目的，因此，以下语句，后者安全性更高\ngets(str);\nfgets(str,sizeof(str),stdin);\n</code></div>\n\n虽然系统隐含的标准I/O文件是指终端文件，但标准输入和标准输出是可以重定向的，操作系统可以把它们重定向到其他文件或具有文件属性的设备，只有标准错误输出不能进行一般的输出重定向，如：把标准输出重定向到打印机，把标准输入重定向到U盘文件等。使用<span class=\"strong\">\"&lt;\"</span>表示输入重定向，用<span class=\"strong\">\"&gt;\"</span>表示输出重定向。如：file.exe是可执行文件，执行该程序时需要从键盘输入数据，如果现在要求从文件file.in读取所需要输入的数据，那么只需在DOS命令提示符下，输入以下命令即可：\n<div class=\"shell\">c:\\file.exe &lt; file.in</div>\n这样file.exe的标准输入就被\"&lt;\"重定向到了file.in文件，此时程序只会从文件file.in读取数据，而不再理会任何键盘输入。同样，以下命令可以将标准输出重定向到文件file.out：\n<div class=\"shell\">c:\\file.exe &gt; file.out</div>\n\n### C语言中的随机数\nC语言标准库在&lt;stdlib.h&gt;头文件中提供了用于生成随机数的函数<span class=\"text-red\">rand()</span>，其函数原型为：<span class=\"strong\">int rand(void)</span>，该函数可以生成<span class=\"text-blue\">0~32767</span>范围内的随机数，但该函数生成的数是伪随机数，每次调用该函数都会重复生成以下值：\n<div class=\"show\"><code>    printf(\"%d\\n\", rand());//41\n\tprintf(\"%d\\n\", rand());//18467\n\tprintf(\"%d\\n\", rand());//6334\n\tprintf(\"%d\\n\", rand());//26500\n\tprintf(\"%d\\n\", rand());//19169\n    ......</code></div>\n\n这是由于，各编程语言获取随机数实际上都是基于递推公式计算出一组数值，当序列足够长，这组数值可以近似满足均匀分布。在计算随机数时，这些随机函数都是基于一种名为\"种子\"的基准值进行运算，当种子值不变，生成的随机数也将固定。C语言中,rand()函数的种子值默认为1，可以通过<span class=\"text-red\">srand()</span>函数来修改该种子值，其函数原型为:\n<span class=\"strong\">void srand(unsigned int seed);</span>\n<div class=\"show\"><code>    srand(6);\n    printf(\"%d\\n\", rand());//58\n\tprintf(\"%d\\n\", rand());//6673\n\tprintf(\"%d\\n\", rand());//30119\n\tprintf(\"%d\\n\", rand());//15745\n\tprintf(\"%d\\n\", rand());//5206</code></div>\n\n如果将种子值设为当前时间，由于时间是每时每刻都不一样的，此时就可以真正生成一个随机数，C语言提供了获取当前时间戳的函数：\n<span class=\"strong\">time_t time(time_t *timer);</span>\n\n该函数会当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，其返回值类型为time_t(但本质上为64位整型)，在用作生成随机数时，传入的参数一般为空指针NULL(或0)\n\n<div class=\"show\"><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;time.h&gt;\nint main()\n{   <span class=\"text-red\">srand((unsigned int)time(NULL));</span>\n    printf(\"%d\\n\", rand());\n\tprintf(\"%d\\n\", rand());\n    return 0;\n}\n</code></div>\n\n如果需要指定生成随机数的范围，则还需要一些额外的运算\n<div class=\"show\">以下操作建立在设置了随机数种子的前提下\n<code>srand((unsigned int)time(NULL));</code>\n1. 通过取模运算来限制随机数范围\n<code>int randomNum = rand() % 100;//生成0-99之间的随机整数\nint randomNum = rand()%100+1;//生成1-100之间的随机整数\n该语句解析为：\nint randomNum = rand()%(101-1)+1;//生成1-101(不包括101)之间的整数</code>\n生成min-max(不包括max)之间的随机整数\n<span class=\"text-blue\">rand()%(max-min)+min</span>\n2. 将随机整数除以RAND_MAX宏常量来获取随机小数：stdlib.h定义了rand()函数能返回伪随机数的最大值RAND_MAX，其值一般为32767，我们将获得的随机整数除以该常量值，就获得了一个0.0-1.0之间的随机小数\n<code>double random_double = (double)rand()/(double)RAND_MAX;</code>\n类似地可以限定该随机小数的范围为a-b：\n<span class=\"text-blue\">(double)rand() / RAND_MAX * (b - a) + a;</span>\n</div>\n\n### 常用函数和头文件\n列出了一些常用的函数及其头文件，这些头文件中还有很多其他函数，可以参考文档：[https://cplusplus.com/reference/](https://cplusplus.com/reference/)，里面罗列了很多C语言和C++的头文件和函数，二者文件名和函数形参可能有所不同但能类似套用\n\n#### 字符与字符串\n以下是对部分字符的定义\n<div class=\"table\">\n\n字符类|说明\n-----|-----\n标点符号字符|!@\"#$%^&'(),*+-./:&lt;=&gt;;[]\\\\_{|}~`\n图形字符|包括字母、数字、标点符号\n空白字符|空格符、水平制表符\\t、换行符\\n、垂直制表符\\v、换页符\\f、回车符\\r\n控制字符|在 ASCII 编码中，这些字符的八进制代码是从 000 到 037，以及 177（DEL）\n可打印字符|包括字母、数字、标点符号和空格字符\n</div>\n\n以下函数用于测试和映射字符，需要包含字符串<span class=\"text-red\">&lt;ctype.h&gt;</span>，除了最后的大小写转换函数，其余函数如果参数 c 满足描述的条件，则这些函数返回非零值(true)，一般返回值为1，否则返回零(false)\n\n<div class=\"table\">\n\n函数名  |函数原型            |说明\n------  |-------------------|-------\nisalnum |int isalnum(int c)|检查字符c是否是字母和数字\nisalpha |int isalpha(int c)|检查字符c是否是字母\niscntrl |int iscntrl(int c)|检查字符c是否是控制字符\nisprint |int isprint(int c)|检查字符c是否是可打印的\nisdigit |int isdigit(int c)|检查字符c是否是十进制数字\nisxdigit|int isxdigit(int c)|检查字符c是否是十六进制数字\nisgraph |int isgraph(int c)|检查字符c是否有图形表示法，有图形表示法的字符是指除了空白字符以外的所有可打印的字符\nislower |int islower(int c)|检查字符c是否是小写字母\nisupper |int isupper(int c)|检查字符c是否是大写字母\nispunct |int ispunct(int c)|检查字符c是否是标点符号字符\nisspace |int isspace(int c)|检查字符c是否是空白字符\ntolower |int tolower(int c)|把给定的字符c转换为小写字母，如果已经是小写字母则c不变\ntoupper |int toupper(int c)|把给定的字符c转换为大写字母，如果已经是大写字母则c不变\n</div>\n\n以下函数用于处理字符串，需要包含头文件<span class=\"text-red\">&lt;string.h&gt;</span>\n<div class=\"table\">\n\n函数名 |函数原型            |说明\n-------|-------------------|-----\nstrlen|unsigned int strlen( const char *str);|返回字符串str中实际字符的个数(不包括终止符'\\0')\nstrcat|char *strcat(char *str1,const char *str2)|把字符串str2拼接到str1后面,并在拼接好的str1串末尾添加一个'\\0',原str1末尾的'\\0'将被覆盖。因无边界检查,调用时应保证str1的空间足够大,能存放原始str1和str2两个串的内容。函数返回指向str1的指针\nstrncat|char * strncat( char * strl, constchar * str2, unsigned int count);|把字符串str2中不多于count个字符拼接到str1后面,并添加\\0',原str1末尾的'\\0'将覆盖，函数指向返回str1的指针\nstrcpy|char * strcpy( char * strl, constchar *str2);|把str2指向的字符串复制到str1中，str2必须是终止符为'\\0'的字符串指针，函数返回指向str1的指针\nstrncpy|char *strncpy(char * strl, constchar *str2,unsigned int count);|把str2指向的字符串中的count个字符复制到st1中，str2必须是终止符为'\\0'的字符串指针。如果str2指向的字符串少于 count个字符，则将'\\0'加到str1的尾部,直到满足coun个字符为止。如果str2指向的字符串长度大于count个字符，则结果串str1不用'\\0'结尾，函数返回指向strl的指针\nstrcmp|int strcmp(const char * strl,const char * str2);|按字典顺序比较两个字符串str1和str2。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数\nstrcnmp|int strcnmp( const char * strl,const char*str2,unsigned intcount);|按字典顺序比较两个字符串str1和str2的不多于count个字符。若str1&lt;str2,则返回负数。若str1=str2,则返回0。若str1&gt;str2,则返回正数\nstrtr|char * strstr(char * strl, char *str2);|找出str2字符串在str1字符串中第一次出现的位置(不包括str2的串结束符)。函数返回该位置的指针。若找不到则返回空指针\n</div>\n\n#### 数学函数\n使用以下函数，源文件需要包含<span class=\"tips\">&lt;math.h&gt;</span>头文件，以下函数这里只写出了返回值和形参为double类型的函数原型，它们中的绝大多数还有一个返回值和形参为float或long double类型的函数原型，因此可以类似地套用\n\n<div class=\"table\">\n\n函数名 |函数原型            |说明\n-------|-------------------|-----\nfabs|double fabs( double x);|计算x的绝对值，返回浮点数\nabs|double abs (double x);|在c++中该函数声明于cmath头文件，可以用于计算double、float、long double的绝对值，在c语言中声明于stdlib.h文件，用于计算int的绝对值\nceil|double ceil (double x);|向上取整\nfloor|double floor( double x);|向下取整，计算不大于x的最大整数\nround|double round  (double x);|四舍五入取整\npow|double pow( double base, doubleexp);|返回base为底的exp次幂,即base<sup>exp</sup>,返回计算结果。当base等于0而exp小于0时或者base小于0而exp不为整数时,出现结果错误。该函数要求参数base和exp以及函数的返回值为double类型,否则有可能出现数值溢出问题\nsqrt|double sqrt(double x)|计算√x(根号下x)的值，注意x>=0\nexp|double exp( double x);|计算e<sup>x</sup>的值\nfmod|double fmod ( double x, double y);|计算整除x/y的余数\nlog|double log( double x );|计算log<sub>e</sub>x,即lnx,返回计算结果。注意,x>0\nlog10|double log10( double x);|计算 log<sub>10</sub>x,返回计算结果。注意,x>0\nsin|double sin(double x)|计算sinx的值，x为弧度值\ncos|double cos(double x)|计算cos(x)的值，x为弧度值\ntan|double tan(double x);|计算tanx的值\nasin|double asin(double x)|计算cos<sup>-1</sup>(x)的值，注意，x应为-1到1范围\nacos|double acos(double x)|计算sin<sup>-1</sup>(x)的值，注意，x应为-1到1范围\natan|double atan(double x)|计算tan<sup>-1</sup>(x)的值\natan2|double atan2(double x,double y)|计算tan<sup>-1</sup>(x/y)的值\nsinh|double sinh(double x)|计算x的双曲正弦函数sinh(x)的值\ncosh|double cosh(double x)|计算x的双曲余弦 cosh(x)的值\ntanh|double tanh(double x)|计算x的双曲正切函数tanh(x)的值\nfrexp|double frexp(double val,int*eptr);|把双精度数val分解为小数部分(尾数)x和以2为底的指数n(阶码),即val=x\\*2 <sup>n</sup>,n存放在eptr指向的变量中,函数返回小数部分x,0.5≤x<1\nmodf|double modf( double val, double *iptr);|把双精度数val分解为整数部分和小数部分,把整数部分存到iptr指向的单元。返回val的小数部分\n</div>\n\n\n#### 其他常用函数\n<div class=\"table\">\n\n函数名 |头文件|函数原型            |说明\n-------|-----|--------------|----------\natof|stdlib.h|double atof(const char * str);|把str指向的字符串转换成双精度浮点值,串中必须含合法的浮点数,否则返回值无定义。函数返回转换后的双精度浮点值\natoi|stdlib.h|int atoi(const char *str);|把str指向的字符串转换成整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的整型值\nalol|stdlib.h|long int atol(const char * str);|把str指向的字符串转换成长整型值,串中必须含合法的整型数,否则返回值无定义。函数返回转换后的长整型值\nexit|stdlib.h|void exit(int code);|使程序立即终止,清空和关闭任何打开的文件。程序正常退出状态由code等于0或EXITSUCCESS表示，如exit(0)，非0值或EXIT_FAILURE表明定义实现错误。函数无返回值\nrand|stdlib.h|int rand(void);|产生伪随机数序列。函数返回0到RAND_MAX之间的随机整数,RAND_MAX至少是32767\nsrand|stdlib.h|void srand(unsigned int seed );|为函数rand()生成的伪随机数序列设置起点种子值，函数无返回值\ntime|time.h|time_t time(time_t *timer)|如果传入的参数为空指针NULL，则该函数返回当前时间到1970年1月1日0时0分0秒的时间差，单位为秒，返回值类型为time_t(但本质上为64位整型)。如果参数为time_t类型指针变量timer，则该时间差值也将放于timer所指向的内存中\nclock|time.h|clock_t clock(void);|clock_t是long类型，该函数返回硬件的时钟节拍数，需要换成秒或者毫秒，通常需要除以CLK_TCK或者CLOCKS_PER_SEC。例如,在VC6.0下,这两个量的值都是1000,表示硬件1秒钟的时钟节拍数为1000，该函数常用于测量从程序开始运行到clock()被调用时所消耗的时间，或用于实现计时器功能，如：计算一个进程的时间需要用clock()除以1000。注意:本函数仅能返回ms级的计时精度\nSleep|stdlih.h|Sleep(unsigned long second);|在标准C中和Linux下是函数的首字母不大写。但在VC和Code::blocks环境下首字母要大写。Sleep()函数的功能是将进程挂起一段时间,即起到延时的作用。参数的单是毫秒\nsystem|stdlib.h|int system(char * command);|发出一个DOS命令。例如,system(\"CLS”)可以实现清屏操作\nkbhit|conio.h|int kbhit(void);|检查当前是否有键盘输人,若有则返回一个非0值,否则回 0\ngetch|conio.h|int getch(void);|无需用户按回车键即可得到入户输入，只要用户按下一个键，立刻返回用户输入字符的ASCII码值，但输入的字符不会显示在屏幕上，出错时返回-1，该函数在游戏中比较常用\n</div>","tags":["C","note"]},{"title":"JavaScript中的各种尺寸","url":"/blog/2023/09/07/JavaScript中的各种尺寸/","content":"\n### 全局尺寸\n#### 屏幕尺寸\n+ <span class=\"strong\">window.screen.height</span>返回整个屏幕的高度\n+ <span class=\"strong\">window.screen.width</span>返回整个屏幕的宽度\n+ <span class=\"strong\">window.screen.availHeight</span>返回屏幕可用高度(去掉任务栏高度)\n+ <span class=\"strong\">window.screen.availWidth</span>返回屏幕可用宽度(去掉任务栏宽度)\n+ <span class=\"strong\">window.screenTop/window.sceenY</span>返回浏览器左边界到屏幕左边缘的距离\n+ <span class=\"strong\">window.screenLeft/window.screenX</span>返回浏览器的上边界到屏幕上边缘的距离\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\navailHeight和availWidth主要用于PC端，一般情况下，任务栏位于屏幕底部占用了屏幕高度，所以window.screen.availHeight的值是window.screen.height减去任务栏高度后得出的值，如果任务栏隐藏，screen.availHeight的值将等于screen.height。同理，当任务栏在屏幕左侧或右侧时，可以用availWidth获得当前屏幕可用宽度。</div>\n\n#### 浏览器尺寸\n+ <span class=\"strong\">window.outerHeight</span>返回整个浏览器窗口的高度，包括地址栏、标签栏、收藏栏和显示网页的布局视口高度\n+ <span class=\"strong\">window.outerWidth</span>返回整个浏览器窗口的宽度\n+ <span class=\"strong\">window.innerHeight</span>返回浏览器显示网页用的布局视口(layout viewport)高度，包含滚动条(如果有)，不包含地址栏、标签栏、收藏栏的高度\n+ <span class=\"strong\">window.innerWidth</span>返回浏览器视口宽度，包含滚动条(如果有)\n\n任何窗口对象window、frame、frameset都支持window.innerHeight属性，outerHeight和innerHeight区别如下(图片来源于MDN文档)\n\n<img data-src=\"/blog/images/innervsouterheight.png\" src=\"#\" alt=\"innerHeight\">\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n在Android端浏览器中，上述4个属性的返回值可能不可靠，如可能出现innerHeight值大于outerHeight等情况，不同Android系统版本返回值不同，因此在移动端中请慎用，Stack Overflow上有一篇讨论这一问题的帖子：<a href=\"https://stackoverflow.com/questions/10610743/android-browsers-screen-width-screen-height-window-innerwidth-window-inner\" target=\"_blank\">Android browser's screen.width, screen.height & window.innerWidth & window.innerHeight are unreliable</a></div>\n\n#### 鼠标位置\n鼠标事件触发时，与鼠标位置有关的坐标\n+ <span class=\"strong\">event.screenY</span>返回触发事件时，鼠标在屏幕中的Y坐标值\n+ <span class=\"strong\">event.screenX</span>返回触发事件时，鼠标在屏幕中的X坐标值\n+ <span class=\"strong\">event.pageY</span>返回触发事件时，鼠标相对于整个document的Y坐标值，其值会受文档滚动影响\n+ <span class=\"strong\">event.pageX</span>返回触发事件时，鼠标相对于整个document的X坐标值，其值会受文档滚动影响\n+ <span class=\"strong\">event.clientY</span>返回触发事件时，鼠标相对于浏览器当前网页视口的Y坐标值，其值不受滚动影响\n+ <span class=\"strong\">event.clientX</span>返回触发事件时，鼠标相对于浏览器当前网页视口的X坐标值，其值不受滚动影响\n+ <span class=\"strong\">event.offsetY</span>返回触发事件时，鼠标相对于事件触发源Dom上边界的Y坐标值，其值会受该Dom滚动的影响\n+ <span class=\"strong\">event.offsetX</span>返回触发事件时，鼠标相对于事件触发源Dom左边界的X坐标值，其值会受该Dom滚动的影响\n+ event.movementY 返回当前事件和上一个mousemove事件之间，鼠标在竖直方向上的移动值\n+ event.movementX 返回当前事件和上一个mousemove事件之间，鼠标在水平方向上的移动值\n+ event.x 即event.clientX的别名，实验性属性，兼容性较差\n+ event.y 即event.clientY的别名，实验性属性，兼容性较差\n\n<canvas width=\"300\" height=\"400\" id=\"canvasMouseEvent\"\n        style=\"display:block;width:300px;height:400px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n        const canvasMouseEvent = document.getElementById('canvasMouseEvent');\n        const ctxME = canvasMouseEvent.getContext('2d');\n        ctxME.beginPath();\n        ctxME.lineWidth = 2;\n        ctxME.strokeRect(10, 150, 280, 200);\n        ctxME.lineWidth = 1;\n        ctxME.strokeRect(60, 200, 180, 100);\n        ctxME.arc(160,250,3,0,Math.PI*2);\n        ctxME.stroke();\n        ctxME.closePath();\n        ctxME.beginPath();\n        ctxME.lineWidth = 1;\n        ctxME.strokeStyle = \"#f00\";\n        ctxME.moveTo(160, 200);\n        ctxME.lineTo(160, 250);\n        ctxME.moveTo(155, 205);\n        ctxME.lineTo(160, 200);\n        ctxME.lineTo(165, 205);\n        ctxME.moveTo(160, 250);\n        ctxME.lineTo(60, 250);\n        ctxME.moveTo(65, 255);\n        ctxME.lineTo(60, 250);\n        ctxME.lineTo(65, 245);\n        ctxME.font = \"16px Serif\";\n        ctxME.fillStyle = \"#f00\";\n        ctxME.fillText('offsetY', 160, 230)\n        ctxME.fillText('offsetX', 80, 245)\n        ctxME.stroke();\n        ctxME.closePath();\n        ctxME.beginPath();\n        ctxME.strokeStyle = \"#00f\";\n        ctxME.moveTo(190, 10);\n        ctxME.lineTo(190, 250);\n        ctxME.moveTo(185, 25);\n        ctxME.lineTo(190, 10);\n        ctxME.lineTo(195, 25);\n        ctxME.moveTo(10, 280);\n        ctxME.lineTo(160, 280);\n        ctxME.moveTo(20, 275);\n        ctxME.lineTo(10, 280);\n        ctxME.lineTo(20, 285);\n        ctxME.fillStyle = \"#00f\";\n        ctxME.fillText('pageY', 200, 80)\n        ctxME.fillText('pageX', 80, 295)\n        ctxME.stroke();\n        ctxME.closePath();\n        ctxME.beginPath();\n        ctxME.strokeStyle = \"#05fe05\";\n        ctxME.moveTo(170, 152);\n        ctxME.lineTo(170, 250);\n        ctxME.moveTo(165, 167);\n        ctxME.lineTo(170, 152);\n        ctxME.lineTo(175, 167);\n        ctxME.moveTo(10, 260);\n        ctxME.lineTo(160, 260);\n        ctxME.moveTo(25, 265);\n        ctxME.lineTo(10, 260);\n        ctxME.lineTo(25, 255);\n        ctxME.stroke();\n        ctxME.font = \"16px Serif\";\n        ctxME.fillStyle = \"#05fe05\";\n        ctxME.fillText('clientY', 170, 190);\n        ctxME.fillText('clientX', 70, 275);\n        ctxME.closePath();\n        ctxME.fillStyle = \"#000\";\n        ctxME.fillText('浏览器可视区', 15, 170)\n        ctxME.fillText('document溢出部分', 15, 30)\n        ctxME.fillText('dom', 65, 215)\n        ctxME.fillText('鼠标事件', 165, 265)\n        ctxME.beginPath();\n        ctxME.strokeStyle = \"#000\";\n        ctxME.setLineDash([10, 5]);\n        ctxME.strokeRect(10, 10, 280, 380);\n        ctxME.closePath();\n</script>\n\n<div class=\"show\">pageY、pageX、offsetY、offsetX的值会受到文档/Dom滚动的影响，即在鼠标位置不变的情况下，文档和Dom滚动前后，鼠标事件触发获得的返回值不一样，因为鼠标相对于整个文档/Dom的位置改变了。而clientX、clientY的返回值始终是以当前网页视口左上角为基准进行计算的，与文档、Dom滚动无关\nbox.addEventListener('click',e=>{\n            e.stopPropagation();\n            console.log('offsetX:'+e.offsetX+'px;\\noffsetY:'+e.offsetY+'px;\\n');\n            console.log('pageX:'+e.pageX+'px;\\npageY'+e.pageY+'px;\\n');\n        })</div>\n\n### Dom\n#### client\n+ <span class=\"strong\">Element.clientHeight</span>元素内部的高度，包含padding值，但不包含border，margin和滚动条带来的高度\n+ <span class=\"strong\">Element.clientWidth</span>元素内部的宽度，同上\n+ <span class=\"strong\">Element.clientTop</span>返回元素顶部边框的宽度，即border--top-width的值，表示元素内容(content)到元素顶部的距离\n+ <span class=\"strong\">Element.clientLeft</span>返回元素左边框的宽度，即border-left-width的值，表示元素内容到元素左侧的距离。如果元素左边有垂直滚动条，则该属性包括滚动条的宽度\n\n#### offset\n+ <span class=\"strong\">Element.offsetHeight</span>元素高度，包含padding，border和滚动条，不包含:before 或:after 等伪类元素的高度\n+ <span class=\"strong\">Element.offsetWidth</span>元素的宽度，同上\n+ <span class=\"strong\">Element.offsetTop</span>返回当前元素相对于最近的祖先定位元素的顶部距离，一般是top值+子元素的margin-top值\n+ <span class=\"strong\">Element.offsetLeft</span>返回当前元素相对于最近的祖先定位元素的左侧距离，一般是left值+子元素的margin-left值\n\n#### scroll\n+ <span class=\"strong\">Element.scrollHeight</span> 返回包括溢出部分的元素高度，包括padding值、伪元素的高度，但不包括border、margin和滚动条的值，如果元素不溢出，则该值等于clientHeight\n+ <span class=\"strong\">Element.scrollWidth</span>返回包括溢出部分的元素宽度，内容同上\n\n+ <span class=\"strong\">Element.scrollTop</span>可以设置和获取，代表元素的内容顶部到它的视口可见内容顶部的距离\n+ <span class=\"strong\">Element.scrollTop</span>可以设置和获取，代表元素的内容左边界到它的视口可见内容左边界的距离\n\n\n<canvas width=\"300\" height=\"500\" id=\"canvasScroll\" style=\"display:block;width:300px;height:500px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n      const canvasScroll = document.getElementById('canvasScroll');\n        const ctxScroll = canvasScroll.getContext('2d');\n        ctxScroll.beginPath();\n        ctxScroll.lineWidth = 5;\n        ctxScroll.strokeRect(10, 150, 280, 200);\n        ctxScroll.closePath();\n        ctxScroll.beginPath();\n        ctxScroll.lineWidth = 1;\n        ctxScroll.strokeStyle = \"#f00\";\n        ctxScroll.moveTo(40, 10);\n        ctxScroll.lineTo(40, 490);\n        ctxScroll.moveTo(35, 25);\n        ctxScroll.lineTo(40, 10);\n        ctxScroll.lineTo(45, 25);\n        ctxScroll.moveTo(35, 475);\n        ctxScroll.lineTo(40, 490);\n        ctxScroll.lineTo(45, 475);\n        ctxScroll.font = \"20px Serif\";\n        ctxScroll.fillStyle = \"#f00\";\n        ctxScroll.fillText('scrollHeight', 40, 250)\n        ctxScroll.stroke();\n        ctxScroll.closePath();\n        ctxScroll.beginPath();\n        ctxScroll.strokeStyle = \"#00f\";\n        ctxScroll.moveTo(190, 10);\n        ctxScroll.lineTo(190, 150);\n        ctxScroll.moveTo(185, 25);\n        ctxScroll.lineTo(190, 10);\n        ctxScroll.lineTo(195, 25);\n        ctxScroll.moveTo(185, 135);\n        ctxScroll.lineTo(190, 150);\n        ctxScroll.lineTo(195, 135);\n        ctxScroll.fillStyle = \"#00f\";\n        ctxScroll.fillText('scrollTop', 190, 80)\n        ctxScroll.stroke();\n        ctxScroll.closePath();\n        ctxScroll.beginPath();\n        ctxScroll.strokeStyle = \"#05fe05\";\n        ctxScroll.moveTo(170, 152);\n        ctxScroll.lineTo(170, 348);\n        ctxScroll.moveTo(165, 167);\n        ctxScroll.lineTo(170, 152);\n        ctxScroll.lineTo(175, 167);\n        ctxScroll.moveTo(165, 333);\n        ctxScroll.lineTo(170, 348);\n        ctxScroll.lineTo(175, 333);\n        ctxScroll.stroke();\n        ctxScroll.font = \"20px Serif\";\n        ctxScroll.fillStyle = \"#05fe05\";\n        ctxScroll.fillText('clientHeight', 170, 250)\n        ctxScroll.closePath();\n        ctxScroll.fillStyle = \"#000\";\n        ctxScroll.fillText('元素显示部分', 45, 180)\n        ctxScroll.fillText('元素溢出部分', 45, 30)\n        ctxScroll.beginPath();\n        ctxScroll.strokeStyle = \"#000\";\n        ctxScroll.setLineDash([10, 5]);\n        ctxScroll.strokeRect(20, 10, 260, 480);\n        ctxScroll.closePath();\n</script>\n\n<div class=\"show\">判断元素是否已经滚到底部，以及判定用户是否已经阅读完文本的解决方案：\n判断是否满足scrollHeight-scrollTop=clientHeight，由于scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的整数，因此判断三个值的差值小于某个阈值即可\nMath.abs(ele.scrollHeight - ele.clientHeight - ele.scrollTop)&lt;3\n</div>\n\n### DOMRect对象\n上述属性返回值一般为四舍五入的整数值，通过DOMRect对象可以获得更为精确的浮点数坐标值\n#### Element.getBoundingClientRect()\n该方法会返回一个DOMRect对象，该对象提供了几个描述该Dom位置和大小的属性，这些属性都是基于网页可视窗口的左上角作为坐标原点进行计算的\n\n+ <span class=\"strong\">width</span>返回Dom的宽度，包含padding值和border-width值\n+ <span class=\"strong\">height</span>返回Dom的高度，包含padding值和border-width值\n+ <span class=\"strong\">x/left</span>返回Dom左边界到网页可视窗口左边界的距离\n+ <span class=\"strong\">y/top</span>返回Dom上边界到网页可视窗口上边界的距离\n+ <span class=\"strong\">right</span>返回Dom右边界到网页可视窗口左边界的距离\n+ <span class=\"strong\">bottom</span>返回Dom下边界到网页可视窗口左边界的距离\n\n<canvas width=\"300\" height=\"300\" id=\"canvasDomRect\"\n        style=\"display:block;width:300px;height:300px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n        const canvasDomRect = document.getElementById('canvasDomRect');\n        const ctxDR = canvasDomRect.getContext('2d');\n        ctxDR.beginPath();\n        ctxDR.lineWidth = 2;\n        ctxDR.strokeRect(10, 10, 280, 280);\n        ctxDR.lineWidth = 1;\n        ctxDR.strokeRect(70, 70, 150, 150);\n        ctxDR.stroke();\n        ctxDR.closePath();\n        ctxDR.beginPath();\n        ctxDR.font = \"16px Serif\";\n        ctxDR.strokeStyle = \"#f00\";\n        ctxDR.moveTo(70,200);\n        ctxDR.lineTo(220,200);\n        ctxDR.moveTo(85,195);\n        ctxDR.lineTo(70,200);\n        ctxDR.lineTo(85,205);\n        ctxDR.moveTo(205,195);\n        ctxDR.lineTo(220,200);\n        ctxDR.lineTo(205,205);\n        ctxDR.fillStyle = \"#f00\";\n        ctxDR.fillText('width', 130, 190)\n        ctxDR.fillText('height', 165, 150);\n        ctxDR.moveTo(200,70);\n        ctxDR.lineTo(200,220);\n        ctxDR.moveTo(195,85);\n        ctxDR.lineTo(200,70);\n        ctxDR.lineTo(205,85);\n        ctxDR.moveTo(195,205);\n        ctxDR.lineTo(200,220);\n        ctxDR.lineTo(205,205);\n        ctxDR.stroke();\n        ctxDR.closePath();\n        ctxDR.beginPath();\n        ctxDR.strokeStyle = \"#00f\";\n        ctxDR.moveTo(100, 10);\n        ctxDR.lineTo(100, 70);\n        ctxDR.moveTo(95, 25);\n        ctxDR.lineTo(100, 10);\n        ctxDR.lineTo(105, 25);\n        ctxDR.moveTo(10, 100);\n        ctxDR.lineTo(70, 100);\n        ctxDR.moveTo(25, 95);\n        ctxDR.lineTo(10, 100);\n        ctxDR.lineTo(25, 105);\n        ctxDR.fillStyle = \"#00f\";\n        ctxDR.fillText('y/top', 110, 45)\n        ctxDR.fillText('x/left', 15, 90)\n        ctxDR.stroke();\n        ctxDR.closePath();\n        ctxDR.beginPath();\n        ctxDR.strokeStyle = \"#05fe05\";\n        ctxDR.moveTo(240, 10);\n        ctxDR.lineTo(240, 220);\n        ctxDR.moveTo(235, 25);\n        ctxDR.lineTo(240, 10);\n        ctxDR.lineTo(245, 25);\n        ctxDR.moveTo(10, 240);\n        ctxDR.lineTo(220, 240);\n        ctxDR.moveTo(25, 245);\n        ctxDR.lineTo(10, 240);\n        ctxDR.lineTo(25, 235);\n        ctxDR.stroke();\n        ctxDR.setLineDash([5,2]);\n        ctxDR.moveTo(260,220);\n        ctxDR.lineTo(220, 220);\n        ctxDR.lineTo(220, 260);\n        ctxDR.stroke();\n        ctxDR.fillStyle = \"#05fe05\";\n        ctxDR.fillText('bottom', 230, 140);\n        ctxDR.fillText('right', 100, 255);\n        ctxDR.closePath();\n        ctxDR.fillStyle = \"#000\";\n        ctxDR.fillText('viewPort', 15, 30);\n        ctxDR.fillText('Element', 125, 85);\n    </script>\n\n\n<div class=\"show\">使用前，使用css清除浏览器默认的padding和margin值，避免浏览器默认值带来的影响\n*{\n            margin: 0;\n            padding: 0;\n        }\n但返回值还是会有一些底层渲染和二进制转化带来的误差\n  const box=document.querySelector('.box');\n  const boxRect=box.getBoundingClientRect();\n  console.log(boxRect.width);//eg: 309.6000061035156\n  console.log(boxRect.left);\n</div>\n\n","tags":["javaScript","html"]},{"title":"xml","url":"/blog/2023/05/25/xml/","content":"### 简介\n#### 关于\nXML 指可扩展标记语言(EXtensible Markup Language)，其文件以<span class=\"tips\">.xml</span>为后缀名，主要用于数据存储、数据传输、编写配置文件，语法格式与HTML相似，二者主要差异有：\n+ XML标签没有被预定义，需要自行定义标签；HTML虽然支持自定义标签，但主要使用预定义标签\n+ XML主要用于传输和存储数据，HTML主要用于显示数据\n+ XML语法要求比HTML严格\n\n#### 组成\nxml文档基本由以下模块组成\n+ 标签(元素)：文档主要部分，将被解析为XML DOM\n+ 标签属性：提供关于标签的信息\n+ 转义字符(实体)：XML中预用字符的实体引用\n+ PCDATA(Parsed Character Data)：需要由解析器解析的文本\n+ CDATA(Character Data)：解析器不会解析的文本，内容将视为字符串\n\n### 语法\n#### xml标签定义规范\nxml中的标签需要自定义，标签名需要遵循以下规范\n+ 可以包含字母、数字和其他符号，包括连字符(-)、下划线(_)和点号(.)\n+ 不能以数字或者标点符号开始\n+ 不能以xml、 XML、Xml开始\n+ 不能包含空格\n+ 尽量避免使用<span class=\"tips\">-</span>和<span class=\"tips\">.</span>字符，该类字符在某些XML解析器中中可能会被错误解析\n+ 避免使用<span class=\"tips\">:</span>，该字符用于命名空间\n\n#### xml基本语法格式\n<div class=\"code\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;web> \n&lt;author>SHIWIVI&lt;/author>\n&lt;license>CC BY-NC&lt;/license>\n&lt;heading>&lt;type>Document&lt;/type>&lt;/heading>\n&lt;body>Meet you like the wind&lt;/body>\n&lt;/web></div>\n\n+ 首行进行xml文档声明，version属性定义版本，encoding声明编码格式\n+ 必须包含一个根标签，标签名自定义\n+ XML标签大小写敏感\n+ 所有XML标签都必须闭合，自闭合标签禁止省略<span class=\"tips strong\">/</span>\n+ XML的属性值须加引号，即便属性值是数值，单双引号均可用\n+ XML标签禁止交叉嵌套\n+ XML中多个连续空格也会被保留，HTML中会被合并\n+ XML 以 LF 存储换行\n\n\n<div class=\"show\">xml正确嵌套：\n&lt;a>&lt;b>content&lt;/b>&lt;/a>\n严禁交叉嵌套：\n&lt;a>&lt;b>content&lt;/a>&lt;/b>\n</div>\n\n##### 空标签\nxml允许空标签，即标签中无内容\n<div class=\"show\">&lt;element>&lt;/element>\n空标签可以使用自闭合，但禁止省略 /\n&lt;element /></div>\n\n\n#### 转义字符\n以下字符在XML中被预定义，使用时需要转义\n<div class=\"table\">\n\n字符|转义     |字符|转义|\n----|---------|----|-----\n&lt;|&amp;lt;|&apos;|&amp;apos;\n&gt;|&amp;gt;|&quot;|&amp;quot;\n&amp;|&amp;amp;\n\n</div>\n\n#### CDATA字符数据\nCDATA(character data)指不被xml解析器解析的文本数据，当文档中出现需要大量转义的字符时，可以直接使用CDATA进行引用，这样，这些字符将不会被xml解析器解析，\n\nCDATA 部分由<span class=\"strong tips\">&lt;![CDATA[</span>开始，<span class=\"strong tips\">]]&gt;</span>结束\n<div class=\"show\">&lt;root>\n&lt;title>标题&lt;/title>\n&lt;![CDATA[\n    if(a&lt;b&&b&lt;c){\n    ....\n        }\n    ]]&gt;\n&lt;/root></div>\n\n### 命名空间\n由于xml中标签是自定义的，多个xml文档同时使用可能出现标签名相同导致命名冲突的情况，此时需要使用命名空间来解决标签名冲突问题\n<div class=\"show\">&lt;person>\n&lt;name>周杰伦&lt;/name>\n&lt;song>米兰的小铁匠&lt;/song>\n&lt;/person>\n</div>\n<div class=\"show\">&lt;person>\n&lt;name>东野圭吾&lt;/name>\n&lt;writing>解忧杂货店&lt;/writing>\n&lt;/person></div>\n\n#### 添加前缀\n在标签名前添加前缀，来定义不同的标签，从而对不同文档的同名标签加以区分\n<div class=\"show\">&lt;j:person>\n&lt;j:name>周杰伦&lt;/j:name>\n&lt;j:song>米兰的小铁匠&lt;/j:song>\n&lt;/j:person>\n&lt;h:person>\n&lt;h:name>东野圭吾&lt;/h:name>\n&lt;h:writing>解忧杂货店&lt;/h:writing>\n&lt;/h:person></div>\n\n#### 添加XML Namespace(xmlns)属性\n可以在父标签中添加命名空间属性，以此定义一个命名空间，之后带有相同前缀的子标签都将同属于该命名空间\n<span class=\"strong\">xmlns:命名前缀=\"namespaceURI\"</span>\n\n<div class=\"show\">&lt;j:person xmlns:j=\"Jay Chou\">\n&lt;j:name>周杰伦&lt;/j:name>\n&lt;j:song>米兰的小铁匠&lt;/j:song>\n&lt;/j:person>\n&lt;h:person xmlns:h=\"Higashino Keigo\">\n&lt;h:name>东野圭吾&lt;/h:name>\n&lt;h:writing>解忧杂货店&lt;/h:writing>\n&lt;/h:person></div>\n\n#### 使用默认的命名空间\n当父元素定义默认的命名空间时，我们可以省略子元素中的前缀\n<span class=\"strong\">xmlns=\"namespaceURI\"</span>\n\n<div class=\"show\">&lt;person xmlns=\"Jay Chou\">\n&lt;name>周杰伦&lt;/name>\n&lt;song>米兰的小铁匠&lt;/song>\n&lt;/person>\n&lt;person xmlns=\"Higashino Keigo\">\n&lt;name>东野圭吾&lt;/name>\n&lt;writing>解忧杂货店&lt;/writing>\n&lt;/person></div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\nURI指统一资源标识符(Uniform Resource Identifier)，用于标识因特网资源，最常用的 URI 是用来标示因特网域名地址的统一资源定位器(URL)，另一个不那么常用的 URI 是统一资源命名(URN)，在使用命名空间时，很多xml文档会将名称写为一个链接形式，但该链接仅作为该命名空间的字符串名称，并不是要”链接”到某个地址，不会引入任何资源</div>\n\n### DTD验证\nDTD(Document Type Definition):文档类型定义，是一套为了进行程序间的数据交换而建立的关于标记符的语法规则\n\nxml的标签是可以自由定义的，每个人写的xml将完全不同。但在一个团队内部，我们往往希望拥有一个统一的文件格式来进行数据交换。此时，我们可以使用DTD来对xml文件进行约束，使用一个标准的 DTD 来交换数据\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n使用IntelliJ IDEA写xml文件可以即时校验文档内容是否满足DTD验证</div>\n\n#### 标签声明\n限制标签内可以写入哪些内容\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child1,child2...)> 标签中可以包含的子标签</span>\n父标签中按顺序声明其中可以包含的子标签，子标签必须以相同的顺序出现在xml文档中，并且所有子标签也要声明其中可以写入的内容，子标签可以嵌套地拥有子标签\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child1,(child2|child3)...)> 标签中可以包含的子标签并可选</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (#PCDATA)> 标签中仅包含需要解析的字符数据(可以为空)</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 EMPTY> 声明为空标签</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 ANY> 标签中可包含任何内容 </span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (#PCDATA|child1|child2|...)*> 标签中可包含PCDATA数据，也可以包含指定子标签<span class=\"tips\">必须添加\\*号</span></span>\n\n##### 限制子标签的数量\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child)> 子标签必须出现一次，且只能出现一次</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child+)> 子元素至少出现一次</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child*)> 子元素出现零次或多次</span>\n+ <span class=\"strong\">&lt;!ELEMENT 标签名 (child?)> 子元素出现零次或一次</span>\n\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n        &lt;!ELEMENT web (author,license,(body|content))>\n        &lt;!ELEMENT author     (#PCDATA)>\n        &lt;!ELEMENT license    (#PCDATA)>\n        &lt;!ELEMENT heading    (#PCDATA|type)*>\n        &lt;!ELEMENT type       (#PCDATA)>\n        &lt;!ELEMENT body       (#PCDATA)>\n        &lt;!ELEMENT content    (#PCDATA)>\n]>\n&lt;web> \n    &lt;author>SHIWIVI&lt;/author>\n    &lt;license>lol&lt;/license>\n    &lt;heading>&lt;type>Document&lt;/type>&lt;/heading>\n    &lt;body>Meet you like the wind&lt;/body>\n&lt;/web>\n1. !DOCTYPE web -  声明文档的根标签是web\n2. !ELEMENT web -  声明web元素必须包含元素：author,license标签，body和content标签可二选一\n3. !ELEMENT author - 声明author标签内容为 \"#PCDATA\"(其余语句同理)\n4. !ELEMENT heading  - 声明author标签内容为 \"#PCDATA\"或type标签，由于标签内容受限，需添加*号表示可出现零次或多次\n</div>\n\n##### 声明实体\n<span class=\"strong\">&lt;!ENTITY 实体引用名称 \"实体实际代表含义\"> 定义一个实体</span>\n引用实体需要添加<span class=\"tips\">&</span>和<span class=\"tips\">;</span>\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n        &lt;!ELEMENT web (author,license)>\n        &lt;!ELEMENT author (#PCDATA)>\n        &lt;!ELEMENT license (#PCDATA)>\n        &lt;!ENTITY sm \"shiwivi.com\">//实体声明\n        &lt;!ENTITY license \"License CC BY-NC 4.0\">\n        ]>\n&lt;web>\n    &lt;author>&amp;sm;&lt;/author>//将解析为&lt;author>shiwivi.com&lt;/author>\n    &lt;license>&amp;license;&lt;/license>\n&lt;/web></div>\n\n\n\n#### 属性声明\n限制标签可添加的属性以及属性值，语法格式为：\n<span class=\"strong\">&lt;!ATTLIST 标签名 属性名 属性类型 属性值></span>\n\n<div class=\"table\">\n\n属性类型     |     说明         |属性类型   |说明\n----------|------------------|---------|----\nCDATA     |字符               |NMTOKEN  |该值是有效的XML名称\n(v1\\|v2\\|..)|值只能为指定内容(枚举)    |NMTOKENS|该值是有效XML名称的列表\nID        |值为唯一ID         |ENTITY\t|值是一个实体\nIDREF      |值是另一个元素的id |ENTITIES|值是实体列表\nIDREFS\t   |该值是其他ID的列表 |xml:\t|该值是预定义的xml值\n</div>\n\n<div class=\"table\">\n\n属性值 | 说明 | 属性值 |说明\n-------|------|-------|-----\n字符串 |属性默认值|#REQUIRED|属性是必需的\n#IMPLIED|属性是可选的|#FIXED 值|属性值是固定的\n\n</div>\n\n<div class=\"show\">1. 限制为test标签添加的属性只能为code，如果开发者不指定属性值，则默认值为java\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n        &lt;!ELEMENT web (test)>\n        &lt;!ELEMENT test EMPTY>\n        &lt;!ATTLIST test code \"java\">//属性声明\n        ]>\n&lt;web>\n    &lt;test code=\"javaScript\"/>\n&lt;/web>\n2. 该标签必须添加code属性，并且不指定默认值\n&lt;!ATTLIST test code CDATA #REQUIRED>\n3. 该标签不强制要求添加code属性，也不指定默认值\n&lt;!ATTLIST test code CDATA #IMPLIED>\n4. 该标签强制拥有code属性并指定属性值为java，且不允许修改\n&lt;!ATTLIST test code CDATA #FIXED \"java\">\n</div>\n\n\n\n\n#### DTD文件引入\n##### 内部DTD\n如果DTD被包含在xml文件中，需要被包装于<span class=\"tips\">DOCTYPE</span>声明中\n<span class=\"strong\">&lt;!DOCTYPE 根标签 [标签声明内容]&gt;</span>\n\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web [\n     &lt;!ELEMENT web (author,license)>\n     &lt;!ELEMENT author (#PCDATA)>\n     &lt;!ELEMENT license (#PCDATA)>\n]&gt;\n&lt;web> \n    .....\n&lt;/web></div>\n\n##### 外部私有DTD\n可以将DTD声明为一个外部文件，然后引用到xml文档中\n<span class=\"strong\">&lt;!DOCTYPE 根标签 SYSTEM \"DTD的URL\"></span>\n\n<div class=\"show\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE web SYSTEM \"./check.dtd\">\n&lt;web> \n    ....\n&lt;/web></div>\n<div class=\"code\">&lt;!--check.dtd文件-->\n&lt;!ELEMENT web (author,license)>\n     &lt;!ELEMENT author (#PCDATA)>\n     &lt;!ELEMENT license (#PCDATA)></div>\n\n##### 外部公用DTD\n也可以使用一些标准化组织或权威机构提供的DTD\n<span class=\"strong\">&lt;!DOCTYPE 根标签 PUBLIC \"DTD公共名称\" \"DTD的URL\"></span>\n\nDTD公共名称格式为：<span class=\"strong\">\"是(否)ISO注册//注册组织//DTD所描述的文件的信息//语言\"</span>\n+ 是否由国际标准化组织(ISO)注册，+表示是，-表示不是\n+ 注册组织或个人\n+ 该DTD所验证文件的描述性信息，经常还会添加版本号\n+ 语言标识，如：ZH为中文，EN为英文\n<div class=\"show\">lt;!DOCTYPE web PUBLIC \"-//shiwivi//blog config//CN\" \"http://www.shiwivi.com/blog/check.dtd\"></div>\n","tags":["Web","Serve"]},{"title":"SVG矢量图","url":"/blog/2023/05/19/SVG矢量图/","content":"\n### 简介\n<span class=\"strong\">SVG</span>(Scalable Vector Graphics)全称为可缩放矢量图形，是一种用 XML 标记语言描述二维矢量图形的技术，它有以下特点：\n+ 使用XML语法文本定义图形，因此SVG图形可以被索引、搜索、选中，很适合制作地图\n+ SVG提供的是矢量图，可以被无限放大且不会失真，也可以在任何分辨率下被高质量地打印\n+ SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强\n\n### 使用\n在HTML中使用SVG，可以直接在文档中直接创建SVG标签，也可以先创建svg文件或者xml文件，再引入到HTML中\n#### svg文件\nSVG文件通常以<span class=\"tips\">.svg</span>作为文件后缀，使用<span class=\"tips\">gzip</span>压缩的SVG文件以<span class=\"tips\">.svgz</span>为后缀名\n\n<div class=\"show\">&lt;svg version=\"1.1\"\n     baseProfile=\"full\"\n     width=\"300\" height=\"200\"\n     viewBox=\"0 0 100 100\"\n     xmlns=\"http://www.w3.org/2000/svg\">\n&lt;/svg></div>\n\n+ version属性用于验证识别SVG版本，SVG 2之后的版本不再推荐使用该属性值\n+ baseProfile 属性用于描述作者认为正确呈现内容所必需的最小SVG语言配置文件，当用户修改内容超出所指定的基准概述范围时，编辑工具会发出警告，一般可以不指定，即使用默认值none，可取值：\n> + none(默认)，代表作者无观点，使用最小的 SVG 语言配置\n> + full(正常)，适用于PC\n> + basic(轻量级)，适用于平板电脑等PDA\n> + tiny(更轻量级)，适用于手机\n+ width和height属性用于指定画布大小，单位会自行解析为px而无需指定，默认大小为300px*150px\n+ viewBox属性用于指定显示区域，上述参数解析为仅显示从(0,0)坐标开始，长宽均为100px的矩形区域内的图形\n+ xmlns属性用于声明命名空间，这里的URL只做该命名空间的字符串名称，并不是要\"链接\"到某个地址。命名空间用于多个文档声明了相同的标签时，帮助XML内容的使用者区别该标签属于哪一个命名空间\n+ 拥有命名空间后意味着该&lt;svg> 标签和它的子节点都属于该命名空间\n\n##### svg写入xml文件\n\n<div class=\"show\">&lt;?xml version=\"1.0\" ?>\n&lt;svg version=\"1.1\"\n     baseProfile=\"full\"\n     width=\"300\" height=\"200\"\n     xmlns=\"http://www.w3.org/2000/svg\">\n     &lt;circle cx=\"150\" cy=\"100\" r=\"80\" fill=\"green\" />\n&lt;/svg></div>\n\n\n#### 引入\n##### 直接插入&lt;svg>标签\n可以直接在HTML所需位置插入&lt;svg>标签\n<div class=\"show\">&lt;body>\n     &lt;svg width=\"400\" height=\"300\">\n          &lt;!--svg内容-->\n     &lt;/svg>\n&lt;/body>     \n</div>\n\n##### 通过img标签引入\n可以将svg定义为一个单独文件，然后通过img标签引入图片\n<div class=\"show\">&lt;img src=\"./index.svg\" alt=\"未加载SVG\"></div>\n\n##### CSS引入\n在CSS样式中将svg作为背景图引入\n<div class=\"show\">.svgPic{\n         width: 400px;\n         height: 300px;\n         background-image: url(./index.svg);\n         background-repeat: no-repeat;\n     }\n</div>\n\n##### object标签引入\nobject标签可用于包含音视频及图形对象，并且支持<span class=\"tips\">.svg</span>和<span class=\"tips\">.xml</span>格式的文件\n<div class=\"show\">&lt;object data=\"./index.svg\" type=\"image/svg+xml\" width=\"400\" height=\"300\">未加载SVG&lt;/object></div>\n<div class=\"show\">&lt;object data=\"./index.xml\" type=\"image/svg+xml\" width=\"400\" height=\"300\">未加载SVG&lt;/object></div>\n\n##### iframe标签引入\n使用内联框架引入svg数据，该标签也同时支持<span class=\"tips\">.svg</span>和<span class=\"tips\">.xml</span>文件\n<div class=\"show\">&lt;iframe src=\"./index.svg\"  width=\"400\" height=\"300\">浏览器不支持iframe标签&lt;/iframe></div>\n<div class=\"show\">&lt;iframe src=\"./index.xml\"  width=\"400\" height=\"300\">浏览器不支持iframe标签&lt;/iframe></div>\n\n\n\n### 基本图形\n#### 矩形\n<span class=\"strong\">rect标签</span>\n<div class=\"show\">&lt;rect x=\"10\" y=\"10\" rx=\"20\" ry=\"40\" width=\"200\" height=\"200\" >&lt;/rect></div>\n\n+ (x,y)为矩形左上角坐标\n+ width,height为矩形长和高，不能为负值！(与canvas不同)\n+ rx为矩形与x轴平行的两条边的圆角半径，默认为0\n+ ry为矩形与y轴平行的两条边的圆角半径，默认为0\n\n#### 圆\n<span class=\"strong\">circle标签</span>\n<div class=\"show\">&lt;circle cx=\"100\" cy=\"100\" r=\"50\">&lt;/circle></div>\n\n+ (cx,cy)为圆心坐标\n+ r为圆的半径\n\n#### 椭圆\n<span class=\"strong\">ellipse标签</span>\n<div class=\"show\">&lt;ellipse cx=\"200\" cy=\"200\" rx=\"100\" ry=\"50\">&lt;/ellipse></div>\n\n+ (cx,cy)为椭圆中心的坐标\n+ rx为椭圆的 x 半径，ry为椭圆的 y 半径\n\n#### 线段line\n<div class=\"show\">&lt;line x1=\"150\" y1=\"300\" x2=\"300\" y2=\"350\"stroke=\"#fff\" stroke-width=\"5\">&lt;/line></div>\n\n+ (x1,y1)为线段起始坐标\n+ (x2,y2)为线段终点坐标\n+ stroke指定线段绘制颜色\n\n#### 折线polyline\n<div class=\"show\">&lt;polyline points=\"0 0,10 10,20 0,30 10\" style=\"stroke:#fff;\" /></div>\n\n+ points属性指定折线折点，每个折点必须指定x,y坐标\n+ 坐标之间可以用空白符、逗号、或者可附带空格的换行符分隔开\n\n<div class=\"show\">以下写法均可以表示(0,0)、(10,10)、(20,0)、(30,10)四个坐标点，也可以用换行替代\npoints=\"0 0 10 10 20 0 30 10\"\npoints=\"0 0,10 10,20 0,30 10\"\npoints=\"0,0 10,10 20,0 30,10\"\n</div>\n\n#### 多边形polygon\n<div class=\"show\">&lt;polygon points=\"10 10,60 30,120 10\" style=\"stroke:#fff;\" />\n</div>\n\n+ points属性与polyline类似\n+ 坐标最后一个点会和第一个点闭合\n\n### path路径\n通过描述路径坐标理论上可绘制任意图形，路径坐标的表示方法与上述points属性坐标表示方法相同，可以用空白符、逗号、或者可附带空格的换行符进行分隔\n#### 命令参数\n<div class=\"show\">&lt;path d=\"M250 150 L150 350 L350 350 Z\" /></div>\n\n+ d属性通过\"命令+坐标参数\"的组合来描述路径\n+ 命令为<span class=\"tips\">大写字母</span>时表示<span class=\"strong\">绝对定位</span>，即相对于svg左上角坐标原点的坐标，命令为<span class=\"tips\">小写字母</span>时表示<span class=\"strong\">相对定位</span>，即相对于上一个命令终点的相对位移\n\n 命令包括以下：\n+ M = moveto，移动画笔\n+ L = lineto，绘制直线\n+ H = horizontal lineto，绘制水平直线，只需要x一个参数\n+ V = vertical lineto，绘制垂直直线，只需要y一个参数\n+ C = curveto，绘制三次贝塞尔曲线\n+ S = smooth curveto，可衔接的三次贝塞尔曲线\n+ Q = quadratic Belzier curve，绘制二次贝塞尔曲线\n+ T = smooth quadratic Belzier curveto，绘制可衔接的二次贝塞尔曲线\n+ A = elliptical Arc，绘制弧线\n+ Z = closepath，闭合路径，一般用于路径最后\n\n#### 二阶贝塞尔曲线\n通过给定一个控制点坐标和曲线终点坐标绘制贝塞尔曲线\n<span class=\"strong\">Q x1 y1, x y</span>\n\n+ 只需要一个控制点(x1,y1)\n+ (x,y)为终点坐标\n\n##### 延长的平滑二阶贝塞尔曲线\n可以将多个贝塞尔曲线衔接起来，形成一条更长的曲线\n<span class=\"strong\">T x y</span>\n\n+ 只需要指定曲线终点坐标(x,y)\n+ 如果该命令前为另一个Q命令或T命令，该命令会把上一个命令控制点关于曲线终点的中心对称点作为其控制点\n+ 如果该命令单独使用，则会认为控制点和终点为同一点，绘制一条直线\n<div class=\"show\">&lt;path d=\"M 10 80 Q 50 200 100 100 T 200 120\"/></div>\n<svg width=\"220\" height=\"200\" style=\"display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;\"> <circle cx=\"10\" cy=\"80\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"50\" cy=\"196\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"100\" cy=\"100\" r=\"4\" style=\"fill:#f00;\"/><polyline points=\"10 80, 50 196,100 100\" style=\"stroke:f00;\" /><circle cx=\"150\" cy=\"4\" r=\"4\" style=\"fill:#00f;\"/><circle cx=\"200\" cy=\"120\" r=\"4\" style=\"fill:#00f;\"/><polyline points=\"100 100, 150 4,200 120\" style=\"stroke:#00f;\" /><path d=\"M 10 80 Q 50 200 100 100 T 200 120\"/>\n</svg>\n\n#### 三阶贝塞尔曲线\n通过指定两个控制点，一个终点坐标绘制曲线\n<span class=\"strong\">C x1 y1, x2 y2, x y</span>\n\n+ (x1,y1)(x2,y2)为控制点坐标\n+ (x,y)为曲线终点坐标\n+ c小写时(x,y)应当为上一个路径终点的相对坐标(dx,dy)\n<div class=\"show\">&lt;path d=\"M 10 10 C 0 200, 150 20, 300 300 \"/></div>\n\n\n同理，可以将多个三阶贝塞尔曲线衔接起来，形成一条更长的曲线\n<span class=\"strong\">S x2 y2, x y</span>\n\n+ (x2,y2)为控制点坐标\n+ (x,y)为终点坐标\n+ 如果该命令跟在一个 C 或 S 命令后面，则该曲线的第一个控制点会被设置为前一个曲线第二个控制点关于曲线终点的中心对称点(以此保持斜率不变来保证曲线可以平滑衔接)\n<div class=\"show\">&lt;path d=\"M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 \"/></div>\n<svg width=\"400\" height=\"200\" style=\"display:block;margin:0 auto;background-color:#fff;fill:none;stroke:#000;\"><circle cx=\"10\" cy=\"10\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"10\" cy=\"150\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"150\" cy=\"20\" r=\"4\" style=\"fill:#f00;\"/><circle cx=\"200\" cy=\"50\" r=\"4\" style=\"fill:#f00;\"/><line x1=\"10\" y1=\"10\" x2=\"10\" y2=\"150\" style=\"stroke:#f00;\" /><line x1=\"150\" y1=\"20\" x2=\"200\" y2=\"50\" style=\"stroke:#f00;\" /><circle cx=\"250\" cy=\"80\" r=\"4\" style=\"fill:#00f;\"/><circle cx=\"160\" cy=\"150\" r=\"4\" style=\"fill:#00f;\"/><circle cx=\"396\" cy=\"100\" r=\"4\" style=\"fill:#00f;\"/><line x1=\"200\" y1=\"50\" x2=\"250\" y2=\"80\" style=\"stroke:#00f;\" /><line x1=\"160\" y1=\"150\" x2=\"396\" y2=\"100\" style=\"stroke:#00f;\" /><path d=\"M 10 10 C 10 150, 150 20, 200 50 S 160 150, 400 100 \"/></svg>\n\n### 颜色与样式\n#### 描边\n默认情况下，创建路径后不会进行描边，需要使用<span class=\"stroke\">stroke</span>属性指定描边颜色\n\n+ <span class=\"strong\">stroke=\"颜色\" 指定描边颜色，取值同CSS</span>\n+ <span class=\"strong\">stroke-opacity=\"值\" 单独指定不透明度</span>\n+ <span class=\"strong\">stroke-width=\"值\" 指定描边线宽度</span>\n\n#### 描边终点与折点样式\n+ <span class=\"strong\">stroke-linecap=\"butt/round/square\"  描边终点为正常(平头截断)/圆形线帽/矩形线帽</span>\n+ <span class=\"strong\">stroke-linejoin=\"miter/round/bevel\" 描边折点为尖角/圆角/切角</span>\n+ <span class=\"strong\">stroke-miterlimit=\"值\" 设置折点斜切面的限制长度</span>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n具体样式区别可以参考这篇博文：<a href=\"http://localhost:4000/blog/2023/05/03/canvas/#%E7%BA%BF%E6%AE%B5%E6%8A%98%E7%82%B9\" target=\"_blank\">canvas绘制线段-实线部分</a></div>\n\n#### 填充\n默认情况下，闭合图形或路径的填充色为黑色，可以通过<span class=\"tips\">fill</span>属性修改\n\n+ <span class=\"strong\">fill=\"颜色\" 指定填充颜色，取值同CSS</span>\n+ <span class=\"strong\">fill-opacity=\"值\" 单独指定填充不透明度</span>\n\n#### 虚线\n+ <span class=\"strong\">stroke-dasharray=\"值,值...\" 设置虚线线段和间隙的长度</span>\n+ <span class=\"strong\">stroke-dashoffset=\"值\" 设置虚线偏移值</span>\n\n#### 使用CSS定义样式\nsvg的属性除了能在标签属性中定义外，也能在CSS中直接声明，但仅适用于部分属性\n+ stroke\n+ fill\n\n### 特殊标签\n#### defs标签\ndefs标签用于定义需要重复使用的图形元素，该标签中定义的图形元素不会直接呈现，只供后续调用\n\n#### g标签\n容器标签，用于包含一组标签，然后将该组标签的共同样式属性添加到g标签上，这样该属性值会对所有子标签继承。注意：g标签不支持使用x,y属性来进行定位，需要修改位置时，可以使用transform属性或CSS修改\n\n### 渐变\n#### 线性渐变\n在<span class=\"tips\">&lt;defs></span>标签内创建一个<span class=\"tips\">&lt;linearGradient></span>标签，在该标签内定义线性渐变，并通过<span class=\"tips\">&lt;stop/></span>标签的属性定义颜色、渐变位置、不透明度，然后在需要调用的图形中，用<span class=\"tips\">fill</span>属性或<span class=\"tips\">stroke</span>属性调用<span class=\"tips\">url</span>引用<span class=\"tips\">&lt;linearGradient></span>标签的<span class=\"tips\">ID</span>值(调用类名无效)\n\n\n<span class=\"strong\">&lt;linearGradient x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\">&lt;/linearGradient></span>\n\n+ x1,x2,y1,y2通过确定两个点来定义渐变路径走向，一般取值0-1间的小数，取大于1的值将导致渐变超出图形范围(溢出的渐变部分不可见)\n+ 默认从左往右，即x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\"\n+ x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\"即调整为从上到下\n\n<span class=\"strong\">&lt;stop offset=\"50%\" stop-color=\"#00f\" /></span>\n+ offset属性定义颜色渐变(偏移)位置，可以取0%-100%，也可以取0-1间的小数\n+ stop-color定义颜色，取值同CSS\n+ stop-opacity定义不透明度\n\n<div class=\"show\">&lt;defs>\n     &lt;linearGradient id=\"G1\">\n          &lt;stop offset=\"0%\" stop-color=\"red\"/>\n          &lt;stop offset=\"50%\" stop-color=\"yellow\"/>\n          &lt;stop offset=\"100%\" stop-color=\"blue\"/>\n     &lt;/linearGradient>\n&lt;/defs>\n&lt;rect x=\"0\" y=\"0\" rx=\"10\" ry=\"10\" width=\"300\" height=\"300\" fill=\"url(#G1)\"/></div>\n\n#### 径向渐变\n与线性渐变类似，径向渐变需要在<span class=\"tips\">&lt;defs></span>标签内创建一个<span class=\"tips\">&lt;radialGradient></span>标签，然后通过<span class=\"tips\">&lt;stop/></span>标签的属性定义颜色、渐变位置、不透明度\n\n<span class=\"strong\">&lt;radialGradient cx=\".5\" cy=\".5\" r=\".5\" fx=\".2\" fy=\".2\">&lt;radialGradient></span>\n\n+ cx,cy定义渐变结束所围绕的圆环，取值0-1\n+ r定义渐变圆在当前图形中的占用半径，一般取值0-1，大于1将导致渐变溢出图形\n+ fx,fy定义渐变开始的位置\n\n<div class=\"show\">&lt;defs>\n     &lt;radialGradient cx=\".5\" cy=\".5\" r=\".5\" fx=\".2\" fy=\".2\"  id=\"R1\">\n          &lt;stop offset=\"0%\" stop-color=\"red\"/>\n          &lt;stop offset=\"25%\" stop-color=\"yellow\"/>\n          &lt;stop offset=\"50%\" stop-color=\"blue\"/>\n          &lt;stop offset=\"75%\" stop-color=\"green\"/>\n          &lt;stop offset=\"100%\" stop-color=\"purple\"/>\n     &lt;/radialGradient>\n&lt;/defs>\n&lt;rect class=\"fillRect\" x=\"0\" y=\"0\"  width=\"200\" height=\"200\" fill=\"url(#R1)\"/>\n1. 渐变开始位置为矩形图20%,20%位置\n2. 渐变结束所形成的圆环：圆心位于矩形50%,50%点处，半径为矩形长的50%\n</div>\n\n<svg width=\"200\" height=\"200\" xmlns=\"radialGradientSVG\" style=\"display:block;margin:0 auto;\">\n<defs>\n<radialGradient cx=\".5\" cy=\".5\" r=\".5\" fx=\".2\" fy=\".2\"  id=\"R1\"><stop offset=\"0%\" stop-color=\"red\"/>\n<stop offset=\"25%\" stop-color=\"yellow\"/>\n<stop offset=\"50%\" stop-color=\"blue\"/>\n<stop offset=\"75%\" stop-color=\"green\"/>\n<stop offset=\"100%\" stop-color=\"purple\"/>\n</radialGradient>\n</defs>\n<rect class=\"fillRect\" x=\"0\" y=\"0\"  width=\"200\" height=\"200\" fill=\"url(#R1)\"/>\n</svg>\n\n#### spreadMethod属性\nspreadMethod属性用于指定渐变到达终点的行为，默认情况下，offset为100%时的颜色会填充剩余部分，该属性对线性渐变和径向渐变均生效\n+ pad(默认)，渐变结束后使用终点颜色填充剩下区域\n+ reflect，渐变结束后按反向颜色顺序填充剩下区域\n+ repeat，渐变结束后从头开始填充剩下区域\n\n<div class=\"show\">&lt;linearGradient  id=\"g2\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"pad\">//\n            &lt;stop offset=\"0%\" stop-color=\"red\"/>\n            &lt;stop offset=\"33%\" stop-color=\"yellow\"/>\n            &lt;stop offset=\"66%\" stop-color=\"blue\"/>\n            &lt;stop offset=\"100%\" stop-color=\"green\"/>\n&lt;/linearGradient>\n1. x2=\".5\"指定了颜色渐变填充到矩形的50%位置\n2. pad值会用终点颜色填充剩下区域\n3. reflect值会按绿，蓝，黄，红顺序(与原顺序相反)填充剩下区域\n3. repeat值会按颜色顺序(从头开始)填充剩下区域\n</div>\n<svg style=\"display:block;margin:0 auto;\" width=\"340\" height=\"200\" xmlns=\"spreadMethodSVG\"><defs>\n<linearGradient  id=\"g2\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"pad\">\n            <stop offset=\"0%\" stop-color=\"red\"/>\n            <stop offset=\"33%\" stop-color=\"yellow\"/>\n            <stop offset=\"66%\" stop-color=\"blue\"/>\n            <stop offset=\"100%\" stop-color=\"green\"/>\n        </linearGradient>\n        <linearGradient  id=\"g3\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"reflect\">\n            <stop offset=\"0%\" stop-color=\"red\"/>\n            <stop offset=\"33%\" stop-color=\"yellow\"/>\n            <stop offset=\"66%\" stop-color=\"blue\"/>\n            <stop offset=\"100%\" stop-color=\"green\"/>\n        </linearGradient>\n        <linearGradient  id=\"g4\" x1=\"0\" x2=\".5\" y1=\"0\" y2=\"0\" spreadMethod=\"repeat\">\n            <stop offset=\"0%\" stop-color=\"red\"/>\n            <stop offset=\"33%\" stop-color=\"yellow\"/>\n            <stop offset=\"66%\" stop-color=\"blue\"/>\n            <stop offset=\"100%\" stop-color=\"green\"/>\n        </linearGradient>\n</defs>\n        <rect  x=\"0\" y=\"0\" width=\"100\" height=\"130\" fill=\"url(#g2)\"/>\n        <rect  x=\"110\" y=\"0\" width=\"100\" height=\"130\" fill=\"url(#g3)\"/>\n        <rect  x=\"220\" y=\"0\" width=\"100\" height=\"130\" fill=\"url(#g4)\"/>\n</svg>\n\n### Pattern\n\n与canvas相同，svg也有一个模板对象，常用于定义需要重复填充的背景图等。与渐变一样，&lt;pattern> 也需要定义在的 &lt;defs> 内部，然后使用其他图形引用Patterns的ID\n<span class=\"strong\">&lt;pattern x=\"0\" y=\"0\" width=\".25\" height=\".25\">&lt;/pattern></span>\n+ x,y定义Pattern图形的开始位置\n+ width,height决定该Pattern图形会在x轴和y轴上重复几次，0.25意味着将在横轴和纵轴方向上均重复4次\n\n<div class=\"show\">&lt;svg width=\"200\" height=\"200\">\n        &lt;defs>\n&lt;pattern id=\"Pattern\" x=\"0\" y=\"0\" width=\".25\" height=\".25\">\n&lt;rect x=\"0\" y=\"0\" width=\"50\" height=\"50\" fill=\"skyblue\"/>\n&lt;circle cx=\"25\" cy=\"25\" r=\"20\" fill=\"yellow\" fill-opacity=\"0.5\"/>\n    &lt;/pattern>\n        &lt;/defs>\n&lt;rect fill=\"url(#Pattern)\" stroke=\"black\" x=\"0\" y=\"0\" width=\"200\" height=\"200\"/>\n    &lt;/svg>\n</div>\n\n<svg width=\"200\" height=\"200\" xmlns=\"pattern\" style=\"display:block;margin:0 auto;\"><defs><pattern id=\"pattern\" x=\"0\" y=\"0\" width=\".25\" height=\".25\"><rect x=\"0\" y=\"0\" width=\"50\" height=\"50\" fill=\"skyblue\" stroke=\"#000\"/><circle cx=\"25\" cy=\"25\" r=\"20\" fill=\"yellow\" fill-opacity=\"0.5\"/></pattern></defs><rect fill=\"url(#pattern)\" x=\"0\" y=\"0\" width=\"200\" height=\"200\"/>\n</svg>\n\n### 文本\n#### text标签\n\n<span class=\"strong\">&lt;text x=\"0\" y=\"0\">&lt;/text></span>\n+ x,y定义文字左下角在SVG中的开始位置(y值)\n+ 通过fill属性和stroke属性指定文字填充/描边颜色\n+ text-anchor属性决定文本开始方向，可取值：start、middle、end、inherit(该属性一般用于阿拉伯语等从右到左阅读的语言)\n+ 以下属性定义文字大小、字间距等，可以直接定义在标签中，也可以定义在CSS中，取值和CSS大致相同：<span class=\"tips\">font-family</span>、<span class=\"tips\">font-style</span>、<span class=\"tips\">font-weight</span>、<span class=\"tips\">font-size</span>、<span class=\"tips\">letter-spacing</span>、<span class=\"tips\">word-spacing</span>、<span class=\"tips\">text-decoration</span>、<span class=\"tips\">font-variant</span>、<span class=\"tips\">font-size-adjust</span>等，注意，文字的填充和描边需要使用<span class=\"tip\">fill</span>和<span class=\"tips\">stroke</span>属性指定颜色\n\n<div class=\"show\">&lt;style>\n #svgText{\n            text-anchor:start;\n            fill: red;\n            font-size: 20px;\n            font-weight: 900;\n        }\n&lt;/style>\n&lt;svg width=\"600\" height=\"600\"  xmlns=\"http://www.w3.org/2000/svg\">\n&lt;text id=\"svgText\" x=\"10\" y=\"30\">手写的从前&lt;/text>\n&lt;/svg></div>\n\n#### tspan标签\ntspan标签常用于标记出一段文本中的特殊部分，如将某句话的关键词加粗标识，该标签必须包含于<span class=\"tips\">text</span>标签或<span class=\"tips\">tspan</span>标签中\n<span class=\"strong\">&lt;tspan>文本内容&lt;/tspan></span>\n+ 该标签需要置于父级text标签或tspan标签内，且文本在svg的位置跟随父级标签\n+ x,y属性可以为该标签设置一个新的位置坐标，该坐标是相对于svg的坐标原点，无视父级坐标\n+ dx,dy属性可以在父级坐标的基础上，进行偏移\n+ rotate属性可以将文字 进行旋转\n+ 上述属性都允许赋值一个数列，表示为tspan标签中的每个字符设置单独的坐标/旋转值\n\n<div class=\"show\">1. x和y属性是相对于SVG的坐标，可能导致tspan标签内容覆盖到父级文本之上\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan x=\"20\" fill=\"red\">x属性&lt;/tspan>父级标签&lt;/text>\n2. dx,dy属性是在父级坐标基础上进行位移\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan dx=\"20\" fill=\"red\">dx属性&lt;/tspan>父级标签&lt;/text>\n3. x,y,dx,dy的属性值可以为一组数列值，依次指定标签中每个字符的坐标\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan dx=\"20,25,30,35\" fill=\"red\">dx属性赋值数列&lt;/tspan>父级标签&lt;/text>\n4. rotate属性值也可以是单个，或者为一组数列，对字符进行旋转\n&lt;text y=\"20\" fill=\"#fff\">父级标签&lt;tspan rotate=\"20,30,40,50,60,70,80\" fill=\"red\">dx属性赋值数列&lt;/tspan>父级标签&lt;/text>\n</div>\n\n<svg width=\"400\" height=\"180\" xmlns=\"tspan\" style=\"display:block;margin:0 auto;font-size:18px;\"><rect x=\"0\" y=\"0\" width=\"400\" height=\"400\" fill=\"skyblue\" /><text x=\"0\" y=\"20\" fill=\"#fff\">1.父级标签<tspan x=\"20\" fill=\"red\">x属性</tspan>父级标签</text><text x=\"0\" y=\"60\" fill=\"#fff\">2.父级标签<tspan  dx=\"20\" fill=\"red\">dx属性</tspan>父级标签</text><text x=\"0\" y=\"100\" fill=\"#fff\">3.父级标签<tspan  dx=\"20,25,30,35,40\" fill=\"red\">dx属性赋值数列</tspan>父级标签</text><text x=\"0\" y=\"140\" fill=\"#fff\">4.父级标签<tspan  rotate=\"20,30,40,50,60,70,80\" fill=\"red\">rotate属性赋值数列</tspan>父级标签</text>\n</svg>\n\n#### textPath标签\ntextPath可创建出跟随路径排列的文本，需要通过<span class=\"tips\">xlink:href</span>属性引用路径ID\n\n<div class=\"show\">&lt;path d=\"M 10 80 Q 50 200 100 100 T 200 120\" id=\"my_path\" fill=\"none\" stroke=\"red\"/>\n&lt;text fill=\"skyblue\" font-size=\"20\">\n&lt;textPath  xlink:href=\"#my_path\">So live a life you will remember&lt;/textPath>\n&lt;/text></div>\n\n<svg width=\"300\" height=\"150\" xmlns=\"textPath\" style=\"display:block;margin:0 auto;\"><path d=\"M 10 80 Q 50 200 100 100 T 200 120\" id=\"my_path\" fill=\"none\" stroke=\"red\"/><text fill=\"skyblue\" font-size=\"20\"> <textPath  xlink:href=\"#my_path\">So live a life you will remember</textPath>\n</svg>\n\n### 变形、剪切、遮罩、图片\n#### 变形\n+ <span class=\"strong\">transform=\"translate(x,y)\" 平移</span>(如果只指定一个值，则默认第二个值为0)\n+ <span class=\"strong\">transform=\"rotate(角度值)\" 沿着图形左上角顺时针(正值)旋转</span>\n+ <span class=\"strong\">transform=\"skewX(角度值)或skewY(角度值)\" 在x/y轴方向上斜切</span>\n+ <span class=\"strong\">transform=\"scale(x缩放,y缩放)\" 在x/y轴进行缩放</span>(如果只指定一个值，则默认第二个值等于第一个值)\n+ 多个属性值可以写到一个transform中，用空格隔开\n\n<div class=\"show\"> &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"red\" transform=\"translate(50,10) scale(.2,1.2) rotate(60)\"/></div>\n\n#### clipPath剪切\n定义一个<span class=\"tips\">clipPath</span>标签并指定路径或图形，然后在需要裁剪的目标元素上使用<span class=\"tips\">clip-path</span>属性调用<span class=\"tips\">clipPath</span>标签的ID值进行裁剪，剪裁会保留二者相同部分，对其余部分进行裁剪。该标签一般定义于<span class=\"tips\">defs</span>标签中\n\n<div class=\"show\">&lt;defs>\n        &lt;clipPath id=\"cut\">\n            &lt;rect x=\"200\" y=\"200\" width=\"200\" height=\"100\"/>\n        &lt;/clipPath>\n    &lt;/defs>\n &lt;circle cx=\"300\" cy=\"300\" r=\"100\" fill=\"yellow\" clip-path=\"url(#cut)\"/></div>\n\n #### mask遮罩\n 遮罩常用于制作淡出淡入效果，<span class=\"tips\">mask</span>标签定义于defs标签中，然后在需要添加遮罩的标签中使用<span class=\"tips\">mask</span>属性引用遮罩ID\n\n <div class=\"show\">&lt;defs>\n    &lt;linearGradient id=\"Gradient\">\n      &lt;stop offset=\"0\" stop-color=\"white\" stop-opacity=\"0\"/>\n      &lt;stop offset=\"1\" stop-color=\"white\" stop-opacity=\"1\"/>\n    &lt;/linearGradient>\n    &lt;mask id=\"Mask\">\n      &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"url(#Gradient)\"/>\n    &lt;/mask>\n&lt;/defs>\n\n  &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"green\"/>\n  &lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"red\" mask=\"url(#Mask)\" /></div>\n\n#### 图片\nSVG使用<span class=\"tips\">image</span>标签插入图片，并且可以在图像上使用剪切、变形、遮罩等SVG提供的功能\n<span class=\"strong\">&lt;image xlink:href=\"\"/></span>\n+ 可以使用x,y属性指定图片位置\n+ 可以使用width,height属性指定图片宽高\n+ xlink:href属性用于指定图片地址\n<div class=\"show\">&lt;image x=\"50\" y=\"50\" width=\"300\" height=\"300\"  xlink:href=\"../dog.jpg\"/></div>\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nSVG中还有链接、动画、滤镜等标签，详见MDN文档:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element\">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element</a></div>","tags":["Web","html"]},{"title":"Canvas","url":"/blog/2023/05/03/canvas/","content":"\n### 引入\n#### 关于\n<span class=\"tips\">canvas</span>是HTML5新增的标签，用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面，canvas不支持IE8及IE8以下浏览器\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n具体的兼容性可以参考MDN文档：\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas\n\">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas</a></div>\n\n\n#### 创建画布\n##### 通过HTML标签\n可以通过直接添加HTML标签的方式创建canvas，并设置画布的宽高，然后通过<span class=\"tips\">getContext()</span>方法获得画布的 2D 渲染上下文对象，需要为该方法提供<span class=\"tips\">'2d'</span>作为参数，该对象提供了用于在画布上绘图的方法和属性\n<pre><code>&lt;body>\n    &lt;canvas width=\"600\" height=\"400\" id=\"canvas\">&lt/canvas>\n    &ltscript>\n        const canvas=document.getElementById('canvas');\n        const context = canvas.getContext('2d');\n    &lt;/script>\n&lt;/body>\n</code></pre>\n\n##### 通过JavaScript动态创建\n也可以通过JavaScript动态添加canvas并指定宽高，tips:通过JavaScript创建的canvas在写代码时IDE会有代码补全提示\n\n<pre><code> const canvas=document.createElement(\"canvas\");\n    canvas.width=600;\n    canvas.height=400;\n    document.body.appendChild(canvas);\n const context = canvas.getContext('2d');</code></pre>\n\n##### 画布尺寸的说明\n\n+ canvas需要通过属性来设置宽度、高度，且不需要单位\n+ 通过CSS设置canvas的width和height属性，仅用于缩放图像，无法改变画布尺寸，当CSS指定的宽高与画布的宽高比例不一致时，图像会出现扭曲\n+ 默认画布大小为300px * 150px，宽高比为2:1，如果不指定画布的宽高，或者设置了无效值(如负数)，则会使用默认值\n\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n通过CSS设置的Canvas宽高样式只会修改浏览器渲染后所显示图像的宽高，不会修改画布本身及其图像本身的宽高。浏览器会在渲染期间根据CSS对源图像进行伸缩，以适应指定的CSS样式大小。如果 CSS 的指定的宽高尺寸与画布的宽高比例不一致，图像有可能出现扭曲。而通过属性修改的画布宽度和高度，实际会修改Canvas DOM对象的属性值，即画布本身的宽度和高度，并将该DOM对象传递给canvas内部的2d渲染上下文环境对象(CanvasRenderingContext2D)\n</div>\n\n#### 兼容性检查\nIE9之前的浏览器不支持Canvas，如果不兼容canvas，canvas 标签会被浏览器解析为自定义标签，显示标签内的提示信息\n<div class=\"show\">&lt;canvas id=\"canvas\">抱歉，您的浏览器不支持 canvas 标签&lt;/canvas></div>\n    同时要做好JavaScript兼容性检查\n<div class=\"show\">const canvas = document.getElementById('canvas');\n        if (canvas.getContext){\n          const ctx = canvas.getContext('2d');\n        }</div>\n\n# Canvas 2D渲染API\n\n所有API都是基于canvas的2d渲染上下文对象，文中以context或ctx为对象名\n### 绘制\n#### 路径\n+ <span class=\"strong\">moveTo(x,y) 移动画笔到指定坐标</span>\n指定画笔最先开始绘制的点，此后Canvas的绘制方法都是基于上一次的路径终点进行的，仍可以使用moveTo(x,y)修改画笔的坐标到路径终点以外\n\n+ <span class=\"strong\">context.beginPath() 创建一个新路径</span>\n\n在同一个画布中绘制多个独立的图像，应当为每个图像创建不同的子路径，如:为不同的线段设置不同的颜色、线宽等样式，应当为每个线段创建独立的子路径，每个路径内部的样式、属性单独声明，否则后声明的样式会覆盖前面的样式，并且应当为每个独立的路径指定画笔初始点，执行绘制方法\n<div class=\"show\">const canvasPath=document.getElementById(\"canvasPath\");\n   const ctxPath = canvasPath.getContext('2d');\n        ctxPath.lineWidth=5;\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"red\";\n        ctxPath.moveTo(150,50);\n        ctxPath.lineTo(50,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"blue\";\n        ctxPath.moveTo(50,200);\n        ctxPath.lineTo(250,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"yellow\";\n        ctxPath.moveTo(250,200);\n        ctxPath.lineTo(150,50);\n        ctxPath.stroke();\n</div>\n<canvas width=\"300\" height=\"300\" id=\"canvasPath\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasPath=document.getElementById(\"canvasPath\");\n   const ctxPath = canvasPath.getContext('2d');\n        ctxPath.lineWidth=5;\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"red\";\n        ctxPath.moveTo(150,50);\n        ctxPath.lineTo(50,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"blue\";\n        ctxPath.moveTo(50,200);\n        ctxPath.lineTo(250,200);\n        ctxPath.stroke();\n        ctxPath.beginPath();\n        ctxPath.strokeStyle=\"yellow\";\n        ctxPath.moveTo(250,200);\n        ctxPath.lineTo(150,50);\n        ctxPath.stroke();\n</script>\n\n\n\n在使用循环定时器创建动画时，往往需要在每次定时器执行时创建一个新路径，避免上次的路径影响到本次路径的绘制\n<div class=\"show\">const canvas=document.createElement(\"canvas\");\n        canvas.width=300;\n        canvas.height=300;\n        document.body.appendChild(canvas);\n        const ctx = canvas.getContext('2d');\n        let cpx=10;\n        let timer=setInterval(()=>{\n        ctx.beginPath();//每次计时器开始时，开始新路径\n        ctx.clearRect(0,0,300,300);//清空画布\n        ctx.moveTo(50,50);\n        ctx.quadraticCurveTo(cpx+=10,100,50,250);//动态绘制贝塞尔曲线\n        ctx.stroke();\n        if(cpx>=250){\n            clearInterval(timer)\n        }\n        },50)</div>\n\n\n+ <span class=\"strong\">context.closePath(); 闭合当前子路径</span>\n将画笔坐标移回到当前子路径起始点，该方法会尝试从当前点到起始点绘制一条直线，如果图形已经是封闭的或者只有一个点，该方法不会做任何操作，可用于闭合图形\n\n<div class=\"show\">const canvasLine=document.getElementById(\"canvasLine\");\n        const ctxLine = canvasLine.getContext('2d');\n        ctxLine.lineWidth=3;\n        ctxLine.moveTo(150,50);\n        ctxLine.lineTo(100,150);\n        ctxLine.lineTo(200,150);\n        ctxLine.closePath();\n        ctxLine.stroke();</div>\n\n#### 描边\n\n+ <span class=\"strong\">context.stroke() 绘制当前路径</span>\n+ <span class=\"strong\">context.lineWidth=值; 修改描边线条的宽度</span>\n+ <span class=\"strong\">context.strokeStyle=\"颜色/渐变对象/Pattern对象\"; 设置描边样式</span>\n\n#### 填充\n+ <span class=\"strong\">context.fill() 填充已闭合的路径</span>\n+ <span class=\"strong\">context.fillStyle=\"颜色/渐变对象/Pattern对象\"; 设置填充的样式</span>\n\n#### 裁剪\n<span class=\"strong\">context.clip() 根据当前路径进行裁剪</span>\n沿着路径进行裁剪，裁剪路径外的图形将不再显示在Canvas中\n\n#### 清除\n<span class=\"strong\">context.clearRect(x,y,width,height) 清除指定区域内的画布内容</span>\n<div class=\"show\">context.clearRect(0,0,canvas.width,canvas.height)//清空整个画布</div>\n\n#### 封装路径-Path2D对象\n <span class=\"strong\">let myPath2D=new Path2D();</span>\n返回一个Path2D对象，之后可以将路径添加到该对象中，并直接重用对象中的所有路径，stroke()、fill()、clip()均接收该对象作为参数\n<div class=\"show\">const canvas=document.getElementById(\"canvas\");\n        const context = canvas.getContext('2d');\n        let myDesign=new Path2D();\n        //将路径封装到Path2D对象中而非context对象上\n        myDesign.moveTo(50,50);\n        myDesign.lineTo(100,50);\n        myDesign.lineTo(100,100);\n        myDesign.lineTo(50,100);\n        myDesign.lineTo(50,50);\n        //之后可以直接重用封装好的路径\n        context.stroke(myDesign);//描边\n        context.fill(myDesign);//填充\n        context.clip(myDesign);//裁剪\n</div>\n\n#### 位置判断\n+ <span class=\"strong\">context.isPointInStroke(x, y) 返回boolean值，判断(x,y)点是否在当前路径上</span>\n+ <span class=\"strong\">context.isPointInStroke(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径上</span>\n+ <span class=\"strong\">context.isPointInPath(x, y) 返回boolean值，判断(x,y)点是否在当前路径内</span>\n+ <span class=\"strong\">context.isPointInPath(path2D对象, x, y) 返回boolean值，判断(x,y)点是否在封装的path2D路径内</span>\n\n\n\n\n\n### 线段\n#### 实线线段\n##### 线段路径\n<span class=\"strong\">context.lineTo(x,y) 连接直线路径到指定坐标</span>\n\n##### 线段折点\n<span class=\"strong\">context.lineJoin=\"miter/round/bevel\"; </span>\n\n设置或返回两条线交汇时，线段折线处的样式\n+ <strong>miter</strong> 尖锐折线(默认)\n+ <strong>round</strong> 圆角折线\n+ <strong>bevel</strong> 切角折线\n\n<span class=\"strong\">ctx.miterLimit = value; </span>\n设置或返回边角斜切面的限制长度(默认为10)，下图为miterLimit=2(左)以及miterLimit=10(右)的区别\n<canvas width=\"300\" height=\"150\" id=\"canvasLimit\" style=\"display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasLimit=document.getElementById(\"canvasLimit\");\n        const ctxLimit = canvasLimit.getContext('2d');\n        ctxLimit.lineWidth=20;\n        ctxLimit.lineJoin=\"miter\";\n        ctxLimit.beginPath();\n        ctxLimit.miterLimit=2;\n        ctxLimit.moveTo(40,20);\n        ctxLimit.lineTo(70,100);\n        ctxLimit.lineTo(100,20);\n        ctxLimit.stroke();\n        ctxLimit.beginPath();\n        ctxLimit.miterLimit=10;\n        ctxLimit.moveTo(190,20);\n        ctxLimit.lineTo(220,100);\n        ctxLimit.lineTo(250,20);\n        ctxLimit.stroke();\n       \n</script>\n\n##### 线段末端\n<span class=\"strong\">context.lineCap=\"butt/round/square;\"</span>\n\n设置或返回线段末端线帽的样式，\"round\" 和 \"square\" 值会使线条略微变长\n+ <strong>butt</strong> 末端以方形结束(默认)\n+ <strong>round</strong>末端添加圆形线帽\n+ <strong>square</strong>末端添加一个宽度相同，长度为宽度一半的矩形线帽\n\n\n\n<canvas width=\"400\" height=\"150\" id=\"canvasLine\" style=\"display:block;width:300px;height:150px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasLine=document.getElementById(\"canvasLine\");\n        const ctxLine = canvasLine.getContext('2d');\n        ctxLine.lineWidth=10;\n        ctxLine.beginPath();\n        ctxLine.lineCap=\"butt\";\n        ctxLine.lineJoin=\"miter\";\n        ctxLine.moveTo(90,50);\n        ctxLine.lineTo(150,50);\n        ctxLine.lineTo(190,10);\n        ctxLine.lineTo(230,50);\n        ctxLine.lineTo(290,50);\n        ctxLine.stroke();\n        ctxLine.beginPath();\n        ctxLine.lineCap=\"round\";\n        ctxLine.lineJoin=\"round\";\n        ctxLine.moveTo(90,100);\n        ctxLine.lineTo(150,100);\n        ctxLine.lineTo(190,60);\n        ctxLine.lineTo(230,100);\n        ctxLine.lineTo(290,100);\n        ctxLine.stroke();\n        ctxLine.beginPath();\n        ctxLine.lineCap=\"square\";\n        ctxLine.lineJoin=\"bevel\";\n        ctxLine.moveTo(90,140);\n        ctxLine.lineTo(150,140);\n        ctxLine.lineTo(190,100);\n        ctxLine.lineTo(230,140);\n        ctxLine.lineTo(290,140);\n        ctxLine.stroke();\n        ctxLine.beginPath();\n        ctxLine.setLineDash([5,10]);\n        ctxLine.lineWidth=1;\n        ctxLine.strokeStyle=\"red\";\n        ctxLine.moveTo(90,0)\n        ctxLine.lineTo(90,200)\n        ctxLine.moveTo(290,0)\n        ctxLine.lineTo(290,200)\n        ctxLine.stroke();\n</script>\n\n#### 虚线线段\n+ <span class=\"strong\">context.setLineDash([数组]);</span> 传递一个数组来指定虚线线段和间隙的交替长度，空数组将设置为实线\n+ <span class=\"strong\">context.getLineDash();</span> 返回一个数组，获取当前线段的样式\n\n<div class=\"show\">context.setLineDash([2,10,5,10])\ncontext.moveTo(0,0)\ncontext.lineTo(100,200);\ncontext.stroke();\n</div>\n\n<span class=\"strong\">context.lineDashOffset = value;</span>\n设置虚线偏移值，可实现蚂蚁线效果\n<div class=\"show\">const canvasDash=document.getElementById(\"canvasDash\");\n   const ctxDash = canvasDash.getContext('2d');\n   let offset=0;\n   ctxDash.lineWidth=5;\n   ctxDash.setLineDash([30,20])\n   ctxDash.setLineDash([30,20])\n   ctxDash.moveTo(0,100)\n   ctxDash.lineTo(300,100);\n   function render(){\n       offset++;\n    if(offset>50){\n        offset=0\n    }\n    ctxDash.clearRect(0,0,300,300)\n    ctxDash.lineDashOffset=offset;\n    ctxDash.stroke();\n    requestAnimationFrame(render)\n    }\n    render();</div>\n<canvas width=\"300\" height=\"300\" id=\"canvasDash\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n  const canvasDash=document.getElementById(\"canvasDash\");\n   const ctxDash = canvasDash.getContext('2d');\n   let offset=0;\n   ctxDash.lineWidth=5;\n   ctxDash.setLineDash([30,20])\n   ctxDash.setLineDash([30,20])\n   ctxDash.moveTo(0,100)\n   ctxDash.lineTo(300,100);\n   function render(){\n       offset++;\n    if(offset>50){\n        offset=0\n    }\n    ctxDash.clearRect(0,0,300,300)\n    ctxDash.lineDashOffset=offset;\n    ctxDash.stroke();\n    requestAnimationFrame(render)\n    }\n    render();\n</script>\n\n### 矩形\n##### 矩形路径\n<span class=\"strong\">context.rect(x,y,width,height) 创建矩形路径</span>\n+ x, y为矩形坐标\n+ width为矩形的宽度，正值矩形位于x坐标右侧，负值则位于左侧\n+ height为矩形的高度，正值矩形位于y坐标下方，负值则在上方\n\n仅创建矩形路径，不会显示在画布中，可以使用stroke()方法或fill()方法进行描边绘制或者填充绘制\n\n##### 描边矩形\n<span class=\"strong\">context.strokeRect(x, y, width, height) 绘制描边矩形</span>\n\n创建矩形路径并描边，参数同上，相当于rect()方法和stroke()方法同时执行，可以使用<span class=\"tips\">lineWidth</span>修改线宽，使用<span class=\"tips\">strokeStyle</span>修改线条样式\n\n##### 填充矩形\n<span class=\"strong\">context.fillRect(x, y, width, height) 填充一个矩形</span>\n\n创建矩形路径并填充，参数同上，相当于rect()方法和fill()方法同时执行，可以使用<span class=\"tips\">fillStyle</span>修改填充样式\n\n\n### 渐变对象\n#### 添加渐变色\n<span class=\"strong\">渐变对象名.addColorStop(偏移量,\"颜色\")</span>\n+ 对象名为以下三种渐变对象创建的实例\n+ 偏移量为0~1之间的值，代表渐变开始到渐变终止的位置，等同于CSS中的百分比位置\n+ 颜色取值同CSS\n\n#### 线性渐变对象\n<span class=\"strong\">context.createLinearGradient(x1,y1,x2,y2)</span>\n在(x1,y1)到(x2,y2)矢量方向上创建径向渐变对象，并返回该对象\n\n<div class=\"show\">const ctx = canvas.getContext('2d');\nconst gradient=ctx.createLinearGradient(0,0,600,400);\n        gradient.addColorStop(0,\"red\");\n        gradient.addColorStop(.3,\"#df0\");\n        gradient.addColorStop(1,\"blue\");\n        ctx.strokeStyle=gradient;</div>\n\n#### 径向渐变对象\n<span class=\"strong\">context.createRadialGradient(x0, y0, r0, x1, y1, r1);</span>\n以(x0,y0)为圆心，r0为半径确定一圆，以(x1,y1)为圆心，r1为半径确定另一圆，\n\n根据参数确定两个圆的坐标，绘制放射性渐变的方法\n\n<div class=\"show\">const canvas1=document.getElementById(\"canvas1\");\n    const ctx1 = canvas1.getContext('2d');\n    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);\n    radial.addColorStop(0,\"red\");\n    radial.addColorStop(.25,\"yellow\");\n    radial.addColorStop(.5,\"green\");\n    radial.addColorStop(.75,\"#ff00fb\");\n    radial.addColorStop(1,\"blue\");\n    ctx1.fillStyle=radial;\n    ctx1.fillRect(0,0,300,300)</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvas1\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;\"></canvas>\n<script>\n    const canvas1=document.getElementById(\"canvas1\");\n    const ctx1 = canvas1.getContext('2d');\n    const radial=ctx1.createRadialGradient(50,50,50,250,250,100);\n    radial.addColorStop(0,\"red\");\n    radial.addColorStop(.25,\"yellow\");\n    radial.addColorStop(.5,\"green\");\n    radial.addColorStop(.75,\"#ff00fb\");\n    radial.addColorStop(1,\"blue\");\n    ctx1.fillStyle=radial;\n    ctx1.fillRect(0,0,300,300)\n     ctx1.moveTo(0,0);\n    ctx1.lineTo(50,50);\n    ctx1.stroke();\n    ctx1.moveTo(250,250);\n    ctx1.lineTo(300,300);\n    ctx1.stroke();\n</script>\n\n#### 锥形渐变对象\n<span class=\"strong\">context.createConicGradient(弧度值,x,y)</span>\n以(x,y)为锥形中心创建锥形渐变对象，弧度值角度为渐变开始的位置，角度通过<span class=\"tips\">Math.PI*角度/180</span>运算为弧度值，值可正可负\n\n\n<div class=\"show\">const canvas=document.getElementById(\"canvas\");\n   const ctx = canvas.getContext('2d');\n    const cg=ctx.createConicGradient(Math.PI*45/180,150,150);\n    cg.addColorStop(0,\"red\");\n    cg.addColorStop(.25,\"yellow\");\n    cg.addColorStop(.5,\"green\");\n    cg.addColorStop(.75,\"#ff00fb\");\n    cg.addColorStop(1,\"blue\");\n    ctx.fillStyle=cg;\n    ctx.fillRect(0,0,300,300);</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasCG\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasCG=document.getElementById(\"canvasCG\");\n   const ctxCG = canvasCG.getContext('2d');\n   try{\n     const cg=ctxCG.createConicGradient(Math.PI*45/180,150,150);\n      cg.addColorStop(0,\"red\");\n    cg.addColorStop(.25,\"yellow\");\n    cg.addColorStop(.5,\"green\");\n    cg.addColorStop(.75,\"#ff00fb\");\n    cg.addColorStop(1,\"blue\");\n    ctxCG.fillStyle=cg;\n    ctxCG.fillRect(0,0,300,300);\n   }\n   catch(error){\n    ctxCG.font=\" 800 58px Serif\"\n    ctxCG.fillText(\"浏览器不支\", 0, 100);\n    ctxCG.fillText(\"持锥形渐变\", 0, 150);\n    console.warn(\"浏览器不支持锥形渐变createConicGradient()方法\")}\n   \n</script>\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n锥形渐变兼容性远比线性渐变、径向渐变差，对浏览器内核版本要求较高，详见MDN文档：\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient\" style=\"display:block;word-break: break-all;\">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createConicGradient</a></div>\n\n\n### Pattern对象\n创建模板对象，\n\n<span class=\"strong\">createPattern(image,重复模式)</span>\nimage为图像源，可以是<span class=\"tips\">&lt;img>图像</span>、<span class=\"tips\">&lt;video>视频</span>、<span class=\"tips\">&lt;canvas>另外一个canvas对象</span>、<span class=\"tips\">canvas的2d上下文对象(CanvasRenderingContext2D)</span>等\n\n\n图像的重复模式可以为<span class=\"tips\">repeat</span>、<span class=\"tips\">repeat-x</span>、<span class=\"tips\">repeat-y</span>、<span class=\"tips\">no-repeat</span>，用法同CSS\n\n<div class=\"show\"> const canvas=document.createElement(\"canvas\");\n        canvas.width=1000;\n        canvas.height=1000;\n        document.body.appendChild(canvas);\n        const ctx=canvas.getContext(\"2d\");\n        let img=new Image();\n        img.src=\"./dog.jpg\";\n        img.onload=function(){\n            const p=ctx.createPattern(img,'repeat-y')\n            ctx.fillStyle=p;\n            ctx.fillRect(0,0,1000,1000)\n        }</div>\n\n### 曲线\n#### 圆与圆弧线绘制\n\n<span class=\"strong\">context.arc(x,y,r,startAngle, endAngle, anticlockwise)</span>\n\n+ x,y为圆弧中心\n+ r为圆弧半径\n+ startAngle, endAngle为圆弧起始点和终点角度，弧度表示，角度为css坐标x轴与y轴夹角\n+ anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制\n<div class=\"show\">const canvasArc=document.getElementById(\"canvasArc\");\n   const ctxArc = canvasArc.getContext('2d');\n   ctxArc.lineWidth=5;\n   ctxArc.arc(150,150,100,0,90/180*Math.PI,true);\n   ctxArc.stroke();</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasArc\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasArc=document.getElementById(\"canvasArc\");\n   const ctxArc = canvasArc.getContext('2d');\n   ctxArc.lineWidth=5;\n   ctxArc.arc(150,150,100,0,90/180*Math.PI,true);\n   ctxArc.stroke();\n</script>\n\n#### 圆弧线绘制方法2\n<span class=\"strong\">context.arcTo(x1, y1, x2, y2, radius)</span>\n\n+ x1, y1为第一个控制点坐标\n+ x2, y2为第二个控制点坐标\n+ radius 为圆弧半径\n\n将当前路径终点与控制点 1 连接的直线，和控制点 1 与控制点 2 连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径\n\n<div class=\"show\"> const canvasArcTo=document.getElementById(\"canvasArcTo\");\n   const ctxArcTo = canvasArcTo.getContext('2d');\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(100,50)\n    ctxArcTo.strokeStyle=\"#000\";\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.arcTo(250,50,250,250,150);\n    ctxArcTo.stroke()\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(50,50)\n    ctxArcTo.setLineDash([5,10]);\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.strokeStyle=\"blue\";\n    ctxArcTo.lineTo(250,50)\n    ctxArcTo.lineTo(250,250)\n    ctxArcTo.stroke()</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasArcTo\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasArcTo=document.getElementById(\"canvasArcTo\");\n   const ctxArcTo = canvasArcTo.getContext('2d');\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(100,50)\n    ctxArcTo.strokeStyle=\"#000\";\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.arcTo(250,50,250,250,150);\n    ctxArcTo.stroke()\n    ctxArcTo.beginPath();\n    ctxArcTo.moveTo(50,50)\n    ctxArcTo.setLineDash([5,10]);\n    ctxArcTo.lineWidth=5;\n    ctxArcTo.strokeStyle=\"blue\";\n    ctxArcTo.lineTo(250,50)\n    ctxArcTo.lineTo(250,250)\n    ctxArcTo.stroke()\n</script>\n\n#### 椭圆\n<span class=\"strong\">context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);</span>\n\n+ x,y为椭圆圆心的坐标\n+ radiusX 为椭圆长轴的半径，radiusY 为椭圆短轴半径\n+ rotation 为椭圆的旋转角度，以弧度表示\n+ startAngle, endAngle为椭圆圆弧起始点和终点角度，弧度表示\n+ anticlockwise可选，true为逆时针绘制圆弧，false为顺时针绘制\n\n<div class=\"show\"> const canvasEllipse=document.getElementById(\"canvasEllipse\");\n   const ctxEll = canvasEllipse.getContext('2d');\n   ctxEll.lineWidth=5;\n   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)\n   ctxEll.stroke();</div>\n\n<canvas width=\"300\" height=\"300\" id=\"canvasEllipse\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasEllipse=document.getElementById(\"canvasEllipse\");\n   const ctxEll = canvasEllipse.getContext('2d');\n   ctxEll.lineWidth=5;\n   ctxEll.ellipse(150,150,100,80,0,0,2*Math.PI)\n   ctxEll.stroke();\n</script>\n\n#### 贝塞尔曲线\n##### 二阶贝塞尔曲线\n<span class=\"strong\"> context.quadraticCurveTo(cpx, cpy, x, y)</span>\n\n+ cpx, cpy为控制点的坐标\n+ x, y为曲线终点坐标\n+ 起始点坐标为当前路径所在终点，或者可以使用moveTo()控制\n\n<div class=\"show\"> const canvasBC=document.getElementById(\"canvasBezierCurve\");\n   const ctxBC = canvasBC.getContext('2d');\n   ctxBC.lineWidth=2;\n   ctxBC.moveTo(50,50);\n        let cpx=50;\n        let timerBC=setInterval(()=>{\n        //想绘制为动画还需再添加beginPath()和clearRect()方法\n        ctxBC.moveTo(50,50)\n        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)\n        ctxBC.stroke()\n        if(cpx>=350){\n            clearInterval(timerBC)\n        }\n        },100)</div>\n<canvas width=\"300\" height=\"300\" id=\"canvasBezierCurve\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasBC=document.getElementById(\"canvasBezierCurve\");\n   const ctxBC = canvasBC.getContext('2d');\n   ctxBC.lineWidth=2;\n   ctxBC.moveTo(50,50);\n        let cpx=50;\n        let timerBC=setInterval(()=>{\n        ctxBC.moveTo(50,50)\n        ctxBC.quadraticCurveTo(cpx+=50,100,50,250)\n        ctxBC.stroke()\n        if(cpx>=350){\n            clearInterval(timerBC)\n        }\n        },100)\n</script>\n\n\n##### 三阶贝塞尔曲线\n<span class=\"strong\"> context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</span>\n\n+ cp1x, cp1y为第一个控制点的坐标\n+ cp2x, cp2y为第二个控制点的坐标\n+ x, y为曲线终点坐标\n+ 起始点坐标为当前路径所在终点，或者可以使用moveTo()控制\n\n<div class=\"show\"> const canvasBC2=document.getElementById(\"canvasBezierCurve2\");\n   const ctxBC2 = canvasBC2.getContext('2d');\n   ctxBC2.lineWidth=2;\n   ctxBC2.moveTo(50,50);\n    ctxBC2.bezierCurveTo(300, 50, 50, 300,250, 290);\n    ctx2BC.stroke()</div>\n\n\n<canvas width=\"300\" height=\"300\" id=\"canvasBezierCurve2\" style=\"display:block;width:100px;height:100px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n<script>\n   const canvasBC2=document.getElementById(\"canvasBezierCurve2\");\n   const ctxBC2 = canvasBC2.getContext('2d');\n   ctxBC2.lineWidth=2;\n   ctxBC2.moveTo(50,50);\n   ctxBC2.bezierCurveTo(250, 50, 50, 250,250, 290);\n   ctxBC2.stroke()  \n</script>\n\n\n\n\n### 文字绘制\n#### 绘制文字\n<span class=\"strong\">context.fillText(text, x, y, [maxWidth]); 对文字进行填充</span>\n\n<span class=\"strong\">context.strokeText(text, x, y, [maxWidth]); 对文字进行描边</span>\n\n+ text指定文本内容\n+ x, y为文本左下角在画布中开始绘制的坐标(因此坐标不应该为0,0)\n+ maxWidth(可选)，指定绘制的最大宽度，会对文本进行水平缩放\n\n#### 获取文本宽度\n<span class=\"strong\">context.measureText(\"文本\");</span>\n\n返回文本的TextMetrics 对象，一般会从该对象中获得文本宽度，以判断文字是否需要在Canva中进行换行\n<div class=\"show\">&lt;canvas width=\"300\" height=\"700\" id=\"canvasText\">&lt;/canvas>\n&lt;script>\nconst canvasText=document.getElementById(\"canvasText\");\nconst ctxText = canvasText.getContext('2d');\nlet string=\"微风需要竹林，溪流需要蜻蜓，乡愁般的离开，需要片片浮萍，青春属于表白，阳光属于窗台，而我想我属于一个，拥有你的未来\";\nctxText.font=\" 30px Serif\";\nlet rowNum=1;//行号\nlet lastIndex=0;//上一行文字的截取索引位置\nlet rowWidth=0;//每一行的文本长度\n    for(let i=0;i&lt;string.length;i++){\n    rowWidth+=ctxText.measureText(string[i]).width;\n        if(rowWidth>canvasText.width){\n            ctxText.fillText(string.substring(lastIndex,i),0,50*rowNum)\n            lastIndex=i--;//substring()截左不截右\n            rowNum++;\n            rowWidth=0;\n        }\n        if(i==string.length-1){\n            ctxText.fillText(string.substring(lastIndex,i+1),0,50*rowNum)\n        }}\n&lt;/script>\n</div>\n\n#### 文本属性\n<span class=\"strong\">context.font = \"value\";</span>\n指定文本属性，默认为 10px sans-serif，value为CSS中的font简写属性，可以按顺序设置<span class=\"tips\">[font-style]&emsp; [font-variant]&emsp;[font-weight]&emsp; font-size[/line-height] &emsp;font-family</span>\n\n+ 必须包含font-size和font-family\n+ font-style：字体样式，常用取值normal(正常)、italic(斜体)、oblique(倾斜)\n+ font-variant：设置小型大写字母，将字母写为大写，但除首字母外的文本将缩小字号，默认为normal，可以修改为small-caps(小型大写字母)\n+ font-weight：设置文本的粗细，常用值：normal(正常)，bold(粗体)，bolder(再加粗)，lighter(细体)，以及100-900的整百数值\n+ font-size必须，line-height为非必须，有line-height时要写为如：16px/20px 的形式\n+ font-family：字体族，5个通用字体：Serif(衬线字体)、Sans-serif(无衬线字体)、Monospace(等宽字体)、Cursive(草书字体)、Fantasy(幻想字体)\n\n<div class=\"show\">const canvasText=document.getElementById(\"canvasText\");\nconst ctxText = canvasText.getContext('2d');\nctxText.font=\" 60px Serif\";\nctxText.fillText(\"hello world\",50,60) //对文字进行填充\nctxText.strokeText(\"hello world\",50,180)//对文字进行描边</div>\n<canvas width=\"400\" height=\"200\" id=\"canvasText\" style=\"display:block;width:340px;height:160px;margin:0 auto;border:1px dashed #000;background:#fff;\"></canvas>\n    <script>\n       const canvasText=document.getElementById(\"canvasText\");\n       const ctxText = canvasText.getContext('2d');\n       ctxText.font=\" 60px Serif\";\n       ctxText.fillText(\"hello world\",50,60)\n       ctxText.strokeText(\"hello world\",50,180)\n    </script>\n\n#### 文本方向\n<span class=\"strong\">context.direction =\"ltr/rtl/inherit\"; 设置当前文本方向</span> \n\n+ ltr ,从左往右\n+ rtl ,从右往左(部分国家读写习惯)\n+ inherit(默认)，从父元素继承\n\n<span class=\"strong\">context.textAlign = \"left/right/center/start/end\"; 定义文本水平方向上的对齐方式</span> \n\n+ center以绘制文本时的x坐标为基准，一半位于x左边，一半位于右边\n+ start与end属性以direction定义的文本方向为基准\n\n\n<span class=\"strong\">context.textBaseline = \"tophanging/middle/alphabetic/ideographic/bottom\"; 定义文本垂直方向上的对齐方式</span>\n\n+ 与CSS相同，以文本基线为基准，详见MDN文档\n\n\n### 图像与视频绘制\n\n+ <span class=\"strong\">drawImage(image, dx, dy)</span>\n+ <span class=\"strong\">drawImage(image, dx, dy, dWidth, dHeight)  </span>\n+ <span class=\"strong\">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) </span>\n\n    + image为图像源，可以是图片、SVG矢量图、视频、canvas等\n    + dx, dy为图片左上角在画布中开始绘制的位置\n    + dWidth, dHeight为图像在画布上绘制出来的尺寸，会对其进行缩 放、拉抻\n    + sx, sy为裁剪时，距离图像左上角的开始裁剪的位置\n    + sWidth, sHeight为裁剪的宽度和高度，省略该参数则默认裁剪到>右下角，sHeight为负值将从sy反向裁剪\n\n<div class=\"show\">const canvasImg=document.getElementById(\"canvasImg\");\n       const ctxImg = canvasImg.getContext('2d');\n       let img=new Image();\n       img.src=\"./dog.jpg\";\n       img.onload=function(){\n        //仅指定图片在画布中的位置\n        ctxImg.drawImage(img, 50, 50);\n        //指定图片在画布中的位置及缩放尺寸\n        ctxImg.drawImage(img, 50, 50,300,200);\n        //裁剪图片，并指定图片在画布中的位置及缩放尺寸\n        ctxImg.drawImage(img, 50, 50,300,200,0,0,300,300);\n       }</div>\n\n### 移动、旋转、缩放\n<span class=\"strong\">context.translate(x, y); 进行水平和垂直位移</span>\n  修改坐标系的原点，默认原点位于(0,0)，由此移动图像在Canvas中的相对位置，可以在上一次translate(x, y)的基础上再次移动坐标系，多次修改坐标原点\n\n<span class=\"strong\">context.rotate(弧度值); 进行旋转变换</span>\n  修改坐标系的旋转角度，参数为弧度值\n\n<span class=\"strong\">context.scale(x, y); 进行水平和垂直缩放</span>\n  对坐标系x轴和y轴进行伸缩，0-1进行缩小，大于1进行放大，负值则进行水平/垂直翻转后进行缩放\n\n<div class=\"show\">const canvas=document.createElement('canvas');\n        canvas.width=600;\n        canvas.height=600;\n        document.body.append(canvas);\n        const ctx=canvas.getContext('2d');\n        ctx.translate(50,50);\n        ctx.fillRect(0,0,50,100)\n        ctx.translate(100,100);\n        ctx.scale(1,-2)\n        ctx.rotate(180*Math.PI/180)\n        ctx.fillRect(0,0,50,100)</div>\n\n### 阴影\n类似于CSS的阴影效果，注意，阴影应当设置在图形绘画之前，如果设置阴影效果之前已经有图形和文字存在，则阴影不会对这些图形和文字生效\n+ <span class=\"strong\">context.shadowOffsetX = value; 阴影的水平偏移距离</span>\n+ <span class=\"strong\">context.shadowOffsetY = value; 阴影的垂直偏移距离</span>\n+ <span class=\"strong\">context.shadowBlur = value;  阴影的模糊值</span>\n+ <span class=\"strong\">context.shadowColor = \"颜色\"; 阴影颜色</span>\n<div class=\"show\">const ctx=canvas.getContext('2d');\nctx.shadowOffsetX=16;\nctx.shadowOffsetY=8;\nctx.shadowBlur=5;\nctx.shadowColor=\"#575656\";\nctx.moveTo(50,50);\nctx.bezierCurveTo(300, 50, 50, 300,250, 290);\nctx.stroke()</div>\n\n### 滤镜\n类似于CSS3中的效果\n<span class=\"strong\">context.filter = \"一个或多个值\"</span>\n\n+ blur(值px)：高斯模糊\n+ brightness(百分比)：亮度\n+ contrast(百分比)：对比度\n+ grayscale(百分比)：灰度滤镜\n+ hue-rotate(角度deg)：对图像进行色彩旋转的处理\n+ invert(百分比)：反色(呈现出照片底片的效果)\n+ opacity(百分比)：不透明度\n+ sepia(百分比)：褐色处理(怀旧风格)\n+ drop-shadow(x, y, 模糊值, 阴影扩张/收缩, 阴影色)：阴影效果\n\n### 图像合成模式\n<span class=\"strong\">context.globalCompositeOperation = \"type\";</span>\n\n+ <span class=\"strong\">source-over</span> 图像叠加显示(默认)\n+ <span class=\"strong\">source-in</span> 只显示图像重叠部分\n+ <span class=\"strong\">source-out</span> 只显示图像不重叠的部分\n+ <span class=\"strong\">source-atop</span> 后叠加的图像只显示与原图像重叠的部分\n+ <span class=\"strong\">destination-over</span> 将后叠加的图像置于原图像之下\n+ <span class=\"strong\">destination-in</span> 只显示图像重叠部分，并且只显示原图像部分\n+ <span class=\"strong\">destination-out</span> 将原图像抠去与后图像叠加部分显示，并且后图像不显示\n+ <span class=\"strong\">destination-atop</span>将后图像重叠部分替换为原图像并显示\n+ <span class=\"strong\">lighter</span>两图像重叠部分进行颜色相加\n+ <span class=\"strong\">copy</span>去除原图像，只显示新图像\n+ <span class=\"strong\">xor</span>重叠部分透明，其他正常显示\n+ <span class=\"strong\">multiply</span>将重叠部分的顶层像素与底层像素相乘，重叠部分显示为暗黑色\n+ <span class=\"strong\">screen</span>将重叠部分像素倒转，相乘，再倒转，重叠部分显示为亮色\n+ <span class=\"strong\">overlay</span>multiply 和 screen 的结合，原本暗的地方更暗，原本亮的地方更亮\n+ <span class=\"strong\">darken</span>保留两个图层中最暗的像素\n+ <span class=\"strong\">lighten</span>保留两个图层中最亮的像素\n+ <span class=\"strong\">color-dodge</span>将底层除以顶层的反置\n+ <span class=\"strong\">color-burn</span>将反置的底层除以顶层，然后将结果反过来\n+ <span class=\"strong\">hard-light</span>类似于叠加，上下图层互换\n+ <span class=\"strong\">soft-light</span>用顶层减去底层或者相反来得到一个正值\n+ <span class=\"strong\">difference</span>一个柔和版本的强光(hard-light),纯黑或纯白不会导致纯黑或纯白\n+ <span class=\"strong\">exclusion</span>和 difference 相似，但对比度较低\n+ <span class=\"strong\">hue</span>保留底层的亮度和色度，同时采用顶层的色调\n+ <span class=\"strong\">saturation</span>保留底层的亮度和色调，同时采用顶层的色度\n+ <span class=\"strong\">color</span>保留了底层的亮度，同时采用了顶层的色调和色度\n+ <span class=\"strong\">luminosity</span>保持底层的色调和色度，同时采用顶层的亮度\n\n### 状态保存与恢复\n+ <span class=\"strong\">context.save() 将当前状态推入栈中</span>\n+ <span class=\"strong\">context.restore() 读取栈顶的状态</span>\n\n将保存当前的裁剪区域、虚线列表、以及各属性值压入栈中，之后可以直接依次读取栈顶存储的状态并直接绘制，会保存的属性值包括：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled\n<div class=\"show\">const canvas=document.getElementById(\"canvas\");\nconst ctx=canvas.getContext('2d');\nctx.fillStyle=\"red\";\nctx.save(); //依次压栈\nctx.fillStyle=\"yellow\";\nctx.save(); //依次压栈\nctx.fillStyle=\"green\";\nctx.restore(); //弹栈\nctx.fillRect(50,50,100,100);//将绘制为黄色而非绿色\n</div>\n\n### 像素操作-ImageData对象\nImageData对象保存了Canvas图像的底层实际像素，可以直接进行读取和写入。其中，像素被保存在Uint8ClampedArray类型的一维数组中，每个数组元素为0-255之间的数据，每4个数组元素为一组代表了一个像素点的RGBA值。如：索引为0-3的数组元素，存储了第一个像素点的红、绿、蓝、不透明度对应的0-255十进制数值，以此类推\n\n<span class=\"strong\">context.getImageData(x,y,width,height)</span>\n返回ImageData对象，获取(x,y)坐标开始，width为宽，height为高的矩形区域中的像素。返回的对象中包含width、height、data数组(Uint8ClampedArray类型)三个属性\n\n <span class=\"strong\">context.putImageData(imagedata对象, dx偏移, dy偏移)</span>\n\ngetImageData()方法可以从(x,y)坐标开始获取一个矩形区域内的像素数据，将该部分数据修改后，可以通过putImageData()方法将数据绘制到canvas中。其中，dx，dy为在(x,y)的基础上进行的偏移量，之前获取到的(x,y)到(x+width,y+height)矩形区域内的图形，修改像素数据后将被绘制到(x+dx,y+dy)开始的同大小矩形区域内\n\n\n <span class=\"strong\">context.putImageData(imagedata对象,dx偏移, dy偏移, dirtyX, dirtyY,dirtyWidth, dirtyHeight)</span>\n+ dx偏移, dy偏移作用同上\n+ (dirtyX, dirtyY)为进行修改像素操作开始的位置坐标\n+ dirtyWidth, dirtyHeight为将进行修改像素操作的矩形区域的长宽\n\n<div class=\"show\">&lt;canvas width=\"300\" height=\"300\" id=\"canvas\">&lt;/canvas>\n    &lt;script>\n       const canvas=document.getElementById(\"canvas\");\n       const ctx = canvas.getContext('2d');\n       let img=new Image();\n       img.src=\"./dog.jpg\";\n       img.onload=function(){\n        ctx.drawImage(img,0,0,300,300);\n        let imageDate=ctx.getImageData(0, 0, 100, 100);\n        //每4个索引为一组，代表一个像素的RGBA值\n        for(let i=0;i&lt;imageDate.data.length;i+=4){\n            //计算每个像素点的灰度值\n            let avg=(imageDate.data[i]+imageDate.data[i+1]+imageDate.data[i+2])/3;\n            imageDate.data[i]=avg; //修改像素点的R\n            imageDate.data[i+1]=avg;//修改像素点的G\n            imageDate.data[i+2]=avg;//修改像素点的B\n            imageDate.data[i+3]=255;//修改像素点不透明度A为1\n        }\n        // 将(10,10)开始，长200，宽200的区域内的像素调为灰色\n        ctxImg.putImageData(imageDate,0,0,10,10,200,200)\n       }\n    &lt;/script>\n</div>\n\n### 案例\n使用图像合成模式的<span class=\"strong\">\"destination-out\"</span>属性值制作刮刮卡\n<div class=\"ticketContainer\" style=\"position:relative;width:100%;\">\n<div class=\"scratchTicket\" style=\"width: 300px;height: 150px;font-size: 24px;color: red;text-align: center;line-height: 150px;margin:0 auto;letter-spacing: 8px;background-color: #ffffff;pointer-events: none;user-select: none;\">再刮一次</div>\n<canvas width=\"300\" height=\"150\" id=\"canvasTicket\" style=\"position:absolute;top:0;left:50%;transform:translateX(-50%);\"></canvas>\n<div class=\"tryAgain\" onclick=\"tryAgain()\" style=\"width: 100px;height: 35px;line-height: 35px;text-align: center;background-color: aqua;border-radius: 5px;cursor: pointer;user-select: none;margin:10px auto;\">再刮一次</div>\n</div>\n<script>\n       const ticketContainer=document.querySelector(\".ticketContainer\");\n       const canvasTicket=document.getElementById(\"canvasTicket\");\n       const contextTicket=canvasTicket.getContext('2d');\n       const p=contextTicket.createPattern(cover(),\"repeat\");\n        contextTicket.fillStyle=p;\n        tryAgain();\n        function tryAgain(){\n            document.querySelector(\".scratchTicket\").innerText=Math.random()>.6?\"恭喜中奖\":\"再刮一次\";\n            contextTicket.clearRect(0,0,300,150);\n            contextTicket.globalCompositeOperation=\"copy\";\n            contextTicket.fillRect(0,0,300,150);\n        }\n        function cover(){\n            const canvasCover=document.createElement('canvas');\n            const coverCtx=canvasCover.getContext('2d');\n            canvasCover.width=60;\n            canvasCover.height=50;\n            coverCtx.fillStyle=\"#6f6d6d\"\n            coverCtx.fillRect(0,0,60,50)\n            coverCtx.rotate(45*Math.PI/180);\n            coverCtx.font=\"300 15px Serif\";\n            coverCtx.fillStyle=\"#333333\"\n            coverCtx.fillText(\"发大财\",20,0)\n            return canvasCover;\n        }\n        let allowedDraw=false;\n        canvasTicket.addEventListener('mousedown',function(){\n            allowedDraw=true;\n        }) \n        canvasTicket.addEventListener('mouseup',function(){\n            allowedDraw=false;\n        })\n        canvasTicket.addEventListener('mousemove',function(event){\n            var event = event || window.event;\n            if(allowedDraw){\n             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器\n              var  x = event.offsetX;\n              var y = event.offsetY;\n            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器\n              var x = event.layerX;\n              var y = event.layerY;\n            }\n            contextTicket.globalCompositeOperation=\"destination-out\";\n            contextTicket.beginPath();\n            contextTicket.arc(x,y,20,0,2*Math.PI);\n            contextTicket.fill();\n            }})\n            canvasTicket.addEventListener('touchstart',function(){\n            let canvasTicketRect=canvasTicket.getBoundingClientRect();\n            canvasTicket.addEventListener('touchmove',function(e){\n                e.preventDefault();\n            var x=e.targetTouches[0].pageX-canvasTicketRect.left;\n            var y=e.targetTouches[0].pageY-canvasTicketRect.top;\n            contextTicket.globalCompositeOperation=\"destination-out\";\n            contextTicket.beginPath();\n            contextTicket.arc(x,y,20,0,2*Math.PI);\n            contextTicket.fill();\n            },{passive:false})    \n        },{passive:false})\n    </script>\n<pre><code>&lt;div class=\"card\">&lt;/div>//底层卡片，显示是否中奖\n&lt;canvas width=\"300\" height=\"150\" id=\"canvas1\">&lt;/canvas>//刮刮乐灰色图层，监听刮开区域\n&lt;div class=\"tryAgain\" onclick=\"tryAgain()\">再刮一次&lt;/div>//重新开始按钮&lt;/div>\n&lt;script>\n       const canvas=document.getElementById(\"canvas1\");\n       const context=canvas.getContext('2d');\n       const p=context.createPattern(cover(),\"repeat\");//创建模板对象，设置图像重复模式\n        context.fillStyle=p;\n        function tryAgain(){\n            document.querySelector(\".card\").innerText=Math.random()>.8?\"恭喜中奖\":\"再刮一次\";\n            context.clearRect(0,0,300,150);\n            context.globalCompositeOperation=\"copy\";\n            context.fillRect(0,0,300,150);\n        }\n        tryAgain();\n        /*\n        *制作刮刮乐封面，返回canvas DOM\n        */\n        function cover(){\n            const canvasCover=document.createElement('canvas');\n            const coverCtx=canvasCover.getContext('2d');\n            canvasCover.width=60;\n            canvasCover.height=50;\n            coverCtx.fillStyle=\"#6f6d6d\"\n            coverCtx.fillRect(0,0,60,50)\n            coverCtx.rotate(45*Math.PI/180);\n            coverCtx.font=\"300 15px Serif\";\n            coverCtx.fillStyle=\"#333333\"\n            coverCtx.fillText(\"发大财\",20,0)\n            return canvasCover;\n        }\n        let allowedDraw=false;\n        canvas.addEventListener('mousedown',function(){\n            allowedDraw=true;\n        }) \n        canvas.addEventListener('mouseup',function(){\n            allowedDraw=false;\n        })\n        canvas.addEventListener('mousemove',function(event){\n            var event = event || window.event;\n            if(allowedDraw){\n             if (event.offsetX || event.offsetY) {  //非Mozilla浏览器\n              var  x = event.offsetX;\n              var y = event.offsetY;\n            } else if (event.layerX || event.layerY) {  //兼容Mozilla浏览器\n              var x = event.layerX;\n              var y = event.layerY;\n            }\n            context.globalCompositeOperation=\"destination-out\";\n            context.beginPath();\n            context.arc(x,y,20,0,2*Math.PI);\n            context.fill();\n            }})\n            //移动端\n            canvas.addEventListener('touchstart',function(){\n            let canvasRect=canvas.getBoundingClientRect();\n            canvas.addEventListener('touchmove',function(e){\n                e.preventDefault();\n            var x=e.targetTouches[0].pageX-canvasRect.left;\n            var y=e.targetTouches[0].pageY-canvasRect.top;\n            context.globalCompositeOperation=\"destination-out\";\n            context.beginPath();\n            context.arc(x,y,20,0,2*Math.PI);\n            context.fill();\n            },{passive:false})    \n        },{passive:false})\n    &lt;/script></code></pre>\n","tags":["Web","javaScript"]},{"title":"Web的发展旅程","url":"/blog/2022/09/18/History-of-browser/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n了解这些历史解开了此前我心中的一些疑惑，比如：UA标识里为什么同时会有好几个内核的标识？CSS为什么需要写浏览器前缀来做兼容性？</div>\n\n### 世界线的开端\n#### 超文本(Hyper Text )\n<span class=\"strong\">超文本:</span>是指利用链接将非线性分布的节点上的信息联结，把各种不同空间的文字信息组织在一起形成的超级文本。它使得原先的线性文本变成可以通向四面八方的非线性文本，读者查阅文本时可以在任何一个关节点上停下来，进入其他文本，然后再点击、再进入另一文本，理论上，这个过程是可以无限重复的。从而，原先单一的文本变成了无限延伸、扩展的超级文本。\n\n1945年，美国工程师Vannevar Bush(曼哈顿计划的主要组织者、雷神公司创始人之一)提出了一种基于静态缩微胶片页面的memex(memory extender)设备,人们可以在该设备中压缩和存储书籍、文件、通信记录及其索引，并以极快的速度对其进行检索查询。这意味着，人们不用再根据特定的程序，一步一步寻找信息，利用文本间的交叉引用链接,人们可以用非线性的方式查阅信息，由于条件所限，Vannevar Bush的思想在当时并没有变成现实，但这一开创性的信息组织方法，奠定了超文本的基础。\n\n1960年，Ted Nelson在哈弗大学参加计算机编程课时，考虑编写一个文档系统来索引和管理他收藏的笔记，他在进入哈弗大学前曾担任电影制片人，因此他准备将电影镜头引入了该系统的设计中。所有信息都可以通过其他任何地方的链接访问，信息导航是非线性的，这取决于每个访问信息的人，人们可以从一个信息跳转到另外一则信息，就像从一个镜头切换到另外一个镜头。基于这个想法，1963年，Ted Nelson 首次提出了“超文本”的概念。\n\n1968年，美国科学家Doug Engelbart在美国秋季联合计算机会议上展示了第一个超文本系统NLS(oN-Line System)，并首次展示了鼠标、第一个图形用户界面。\n\n#### 万维网的诞生\n1989年，工作于CERN(欧洲核子研究所)的Tim Berners Lee为查找存储在不同计算机上的信息而苦恼，不兼容的网络、磁盘、数据格式和字符编码使得人们查找信息十分困难且低效。于是，他向CERN的领导层提交了一个超文本项目提案，该提案提出建立一个用于CERN研究人员之间交流信息的系统，用以帮助处于不同网络、计算机系统、国家的研究人员共享信息和交流问题。\n\n1990年，Tim Berners Lee开发出了构建Web所需要的三个基本技术：\n+ <span class=\"strong\">统一资源定位符(URL)</span>\n+ <span class=\"strong\">超文本标记语言(HTML)</span>\n+ <span class=\"strong\">超文本传输协议(HTTP)</span>\n\n同年，在同事Robert Cailliau的帮助下，Tim Berners Lee发起建立了一个名为World Wide Web (万维网)的超文本项目。1990年12月，Tim Berners Lee和他的团队开发出了世界上第一个Web浏览器(WorldWideWeb，与万维网同名)，第一个Web服务器(CERN httpd)，并发布了世界上第一个网站：<a href=\"http://info.cern.ch/\">http://info.cern.ch/</a>，万维网就此诞生！\n\n1994年，W3C联盟(万维网联盟)正式成立，由Tim Berners-Lee 担任W3C联盟主任，这是一个非营利性技术组织，旨在对 web 技术进行标准化，以协调服务提供商、内容供应商、实验室等各方协同工作，致力在万维网发展方向上达成共识，并起草发布<span class=\"strong\">W3C标准</span>，主要包括HTML、XHTML、CSS、DOM、ECMAScript标准的规划制定。\n\n#### 浏览器的发展\nWorldWideWeb浏览器最初只能在NeXTSTEP操作系统上使用(next公司老板是大名鼎鼎的乔布斯，后来next被苹果收购，NeXTSTEP系统和OpenStep结合，衍生出了MacOS)，为了解决这个问题，Tim Berners Lee的团队使用C语言重写了WorldWideWeb的许多组件，从而创建了libwww API。\n\n1992年4月，在Robert Cailliau的指导下，赫尔辛基理工大学的4名硕士生小组联合开发出了第一个可运行于Unix的浏览器Erwise，该项目在学生毕业后被搁置了，Tim Berners Lee前往芬兰鼓励该小组毕业后继续开发该项目，但后期由于缺少资金该项目再次被搁置。\n\n1992年，加州大学伯克利分校学生魏培源使用Viola语言将WWW浏览器的组件组合了起来，发布了第二个可以运行于Unix系统中的浏览器ViolaWWW，这是第一个支持添加扩展功能的浏览器，该浏览器得到了CERN的推崇，成为了第一个流行于万维网中的浏览器。\n\n1993年，美国国家超级计算应用中心(NCSA)的俩名员工Marc Andreessen和Eric Bina在接触了ViolaWWW后，为Unix的X窗口系统设计出了Mosaic浏览器，这是第一款可以显示图形界面和图片的浏览器，设计之初就考虑到了非技术用户的使用体验，由此引发了Web网络的爆炸式发展，Web在短短几个月内从鲜为人知变成了无处不在，该浏览器也很快被移植到Amiga、Apple Macintosh和Windows等平台。\n\n### 内核的发展\n#### 开拓者 网景导航者\n1994年4月，Mosaic浏览器的核心开发人员Marc Andreessen离开了NCSA，与几何图形发生器的发明人Jim Clark共同创办了网景公司（Netscape Communications Corporation），网景大量聘用了原有的Mosaic浏览器工程师，但由于Mosaic的版权在NCSA，于是开发团队重写了浏览器代码。\n\n1994年11月，网景发布了大名鼎鼎的<span class=\"strong\">网景导航者（Netscape Navigator）</span>浏览器1.0版本，这是全球第一款商业浏览器，由于公司目标是替代NCSA Mosaic成为全球第一的浏览器，因此将其内部代号定为了\"Mozilla\"，意为Mosaic杀手。1995年，网景开发出了<span class=\"strong\">HTTP cookie、</span><span class=\"strong\">Frame框架、</span><span class=\"strong\">SSL</span>等一系列技术，并创建了<span class=\"strong\">JavaScript</span>语言，网景导航者由于其功能更新迅速，又有新技术的加持，市场份额一度达到了86%。\n\n意气风发的网景将目光转向了操作系统的开发，网景希望开发出一款基于浏览器的操作系统，类似于如今的Chrome OS。这引起了微软的警觉，这一跨越浏览器界限的作业系统，被微软视为是对Windows的直接威胁，微软担心网景抢占他们在操作系统和应用软件方面的市场份额。\n\n\n#### 泥石流 IE\n1995年，为了对抗网景导航者，微软从Spyglass公司(Spyglass是NCSA创建的商业化公司)购买了Mosaic浏览器的源代码和许可，同年8月，微软推出了基于此开发的<span class=\"strong\">Internet Explorer</span>浏览器1.0版本。IE浏览器的发布引发了“浏览器大战”，网景和微软竭力为各自的产品推陈出新，以求占据更大的市场份额。\n\n1996年，微软推出了IE3,这是第一款支持<span class=\"strong\">CSS</span>的商用浏览器。\n\n1997年9月，微软发布了<span class=\"strong\">Trident</span>内核，并推出了第一个以该内核作为引擎的浏览器 IE4。事态开始逐渐失控，微软的团队制作了一个巨大的字母\"E\"模型并将它放在了网景总部的草坪上。网景的团队不甘示弱，推倒了模型并放上了Mozilla的恐龙吉祥物，并写上标语\"Netscape 72，Microsoft 18\"以嘲讽微软IE浏览器的市场份额比网景低。\n\n随后，微软开始不讲武德，将IE集成到了Windows中进行捆绑发行，并投给了苹果1.5亿美元，让苹果撤销之前对微软的侵权指控，附加条件是让苹果在其Macintosh上内置IE浏览器。此外，微软在授权条款中，要求主机厂商们在桌面上展示IE的图标，并不得加入Netscape，否则以涨价方式作为处罚。\n\n微软的垄断式发行卓有成效，当人们看到打开操作系统就有开箱即用的浏览器时，很少会有人再想到网景导航者了，更何况IE是免费的而网景导航者需要付费。微软的一系列操作让IE浏览器的市场份额很快暴涨，直至2002年，IE浏览器的市场份额达到恐怖的96%，比网景的峰值还高。\n\n过高的市场占有率开始使微软养尊处优，没有了网景这一竞争对手的压力，微软放慢了对内核的更新进程，并开始奉行一套自己的Web标准，在IE浏览器中加入了VBScript，DHTML等不遵循W3C公开标准的专属技术，以巩固自己的霸主地位，IE浏览器开始变得臃肿而笨重。由于IE浏览器垄断了市场，不少网页开发者只能迎合微软的Web标准，公开的W3C标准反而不被关注，从而衍生出了一大堆只和IE专属技术契合的网站，使得一些网站只能使用IE浏览器打开。\n\n此外，IE由于市场占有率高，已然成为了蠕虫病毒的主要攻击目标，IE浏览器一旦被发现安全漏洞，蠕虫病毒会由于IE的普及高速传播。IE的泥石流行径为web的发展带来了难以根治的后遗症，而微软的不正当竞争行径也使之背负了多年的反垄断指控。\n\n#### 网景的继承 Mozilla火狐\n除了微软的垄断式打压，网景后期对浏览器的错误定位也成为了网景覆灭的导火索之一。网景在与微软的“浏览器大战”中过分追求为浏览器增加特色功能，将电子邮件、新闻组件、文件编辑等功能塞入了浏览器中，并将其更名为了 Netscape Communicator4.0（网景通讯家）。过多的组件造成整个软件渲染缓慢，臃肿不堪。并且其新增的“特色”功能并没有革命性的创新，反而逐渐脱离了W3C的标准，期间曾一度创造了臭名昭著的<span class=\"tips\">&lt;blink&gt;</span>标签。欠缺的使用体验，再加上微软的流氓式打压，网景浏览器的市场份额一落千丈。\n\n1998年1月，在与微软的“浏览器大战”中失利后，为了挽回市场，网景宣布旗下所有软件对公众免费，并开源了Netscape Communicator4.0的源代码。与此同时，网景发布了一个全新的开源项目Mozilla，其中包含了全新的排版引擎<span class=\"strong\">Gecko</span>，并建立了非正式组织Mozilla，以支持后续的Netscape Communicator开发。\n\n1998年10月，网景宣布Netscape Communicator5.0将使用全新的Gecko引擎，这引起了Netscape开发人员的不满，因为在此之前他们对旧引擎<span class=\"strong\">Mariner</span>进行了长达六个月的改进工作，而此举意味着他们此前的努力将付诸东流。网景的盈利主要依靠网景导航者及其衍生产品的收益，主要支柱遭受巨大打击，此时的网景已经摇摇欲坠，内部进行了大量人员裁剪。诸多原因直接导致Netscape Communicator5.0的发布被极大地推迟了，而此前微软发布的IE4比旧版本的网景通讯家拥有更好的性能，包括对HTML4、CSS、DOM和ECMAScript等W3C标准的支持，市场的天平进一步向微软倾斜。\n\n1998年11月，AOL(美国在线)公司以42亿美元、免税换股的方式收购了网景通讯公司。AOL在证实微软因滥用垄断能力而败诉后(此前微软因垄断问题在和苹果等公司打官司)，AOL向微软提出了索偿诉讼，指控微软在与网景的竞争中滥用垄断能力。2003年5月，微软和AOL达成和解协议，微软将向网景支付7.5亿美元，而AOL允许微软在7年无限制的使用和散布IE浏览器，AOL的这一举动带领网景走向了覆灭。\n\n2000年11月，在推迟将近两年后，网景跳过了Netscape Communicator5.0，发布了基于Gecko引擎的Netscape 6，但此时已是IE5的天下。\n\n2003年7月15日，AOL解散了网景公司，解雇了Gecko的开发人员，并将Gecko及其相关产品的知识产权交给了Mozilla组织，Mozilla组织接收了大量Gecko的开发人员。同一天，Mozilla基金会正式成立，其目的是保证Mozilla组织可以在没有网景以后能继续生存下去。\n\n2004年11月，Mozilla发布了Firefox(火狐)1.0版本，起初，Firefox被命名为Phoenix，寓意网景导航者的欲火重生，但由于与一家科技公司重名而改为了Firebird，该名称又和一个数据库软件重名，最后Mozilla 将名称确定为了Firefox。\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nMozilla还负责运行维护MDN开发者平台，该平台提供了大量关于HTML、CSS、JavaScript和Web API的免费文档资料，是最好的Web开发资源平台之一。</div>\n\n#### 勤劳的蜜蜂 苹果safari\n在safari之前，苹果Macintosh系列计算机所使用的默认浏览器为网景导航者、Cyberdog（苹果自行开发的浏览器，由于苹果经营不善该项目被裁掉）和IE。\n\n2001年6月，苹果fork了由KDE社区(一个崇尚开源自由的软件社区)开发的开源渲染引擎KHTML和JS引擎KJS，然后利用适配器库将其移植到了苹果的Mac OS X系统上，并重命名为WebCore和JavaScriptCore。经过苹果二次开发的KHTML和KJS拥有了更为严谨的代码结构和更快的渲染速度，苹果将其命名为<span class=\"strong\">Webkit</span>引擎。\n\n2003年1月，苹果发布了首个以此为内核的<span class=\"strong\">safari</span>浏览器\n\n2005年6月，苹果开源了Webkit源代码，同年12月，添加了对SVG(矢量图)的支持\n\n2007年，苹果开始对CSS进行拓展，使得CSS开始支持动画、过渡、2D和3D变换，并于2009年将其以草案的方式发布给了网维网联盟进行标准化，辛勤的苹果为CSS标准库提供了大量的草案和建议。\n\n#### 新的引领 谷歌chrome\nWebkit的高效和稳定引来了谷歌的青睐，2008年9月，谷歌发布了以Webkit为引擎的<span class=\"strong\">Chrome</span>浏览器,实际上，Chrome还使用了Mozilla等组织的诸多开源组件来增强性能。\n\n2010年苹果发布了Webkit2，由于Webkit2使用的进程隔离技术与谷歌的沙箱设计存在冲突，谷歌决定在WebKit的基础上自行开发引擎。谷歌的工程师们fork了WebKit的Webcore渲染引擎，并对源代码作了大量的精简和修改，而JS引擎将谷歌自行开发。\n\n2013年4月，谷歌发布并开源了全新的浏览器内核<span class=\"strong\">Blink</span>，其名字来源于网景创建的臭名昭著的<span class=\"tips\">&lt;blink&gt;</span>标签，谷歌的工程师戏虐的表示：\"我们永远不会支持blink标签\"。此外，谷歌还开发出了强悍的JavaScript解释器——V8引擎(基于Strongtalk)，大大加快了chrome的JS解析速度。\n\n随着Blink的发布，Opera等浏览器厂商纷纷宣布将转向使用Blink引擎。2015年3月，微软宣布放弃IE浏览器的开发，转而使用Microsoft Edge取代IE。2020年，微软宣布Microsoft Edge浏览器将弃用EdgeHTML转而使用Blink内核。\n\n#### 兢兢业业的Opear\n1994年，挪威电信公司Telenor的两名员工Jon Stephenson von Tetzchner和Geir Ivarsøy开始开发Opear浏览器，后来，他们离开了Telenor并创立了Opear Software，并于1995年4月发布了Opear浏览器\n\n2003年1月，欧朋发布就基于<span class=\"strong\">Presto</span>内核的Opera 7\n\n2010年，欧朋首创了选项卡堆叠、鼠标手势等功能，这些功能后来也被其他浏览器大量应用\n\n2013年2月，欧朋宣布放弃presto转而使用Webkit，2013年4月，欧朋跟随谷歌转而使用Blink引擎。\n\n2016年2月，欧朋被360公司和昆仑万维收购\n\n欧朋浏览器自发布以来严格遵守W3C标准，老老实实地开发使用符合W3C规范的技术拓展，然而“浏览器大战”与IE的横行造就了一大堆不符合W3C标准的网页，由于Opear不支持非标准的技术栈，这些网页在Opear上往往会解析错误，Opear的兢兢业业反而为其带来了负面的用户口碑，因为用户只会将页面的不解析归咎于浏览器的问题。\n\n2001年10月，随着WindowsXP的发布，微软对MSN通讯软件进行了重大更新，随后就有用户反馈无法使用Opear浏览器进入MSN主页。微软随即甩锅解释是因为Opear浏览器不支持W3C的XHTML技术规范导致。Opear公司反驳表示，Opear浏览器比微软更能满足W3C标准，并给出了W3C验证服务结果：微软的MSN主页使用了非标准的编码。Opear公司还制作了一份标准XHTML的页面进行还击，经过测试，网景6、Opear 等浏览器能正确访问该页面，而IE 6则无法正常显示。随后，微软开始排挤Opear用户，谷歌在发布Chrome后也曾排挤Opear，直至Opear改用Blink引擎后才有所好转。\n\nOpear在不断遭受排挤后开始考虑支持非标准拓展，Opear公司为浏览器添加了伪装功能，允许用户将Opear伪装为IE、Firefox等浏览器以解决某些网站排挤Opear的问题，兢兢业业的欧朋由于遵守W3C标准反而吃了不少亏，这不是欺负老实人吗!!（胡万腔）\n\n#### 国产浏览器\n中国互联网发展最快的时间刚好遇上了IE浏览器霸榜的时代，由于IE的Trident内核市场占有率较高，许多网页设计者不得不将以IE的标准作为优先考量，直接导致许多政府机构、高校、企业、银行的网站只能在IE浏览器上正常访问，而在更支持W3C标准的safari、chrome、Firefox等浏览器反而会出现加载或解析错误的情况。为此，国内的浏览器厂商们整合了IE的Trident内核与苹果的Webkit内核，美其名曰双内核并以此作为宣传浏览器的噱头(其实都是别人家的内核)。兼容模式下，浏览器会启用Trident内核以适应脱离w3c标准的垃圾网页。\n\n### 浏览器UA标识\nUA为User Agent的简写，指浏览器等软件在网络协议中工作时，会向服务器等对等方提交一个特征字符串，方便对方识别应用类型、操作系统、软件版本号等信息。例如：由于手机屏幕和电脑屏幕尺寸相差巨大，网站设计者一般会为手机端和电脑端设计两个不同大小的网页(或者响应式网页)，当我们访问网站时，服务器会通过UA标识(或者屏幕大小)检测到我们使用的设备是手机还是电脑，从而返回相应的网页。浏览器UA的语法格式通常为：\n<div class=\"show\"><span class=\"strong\">&lt;product> /&lt;version> (&lt;system-information>) &lt;platform> (&lt;platform-details>) &lt;extensions></span></div>\n\n\n\nUA也起源于著名的“浏览器之战”，当时，由于网景首先开创使用了JavaScript、Frames框架等技术，使得网景导航者浏览器的使用体验一骑绝尘，当时的网景导航者支持图片嵌入、网页嵌入等技术，而Mosaic、Samba等一些比较旧的浏览器只支持显示简单的HTML文档。为了提高网站的使用体验，网站设计者们往往希望网页拥有比较前沿的技术设计，但用户的浏览器却不一定支持网站的新颖技术。解决这一问题，UA嗅探技术诞生了。通过UA，网站会动态识别访问用户的浏览器，如：如果是网景导航者，则返回带有Frames框架技术的高级网页内容，如果为Mosaic，则只需返回简单的HTML文档即可。\n\n起初，网景的UA长这样：\n<div class=\"show\"><code>Mozilla/1.0 (win3.1)</code></div>\n\n后来，IE浏览器诞生，IE及其他浏览器逐步追上了网景的脚步，并开始支持网景的特色功能，但由于它们起步较晚，绝大多数网站仍只支持为带有Mozilla标识的浏览器返回高级网页。于是乎，微软等公司的在UA中添加了Mozilla的标识来“欺骗”Web服务器，于是，IE浏览器的标识写为了：\n\n<div class=\"show\"><code>Mozilla/1.22 (compatible;MSIE 2.0;Windows 95)</code></div>\n\n后来，网景飞升，留下了遗孤Mozilla ，Mozilla 打造 Gecko并发布了Firefox，Firefox的UA写为了\n<div class=\"show\"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0</code></div>\n\n再后来，KDE社区开发出了KHTML引擎，并发布了嵌入式浏览器 Konqueror，但网页不给他们分发高级内容，他们很烦，于是他们也伪装成了Mozilla，并且表示KHTML跟Gecko一样好~\n<div class=\"show\"><code>Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)</code></div>\n\n\n后来，苹果基于KHTML开发出了WebKit，他们又在KHTML的UA上套了一层娃\n<div class=\"show\"><code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5</code></div>\n\n再再后来，谷歌又在WebKit基础上开发出了blink，他们也想套娃\n<div class=\"show\"><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13</code></div>\n\n于是，人人都是网景Mozilla\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n参考：<a href=\"https://webaim.org/blog/user-agent-string-history/\">user-agent-string-history</a></div>\n\n\n### 代码兼容性\n#### CSS浏览器前缀\n为了兼容旧版本的浏览器，对于比较新颖的CSS样式我们需要添加浏览器前缀\n<div class=\"table\">\n\n浏览器 | 内核 | 前缀\n------|------|----\nIE    |Trident|-ms-\nFirefox|Gecko| -moz-\nOpera |Presto| -o-\nSafari | WebKit|-webkit-\nChrome |WebKit| -webkit-\n\n</div>\n\n#### 渲染内核\n##### 双核浏览器\n对于双核浏览器，我们可以使用<span class=\"tips\">meta</span>标签指定内核渲染网页，国内的双核浏览器一般是Trident内核和webkit内核，因此选其一。\n<div class=\"show\">使用webkit渲染网页，用于提高渲染速度\n&lt;meta name=\"renderer\" content=\"webkit\"> \n使用IE兼容内核，用于兼容为低版本IE浏览器\n&lt;meta name=\"renderer\" content=\"ie-comp\">\n使用IE标准内核，用于网站用了IE专属技术\n&lt;meta name=\"renderer\" content=\"ie-stand\">\n</div>\n\n\n##### IE浏览器\n<span class=\"tips\">X-UA-Compatible</span>是IE8的一个专有<meta>属性，它用来指示IE8以上浏览器采用何种IE版本去渲染网页\n\n常用值有：\n<div class=\"show\">使用最高版本的IE内核渲染\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n启用谷歌内嵌框架Chrome Frame(谷歌推出的IE插件)进行渲染，没有则使用最高版本的IE内核渲染（推荐使用）\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge,chrome=1\" />\n</div>\n\n其他还支持\n<div class=\"show\">使用IE7内核渲染\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" />\n值可并列，该值表示IE8降级使用IE7内核渲染，若有IE9则使用IE9\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7;IE=9\" />\n</div>\n\n","tags":["Web","CS"]},{"title":"基于certbot获取TLS证书","url":"/blog/2022/07/29/lets-encrypt/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nLet’s Encrypt 官网：<a href=\"https://letsencrypt.org/\">https://letsencrypt.org/</a></div>\n\n### 关于 \n#### Let's Encrypt\nLet’s Encrypt 是由 ISRG (Internet Security Research Group)推出的免费安全证书计划，我们可以利用Let’s Encrypt 提供的TLS证书，在我们的网站上部署HTTPS 服务。\n\n#### ISRG\nISRG（Internet Security Research Group ，互联网安全研究小组）是一个公益性的组织，该公益组织旨在减少资金、技术、教育障碍，以保护互联网上的通信，推动全球网站的HTTPS化。ISRG成立于2013 年 5 月，起初由Mozilla、电子前沿基金会(EFF)、密歇根大学、思科和 Akamai共同建立，后来又得了谷歌、亚马逊、讯飞、IBM、RedHat、Linux基金会等大厂商的赞助，所以他们的技术和证书安全是可以保障的。\n\n#### Certbot\nCertbot 是由电子前沿基金会 (EFF)制作的免费开源软件工具，用于在网站上申请、管理、使用由Let's Encrypt颁发的证书，证书每60天更新一次。\n\n### 前置需要\n+ 一台可用的服务器，并拥有<span class=\"tips\">root</span>权限\n+ 安装了Web服务，以<span class=\"tips\">Nginx</span>为例\n+ 一个可用的域名，并解析到了该服务器上\n\n### 安装certbot\n#### 官方安装\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\ncertbot官方文档：<a href=\"https://certbot.eff.org/\">https://certbot.eff.org/</a></div>\n\n官网文档里给出了不同系统的详细安装方法，但在安装过程中会遇到不少问题，有些甚至涉及到需要重新编译Linux内核，这在已经部署业务的服务器上往往是无法实现的。\n\n以CentOS7为例，根据官方的文档，安装Certbot需要先添加EPEL存储库，然后从中安装snapd软件包，但安装snapd需要解决诸多依赖问题：\n+ 安装snapd需要Linux内核支持 SquashFS 文件系统\n+ 手动编译安装的SquashFS 文件系统，yum可能无法识别\n+ 内核编译时需要启用CONFIG_DEVPTS_MULTIPLE_INSTANCES 选项，如果没有需要重新编译内核\n\n#### 通过pip3安装\n如果无法安装snapd，那只能绕过它，通过其他包管理工具安装，以pip（python包管理工具）为例\n\n安装python并通过pip安装certbot\n<pre><code>yum install -y python3 && pip3 install certbot</code></pre>\n\n##### pip3版本较低报错问题\n在安装certbot时，如果yum源中的pip3版本较低，可能会导致模块导入失败，从而报错\n<div class=\"shell\">Complete output from command python setup.py egg_info:\n            =============================DEBUG ASSISTANCE==========================\n            If you are seeing an error here please try the following to\n            successfully install cryptography:\n            Upgrade to the latest pip and try again. This will fix errors for most\n            users. See: https://pip.pypa.io/en/stable/installing/#upgrading-pip\n            =============================DEBUG ASSISTANCE==========================\n    Traceback (most recent call last):\n      File \"&lt;string>\", line 1, in &lt;module>\n      File \"/tmp/pip-build-2bwzqu_0/cryptography/setup.py\", line 14, in &lt;module>\n        from setuptools_rust import RustExtension\n    ModuleNotFoundError: No module named 'setuptools_rust'\n    ----------------------------------------\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-2bwzqu_0/cryptography/</div>\n\n此时根据报错提示，升级pip3到最新版本即可\n<pre><code>sudo pip3 install --upgrade pip</code></pre>\n\n升级完毕再安装certbot\n<pre><code>pip3 install certbot</code></pre>\n\n\n\n### 申请证书\n#### 验证域名\n申请证书前，Let’s Encrypt需要先验证域名，以确认用户拥有对域名的控制权。验证通过后，certbot会立马进入申请流程，因此下述命令会同时验证域名和申请证书。certbot针对不同的web服务器和需求，有多种不同的验证方式：\n##### 1. Nginx\n如果部署了Nginx，可以直接执行（但要确保安装了certbot-nginx插件）\n<pre><code>sudo certbot --nginx</code></pre>\ncertbot将自动获取域名，并在进入证书申请流程时让你确认域名，也可以在执行上述命令时通过添加<span class=\"tips\">-d</span>参数来指定域名，如：\n<div class=\"show\"><code>sudo certbot -&zwnj;-nginx -d  shiwivi.com -d  www.shiwivi.com</code></div>\n\n可以通过<span class=\"tips\">-&zwnj;-email</span>来添加邮箱，Let’s Encrypt会在证书即将到期时发邮件通知你更新证书。\n<div class=\"show\"><code>sudo certbot -&zwnj;-nginx --email xxxx@gmail.com -d  shiwivi.com -d  www.shiwivi.com</code></div>\n\n如果不添加上述参数，certbot会在验证通过后要求你添加，邮箱一般只需要在首次验证证书或者更改邮箱时添加。\n\n##### 2. Apache\nApache中的验证方法与上类似\n<pre><code>sudo certbot --apache</code></pre>\n\n##### 3. Webroot模式\n上述方法会重启我们的web服务以重新加载配置文件，如果我们希望在颁发证书时，不重启web服务，则可以使用webroot模式。webroot模式下，certbot 会利用已经部署的 web 服务，在其 web 服务根目录下创建名为<span class=\"tips\">/.well-known/acme-challenge</span>的隐藏文件，然后由 Let’s Encrypt 服务端通过域名来访问该隐藏文件，从而完成验证。\n\n因此，在执行命令时，我们需要添加<span class=\"tips\">-w</span>参数来引导certbot找到web服务的根目录\n\n<pre><code>certbot certonly --webroot -w 网站根目录 -d 域名</code></pre>\n如：Nginx默认放置网页的根目录为：<span class=\"tips\">/usr/local/nginx/html</span>，则对应命令为\n<div class=\"show\"><code>certbot certonly --webroot -w /usr/local/nginx/html -d shiwivi.com</code></div>\n\n\n##### 3. Standalone模式\n如果服务器上没有部署任何web服务，或者不想使用已部署的服务，则可以使用Standalone模式，该模式下，certbot 会自动运行一个 web server 来进行验证。该服务需要占用<span class=\"tips\">80</span>端口，如果我们自己的服务器上已经有 web server 正在运行 （如 Nginx 或 Apache ）并且占用了80端口，则使用Standalone前应该关闭相关服务或修改端口。\n<pre><code>certbot certonly --standalone -d 域名</code></pre>\n可以在命令中指定验证的端口和协议\n<div class=\"show\"><code>certbot certonly --standalone --&lt;challenge-type>-address  -d 域名</code></div>\n\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n更多验证方法详见官方文档：<a href=\"https://eff-certbot.readthedocs.io/en/stable/\">https://eff-certbot.readthedocs.io/en/stable/</a></div>\n\n#### 申请流程\ncertbot完成认证后会开始进入申请流程，初次申请证书，可能需要经历以下流程：\n\n+ certbot会提示你阅读并同意使用者条款\n+ 让你输入一个email地址以推送消息，在证书快到期时，lets encrypt会发邮件提醒你及时更新证书\n+ 询问是否愿意将该邮箱提供给EFF，他们会推送有关lets encrypt 的资讯\n\n邮箱的添加可以在一开始使用<span class=\"tips\"></span>\n\n\n证书申请成功后，certbot会返回如下提示信息，其中较为重要的信息包括证书与密钥路径，证书到期时间\n\n<div class=\"shell\">IMPORTANT NOTES:\n - Congratulations! Your certificate and chain have been saved at:\n   /etc/letsencrypt/live/newyear1234.xyz/fullchain.pem\n   Your key file has been saved at:\n   /etc/letsencrypt/live/newyear1234.xyz/privkey.pem\n   Your certificate will expire on 2022-10-27. To obtain a new or\n   tweaked version of this certificate in the future, simply run\n   certbot again. To non-interactively renew *all* of your\n   certificates, run \"certbot renew\"\n - If you like Certbot, please consider supporting our work by:\n\n   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate\n   Donating to EFF:                    https://eff.org/donate-le</div>\n\n#### 插件未安装报错问题\n以nginx为例，执行<span class=\"tips\">sudo certbot -&zwnj;-nginx</span>时，可能会有nginx插件未被正确安装报错\n<div class=\"shell\">The requested nginx plugin does not appear to be installed</div>\n\n安装nginx插件\n<pre><code>yum install python-certbot-nginx</code></pre>\n\n问题叠问题，如果源中没有该插件包，又可能会遇到报错提示无有效的包\n<div class=\"shell\">No package python-certbot-nginx available.\nError: Nothing to do</div>\n\n此时需要更换一下repo 源，更换前记得先将自己的源的备份\n<pre><code>yum remove -y epel-release  # 先移除当前的包</code></pre>\n<pre><code>yum clean all -v     # 清除所有下载缓存的包，并显示过程</code></pre>\n<pre><code>yum makecache        # 重新将远程服务器的包下载缓存到本地</code></pre>\n<pre><code>yum install -y epel-release # 重新安装 epel </code></pre>\n\n安装完epel，再重新尝试安装插件，安装完成就可以开始申请证书了\n<pre><code>yum install python-certbot-nginx</code></pre>\n\n#### web服务无法找到报错问题\n执行<span class=\"tips\">sudo certbot -&zwnj;-nginx</span>时，还可能会遇到 certbot 无法找到 web server 或配置文件报错，这是路径问题，可以建一个软链接到 /etc/nginx 目录下\n<pre><code>ln -s /usr/local/nginx/conf/ /etc/nginx</code></pre>\n或者在申请证书时手动指定nginx配置文件路径\n<pre><code>certbot --nginx-server-root /usr/local/nginx/conf</code></pre>\n\n### 文件说明\n证书申请成功后，相关文件会放置在<span class=\"tips\">/etc/letsencrypt</span>目录下，一般就用得到证书和密钥文件\n#### 密钥与证书\n证书和密钥位于 <span class=\"tips\">/etc/letsencrypt/live/域名.xx/</span> 路径下，该路径下有如下几个文件（配置时一般只需要fullchain.pem和privkey.pem文件）：\n\n+ <span class=\"strong\">fullchain.pem：</span>完整的证书链文件，包含了cert.pem和chain.pem文件中的内容\n+ <span class=\"strong\">privkey.pem：</span>证书对应的私钥\n+ cert.pem：证书文件，需要与chain.pem文件结合使用\n+ chain.pem：链文件，包含了浏览器解析所需的其他全部证书，比如根证书和中间证书\n+ README：说明文件\n\n#### 通用配置文件\n在<span class=\"tips\">/etc/letsencrypt</span>路径下会生成Nginx的通用配置文件<span class=\"tips\">options-ssl-nginx.conf</span>\n<div class=\"shell\">ssl_session_cache shared:le_nginx_SSL:10m;\nssl_session_timeout 1440m;\n\nssl_protocols TLSv1.2;\nssl_prefer_server_ciphers off;\n\nssl_ciphers \"FCDHE-FCLSA....\";</div>\n\n+ ssl_session_cache：会话缓存\n+ ssl_session_timeout：用户会话缓存失效时间，如果对安全性有较高要求，可以降低此值\n+ ssl_protocols：加密协议\n+ ssl_prefer_server_ciphers：是否开启服务端加密算法优先\n+ ssl_ciphers：加密算法列表\n\n#### 密钥交换\n在<span class=\"tips\">/etc/letsencrypt</span>路径下还有一个用于密钥交换算法的Diffie-Hellman 密钥<span class=\"tips\">ssl-dhparams.pem</span>\n\n#### 历史文件\n<span class=\"tips\">/etc/letsencrypt/archive</span>和<span class=\"tips\">/etc/letsencrypt/keys</span>包含所有以前的密钥和证书，而<span class=\"tips\">/etc/letsencrypt/live</span>目录下保存了最新的证书和密钥\n\n#### 日志文件\n默认情况下，certbot 的日志文件位于/var/log/letsencrypt 路径下。且默认情况下，一旦日志目录中有 1000 条日志，certbot 就会开始日志轮替。\n\n\n\n### Nginx配置文件\n\n<div class=\"show\">server {\nlisten 443 ssl;\n\n#配置SSL证书和密钥路径\nssl_certificate    /etc/letsencrypt/live/域名/fullchain.pem;\nssl_certificate_key    /etc/letsencrypt/live/域名/privkey.pem;\n\n#可以将certbot生成的通用配置文件包含进去，自由选择\ninclude    /etc/letsencrypt/options-ssl-nginx.conf;\n\n#使用生成的Diffie-Hellman 密钥，自由选择\nssl_dhparam    /etc/letsencrypt/ssl-dhparams.pem;\n......\n}</div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nDiffie-Hellman密钥用于密钥交换</div>\n\n\n### 常用命令\n#### 测试自动续订\n+ <span class=\"strong\">sudo certbot renew -&zwnj;-dry-run</span> 测试更新证书\n\n如果测试成功，certbot会返回成功信息\n<div class=\"shell\">- - - - -\nAccount registered.\nSimulating renewal of an existing certificate for newyear110.xyz\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nCongratulations, all simulated renewals succeeded: \n  /etc/letsencrypt/live/newyear110.xyz/fullchain.pem (success)\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </div>\n\n##### 插件未安装报错\n在测试续订时，如果遇到插件未安装的报错，则需要安装nginx插件\n<div class=\"shell\">Failed to renew certificate newyear110.xyz with error: \nThe requested nginx plugin does not appear to be installed</div>\n\n安装<span class=\"tips\">letsencrypt-nginx</span>插件\n<pre><code>pip3 install -U letsencrypt-nginx</code></pre>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n更多关于插件未安装的报错，可以查看github上的Issues，上述解决方法也来源于该贴：<a href=\"https://github.com/certbot/certbot/issues/1736\">https://github.com/certbot/certbot/issues/1736</a></div>\n\n#### 续订证书\n\n+ <span class=\"strong\">certbot renew</span> 自动更新30天内到期的证书（推荐）\n+ <span class=\"strong\">certbot renew -&zwnj;-force-renewal</span> 强制更新未到期的证书\n\n\n\n在初次申请证书时，certbot会记住所使用的配置和插件，并在续订时使用相同的配置和插件。如果需要更改配置（如：修改文件路径），则需要以下步骤\n1. 在命令行中使用修改以后的配置进行一次测试自动续订\n2. 测试成功，说明新的配置是可以运行的，再执行一次证书更新（时间未到就使用强制更新），这将保存新的配置\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nCA机构会限制证书颁发速度并阻止用户在短时间内多次续订同一个域名的证书，所以不要在短时间内多次执行强制更新证书操作</div>\n\n\n\n\n\n#### 查看证书列表\n+ <span class=\"strong\">certbot certificates</span> 查看证书\n\n会返回当前所有域名的证书情况，包括证书名、 证书序列号、密钥类型、到期时间、证书路径、私钥路径信息\n<div class=\"show\">Found the following certs:\n  Certificate Name: newyear110.xyz\n    Serial Number: 34829c6e3465f2b1b90db11c36111480280\n    Key Type: RSA\n    Domains: newyear110.xyz\n    Expiry Date: 2022-10-27 11:47:25+00:00 (VALID: 87 days)\n    Certificate Path: /etc/letsencrypt/live/newyear110.xyz/fullchain.pem\n    Private Key Path: /etc/letsencrypt/live/newyear110.xyz/privkey.pem\n</div>\n\n#### 吊销与删除证书\n删除与吊销证书前，应当从web服务器软件的配置文件中删除对对应证书的引用\n+ <span class=\"strong\">certbot revoke -&zwnj;-cert-name 域名.xxx</span> 吊销证书(根据域名)\n+ <span class=\"strong\">certbot revoke -&zwnj;-cert-path /etc/letsencrypt/live/域名.xxx/cert.pem</span> 吊销证书(根据路径)\n+ <span class=\"strong\">certbot delete -&zwnj;-cert-name 域名.xxx</span> 删除指定证书\n+ <span class=\"strong\">certbot delete</span> 从列表中选择删除证书\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n官方命令和文档：<a href=\"https://eff-certbot.readthedocs.io/en/stable/using.html\">https://eff-certbot.readthedocs.io/en/stable/using.html</a></div>\n","tags":["Server","Web"]},{"title":"路由与路由守卫","url":"/blog/2022/07/16/路由与路由守卫/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nvue路由官方网站：<a href=\"https://router.vuejs.org/zh/\">https://router.vuejs.org/zh/</a></div>\n\n### 入门\n#### 介绍\n+ Vue Router 是Vue的官方路由插件，用于构建单页应用\n+ 页面不刷新，配合ajax实现页面的局部更新，并响应式更新地址栏URL\n+ 在工程中，普通组件一般放在components下，而路由组件放于pages目录下\n+ 切换组件时，未调用的组件是被销毁的，调用时被挂载\n+ 整个应用由一个<span class=\"tips\">router</span>(路由器)统一管理，通过<span class=\"tips\">$router</span>调用\n+ 但每个路由组件都有自己的<span class=\"tips\">$route</span>属性\n\n#### 安装vue router\nvue2的工程使用vue-router3，vue3的工程使用vue-router4，版本需要对应，这里以安装vue-router3为例\n\n在脚手架中执行：\n<code><pre>npm i vue-router@3</pre></code>\n\n### 路由的使用\n案例：通过组件嵌套，实现功能\n1. 在app单个页面中通过按钮实现Home和About页面的切换\n2. About页面中嵌套aboutMe和aboutWeb页面\n\n<span class=\"strong\">1. 新建pages目录，存放Home.vue、About.vue、aboutMe、aboutWeb组件</span>\n\nHome.vue文件:\n<pre><code>&lt;template>\n  &lt;div class=\"home\">\n    &lt;h2>Home页面&lt;/h2>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n    name:'pageHome'\n  }\n&lt;/script></code></pre>\n\nAbout.vue文件:\n<pre><code>&lt;template>\n  &lt;div class=\"about\">\n    &lt;h2>About页面&lt;/h2>\n    &lt;div class=\"about-btn\">\n    &lt;!--router-link标签路由切换按钮的两种写法，该标签最后会被解析为a标签-->\n    &lt;!--1. 根据路径调用组件-->\n    &lt;router-link to=\"/about/aboutWeb\">关于网页&lt;/router-link> \n    &lt;router-link to=\"/about/aboutMe\">关于我&lt;/router-link> \n    &lt;!--2. 根据路由规则中的name属性调用组件-->\n    &lt;router-link :to=\"{name: 'aboutme'}\">关于网页&lt;/router-link> \n    &lt;router-link :to=\"{name: 'aboutweb'}\">关于我&lt;/router-link> \n    &lt;/div>\n    &lt;div class=\"about-content\">\n    &lt;!--子组件显示的位置-->\n    &lt;router-view>&lt;/router-view> \n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n &lt;script>\n export default {\n     name:'pageAbout'\n }\n&lt;/script></code></pre>\n\naboutWeb.vue文件 (aboutMe.vue类似)\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">{{t}}&lt;/li>\n    &lt;/ul>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:{\n                前端:'html/css/javaScript',\n                后端:'java',\n                系统:'CentOS7',\n                服务器:'nginx'\n            }\n        }\n    }\n }\n&lt;/script></code></pre>\n\n<span class=\"strong\">2. 新建router目录，新建index.js文件用于创建路由器</span>\nindex.js文件：\n<pre><code>// 引入vueRouter插件\nimport VueRouter from \"vue-router\";\n//引入路由组件\nimport Home from '../pages/pageHome'\nimport About from '../pages/pageAbout'\nimport aboutMe from '../pages/aboutMe'\nimport aboutWeb from '../pages/aboutWeb'\n// 创建路由器\nexport default new VueRouter({\n    // 创建路由规则一个{}内为一条路由\n    routes:[\n        {\n            name: 'home',    //路由规则指定的组件别名\n            path:'/home',   //路由路径\n            component:Home //调用的组件\n        },\n        {   \n            name: 'about',\n            path:'/about',\n            component:About,\n            children:[     //组件嵌套\n                {   \n                    name:'aboutme',\n                    path:'aboutMe',\n                    component:aboutMe\n                },\n                {   \n                    name:'aboutweb',\n                    path:'aboutWeb',\n                    component:aboutWeb\n                }\n            ]\n        }\n    ]\n })\n</code></pre>\n\n<span class=\"strong\">3. 在main.js中引入路由器</span>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\n// 引入vue-router\nimport VueRouter from 'vue-router'\n// 使用vue-router\nVue.use(VueRouter)\n// 引入创建的路由器\nimport router from './router'\nnew Vue({\n  render: h => h(App),\n  router:router   //配置路由器\n}).$mount('#app')</code></pre>\n\n<span class=\"strong\">4. 在App中调用路由组件</span>\n\n<pre><code>&lt;template>\n  &lt;div id=\"app\">\n    &lt;div class=\"btn\">\n      &lt;!-- active-class用于指定该链接按钮被选中时生效的样式-->\n      &lt;router-link class=\"link\" active-class=\"active\" to=\"/home\">Home&lt;/router-link>\n      &lt;router-link class=\"link\" active-class=\"active\" to=\"/about\">About&lt;/router-link>\n      &lt;!-- 同样，to可以写为对象形式 -->\n      &lt;router-link class=\"link\" active-class=\"active\" :to=\"{name:'home'}\">Home&lt;/router-link>\n      &lt;router-link class=\"link\" active-class=\"active\" :to=\"{name:'about'}\">About&lt;/router-link>\n    &lt;/div>\n    &lt;div class=\"content\">\n      &lt;!-- 指定组件显示的位置 -->\n      &lt;router-view>&lt;/router-view>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n  name:'App',\n }\n&lt;/script></code></pre>\n\n### 路由传参\n#### query传参\n父组件可通过向<span class=\"tips\"> to </span>属性添加参数进行传参，类似于带参数的http请求，子路由可通过<span class=\"tips\">$route.query.参数名</span>读取数据\n\n案例：为aboutWeb组件添加子组件webTech，并由aboutWeb向webTech传参\n\n##### 方法1：通过字符串传参\n在路由路径后添加查询字符串<span class=\"tips\"> ? </span>，并在之后以键值对的方式传参。\n\n父组件 aboutWeb.vue\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">\n        &lt;!-- 字符串写法 -->\n        &lt;!-- 注意：由于to前使用了:解析js语法，因此要添加``将语句解析为字符串 -->\n        &lt;router-link :to=\"`/about/aboutWeb/webTech?name=${t.name}&lang=${t.language}`\">{{t.name}}&lt;/router-link>\n        &lt;/li>\n    &lt;/ul>\n    &lt;router-view>&lt;/router-view>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:[\n                {name:'前端',language:'html/css/javaScript'},\n                {name:'框架',language:'vue'},\n                {name:'后端',language:'java'},\n                {name:'系统',language:'CentOS7'},\n                {name:'服务器',language:'nginx'},\n                ]\n            }\n        }\n }\n&lt;/script></code></pre>\n\n##### 方法2：通过对象传参\n\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">\n        &lt;!-- 对象写法 -->\n            &lt;router-link :to=\"{\n            path:'/about/aboutWeb/webTech',\n            query:{\n                name:t.name,\n                lang:t.language\n            }\n            }\">\n            {{t.name}}\n            &lt;/router-link>\n        &lt;/li>\n    &lt;/ul>\n    &lt;router-view>&lt;/router-view>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:[\n                {name:'前端',language:'html/css/javaScript'},\n                {name:'框架',language:'vue'},\n                {name:'后端',language:'java'},\n                {name:'系统',language:'CentOS7'},\n                {name:'服务器',language:'nginx'},\n                ]\n            }\n        }\n }\n&lt;/script></code></pre>\n\n##### 子路由读取参数\nwebTech.vue文件：\n<pre><code>&lt;template>\n  &lt;div class=\"show\">\n  &lt;!-- 读取数据 -->\n    &lt;span class=\"tech-name\">{{$route.query.name}}：&lt;/span>\n    &lt;span class=\"tech-lang\">{{$route.query.lang}}&lt;/span>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n export default {\n    name:'webTech'\n }\n&lt;/script></code></pre>\n\n#### params传参\n##### 方法1：通过字符串传参\n通过字符串传参时，必须在配置路由规则时在<span class=\"tips\">path</span>路径中指定解析的参数\n\n<pre><code> {   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    path:'webTech/:name/:lang', //在路径中解析参数\n    conpontent:webTech\n  }]\n      }</code></pre>\n\n父组件通过附带参数的路径传输参数\n<pre><code>&lt;router-link :to=\"`/about/aboutWeb/webTech?name=${t.name}&lang=${t.language}`\">{{t.name}}&lt;/router-link></code></pre>\n\n子组件通过<span class=\"tips\">$route.params.参数名</span>读取参数\n<pre><code>&lt;span class=\"tech-name\">{{$route.params.name}}&lt;/span>\n&lt;span class=\"tech-lang\">{{$route.params.lang}}&lt;/span></code></pre>\n\n##### 方法2：通过对象传参\n通过对象传参时，<span class=\"tips\">to</span>属性不能再使用<span class=\"tips\">path</span>调用组件，而需要使用<span class=\"tips\">name</span>属性，因此路由规则中一定需要给予组件name属性\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' //必须\n    path:'webTech/:name/:lang', //必须\n    conpontent:webTech\n  }]\n      }</code></pre>\n\n传参的父组件\n<pre><code>&lt;router-link :to=\"{\n            name:'webtech', //不能使用path\n            params:{\n                name:t.name,\n                lang:t.language\n            }}\">\n            {{t.name}}\n&lt;/router-link></code></pre>\n子组件通过<span class=\"tips\">$route.params.参数名</span>读取参数，代码同上\n\n#### props属性\n当需要大量调用参数时，频繁使用$route.query增加了代码量，可以在路由中配置<span class=\"tips\">props</span>属性简化代码。props属性支持三种配置方法。\n\n##### 1. 对象形式，传输固定参数\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' \n    path:'webTech',\n    conpontent:webTech,\n    //对象形式，传输固定参数\n    props:{ name:'框架',\n            lang:'Vue'}\n  }]\n      }</code></pre>\n##### 2. 函数形式，传输指定参数(用query)\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' \n    path:'webTech',\n    conpontent:webTech,\n    //对象形式，传输固定参数\n    pros(route){\n      return {\n        name: route.query.name,\n        lang: route.query.language\n      }\n    }\n  }]\n      }</code></pre>\n\n##### 3. 布尔值，自动传输所有params参数\n<pre><code>{   \n  name:'aboutweb',\n  path:'aboutWeb',\n  component:aboutWeb,\n  children:[{\n    name:'webtech' \n    path:'webTech/:name/:lang', //自动传输所有参数\n    conpontent:webTech,\n    //布尔值形式\n    pros: true\n  }]\n      }</code></pre>\n##### 接收参数\n子组件需要通过<span class=\"tips\">props</span>属性接收参数\n<pre><code>&lt;span>{{name}}&lt;/span> //直接调用\n&lt;span>{{lang}}&lt;/span>\nexport default{\n   name:'webTech',\n  pros:['name','lang'] //接收参数\n   }</code></pre>\n\n### 路由导航\n路由导航分为声明式和编程式\n+ <span class=\"strong\">声明式：</span>通过&lt;router-link>配置to属性实现跳转\n+ <span class=\"strong\">编程式：</span>通过调用push、back等API跳转组件\n\n#### 路由导航与浏览器历史记录\n浏览器历史记录默认为<span class=\"tips\">push</span>状态，组件的跳转会记录到历史记录中，通过浏览器的前进/后退按钮，或者调用<span class=\"tips\">go</span>、<span class=\"tips\">back</span>等API，能根据历史记录实现页面的前进、回退。当浏览器历史记录切换为<span class=\"tips\">replace</span>状态时，浏览器会使用当前页面的记录替换掉上一条历史记录。\n<pre><code> &lt;--跳转到About页面后，About页面的历史记录会替换掉该页的历史记录，此时无法再使用浏览器的回退按钮返回该页面了-->\n&lt;router-link replace to=\"...\">跳转到About页面&lt;/router-link></code></pre>\n\n#### 编程式路由导航\n不借助&lt;router-link>标签，实现路由跳转\nAPI：\n+ <span class=\"strong\">push：</span>跳转到指定路由组件\n+ <span class=\"strong\">replace：</span>跳转到指定路由组件并替换浏览器历史记录\n+ <span class=\"strong\">back：</span>回退\n+ <span class=\"strong\">forward：</span>前进(需要之前回退过)\n+ <span class=\"strong\">go(值)：</span>根据值前进/回退指定次数\n\neg：通过按钮实现(或div)实现路由跳转\n<pre><code>&lt;template>\n  &lt;div>\n   &lt;button class=\"link\" @click=\"backTo\">回退&lt;/button>\n    &lt;button class=\"link\" @click=\"forwardTo\">前进&lt;/button>\n    &lt;button class=\"link\" @click=\"goTo\">跳转&lt;/button>\n    &lt;ul>\n        &lt;li v-for=\"(t,index) in tech\" :key=\"index\">\n            &lt;button @click=\"pushTo(t)\">push&lt;/button>\n            &lt;button @click=\"replaceTo(t)\">replace&lt;/button>\n        &lt;/li>\n    &lt;/ul>\n    &lt;router-view>&lt;/router-view>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n export default {\n    name:'aboutWeb',\n    data(){\n        return{\n            tech:[\n                {name:'前端',language:'html/css/javaScript'},\n                {name:'后端',language:'java'},\n                {name:'系统',language:'CentOS7'},\n                {name:'服务器',language:'nginx'},\n                ]\n            }\n        },\n    methods:{\n        backTo(){\n      this.$router.back() //回退一次\n    },\n    forwardTo(){\n      this.$router.forward() //前进一次\n    },\n    goTo(){\n      this.$router.go(-2) //，回退2步，正数前进，负数后退\n    },\n        pushTo(m){    //跳转到指定组件\n            this.$router.push({\n                path:'/about/aboutWeb/webTech',\n                query:{\n                name:m.name,\n                lang:m.language\n            }\n            })\n        },\n        replaceTo(n){  //跳转到指定组件并替换上一个历史记录\n            this.$router.replace({\n                path:'/about/aboutWeb/webTech',\n                query:{\n                name:n.name,\n                lang:n.language\n            }\n            })\n        }\n    }\n }\n&lt;/script></code></pre>\n\n### 路由组件的缓存\n当组件进行切换时，原组件会被销毁，原组件中未保存的表单内容等数据同时也会被删除，此时，可以使用<span class=\"tips\">&lt;keep-alive></span>标签阻止组件被销毁，保留数据。\n\n<pre><code> //缓存多组件使用 :include=\"['组件1','组件2',...]\"\n&lt;keep-alive include=\"aboutMe\"> \n  &lt;router-view>&lt;/router-view>\n&lt;/keep-alive></code></pre>\n\n### 路由独有生命周期\n+ <span class=\"strong\">activated：</span>当组件被激活时(显示到页面)\n+ <span class=\"strong\">deactivated：</span>当组件失活时\n当组件被&lt;keep-alive>时，组件不会被销毁，在切换组件时created、destory等钩子函数不会执行，此时可以使用activated、deactivated替代。\n\neg：使某组件在激活时启用定时器，失活时关闭\n<pre><code> export default {\n  name:'webTech',\n  data(){.....},\n  activated(){\n            let timer=setInterval(....);\n            },\n  deactivated(){\n            clearInterval(this.timer)\n            }\n }</code></pre>\n\n ### 路由守卫\n 在切换组件时，可借助路由守卫来阻止/放行组件的跳转，常用于判断用户是否有权限访问，无权限时阻止访问,也可用于在组件跳转前后执行某些功能。\n\n #### 前置、后置路由守卫(全局)\n 该路由守卫写于路由器配置文件中\n+ <span class=\"strong\">beforeEach((to,from,next)=>{ })：</span>前置路由守卫，在<span class=\"tips\">初始化、路由跳转前</span>执行，接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行\n+ <span class=\"strong\">beforeEach((to,from)=>{ })：</span>后置路由守卫，在<span class=\"tips\">路由跳转后</span>执行，接收to,from两个参数\n\n\neg: 检查用户是否为指定用户，不是则禁止访问aboutWeb和aboutMe组件\n<pre><code> import VueRouter from \"vue-router\";\n import Home from '../pages/pageHome'\n import About from '../pages/pageAbout'\n import aboutMe from '../pages/aboutMe'\n import aboutWeb from '../pages/aboutWeb'\n import webTech from '../pages/webTech'\n const router= new VueRouter({\n    routes:[\n        {\n            name:'home',\n            path:'/home',   \n            component:Home, \n            meta:{title:'首页'}//meta为自定义属性，程序员可自定义添加任何参数\n        },\n        {\n            name:'about',\n            path:'/about',\n            component:About,\n            meta:{title:'关于'},\n            children:[\n                {\n                    name:'aboutme',\n                    path:'aboutMe',\n                    component:aboutMe,\n                    meta:{isAuth:true,//标识该组件是否需要鉴别权限\n                          title:'关于我'}//用于组件跳转后修改地址栏标题\n                },\n                {\n                    name:'aboutweb',\n                    path:'aboutWeb',\n                    component:aboutWeb,\n                    meta:{isAuth:true,\n                        title:'关于网站'},\n                    children:[\n                        {\n                            name:'webTech',\n                            path:'webTech',\n                            component:webTech,\n                            meta:{title:'关于本站采用的技术'}\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n })\n// 全局前置路由守卫\n router.beforeEach((to,from,next)=>{\n        if(to.meta.isAuth){//确认是否鉴权，避免对所有组件都进行鉴权消耗性能\n // 当组件不多时，可以使用下面的代码通过判断路径来识别哪些组件需要权限认证\n        // if(to.name==='aboutme'||to.path==='/about/aboutWeb')\n        //只有localStorage中的user为zhoujielun才能访问\n            if(localStorage.getItem('user')==='zhoujielun'){\n                next() //放行访问\n            }\n            else{\n                alert('无权限访问')\n            }\n        }\n        else{\n            next()  //对不需要权限认证的页面直接放行\n        } \n })\n// 全局后置路由守卫\n//用于切换完毕后，修改网页地址栏的标题\n router.afterEach((to)=>{\n    document.title=to.meta.title  \n })\n export default router</code></pre>\n\n#### 独享路由守卫\n只为某个路由组件配置的路由守卫， 同样写于路由器配置文件中\n<span class=\"strong\">beforeEnter:(to,from,next)=>{ }</span>只对针对某个组件配置守卫，同样接收to,from,next三个参数，to代表即将跳转的组件，from为来源组件，next代表放行\n \neg: 判断用户是否为指定用户，不是则禁止访问aboutMe组件\n<pre><code>{\n            name:'about',\n            path:'/about',\n            component:About,\n            meta:{title:'关于'},\n            children:[\n                {\n                    name:'aboutme',\n                    path:'aboutMe',\n                    component:aboutMe,\n                    meta:{isAuth:true,//鉴别权限\n                          title:'关于我'},\n                          //独享路由守卫\n                          beforeEnter:(to,from,next)=>{\n                                if(to.meta.isAuth){\n                                  //只有localStorage中的user为zhoujielun才能访问\n                                    if(localStorage.getItem('user')==='zhoujielun'){\n                                        next()\n                                    }\n                                    else{\n                                        alert('无权限访问')\n                                    }\n                                }\n                                else{\n                                    next()\n                                } \n                          }\n                },</code></pre>\n\n#### 组件内路由守卫\n无法修改路由器配置文件时，可以将路由守卫设于组件.vue的文件中。<span class=\"tips\">组件内的路由守卫只会在通过路由规则进入组件时才会执行</span>，如果将组件标签直接添加到页面中，该组件会被调用，但此时不属于通过路由规则进入组件，不会执行下述路由守卫函数。\n\n+ <span class=\"strong\">beforeRouteEnter(to,from,next){ }</span>：进入组件前执行\n+ <span class=\"strong\">beforeRouteLeave(to,from,next){ }</span>：离开组件前执行\n+ <span class=\"strong\">beforeRouteUpdate(to,from,next){ }</span>：组件更新时执行\n\n<pre><code>&lt;template>\n  &lt;div class=\"about\">\n    &lt;h2>About页面&lt;/h2>\n    &lt;div class=\"about-btn\">\n    &lt;router-link  to=\"/about/aboutWeb\">关于网页&lt;/router-link>\n    &lt;router-link  to=\"/about/aboutMe\">关于我&lt;/router-link>\n    &lt;/div>\n    &lt;div class=\"about-content\">\n      &lt;keep-alive include=\"aboutMe\">\n      &lt;router-view>&lt;/router-view>\n      &lt;/keep-alive>\n    &lt;/div>\n  &lt;/div>\n &lt;/template>\n &lt;script>\n export default {\n    name:'pageAbout',\n    // 通过路由规则进入组件时调用\n    beforeRouteEnter(to,from,next){\n      //只有localStorage中的user为zhoujielun才能访问\n            if(localStorage.getItem('user')==='zhoujielun'){\n                    next()\n                    }\n            else{\n                 alert('无权限访问')\n             }\n    },\n     // 通过路由规则离开组件时调用\n    beforeRouteLeave(to,from,next){\n      console.log('即将离开组件')\n        next();//放行\n    }\n}\n &lt;/script></code></pre>","tags":["web","vue"]},{"title":"yaml语法","url":"/blog/2022/07/14/yaml语法/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nYAML官方文档：<a href=\"https://yaml.org/spec/1.2.2/\">YAML 1.2.2</a></div>\n\n### 简介\n#### 关于\nYAML是一种数据序列化语言，可用于存储和传输数据，常用于编写配置文件、数据文件、日志文件，以及跨语言进行数据共享等环境，大多数编程语言都可以使用 YAML 进行数据序列化。\n\nYAML文件后缀为<span class=\"tips\">.yml</span>或<span class=\"tips\">.yaml</span>\n\n#### 基本语法\n<span class=\"strong\">1. 通常使用键值对形式</span>\n\n+ 键与值通常不需要引号包裹 (这点与json不同)\n+ 值可以为：数组、对象、标量值\n+ 标量值是指：整数、浮点数、字符串、布尔值、Null、时间、日期\n\n<span class=\"strong\">2. 通过缩进或者样式流表示数据结构</span>\n\n+ 数据可以通过空格缩进来表示层级关系，但不能用制表符(Tab)\n+ 子结构相较父结构必须缩进至少一个空格，同一级数据须缩进相同空格数，即左端对齐\n+ 也可以使用花括号{&nbsp;}，中括号[&nbsp;]等样式流表示层级关系\n<span class=\"strong\">3. 大小写敏感</span>\n<span class=\"strong\">4. 使用#号注释</span>\n\n\n### 对象\n最为常用的数据类型，又称为字典、哈希、映射，以<span class=\"tips\"> key: &nbsp;value </span>键值对的形式存储数据，<span class=\"tips\">key: 后需要有空格!</span>\n#### 对象写法\n<div class=\"show\">name: JayChou\nalbum: 十一月的萧邦\n</div>\n\n或者使用样式流：\n<div class=\"show\">{\n    name: JayChou,\n    album: 十一月的萧邦\n}\n</div>\n等同于json格式下的\n<div class=\"show\">{\n  \"name\": \"JayChou\",\n  \"album\": \"十一月的萧邦\"\n}\n</div>\n\n#### 缩进与嵌套\n可以通过缩进至少一个空格表示层级关系，从而嵌套其他对象、数组等\n<div class=\"show\">student:\n   name: aaa\n   age: 16\n   hobby:\n    - basketball\n    - swimming</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n多级嵌套时，每层嵌套都应当缩进，<span class=\"tips\">且每个子元素左边应该缩进相等的空格数，即左端对齐</span></div>\n   使用样式流：\n   <div class=\"show\">student: {\n        name: aaa,\n        age: 16,\n        hobby: [ basketball , swimming ]\n   }</div>\n\n#### 复杂对象格式\n使用<span class=\"tips\">?加空格</span>可以指定多个key值，使用<span class=\"tips\">:加空格</span>指定多个value\n<div class=\"show\">? \n      - key1\n      - key2\n: \n      - value1\n      - value2</div>\n    表示key是一个数组，值也是一个数组，样式流：\n    <div class=\"show\">key1,key2: [\"value1\",\"value2\"]</div>\n\n### 数组\n使用<span class=\"tips strong\">-</span>开头表示数组元素\n#### 数组写法\n<div class=\"show\">- value1\n- value2\n- value3</div>\n样式流：\n<div class=\"show\">[value1,value2,value3]</div>\n\n#### 缩进与嵌套\n可以通过缩进表示层级关系，来嵌套数组、对象等\n<div class=\"show\">- name: 周杰伦,\n  age: 42,\n  songs: \n   - 夜曲\n   - 米兰的小铁匠\n- name: 林肯公园,\n  age: 41,\n  songs:\n   - In the End\n   - Numb\n</div>\n样式流\n<div class=\"show\">[\n  {\n    name: 周杰伦,\n    age: 42,\n    songs: [ 夜曲 , 米兰的小铁匠 ]\n  },\n  {\n    name: 林肯公园,\n    age: 41,\n    songs: [ In the End , Numb ]\n  }\n]</div>\n\n### 标量\n标量指最基本的，不可再分的值，这里指：整数、浮点数、字符串、布尔值、Null、时间、日期\n\n基本使用方法：\n<div class=\"show\">1. 整数可以为非十进制数\nnum1: 120           #普通十进制数\nnum2: 0b10_1011     #二进制以0b开头\nnum3: 07100         #八进制以0开头\nnum4: 0xf1ab        #十六进制以0x开头\n2. 浮点数可以使用科学计数法\nfloat1: 3.14\nfloat2: 3.1415926e+5 #科学计数法314159.26\nfloat3: -.inf        #负无穷大\nflota4: .nan         #不是数字\n3. 布尔值大小写均可\nbool: true\n值为：true、True、TRUE均可，但TRUe将被解析为字符串\n4. Null可用<span class=\"tips\">~</span>表示\ndata: ~\n5. 日期必须使用ISO 8601格式，即yyyy-MM-dd\ndate: 2021-07-15\n6. 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\ntime: 2021-07-15T00:42:31+08:00\n在JavaScript中解析为Thu Jul 15 2021 00:42:31 GMT+0800 (中国标准时间)\n7. 使用<span class=\"tips\">!!数据类型 值</span>进行类型转换\ndate: !!str 2021-01-15\n</div>\n\n### 字符串处理\n一般情况下，字符串不需要添加引号，但如果字符串中间包含特殊字符，尤其是<span class=\"tips\">冒号加空格</span>组合时，为了避免被yaml解析为键值对，需要添加引号\n<div class=\"show\">str: 'said: meet you like wind'</div>\n\n给数值等标量添加引号将解析为字符串\n<div class=\"show\">str: '99.99'</div>\n\n多行字符串，<span class=\"tips\">第二行开始所有行需要缩进至少一个空格</span>，但解析时将被解析为一行字符串，且换行符会被替换为空格\n<div class=\"show\">str: aaaa\n bbbb\n cccc\n 将被解析为\n str: \"aaaa bbbb cccc\"</div>\n\n #### 单引号与双引号\n 单引号和双引号均可以用于包裹字符串\n + <span class=\"strong\">单引号会原样输出，将转义字符作为普通字符串输出</span>\n + <span class=\"strong\">双引号会转义字符串，如将 \\n 转义为换行</span>\n\n<div class=\"show\">如：\ncontent: '不会\\n换行'\n内容输出为：\n<span class=\"tips\">不会\\n换行</span>\ncontent: \"进行\\n换行\"\n内容输出为：\n <span class=\"tips\">进行\n  换行</span>\n</div>\n\n#### 区块字符串处理\n1. 多行字符串可以使用<span class=\"tips strong\">|</span>保留所有换行符，内容从第二行开始需要缩进至少一个空格，且最后一行的换行符也会保留。\n<div class=\"show\">lyrics: |\n aaaa \n bbbb\n cccc \n dddd\n</div>\n输出为：\n<div class=\"show\">aaaa \n bbbb\n cccc \n dddd\n <br/></div>\n\n2. 可以使用<span class=\"tips strong\">></span>去除换行，换行符将被空格代替 (如果某一行是空行，该空行会被额外保留)\n<div class=\"show\">lyrics: >\n aaaa \n bbbb\n cccc \n dddd</div>\n 输出为：\n<div class=\"show\">aaaa bbbb cccc dddd</div>\n\n3. 可以使用<span class=\"tips strong\">+</span>保留文字块末尾的换行\n<div class=\"show\">lyrics: |+\n aaaa \n bbbb\n cccc \n dddd</div>\n 输出为：\n<div class=\"show\">aaaa \n bbbb\n cccc \n dddd\n <br/></div>\n\n4. 可以使用<span class=\"tips strong\">-</span>去除文字块末尾的换行\n<div class=\"show\">lyrics: |-\n aaaa \n bbbb\n cccc \n dddd</div>\n 输出为：\n<div class=\"show\">aaaa \n bbbb\n cccc \n dddd\n</div>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n在yml文件中配置好字符串格式后，读取到html中时往往需要添加如<span class=\"tips\">white-space: pre-line;</span>等css属性来保留换行符和空格，否则读入的数据可能会被css默认样式去除换行符，从而无法展示原生yml指定的数据格式</div>\n\n5. <div class=\"tips strong\">在样式流中，无法使用 | > + -</div>\n<div class=\"show\">如：以上数据写为样式流\n             { \n               lyrics: |-\n                aaaa \n                bbbb\n                cccc \n                dddd\n               }\n  |- 将无法解析，抛出错误</div>\n\n\n### 添加HTML标签\nyaml允许在值中添加HTML标签，并且标签会被正确地解析为DOM\n<div class=\"show\">- tag: web\n  content: 推荐网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>\n  或\n  <div class=\"show\">- tag: web\n  content: |-\n   推荐\n   网站&lt;a href='SHIWIVI'>SHIWIVI&lt;/a></div>\n解析为：\n<div class=\"show\">推荐网站 <a href=\"#\">SHIWIVI</a></div>\n   <div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n使用时需要注意，插入的HTML标签是否会被其他语言解析为字符串，但yaml本身是可以输出为DOM元素的</div>\n\n### 锚点与引用\n可以使用<span class=\"tips\">&</span>定义一个锚点，然后使用<span class=\"tips\">*</span>引用锚点\n<div class=\"show\">first: &anchor  #定义锚点\n - aaa\n - bbb\nsecond:  *anchor #调用锚点</div>\n解析为\n<div class=\"show\">first: [aaaaa,bbb]\nsecond: [aaaaa,bbb] </div>\n\n如果将多个键值对引用到其他地方，可以使用<span class=\"tips\"><<</span>合并数据\n<div class=\"show\">first: &data  #定义锚点\n   name: lol\n   age: 18\n   hobby:\n    - sing\n    - swing\nsecond: \n   <<: *data    #将数据插入此处\n   address: zzz</div>\n 解析为：\n <div class=\"show\">{\n  \"first\": {\n      \"name\": \"lol\",\n      \"age\": 18,\n      \"hobby\": \"sing  swimming\"\n  },\n  \"second\": {\n      \"name\": \"lol\",\n      \"age\": 18,\n      \"hobby\": \"sing  swimming\",\n      \"address\": \"zzz\"\n  }\n}</div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n如果多次定义了同名的锚点(重定义)，则先定义的锚点会被覆盖</div>\n\n### 文件格式\n一个完整的yml文档以<span class=\"tips\">-&zwnj;-&zwnj;-</span>标识文档开始，以<span class=\"tips\">...</span>标识文档结束，该标识非必须，无标识的称为<span class=\"tips\">裸文档</span>，文件开头可以添加<span class=\"tips\">%YAML</span>来识别文件的YAML版本\n<div class=\"show\">%YAML 1.2\n# 开头注释，注明文档作者等信息\n---\nip: 45.77.77.49\nport: 443\n...</div>\n\n一个yml文件中可能有多个文档\n<div class=\"show\">---\nip: 45.77.77.10\nport: 80\n...\n---\nip: 45.77.77.11\nport: 443\n...</div>\n但如果在一个yml文件中写入多个文档，在某些环境下读入可能报错，需要分割为多个文件\n<div class=\"shell\">err: YAMLException: expected a single document in the stream, but found more</div>\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n更多语法和拓展详见官方文档</div>","tags":["CS","File"]},{"title":"Grid栅格布局","url":"/blog/2022/06/14/Grid布局/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nGrid在MDN上翻译为网格布局，在《CSS权威指南》中翻译为栅格布局，其实是同一种布局方案，本文语句主要整理自《CSS权威指南》一书</div>\n\n### 1. 栅格布局\nGrid 是一种强大的布局方案，也是最为普适的布局方案，允许在Web上创建二维布局，通过对父元素定义不同参数的行与列垂直线，再将子元素部署于行列网格上，由此实现各类灵活的布局，如：\n<br/>\n<div style=\"display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;grid-area:a;\">box1</div>\n<div style=\"background-color:#fff200;grid-area:b;\">box2</div>\n<div style=\"background-color:#7d5fff;grid-area:c;\">box3</div>\n<div style=\"background-color:#32ff7e;grid-area:d;\">box4</div>\n<div style=\"background-color:#4b4b4b;grid-area:e;\">box5</div>\n</div>\n<br/>\n\n通过标准流、float、flex也可以实现类似的布局，但这些方案往往需要更多的DOM元素，或者需要指定更多的参数，并且很多情况下无法做到自适应，此时，grid布局方案的优势就体现出来了。并且语法兼容性也很好，除了那位大爷.....\n\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>Chrome</th><th>Edeg</th><th>Firefox</th><th>IE</th><th>Opera</th><th>Safari</th>\n</tr>\n</thead>\n<tr><td>57</td><td>16</td><td>52</td><td style=\"color:red;\">不支持</td><td>44</td><td>10.1</td></tr>\n</table>\n</div>\n\n### 2. 栅格容器\n创建栅格的第一步就是创建一个栅格容器，并将其中的内容定义为栅格布局\n#### 2.1 栅格属性\n<span class=\"strong\">display: grid/inline-grid;</span>\n\n指定容器布局方式为栅格布局，该属性和 block 与 inline-block 值相似\n\n#### 2.2 定义栅格模板\n<span class=\"strong\">grid-template-columns: 值;</span>\n\n<span class=\"strong\">grid-template-rows: 值;</span>\n\n将容器划分为行列栅格,栅格线的值可以为<span class=\"tips\">固定值</span>、<span class=\"tips\">百分比</span>、<span class=\"tips\">fr关键字</span>、<span class=\"tips\">repeat()语句</span>、<span class=\"tips\">minmax()语句</span>、<span class=\"tips\">calc()函数</span>等，并且参数可以混用\n\n##### 2.2.1 固定值行列轨道宽度\n将子元素宽高设为固定值，单位可以为px，也可以为em、rem等相对单位\n\n<div class=\"show\">如：给父元素指定行列轨道宽度，子元素可以不设置任何参数\ndiv{\n    display:grid;\n    grid-template-columns:50px 60px 100px;\n    grid-template-rows:50px 60px 100px;\n}\n</div>\n<div style=\"display:grid;grid-template-columns:50px 60px 100px;grid-template-rows:50px 60px 100px;text-align:center;color:#fff;width:210px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">类似的取值可以为\n    grid-template-columns:5em 5em 5em;\n</div>\n\n##### 2.2.2 百分比配置宽高\n将元素的宽高按百分比配置，可以让网页元素自适应不同屏幕大小\n\n<div class=\"show\">如：元素宽高分别为20% 20% 50% \ndiv{\n    display:grid;\n    grid-template-columns:20% 20% 50%;\n    grid-template-rows:20% 20% 50%;\n    border:1px solid black;\n    box-sizing: border-box;\n}\n</div>\n<div style=\"display:grid;grid-template-columns:20% 20% 50%;grid-template-rows:20% 20% 50%;text-align:center;color:#fff;width:280px;height:300px;margin:0 auto;border:1px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n百分比是基于父容器的宽度和高度计算，不管子元素内容大小如何变化也不会变，因此要给与父元素宽高参数，即不能再使用子元素撑开父元素了。若子元素宽高相加不到100%，则剩余部分空置</div>\n\n##### 2.2.3 fr按比例配置宽高\ngrid布局提供了 <span class=\"tips\">fr</span> 关键字(fraction)用于表示比例关系\n\n<div class=\"show\">如：元素宽高比为1:2:2 \ndiv{\n    display:grid;\n    grid-template-columns:1fr 2fr 2fr;\n    grid-template-rows:1fr 2fr 2fr;\n    border:1px solid black;\n    box-sizing: border-box;\n}\n</div>\n<div style=\"display:grid;grid-template-columns:1fr 2fr 2fr;grid-template-rows:1fr 2fr 2fr;text-align:center;color:#fff;width:210px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">配合其他值来实现弹性布局\n     grid-template-columns:150px 1fr 10%;\n     <span class=\"tips\">第一列宽为150px，最后一列宽为10%,剩下宽度给中间一列</span>\n</div>\n\n##### 2.2.4 定义栅格线名称\n可以使用<span class=\"tips\">[ ]</span>为边框线起名字，并且同一条线的名称可以有无数多个，如：<span class=\"tips\">[a1 b1]</span>为同一条线取名a1和b1\n<div class=\"show\">如：元素宽高比为1:2:2 \ndiv{\n    display:grid;\n    grid-template-columns: [c1] 80px [c2] 80px [c3] 80px [c4];\n    grid-template-rows: [r1] 60px [r2] 60px [r3] 60px [r4];\n    border:1px solid black;\n    box-sizing: border-box;\n}\nbox1、box4、box7左边框线相连为c1，右边框线相连为c2；\nbox1、box2、box3上边框线相连为r1，下边框线相连为r2\n其他以此类推\n</div>\n<div style=\"display:grid;grid-template-columns:[c1] 80px [c2] 80px [c3] 80px [c4];\n    grid-template-rows:[r1] 60px [r2] 60px [r3] 60px [r4];text-align:center;color:#fff;margin:0 auto;width:240px;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n##### 2.2.5 repeat()重复填充\n对于多个宽高值相同的元素，可以使用<span class=\"tips\">repeat()</span>语句简写\n\n<div class=\"show\">如：\n1. 对于grid-template-columns: 5em 5em 5em;\n该语句可以简写为\n    grid-template-columns: repeat(3,5em);\n2. 类似地可以创建宽度有一定规律的子元素\n    如：创建宽度依次为20px,40px,60px,20px,40px,60px的6列元素\n    grid-template-columns: repeat(2, 20px 40px 60px);\n3. 还可以repeat()前后添加不想重复的宽高值\n    grid-template-columns: repeat(2,1em 5em) 2em;\n    这就生成了1em 5em 1em 5em 2em的网格\n4. 百分号和比例依旧适用\n    grid-template-columns: repeat(3,33.3%);\n5. 如果包含了栅格线名，名称也会被复制\n    grid-template-columns: repeat(3,[top] 5em [bottom]);\n    则会生成\n    [top] 5em [bottom top] 5em [bottom top] 5em [bottom]\n    即：中间的栅格线将会有两个名称，该语句等同于：\n    grid-template-columns: [top] 5em [bottom top] 5em [bottom top] 5em [bottom];\n</div>\n\n\n\n\n##### 2.2.6 minmax()限制尺寸\n当子元素溢出父容器之外时，除了使用<span class=\"tips\">overflow: hidden;</span>外，还可以使用<span class=\"tips\">minmax(最小值，最大值)</span>来限制宽高尺寸\n<div class=\"show\">如：将剩余空间分配给第二列，但又要避免他被挤占得太小\n     grid-template-columns:5em minmax(10%,1fr) 2em;\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n注意！当minmax()中最大值小于最小值时，最大值将失效。如minmax(100px,2em)中，当2em计算值小于100px时，元素宽高将被解析为100px</div>\n\n##### 2.2.7 calc()计算尺寸\ngrid是支持<span class=\"tips\">calc()</span>语句的，只是有时候不太适用\n<div class=\"show\">如：第二列宽度通过计算得出\n     grid-template-columns:2em calc(100%-1.5em) 10%;\n</div>\n\n##### 2.2.8 根据内容自适应\n子元素宽高还可以根据子元素内容，通过<span class=\"tips\">max-content</span>、<span class=\"tips\">min-content</span>、<span class=\"tips\">fit-content</span>来实现栅格自适应\n\n+ <span class=\"strong\">max-content:</span>解析为尽可能大的空间，以防换行\n+ <span class=\"strong\">min-content:</span>解析为尽可能小的空间，能够显示内容即可\n+ <span class=\"strong\">fit-content:</span>解析为空间尽可能小，但如果超过指定空间大小就换行\n\n<div class=\"show\">如：尽可能容纳内容\ndiv{\n    display:grid;\n    grid-template-columns:max-content max-content max-content;\n    grid-template-rows:max-content max-content max-content;\n}\n可以看到，每一列的宽度由该列有最长内容的列宽决定，行类似。当父元素指定宽度时，这可能会溢出到父容器之外\n</div>\n\n<div style=\"display:grid;grid-template-columns:max-content max-content max-content;grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">1</div>\n<div style=\"background-color:#fff200;\">22</div>\n<div style=\"background-color:#7d5fff;\">33333333</div>\n<div style=\"background-color:#32ff7e;\">44444444444</div>\n<div style=\"background-color:#4b4b4b;\">5</div>\n<div style=\"background-color:#67e6dc;\">6</div>\n<div style=\"background-color:#ff9f1a;\">77</div>\n<div style=\"background-color:#ffb8b8;\">8888</div>\n<div style=\"background-color:#c56cf0;\">9</div>\n</div>\n\n<div class=\"show\">配合minmax()使用可以不破坏外部布局，但会挤压内部空间\ndiv{\n    display:grid;\n    grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);\n    grid-template-rows:max-content max-content max-content;\n}\n</div>\n\n<div style=\"display:grid;grid-template-columns:minmax(0,max-content) minmax(0,max-content) minmax(0,max-content);grid-template-rows:max-content max-content max-content;text-align:center;color:#fff;width:180px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">1</div>\n<div style=\"background-color:#fff200;\">22</div>\n<div style=\"background-color:#7d5fff;\">33333333</div>\n<div style=\"background-color:#32ff7e;\">44444444444</div>\n<div style=\"background-color:#4b4b4b;\">5</div>\n<div style=\"background-color:#67e6dc;\">6</div>\n<div style=\"background-color:#ff9f1a;\">77</div>\n<div style=\"background-color:#ffb8b8;\">8888</div>\n<div style=\"background-color:#c56cf0;\">9</div>\n</div>\n\n<div class=\"show\"><span class=\"tips\">fit-content</span>用于限制最大长度，类似于max-width\n指定三列宽均为50等宽字符，当未满50ch时按实际字符长度算，超过该值则进行换行，即最大值只能为50ch\ndiv{\n    display:grid;\n    grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(5.0ch);\n}\n只指定宽度，高度自适应，第一第二列未满50ch时，以各自长度为列宽，第三列超过50ch，则进行换行，以50ch为列宽\n</div>\n<div style=\"display:grid;grid-template-columns:fit-content(50ch) fit-content(50ch) fit-content(50ch);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#18dcff;\">the night</div>\n<div style=\"background-color:#4b4b4b;\">Avicii</div>\n<div style=\"background-color:#7d5fff;\">He said one day you will leave this world behind So live a life you will remember</div>\n</div>\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n当父容器较小时，第一、第二列即便未满50ch也可能会进行换行，以保证不会溢出父亲容器</div>\n\n##### 2.2.9 auto-fill自动填充\n当父容器宽度固定，可以使用<span class=\"tips\">auto-fill</span>让子元素根据大小自动填充\n<div class=\"show\">如：\ndiv{\n    display:grid;\n    width:50vh;\n    grid-template-columns:repeat(auto-fill,5em);\n    grid-template-rows:max-content max-content max-content;\n    }\n在父容器中尽量排列宽3em的元素，排列到第一行排完，如果剩下空间不足3em，则剩余子元素将进行换行\n</div>\n<div style=\"display:grid;grid-template-columns:repeat(auto-fill,3em);text-align:center;color:#fff;width:50vh;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">1. 一个父容器的宽/高只能有一次自动排列，因此下述语句是不允许的\ngrid-template-columns: repeat(auto-fill,5em) repeat(auto-fill,2em);\n2. 但可以固定尺寸的repeat与自动填充的repear共存，如：\ngrid-template-columns: repeat(2,5em) repeat(auto-fill,2em);\n或者\ngrid-template-columns: repeat(auto-fill,5em) repeat(3,2em);\n但无论语序如何，grid总会为固定尺寸的元素分配空间，因此auto-fill会被最后才被分配空间\n</div>\n\n#### 2.3栅格间距\n通过<span class=\"tips\">row-gap</span>、<span class=\"tips\">column-gap</span>来设置栅格见的行、列间隔。或者将两个属性合并为一个 <span class=\"tips\">grid-gap：行间隔 列间隔;</span>\n<div class=\"show\">给父容器添加该属性\ndiv{\n    display:grid;\n    width:50vh;\n    height:50vh;\n    grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);\n    row-gap:10px;\n    column-gap:10px;\n    }\n如图所见，添加间隔可能导致栅格溢出，这两个属性可合并为 grid-gap ，如果该语句之后的值只有一个，则解析为行列间隔都为该值。\n    grid-gap:10px 10px;\n等价于\n    grid-gap:10px;\n</div>\n\n<div style=\"display:grid;grid-template-columns:repeat(3,60px);grid-template-rows:repeat(3,60px);row-gap:10px;\n    column-gap:10px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n### 3. 栅格区域\n此前都是给父容器添加属性，但如果同时给子元素添加相应属性可以做出更好的布局\n\n\n#### 3.1 调用栅格线名\n通过<span class=\"tips\">grid-template-columns</span>、<span class=\"tips\">grid-template-rows</span>定义栅格宽高和栅格线名后，可以通过下列语句调用栅格线名\n\n+ <span class=\"strong\">grid-column-start：</span>列开始的栅格线名\n+ <span class=\"strong\">grid-column-end：</span>列结束的栅格线名\n+ <span class=\"strong\">grid-row-start：</span>行开始的栅格线名\n+ <span class=\"strong\">grid-row-end：</span>行结束的栅格线名\n\n<div class=\"show\">通过四条边来定义子元素的具体位置，当未定义栅格线名时，可以使用1，2，3...作为栅格线名\n.box1 {\n    grid-column-start:1;\n    grid-column-end:2;\n    grid-row-start:2;\n    grid-row-end:4;\n    background-color: #ff3426;//红色\n}\n.box2 {\n    grid-column-start:3;\n    grid-column-end:5;\n    grid-row-start:1;\n    grid-row-end:3;\n    background-color: #39f64f;//绿色\n}\n\n.parbox {\n    display:grid;\n    grid-template-columns: repeat(4,50px);\n    grid-template-rows: repeat(4,50px);\n}\n栅格线名可以为负数，表示从该栅格线往其反方向数\n</div>\n\n\n<div style=\"display:grid;display:grid;grid-template-columns: repeat(4,50px);grid-template-rows: repeat(4,50px);text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;box-sizing: border-box;\">\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #ff3426;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #39f64f;\"></div>\n<div style=\"border:1px solid #474747;background-color: #ff3426;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n<div style=\"border:1px solid #474747;\"></div>\n</div>\n\n<div class=\"show\">1. 栅格线的编号可以为<span class=\"tips\">负值</span>，表示从倒数第n条线开始从后往前数\n如：不知道栅格有几列，但想从最右边的栅格线开始部署，可以使用\n        grid-column-start:-1;\n        grid-row-start:-1;(行同理)\n2. 如果为栅格线定义过名称，则可以使用该名称作为上述语句的值，如果变量对应的栅格线有多条，则使用<span class=\"strong\">变量名 序号</span>来确定具体的栅格线，序号从1开始排列。如：有多条名为col-A的线，表示列从第4条col-A开始：\n            grid-column-start:col-A 4;\n3. 此外可以使用<span class=\"tips\">span</span>语句指定子元素跨越的行列数，如：\n.box1 {\n    grid-column-start:1;\n    grid-column-end: span 1;\n    grid-row-start:2;\n    grid-row-end: span 2;\n}\n上述代码等同于：\n.box1 {\n    grid-column-start:1;\n    grid-column-end: 2;\n    grid-row-start:2;\n    grid-row-end: 4;\n}\n表示该子元素从左边框号1开始，跨越1列，从上边框号2开始，跨越2行，其中<span class=\"strong\">span 1</span>可以直接简写为<span class=\"strong\">span</span>(默认为1)，且span后的值不能为<span class=\"tips\">0</span>或<span class=\"tips\">负值</span>\n4. 当使用 <span class=\"strong\">span 栅格线名 n</span> 时，表示该元素跨越了n条该名称的栅格线\n如：栅格部署为A、B栅格线交替命名时\nA 格子 B 格子 A 格子 B 格子 A 格子 B 格子\n此时\n    grid-column-start: A 1;\n    grid-column-end: span 2 A;\n表示栅格从第1条A线开始，跨越1条名为A的栅格线，在下一个A线处结束\n\n</div>\n\n#### 3.2 调用栅格线名的简写\n上一节中 grid-column-start，grid-column-end和grid-row-start，grid-row-end用于指定栅格起始和结束的位置，该属性可以简写为\n\n+ <span class=\"strong\">grid-column: 起始栅格线/结束栅格线</span>\n+ <span class=\"strong\">grid-row: 起始栅格线/结束栅格线</span>\n\n<div class=\"show\">1. 元素开始和结束的栅格线名用 / 隔开 \n.box1 {\n    grid-column-start:1;\n    grid-column-end: 2;\n    grid-row-start:2;\n    grid-row-end: 4;\n}\n等价于\n.box1 {\n    grid-column: 1 / 2;\n    grid-row: 2 / 4;\n}\n也可以用跨越了多少栅格表示\n.box1 {\n    grid-column: 1 / span 1;\n    grid-row: 2 / span 2;\n}\n2. 如果 / 和第二个值省略，则默认起始结束的栅格线名都一致\n如：列栅格线中有两条名为header的线，则\n        grid-column: header;\n等价于\n        grid-column: header / header;\n即以第一条header开始，第二条header结束，无论中间跨越多少栅格\n</div>\n\n\n#### 3.3 grid-area\ngrid-area可用于调用网格线，也可用于为子元素命名\n##### 3.3.1 grid-area调用网格线\n grid-column-start，grid-column-end和grid-row-start，grid-row-end可以直接用一个语句代替：\n <span class=\"strong\">grid-area：行开始/列开始/行结束/列结束</span>\n<div class=\"show\">如：\n.box1 {\n    grid-row-start:2;\n    grid-row-end: 4;\n    grid-column-start:1;\n    grid-column-end: 2;  \n}\n等价于\n.box1 {\n    grid-area:2/1/4/2;\n}\n同样，值可以为跨越了多少个网格\n.box1 {\n  grid-area: 2 / 1 / span 2 / span 1;\n}\n</div>\n\n\n##### 3.3.2 grid-area为子元素命名\n可以通过<span class=\"tips\">grid-area</span>给每个栅格子元素定义名称，然后由父容器通过<span class=\"tips\">grid-template-areas</span>定义它们的排列方法\n\n<div class=\"show\">如：\n.box1 {\n    grid-area: a;\n}\n.box2 {\n    grid-area: b;\n}\n.box3 {\n    grid-area: c;\n}\n.box4 {\n    grid-area: d;\n}\n.box5 {\n    grid-area: e;\n}\n.parbox {\n    display:grid;\n    grid-template-areas: 'a a a'\n                        &emsp;&emsp;&emsp;&emsp;'b c d'\n                        &emsp;&emsp;&emsp;&emsp;'b e e';\n}\n排列方法可以写于同一行上，但需要注意'&nbsp;'号\ngrid-template-areas: 'a a a''b c d''b e e';\n</div>\n\n<div style=\"display:grid;grid-template-areas:'a a a' 'b c d' 'b e e';text-align:center;color:#fff;width:280px;height:200px;margin:0 auto;\">\n<div style=\"background-color:#EA2027;grid-area:a;\">box1</div>\n<div style=\"background-color:#fff200;grid-area:b;\">box2</div>\n<div style=\"background-color:#7d5fff;grid-area:c;\">box3</div>\n<div style=\"background-color:#32ff7e;grid-area:d;\">box4</div>\n<div style=\"background-color:#4b4b4b;grid-area:e;\">box5</div>\n</div>\n\n<div class=\"show\">变量名应该尽量使用有含义的单词\n(子元素变量名应相应改变，这里只展示父容器属性)\n.parbox {\n    display:grid;\n    grid-template-areas: 'header header header''left content right''left footer footer';\n}\n也可以省略其中的部分变量，使用...代替\n.parbox {\n    display:grid;\n    grid-template-areas: 'header header header''left ... right''left footer footer';\n}\n</div>\n\n### 4. 栅格的对齐方式\n栅格对齐方式类似于flex弹性盒里的属性\n<div class=\"table\">\n\n属性   |  目标 | 适用于\n----------------|--------------|-------\njustify-self    |行(一个栅格元素)|子元素\njustify-items   |行(所有栅格元素)|父容器\njustify-content |行(整个栅格)   |父容器\nalign-self      |列(一个栅格元素)|子元素\nalign-items     |列(所有栅格元素)|父容器\nalign-content   |列(整个栅格)   |父容器\n</div>\n\n<div class=\"show\">以行为例\n.box1{\n    justify-self:start;\n}\n.box2{\n    justify-self:center;\n}\n.box3{\n    justify-self:end;\n}\njustify-self和justify-items用来调整单个或多个元素在它们自己栅格内的位置\n当justify-self赋值为start、center、end时，如果子元素没有指定宽度和高度，则会自动缩为仅合适内容的大小，对齐方式同单词含义。赋值为stretch时会被拉伸，完全填充box(同剩下的box)\n当需要所有元素都有该对齐方式，则可以给父容器添加justify-items和对应的值\n</div>\n\n<div style=\"display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;justify-self:start;\">box1</div>\n<div style=\"background-color:#fff200;justify-self:center;\">box2</div>\n<div style=\"background-color:#7d5fff;justify-self:end;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n<div class=\"show\">同样以行为例\n.parbox{\n    width:260px;\n    height:260px;\n    display:grid;\n    grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);\n    justify-content:center;\n}\njustify-content则是用来调整整个grid网格在父容器中的位置\n</div>\n<div style=\"display:grid;grid-template-columns:repeat(3,80px);grid-template-rows:repeat(3,80px);justify-content:center;text-align:center;color:#fff;width:260px;height:260px;margin:0 auto;border:2px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n<div style=\"background-color:#ff9f1a;\">box7</div>\n<div style=\"background-color:#ffb8b8;\">box8</div>\n<div style=\"background-color:#c56cf0;\">box9</div>\n</div>\n\n\n\n\n### 5. 隐式栅格\n此前通过<span class=\"strong\">grid-template-rows</span>定义的栅格为<span class=\"tips\">显式栅格</span>，当一部分栅格超出了显式栅格，系统会将超出的那部分定义为<span class=\"tips\">隐式栅格</span>。可以使用<span class=\"tips strong\">grid-auto-rows</span>与<span class=\"tips strong\">grid-auto-columns</span>定义隐式栅格的大小\n<div class=\"show\">如：\n.grid{\n    display:grid;\n    width:200px;\n    height:200px;\n        //定义2*2的显式栅格\n    grid-template-columns:100px 100px;\n    grid-template-rows:100px 100px;\n        //定义隐式栅格尺寸(以行为例)\n    grid-auto-rows: 50px;\n}\nbox1、box2、box3、box4在显式栅格内，高为100px，box5，box6超出了显式栅格，高将变为隐式栅格的高50px\n</div>\n<div style=\"display:grid;width:200px;\n    height:200px;grid-template-columns:100px 100px;grid-template-rows:100px 100px;grid-auto-rows: 50px;text-align:center;color:#fff;width:200px;height:200px;margin:0 auto;border:5px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n<div style=\"background-color:#67e6dc;\">box6</div>\n</div>\n<br/>\n<br/>\n<br/>\n\n### 6. 栅格流\n栅格流主要分为优先行、优先列、密集流三种模式，由<span class=\"tips\">grid-auto-flow</span>决定\n\n<div class=\"show\">grid-auto-flow的取值有row、column、dense(密集流)\n .box{\n    display: grid;\n    grid-template: repeat(3,80px) / repeat(3,80px);\n    width: 240px;\n    height: 240px; \n    grid-auto-flow: row;\n    }\n优先行与优先列的部署模型如下\n</div>\n<div style=\"display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: row;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n</div>\n<br/>\n<div style=\"display:grid;grid-template: repeat(3,80px) / repeat(3,80px);width: 240px;height: 240px; grid-auto-flow: column;text-align:center;color:#fff;margin:0 auto;border:1px solid black;box-sizing: border-box;\">\n<div style=\"background-color:#EA2027;\">box1</div>\n<div style=\"background-color:#fff200;\">box2</div>\n<div style=\"background-color:#7d5fff;\">box3</div>\n<div style=\"background-color:#32ff7e;\">box4</div>\n<div style=\"background-color:#4b4b4b;\">box5</div>\n</div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n密集流的主要作用是让元素尽量靠紧，因此有时会破坏栅格元素的顺序进行密集分布，向任何可以插入的位置安插合适的子元素</div>\n\n### 7. 错误处理\n当输入错误的代码时，部分情况下grid会帮我们修正属性，但在有些情况下会抛弃部分无法解析的值，甚至不解析整个语句\n<div class=\"show\">1. 当栅格开始线放在结束线后\n    grid-row-start:5;\n    grid-row-end:2;\ngrid将修正为\n    grid-row-start:2;\n    grid-row-end:5;\n2. 当栅格开始线和结束线都被声明为了跨度\n    grid-row-start: span ;\n    grid-row-end: span 3;\n结束线的值将被修改为 auto\n    grid-row-start: span ;\n    grid-row-end: auto;\n3. 如果栅格开始线被声明为跨越已命名的线，则该语句将被认为非法\n    grid-row-start: span header;\n</div>\n\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n当栅格元素出现重叠时，可以使用 z-index 或 order 进行排序，并且栅格元素可以使用margin、position等标准流、定位等属性。并且还有其他一些更复杂的属性简写语法，本文不再展开说明，具体可以查阅MDN的文档</div>","tags":["css","web"]},{"title":"Vux状态管理","url":"/blog/2022/06/13/Vux状态管理/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\nVux官网：<a href=\"https://vuex.vuejs.org/zh/\">https://vuex.vuejs.org/zh/</a></div>\n\n### 入门\n#### 简介\n<span class=\"tips\">Vuex</span>是专门为Vue应用程序开发的集中式状态(数据)管理插件，可以对Vue中的组件进行统一的数据管理。\n\n#### 搭建环境\nvue2的工程使用vux3，vue3的工程需要使用vux4，版本需要对应，这里以安装vux3为例\n\n在脚手架中执行：\n<pre><code>npm i vuex@3</code></pre>\n\n#### 工作流程\n<img data-src=\"/blog/images/vuex_art.jpg\" src=\"/blog/images/vuex_art.jpg\" alt=\"vuex工作流程\">\n\n\n+ <span class=\"strong\">Action</span>主要用于响应Vue Conponents的消息，或者从后端接收数据，并且可以将数据在Action中进行初步处理(主要为异步处理，如：添加定时器)\n+ <span class=\"strong\">Mutation</span>主要用于处理数据，在Mutation处理的数据才能被Devtools调试工具监测\n+ <span class=\"strong\">State</span>主要用于集中存储数据\n\n<span class=\"strong\">工作流程：</span>Vue Conponents发送消息<span class=\"tips\">(dispatch)</span>给Action，或者Action通过Ajax等技术从后端异步获取数据 ---> Actions提交<span class=\"tips\">(commit)</span>到Mutation ---> 数据在Mutation中进行处理后，修改<span class=\"tips\">(mutate)</span>State中存储的数据 ---> 监测到State数据发生变化，Vue重新渲染<span class=\"tips\">(render)</span>页面\n\nvue组件的中数据不要预处理时，也可以越过Action，直接commit到mutation中进行处理\n\n<span class=\"strong\">关于store：</span>store是Vuex的核心库，可以理解为一个容器，Action、Mutation、state由Store统一管理，在进行消息提交、数据操作时往往需要经过store，通过<span class=\"tips\">this.$store.dispatch</span>、<span class=\"tips\">this.$store.commit</span>等语句来调用api\n\n### 上手\n#### 开发步骤\n##### 1. 配置store\n在src目录下新建store目录，新建index.js文件\n<pre><code>import Vue from 'vue'\nimport Vue from 'vue'\n//引入并应用vux\nimport Vuex from 'vuex'\nVue.use(Vuex)\n//创建action、mutations、state\nconst actions={....}\nconst mutations={....}\nconst state={.....}\n//创建并暴露Store\nexport default new Vuex.Store({\n    actions,\n    mutations,\n    state,\n    getters\n})</code></pre>\n\n##### 2. 引入store配置项\n在main.js中引入store配置项\n<pre><code>// 全写为import store from './store/index.js'\nimport store from './store'\nnew Vue({\n  render: h => h(App),\n  store\n  }).$mount('#app')</code></pre>\n\n#### 案例\neg：简单求和差案例，4个按钮分别实现求和、求差、判断偶数后求和、定时器延时1s求和\n+ 直接求和、求差可以直接commit到Mutation中运算\n+ 判断当前值是否为偶数，延时求和需要dispatch到Action中预处理，再commit到Mutation中运算\n+ 需要多次处理的数据可以在Action中多次dispatch，处理完毕再commit\n\n##### 1. 创建组件\n在components中创建Count.vue\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>求和案例&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{$store.getters.addTen}}&lt;/h2>\n    &lt;h3>当前值为{{$store.state.sum}}&lt;/h3>\n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    &lt;button @click=\"incrace\">加&lt;/button>\n    &lt;button @click=\"decrace\">减&lt;/button>\n    &lt;button @click=\"addOpp\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate\">延迟3s加&lt;/button>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n export default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1, //加数\n        }\n    },\n    methods:{\n        // 求和、求差直接commit\n    incrace(){\n        this.$store.commit('JIA',this.num)\n    },\n    decrace(){\n        this.$store.commit('JIAN',this.num)\n    },\n    //延时、判断奇偶dispatch到actions经过处理后再提交\n    addOpp(){\n        this.$store.dispatch('addOpp',this.num)\n    },\n    addLate(){\n        this.$store.dispatch('addLate',this.num)\n    }\n    }\n }\n&lt;/script>\n</code></pre>\n\n##### 2. 配置store\n新建store目录并在该目录下新建index.js\n<pre><code>import Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\nconst actions={\n    // actions里的方法名一般小写\n    //接收参数 (context,实参)\n    // context是一个对象，拥有store的部分属性,变量名可以为其他\n    addOpp(context,value){          \n        if(!(value%2)){             //判断是否为偶数，为偶数则commit到mutations\n        context.commit('JIA',value)\n        }else{\n            console.log('非偶数，数未提交')\n        }\n    },\n    addLate(context,value){       //数据想要多道处理时，可以在actions内多次dispatch，无限套娃\n        setTimeout(()=>{\n            context.dispatch('addLate2',value);\n            console.log('第一次延迟处理')\n        },500)\n    },\n    addLate2(context,value){      //数据经过第二道处理后，再提交\n        setTimeout(()=>{\n            context.commit('JIA',value);\n            console.log('第二次延迟处理')\n        },500)\n    }\n}\n// mutations里的方法名一般大写，用于和actions里的区别\nconst mutations={\n    //接收参数(state,实参)\n    JIA(state,value){           //加\n        state.sum+=value\n    },\n    JIAN(state,value){          //减\n        state.sum-=value;\n    }\n}\nconst state={ //存储数据\n    sum:0\n }\nconst getters={                //读取数据前，想要预先进行处理使用getters\n    addTen(state){\n        return state.sum+10\n    }\n}\n// 创建并暴露store\nexport default new Vuex.Store({\n    actions,\n    mutations,\n    state,\n    getters\n })\n</code></pre>\n\n##### 3. 引入store配置项\n在main.js中引入store配置\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport store from './store'// 全写为import store from './store/index.js'\nVue.config.productionTip = false\n new Vue({\n  render: h => h(App),\n  store\n }).$mount('#app')\n</code></pre>\n\n##### 4. 引入Count组件\n在App中使用Count组件\n<pre><code>&lt;template>\n  &lt;div id=\"app\">\n    &lt;Count/>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nimport Count from'./components/Count.vue'\nexport default {\n  name:'App',\n  components:{\n    Count\n             }\n   }\n&lt;/script></code></pre>\n\n### getters\n组件从state读取数据前，如果需要对数据进行预处理，可以在getter中进行。如：读取state中的num前进行处理(完整代码位于上一个案例)\n\n#### 1. 在store中添加getter\n<pre><code>\nconst actions={.....}\nconst mutations={....}\nconst state={.....}\nconst getter={ \n    //读取state中的sum前，将值增大10\n     addTen(state){\n        return state.sum+10;\n     }\n}\n</code></pre>\n\n#### 2. 读取数据\n读取数据使用\n<pre><code>$store.getters.addTen</code></pre>\n\n### 辅助函数\n当一个组件需要获取多个数据(状态)时，调用数据和api需要大量使用this.$store.state.number等语句，为了减小代码书写量，可以在计算属性中借助<span class=\"tips\">mapState</span>、<span class=\"tips\">mapGetters</span>、<span class=\"tips\">mapMutations</span>、<span class=\"tips\">mapActions</span>辅助函数简化代码\n\n#### 通过对象\n当组件中的方法名、变量名与State、Mutations...中的变量名不同时，需要通过对象方式接收。并借助模板语法解析变量，以读取State中的数据为例：\n<div class=\"show\">...mapState({组件中的变量名:'state数据',.....})</div>\n\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>求和案例&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{addTen}}&lt;/h2>\n    &lt;h3>当前值为{{sum1}}&lt;/h3>\n    &lt;h2>从state获取name为{{name1}},从state获取song为{{song1}}&lt;/h2>\n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    //当使用mapState等语法时，需要在写函数时传参(num)\n    &lt;button @click=\"incrace(num)\">加&lt;/button>\n    &lt;button @click=\"decrace(num)\">减&lt;/button>\n    &lt;button @click=\"addOpp(num)\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate(num)\">延迟3s加&lt;/button>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n//引入mapState、mapGetters、mapMutations、mapActions\n import {mapState,mapGetters, mapMutations,mapActions} from 'vuex'\n export default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1,\n        }\n    },\n    computed:{\n        //模板语法\n        ...mapState({sum1:'sum',name1:'name',song1:'song'}),\n        ...mapGetters({addTen:'addTen'})\n        // 可以简写为数组形式...mapGetters(['addTen'])，在对象中不能简写，会解析为addTen:addTen，值也解析为变量\n    },\n    methods:{\n    //原语句\n    // incrace(){this.$store.commit('JIA',this.num)},\n    // decrace(){this.$store.commit('JIAN',this.num)},\n    // 借助mapMutations生成对应方法，该方法会自动调用commit，数组写法在另一组件中\n     ...mapMutations({incrace:'JIA',decrace:'JIAN'}),\n    //原语句\n    // addOpp(){this.$store.dispatch('addOpp',this.num)},\n    // addLate(){this.$store.dispatch('addLate',this.num)}\n     ...mapActions({addOpp:'addOpp',addLate:'addLate'})\n     }\n }\n&lt;/script></code></pre>\n\n#### 通过数组\n当组件中的方法名、变量名与State、Mutations...中的变量名相同时，可以直接使用数组\n<div class=\"show\">...mapState(['变量名1','变量名2',....])</div>\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>不同的mapstate等写法&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{addTen}}&lt;/h2>\n    &lt;h3>当前值为{{sum}}&lt;/h3>\n    &lt;h2>从state获取name为{{name}},从state获取song为{{song}}&lt;/h2>\n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    &lt;button @click=\"JIA(num)\">加&lt;/button>\n    &lt;button @click=\"JIAN(num)\">减&lt;/button>\n    &lt;button @click=\"addOpp(num)\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate(num)\">延迟3s加&lt;/button>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nimport {mapState,mapGetters, mapMutations,mapActions} from 'vuex'\nexport default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1,\n        }\n    },\n    computed:{\n        ...mapState(['sum','name','song']),\n        ...mapGetters(['addTen'])\n    },\n    methods:{\n        //数组写法\n    ...mapMutations(['JIA','JIAN']),\n     ...mapActions(['addOpp','addLate'])\n    }\n }\n&lt;/script></code></pre>\n\n### 模块化与命名空间\n当有多类数据需要vuex管理时，可以将他们的state、actions、mutation封装到多个js文件中，并为它们开启<span class=\"tips\">命名空间</span>\n\n#### 方法\n1. 在store目录中创建多个store配置文件\n2. 将配置文件统一引入该目录的index.js中\n3. 将store配置引入main.js中\n4. 创建组件，需要注意辅助函数的用法，指向命名空间的方法\n5. 在app中引入组件\n\n#### 案例\neg: 在上个案例基础上加入添加成员的功能。现在有两个功能：求和求差、添加成员，因此store目录下需要两个store配置项。在组件中调用数据时，需要用到命名空间，从不同state中引用数据。\n\n\n##### 1. 配置store\n在store目录新建 person.js文件\n<pre><code>//添加人员模块\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\n const person = {\n    namespaced:true, //开启命名空间\n    actions:{\n        addPersonZhou(context,value){\n            if(value.name.indexOf('周')===0){\n                context.commit('ADD_PERSON',value)\n            }\n            else{\n                alert('只能添加姓周的名')\n            }\n        },     \n    },\n    mutations:{\n        ADD_PERSON(state,personObj){\n            state.personList.unshift(personObj);\n        }\n    },\n    state:{\n        personList:[{id:'001',name:'张三'}]\n    },\n    getters:{\n        getFirstName(state){\n            return state.personList[0].name;\n        }\n    }\n }\n export default person</code></pre>\n\n在store目录新建 count.js文件\n<pre><code>//求和模块\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\nexport default {\n    namespaced:true, //开启命名空间\n    actions: {\n        addOpp(context,value){          //判断是否为偶数\n            if(!(value%2)){\n            context.commit('JIA',value)\n            }else{\n                console.log('非偶数，数未提交')\n            }\n        },\n        addLate(context,value){        //数据想要多道处理时，可以dispatch为actions内的其他方法，无限套娃\n            setTimeout(()=>{\n                context.dispatch('addLate2',value);\n                console.log('第一次延迟处理')\n            },500)\n        },\n        addLate2(context,value){      //数据经过第二道处理后，再提交\n            setTimeout(()=>{\n                context.commit('JIA',value);\n                console.log('第二次延迟处理')\n            },500)\n        }\n    },\n    mutations:{\n        JIA(state,value){           //加\n            state.sum+=value\n        },\n        JIAN(state,value){          //减\n            state.sum-=value;\n        },\n    },\n    state:{\n        sum:0,\n        name:'周杰伦',\n        song:'夜曲',\n    },\n    getters:{\n        addTen(state){\n            return state.sum+10\n        }\n    }\n}</code></pre>\n\n ##### 2. 在index.js中引入\n 在store目录下index.js中引入\n<pre><code> import Vue from 'vue'\n import Vuex from 'vuex'\nVue.use(Vuex)\n//引入两个配置项\nimport count from './count'\nimport person from './person'\n// 创建并暴露store\nexport default new Vuex.Store({\n    //引入模块\n    modules:{\n        //全写count: count,\n        count,\n        person\n    }\n })</code></pre>\n\n #### 3. 在main.js中引入store\n <pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport store from './store'\nnew Vue({\n  render: h => h(App),\n  store\n}).$mount('#app')</code></pre>\n\n##### 4. 书写组件\n创建count.vue组件\n<pre><code>\n&lt;template>\n  &lt;div>\n    &lt;h2>求和案例&lt;/h2>\n    &lt;h2>sum经过getters预处理后{{addTen}}&lt;/h2>\n    &lt;h3>当前值为{{sum}}&lt;/h3>\n    &lt;h2>从state获取name为{{name}},从state获取song为{{song}}&lt;/h2>\n    \n    &lt;select v-model.number=\"num\">\n        &lt;option value=\"1\">1&lt;/option>\n        &lt;option value=\"2\">2&lt;/option>\n        &lt;option value=\"3\">3&lt;/option>\n        &lt;option value=\"4\">4&lt;/option>\n    &lt;/select>\n    &lt;button @click=\"incrace(num)\">加&lt;/button>\n    &lt;button @click=\"decrace(num)\">减&lt;/button>\n    &lt;button @click=\"addOpp(num)\">偶数才加&lt;/button>\n    &lt;button @click=\"addLate(num)\">延迟3s加&lt;/button>\n    &lt;h1>组件2共享过来的人员名单&lt;/h1>\n   &lt;ol class=\"person-list\">\n    &lt;li v-for=\"person in personList\" :key=\"person.id\">{{person.name}}&lt;/li>\n    &lt;/ol>\n  &lt;/div>\n&lt;/template>\n&lt;script>\n import {mapState,mapGetters, mapMutations,mapActions} from 'vuex'\n export default {\n    name:'CountSum',\n    data(){\n        return {\n            num:1,\n        }\n    },\n    //使用mapState,mapGetters, mapMutations,mapActions时更简洁\n    computed:{\n        // 从count组件获取数据\n        ...mapState('count',{sum:'sum',name:'name',song:'song'}),\n         // 从person组件获取数据\n        ...mapState('person',['personList']),\n\n        ...mapGetters('count',{addTen:'addTen'})\n    },\n    methods:{\n    ...mapMutations('count',{incrace:'JIA',decrace:'JIAN'}),\n    ...mapActions('count',{addOpp:'addOpp',addLate:'addLate'})\n    }\n }\n&lt;/script></code></pre>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n辅助函数指向命名空间时，需要在数据和方法名前添加命名空间名，如：...mapState('命名空间',{参数})</div>\n\nperson.vue组件\n<pre><code>&lt;template>\n  &lt;div>\n    &lt;h2>组件2：添加成员&lt;/h2>\n    &lt;input type=\"text\" v-model=\"personName\" placeholder=\"添加成员\">\n    &lt;button @click=\"add\">添加&lt;/button>\n    &lt;button @click=\"addZhou\">只添加姓周的人&lt;/button>\n    &lt;ul>\n        &lt;li v-for=\"person in personList\" :key=\"person.id\">{{person.name}}&lt;/li>\n    &lt;/ul>\n    &lt;h2>名单第一个人为{{firstPersonName}}&lt;/h2>\n    &lt;h2>组件一共享的值&lt;/h2>\n    &lt;h3>和为：{{sum}}&lt;/h3>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nimport { nanoid } from 'nanoid'\nexport default {\n    name:'CountSum',\n    data(){\n        return {\n            personName:''\n        }\n    },\n    //不使用mapState,mapGetters, mapMutations,mapActions时更新、获取数据的方法\n    computed:{\n        personList(){\n            return this.$store.state.person.personList\n        },\n        sum(){\n            return this.$store.state.count.sum\n        },\n        //通过getters获取时，想要指定组件名与路径\n        firstPersonName(){\n            return this.$store.getters['person/getFirstName']\n        }\n    },\n    methods:{\n     add(){\n        const personObj={id:nanoid(),name:this.personName};\n        //指定为person组件下的ADD_PERSON函数\n        this.$store.commit('person/ADD_PERSON',personObj);\n        this.personName='';\n     },\n     addZhou(){\n         const personObj={id:nanoid(),name:this.personName};\n         this.$store.dispatch('person/addPersonZhou',personObj);\n         this.personName='';\n     }\n    }\n  }\n&lt;/script></code></pre>\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n不借助mapState等辅助函数，需要使用路径来指定命名空间名称，其中读取state中的数据使用<span class=\"tips\">this.$store.state.配置文件名.数据名</span>来指向命名空间，而<span class=\"tips\">dispatch</span>、<span class=\"tips\">commit</span>、<span class=\"tips\">getter</span>等api需要使用<span class=\"tips\">this.$store.api名['命名空间/方法名',变量名]</span>语句来指向命名空间</div>\n\n##### 5. App.vue引入两个组件即可\n<pre><code>&lt;template>\n  &lt;div id=\"app\">\n    &lt;Count/>\n    &lt;Person/>\n  &lt;/div>\n&lt;/template>\n &lt;script>\n import Count from'./components/Count.vue'\n import Person from'./components/Person.vue'\n export default {\n  name:'App',\n  components:{\n    Count,\n    Person\n  }\n }\n&lt;/script>\n</code></pre>","tags":["web","vue"]},{"title":"一位资深数据工程师酒后的肺腑之言(转载)","url":"/blog/2022/03/15/一位十年IT工程师的酒后真言/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n原帖来源于Reddit论坛：<a href=\"https://www.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/\">Drunk Post: Things I've learned as a Sr Engineer</a></div>\n\n最早我是在知乎上看到的，后来又陆陆续续在公众号、贴吧多次看到，最后追到了Reddit上，原帖作者是flipstables，这篇帖子目前已经获得了12k的点赞，写的很有意思。\n\n### 节选\n<span class=\"strong\">我喝醉了，这是我作为一名工程师在过去十年学到的一些东西，我可能会后悔说了这些话，但是.....醉都醉了，管他呢。</span>\n\n(1)\t提升职业生涯的最好方法是换公司。\n\n(2)\t技术栈不重要。每个技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。\n\n(3)\t人们爱跳槽是有原因的。 如果对当前工作不满意，也许是时候离开了\n\n(4)\t工作和人际关系是两回事。在一些公司，我交到了好朋友，但是工作得并不开心；在另一些公司里，我没有与任何同事建立友谊，但是工作得很开心。\n\n(5)\t我学会了对经理诚实，总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。\n\n(6)\t如果我每个季度不止一次在凌晨2点被人叫醒，并且他们认为我是可以随叫随到的，那么肯定是出了很严重的问题(系统或人)，要么我得修正他们的看法(或者修复系统)，要么提桶跑路。\n\n(7)<span class=\"strong\">再倒一杯</span>\n\t\n(8)\t优秀的经理和优秀的工程师有很多相似之处。\n\n(9)\t刚开始的时候，我也曾痴迷技术、编程、计算机，但现在已经翻篇了。\n\n(10)\t好的代码是能被初级工程师理解的代码。伟大的代码是可以被CS 专业的大一新生理解的代码。\n\n(11)\t作为一名工程师，最被忽视的能力是写文档。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。\n\n(12)\t网上的口水战(vim vs emacs ,mac vs linux)，几乎都无关紧要，别去参与，除了下一条。\n\n(13)\t年纪越大，我就越觉得动态语言更好，妈的，我就这么说了，有谁反对？\n\n(14)\t如果发现自己是公司里面最厉害的工程师，那就该离开了。\n\n(15)\t我不知道为什么全栈工程师的工资这么低。 不，真的，他们应该每年得到50万的年薪，只是基本工资。 妈的，他们必须了解前端和后端以及不同的浏览器如何工作，还得了解网络、数据库、缓存以及PC端和移动端之间的差异，天哪，还有公司使用的其他框架？ 说真的，为什么全栈工程师工资这么少\n\n(16)\t我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了，我喜欢实习生。\n\n(17) <span class=\"strong\">抿~</span>\n\n(18)\t不要过于迷恋大牛，我花了 5000 美元参加了我所崇拜大牛的公开课。 他是一个才华横溢的人，但后来我意识到，他和我们其他人一样，在瞎编。\n\n(19)\t技术栈很重要。好吧，我刚刚说过不重要之类的话，但听我说完，如果你使用 Python 或 C++ 语言，就会忍不住想用这些语言做一些非同寻常的事情，因为这些语言确实适合干这些工作。\n\n(20)\t如果你不确定自己想做什么东西，请使用 Java。这是一门很糟糕的编程语言，但它几乎无所不能。\n\n(21)\t对于初学者来说，最赚钱的编程语言是 SQL，能干翻所有其他语言。就算你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。\n\n(22)\t测试很重要，但 TDD （测试驱动的开发）是个该死的邪教。\n\n(23)\t政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你得出卖你的灵魂去深究这些专有技术，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄多数在 50 岁以上是有原因的。\n\n(24)\t如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。\n\n(25)\t我从来没有在FAANG (Facebook、亚马逊、苹果、奈飞、谷歌)工作过，所以我不知道我错过了什么。但是我招过FAANG的工程师，他们也不知道自己在做什么。\n\n(26)\t自我价值不是和薪酬挂钩的函数，跟那东西没什么关系，用资本来确定自我价值很糟糕。\n\n(27)\t头衔大多无关紧要，随便什么公司都可以有首席工程师。\n\n(28)\t说到头衔，在职业生涯早期，头衔升级很好，因为这可以让你历练技能，学会担当责任。但到后期，头衔降级很好，这会让你增加薪水。\n\n(29)\t善待每一个人，不是因为这会有助于你的事业，而是因为向善本身就有回报。\n\n(30)\t如果上个月我没有从初级工程师或实习生那里学到点什么，那说明我没有上心。\n\n(31)\t<span class=\"strong\">该死，没酒了</span>\n\n(32)\t在课程、书籍、会议方面花点钱是值得的。\n\n(33)\t手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。\n\n(34)\t当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。\n\n(35)\t就算我心里讨厌某种技术，但如果我觉得他好的话，我还是会把它推荐给客户，比如我恨 Jenkins，但会把它推荐给客户，我不觉得做错了。\n\n(36)\tGit很糟糕，但我没有选择只能使用它，它的GUI可以见鬼去了，给我命令就行，大概只需要记住7个，其他的可以Google。\n\n(37)\t我喜欢团队里的半技术分析师， 因为懂编程但不懂软件工程，他们对我成长的帮助比最杰出的工程师要大得多。\n\n(38) <span class=\"strong\">糟糕，又没酒了</span>\n\n(39)\t成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。\n\n(40)\t发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。\n\n(41)\t我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。\n\n(42)\t算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。\n\n(43)\t做自己喜欢的事情并不重要，不要让做讨厌的事情更重要。\n\n(44)\t越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。\n\n(45)\t即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。\n\n(46)\t不是所有好工作都在硅谷，但那里有很多。\n\n(47) <span class=\"strong\">哦，该死，我又找到啤酒了</span>\n\n(48)\t结对编程很棒，只是需要花很多时间，而公司往往不想花那么多时间。\n\n(49)\t和聪明的工程师一起工作让我变成更好的码农，和聪明的非技术同事一起工作让我成为更好的工程师。\n\n(50)\t朝九晚五以外的时间就别花在工作上了，除非那个项目真的很棒，你状态很好。\n\n(51)\t人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那将是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。\n\n(52)\t好人写的代码也有烂的，聪明人写的代码也是，好的工程师也会写出糟糕的代码。不要让代码质量成为你衡量自我价值的因变量。\n\n(53)\t我进入这个行业是因为我喜欢技术，但现在工作已经毁了我的爱好。\n\n(54)\t我挣的钱还不错，对此我心存感激，不过还是得省着点用。\n\n","tags":["life","CS"]},{"title":"VLess+TLS+WS代理服务器搭建","url":"/blog/2022/03/10/VLess-TLS高阶搭建/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n本文采用 WTFPL 许可证书，转载请不要标注任何本站信息\n<div><a href=\"https://wtfpl2.com/\">WTFPL © Do What the Fuck You Want to Public License</a></div></div>\n\n### 简介\nVLESS 是一种无状态的轻量级数据传输协议，使用 UUID 进行身份验，其协议不再依赖系统时间，配置灵活。但其本身协议不带加密，因此需要配合 TLS 等加密手段。\n\n### 前置需要\n#### 一台可用的VPS\n国内的可以使用香港、台湾地区的服务器，如GCP在台湾的节点、softshellweb，国外的推荐vultr、搬瓦工等主流厂商，支持支付宝付款并且不容易跑路。\n\n操作系统请选择自己熟悉的发行版，并能解决防火墙策略、开放端口等问题，这里以CentOS7为例。\n\n安装完毕后需要测试是否能Ping通，可以直接使用ping命令尝试，或者去相关网站，国内可以通过<a href=\"https://ping.chinaz.com/\">站长Ping工具</a>检测，国外通过<a href=\"https://www.yougetsignal.com/\">yougetsignal</a>检测。如果国内能ping通，说明该服务器可用，可以开始搭建了。如果国外能ping通，国内无法ping通，则说明被拦截了，需要换一台服务器。如果国内国外都无法ping通，则说明服务器还未部署好，需等待几分钟后再重试。\n\n#### 域名\n域名推荐去 godaddy 购买，顶级域名为<span class=\"tips\">.com</span>的域名一般第一年只需要59元，<span class=\"tips\">.cn</span>域名一般35元，最便宜的诸如<span class=\"tips\">.live</span>结尾的域名第一年不到14元\n\n拿到域名后将其解析到所购买的VPS IP地址，域名一般需要24h才会生效(实际不用)。\n\n#### SSL/TLS证书\nSSL/TLS证书可以从以下平台免费获取，证书有效期一般为90天，90天后需要更换\n+ zerossl：<a href=\"https://zerossl.com/\">https://zerossl.com/</a>\n+ letsencrypt：<a href=\"https://letsencrypt.org/\">https://letsencrypt.org/</a>\n+ FreeSSL：<a href=\"https://freessl.org/\">https://freessl.org/</a>\n+ SSL For Free：<a href=\"https://www.sslforfree.com/\">https://www.sslforfree.com/</a>\n\n将获取的证书、密钥文件上传到服务器上，在配置文件时使用。如果不想手动更新SSL证书，可以使用脚本自动更新\n脚本地址：https://github.com/acmesh-official/acme.sh\n### 安装内核\n#### 安装V2fly\nGithub开源地址：https://github.com/v2fly/fhs-install-v2ray\n\n安装/更新 v2fly命令：\n<pre><code>bash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)</pre></code>\n\n安装完成后，配置文件放在<span class=\"tips\">/usr/local/etc/v2ray/config.json</span>路径下\n\n#### Google BBR加速算法\nTCP BBR(Bottleneck Bandwidth and Round-trip propagation time)是由Google于2016年发布的一种拥塞控制算法，可以显著地提高Linux服务器吞吐量并减少TCP连接的延迟\n\n安装bbrplus：\n<pre><code>wget \"https://github.com/cx9208/bbrplus/raw/master/ok_bbrplus_centos.sh\" && chmod +x ok_bbrplus_centos.sh && ./ok_bbrplus_centos.sh</code></pre>\n\n安装完毕需要重启系统，重启完毕可通过<span class=\"tips\">uname -r</span>命令查询内核，返回bbr相关值说明升级完成，通过命令<span class=\"tips\">lsmod | grep bbr</span>查看是否载入bbr系统模块，返回bbr相关值说明已经加载。\n\nCentOS8+系统内核自带BBR，开启方法可自行百度。\n### 服务端\n#### 服务端配置\n使用vim在<span class=\"tips\">/usr/local/etc/v2ray/config.json</span>配置文件中添加配置设置。\n\n<pre><code>{\n  {\n\t\"log\": {\n\t\"loglevel\": \"warning\",\n\t\"access\": \"/var/log/v2ray/access.log\",   \n\t\"error\": \"/var/log/v2ray/error.log\"  //日志输出路径\n    },\n\t\"inbounds\": [{\n\t\"port\": 8180 ,  //监听端口\n\t\"protocol\": \"vless\",//主传入协议\n\t\"settings\": {\n\t\"decryption\": \"none\",\n\t\"clients\": [\n\t{\n\t\"id\": \"41803377-5789-4bf5-8cb4-dd6ad659554c\",//UUID\n\t\"level\": 0\n\t    }\n      ]\n\t},\n\t\"streamSettings\": {\n\t\"network\":\"ws\",  //传输协议\n\t\"security\": \"tls\", //传输层安全\n\t\"wsSettings\":{\n\t\"path\":\"/\",     //路径\n\t\"headers\":{}\n    },\n    \"tlsSettings\": {\n    \"serverName\": \"newyear101.xyz\", //域名\n    \"certificates\": [{\n    \"certificateFile\": \"/etc/ssl/certificate.crt\",//SSL证书路径\n    \"keyFile\": \"/etc/ssl/private.key\" //密钥路径\n            }]\n         }\n      }\n    }],\n    \"outbounds\": [{\n    \"protocol\": \"freedom\",//主传出协议\n    \"settings\": {}\n    },{\n    \"protocol\": \"blackhole\",\n    \"settings\": {},\n    \"tag\": \"blocked\"\n    }],\n    \"routing\": {\n    \"rules\": [\n    {\n    \"type\": \"field\",\n    \"ip\": [\"geoip:private\"],\n    \"outboundTag\": \"blocked\"\n        }\n      ]\n   }\n }\n</code></pre>\n\n+ UUID作为唯一身份识别码，可通过客户端生成，或通过UUID生成网站获得，不能自行编写\n##### 检测配置文件是否正确\nv2ray官方检测命令：\n<pre><code>/usr/local/bin/v2ray -test -config  /usr/local/etc/v2ray/config.json</pre></code>\n文件正确会返回值：\n<div class=\"shell\">V2Ray 4.44.0 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.17.3 linux/amd64)\nA unified platform for anti-censorship.\n2021/02/03 21:46:12 [Info] main/jsonem: Reading config: /usr/local/etc/v2ray/config.json\nConfiguration OK.</div>\n\n#### 更新防火墙规则\n##### Centos 7/8 firewalld 放行端口\n<div class=\"show\">// 8180改成自己的端口号\nfirewall-cmd --permanent --add-port=8180/tcp \n//重启使之生效\nfirewall-cmd --reload\n</div>\n\n##### ubuntu系统 ufw放行端口\n<div class=\"show\">//8180改成自己的端口号\nsudo ufw allow 8180/tcp\n//重启\nsudo ufw reload\n</div>\n\n##### Centos 6/7 iptable放行端口\n<div class=\"show\">//8180改成自己的端口号\niptables -I INPUT -p tcp --dport 8180 -j ACCEPT\n//保存添加的规则链\nservice iptables save\n</div>\n\n\n\n\n\n### 客户端\n客户端需要使用4.23.2以上内核\n\n#### 客户端下载地址：\n+ <strong>Android</strong>: [v2rayNG](https://github.com/2dust/v2rayNG/releases)\n+ <strong>windows</strong>:[v2rayN](https://github.com/2dust/v2rayN/releases)\n+ <strong>MacOS</strong>:[V2rayU](https://github.com/yanue/V2rayU/releases)\n\n### 客户端配置\n<div class=\"table\">\n\n配置项 | 值\n--------|-------\n别名    | 任意\n地址    |VPS的IP地址\n端口    |配置文件中的端口号\n用户ID   |UUID,需要和配置文件一致\n传输协议 |ws\n伪装域名 |解析的域名\n路径    |配置文件中的路径\n传输层安全|tls\n</div>\n\n### 命令\n#### 系统命令\n如果已经启动v2ray服务，修改的配置文件需要重启生效\n+ <strong>systemctl start v2ray</strong> 运行\n+ <strong>systemctl stop v2ray</strong> 停止\n+ <strong>systemctl restart v2ray</strong> 重启\n\n#### 常用服务命令\n##### 生成uuid\n <span class=\"strong\">v2ctl uuid</span> 生成一个新的uuid\n\n ##### 配置相关\n <span class=\"strong\">v2ray [参数]</span>\n\n<div class=\"table\">\n\n参数 | 说明\n--------|-------\n-version | 查看当前版本\n-test    |测试配置文件有效性\n-config |手动指定配置文件，值可以是绝对路径、相对路径、url链接、\"stdin:\"(从标准输入读取内容)\n\n</div>\n","tags":["Server","VPS"]},{"title":"Nginx笔记(上)","url":"/blog/2022/03/04/nginx笔记/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nnginx官方文档：<a target=\"_blank\" href=\"http://nginx.org/en/docs/\">http://nginx.org/en/docs/</a></div>\n\n### 基本介绍\n#### Nginx简介\nNginx是一款高性能的Web服务器软件，能在高并发环境下快速响应http/https请求，同时也提供IMAP/POP3/SMTP服务,可用于反向代理服务器、虚拟主机、域名解析、负载均衡、防盗链、URL重定向、http/https、邮件代理服务器等各类场景。\n\n根据[Netcraft](https://news.netcraft.com/) 发布的web服务器调查报告，截至2022年1月，nginx是全球最常用的web服务器软件，占有全球32.3%的站点，另一服务器软件Apache占有23.9%的站点，很大一部分web服务器使用Nginx作为负载均衡服务器。\n\n#### 依赖与环境\n<strong>操作系统要求：</strong>Nginx底层使用了多进程和I/O多路复用(epoll)来提高并发能力，因此需要使用Linux2.6以上的内核以支持epoll\n\n<strong>源码包依赖：</strong>\n\n+ GCC编译器：编译C语言\n+ PCRE库(兼容正则表达式库)：用于支持正则表达式\n+ zlib库：为Nginx的gzip压缩提供压缩算法\n+ OpenSSL：提供安全通信\n\n#### 进程模型\n\nmaster进程：主进程，以root权限运行，负责读取检测配置文件，启动和管理worker进程\n\nworker进程：工作进程，权限由配置文件中的user决定，负责处理网络请求，进程数量由配置文件中的worker_processes决定\n\n### 常用命令\n#### Nginx服务命令\n未配置全局环境变量的情况下，nginx命令执行路径为<span class=\"tips\">/usr/local/nginx/sbin</span>，可以通过./nginx -h查看所有命令\n\n<div class=\"table\">\n\n命令|说明\n----|-----\n./nginx|启动nginx\n./nginx -h|-h可替换为-?,查看nginx的所有命令\n./nginx -v|查看nginx的版本\n./nginx -s 信号量|发送一个信号量操作nginx\n./nginx -s stop|强制关闭nginx\n./nginx -s quit|停止接受新请求，等待nginx处理完当前任务后关闭nginx\n./nginx -s reload|重新加载配置文件\n./nginx -s reopen|重新打开日志文件(可用于日志分割)\n./nginx -t [文件路径]|检测nginx的配置文件是否书写正确\n./nginx -T |检测nginx的配置文件是否书写正确，若正确则将内容输出到屏幕\n./nginx -c 文件路径 |手动指定nginx的配置文件后启动\n</div>\n\n#### Linux系统命令\n<span class=\"strong\">kill -信号 master进程PID</span>\n<div class=\"table\">\n\n信号|说明\n----|-----\nTERM/INT | 强制关闭nginx\nQUIT | 停止接受新请求，处理完当前任务后关闭nginx\nHUP |重新加载配置文件\nUSR1|重新打开日志文件(可用于日志分割)\nUSR2|不停止服务，平滑升级到最新版nginx\nWINCH|停止接受新请求，处理完当前任务后关闭所有worker进程\n</div>\n\n##### 关于平滑升级\n执行 <span class=\"tips\">kill -USR2 17482</span>(假设17482为master进程PID)命令进行平滑升级时，更新完ngixn后会开启一个新版本nginx对应的master进程和work进程，此时系统中将会有两个master进程，并且新版本的master进程PID会被记录在<span class=\"tips\">/usr/loca1/nginx/logs/nginx.pid</span>文件中，而旧版本master进程PID会被记录在<span class=\"tips\">/usr/loca1/nginx/logs/nginx.pid.oldbin</span>文件中，之后会发送QUIT信号给旧的master进程，让其处理完请求后关闭，完成升级。\n\n\n\n\n### 配置文件\n配置文件位于<span class=\"tips\">/usr/local/nginx/conf/nginx.conf</span>路径下\n#### 全局配置\n<div class=\"show\">#user  nobody;          //指定nginx工作进程的用户身份，默认为nobody\nworker_processes  1;   //允许生成的worker process数\n\n#error_log  logs/error.log;     //日志级别与存放路径\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid; //master进程pid存放路径\n......</div>\n\n##### user配置进程权限\n<span class=\"strong\">user 用户名 [用户组];</span>\n\n默认为nobody，配置决定了worker进程的调用用户，以及nginx对文件(一般指资源文件和目录)的读写权限，而日志文件、pid文件、配置文件等由master进程调用的文件则不受此配置影响，所有者一般为root。当配置的用户对指定文件无访问权限时，Nginx将返回403错误，此时需要授予该用户相关权限，或者更改为权限更高的用户。\n\n##### worker_processes配置进程数量\n+ <span class=\"strong\">master_process on/off;</span>用于指定是否生成worker进程，默认为on\n+ <span class=\"strong\">worker_processes 值/auto;</span>指定worker进程生成数量，默认为1\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nworker_processes值越大，处理并发能力越强。但需要考虑服务器的CPU核心数、内存余量等硬件资源大小</div>\n\n\n##### daemon配置nginx为守护进程\n<span class=\"strong\">daemon on/off;</span>\n\n配置nginx是否以守护进程方式启动，并在后台运行，默认为on\n\n\n##### error_log配置日志\n<span class=\"strong\">error_log 路径 [日志级别];</span>\n\n配置日志路径和记录级别，这里指Nginx本身运行错误产生的日志，用户连接产生的日志需要在http/https块里配置，默认将notice以上级别的日志写入error.log日志文件中，日志级别有 debug、info、notice、warn、error、crit\n\n\n##### pid配置pid文件路径\n<span class=\"strong\">pid 路径;</span>\n\n自定义pid文件路径，默认在/usr/local/nginx/logs/nginx.pid路径下。pid文件用于存放master进程的pid，会在master进程产生时生成，进程关闭时删除。当使用nginx -s reload/reopen重新加载配置文件或日志时，nginx会到该文件中读取进程pid，如果该文件无法找到或者已经被删除，nginx将报错，常用的解决方法是使用<span class=\"tips\">nginx -c 配置文件名</span>命令重新指定配置文件后启动nginx\n\n#### events块\n<div class=\"show\">...\nevents {\n    worker_connections  1024;//每个worker允许的最大连接数\n}\n</div>\n\n##### accept_mutex配置网络连接序列号\n<span class=\"strong\">accept_mutex on/off;</span>\n\n默认为on，用于解决“惊群”问题，即将连接到nginx的网络连接进行序列化，并依次分配给worker进程，防止多个worker争抢连接。\n\n##### accept_mutex配置网络连接序列号\n<span class=\"strong\">multi_accept on/off;</span>\n\n默认为off，在off状态下，一个worker进程只能接收一个新的连接请求，否则，一个worker进程将同时接收所有新连接。\n\n##### worker_connections配置单进程最大连接数\n<span class=\"strong\">worker_connections 值;</span>\n\n默认为1024，用于配置每个worker允许的最大连接数，值不能超过操作系统最大文件句柄数量。\n\n##### use配置事件处理模型\n<span class=\"strong\">use 参数;</span>\n\n可选参数有poll/select/epoll/kqueue等，Linux2.6以上内核默认使用epoll函数以优化并发连接能力。\n\n\n#### http块\n<div class=\"shell\">http {\n    include       mime.types;   //引入外部文件mime.types\n    default_type  application/octet-stream;\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #access_log  logs/access.log  main; //定义access连接日志的路径与内容\n//快速传输文件\n    sendfile        on;\n    #tcp_nopush     on;\n//服务器保持连接最大时间，单位为s\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n//传输文件前是否压缩\n    #gzip  on;\n    ....</div>\n\n#####  include\n<span class=\"strong\">include 文件名;</span>\n\n+ 用于引入外部文件，管理员可以定义一个外部文件书写配置，然后通过include将该文件内容引入到相应位置。\n+ 这里引入的mime.types用于标识文档、媒体文件格式和类型，该文件标识了常用的html、css、js、jpg等文件类型，用于帮助nginx识别请求的文件类型\n\n#####  default_type\n<span class=\"strong\">default_type MIME类型;</span>\n\n默认值application/octet-stream指没有特定类型的二进制文件，MIME类型可参考MDN文档：\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" style=\"word-wrap: break-word;\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a>\n\n##### access_log\n+ <span class=\"strong\">log_format 变量名 日志格式;</span>\n+ <span class=\"strong\">access_log 路径 变量名;</span>\n\n二者搭配使用，第一个语句用于定义一个变量名，并将配置的日志格式赋值给该变量，变量名取值需使用<span class=\"tips\">$</span>符。第二个语句用于根据变量名对应的日志格式，将用户访问日志书写到对应路径下。日志格式中对应的变量含义：\n<div class=\"table\">\n\n变量名 | 说明\n------|------\nremote_addr|客户端地址\nremote_user |客户端用户名\ntime_local  |访问时间和时区\nrequest|请求的URL和HTTP协议\nhttp_host|请求地址，即浏览器中输入的地址\nstatus |http请求返回的状态码，如：301、404等\nupstream_status|upstream状态\nbody_bytes_sent |发送给客户端的文件大小(字节)\nhttp_referer | 该请求是从哪个链接跳转过来\nhttp_user_agent |客户端信息，如：浏览器标识等\nssl_protocol|SSL协议版本\nssl_cipher|交换数据中的算法\nrequest_time|整个请求的总时间\nupstream_addr|upstream的地址，即真正提供服务的主机地址\nhttp_x_forwarded_for  |记录有代理服务器时客户端地址的配置\nupstream_response_time|请求过程中，upstream响应时间\n</div>\n\n#####  sendfile\n+ <span class=\"strong\">sendfile on/off;</span>\n+ <span class=\"strong\">tcp_nopush on/off;</span>\n\nsendfile用于高效传输文件，在sendfile为on的状态下，开启tcp_nopush会将文件积累到一定大小后再统一发送，用于提高包传输效率\n\n##### keepalive_timeout\n+ <span class=\"strong\">keepalive_timeout 值;</span>\n+ <span class=\"strong\">tcp_nodelay on/off;</span>\n\nkeepalive_timeout用于设置保持与客户端连接的最大时间，单位默认为s，超时时nginx会关闭连接并释放服务器资源，若设置为0则禁用该设置。设置的时间过大会导致大量的无效连接未断开，从而占用服务器资源，太小会导致服务未处理完，就被强制关闭连接。\n\n在keepalive_timeout启用状态下，配置tcp_nodelay on;可以将数据即使发送。\n\n##### gzip\n<span class=\"strong\">gzip on/off;</span>\n\ngzip 用于配置传输文件前是否进行压缩以提高传输速率，压缩会占用一定系统资源\n\n#### server块\n<div class=\"show\">server {\n        listen      80;   //监听端口\n        server_name  localhost;//监听的域名或ip地址\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;//日志输出路径\n        location /web/ {  //路由路径\n            root   /test;\n            index  index.html index.htm;\n        }\n        location /images {\n            root /test;\n            autoindex on;//自动生成文件归档页面\n        }\n        location /.well-known/pki-validation/{\n        root /;\n        }\n        location /new/{\n        root    /;\n        add_header Content-Disposition \"attachment;\";\n        }\n//定义404页面\n        #error_page  404              /404.html;\n//定义50x页面\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }</div>\n\n#####  listen\n<span class=\"strong\">listen 地址/端口 [default_server];</span>\n\n配置监听地址和端口，default_server参数用于将该server设置为默认主机，无该参数则第一个server为默认主机，当没有匹配到客户端指定的端口/IP时，将连接到默认主机。地址和端口格式可以为：\n\n+ listen 127.0.0.1 监听该地址所有端口\n+ listen 127.0.0.1:8080 监听该地址的8080端口\n+ listen *:8080 监听所有地址的8080端口\n\n\n ##### server_name\n<span class=\"strong\">server_name 域名/IP地址;</span>\n\n用于配置虚拟主机的标识名称，域名或IP地址可以写多个，使用空格隔开。当listen中配置了域名或IP地址，则server_name配置的域名和IP地址将失效，配置方法可以使用以下三种，当域名被多个server匹配到，将按精确匹配>通配符在开头>通配符在结尾>正则匹配>默认主机的优先级进行分配。\n\n###### 精确匹配\n<div class=\"show\">server {\n    listen 80;\n    server_name aaaa.com bbbbb.cn;//配置多个域名\n    .....}\n</div>\n\n###### 通配符匹配\n通配符只能在段首和段尾使用，不能再域名中间使用！\n<div class=\"show\">server {\n    listen 80;\n    server_name *.aaaa.com www.aaaa.*;\n    .....}\n</div>\n\n###### 正则匹配\n<div class=\"show\">server {\n    listen 80;\n    server_name ~正则表达式;\n    .....}\n</div>\n\n ##### charset\n<span class=\"strong\">charset 编码格式;</span>\ncharset 用于指定字符编码格式，默认的koi8-r为俄语编码格式(nginx作者是俄罗斯人)，与utf-8类似\n\n ##### access_log\n<span class=\"strong\">access_log 路径 日志格式;</span>\n\n用于指定该server的连接日志，日志格式默认使用http模块中的main变量定义的格式，可用<span class=\"tips\">log_format</span>命令自行定义。\n\n ##### location\n<span class=\"strong\">location 请求路径;</span>\n\n配置请求路径，可配置多个location块用于响应不同请求\n\n\n<div class=\"show\">location  /路径{   //在test目录下匹配该路径(默认)\n    root /test\n}\nlocation = /路径{   //在test目录下精准匹配该路径\n    root /test\n}\nlocation ~* \\正则表达式  {   //在test目录下正则匹配(添加*号不区分大小写)\n    root  /test            \n}\n~用于标识正则表达式，*表示不区分大小写，^~则表示不包含正则表达式，功能和不加~一致</div>\n\n ##### root/alias\n<span class=\"strong\">root/alias 路径;</span>\n\n用于指定资源查找路径，使用root语句时，客户端请求location路径，Nginx查找资源会直接前往<span class=\"tips\">root路径+location路径</span>。alias一般在需要隐藏服务器真实路径时使用，查找资源会直接前往alias路径，location路径仅作为客户端请求的虚拟路径\n\n ##### index\n<span class=\"strong\">index 文件名;</span>\n\n用于设置主页，文件名可以写多个，如: index index1.html index2.html;当找不到第一个文件时，会依次往后查找。\n\n ##### error_page\n<span class=\"strong\">error_page 状态码 [=状态码] 路径;</span>\n\n用于设置错误处理方法，根据不同的状态码，进行相应处理，常用于配置404，50x页面，可以通过添加[=状态码]修改返回给客户端的状态码，如：error_page 404 [=200] /404.html，浏览器收到的状态码将从404修改为200。路径可以为：\n+ 地址：error_page 404 http://<span></span>wrong.com\n+ 重定向:<div class=\"show\">error_page   500 502 503 504  /50x.html;\nlocation = /50x.html {\nroot   html;\n}</div>\n+ 返回信息:<div class=\"show\">error_page 404 @goto\nloaction @goto{\n    default_type text/plain;\n    return 404 'not found....'\n}</div>\n\n### Web服务器配置实例\n<strong>需求：</strong>在服务器8081和8082端口分别配置server1、server2两个服务，每个服务下有两个页面，根据客户端请求返回不同页面，为每个服务配置单独的访问日志。\n\n#### 目录树\nwebservers目录位于服务器根目录下，conf.d目录用于存放每个服务的配置文件，web目录用于存放页面和访问日志。每个服务下的logs目录用于存放access_log日志文件，webpages目录用于存放页面。\n<div class=\"shell\">webservers\n     |____conf.d\n     |          |_____server1.conf\n     |          |_____server2.conf\n     |____web\n           |____404.html\n           |____server1\n           |          |____logs——access_log\n           |          |____webpages\n           |                |____web1.html\n           |                |____web2.html\n           |____server2\n                      |_____logs——access_log\n                      |_____webpages\n                                 |_____web3.html\n                                 |_____web4.html\n</div>\n\n#### http块配置\n定义两个变量server1和server2，用于配置日志格式，两个服务的配置文件独立存放于/webservers/conf.d路径下，使用include引入nginx.conf配置文件中。\n<div class=\"show\">http{\n    ......\n    log_format server1 'new access =>$time_local';\n    log_format server2 'new access =>$time_local';\n    include /webservers/conf.d/*.conf;//引入两个服务的配置文件\n}\n</div>\n\n#### server1配置\n访问<span class=\"tips\">`http://45.77.77.10:8081`</span>访问web1页面\n\n访问<span class=\"tips\">`http://45.77.77.10:8081/pages`</span>访问web2页面\n\n<pre><code>server{\n\tlisten 8081;\n\tserver_name 45.77.77.10;\n\taccess_log /webservers/web/server1/logs/access.log server1;\n\terror_page 404 /404.html;\n    location /{\n\talias /webservers/web/server1/webpages/;\n\tindex web1.html;\n\t}\n\tlocation /pages{\n\talias /webservers/web/server1/webpages/;\n\tindex web2.html;\n\t}\n\tlocation =/404.html{\n\troot /webservers/web;\n\tindex 404.html;\n\t}\n      }\n</code></pre>\n\n##### server2配置\n访问<span class=\"tips\">`http://45.77.77.10:8082/web3.html`</span>访问web3页面\n\n访问<span class=\"tips\">`http://45.77.77.10:8082/webpages`</span>访问web4页面\n<pre><code>server{\n\tlisten 8082;\n\tserver_name 45.77.77.10;\n\taccess_log /webservers/web/server2/logs/access.log server2;\n\terror_page 404 /404.html;\n\tlocation /web3.html{\n\troot /webservers/web/server2/webpages;\n\tindex web3.html;\n\t}\n\t\n\tlocation /webpages{\n\troot /webservers/web/server2;\n\tindex web4.html;\n\t}\n\n\tlocation =/404.html{\n\troot /webservers/web;\n\tindex 404.html;\n\t}\n      }\n</code></pre>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n配置https服务时，使用<span class=\"tips\">ssl_certificatessl 路径</span>语句配置证书，使用<span class=\"tips\">ssl_certificate_key 路径</span>配置密钥</div>\n\n\n\n### 静态资源提供服务\n\n<pre><code>http {\n    .......\ngzip on;\ngzip_min_length 1;  //设置最小压缩大小，小于1字节的文件不进行压缩\ngzip_comp_level 3; //压缩级别(压缩比)，取值范围为1-9，值越大，压缩越多，cpu占用率越高\ngzip_types text/css text/javascript; //配置压缩的文件类型\n    server {\n        listen      80;\n        server_name  45.77.78.10;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n\t    location /images/ {  //匹配路径\n\t    root /test;         //资源所在路径\n\t    autoindex on;  //自动生成资源归档页面\n \t    }\n\t    location /images {  //匹配路径\n\t    root /test;         //资源所在路径\n \t    }\n         location /other/ {  //匹配路径\n\t    alias /test/images;         //资源所在路径\n \t    }\n        #error_page  404              /404.html;\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n        .....\n    }\n    ........\n}</code></pre>\ntest目录服务器根目录下，并且在/test/images路径下存放了photo.jpg照片\n\n+ 使用第一个location配置时，当访问 http:<span></span>//45.77.78.10/images/ 时，ngxin会在自动生成的归档页面上输出/test/images/目录下的所有文件。请求只能为location后面配置的参数，若请求为 http:<span></span>//45.77.78.10/test/images/则会返回404\n+ 使用第二个location配置时，由于未使用 <span class=\"tips\">autoindex on</span> 配置，nginx不会生成归档页面，当访问 http:<span></span>//45.77.78.10/images/ 时nginx将返回403，访问文件需指定具体文件路径，如：http:<span></span>//45.77.78.10/test/images/photo.jpg\n+ 当需要对访问者隐藏服务器实际文件路径时，可以使用<span class=\"tips\">alias</span>进行配置，使用第三个location配置，url应当为http:<span></span>//45.77.78.10/other/photo.jpg，此时实际访问的依旧alias指定的/test/images路径下的文件\n","tags":["Server","Web"]},{"title":"Redhat防火墙","url":"/blog/2022/02/23/Centos防火墙/","content":"<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n本文不涉及Debian系列操作系统使用的ufw(Uncomplicated FireWall)防火墙</div>\n\n### Firewalld\nFirewalld支持动态更新防火墙规则，并加入了区域（zone）的概念，zone是Firewalld预先准备的几套防火墙策略模板，用户可以根据不同生产场景选择合适的策略集合，从而实现防火墙策略之间的快速切换。\n\n#### 常用的区域\n\n<div class=\"table\">\n\n区域 | 默认策略\n-----|-------\ntrusted(信任)|允许所有数据包\nblock(阻塞)|拒绝所有数据包\ndrop(丢弃)|丢弃所有数据包，并且不回复信息\nhome(家庭)|仅接受与流出数据有关，或者与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关的数据包\npublic(公共)|仅接受与流出数据有关，或与ssh、dhcpv6-client服务相关的数据包\ninternal(内部)|仅接受与流出数据有关，或与ssh、mdns、ipp-client、dhcpv6-client服务相关的数据包\nwork(工作)|仅接受与流出的流量，或与ssh、ipp-client与dhcpv6-client服务相关的数据包\nexternal(外部)|仅接受与流出流量和ssh服务相关的数据包\nDMZ(隔离)|又称为非军事区域，内外网络之间增加的一层网络，起到缓冲作用，仅接受与流出的流量相关和ssh服务相关的数据包\n</div>\n\nfirewalld默认提供了9个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、 home.xml、internal.xml、public.xml、trusted.xml、work.xml，文件位于<span class=\"tips\">/usr/lib /firewalld/zones/</span>目录下。用户对区域进行修改后，会在<span class=\"tips\">/etc/firewalld/zones</span>目录下生成对应的(用户自定义)配置文件。\n\n#### 防火墙开启与关闭\n<div class=\"table\">\n\n命令 | 说明\n---- |------\nsystemctl start firewalld|开启防火墙\nsystemctl stop firewalld  |关闭防火墙\nsystemctl enable firewalld|开机自启动防火墙\nsystemctl disable firewalld|禁止开机自启动\nsystemctl status firewalld |查看防火墙状态\n</div>\n\n\n#### 命令与参数\n<span class=\"strong\">firewall-cmd [参数]</span>\n\n<div class=\"table\">\n\n参数 | 说明\n ----|-----\n-&zwnj;-state|查看防火墙是否在运行\n-&zwnj;-get-default-zone|查看当前生效的防火墙区域\n-&zwnj;-set-default-zone=区域名|设置生效的防火墙区域\n-&zwnj;-get-zones\t|显示所有可用的区域\n-&zwnj;-get-active-zones|显示当前正在使用的区域与网卡名称\n-&zwnj;-zone=区域名 -&zwnj;-list-all|列出指定区域的所有配置参数\n-&zwnj;-list-all-zones\t|显示所有区域的网卡配置参数、资源、端口以及服务等信息\n-&zwnj;-get-services\t|查看当前域所有支持的服务(需要放行的服务需要自行添加)\n-&zwnj;-list-services\t|查看当前区域允许放行的服务列表\n-&zwnj;-add-service=服务名|设置当前区域允许该服务的流量通过\n-&zwnj;-add-port=端口号/协议\t|设置当前区域允许该端口的流量通过\n-&zwnj;-remove-service=服务名\t|设置默认区域禁止该服务的流量通过\n-&zwnj;-remove-port=端口号/协议\t|设置当前区域禁止该端口的流量通过\n-&zwnj;-add-source=\t|将源自此IP或子网的流量导向指定的区域\n-&zwnj;-remove-source=\t|不再将源自此IP或子网的流量导向某个指定区域\n-&zwnj;-add-interface=网卡名\t|将源自该网卡的所有流量都导向某个指定区域\n-&zwnj;-change-interface=网卡名|\t将某个网卡与区域进行关联\n-&zwnj;-list-all\t|显示当前区域的网卡、资源配置，以及开放了哪些端口、服务\n-&zwnj;-reload\t|让“永久生效”的配置规则立即生效，并覆盖当前的配置规则\n-&zwnj;-panic-on|开启应急状况模式(关闭所有网络连接，包括远程ssh连接)\n-&zwnj;-panic-off\t|关闭应急状况模式\n\n</div>\n\n#### 生效模式，更新防火墙规则\n默认情况下，firewalld配置的防火墙策略为当前生效模式(Runtime)，系统重启时会失效。想让配置策略永久生效，需要添加<span class=\"tips\">-&zwnj;-permanent</span>参数使用永久模式(Permanent)，如：永久开放10800端口：firewall-cmd -&zwnj;-add-port=10800/tcp -&zwnj;-permanent ，但该模式配置的策略需要执行firewall-cmd -&zwnj;-reload命令重新加载后才会生效。\n\n<div class=\"table\">\n\n命令  | 说明\n----|-----\nfirewall-cmd -&zwnj;-reload|重新加载防火墙配置\nfirewall-cmd -&zwnj;-complete-reload |重新加载防火墙，不中断用户的连接,如远程连接（防火墙出严重故障时使用）\n</div>\n\n#### 示例\n<strong>1. 查看区域信息</strong>\n<div class=\"shell\">查看public区域的所有信息\n# firewall-cmd --zone=public --list-all\n返回值的含义：\nTarget：default                  //目标\nicmp-block-inversion：yes/no    //是否允许ICMP协议类型的数据包通过防火墙\nInterfaces：                   //关联的网卡\nsources：                     //来源，可以是IP地址或mac地址\nservices：                   //允许的服务\nports：                     //允许的端口，即本地开放的端口\nprotocols：                //允许通过的协议\nmasquerade: yes/no        //是否允许伪装，可改写来源IP地址及mac地址 \nforward-ports：          //允许转发的端口 \nsource-ports：          //允许的来源端口 \nicmp-blocks：         //可添加的ICMP类型，当icmp-block-inversion为no时，这些ICMP类型被拒绝；当icmp-block-inversion为yes时，这些ICMP类型被允许\n rich rules： //富规则，即更细致、更详细的防火墙规则策略，它的优先级在所有的防火墙策略中也是最高的。\n</div>\n\n<strong>2. 放行端口</strong>\n<div class=\"shell\">永久放行10800-10805端口的tcp数据\n# firewall-cmd --permanent --add-port=10800-10805/tcp\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n<strong>3. 为网卡绑定区域</strong>\n\n一般情况下，一台主机会有多个网卡，比如一块对公网，一块对内网，因此网卡使用的防火墙策略也不一样，可以单独为某个网卡绑定某个区域。通过firewall-cmd --set-default-zone命令设置的区域会对所有网卡生效，但如果该网卡绑定了单独的区域，则单独绑定区域的优先级更高。\n<div class=\"shell\">将网卡eth0默认区域修改为external\n# firewall-cmd --permanent --zone=external --change-interface=eth0\n</div>\n\n<strong>4. 查询服务是否放行</strong>\n\n如：查询SSH和HTTPS协议的流量是否允许放行\n<div class=\"shell\">查询public区域中SSH协议的流量是否被放行\n# firewall-cmd --zone=public --query-service=ssh\n查询public区域中https协议的流量是否被放行\n# firewall-cmd --zone=public --query-service=https\n</div>\n\n<strong>5. 放行协议流量</strong>\n\n把HTTPS协议的流量设置为永久允许放行\n<div class=\"shell\">在public区域中放行https协议的流量\n# firewall-cmd --permanent --zone=public --add-service=https\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n\n#### 端口转发\n端口转发命令格式如下，目标IP地址为所要访问服务器的IP地址：\n<span class=\"strong\">firewall-cmd --permanent --zone=区域 --add-forward-port=port=源端口号:proto=协议:toport=目标端口号:toaddr=目标IP地址</span>\n\n<div class=\"shell\">将9000端口转发到22端口，使得用户能通过9000端口使用ssh远程连接服务\n# firewall-cmd --permanent --zone=public --add-forward-port=port=9000:proto=tcp:toport=22:toaddr=192.168.0.1\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n\n#### 富规则\n富规则也叫复规则，表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置，它的优先级在所有的防火墙策略中也是最高的。\n<div class=\"shell\">拒绝192.168.0.1/24网段的所有用户访问本机的ssh服务\n# # firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.0.1/24\" service name=\"ssh\" reject\"\n重新加载防火墙配置\n# firewall-cmd --reload\n</div>\n\n\n### IPTables\n早期的RHEL系列的操作系统，默认使用IPTables来配置防火墙。RHEL7之后的系统使用firewalld取代了IPTables防火墙，IPTables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nCentos官方IPTables文档：<a target=\"_blank\" href=\"https://wiki.centos.org/HowTos/Network/IPTables\">https://wiki.centos.org/HowTos/Network/IPTables</a></div>\n\n#### 策略与规则链\nIPTables会根据管理员书写的策略来决定防火墙是否放行数据包通过，基本的策略规则有四种：ACCEPT、REJECT、LOG、DROP。IPTables会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后立即执行规则定义的行为(如：放行或阻止流量)，若在读取完所有的策略规则之后没有匹配项，则会执行默认的策略。\n\nIPTables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链。<span class=\"tips\">由于防火墙策略规则是按照从上到下的顺序匹配执行的，因此一定要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝，因此规则链最后一条往往为拒绝规则。</span>\n\n当防火墙的默认策略为拒绝时，需要添加相应的规则链来放行允许进入服务器的数据，否则服务器将拒绝所有数据包；而当防火墙的默认策略为允许时，则需要添加相应的拒绝规则链，否则防火墙就失去了它的作用。一般情况下，INPUT流量的默认策略为拒绝，OUTPUT流量默认策略为允许。\n\n#### 数据包分类与处理方式\n根据数据包的不同处理位置，数据包分为\n+ <span class=\"strong\">在进行路由选择前处理数据包(PREROUTING)</strong>\n+ <span class=\"strong\">处理流入的数据包(INPUT)</strong>\n+ <span class=\"strong\">处理流出的数据包(OUTPUT)</strong>\n+ <span class=\"strong\">处理转发的数据包(FORWARD)</strong>\n+ <span class=\"strong\">在进行路由选择后处理数据包(POSTROUTING)</strong>\n\n\n##### 数据包处理方式\n<div class=\"table\">\n\n 语句|说明\n  ---|---\nACCEPT|允许流量通过\nREJECT|拒绝流量通过并返回流量被丢弃的提示信息\nLOG   |记录日志信息\nDROP  |拒绝流量通过且不返回任何信息\n</div>\n\nREJECT会在拒绝流量后，告知流量发送方流量已收到，但服务器拒绝响应的信息\n\nDROP会直接丢弃流量，使流量发送方不清楚流量是被拒绝还是主机不在线，一般能更好保护主机安全。\n\n#### 命令与参数\n\n<span class=\"strong\">iptables [参数] [对象]</span>\n<div class=\"table\">\n\n参数 | 作用\n---|---\n-L  |查看当前的规则链，可以使用iptables -L --line-numbers命令显示规则链的序号\n-P|设置默认策略\n-F|清空规则链\n-A|在规则链末尾加入新规则\n-I [序号]|在指定序号规则前加入新规则，无序号默认在规则链首加入\n-R 序号|替换指定规则，无序号默认替换第一条规则\n-D 序号|删除指定规则\n-s IP/主机名|匹配来源的IP和主机，加!号表示除该IP外，子网掩码可以使用/MASK的方式表示\n-d |匹配目标地址，类似于参数-s\n-J |跳转到下一个处理规则，可能的值有：ACCEPT(允许数据通过), DROP(丢弃), QUEUE(进入队列), RETURN(返回上一个跳转规则)。也可以添加规则名跳转到指定规则\n-i 网卡名|匹配从该网卡流入的数据\n-o 网卡名|匹配从该网卡流出的数据\n-p 协议 |匹配协议，如:TCP、UDP等,all代表所有协议(一般不使用)\n-&zwnj;-dport 端口号|匹配目标端口号\n-&zwnj;-sport 端口号|匹配来源端口号\n\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n防火墙命令均需要root权限</div>\n<div class=\"shell\">如：查看当前规则链\niptables -L\n返回结果：\nChain INPUT (policy ACCEPT)     //INPUT数据包，默认策略为ACCEPT\nnum  target     prot opt source               destination         \n1    ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED\n2    ACCEPT     all  --  anywhere             anywhere            \n3    INPUT_direct  all  --  anywhere             anywhere            \n4    INPUT_ZONES_SOURCE  all  --  anywhere             anywhere            \n5    INPUT_ZONES  all  --  anywhere             anywhere            \n6    DROP       all  --  anywhere             anywhere             ctstate INVALID\n7    REJECT     all  --  anywhere             anywhere             reject-with icmp-host-prohibited\n</div>\n<div class=\"show\">示例：\n<strong>1. 修改INPUT规则链默认配置为拒绝，并允许允许ICMP流量进入(允许服务器被ping后返回信息)</strong>\n# iptables -P INPUT DROP\n# iptables -I INPUT -p icmp -j ACCEPT\n<strong>2. 拒绝所有人访问本机10800端口</strong>\n# iptables -I INPUT -p tcp --dport 10800 -j REJECT\n# iptables -I INPUT -p udp --dport 10800 -j REJECT\n<strong>3. 拒绝192.168.10.5主机访问本机80端口</strong>\niptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT\n<strong>4.拒绝所有主机访问本机1000～1024端口</strong>\n# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT\n# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT\n<strong>5.只允许192.168.10.0主机访问本机的22端口，拒绝来自其他所有主机的流量。</strong>\n# iptables -I INPUT -s 192.168.10.0 -p tcp --dport 22 -j ACCEPT\n# iptables -A INPUT -p tcp --dport 22 -j REJECT\n</div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n如同第5条命令，由于防火墙策略规则是按照从上到下的顺序匹配的，因此需要把允许规则放到拒绝规则前，否则所有的流量就将被拒绝</div>\n<div class=\"show\">\n网口转发,如将公网的数据包转发到内网,假设eth0连接内网，eth1连接公网\niptables -A FORWARD -i eth0 -o eth1 -j ACCEPT\n</div>\n\n\n\n#### 保存规则\n通过命令添加的规则链，会在系统重启后失效，因此需要写入配置文件使其永久生效，可以使用命令<span class=\"tips\">service iptables save</span>保存\n\nipv4默认保存位置为<span \nclass=\"tips\">/etc/sysconfig/iptables-config</span>\n\nipv6默认保存位置为<span class=\"tips\">/etc/sysconfig/ip6tables-config</span>\n\n\n\n","tags":["CentOS","firewall"]},{"title":"Bash与shell脚本","url":"/blog/2022/02/10/Bash与shell/","content":"### Bash命令\n#### 历史命令\n<span class=\"strong\">history [选项] [历史命令保存文件]</span>\n\n+ -c&emsp;清空历史命令\n+ -w&emsp;把缓存的历史命令写入历史命令保存文件~/.bash_history中\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n每个用户都有独立的历史命令保存文件，一般在用户家目录下，该文件默认隐藏，用户执行过的命令会先缓存在内存中，等登出账户后再写入bash_history文件中，历史命令默认保存1000条，用户可在环境变量配置文件/etc/profile中的HISTSIZE选项自行修改</div>\n\n#### 调用历史命令\n+ <span class=\"strong\">可通过上下箭头调用之前执行的命令</span>\n+ <span class=\"strong\">!!</span>再次执行上一次执行的命令\n+ <span class=\"strong\">!n</span>再次执行第n条历史命令(序号以history列出的序号为准)\n+ <span class=\"strong\">!字符串</span>再次执行最后一次以该字符串开头的命令\n\n#### 自定义命令名\n<span class=\"strong\">alias</span>查看所有自定义的命令\n\n<span class=\"strong\">alias 别名='原命令'</span>自定义命令名，原命令依旧可用\n\n使用命令定义的命令名只能临时生效，系统重启后将丢失，要永久生效需将自定义的命令添加到文件<span class=\"tips\">/用户名/.bashrc</span>中\n\n删除自定义的命令:\n\n<span class=\"strong\">unalias 别名</span>\n\n\n#### 命令的执行优先级\n+ 第一顺位执行通过绝对路径或相对路径执行的命令\n+ 第二顺位执行自定义的命令别名\n+ 第三顺位执行bash内部命令\n+ 第四顺位执行$PATH环境变量定义的第一个命令\n\n#### bash常用快捷键\n<div class=\"table\">\n\n|快捷键|说明|\n   ---|---\nctrl+c|强制终止当前目录\nctrl+l|清屏，同clear命令\nctrl+u|剪切光标之前的命令\nctrl+k|剪切光标之后的内容\nctrl+y|粘贴剪切的内容\nctrl+r|搜索执行过的历史命令\nctrl+d|退出当前终端\nctrl+z|暂停工作并放入后台\nctrl+a|将光标移动到命令行开头\n</div>\n\n相关命令\n+ <span class=\"strong\">stty -a</span>&emsp;查看所有快捷键\n+ <span class=\"strong\">stty 关键字 快捷键</span>&emsp;更改快捷键\n\n\n### shell简介\n#### shell的不同家族\nBourne Shell：包括sh、ksh、Bash、psh、zsh，Linux默认使用Bash\n\nC Shell：包括csh、tcsh，语法与C语言类似，主要用于BSD版Unix系统\n\n#### Linux支持的shell\n查看<span class=\"tips\">/etc/shells</span>文件可获取当前Linux支持的shell列表，Linux默认使用Bash作为命令解释器，直接输入其他shell名可进行切换，通过<span class=\"tips\"><strong>exit</strong></span>命令返回默认的Bash终端\n\n#### shell脚本的执行方式\n##### 通过路径直接运行脚本\n赋予脚本执行权限，然后运行,如对于名为HelloWorld.sh脚本，执行方式为:\n<span class=\"strong\">chmod 755 HelloWorld.sh</span>\n\n <span class=\"strong\">./HelloWorld.sh</span>\n \n\n##### 通过bash调用\nbash HelloWorld.sh\n\n#### 脚本格式转换\n在Linux中，回车符识别为<span class=\"tips\"><strong>`$`</strong></span>，而在windows中回车符为^M$，因此在windows中编写的sh脚本需要经过转换，才能在Linux中运行，转换命令为：\n<span class=\"strong\">dos2unix 文件名</span>\n相反，将文件从Linux格式转为Windows格式为\n<span class=\"strong\">unix2dos 文件名</span>\n\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n该功能需要自行安装，yum -y install dos2unix</div>\n\n\n\n### shell基础语法\n#### 脚本声明\n<div class=\"show\">#!bin/bash  //申明shell脚本\n</div>\n\n#### 基本输出\n<span class=\"strong\">echo [选项] [输出内容]</span>\n\n+ -e&emsp;支持使用\\进行字符转换\n\n\n\n#### 修改字体颜色\n通过转义序列，可以修改终端的字体、背景的颜色和显示效果。转义序列语法为：\n\n<span class=\"strong\">[代码m</span>\n\n转义序列语法前需要使用<span class=\"tips\">\\e或\\033 或\\x1B</span>来引导非常规字符序列\n\n<div class=\"show\">如：输出红色字符串 \"RedColor\"\n# echo -e \"\\e[31mRedColor \\e[0m\"\n末尾的\\e[0m用于删除所有设置的属性(包括颜色、加粗、闪烁等效果)使后续输出内容恢复默认属性\n</div>\n\n\n##### 文字效果\n<div class=\"table\">\n\n设置效果代码 | 效果 |取消效果代码\n------|--------|-------\n1|加粗高亮|21\n2|变暗|22\n4|下划线|24\n5|闪烁|25\n7|反转背景色和前景色|27\n8|隐藏(常用于密码)|28\n</div>\n\n\n##### 字体颜色\n<div class=\"table\">\n\n代码 | 颜色 |代码|颜色\n------|------|----|----\n39|默认颜色\n30|黑色|90|深灰\n31|红色|91|红色\n32|绿色|92|浅绿色\n33|黄色|93|淡黄色\n34|蓝色|94|浅蓝\n35|品红|95|浅洋红色\n36|青色|96|浅青色\n37|浅灰|97|白色\n</div>\n\n##### 字体背景色\n\n<div class=\"table\">\n\n代码 | 颜色 |代码|颜色\n------|------|----|----\n49|默认颜色\n40|黑色|100|深灰\n41|红色|101|红色\n42|绿色|102|浅绿色\n43|黄色|103|淡黄色\n44|蓝色|104|浅蓝\n45|品红|105|浅洋红色\n46|青色|106|浅青色\n47|浅灰|107|白色\n</div>\n\n##### 修改文件目录颜色\n想在使用ls命令后使各种不同类型文件显示不同颜色，可以修改<span class=\"tips\">/etc/DIR_COLORS</span>文件中的颜色配置，修改完成后使用<span class=\"tips\">eval \\`dircolors /etc/DIR_COLORS\\`</span>命令使之生效\n#### 输入输出重定向\n##### 1. 标准输入输出设备\n\n<div class=\"table\">\n\n设备|Linux文件名|文件描述符|类型\n---|---        |----     |---\n键盘|/dev/stdin|  0     |标准输入\n显示器|/dev/stdout|1    |标准输出\n显示器|/dev/stderr|2    |标准错误输出\n\n</div>\n\n##### 2. 输出重定向\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>类型</th><th>符号</th><th>作用</th></tr>\n</thead>\n<tbody>\n<tr><td rowspan=\"2\">标准输出重定向</td>\n<td>&gt;</td><td>以覆盖方式将正确命令返回内容输出到指定文件或设备中</td></tr>\n<tr><td>&gt;&gt;</td><td>以追加方式将正确命令返回内容输出到指定文件或设备中</td></tr>\n<tr><td rowspan=\"2\">标准错误输出重定向</td><td>2&gt;</td><td>以覆盖方式将错误命令返回内容输出到指定文件或设</td></tr>\n<tr><td>2&gt;&gt;</td><td>以追加方式将错误命令返回内容输出到指定文件或设备中</td></tr>\n      <tr>\n      <td rowspan=\"5\">同时输出正确和错误命令返回信息</td>\n      <td>命令&&gt;文件</td>\n      <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>命令&&gt;&gt;文件</td>\n         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>命令&&gt;文件 2&gt;&1</td>\n         <td>以覆盖方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>命令&&gt;&gt;文件 2&gt;&1</td>\n         <td>以追加方式，把正确和错误返回信息保存到同一文件中</td>\n      </tr>\n      <tr>\n         <td>命令&gt;&gt;文件1 2&gt;&gt;文件2</td>\n         <td>把正确命令返回信息追加到文件1中，错误命令返回信息追加到文件2中</td>\n      </tr>\n   </tbody>\n</table>\n</div>\n\n##### 3. 输入重定向(不常用)\n<span class=\"strong\">wc [选项] [文件名]</span>\n\n+ -c &emsp;统计字节数\n+ -w &emsp;统计单词数\n+ -l &emsp;统计行数\n\n<div class=\"show\"># wc < test\n计算test文件字符数等</div>\n\n##### 4. 多命令执行\n<div class=\"table\">\n\n多命令执行|格式|作用\n-------  |----|----\n;        |命令1;命令2|顺序执行，若前一命令执行错误，则跳过继续执行\n&&       |命令1&&命令2|当命令1正确执行，才继续执行命令2\n\\|\\|       |命令1\\|\\|命令2|当命令1正确执行，停止执行命令2，命令1错误才继续执行命令2\n</div>\n\n<div class=\"show\"># 命令 && echo true || echo false\n   类似于三目运算符，执行命令，执行正确输出true，执行错误输出false\n</div>\n\n##### 5. 管道符\n<span class=\"strong\">命令1 | 命令2</span>将命令1的输出作为命令2的输入\n\n#### 特殊符号\n\n<div class=\"table\">\n\n符号  | 作用\n---|----\n''|单引号中的所有特殊字符仅作为普通字符，无特殊含义，\n\"\" |双引号中的所有特殊字符，除了$、`、\\外，其他仅作为普通字符。命令行中的字符串之间有空格时，需要通过引号包裹\n`` |反引号，引入系统命令\n$()|同``，引入系统命令\n\\#  |注释\n$  |调用变量值\n\\  |转义符，输出$等字符可使用\\$使其无特殊含义\n\n</div>\n\n##### 字符转换\n<div class=\"table\">\n\n|字符转换|作用|\n----|----\n\\\\\\\\  |输出\\\n\\a  |输出警告音\n\\b  |退格，删除一个字符\n\\c  |取消行末的换行符,同-n选项\n\\e  |ESC键\n\\f  |换页符\n\\n  |换行符\n\\r  |回车键\n\\t  |制表符\n\\v  |垂直制表符\n\\0nnn|按照八进制ASCII码表输出字符，如:\\x106\n\\xhh |按照十六进制ASCII码表输出字符，如:\\xff\n</div>\n\n#### 根据关键字搜索grep\n<span class=\"strong\">grep [选项] 搜索内容</span>\n\n+ -i&emsp;忽略大小写\n+ -n&emsp;输出行号\n+ -v&emsp;反向查找\n+ -&zwnj;-color=auto;&emsp;搜索到的关键字用颜色高亮显示(默认)\n\n### 变量\n#### 变量类型\n+ 自定义变量\n+ 环境变量：保存和操作系统环境相关的数据\n+ 位置参数变量：用于向脚本中传递参数和数据，变量名不能自定义\n+ 预定义变量：bash预定义的变量\n\n##### 查看所有变量\n<span class=\"strong\">set</span>&emsp;查看所有变量(包括系统自定义的变量)\n\n#### 自定义变量\n+ 变量名规则同C语言，允许由字母、数字、下划线组成，但不能以数字开头\n+ bash中变量默认类型都为字符串类型\n+ 变量赋值时，若值包含空格，则需要使用单引号或双引号包裹\n+ 变量值中可以使用\\进行转义\n+ 环境变量名一般使用大写\n\n<span class=\"tips\">自定义变量不需要int、var等关键字，直接写<strong> 变量名=值</strong> 即可</span>，如：name=\"South West\"\n\n##### 删除变量\n+ <span class=\"strong\">unset 变量名</span>&emsp;删除变量\n\n#### 环境变量\n+ <span class=\"strong\">export 变量名=值</span>&emsp;定义环境变量\n+ <span class=\"strong\">env</span>&emsp;查询环境变量\n+ <span class=\"strong\">unset 变量名</span>&emsp;删除变量\n\n用户自定义的变量只在当前shell终端中有效，如果需要该变量在所有shell中生效，则需要把该变量写入环境变量的配置文件中\n\n\n\n\n\n#### 位置参数变量\n\n<div class=\"table\">\n   \n   变量|作用\n   ---|---\n   $n |n为数字，$0代表命令本身，$1-$9代表命令第1-9个参数，10以上用{}包裹，如:${10}\n   $* |代表命令行所有参数，$*将命令行所有参数作为一个整体进行处理，在遍历时循环只执行一次\n   $@ |代表命令行所有参数，$@将区分每一个参数\n   $# |代表命令行所有参数个数\n</div>\n<div class=\"show\">定义一个test.sh脚本\n#! /bin/bash\nnum1=$1\nnum2=$2\nsum=$(($num1+$num2))\necho \"sum is: $sum\"\n执行该脚本并传参\nchmod 755 test.sh\n./test.sh 10 20\n输出参数和 30\n</div>\n\n#### 预定义变量\n\n<div class=\"table\">\n   \n   变量|作用\n   ---|---\n   $? |返回上一个命令的执行状态，如果返回0则说明执行正确，返回值非0则说明上一个命令执行不正确\n   $$ |当前进程的进程号(PID)\n   $! |后台运行最后一个进程的进程号(PID)\n</div>\n\n\n#### 键盘输入\n<span class=\"strong\">read [选项] [变量名]</span>\n\n+ -p \"提示信息\" &emsp;输出提示信息\n+ -t 秒数 &emsp;read命令只等待指定时间\n+ -n 字符数&emsp;read命令只接收指定数量字符\n+ -s &emsp;隐藏输入的内容\n\n<div class=\"shell\">示例：\n#!/bin/bash\nread -t 30 -p \"input name:\" name    //30s内输入姓名并赋值给name\nread -s -t 30 -p \"input password:\" passwd  //30s内隐藏输入密码并赋值给passwd\necho \"Name is $name\"                //输出姓名\necho -e \"\\n\"                        //输出换行符\n</div>\n\n### 数值运算\n#### 声明变量类型\n<span class=\"strong\">declare [+或-] [选项] 变量名</span>\n\n+ -&emsp;给变量设置类型属性\n+ +&emsp;取消变量的类型属性\n+ -i&emsp;将变量声明为整形(integer)\n+ -x&emsp;将变量声明为环境变量\n+ -p&emsp;查看变量的类型\n\n#### 数值运算\n##### 1.通过\"$(())\"或\"$[]\"运算式\n+ <span class=\"strong\">变量名=$((运算式))</span>\n+ <span class=\"strong\">变量名=$[运算式]</span>\n\n<div class=\"shell\">示例：\n[root@localhost ~]# num1=$((11+22))\n[root@localhost ~]# num2=$[11+22]\n</div>\n\n##### 2.通过declare -i声明\n<span class=\"strong\">declare -i 变量名</span>\n<div class=\"shell\">示例：\n[root@localhost ~]# declare -i num1=11+22\n</div>\n\n\n\n##### 3.通过expr或let转换为数值\n<span class=\"strong\">变量名=$(expr $变量1 + $变量2)</span>\n\n<div class=\"shell\">示例:\n[root@localhost ~]# a=11\n[root@localhost ~]# b=22\n[root@localhost ~]# num1=$a+$b\n[root@localhost ~]# echo $num1  //输出11+22\n[root@localhost ~]# num2=$(expr $a + $b)  //严格遵守expr后空格，+号两边空格\n[root@localhost ~]# echo $num2  //输出33\n</div>\n\n#### 变量测试与内容替换\n<div class=\"table\">\n\n语句        |未定义变量y  |变量y为空      | 变量y有值\n----        |-----      |------         |----\nx=${y-新值}    |x=新值      |x为空           |x=$y\nx=${y:-新值}   |x=新值     |x=新值          |x=$y\nx=${y+新值}    |x为空      |x=新值           |x=新值\nx=${y:+新值}   |x为空      |x为空           |x=新值\nx=${y=新值}    |x=y=新值   |x为空，y值不变 |x=$y,y值不变\nx=${y:=新值}   |x=y=新值   |x=y=新值      |x=$y,y值不变\nx=${y?新值}    |新值输出到标准错误输出|x为空 |x=$y\nx=${y:?新值}    |新值输出到标准错误输出|新值输出到标准错误输出 |x=$y\n</div>\n\n<div class=\"shell\">示例：\n[root@localhost ~]# x=${y-new}    //new值可任意\n[root@localhost ~]# echo $x      //未定义y，x值也为new\n[root@localhost ~]# y=\"\"         //定义y，赋为空\n[root@localhost ~]# x=${y-new}   //此时x为空\n</div>\n\n\n### 环境变量\n#### 环境变量配置文件\n##### 全局配置文件\n对所有用户生效\n+ <strong>/etc/profile</strong>&emsp;主要的配置文件，也是用户登录时最先读取的文件\n+ <strong>/etc/profile.d/.sh后缀文件</strong>&emsp;由profile调用\n+ <strong>/etc/bashrc</strong>&emsp;定义PS1等bash终端的环境\n\n##### 用户配置文件\n只对单一用户生效，每个用户都有自己的配置文件，root用户位于/root下，普通用户位于/home/用户名下，默认隐藏，需要使用ls -a命令才能看见文件\n\n+ ~/.bash_profile &emsp; 用户个人的/etc/profile文件 \n+ ~/.bashrc &emsp;写有用户自定义的命令别名等\n+ ~/.bash_logout &emsp;用户注销时执行的环境变量配置文件，可以写一些我们希望系统关机时执行的操作，如备份日志等\n+ ~/.bash_history &emsp;记录用户执行过的命令\n\n\n##### 不重启就使配置文件生效\n直接执行任一命令\n+ <span class=\"strong\">source 文件名</span>\n+ <span class=\"strong\">.配置文件名</span>\n\n#### /etc/profile配置文件\n配置文件中变量的主要作用\n<div class=\"table\">\n\n变量| 作用\n---- |-----\nUSER   |当前用户\nLOGNAME|当前用户名，配置文件中LOGNAME=$USER，因此同USER\nMAIL   |用户邮箱\nHOSTNAME|主机名\nHISTSIZE|历史命令保存条数 \numask   |设置文件默认权限\n</div>\n\n\n\n#### 全局执行脚本方式\n执行脚本一般需要在赋予脚本执行权限后，使用绝对路径调用，或者进入脚本所在目录，使用相对路径调用。全局使用的脚本和命令，Linux是根据PATH寻找相应路径自动执行实现的，可通过<span class=\"strong\">echo $PATH</span>查看当前配置的全局路径，手动安装的服务想实现全局执行脚本，有两种实现方法：\n+ <span class=\"strong\">将脚本cp复制到PATH中的某个路径下，如:/usr/bin下</span>\n+ <span class=\"strong\">通过变量叠加的方式，将脚本路径添加到PATH变量中，格式为PATH=\"$PATH\":路径</span>\n\n通过变量叠加的方式添加的全局变量，在系统重启后将失效，永久生效方法是将路径添加到<span class=\"tips\">/etc/profile</span>文件的PATH变量后\n<div class=\"show\">如Nginx的启动脚本在/usr/local/nginx/sbin路径下，非全局启动方法为：\n1.相对路径： 在 /usr/local/nginx/sbin 路径下执行./nginx \n2. 绝对路径：执行 /usr/local/nginx/sbin/nginx\n添加到全局的方法为：\n执行PATH=\"$PATH\":/usr/local/nginx/sbin\n使调用命令永久生效的方法：在 /etc/profile 中最后一行添加\nPATH=$PATH:/usr/local/nginx/sbin\n</div>\n\n#### 修改命令提示符\n默认情况下的命令提示符为<span class=\"tips\">[用户名@主机名 当前目录]提示符</span>，如：[root@localhost ~]#，该默认值由系统定义的变量<span class=\"tips\">PS1</span>决定，可通过<span class=\"strong\">echo $PS1</span>&emsp;查看当前配置，也可以通过修改PS1变量自定义命令提示符，如：\n<div class=\"show\">PS1='[\\u@\\t \\w]#'\n命令提示符将修改为：\n[root@15:21:13 /home/user1]#\n</div>\n但通过修改变量自定义的命令提示符，只在本次登录有效，系统重启后将失效，需要永久修改命令提示符，可以将上述语句写入配置文件<span class=\"tips\">/etc/bashrc</span>中，自定义命令提示符常用的转义符有：\n<div class=\"table\">\n\n转义符| 作用\n---- |-----\n \\d  |显示当前系统日期，格式为\"星期 月 日\"\n \\h  |显示简写主机名\n \\t  |显示24小时制时间，格式为\"HH:MM:SS\"\n \\T  |显示12小时制时间，格式为\"HH:MM:SS\"\n \\A  |显示24小时制时间，格式为\"HH:MM\"\n \\u  |显示当前用户名\n \\w  |显示当前所在目录完整名称\n \\W  |显示所在目录最后一个目录\n \\\\#  |显示执行的第几个命令\n \\$   |提示符，root用户提示符为\"#\"，普通用户为\"$\"\n</div>\n\n##### 修改bash终端颜色\n永久修改Bash终端的默认配色，可以修改<span class=\"tips\">/etc/bashrc</span>配置文件中的PS1变量，若只想修改某个用户的终端，可以修改该用户家目录下的<span class=\"tips\">.bashrc</span>配置文件中的PS1变量。\n\n配置文件中修改颜色的语句需要用\"[]\"包裹，并且\"[]\"前需要使用转义符，并使用\\\\e获取颜色设置字符，即语法为：\n\n<span class=\"strong\">\\\\[\\e[颜色码m\\\\]</span>\n\n修改完使用<span class=\"tips\">source 文件名</span>使之生效\n\n<div class=\"shell\">如在/etc/bashrc文件最后一行添加语句：\nPS1='\\[\\e[0m\\][\\[\\e[36m\\]\\u\\[\\e[34m\\]@\\h \\[\\e[36m\\]\\W\\[\\e[0m\\]]\\[\\e[95m\\]#\\[\\e[0m\\]'\n终端提示符将变为：\n[<span style=\"color:#0cf8fc;\">root</span><span style=\"color:#0c8afc;\">@myLinux</span> <span style=\"color:#0cf8fc;\">etc</span>]<span style=\"color:#fc0ce6;\">#</span>\n</div>\n\n#### 本地终端登录欢迎信息\n需要修改本地终端登录时显示的信息，可修改配置文件<span class=\"tips\">/etc/issue</span>，配置文件中可使用的转义字符：\n\n<div class=\"table\">\n\n转义符| 作用\n---- |-----\n \\d  |显示当前系统日期\n \\t  |显示当前系统时间\n \\s  |显示操作系统名称\n \\l  |显示登录的终端号\n \\m  |显示硬件架构信息，如i386等\n \\n  |显示主机名\n \\o  |显示域名\n \\r  |显示内核版本\n \\u  |显示当前用户登录的序列号\n\n</div>\n\n<div class=\"show\">最小化安装的Centos7默认配置为：\n\\S\nKernel \\r on an \\m\n</div>\n\n\n#### 远程终端登录欢迎信息\n修改远程终端登录时显示的信息，可修改配置文件<span class=\"tips\">/etc/issue.net</span>，该文件不支持上述本地终端登录可用的转义字符，需要显示此欢迎信息，需要在配置文件<span class=\"tips\">/etc/ssh/sshd_config</span>中加入<span class=\"tips\">Banner /etc/issue.net</span>配置内容(需要重启生效)\n\n<div class=\"shell\">/etc/ssh/sshd_config文件添加配置位置:\n#UseLogin no\n#UsePrivilegeSeparation sandbox\n#PermitUserEnvironment no\n#Compression delayed\n#ClientAliveInterval 0\n#ClientAliveCountMax 3\n#ShowPatchLevel no\n#UseDNS yes\n#PidFile /var/run/sshd.pid\n#MaxStartups 10:30:100\n#PermitTunnel no\n#ChrootDirectory none\n#VersionAddendum none\n\n\\# no default banner path\n#Banner none\n<span style=\"color:rgb(232, 250, 0)\">Banner</span><span style=\"color:rgb(250, 0, 136);\"> /etc/issue.net</span>\n\n\\# Accept locale-related environment variables</div>\n\n\n#### 配置终端登录成功后的提示信息\n配置文件位于<span class=\"tips\">/etc/motd</span>，用于在远程和本地终端登录成功后显示提示信息，文件默认为空\n\n\n### 字符串\n#### cut字段提取\n<span class=\"strong\">cut [选项] 文件名</span>\n\n+ -f 列号 &emsp;提取第几列\n+ -d 分隔符&emsp;按照分隔符识别目标内容中的列(可以识别制表符和其他特殊符号，但不能识别空格)\n\n从文本或命令输出中提取列内容，grep为提取行内容，因此二者搭配可根据行列精确提取对应内容。cut无法识别以空格为分隔符的内容。\n\n<div class=\"shell\">如 /etc/passwd 文件中保存了Linux用户信息\nuser1:x:1001:1001::/home/user1:/bin/bash\nuser2:x:1002:1002::/home/user2:/bin/bash\nuser3:x:1003:1003::/home/user3:/bin/bash\n从中提取普通用户的用户名与UID\ncat /etc/passwd | grep /bin/bash | grep -v root | cut -d \":\" -f 1,3\n1. 普通用户默认使用/bin/bash，通过grep /bin/bash识别\n2. 通过grep -v root去除root用户,\n3. 文件使用:为分隔符，使用-d 识别分隔符\n4. 截取1，3列即用户名和UID\n</div>\n\n#### printf格式化输出\n<span class=\"strong\">printf '输出类型输出格式' 输出内容</span>\n\n输出类型\n\n+ %ns:&emsp;输出字符串，n指定输出个数\n+ %ni:&emsp;输出整数，n指定输出个数\n+ %m.nf:&emsp;输出浮点数，m为总位数，n为小数位数\n\n输出格式\n<div class=\"table\">\n\n字符 |  作用\n---- |------\n\\a   |输出警告音\n\\b |输出退格键\n\\f |清除屏幕\n\\n|换行\n\\r|回车\n\\t|水平输出制表符\n\\v|垂直输出制表符\n</div>\n\n<div class=\"show\">示例：\n# printf '%s\\t %s\\t %s\\t' 6 6 6  //格式输出6 6 6\n# printf '%s' $(cat test.txt)   //无任何格式输出test.txt文件内容\n</div>\n\n#### awk命令\n<span class=\"strong\">awk '条件1{操作1}&emsp;条件2{操作2} .....' [文件名]</span>\n\n提取列内容，满足条件1，执行操作1，以此类推。C语言中的大部分数学表达式都可作为条件\nawk支持printf和print命令，其中print命令会在每行自动添加换行符后再输出，printf需要手动输入\\n。\n\n\n<div class=\"show\">示例：df -h 命令可以查看当前磁盘使用情况\nFilesystem      Size  Used Avail Use% Mounted on\ndevtmpfs        229M     0  229M   0% /dev\ntmpfs           241M     0  241M   0% /dev/shm\ntmpfs           241M   29M  212M  12% /run\ntmpfs           241M     0  241M   0% /sys/fs/cgroup\n/dev/vda1       9.4G  2.6G  6.3G  30% /\n需求：检测根目录 / 文件占用百分比\ndf -h | grep /dev/vda1 | awk '{print $5}'    //$5代表第5列内容\n</div>\n\n<div class=\"show\">示例：文件test.txt中有内容\nname ID     Grade\nstu1 1001    65\nstu2 1002    60\nstu3 1003    55\n找出Grade小于60并列出姓名\ncat test.txt | grep -v name |awk '$3<60 {print $1 \"\\n\"}'\n1. grep -v name去除第一行内容\n2. awk '$3<60 {print $1 \"\\n\"}'找出列3小于60的值并返回列1\n</div>\n\n##### BEGIN\nBEGIN作为awk的一种条件，用于在最开始执行操作，如在读取数据之前执行某操作\n<div class=\"show\">示例：\nawk 'BEGIN{print \"first printf\"} {print $4 \"\\t\" $5}' test.txt\n在读取test.txt文件前先输出 first printf ，再输出该文件第4和第5列\n</div>\n\n##### END\n类似于BEGIN，在最后执行操作\n<div class=\"show\">示例：\nawk 'BEGIN{print \"first printf\"}END{print \"END!\"} {print $4 \"\\t\" $5}' test.txt\n在读取test.txt文件前先输出 first printf ，再输出该文件第4和第5列,最后输出END!\n</div>\n\n##### 常用的内置变量\nawk有自己内置的特殊变量集合，常用变量有：\n\n<div class=\"table\">\n\n变量名|说明\n----|-----\nFILENAME|当前输入文件名\n$数值|$0为当前整行，$1表示第1个字段，$2表示第2个字段，以此类推\nNR|当前输入行号，多文件记录递增\nFNR |与NR类似，多文件记录不递增，每个文件都从1开始\nNF|当前输入行的字段编号\nFS |输入字段分隔符\nOFS |输出字段分隔符，默认为空格\nRS |输入记录分隔符\nORS |输出记录分隔符，默认为换行符\n</div>\n\n<div class=\"shell\">例：\n同cut语句的例子，提取所有非root用户用户名和UID可用\n#cat /etc/passwd | grep \"/bin/bash\" | awk 'BEGIN {FS=\":\"} {printf $1 \"\\t\" $3 \"\\n\"}' \n使用内置变量FS指定输入字段的分隔符，使用BEGIN在读取文件前进行分隔符设置\n</div>\n\n<div class=\"shell\">例：\n如一个通信记录文件\nliudehua:13212345678:ldh@mail.com\nwuyanzu:13112345678:wyz@mail.com\n可以将每一行看作是一个记录，一个记录包含三个字段，由此\nawk 'BEGIN{FS=\":\";RS=\"\\n\";OFS=\"\\t\";ORS=\"**\\n\"}{print $1,$2,$3}' awktest.txt \n将换行符识别为记录分隔符，并用**\\n代替；将：识别为字段分隔符，并用制表符代替。\n字段必须写为$1,$2,$3格式，否则OFS将不生效\nldh   13212345678   ldh@mail.com**\nwyz\t13112345678   wyz@mail.com**\t\n</div>\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n自定义分隔符必须要写条件BEGIN，使之在读取数据前生效</div>\n\n#### sed命令\n<span class=\"strong\">sed [选项] '[操作]' [文件名]</span>\n进行数据的选取、替换、删除、新增\n\n<strong>常用选项</strong>\n\n+ -n&emsp;只显示sed处理的行到屏幕上，默认情况下sed会显示所有数据\n+ -e&emsp;允许使用多条Sed命令处理输入数据\n+ -i&emsp;sed处理结果应用到文件，不再输出到屏幕\n\n<strong>常用操作</strong>\n\n+ a&emsp;追加，在当前行之后添加一行或多行，添加多行内容时，在输入一行内容后添加\\，并在下一行添加第2行内容，以此类推\n+ c&emsp;替换，使用c之后的内容替换原数据行，替换多行同上\n+ i&emsp;插入，在当前行之前插入一行或多行，插入多行同上\n+ d&emsp;删除指定行\n+ p&emsp;输出指定行到屏幕\n+ s&emsp;字符串替换，格式为\"行号s/旧字符/新字符/g\"\n\n<div class=\"show\">示例：文件test.txt中有内容\nname ID     Grade\nstu1 1001    65\nstu2 1002    60\nstu3 1003    55\n命令\nsed -n '2p' test.txt\n显示第2行内容到屏幕，-n只显示sed处理的行，'2'指定行号，'p'输出指定行到屏幕\nsed '3i stu5 1005 58 \\\n> stu6 1006 66' test.txt\n在第3行之前插入两行内容，新的test.txt内容为\nname ID     Grade\nstu1 1001    65\nstu5 1005    58\nstu6 1006    66\nstu2 1002    60\nstu3 1003    55\n以上命令只修改输出到屏幕的内容，修改文件内容需添加-i参数，如：\nsed -i '3s/58/66/g' test.txt\n替换第3行内容中的58为66，并将修改应用到文件\n不添加行号会修改文件中所有匹配到的内容，修改内容可为空，如：\nsed -i 's/58//g' test.txt\n</div>\n\n#### sort排序处理\n<span class=\"strong\">sort [选项] [文件名]</span>\n\n将文件或命令结果进行排序，默认以每行第一个字母为依据，按字母顺序排序\n\n+ -f&emsp;忽略大小写\n+ -n&emsp;按数值大小进行排序\n+ -r&emsp;反向排序\n+ -t&emsp;指定分隔符为分段依据\n+ -k n[,m]&emsp;指定字段为排序依据，不指定m则判断依据为以n字段开始到本行末\n\n<div class=\"show\">示例：\nsort /etc/passwd\n按passwd文件每行首字母进行排序显示\nsort -n -t \":\" -k 3,3 etc/passwd\n指定字段以:分隔，按第3字段(UID)值大小进行排序显示\n</div>\n\n### 条件判断\n#### 检测文件类型\n+ <span class=\"strong\">test 选项 文件名</span>\n+ <span class=\"strong\">[选项 文件名 ]</span>\n返回值在终端上需要用$?查看\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n-e |判断文件是否存在\n-d |判断文件是否存在，且是否为目录文件\n-f |判断文件是否存在，且是否为为普通文件\n-b |判断文件是否存在，且是否为块设备文件(如：硬盘设备文件)\n-c |判断文件是否存在，且是否为字符设备文件(如：鼠标、键盘设备文件)\n-L |判断文件是否存在，且是否为链接文件\n-p |判断文件是否存在，且是否为管道文件\n-s |判断文件是否存在，且是否非空，非空为true\n-S |判断是否为套接字文件\n</div>\n\n#### 检测文件权限\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n-r |判断文件是否存在，且是否拥有读权限\n-w |判断文件是否存在，且是否拥有写权限\n-x |判断文件是否存在，且是否拥有执行权限\n-u |判断文件是否存在，且是否拥有SUID权限\n-g |判断文件是否存在，且是否拥有SGID权限\n-k |判断文件是否存在，且是否拥有SBit权限\n</div>\n\n检测读(写/执行)权限时，文件所有者、所属组、其他任意拥有读(写/执行)权限都将返回true\n\n\n#### 两个文件间的比较\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n文件1 -nt 文件2 |判断文件1的修改时间是否比文件2新\n文件1 -ot 文件2 |判断文件1的修改时间是否比文件2旧\n文件1 -et 文件2 |判断文件1和文件2的i节点(Inode)是否一致，即判断是否为同一文件，常用于判断是否为硬链接\n</div>\n\n#### 两个整数的比较\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n整数1 -eq 整数2 |判断整数1与整数2是否相等\n整数1 -ne 整数2 |判断整数1与整数2是否不相等\n整数1 -gt 整数2 |判断整数1是否大于整数2\n整数1 -lt 整数2 |判断整数1是否小于整数2\n整数1 -ge 整数2 |判断整数1是否大于等于整数2\n整数1 -le 整数2 |判断整数1是否小于等于整数2\n</div>\n\n#### 字符串判断\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n-z 字符串 |判断字符串是否为空\n-z 字符串 |判断字符串是否为非空\n字符串1==字符串2 |判断字符串1和字符串2是否相等\n字符串1!=字符串2 |判断字符串1和字符串2是否不相等\n</div>\n\n字符串可以使用 $变量名 取值\n\n#### 多重判断\n\n<div class=\"table\">\n\n测试选项 | 作用\n---|----\n判断1 -a 判断2 |逻辑与，判断1和判断2都成立，结果为真\n判断1 -o 判断2 |逻辑或，判断1和判断2任意一个成立，结果为真\n! 判断         |结果取反\n</div>\n\n<div class=\"show\">示例：\na=10\n[ -n \"$a\" -a \"$a\" -gt 20] && echo \"true\" || echo \"false\"\n判断a是否有值，并且判断a是否大于20，都成立输出 true，否则输出 false\n</div>\n\n### 流程控制语句\n#### if语句\n<div class=\"show\"><span class=\"strong\">if语句的格式为:</span>\n   if [条件判断] ;         //;可省略\n   then\n     程序体\n   fi\n   <span class=\"tips\">或</span>\n    if [条件判断] \n      then\n            条件成立执行\n      else\n            条件不成立时执行\n   fi\n   <span class=\"tips\">多分支if语句</span>\n   if [条件判断] \n      then\n            条件成立执行\n   elif [条件判断]\n      then\n            条件成立时执行\n   (.....)\n   else\n         上述所有条件不成立时执行\n   fi\n</div>\n\n#### case语句\n<div class=\"show\"><strong>case语句格式为：</strong>\ncase $变量 in\n   \"值1\")\n            程序1\n      ;;\n   \"值2\")\n            程序2\n      ;;\n     .....\n     *)\n         上述条件都不满足，执行该程序\n     ;; \nesac\n</div>\n\n#### for语句\n<div class=\"show\"><strong>for语句格式：</strong>\n for 变量 in 值1 值2 值3.....\n   do \n      程序\n   done\n</div>\n\n<pre><code> #! /bin/bash\n cd /lamp\n ls *.tar.gz>ls.log\n for i in $(cat ls.log)\n   do\n      tar -zxf $i &>/dev/null\n   done\n rm -rf /lamp/ls.log\n # 功能：将lamp目录下的所有压缩包文件名写入ls.log文件中，再遍历ls.log文件依次解压所有包\n </code></pre>\n\n<div class=\"show\"><strong>for语句格式2：(类似于c语言，注意双括号)</strong>\n  for((初始值;条件;变量变化))\n   do\n     程序\n   done\n</div>\n\n#### whlie与until循环\n<div class=\"show\"><strong>whlie语法结构:</strong>\n   whlie [判断语句]\n      do\n         程序\n      done\n</div>\n\n<div class=\"show\"><strong>until语法结构：</strong>\n  until [条件判断]\n   do\n     程序\n   done\n</div>\n","tags":["Linux","shell"]},{"title":"Linux文件与权限","url":"/blog/2022/01/22/Linux文件与权限/","content":"\n### 文件与目录管理\n#### 常见的文件类型\n1. <span class=\"tips\"><strong>普通文件：</strong></span>最为常见的文件类型，包括纯文本文件(ASCII)，二进制文件(binary)，数据文件(data)等\n2. <span class=\"tips\"><strong>目录：</strong></span>即文件夹，用于包含更多目录和文件\n3. <span class=\"tips\"><strong>块设备文件：</strong></span>将硬盘、光盘等存储设备以文件形式供用户操作\n4. <span class=\"tips\"><strong>字符设备文件：</strong></span>将串行端口的接口设备，如键盘、鼠标等以文件形式供用户操作\n5. <span class=\"tips\"><strong>套接字文件：</strong></span>又称为数据接口文件，用于网络数据连接\n6. <span class=\"tips\"><strong>管道文件：</strong></span>用于解决多个程序同时存取一个文件所造成的错误\n7. <span class=\"tips\"><strong>链接文件：</strong></span>分为硬链接和软链接，类似于快捷方式\n\n#### 查看目录\n##### 1. 查看目录(list)信息\n<span class=\"strong\">ls [可选参数] [文件或目录]</span>\n\n+ -a &emsp;显示所有文件，包括隐藏文件\n+ -l &emsp;显示详细信息，默认情况下文件大小只以byte显示，命令可以直接写为 ll\n+ -d &emsp;查看目录信息而非展示目录所含文件\n+ -h &emsp;常与l参数一起使用，文件大小会被换算为KB、MB等单位\n+ -i &emsp;查看文件i节点\n\n如果不指定文件或目录名，操作对象为当前目录\n\n<div class=\"show\">示例：\n# ls\n列出当前目录所含非隐藏文件或文件夹\n# ll (同ls -l)\n列出当前目录所含非隐藏文件或文件夹详细信息\n# ls -ld\n列出当前目录的详细信息\n#ls -ldh tmp\n列出tmp目录的详细信息，并且文件大小会被换算为KB等方便阅读的单位\n</div>\n\n##### 2. 文件信息详解\n使用<span class=\"tips\">ls -l</span>等命令列出文件详细信息，文件信息格式类似于\n<div style=\"text-align:center;\"><span class=\"tips\">&emsp;drwxr-xr-x.  &nbsp;6&nbsp; root&nbsp; root&nbsp; 4.0K &nbsp;Feb&nbsp;  9&nbsp; 11:53&nbsp; home&emsp;</span></div>\n\n##### 字段一\n###### 第1位\n第1位表示文件类型\n+ -为普通文件\n+ d为目录\n+ l为链接文件\n+ c为字符设备文件，如：鼠标、键盘设备文件\n+ b为块设备文件，如：硬盘设备文件\n+ s为套接字文件，一般用于数据连接，常见于 /var/run目录\n+ p为管道文件(FIFO)，用于解决多个程序同时存取一个文件所造成的错误\n\n###### 第2-10位\n3位为一组，分别为文件所有者、所属组、其他用户的读、写、执行权限\n+ r为可读\n+ w为可写\n+ x为可执行\n+ -为无权限\n\n###### 第11位 .号\n.号为安装有SElinux的系统特有，这个点表示该文件带有“SELinux的安全上下文\"\n##### 其他字段\n之后的字段分别表示\n+ 该文件被硬链接调用过的次数\n+ 文件所属用户\n+ 文件所属组\n+ 文件大小\n+ 文件最后一次修改时间，无修改则为创建时间\n+ 文件名\n\n#### 创建目录\n\n##### 1.创建目录(make directory)\n<span class=\"strong\">mkdir [-p] 目录名</span>\n\n+ 使用-p 可以递归创建目录，在不存在的目录下创建新目录\n+ 目录名可以写多个来同时创建多个目录\n\n<div class=\"show\">示例：\n# mkdir tmp/test/newdir\n如果tmp目录下没有test目录，将提示无test目录，此时可以用-p参数\n# mkdir -p tmp/test/newdir\n将在tmp下新建test，再在test下新建newdir目录\n# mkdir newdir1 newdir2 newdir3\n在当前路径下新建三个目录\n</div>\n\n##### 2.切换目录(change directory)\n<span class=\"strong\">cd 目录名</span>\n\n+ 目录名可以用<span class=\"tips\"> Tab键 </span>补全\n+ Linux中使用<span class=\"tips\"> . </span>表示当前目录，<span class=\"tips\"> .. </span>表示上一级目录，可以使用<span class=\"tips\">cd .. </span>返回上一级目录\n\n##### 3.查看当前路径(print working directory)\n<span class=\"strong\"> pwd </span>\n显示工作目录的路径\n\n##### 4.删除空目录(remove empty directory)\n<span class=\"strong\"> rmdir 目录名 </span>\n系统不允许使用该命令删除有内容的目录\n\n##### 5.删除文件与目录(remove)\n<span class=\"strong\"> rm [-rf] 文件或目录名</span>\n\n+ -r&emsp;删除目录需要使用该参数\n+ -f&emsp;强制删除，不再询问用户确认\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nLinux无回收站功能，文件会被直接删除</div>\n\n##### 5.复制文件或目录(copy)\n<span class=\"strong\"> cp [可选参数] [源文件或目录] [目标目录]</span>\n\n+ -r &emsp;复制目录\n+ -p &emsp;保留文件属性，如文件修改时间\n+ 复制文件不需要任何参数，复制目录使用-r\n+ 源文件或目录可以有多个来同时复制多个文件\n+ 复制文件的同时可以将新文件改名\n<div class=\"show\">示例：\n# cp /file/test1 /file/test2 /newdir\n复制文件test1和test2到newdir目录中\n# cp -p install.log /tem\n复制install.log文件到tem目录中并保留install.log文件信息(不使用-p参数则文件最后修改时间为执行复制操作的当前时间)\n# cp -r /usr/dir /tem/newdir\n复制目录dir到tem目录下并命名为newdir\n</div>\n\n##### 6.移动文件和修改文件名(move)\n<span class=\"strong\"> mv [源文件或目录] [目标目录]</span>\n\n+ 如果目标目录没有对应名字，则为修改文件名操作\n+ 源文件或目录可以有多个来同时移动多个文件\n\n#### 文件操作\n##### 1. 创建空文件\n<span class=\"strong\"> touch [文件名]</span>\n\n+ 可以同时创建多个文件，文件名之间用空格隔开\n+ 如果文件名中有空格符，需要使用\"\"\n<div class=\"show\">示例：\n# touch file1 file2\n创建两个文件file1、file2\n# touch \"fi le\"\n创建一个名为fi le的文件\n</div>\n\n##### 2. 查看文件内容\n###### 2.1 查看短文件\n<span class=\"strong\"> cat [-n] [文件名]</span>\n\n+ -n &emsp;显示行号\n从头到尾正常显示文件\n\n<span class=\"strong\"> tac [-n] [文件名]</span>\ncat反写，从尾到头显示文件(文件末行为第一行)\n\n###### 2.2 查看长文件\n<span class=\"strong\"> more [文件名]</span>\n分页显示文件，一般用于查看长文件\n\n+ 空格或f &emsp;向下翻页\n+ b     &emsp;&emsp; &emsp;&nbsp;向上翻页\n+ Enter  &emsp;&emsp;换行\n+ q或Q &emsp;&emsp;退出\n\n<span class=\"strong\"> less [文件名]</span>\n分页显示文件，一般用于查看长文件，支持关键字搜索\n\n+  空格或f或PageDown&emsp;向下翻页\n+ b或PageUp&emsp;&emsp;&emsp;&emsp;&emsp;向上翻页\n+ 上下方向键&emsp;&emsp;&emsp;&emsp;&emsp;逐行翻动\n+ 可以使用<span class=\"tips\"> /关键字 </span>进行关键字搜索，使用<span class=\"tips\"> n </span>跳转到下一个高亮显示的关键字\n+ q或Q &emsp;&emsp;退出\n\n###### 2.3 仅查看前几行或后几行\n<span class=\"strong\"> head [-n 行号] 文件名</span>\n仅仅查看文件前几行，不使用 -n 指定行号，默认显示前10行\n\n<span class=\"strong\"> tail [可选参数] 文件名</span>\n\n+ -n 行号 &emsp; 仅仅查看文件末几行，不使用 -n 指定行号，默认显示后10行\n+ -f &emsp;&emsp;&emsp;动态显示文件末尾，常用于查看日志文件实时变更\n\n#### 链接文件\n软链接：类似于Windows的快捷方式，读取、执行等操作依旧基于源文件，当源文件删除，软链接文件也将失效\n<p>硬链接：相当于复制了一份文件，并且当源文件发生改动，硬链接文件会同步更新，源文件删除，硬链接文件依旧有效</p>\n\n<span class=\"strong\">ln [-s] 源文件 目标文件</span>\n -s 为生成生成软链接，无该参数为生成硬链接\n\n<div class=\"show\">示例:\n# ln /etc/issue /tmp/issue.hard\n为/etc/issue创建硬链接\n# ln -s /etc/issue /tmp/issue.soft\n为/etc/issue创建软链接\n</div>\n\n二者区别:\n+ 生成的软链接权限都为 rwxrwxrwx，实际权限取决于源文件权限\n+ 硬链接文件 i 节点与源文件相同，软链接不同\n+ 硬链接指向不能跨分区，软链接可以\n+ 不能给目录生成硬链接，软链接可以\n\n### 文件与目录权限管理\n#### 权限管理中的参数\n\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n<th>对文件</th>\n<th>对目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>读权限</td>\n<td>可以查看文件内容</td>\n<td>可以列出目录中的内容</td>\n</tr>\n<tr>\n<td>w</td>\n<td>写权限</td>\n<td>可以修改文件内容</td>\n<td>可以在目录中创建、删除文件</td>\n</tr>\n<tr>\n<td>x</td>\n<td>执行权限</td>\n<td>可以执行文件</td>\n<td>可以进入目录</td>\n</tr>\n<tr>\n<td>-</td>\n<td>无权限</td>\n<td>无权限</td>\n<td>无权限</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n<span class=\"tips\">删除某个文件需要对包含该文件的母目录拥有w权限，对文件拥有w权限只能修改文件内容而不能进行删除</span>\n\n#### 更改权限(change the permissions mode of a file)\n<span class=\"strong\">chmod [-R] [{ugoa}{+-=}{rwx}] [文件名或目录名]</span>\n只有root用户与文件所有者才能修改文件的权限\n+ -R&emsp;递归修改，修改目录及其所有子文件的权限\n+ u为文件所有者，g为文件所属组，o为其他用户，a为所有用户\n+ +为添加权限，-为取消权限，=为修改权限为等号所指\n+ 同时修改ugoa中的多个可以使用 , 号分隔\n<div class=\"show\">示例：\n# chmod g+w,o-r file\n添加文件所属组写权限，取消文件其他用户的读权限\n# chmod a=rwx file\n将所有人权限都修改为 rwx</div>\n可以将rwx写为mode值之和\n<p><span class=\"strong\">chmod [mode] [文件名或目录名]</span></p>\n\n+ r 值为4\n+ w 值为2\n+ x 值为1\n+ rwx值为7，rw-值为6，r-x值为5依此类推\n<div class=\"show\">示例：\n# chmod 640 index.html\n修改权限为rw-r-----</div>\n\n#### 更改文件所有者(change file ownership)\n<span class=\"strong\">chown [用户] [文件名或目录名]</span>\n<p><span class=\"tips\">只有root用户才能更改文件所有者</span></p>\n\n#### 更改文件所属组(change file group ownership)\n<span class=\"strong\">chgrp [用户组] [文件名或目录名]</span>\n<p><span class=\"tips\">只有root用户才能更改文件所属组</span></p>\n\n#### 更改新建文件时的默认权限设置(the user file-creation mask)\n+ <span class=\"strong\">umask -S</span>&emsp;显示新建目录时权限的默认设置\n+ <span class=\"strong\">umask</span>&emsp;显示默认权限值\n+ <span class=\"strong\">umask  权限值</span>&emsp;修改默认权限\n\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n新建的文件相较于新建的目录所有用户会少一个x权限，这是因为Linux会取消新建文件的可执行权限以防止危害系统的可执行程序运行</div>\n<div class=\"show\">root执行umask显示默认权限值一般为0022(普通用户为0002)，第一位0代表特殊权限，022为默认的权限与777权限异或后的权限值\n    777 rwx rwx rwx\n    022 --- -w- -w-\n  ===============\n    755 rwx r-x r-x(默认权限)\n因此需要修改默认权限时，需要先异或操作计算出权限值，如想把默认权限改为rwx --- ---，则先计算权限值\n    777 rwx rwx rwx\n    700 rwx --- ---\n  =================\n    077 --- rwx rwx\n然后执行\numask 077\n即可，同样，如果创建的是一个文件，Linux会在默认权限基础上取消所有用户的x权限\n</div>\n\n### 文件查找\n#### 文件查找\n文件查找会占用大量的系统资源，尽量避免在系统使用高峰期使用文件查找命令，文件查找范围应该尽可能小。\n##### 1. 根据文件名查找\n<span class=\"strong\">find [查找路径] [参数] [文件名]</span>\n\n+ -name&emsp;根据文件名查找\n+ -iname&emsp;根据文件名查找(文件名不区分大小写)\n+ 搜索范围应尽可能小，尽量避免在根目录下搜索\n+ 只使用文件名为精确搜索，可以使用通配符(*匹配任意数量字符，一个?匹配一个字符)来模糊查找\n<div class=\"show\">示例:\n# find /etc -name init\n在/etc目录下查找init文件\n# find /etc -name *init*\n在/etc目录下查找所有文件名带init的文件\n# find /etc -name init???\n在/etc目录下查找所有文件名init开头，后面跟3个字符的文件\n</div>\n\n##### 2. 根据文件大小查找\n<span class=\"strong\">find [查找路径] [参数] [文件大小]</span>\n\n+ -size &emsp;根据文件大小查找\n+ 文件大小中，可以使用+表示大于，-表示小于，直接写数值表示等于\n<div class=\"show\">示例:\n# find / -size +100M\n查找服务器中大于100MB的文件\n</div>\n\n##### 3. 根据文件所有者、所属组查找\n<span class=\"strong\">find [查找路径] [参数] [用户名或组名]</span>\n\n+ -user &emsp;根据根据文件所属用户查找\n+ -group&emsp;根据文件所属组查找\n<div class=\"show\">示例:\n# find /home -user shw\n查找/home目录下属于shw用户的文件\n</div>\n\n##### 4. 根据时间属性查找\n<span class=\"strong\">find [查找路径] [参数] [时间]</span>\n\n+ -amin &emsp;根据根据文件访问时间\n+ -cmin &emsp;根据文件属性被修改时间\n+ -mmin &emsp;根据文件内容被修改时间\n+ 时间参数中，使用+表示超过该时间范围，-表示小于该时间内，直接写数值表示等于\n<div class=\"show\">示例:\n# find /etc -amin -5\n查找/etc目录下5分钟内被访问过的所有文件\n</div>\n\n##### 5. 根据文件类型查找\n<span class=\"strong\">find -type [文件类型]</span>\n\n+ f &emsp;文件\n+ d &emsp;目录\n+ l &emsp;链接文件\n<div class=\"show\">示例:\n# find /etc -type f\n查找/etc目录下的所有普通文件\n</div>\n\n##### 6. 多个条件同时查找\n如果需要查找同时满足多个条件的文件，可以添加下面的参数\n+ -a &emsp;两个条件同时满足\n+ -o &emsp;两个条件任意满足一个\n<div class=\"show\">示例:\n# find /etc -size +100MB -a -size -200MB\n查找大于100MB而小于200MB的文件\n</div>\n\n##### 7. 对找到文件的执行其他命令\n如果在找到文件后需要对其进行相应操作，可以添加下述命令\n+ -exec 命令 {}\\; &emsp;找到文件后直接执行命令\n+ -ok 命令 {}\\; &emsp;找到文件后会每个文件逐一询问是否执行命令\n<div class=\"show\">示例:\n# find /etc -name init* -a -type f -exec ls -l {} \\;\n找到/etc目录下所有init开头的文件并列出具体文件信息\n# find /home -size +100MB -a -user shw -ok rm {} \\;\n找到/home目录下属于shw用户且大于100MB的文件，然后依次询问是否删除找到的文件\n</div>\n\n##### 根据i节点查找\n<span class=\"strong\">find [查找路径] -inum i节点值</span>\n在知道某文件i节点值的情况下根据i节点查找，如：用于查找某个文件的硬链接(文件i节点值与文件硬链接i节点值相同)\n\n#### locate \nlocate为一个文件查找工具，可以从yum源安装\nfind命令为在指定目录下遍历查找，会占用大量系统资源，而且查找速度较慢，locate会建立文件资料库，然后在资料库中查找，反应速度快。\n<span class=\"strong\">locate [-i] 文件名</span>\n\n+ -i&emsp;不区分大小写\n+ locate会定期更新资料库，但实时新建的文件可能会找不到，可以在root下使用 updatedb 命令手动更新资料库\n+ locate 不会将/tmp等临时缓存文件收录到资料库中，因此临时文件使用locate找不到\n\n### 查找命令所在路径\n+ <span class=\"strong\">which 命令</span>&emsp;查找命令所在路径，同时可以查看命令的别名\n+ <span class=\"strong\">whereis 命令</span>&emsp;查找命令所在路径，同时可以查看命令帮助文档所在路径\n<div class=\"show\">示例:\n# which rm\nLinux返回:\nalias rm='rm -i' \n\t/usr/bin/rm\n查看rm命令所在路径，rm -i为rm命令全写\n#whereis rm\nLinux返回:\nrm: /usr/bin/rm /usr/share/man/man1/rm.1.gz\n返回信息为rm命令所在路径和rm命令帮助文档所在路径\n</div>\n\n### 查找文件中的某个内容\n<span class=\"strong\">grep [参数] [搜索的字符串] [文件]</span>\n\n+ -i &emsp;不区分大小写\n+ -v &emsp;排除指定字符串\n找到或排除字符串所在行，然后输出内容\n<div class=\"show\">示例:\n# grep man /etc/file\n找到/etc/file文件中含有man的行并输出\n# grep -v ^# /etc/inittab\n显示/etc/inittab中除了#开头的所有行内容(#开头的内容为被注释了的内容，不想看注释)\n</div>\n\n### 查看帮助 (manual)\n#### 1. 查看完整帮助man\n<span class=\"strong\">man [命令或配置文件]</span>\n\n+ 查看配置文件的帮助时，直接写文件名，不能加上文件路径，使用文件路径会直接显示文件内容而不是该配置文件的使用说明\n+ 对于命令，man 有帮助级别(通常为0-9)，可以使用 <span class=\"tips\">whereis 命令</span>查看该命令在man目录下有几个级别，如果有级别，可以使用<span class=\"tips\">man [级别] [命令]</span>来查看对应帮助。如：1为通常为命令的帮助，5通常为命令对应说明文档的帮助。即：使用<span class=\"tips\">man 命令</span>和<span class=\"tips\">man 1 命令</span>为查看命令的帮助，<span class=\"tips\">man 5 命令</span>为查看目录说明文档的帮助(具体级别视命令而定)\n\n#### 2. 查看简短帮助 \n+ <span class=\"strong\">what 命令</span>&emsp;只显示命令帮助文档中NAME部分的内容\n+ <span class=\"strong\">apropos 配置文件</span>&emsp;简短查看配置文件作用\n\n#### 3. 查看命令的可选参数选项\n只查看命令的可选参数选项，不需要查看命令完整帮助信息\n<p><span class=\"strong\">命令 --help</span></p>\n\n#### 4. 查看shell内置命令\n有些命令是bash(shell)内置命令而不是Linux的命令，使用上述命令查看不到帮助，可以使用\n<p><span class=\"strong\">help 命令</span></p>\n\n### 压缩与解压缩\n#### 文件的压缩与解压(.gz格式)\n压缩格式为<span class=\"tips\">.gz</span>，与windows不同，下述命令只能压缩与解压缩文件，不能处理文件夹，并且压缩完只保留压缩文件，不保留原文件\n+ <span class=\"strong\">gzip 文件名</span>&emsp;压缩(GUN zip)\n+ <span class=\"strong\">gunzip 文件名</span>&emsp;解压缩(GUN unzip)\n\n#### 文件夹的打包、压缩与解压(.tar.gz格式)\n##### 打包与压缩\n<span class=\"strong\">tar [参数] [压缩后文件名] [压缩目录]</span>\n<p>打包是将多个文件打包为一个文件，文件总大小不变，打包后的文件格式为<span class=\"tips\">.tar</span>，对包可以用<span class=\"strong\">gzip</span>命令压缩，生成<span class=\"tips\">.tar.gz</span>格式的压缩包文件，而<span class=\"strong\">tar</span>命令可以将打包压缩同时处理，打包压缩后的文件名可以不写.tar.gz等后缀，但不方便用户识别。</p>\n\n+ -c &emsp;打包\n+ -v &emsp;显示详细信息\n+ -f &emsp;指定文件名(该参数必须)\n+ -z &emsp;打包后压缩(需要和c参数一起使用)\n<div class=\"show\">示例:\n# tar -cvf test1.tar test1\n打包test1文件夹中文件为test1.tar文件，并显示详细信息\n# tar -zcf test.tar.gz test1\n打包并压缩test1文件夹为test.tar.gz\n</div>\n\n##### 解压\n<span class=\"strong\">tar [参数] [解压缩的文件]</span>\n\n+ -x &emsp;解包\n+ -v &emsp;显示详细信息\n+ -f &emsp;指定解压缩的文件(该参数必须)\n+ -z &emsp;解包后解压缩(需要和x参数一起使用)\n<p>最常用的是解压一个.tar.gz文件，因此大多数情况下-zxf为必用参数</p>\n<div class=\"show\">示例:\n# tar -zxvf test.tar.gz \n解压缩test.tar.gz文件，并显示详细信息\n</div>\n\n#### .zip格式的压缩与解压\n<span class=\"strong\">zip [选项] [-r] [压缩后文件名] [压缩文件或目录]</span>\n\n- -r&emsp;压缩目录\n<p>.zip格式为Linux和windows通用格式，zip命令会保留原文件，并且一个命令就可以处理文件与文件夹</p>\n\n<span class=\"strong\">unzip [解压的文件名]</span>\n<p>解压文件</p>\n\n#### .bz2、.tar.bz2格式的压缩与解压\n##### 1. 压缩\n###### 对文件(格式为.bz2)\n<span class=\"strong\">bzip2 [参数] [-k][文件]</span>\n\n+ -k &emsp;压缩后保留原文件\n\n###### 对文件夹(格式为.tar.bz2)\n<p><span class=\"strong\">tar -jcf [压缩后文件名] [压缩目录]</span></p>\n<p>即将tar中的z参数改为j参数就是压缩为.tar.bz2格式</p>\n\n##### 2. 解压\n###### 对文件(格式为.bz2)\n<span class=\"strong\">bunzip2 [-k] [解压文件]</span>\n\n+ -k &emsp;解压缩后保留原文件\n\n###### 对文件夹(格式为.tar.bz2)\n<p><span class=\"strong\">tar -jxf [解压文件]</span></p>\n<p>同样将tar中的z参数改为j参数就是解压.tar.bz2格式</p>\n\n### ACL权限\nACL权限用于给文件所有者(u)、所属组(g)、其他用户(o)以外的用户提供权限\n\n#### 查看ACL权限\n<span class=\"strong\">getfacl 文件名</span>\n<div class=\"show\">设置了ACL权限的文件，使用 ls -l 命令查看文件时权限标识后带有+号，如：\n-rw-r-xr--+ 1 root root  174 Jan 23 18:55 index.html\n使用 getfacl 命令查看具体ACL权限，会多一组拥有ACL权限的 user或group 并标明用户名或组名，如：\n# file: index.html\n# owner: root\n# group: root\nuser::rw-\nuser:sw:r-x     //sw用户拥有ACL权限r-x\ngroup::r--\nmask::r-x\nother::r--\n</div>\n\n#### 设置mask权限\nmask权限用于指定最大的权限，防止给与用户ACL权限时权限过大。用户最终得到的权限是ACL权限于mask权限相与以后得到的权限。\n<span class=\"strong\">setfacl -m m:组名:权限 文件名</span>\n\n#### 设置ACL权限\n<span class=\"strong\">setfacl 参数 文件名</span>\n\n+ -m &emsp;设定ACL权限\n+ -x &emsp;删除指定ACL权限\n+ -b &emsp;删除文件所有ACL权限\n+ -d &emsp;设定默认ACL权限\n+ -k &emsp;删除默认ACL权限\n+ -R &emsp;递归设置ACL权限\n\n##### 1. 设置ACL权限\n+ <span class=\"strong\">setfacl -m u:用户名:权限 文件名</span>给用户设置ACL权限\n+ <span class=\"strong\">setfacl -m u:用户名:权限 -R 文件名</span>递归设置，给用户设置目录下所有子文件的ACL权限\n+ <span class=\"strong\">setfacl -m g:组名:权限 文件名</span>给组设置ACL权限\n+ <span class=\"strong\">setfacl -m g:组名:权限 -R 文件名</span>递归设置，给组设置目录下所有子文件的ACL权限\n<div class=\"show\">示例：\nsetfacl -m u:lm:r-x index.html\n给与用户lm对index.html的读和执行权限\n</div>\n\n##### 2. 删除ACL权限\n<span class=\"strong\">setfacl -x [u或g]:[用户名或组名] 文件名</span>\n\n删除对应用户或组的ACL权限\n\n<span class=\"strong\">setfacl -b 文件名</span>\n\n删除对应文件所有ACL权限\n\n##### 3. 设置默认ACL权限\n设置默认ACL权限的作用是给父目录设置ACL权限后，父目录中创建的所有子文件都会继承父目录的ACL权限，但执行命令前的文件不会拥有权限。与递归设置的区别是，递归设置的ACL权限只会给当前已经存在的子目录给与ACL权限，新建的后来文件不会拥有权限。\n+ <span class=\"strong\">setfacl -m d:u:用户名:权限 文件名</span>设置默认ACL权限\n+ <span class=\"strong\">setfacl -m k:u:用户名:权限 文件名</span> 删除默认ACL权限设置\n\n\n可以添加-R参数递归给子目录的子文件也设置默认ACL权限，但执行命令前创建的文件依旧不会有ACL权限。\n\n<span class=\"strong\">setfacl -m d:u:用户名:权限 -R 文件名</span>\n\n### 特殊权限\n\n#### 1. SetUID权限\n用于执行某个程序时赋予该用户文件所有者身份，程序运行完毕收回所有者身份。如：普通用户对 /etc/shadow 文件的权限为 0 ，即无法查看无法修改，但通过执行passwd命令，普通用户会获得临时的所有者即root权限，可以修改密码，\n\n\n+ <span class=\"tips\">只有可执行的二进制程序才能设置SUID权限</span>\n+ <span class=\"tips\">要求命令执行者要对该程序拥有x(执行)权限</span>\n+ 命令执行者在运行该程序时会临时获得文件所有者身份\n+ SUID权限只在该程序执行时有效，程序执行完毕权限失效\n\n##### 设置SUID权限\n4代表SUID\n\n+ <span class=\"strong\">chmod 4755 文件名</span>&emsp;755为权限值可任意，但要保证用户有x权限\n+ <span class=\"strong\">chmod u+s 文件名</span>\n\n##### 取消SUID权限\n<span class=\"strong\">chmod 755 文件名</span>\n\n<span class=\"strong\">chmod u-s 文件名</span>\n\n<div class=\"show\">说明：\n当设置SUID权限后，该文件权限标识中所有者的可执行权限x会被修改为s\n-rwsr--r--  1 root root 174 Jan 23 18:56 file\n如果该标识为大写S，则说明文件设置了SUID权限，但用户没有x权限，SUID权限无法生效，权限报错\n</div>\n\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n该命令容易造成权限滥用，Linux中默认只有/usr/bin/passwd 等少数文件有SUID权限，禁止为 vi 等命令设置该权限，否则所有用户在使用 vi 命令时都将获得 root 权限。应定时检查系统中是否有除默认以外的文件设置了SUID权限</div>\n\n#### 2. SetGID权限\n对文件\n+ 只有可执行的二进制程序才能设置SGID权限\n+ 要求命令执行者要对该程序拥有x(执行)权限\n+ 命令执行者在运行该程序时，组身份会临时升为文件所属组身份\n+ SGID权限只在该程序执行时有效，程序执行完毕权限失效\n\n<div class=\"show\">说明：\n当设置SGID权限后，该文件权限标识中所属组的可执行权限x会被修改为s，如 locate 命令的权限为\n-rwx--s--x  1 root root 174 Jan 23 18:56 usr/bin/locate\n</div>\n\n对目录\n\n+ 要求用户必须拥有此目录的 r 和 x 权限\n+ 普通用户进入该目录时，用户的组会升为此目录的所属组\n+ 如果用户对目录有w权限，新建文件的默认组 将变为目录的所属组，而非创建者的所属组\n\n##### 设置SGID权限\n2代表SGID\n\n+ <span class=\"strong\">chmod 2755 文件名</span>&emsp;755为权限值可任意，若为文件要保证拥有x权限，为目录则拥有r和x权限\n+ <span class=\"strong\">chmod g+s 文件名</span>\n\n##### 取消SGID权限\n<span class=\"strong\">chmod 755 文件名</span>\n\n<span class=\"strong\">chmod g-s 文件名</span>\n\n#### 3. Sticky BIT(粘着位权限)\n\n+ 只对目录有效\n+ <span class=\"tips\">要求用户对目录拥有w和x权限</span>\n+ 没有设置粘着位权限时，用户拥有w权限后可以删除目录下的所有文件，包括其他用户创建的文件。设置粘着位后，用户只能删除自己创建的文件，root用户不受此规则影响\n\n<div class=\"show\">说明：\n当设置SBIT权限后，文件权限标识中其他用户的可执行权限x会被修改为t，如\ndrwxrwxrwt  1 root root 174 Jan 23 18:56 /dir/\n</div>\n\n##### 设置SBIT权限\n1代表SBID\n\n+ <span class=\"strong\">chmod 1755 目录名</span>&emsp;755为权限值可任意，要保证用户拥有w和x权限\n+ <span class=\"strong\">chmod o+t 目录名</span>\n\n##### 取消SBIT权限\n<span class=\"strong\">chmod 755 目录名</span>\n\n<span class=\"strong\">chmod o-t 目录名</span>\n\n### 文件系统属性权限chattr权限\n\n<span class=\"strong\">chattr&emsp;[+-=][i或a]&emsp;文件或目录名</span>\n\n+ +为增加权限，-为删除权限，=为设置为指定权限\n+ i &emsp;对文件：不允许删除、改名、添加内容或修改文件内容操作\n&emsp;对目录：只能修改目录下文件的内容，不允许新建和删除文件\n<span class=\"tips\">对root用户生效！</span>\n\n+ a &emsp;对文件：只能添加新内容，不能删除、修改已有内容(并且只允许使用echo添加，不能使用vi等编辑器添加)\n&emsp;对目录：只能新建和修改文件，不能删除文件\n<span class=\"tips\">对root用户生效！</span>\n\n<div class=\"show\">示例：\nchattr +i test\n给文件test添加i属性，锁定文件，防止误操作</div>\n\n##### 查看chattr权限方法\n该权限无法使用 ls 命令查看，而需要使用：\n\n<span class=\"strong\">lsattr [参数] 文件名</span>\n\n+ -a 显示所有文件和目录\n+ -d 若为目录，则显示目录属性，而非子文件属性\n\n### sudo权限\n由root用户赋予普通用户权限，使普通用户可以使用原本只有root用户才能执行的系统命令。能赋予的只能是系统命令！\n\n##### 1. 添加赋予的命令\n执行 <span class=\"strong\">visudo</span> 命令，执行该命令实际是修改<span class=\"tips\"> /etc/sudoers </span>文件，在文件中添加格式为<span class=\"tips\">用户名 被管理主机地址=(赋予的身份) 授权命令的绝对路径</span> 的内容，赋予组相关权限的格式类似\n<div class=\"show\">举例：\n  root    ALL=(ALL)       ALL   //文件自带，给root授予的权限\n  wj      ALL=/sbin/shutdown -r now\n//用户名  被授权的主机=被授予可以使用的命令，被授权主机指被授予的命令可以在哪些主机上使用\n  %wheel  ALL=(ALL)       ALL   //文件自带\n  //若要为组添加，组名前使用%号</div>\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n授予命令越简单，权限越大，因此命令应该尽量详细</div>\n\n##### 2. 查看当前用户可以使用sudo权限执行的命令\n<span class=\"strong\">sudo -l</span>\n\n执行命令后Linux系统会要求输入当前账户密码\n\n##### 3. 使用sudo权限执行命令\n<span class=\"strong\">sudo 被授予的命令</span>\n<div class=\"show\">wj用户被授予使用shutdown -r now命令后，可以使用\nsudo shutdown -r now 重启系统了\n</div>\n\n### 文件系统常用命令\n#### 文件系统空间\n\n##### 1.显示磁盘分区大小\n<span class=\"strong\">df [参数] [挂载点]</span>\n\n+ -a &emsp;显示所有文件系统信息，包括特殊文件系统\n+ -h &emsp;将磁盘大小单位换算为KB、MB等单位\n+ -T &emsp;显示文件系统类型\n+ -m &emsp;以MB为单位显示容量\n+ -k &emsp;以KB为单位显示容量，默认值\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\ndf命令会统计包括一些磁盘碎片在内的空间，而该类空间是被程序占用后释放的碎片空间，需要Linux整理后才能使用，因此df命令统计结果也往往比du命令统计结果大，但更能正确反映系统可用的空间大小</div>\n\n##### 2. 显示目录或文件大小\n<span class=\"strong\">du [参数] [目录或文件名]</span>\n\n+ -a &emsp;显示每个子目文件的大小\n+ -h &emsp;将文件大小单位换算为KB、MB等单位\n+ -s &emsp;只统计总大小，不列出子目录和文件\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\nls命令只统计目录下一级子文件和子目录文件信息大小，而不统计子目录下属文件大小，du命令更能准确统计出子文件、子目录和子目录所含文件的数据大小</div>\n\n#### 文件系统修复\n<span class=\"strong\">fsck [参数] 分区设备名</span>\n\n+ -a &emsp;不显示用户提示，自动修复文件系统\n+ -y &emsp;功能同-a，部分文件系统仅支持-y\n\n#### 文件系统挂载\n<span class=\"strong\">mount [-l]</span>查询已经挂载的设备，-l显示卷标\n\n<span class=\"strong\">mount -a</span>根据配置文件 /etc/fstab 自动挂载\n\n##### 手动挂载\n<span class=\"strong\">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span>\n\n+ -t 文件系统：挂载指定文件系统，如 ext4、iso9660\n+ -L 卷标名：自定义卷标的名字\n+ -o 特殊选项：指定挂载的额外选项，几个常用的选项：\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>atime/noatime</td>\n<td>访问分区文件时是否更新文件访问时间</td>\n</tr>\n<tr>\n<td>exec/noexec</td>\n<td>是否允许文件系统中的可执行程序可以运行，默认为exec允许</td>\n</tr>\n<tr>\n<td>user/nouser</td>\n<td>是否允许普通用户挂载文件系统，默认为不允许</td>\n</tr>\n<tr>\n<td>remount</td>\n<td>重挂载已经挂载的文件系统，一般用于修改特殊权限后重挂载</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n<div class=\"show\">示例：\n# mount -o remount,noexec /home/\n禁止 /home/分区中的所有可执行程序执行，包括root用户\n</div>\n\n##### 硬件设备文件名\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>硬件</th>\n<th>设备文件名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IDE硬盘</td>\n<td>/dev/hd[a-d]</td>\n</tr>\n<tr>\n<td>SCSI/SATA/USB硬盘</td>\n<td>/dev/sd[a-p]</td>\n</tr>\n<tr>\n<td>光驱</td>\n<td>/dev/cdrom 或 /dev/sr0</td>\n</tr>\n<tr>\n<td>软盘</td>\n<td>/dev/fd[0-1]</td>\n</tr>\n<tr>\n<td>打印机(25针)</td>\n<td>/dev/lp[0-2]</td>\n</tr>\n<tr>\n<td>打印机(USB)</td>\n<td>/dev/usb/lp[0-15]</td>\n</tr>\n<tr>\n<td>鼠标</td>\n<td>/dev/mouse</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n##### 挂载光盘\n为方便文件查找，一般将光盘挂载于根目录下的 /media  ，U盘挂载于/mnt目录下，iso9660为光盘默认文件系统，因此-t iso9660 可以省略\n\n<span class=\"strong\">mount -t iso9660 /dev/cdrom /media</span>\n\n\n##### 挂载U盘\n1. <span class=\"strong\">fdisk -l</span>查看U盘设备文件名\n\n2. <span class=\"strong\">mount -t &emsp;文件系统 &emsp;/dev/U盘设备文件名 &emsp;/mnt</span>\n\nlinux默认不支持NTFS文件系统(大部分移动硬盘设备使用NTFS文件系统)，但可以通过插件提供支持\n\n\n##### 卸载设备\n<span class=\"strong\">umount 设备文件名或挂载点目录名</span>\n\n","tags":["File","Linux"]},{"title":"Linux服务与系统资源管理","url":"/blog/2022/01/20/Linux服务与系统资源管理/","content":"\n### 网络命令\n#### ping 测试网络\n<span class=\"strong\">ping [-c 次数] IP地址</span>\n\n+ -c &emsp;指定发送次数\n\n测试网络是否联通，如果不添加-c参数，则会无终止进行ping操作，直至 ctrl+c 停止\n\n#### ifconfig 网卡设置\n<span class=\"strong\">ifconfig [网卡名称] [IP地址]</span>\n<p>查看和设置网卡</p>\n  <div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>直接使用 ifconfig 为查看网卡，不同发行版的Linux网卡标识不同，Centos7中网卡名以eth+数字标识，其中lo为回环网卡，用于本地通信与测试\n</div>\n\n#### traceroute 查看与目标主机间的网路节点\n<span class=\"strong\">traceroute 网址或IP地址</span>\n<p>显示当前主机与目标主机之间的所有网络节点的IP地址、延迟等信息，节点为***表示该节点信息被加密</p>\n\n#### 查看网络状态\n<span class=\"strong\">netstat [参数]</span>\n查看当前主机的网络连接状态，包括端口号、IP地址等\n+ -t &emsp;TCP协议\n+ -u &emsp;UDP协议\n+ -l &emsp;监听\n+ -r &emsp;路由\n+ -n &emsp;显示IP地址和端口号\n+ -a &emsp;所有\n+ -p &emsp;列出相关程序名\n\n常用\n+ <span class=\"strong\">netstat -tulnp &emsp;查看本机监听的TCP和UDP端口并列出相关程序</span>\n+ <span class=\"strong\">netstat -an &emsp;查看本机的所有网络连接</span>\n+ <span class=\"strong\">netstat -rn &emsp;查看本机所有路由表</span>\n\n#### setup 配置网络(redhat系列操作系统专有)\n<span class=\"strong\">setup</span>\n调出GUI界面设置IP地址、子网掩码等信息，setup是redhat开发的用于配置网络IP地址、子网掩码等网络信息的GUI工具，只有部分redhat发行的操作系统中有该工具。\n\n#### mount 挂载设备\n##### 1.挂载设备\n<span class=\"strong\">mount [-t 文件系统] 设备文件名 挂载路径</span>\n<p>挂载u盘、光盘等设备到Linux中，设备文件名与挂载路径一般有约定俗成的设置</p>\n\n##### 2.卸载设备\n<span class=\"strong\">umount 设备文件名或挂载路径</span>\n<p>卸载已经挂载的设备，类似于Windows的U盘弹出，参数使用设备文件名或挂载路径其一，不能同时使用两个参数，卸载时需要回到挂载路径的母目录中。</p>\n\n#### 发送消息\n##### 1. write 给某个在线用户发送信息\n<span class=\"strong\">write 用户名 信息</span>\n<p>给已经登录Linux的用户发送消息，<span class=\"tips\">Ctrl+D</span>结束输入并发送，需要用户在线，可以使用<span class=\"tips\">w</span>查询在线的账户。\n</p>\n\n##### 2. wall 给所有在线用户发送信息(write all)\n<p><span class=\"strong\">wall 信息</span></p>\n给所有在线用户发送广播信息\n\n\n#### mail 发送邮件\n<span class=\"strong\">mail 用户名</span>\n<p>当用户未登录无法使用上述命令发送消息时，可以发送邮件给Linux用户。</p>\n<div class=\"show\">邮件发送:\n# mail 用户名 \nSubject : 邮件标题  //输入邮件\n邮件内容           //输入邮件内容，输入完毕<span class=\"tips\">Ctrl+D</span>发送\n\n邮件接收：\n~ mail          //查看邮件箱\n收到的邮件将以New标识(是否已读)、序号、发送用户、发送时间、邮件标题的格式列出\n-> N 1 root                  Sun Feb 20 12:38  18/532   \"test\"\n~ 1             //直接输入序号查看对应邮件\n~ h             //列出所有邮件\n~ d1            //d+序号删除对应邮件\n~ q             //退出邮件查看系统</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nLinux会通过mail给root用户发送一些邮件反映服务器错误信息等</div>\n\n\n#### last 查看用户登录系统时间与系统重启时间\n<span class=\"strong\">last </span>\n列出目前与过去所有登入过系统的用户信息，并列出了系统何时重启过\n<p><span class=\"strong\">lastlog </span></p>\n列出用户上次登录系统的时间(包括系统用户)\n<p><span class=\"strong\">lastlog -u UID</span></p>\n仅列出指定用户上次登录系统的时间\n\n## 软件安装\nLinux中的软件安装包一般分为两种：源码包和二进制包\n<p>源码包：一般是使用C语言编写但未经过编译的包，安装时需要编译，所以时间长且安装步骤多，容易报错，但方便程序员阅读和修改源码</p>\n<p>二进制包：源码包经过编译后形成二进制包，安装简单，安装速度快，但依赖性强，需要安装其他环境。二进制包通常有两大主流的管理系统：\n\n+ RPM 包管理系统：即Red-Hat Package Manager(红帽软件包管理器)，大多数 Linux 发行版默认的包管理方式，如 Fedora、CentOS、SuSE 操作系统。\n+ DPKG 包管理系统：为 “Debian” 专门开发的套件管理系统，主要应用在 Debian 和 Ubuntu 上</p>\n\nRPM包安装的默认路径为：\n<div class=\"table\">\n<table>\n<thead>\n<tr>\n<th>路径</th>\n<th>文件</th>\n<tr>\n</thead>\n<tbody>\n<tr><td>/etc/</td><td>配置文件</td></tr>\n<tr><td>/usr/bin/</td><td>可执行命令安装目录</td></tr>\n<tr><td>/usr/lib/</td><td>程序使用的函数库保存位置</td></tr>\n<tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr>\n<tr><td>/usr/share/man</td><td>帮助文件保存位置</td></tr>\n</tbody>\n</table>\n</div>\n因此通过RPM包安装的软件，服务启动时会自动去默认路径下寻找可执行命令，红帽系列的操作系统可通过系统服务管理命令<span class=\"tips\">service、systemctl</span>命令管理\n\n\n\n\n<p>源码包安装路径自定义，一般安装在<span class=\"tips\"> /usr/local/软件名/</span>路径下</p>\n\n\n#### 源码包安装\n由于未经过编译，源码包安装一般需要先安装gcc编译器。源码包的安装一般要经过\n1. 通过tar命令解压\n2. 进入解压缩的目录下\n3. 阅读INSTALL文件，INSTALL一般为安装说明\n4. 执行<span class=\"strong\"> ./configure</span>设置安装在默认路径下，也可以使用<span class=\"strong\"> ./configure --prefix=/usr/local/路径</span>自定义安装路径，执行完会根据配置项生成 Makefile 文件\n5. 执行<span class=\"strong\">make</span> 命令进行编译。如果报错，除错后执行<span class=\"strong\">make clean</span>删除编译产生的临时文件即可。\n6. 执行<span class=\"strong\">make install</span> 命令进行安装\n7. 源码包的卸载只需删除安装目录即可，不会遗留任何垃圾文件。\n\n#### RPM包安装\nRPM包安装需要提前安装好软件的依赖环境\n##### RPM包\nRPM包全名类似于 httpd-2.2.3-29.el5.i386.rpm ，其命名规则为\n1. 包名\n2. 版本号，格式通常为“主版本号.次版本号.修正号”\n3. 发布次数，表示RPM包是第几次编译后发布的\n4. 适合的Liunx平台，如el5表示支持RHEL 5.x/CentOS 5.x下安装\n5. 适合的硬件平台，目前RPM支持的平台有：i386、i586、i686、sparc和alpha，noarch为支持所有硬件平台。\n6. 后缀名，.rpm是编译好的二进制包，可用rpm命令直接安装；.src.rpm表示是源码包，需要编译以后才能安装\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n在安装软件时，有些命令后使用的是包的全名，有些命令使用的是包名，二者混用会导致软件无法安装</div>\nrpm模块依赖查询网站：<span class=\"tips\"> www.rpmfind.net </span>\n\n##### 安装升级与卸载\n1. <span class=\"strong\">rpm -[i或U]vh 包全名</span>&emsp;安装或升级软件\n\n+ -i &emsp;安装(install)\n+ -U &emsp;升级(upgrade)\n+ -v &emsp;显示详细信息(verbose)\n+ -h &emsp;显示进度(hash)\n+ -&nbsp;-nodeps &emsp;不检测依赖性(通常仅用于实验测试)\n\n2. <span class=\"strong\">rpm -e 包名</span>&emsp;卸载软件\n\n+ -&nbsp;-nodeps &emsp;不检测依赖性\n    \n\n##### 查询包信息\n###### 1. 查询是否安装了某个包\n<span class=\"strong\">rpm -q 包名</span>\n\n+ -q &emsp;查询(query)\n\n###### 2. 列出所有已经安装的rpm包\n<span class=\"strong\">rpm -qa&emsp;</span>\n\n+ -a &emsp;所有(all)\n\n###### 3. 查询rpm包详细信息\n<span class=\"strong\">rpm -qi 包名</span>\n\n+ -i &emsp;查询信息(information)\n+ -p &emsp;添加-p查询未安装包的信息(package)，对于未安装的包，包名应为完整包名\n\n###### 4. 查询包文件安装位置\n<span class=\"strong\">rpm -ql 包名</span>\n\n+ -l &emsp;列表(list)\n+ -p &emsp;未安装包的信息(package)，包名应为完整包名\n\n###### 5. 查询某个系统文件属于哪个rpm包\n<span class=\"strong\">rpm -qf 文件名</span>\n\n+ -f &emsp;系统文件(file)\n\n###### 6. 查询rpm包的依赖环境\n<span class=\"strong\">rpm -qR 包名</span>\n\n+ -R &emsp;查询包的依赖(requires)\n+ -p &emsp;未安装包的依赖(package)，包名应为完整包名\n\n##### 包校验\n<span class=\"strong\">rpm -V 已经安装的包名</span>\n<p>校验包中的文件是否正确，会返回包的验证信息</p>\n\n##### 包文件提取\n\n<span class=\"strong\">rpm2cpio 包全名 | cpio -idv 文件绝对路径</span>\n<p>cpio：标准工具，用于创建档案文件和从档案文件中提取文件</p>\n<p>rpm2cpio命令用于将rpm包转换为cpio格式</p>\n<div class=\"show\">示例：\nrpm2cpio coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls\n该命令可用于 /bin 目录下的 ls 目录被误删除，因而无法使用 ls 命令时，从 coreutils-8.4-19.el6.i686.rpm 包中提取 ls 目录到 bin 目录下，修复 ls 命令</div>\n\n### yum操作\nyum是一个由RedHat社区开发，基于RPM包管理的Shell前端软件包管理器，被广泛用于Fedora、RedHat以及CentOS中。yum能自动从指定的服务器下载RPM包并且安装，并自动处理依赖性关系\n#### 配置网络yum源\n网络yum源的配置文件路径为<span class=\"tips\"> /etc/yum.repos.d/CentOS-Base.repo </span>，配置信息类似于：\n<div class=\"shell\">[base]\nname=CentOS-$releasever - Base - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/\n        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\ngpgcheck=1\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7\n#additional packages that extend functionality of existing packages\n[centosplus]\nname=CentOS-$releasever - Plus - mirrors.aliyun.com\nfailovermethod=priority\nbaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/\n        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/\n        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7</div>\n\n配置信息中各项配置解析：\n+ [base] &emsp;容器名称，放在[]中\n+ name &emsp;容器说明，自由写\n+ mirrorlist &emsp;镜像站点\n+ baseurl &emsp;yum源服务器地址，默认为CentOS官方地址，国内可使用阿里云镜像地址\n+ enabled &emsp;该容器是否失效，enable=0为不生效，enable=1为生效但会略写。\n+ gpgcheck &emsp;为1则RPM的数字证书失效，0为不生效\n+ gpgkey &emsp;数字证书公钥文件保存位置\n\n#### yum安装软件\nyum命令中的包名不需要包的全名\n##### 查询包\n<span class=\"strong\">yum list &emsp;列出所有可用的软件包</span>\n\n<span class=\"strong\">yum search 关键字&emsp;搜索服务器上所有和关键字相关的包</span>\n\n##### 安装与升级\n<span class=\"strong\">yum -y install 包名</span>\n\n\n+ -y &emsp;对询问自动回答yes\n\n\n##### 升级、卸载\n+ yum -y update 包名\n+ yum -y remove 包名\n\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n升级时必须写包名，否则会升级所有包，包括Linux内核，会直接导致服务器崩溃。而卸载时会卸载包和包的所有依赖，但依赖可能还是其他包的依赖，因此可能导致其他软件功能失效，因此这两条命令慎用</div>\n\n#### yum安装软件包组\n+ <span class=\"strong\">yum grouplist &emsp;列出所有可用软件组</span>\n+ <span class=\"strong\">yum groupinstall 软件组名&emsp;安装软件组</span>\n+ <span class=\"strong\">yum groupremove 软件组名&emsp;卸载软件组</span>\n\n### 服务管理\n通过源码包安装的程序，所有文件会统一放置于如 /usr/local/ 目录下，而通过RPM包安装的程序，不同文件会放在不同目录下，如：可执行命令文件放在 /usr/bin 目录下，配置文件放在 /etc目录下。通过RPM包安装的软件服务，可以通过脚本文件启动，也可以通过service或systemctl命令直接启动，当执行该命令时，Linux会默认前往/usr/bin 目录下寻找相关文件。而通过源码包安装的服务由于安装路径不同，就无法通过该命令直接启动，但也可以将启动命令文件生成链接放置在/usr/bin目录下，这样源码包安装的服务也可以通过该命令启动了。\n\n卸载软件时，通过源码包安装的程序直接删除对应文件即可，而通过RPM包安装的软件，由于文件散列分布，因此需要rpm -e 命令来卸载。\n\n#### 服务查询\n查询服务开机自启动状态\n##### 1. RPM包安装的应用服务\n<span class=\"strong\">chkconfig -&zwnj;-list</span>\n\n查询所有RPM包安装的应用服务启动状态，会标出int0-6哪个级别系统启动状态下，服务会自启动。通过管道符可以查询指定服务的启动状态，如: chkconfig | grep nginx查看nginx服务的启动状态，在Centos7以后，该命令只能查看应用服务自启动情况，不包括系统本地服务，查看本地服务可以使用<span class=\"strong\">systemctl list-unit-files</span>命令，使用管道符可以只查看指定服务的启动状况。\n\n\n\n##### 2. 源码包安装的服务\n查看安装位置下对应服务的配置文件，一般位于<span class=\"tips\"> /usr/local/</span>路径下。\n\n#### RPM服务管理\n##### 独立服务管理\n常用文件路径\n<div class=\"table\">\n\n|    路径    |  说明     |\n|:---------:|:---------:|\n|/etc/init.d|启动脚本位置|\n|/etc/xinetd.d|基于xinetd 服务的启动脚本|\n|/etc/sysconfig|初始化环境配置文件|\n|/etc           |配置文件位置   |\n|/etc/xinetd.conf|xinetd 配置文件|\n|/var/lib       |放置服务产生的数据|\n|/var/log       |日志           |\n\n</div>\n\n##### 独立服务命令\n+ <span class=\"strong\">/etc/init.d/服务名&emsp;start/stop/status/restart </span>\n\n+ <span class=\"strong\">service/systemctl&emsp;服务名&emsp;start/stop/status/restart </span>&emsp;红帽系列系统专属\n\n##### 独立服务自启动\n+ 将启动程序的命令写入<span class=\"tips\"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令\n+ chkconfig 服务名 on/off &emsp;开启、关闭自启动，默认在2345运行级别下自启动\n\n\n##### 基于xinetd(超级守护进程)服务\nxinetd负责管理系统中不频繁使用的服务，这些服务程序在有请求时才由xinetd服务负责启动运行，一旦完成服务请求服务程序结束运行，以减少对系统资源的占用。\n\n基于 xinetd 的服务没有自己独立的启动脚本程序，需要依赖 xinetd 的启动脚本来启动。xinetd 本身是独立的服务，启动xinetd 服务的方法和启动独立服务的方法一致。\n\n基于 xinetd 的服务只需修改 <span class=\"tips\"> /etc/xinetd.d/服务名 </span> 文件下的 <span class=\"tips\"> /disable</span>为 <span class=\"tips\"> no</span>，然后重启xinetd 服务即可\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nxinetd常用于红帽系列的操作系统，需要用户自行安装</div>\n\n#### 源码包安装的服务管理\n##### 服务启动\n源码包安装的服务一般通过绝对路径下的脚本启动，具体路径需查看安装说明INSTALL文件。\n\n##### 自启动\n将启动程序的命令写入<span class=\"tips\"> /etc/rc.d/rc.local</span>文件中，系统启动后会自动执行该文件中的所有命令\n\n#### 查看开机时服务启动顺序\nLinux开机或关机时的服务启动/关闭顺序写于文件<span class=\"tips\"> /etc/rc.d/</span>路径下的对应文件中， <span class=\"tips\"> rc0-rc6 </span>文件中分别书写有系统不同启动级别下服务启动顺序。如 rc3 中，S85nginx表示系统启动时，nginx将是第85个启动的服务，K15nginx表示系统关机时，nginx将是第15个关闭的服务。\n\n### 进程管理\n#### 查看进程\n1. <span class=\"strong\">ps aux</span>&emsp;使用BSD(unix)标准格式显示进程\n\n+ a &emsp;显示所有前台进程\n+ x &emsp;显示所有后台进程\n+ u &emsp;显示进程由哪个用户产生\n\n<div class=\"show\">BSD格式的进程信息：\nUSER：该进程由哪个用户产生\nPID：进程的ID号\n%CPU：进程占用的CPU百分比\n%MEM：进程占用的物理内存百分比\nVSZ：进程占用的虚拟内存，单位为KB\nRSS：进程占用的物理内存大小，单位为KB\nTTY：进程在哪个终端运行，？为由Linux系统运行，tty1-tty6为本地字符界面终端，tty7为图形终端，pts/0-255为远程登录虚拟终端\nSTAT：进程状态，常见的状态字符有：R运行(runnable)，S睡眠(sleeping)，s包含子进程，+位于后台的进程组，T停止，&lt;优先级高的进程，N优先级低的进程，l多线程，Z僵尸进程，D无法中断的休眠进程(通常为IO进程)\nSTART：进程启动时间\nTIME：进程占用CPU时间\nCOMMAND：产生进程的命令名\n</div>\n2. <span class=\"strong\">ps -le</span>&emsp;使用Linux标准格式显示进程\n\n+ -l &emsp;显示详细信息\n+ -e &emsp;显示所有进程\n+ -C命令&emsp;显示指定命令的状态\n\n<div class=\"show\">Linux格式的进程信息：\nUID：产生进程的用户ID\nPID：进程的ID号\nPPID：父进程ID\nC：进程占用CPU百分比\nSTIME：进程启动时间\nTTY：进程在哪个终端运行，参数同上\nCMD：产生进程的命令名\n</div>\n\n#### 查看进程树\n<span class=\"strong\">pstree [选项]</span>\n\n+ -p &emsp;显示进程PID\n+ -u &emsp;显示进程所属用户\n\n#### 查看进程调用的文件\n<span class=\"strong\">lsof [参数]</span>\n\n+ -c 字符串 &emsp;只列出以字符串开头的进程打开的文件\n+ -u 用户名 &emsp;只列出某个用户所启动进程打开的文件\n+ -p pid   &emsp;只列出某个PID进程打开的文件\n\n\n\n#### 监控系统资源占用状态\n<span class=\"strong\">top [参数]</span>\n\n+ -d 秒数 &emsp;指定每几秒更新系统状态，默认是3秒\n\n显示当前系统的内存、CPU占用情况，显示状态下通过下列按键进行交互\n+ ?或h &emsp;显示交互帮助\n+ P &emsp; 根据CPU占用率显示进程顺序，默认\n+ M &emsp; 根据内存占用率显示进程顺序\n+ N &emsp; 根据PID显示进程顺序\n+ q &emsp; 退出top监控\n\n<div class=\"shell\">系统资源显示信息：\ntop - 15:40:11 up 41 days, 15:45,  2 users,  load average: 0.04, 0.05, 0.01\nTasks:  78 total,   1 running,  45 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :   492280 total,    15964 free,    74408 used,   401908 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.   375944 avail Mem\n\nPID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND  \n  1 root      20   0   51704   4948   3660 S  0.0  1.0  10:45.34 systemd\n</div>\n\n<div class=\"table\" style=\"text-align:left;\">\n\n|内容             |说明           |\n|:-----------     |:---            |\n|15:40:11         |系统当前时间\n| up 41 days,15:45|系统运行时间，已运行41天15小时45分|\n| 2 users         |当前登录用户数量|\n|load average: 0.04, 0.05, 0.01|系统在1分钟、5分钟、15分钟前的平均负载，根据主机内核数量判断负荷情况，如 8核，超过8表明已超负荷运行|\n|Tasks|Tasks后分别为 系统中的总进程数、正在运行的进程、睡眠进程、停止的进程、僵尸进程|\n| %Cpu(s)|us为CPU被用户占用的比率，sy为系统占用比例，ni为修改过优先级的用户进程CPU占用比率，id为CPU空闲的比率，wa为等待输入、输出的进程占用CPU的比率，hi为硬中断请求服务占用CPU比率，si为软中断请求服务占用CPU比率，st为有虚拟机时，虚拟CPU等待实际CPU的时间百分比|\n|  Mem |物理内存总大小、空闲内存大小、使用内存大小、正在缓冲的内存大小|\n| Swap |交换分区总大小、空闲部分、使用部分、有效大小|\n\n</div>\n\n#### 按指定次数监控系统资源\n<span class=\"strong\">vmstat 刷新延迟 监听次数</span>\n\n输出进程数、内存状态、交换分区状况、硬盘输入输出状况、CPU状态\n<div class=\"show\"># vmstat 3 4\n每3秒监听一次系统资源，输出4次</div>\n\n#### 查看开机时检测的系统内核信息\n<span class=\"strong\">dmesg</span>\n\n会输出非常详细的CPU(如型号、主频、核心数....)、网卡、硬盘等主机开机检测的信息，一般通过管道符只查看某部分具体信息，如: dmesg | grep CPU 查看CPU详细信息\n\n##### 查看CPU信息\n开机检测后，检测到的信息会按格式写于<span class=\"tips\">/proc/cpuinfo</span>文件中，通过该文件查看CPU信息更为清晰\n\n#### 查看内存信息\n<span class=\"strong\">free [参数]</span>\n\n+ -b &emsp;以字节单位显示内存大小\n+ -k &emsp;以KB单位显示内存大小(默认)\n+ -m &emsp;以MB单位显示内存大小\n+ -g &emsp;以GB单位显示内存大小\n\n#### 查看操作系统内核\n<span class=\"strong\">uname [选项]</span>\n\n+ -a &emsp;查看系统所有信息\n+ -r &emsp;查看内核版本\n+ -s &emsp;查看内核名称\n+ -m &emsp;查看内核架构、操作系统位数\n\n通过查看文件系统的位数，也可以查看操作系统位数，如执行 <span class=\"tips\">file /bin/ls</span>，其中/bin/ls可以为任意外部命令\n\n#### 查看当前Linux操作系统的发行版本\n使用cat命令查看 <span class=\"tips\">/etc/system-release</span>或 <span class=\"tips\">/etc/redhat-release(红帽专属)</span>文件即可\n\n#### 中止进程\n##### 系统的中止信号\n<span class=\"strong\">kill -l</span>查询可用的进程信号\n常用的进程信号\n<div class=\"table\">\n\n|代号|名称   |    说明           |\n|--- |----  | -------            |\n|1   |SIGHUP|该信号用于让进程重新读取配置文件后重启|\n|2   |SIGINT|中止前台进程，相当于ctrl+C|\n|9   |SIGKILL|该信号用于强制中止进程|\n|15  |SIGTERM|正常中止进程，kill命令的默认信号|\n|18  |SIGCONT|让一个暂停的进程继续执行|\n|19  |SIGSTOP|暂停进程的执行|\n</div>\n\n##### kill命令\n<span class=\"strong\">kill [信号代号] [进程PID]</span>\n\n根据进程PID中止进程\n+ kill -15 PID &emsp;中止进程(默认，-15可省略)\n+ kill -1 PID &emsp;重新载入配置文件后重启\n+ kill -9 PID &emsp;强制中止进程\n\n##### killall命令\n<span class=\"strong\">kill [参数][信号代号] [进程名]</span>\n\n根据进程名中止进程\n+ -i &emsp;询问是否杀死某进程\n+ -I &emsp;忽略进程名大小写\n\n##### pkill命令\n<span class=\"strong\">pkill [参数][信号代号] [进程名]</span>\n\n+ -t 终端号 &emsp;按终端号关闭用户的连接(踢出用户)\n\n<div class=\"show\"># pkill -9 -t tty1\n关闭终端号为 tty1 用户的连接\n</div>\n\n### 工作管理\n#### 将程序转入后台运行/暂停\n<span class=\"strong\">在命令后添加 <span class=\"tips\"> & </span>，可使该命令在后台执行</span>\n<div class=\"show\">如：\n# tar -zxf test.tar.gz &\n在后台解压缩 test.tar.gz文件，执行完会提示Done\n</div>\n\n<span class=\"strong\">在命令运行时执行<span class=\"tips\"> Ctrl + Z </span> 是将当前工作暂停后转入后台</span>\n<div class=\"show\">如：\n# top\n执行Ctrl + Z会将监视系统资源的top程序设为stopped(暂停)状态后转入后台\n</div>\n\n#### 查看后台的工作\n<span class=\"strong\"> jobs [-l]</span>\n\n+ -l &emsp;显示工作的PID\n\n<div class=\"shell\">[1]   Stopped                 top\n[2]-  Stopped                 top\n[3]+  Stopped                 top</div>\n\n[3]代表工作序号，“+”号代表最后一个放入后台的工作，“-”号代表倒数第二个放入后台的工作，恢复时默认使用出栈方式从最后一个放入后台的工作开始恢复\n\n#### 将后台暂停的工作恢复到前台执行\n<span class=\"strong\"> fg [%工作序号]</span>\n\n+ %可省略，如果不添加工作序号，则默认从后放入的工作开始恢复\n\n#### 将后台暂停的工作恢复到后台执行\n<span class=\"strong\"> bg [%工作序号]</span>\n\n+ %可省略，如果不添加工作序号，则默认从后放入的工作开始恢复\n\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\ntop，vi等服务于前台的命令，不能恢复到后台执行。</div>\n\n###  alternatives工具\n#### alternatives简介\nalternatives工具常用于指定默认软件、默认配置，或者某一软件的默认版本。\n\n如：在Linux中，yum等工具一般使用python2作为命令解释器，而一些较新的软件依赖较新版的python3。因此有时我们不得不同时安装python2和python3。如果使用 python3 作为默认的python版本，使用yum会抛出错误，这是因为使用了python3解析yum中python2的语法，同理，一些较新的软件也无法使用python2解析。此时，我们就需要使用alternatives来控制软件的默认版本。\n\nalternatives的使用方法是：给定两个软件或多个软件的路径，然后将它们注册为一个组，为这个组建立一个软链接，之后调用软件将直接从这一软链接调用\n\n#### alternatives命令\n##### 注册组\n<span class=\"strong\">alternatives -&zwnj;-install &lt;link> &lt;name> &lt;path> &lt;priority></span>\n\n+ -&zwnj;-install 注册(新增)需要管理的命令/软件\n+ link：注册路径，会在该路径下生成一个软链，此后由该软链启动命令\n+ name：组名\n+ path：软件/命令的路径，将该路径下的命令加入alternatives管理组\n+ priority：权值，在自动模式下，权值越高，软件优先级越高\n\n##### 其他命令\n+ <span class=\"strong\">alternatives -&zwnj;-config &lt;name></span> 修改默认配置(将进入交互模式，并切换为手动模式)\n+ <span class=\"strong\">alternatives -&zwnj;-set &lt;name> &lt;path></span> 修改默认配置(将切换为手动模式)\n+ <span class=\"strong\">alternatives -&zwnj;-auto &lt;name></span> 切换为自动模式\n+ <span class=\"strong\">alternatives -&zwnj;-display &lt;name></span> 显示对应组的配置信息(包括自动/手动模式，路径，权值)\n+ <span class=\"strong\">alternatives -&zwnj;-remove &lt;name> &lt;path></span> 删除组中对应路径的软件\n+ <span class=\"strong\">alternatives -&zwnj;-list</span> 列出所有组的信息(组名、自动/手动模式、当前默认软件路径)\n\n\n#### 示例\n##### 1. 注册组\n在<span class=\"tips\">/usr/bin</span>目录下有python2.7与python3.7的启动命令，我们可以新建python组，将python2和python3的启动路径加入到该组中，并指定python3为默认版本，此后直接执行<span class=\"tips\">python</span>命令将唤醒python3，而不用再指定明确的版本号，且将默认唤醒python3，该默认值是可以随时更改的\n<div class=\"shell\"><code># alternatives --install /usr/bin/python python /usr/bin/python2.7 10\n# alternatives --install /usr/bin/python python /usr/bin/python3.6 20\n</code></div>\n\n上述命令\n+ 将在 <span class=\"tips\">/usr/bin</span> 目录下新建名为 <span class=\"tips\">python</span> 的软链接，该软链接指向<span class=\"tips\">/etc/alternatives/python</span>，该链接又指向<span class=\"tips\">/usr/bin/python3.6</span>\n\n<div class=\"show\">即 /usr/bin/python --> /etc/alternatives/python --> /usr/bin/python3.6</div>\n\n+ 修改默认值，修改的是/etc/alternatives/python的指向，即默认值为python2.7时，/etc/alternatives/python链接指向将修改为/usr/bin/python2.7\n+ python3.6的权值为20，python2.7的权值为10，自动模式下，alternatives将优先调用python3.6\n+ 生成链接名可以任意自定义，并且调用命令也将相应修改，如：\n<div class=\"shell\"><code>alternatives --install /usr/bin/py ppyy /usr/bin/python3 10</code></div>\n调用命令将变为py:\n<div class=\"shell\">py --version #同python3 --version命令</div>\n\n###### 2. 修改默认值\n<div class=\"shell\"><code>alternatives --config python</code></div>\n将进入交互模式，让你输入序号选择版本\n<div class=\"shell\">There are 2 programs which provide 'python'.\n  Selection    Command\n-----------------------------------------------\n   1           /usr/bin/python2.7\n*+ 2           /usr/bin/python3.6\n\nEnter to keep the current selection[+], or type selection number: \n</div>\n\n+号为当前生效的版本，*为新增版本\n\n###### 3. 查看python组信息\n<div class=\"shell\"><code>alternatives --display python</code></div>\n<div class=\"shell\">python - status is manual. #python处于手动模式\n link currently points to /usr/bin/python3.6 #当前默认使用python3.6版本\n/usr/bin/python2.7 - priority 10  #可选版本信息\n/usr/bin/python3.6 - priority 20\nCurrent `best' version is /usr/bin/python3.6.\n</div>\n\n###### 4. 从组中删除python3.6版本\n<div class=\"shell\"><code>alternatives --remove python /usr/bin/python3.6</code></div>\n从python组中移除3.6版本，将只剩2.7版本可选\n\n\n### 定时任务\n#### crond服务\ncron即计划任务，而crond则是一个常驻服务，在Linux中用于周期性执行某个任务，该服务的配置文件位于<span class=\"tips\">/etc/crontab</span>\n\n##### 查看crond服务运行情况\n<span class=\"strong\">ps aux | grep crond</span>查看crond进程是否在运行，红帽系列的操作系统可使用<span class=\"strong\">service status crond</span>或<span class=\"strong\">systemctl status crond</span>(centos7+)\n\n##### 查看crond服务是否开机自启动\n<span class=\"strong\">chkconfig -&zwnj;-list | grep crond</span>或<span class=\"strong\">systemctl list-unit-files | grep crond</span>(centos7+)\n\n#### 设置crond定时任务\n可通过修改<span class=\"tips\">/etc/crontab</span>文件来设置定时任务，同路径下还有 cron.daily，cron.weekly等对应时间记录crond任务的文件。也可以通过命令来修改crontab文件，语法为:\n\n<span class=\"strong\">crontab [参数]</span>\n\n+ -e &emsp;编辑crontab定时任务\n+ -l &emsp;查询crontab定时任务\n+ -r &emsp;删除当前用户所有crontab任务\n\n##### cron语法\n编辑定时任务时会打开vi编辑器，编辑语法格式需遵循cron语法，基本格式为：<span class=\"tips\"><strong>***** 命令</strong></span>\n\n+ <span class=\"strong\">第一个*表示一小时当中的第几分钟，范围为0-59</span>\n+ <span class=\"strong\">第二个*表示一天当中的第几个小时，范围为0-23</span>\n+ <span class=\"strong\">第三个*表示一个月当中的第几天，范围为1-31</span>\n+ <span class=\"strong\">第四个*表示一年当中的第几个月，范围为1-12</span>\n+ <span class=\"strong\">第五个*表示一周当中的星期几，范围为0-7(0和7都代表星期日)</span>\n\n<div class=\"table\">\n\n|特殊符号|含义|\n|:--    |:--|\n|*      |代表任何时间|\n|,      |代表不连续的时间|\n|-      |代表连续的时间范围|\n|*/n    |代表隔多久执行一次|\n</div>\n\n<div class=\"show\">示例：\n30 23 * * * 命令      //每天的23：30执行对应命令\n0 1 1,15 * * 命令    //每个月1号和15号凌晨1:00执行命令\n30 2 * * 1-3 命令   // 每周一到周三凌晨2点30执行命令\n*/10 4 * * * 命令   //每天凌晨4点，每隔10分钟执行一次命令，执行6次(即小时数超过4时就停止)\n0 0 1,15 * 1 命令   //每个月1号，15号和每周一凌晨00:00执行一次命令\n0 2 1 * * /sbin/shutdown -r now 每个月1号凌晨2：00重启Linux\n</div>\n\n### 日志服务\n#### rsyslog服务\nSyslog(系统日志协议)是在一个IP网络中转发系统日志信息的标准，syslogd服务被广泛用于老版Unix/Linux系统中负责记录系统日志，RSyslog是syslog的多线程增强版，CentOS6以后系统默认使用Rsyslogd服务记录系统日志。\n\n##### 查询rsyslog服务是否在运行\n可使用命令<span class=\"strong\">ps aux | grep rsyslogd</span>查看rsyslog进程是否在运行，红帽系列可使用命令<span class=\"strong\">systemctl status rsyslog</span>查看\n\n##### 查看rsyslog服务是否开机自启动\n+ <span class=\"strong\">chkconfig --list |grep rsyslog</span>\n+ <span class=\"strong\">systemctl list-unit-files | grep rsyslog</span>(centos7)\n\n#### 日志文件\n系统日志默认保存在 <span class=\"tips\">/var/log</span> 路径下，对应文件的作用:\n<div class=\"table\">\n\n文件          |        说明|\n----          |         ----|\n/var/log/cron |定时任务相关日志\n/var/log/cups|打印系统的日志|\n/var/log/dmesg|开机内核自检的信息，使用dmesg命令就是读取了该文件|\n/var/log/btmp|错误登录日志，二进制文件，需通过<span class=\"tips\">lastb</span>命令查看|\n/var/log/lastlog|记录所有用户最后一次登录系统的日志，二进制文件，需通过<span class=\"tips\">lastlog</span>命令查看|\n/var/log/mailog|邮件日志|\n/var/log/message|记录系统所有重要事件信息\n/var/log/secure|记录所有涉及用户账户和密码的信息，如：用户登录，添加用户，切换用户，sudo授权，修改密码等|\n/var/log/wtmp|永久记录所有用户的登录、注销、系统启动、重启等信息，二进制文件，需使用<span class=\"tips\">last</span>命令查看|\n/var/log/utmp|记录当前登录的用户信息，并且随着用户注销、切换不断变化，使用w,who,users等命令查看\n\n</div>\n\n使用RPM包安装的服务也会默认把日志文件放在<span class=\"tips\">/vat/log/服务名</span> 路径下，但其日志由自身服务管理，而不归rsyslogd服务管理\n\n使用源码包安装服务的日志文件位于用户指定的安装路径下，一般位于 /usr/local路径下\n\n#### rsyslog日志格式\n日志文件通常由以下内容按顺序书写：\n+ 事件产生时间\n+ 服务器主机名\n+ 产生事件的服务名\n+ 事件的具体信息\n\n#### rsyslog日志配置文件\n该配置文件位于<span class=\"tips\">/etc/rsyslog.conf</span>，配置文件决定了日志系统记录哪些级别的日志信息，文件的格式为 <span class=\"tips\"><strong>服务名[连接符]日志等级&emsp;&emsp;日志记录位置</strong></span>\n\n##### 服务名\n<div class=\"table\">\n\n服务名称 | 说明\n----    |-----\nauth    |安全和认证相关信息\nauthpriv|安全和认证相关信息(私有信息)\ncron    |系统定时任务cront和At产生的日志\ndaemon  |守护进程相关的日志\nftp     |ftp守护进程相关日志\nkern    |内核产生的日志\nlocal0-local7|为本地预留的服务项\nlpr     |打印系统产生的日志\nmail    |邮件日志\nnews    |新闻服务器相关日志\nsyslog  |rsyslog服务产生的日志\nuser    |用户等级类别产生的日志\nuucp    |uucp(数据传输协议)子系统的日志\n\n</div>\n\n##### 连接符\n\n<div class=\"table\">\n\n连接符|说明\n----|----\n.   |表示比后面所写等级高(包含该等级)的日志都记录下来\n.=  |只记录指定等级的日志\n.!  |除了该等级，其余等级都记录\n</div>\n\n##### 日志等级\n\n<div class=\"table\">\n\n等级   |说明\n----  |----\n<strong>*</strong>     |所有等级\nnone  |与*相反，不记录任何日志\n debug|调试信息\n info |通知信息，反馈系统状态\n notice|提醒信息，程序可能存在潜在错误，但不影响运行\n warning|警告信息，程序发现错误，暂且不影响运行\n err    |错误信息，服务出错停止运行，需要修复\n crit   |临界状态信息，服务宕机，且可能无法修复\n alert  |警报信息，服务宕机，影响系统运行\n emerg  |紧急信息，系统疼痛等级，系统濒临崩溃甚至已经崩溃\n</div>\n\n##### 日志记录位置\n日志记录位置可以是以下值:\n+ 路径，写于本机指定位置，如:/var/log/lastlog\n+ 系统设备，写于U盘或者通过打印机打印日志，如:/dev/lp0\n+ 转发到远程主机或日志服务器，如:@192.168.0.100:514\n+ 用户名，发送给指定用户，如:root\n+ 忽略或丢弃日志，如：~ ，直接丢弃\n\n##### 示例\n以下示例来源于centos7系统默认配置\n<div class=\"shell\">cron.*                                                  /var/log/cron\n所有等级的cron日志写于/var/log/cron文件中\n*.emerg                                                 :omusrmsg:*\n出现疼痛等级的日志时，发送给所有用户\n*.info;mail.none;authpriv.none;cron.none                /var/log/messages\n不记录任何私人身份验证消息\nuucp,news.crit                                          /var/log/spooler\n将uucp,news服务crit和更高级别的日志信息保存在指定文件中\n</div>\n\n\n#### 日志轮替\n日志轮替用于用新日志覆盖旧日志，其配置文件位于<span class=\"tips\">/etc/logrotate.conf</span>，需要相关功能只需在配置文件中添加对应参数就即可。\n\n<div class=\"table\">\n\n参数                |说明\n-------             |--\ndaily/weekly/monthly|日志轮替周期\nrotate 数字         |保留日志文件的个数，0为不备份\ncompress           |日志轮替时，对旧日志进行压缩\ncreate 权限值 所有者 所属组|建立新日志，并指定日志文件的权限、所有者、所属组\nmail address       |日志轮替时，日志内容发送到指定邮箱，如:mail 11@gmail.com\nmissingok           |日志不存在时，忽略该日志的警告信息\nnotifempty          |如果日志文件为空，则不进行轮替\nmaxsize 大小        |当日志文件到达指定大小，无论是否到轮替时间，都进行一次轮替，未到达指定大小但到达轮替周期，也进行轮替\nminsize 大小        |到达轮替时间时，如果日志文件达到该最小值时就进行轮替，否则不进行轮替\nsize 大小           |时间周期设置无效，只有当日志文件大于指定大小才进行轮替\ndateext             |使用日期作为日志轮替文件名\n\n</div>\n\n\n<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n<span class=\"tips\">dateext</span>参数用于指定当前日期作为日志文件后缀名，如:secure-20210211。如果配置文件中没有该参数，则日志文件将以.1，.2作为文件名名后缀。如：当前日志文件为secure，进行轮替后该文件改名为secure.1，secure.1改为secure.2，而将新的日志文件命名为secure。</div>\n\n##### 配置文件内容\n通过RPM包安装的服务其日志会被自动识别配置轮替，通过源码包安装的服务需要自行添加配置，配置格式同本地配置的基本格式。\n\n<div class=\"shell\"># see \"man logrotate\" for details\n# rotate log files weekly\nweekly\n\n\\# keep 4 weeks worth of backlogs\nrotate 4\n\n\\# create new (empty) log files after rotating old ones\ncreate\n\n\\# use date as a suffix of the rotated file\ndateext\n\n\\# uncomment this if you want your log files compressed\n#compress\n\n\\# RPM packages drop log rotation information into this directory\ninclude /etc/logrotate.d\n\n\\# no packages own wtmp and btmp -- we'll rotate them here\n/var/log/wtmp {\n    monthly\n    create 0664 root utmp\n\tminsize 1M\n    rotate 1\n}\n/var/log/btmp {\n    missingok\n    monthly\n    create 0600 root utmp\n    rotate 1\n}\n本地配置格式(若某参数同时设置了本地配置和全局配置，则本地配置生效)\n日志路径 {\n  配置参数\n}\n如：\n/usr/local/apache/logs/access_log {\n  daily      //每天进行日志轮替\n  create    //日志轮替时新建日志，文件权限、所有者等信息默认\n  rotate 30 //保留30份日志文件(即保留30天)\n}\n</div>\n\n##### 手动进行日志轮替\n<span class=\"strong\">logrotate [参数] 配置文件名</span>\n\n不添加任何参数时，将按配置文件进行轮替\n+ -v 显示日志轮替的过程\n+ -f 无论是否达到轮替配置要求，强制进行日志轮替\n\n### 备份与恢复\n#### 备份\n<strong>完全备份：</strong>即把所有需要备份的数据全部备份， 在Linux 中，完全备份指将根目录下的所有文件进行备份。\n\n<strong>增量备份：</strong>指第一次进行完全备份，服务器运行一段时间后，比较当前数据和第一次备份数据之间的差异，只备份有差异的数据，之后的每次备份都只备份与上一次备份有差异的数据。\n\n##### 一般需备份的数据\n+ <strong>/root/</strong>&emsp;管理员账户根目录\n+ <strong>/home/</strong>&emsp;普通用户家目录\n+ <strong>/var/spool/mail</strong>&emsp;邮件\n+ <strong>/etc/</strong>&emsp;重要服务的配置文件\n+ <strong>/var/log</strong>&emsp;常用服务的日志\n+ <strong>数据库数据、账户资料....</strong>\n\n#### dump文件备份系统\n##### 1. 安装dump\n+ <strong>yum -y install dump</strong> (redhalt系列)\n+ <strong>apt-get install dump</strong> (debian系列)\n\n##### 2. dump命令\n<span class=\"strong\">dump [参数] 备份后文件名 原文件或目录</span>\n\n+ -[0-9级别]&emsp;可选0-9备份级别\n+ -f 文件名&emsp;指定备份后的文件名\n+ -u&emsp;备份成功后，把备份时间、备份级别等信息记录在 /etc/dumpdates 文件中\n+ -v&emsp;显示备份过程中更多的输出信息\n+ -j&emsp;调用 bzlib 库压缩备份文件，其实就是把备份文件压缩为 .bz2 格式，默认压缩等级为2\n+ -W&emsp;显示允许被 dump 的分区的备份等级及备份时间\n\n##### 3.备份操作\n对于某个文件或不是分区的目录，dump只能使用 0 级别进行完全备份。而备份分区或整块硬盘时，dump 通过“备份级别”实现增量备份，其中，0 级别是完全备份，1-9为增量备份。\n\n当我们备份数据时，第一次备份应该使用 0 级别，dump会把所有数据完全备份一次；第二次备份就可以使用 1 级别了，它会和 0 级别进行比较，把 0 级别备份之后变化的数据进行备份；第三次备份使用  2 级别，2 级别会和 1 级别进行比较，把 1 级别备份之后变化的数据进行备份，以此类推。\n\n###### 备份目录\n<div class=\"show\"># dump -0uj -f /new/home.bak.bz2 /home/\n完全备份home目录到/new/home.bak.bz2路径下\n</div>\n\n###### 备份分区\n<div class=\"show\">#df -h \n查看分区信息\n# dump -0uj -f /root/boot.bak.bz2 /boot/\n第一次备份进行完全备份，记录备份信息\n# dump -1uj -f /root/boot.bak1.bz2 /boot/\n第二次开始使用增量备份\n# dump -W\n查询分区的备份时间及备份级别(需要备份的时候添加u参数)\n</div>\n\n#### restore还原dump备份的文件\n<span class=\"strong\">restore [模式选项] [-f 文件名]</span>\n\n-f用于指定备份文件文件名，模式选项有四个，只能选一个模式\n\n+ -C&emsp;比较模式，比较备份数据和现有数据的不同并返回(只能检测出数据修改或减少的部分，如果新增了数据不会被检测到)\n+ -i&emsp;交互模式，手动选择需要恢复的文件\n+ -t&emsp;查看模式，用于查看备份文件中拥有哪些文件和目录\n+ -r&emsp;还原模式，用于数据还原(如果是增量备份，则需先还原首次完全备份的数据)\n\n<div class=\"show\"># restore -r -f /root/boot.bak.bz2\n先还原增量备份中首次备份的数据\n# restore -r -f /root/boot.bak.bz2\n再还原第二次开始增量备份的数据\n</div>\n\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n一般使用<span class=\"tips\">bak</span>作为系统备份文件名后缀</div>","tags":["Linux","command"]},{"title":"Linux 运行级别与用户管理","url":"/blog/2021/12/29/Linux用户与用户组/","content":"\n### Linux目录\n#### 指令集\n+ <strong>/bin</strong> &emsp; Binaries的缩写，存放普通用户可使用的系统命令,如:ls\n+ <strong>/sbin</strong>&emsp;Super user Binary的缩写，存放只有系统管理员才能使用的系统命令，如:shutdown、reboot\n+ <strong>/usr/bin</strong>&emsp;存放安装软件后，普通用户可以使用的软件命令，如:c++、make、wget等\n+ <strong>/usr/sbin</strong>&emsp;存放系统管理员用户安装使用的高级管理程序和系统服务程序，如:httpd、netconfig、tcpd等\n\n\n#### 系统文件\n+ <strong>/etc</strong>&emsp;Etcetera(其他)的缩写，这个目录用来存放所有系统管理所需要的<strong>配置文件</strong>和子目录\n+ <strong>/var</strong>存放一些经常被修改、扩充的文件，如各种日志文件\n+ /boot&emsp;存放引导启动Linux时使用的核心文件,如镜像文件等\n+ /sys&emsp; Linux2.6内核新增的文件系统sysfs，sysfs文件系统集成了3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统\n+ /lib&emsp;存放系统所需要的动态链接库(如C++库)，相当于windows的dll文件\n+ /dev&emsp;Device的缩写, 将Linux主机的硬件以文件形式存储并提供访问，相当于Windows的设备管理器\n+ /usr/src&emsp;内核源代码、说明文档等默认放置目录\n+ /opt&emsp;默认为空，常用于安装额外软件\n+ /proc&emsp;Processes(进程)的缩写，虚拟的目录，用于管理内存空间，是系统内存的映射，我们可以直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里\n+ /selinux&emsp;全称为security-enhanced linux，该目录是 Redhat/CentOS 所特有的目录，是Redhat/CentOS的安全子系统\n+ /srv&emsp;service缩写，存放一些服务启动后需要提取的数据\n\n\n#### 用户\n+ <strong>/root</strong>&emsp;系统管理员的账号主目录\n+ <strong>/home</strong>&emsp;存放普通用户的相关文件，Linux会在home目录下为每一个用户生成一个以用户账号命名的目录\n+ <strong>/usr</strong>&emsp;Unix Software Resource(共享资源)的缩写,放置用户的应用程序和文件，类似于windows下的program files目录\n+ <strong>/usr/local</strong>&emsp;软件安装目录，一般通过源码编译安装方式安装的软件都会存放于该目录下\n+ /usr/include&emsp;放置如c/c++等程序语言的头文件(header)与包含档(include)\n+ /usr/lib&emsp;放置各应用软件的函式库、目标文件等，如果使用的是X86_64的Linux系统，则可能会生成/usr/lib64文件夹\n\n#### 外部文件\n+ <strong>/media</strong>&emsp;挂载U盘、光驱等设备的目录，类似于windows的其他设备\n+ /mnt&emsp;让用户挂载其他的文件系统，如将Windows上的某个目录挂载在/mnt下，可用于共享文件等\n\n#### 临时文件\n+ /lost+found&emsp;一般情况下为空目录，用于存放系统非法关机或者发生意外错误后，fsck(磁盘修复)过程修复的部分文件\n+ /tmp&emsp;用于存放临时文件\n+ /run&emsp;一个临时文件系统，存放存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。\n\n\n### 系统运行级别\nLinux系统的开机过程流程为：加载BIOS，进入Boot Loader，加载系统内核，进行内核初始化，启动初始化进程init。\n\n可以使用<span class=\"tips\">init 运行级别</span>在系统运行级别之间切换，使用<span class=\"tips\">runlevel</span>查询当前运行级别。\n<div class=\"table\">\n\n运行级别(runlevel) | 说明\n-------|------\n0|系统关机，禁止设置为系统默认运行级别\n1|单用户状态，只启动系统核心，用于系统修复和维护\n2|多用户状态，禁用NFS(网络文件系统)和网络服务，可用于停机维护\n3|完全多用户状态，具有完整的功能\n4|系统未使用，保留\n5|GUI模式，桌面版Linux专属\n6|系统重启，禁止设置为系统默认运行级别\nemergency|用于系统救援\n</div>\n\n在路径<span class=\"tips\">/etc/rc.d</span>下存放有7个对应系统运行级别的目录<span class=\"tips\">/rc0.d——rc6.d</span>，目录中列出了该运行级别下会启动/关闭的服务，init.d目录下存放有用户可以开机启动的脚本，对于以K(Kill)开头的文件，系统会关闭对应的服务，以S(Start)开头的文件，系统将启动对应的服务，并且启动/关闭次序为S/K之后的值。<span class=\"tips\">rc.local</span>文件用于配置用户开机执行的命令，系统在启动后将自动执行该文件中的所有命令。\n\n在一些旧版本的Linux中，/etc/rc.d路径下还含有<span class=\"tips\">/etc/inittab</span>文件，文件中可以设置系统默认运行级别。centos7之后的系统将不再支持该方式修改默认级别，而使用target替代了sysvinit的运行级。\n<div class=\"table\">\n\nSys v init runlevel | systemd target\n-------|------\n0|poweroff.target\n1|rescue.target\n2|multi-user.target\n3|multi-user.target\t\n4|multi-user.target\n5|graphical.target\n6|reboot.target\nemergency|emergency.target\n</div>\n<div class=\"show\">系统默认以启动runlevel3启动\n# systemctl set-default multi-user.target\n系统默认以启动runlevel5启动\n# systemctl set-default graphical.target\n查看当前运行级别\n# systemctl get-default\n</div>\n\n\n\n### 命令\n许多主流Linux系统默认使用的Shell(终端程序)是Bash(GNU Bourne-Again Shell)解释器，可以通过<span class=\"tips\">上下方向键</span>来调取之前执行过的Linux命令，可以使用<span class=\"tips\">Tab键</span>来补全命令、参数或文件名。\n<p>常见的执行Linux命令的格式为</p>\n<p><span class=\"strong\">命令  [参数] [对象]</span></p>\n\n+ 有多个可选参数时，可以写在一起\n+ 参数可以用长格式(完整的参数名称)并使用\"-&zwnj;-\"作为前缀，也可以用短格式（单个字母的缩写）使用\"-\"作为前缀。如：<span class=\"tips\">-&zwnj;-help</span>和<span class=\"tips\"> -h</span>，但有时短格式与长格式表示的不是同一个参数，如：shutdown -&zwnj;-help会显示shutdown命令的帮助信息,shutdown -h则为系统关机命令\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n命令、参数与命令对象字母严格区分大小写</div>\n\n#### Linux的关闭与重启\n##### 1. sync 保存数据\n<span class=\"strong\">sync</span>&emsp;将内存数据存储到磁盘，<span class=\"tips\">关机或重启Linux前应当执行该命令防止数据丢失</span>\n\n##### 2.shutdown 命令(推荐使用)\nshutdown命令用于关闭/重启Linux，命令格式为\n<p> <span class=\"strong\">   shutdown [选项] [时间] [警告消息]</span></p>\n常用选项\n<ul>\n<li><span class=\"strong\">-t 值</span>&emsp;设置在几秒后关机</li>\n<li><span class=\"strong\">-h</span>&emsp;关机</li>\n<li><span class=\"strong\">-r</span>&emsp;重启</li>\n<li><span class=\"strong\">-c</span>&emsp;取消已经设置的关机/重启命令</li>\n<li>- m&emsp;强制杀死所有执行中的程序,然后关机(不调用init进程)</li>\n<li>-k &emsp;不关机，仅把警告讯息传送给所有登录的用户</li>\n<li>-f &emsp;强制略过fsck磁盘检测(unbuntu独有参数)</li>\n<li>-F &emsp;强制进行fsck磁盘检测(unbuntu独有参数)</li>\n<li>-w &emsp;测试使用，系统不会重启，但会把重新开机的数据写入/var/log目录下的wtmp记录文件</li>\n<li>-H 或 --halt&emsp;&emsp;&emsp;相当于halt</li>\n<li>-P 或 --poweroff&emsp;相当于poweroff</li>\n<li>--no-wall &emsp;&emsp;&emsp;&emsp;系统在重启、关闭时不发送信息给登录的用户</li>\n</ul>\n<div class=\"show\">示例：\n# shutdown -t 30        30s后关机\n# shutdown -h now       马上关机\n# shutdown -h 12:30     12:30关机，会占用终端\n# shutdown -h 12:30 &   12:30关机，关机命令会在后台处理不占用终端\n# shutdown -h 10 \"System will shutdown after 10 minutes\"    10分钟后关机并发送消息给用户\n# shutdown -r +10       10分钟后重启\n# shutdown -fr now      马上重启并强制略过fsck磁盘检测\n# shutdown -c           取消已设置的关机/重启命令\n</div>\n\n##### 3.halt 关机\n<span class=\"strong\">halt [选项]</span>\n\n可选选项\n+ -d &emsp;不把关机记录写到 /var/log/wtmp 文件里\n+ -n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)\n+ -w &emsp;不会真的关机,只是把关机记录写到 /var/log/wtmp 文件里\n+ -f &emsp;强制关机，不调用shutdown命令\n+ -i &emsp;关机前关闭所有网络接口\n+ -p &emsp;关机后关闭电源(poweroff)\n\n##### 4.reboot 重启\n<span class=\"strong\">reboot [选项]</span>\n\n可选选项\n+ -d &emsp;不把重启记录写到 /var/log/wtmp 文件里\n+ -n &emsp;重启前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)\n+ -w &emsp;不会真的重启,只是把重启记录写到 /var/log/wtmp 文件里\n+ -f &emsp;强制重启，不调用shutdown命令\n+ -i &emsp;重启前关闭所有网络接口\n\n##### 5.poweroff 关机并切断电源\n<span class=\"strong\">poweroff [选项]</span>\n\n可选选项\n+ -d &emsp;不把关机记录写到 /var/log/wtmp 文件里\n+ -n &emsp;关机前不保存数据到硬盘(包括不把记录写到 /var/log/wtmp 文件里)\n+ -w &emsp;不会真的关机,只是把关闭记录写到 /var/log/wtmp 文件里\n+ -f &emsp;强制关闭\n+ -i &emsp;关机前关闭所有网络接口\n+ -h &emsp;关机前将系统中所有的硬件设置为备用模式\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n除了上述命令，还可以通过设置系统运行级别进行关机、重启。使用 <span class=\"tips\">init 0 </span>关机，使用<span class=\"tips\">init 6 </span>重启。\n</div>\n\n### 用户与组管理\nLinux系统是一个多用户多任务的分时操作系统，用户可以属于一个或多个组方便系统管理员控制用户权限，默认有一个root管理员组并且root账户属于该组。可以使用<span class=\"tips\">logout</span>登出当前用户账户。\n#### 用户管理\n##### 1. 添加用户\n<span class=\"strong\">useradd [可选参数] 用户名</span>\n<p>默认会在/home 目录下生成一个以用户名命名的文件夹作为用户的主文件夹，并且会生成一个与用户名同名的用户组。</p>\n可选参数：\n\n+ -c 注释 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;为用户添加一段注释性描述\n+ -d /路径/目录名&emsp;&emsp;&emsp;自定义用户的主目录，即不使用与用户名同名的默认目录,如果该目录不存在，则可以同时使用-m参数来新建文件夹指定为主目录\n+ -g 用户组 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户所属的初始用户组\n+ -G 用户组，用户组 &emsp;指定用户所属的附加用户组\n+ -s Shell文件 &emsp;&emsp;&emsp;&emsp;指定用户的登录Shell\n+ -u 用户号 &emsp;&emsp;&emsp;&emsp;&emsp;指定用户的用户号，可以添加-o选项来重复使用与其他用户相同的标识号\n<div class=\"show\">示例：\n# useradd yg\n新增用户yg，同时会新建一个组yg\n# useradd -g gumu lmc\n新增用户lmc，并且将lmc添加到gumu组\n# useradd -d /somedir/user2dir -m user2\n新建用户user2，在 /somedir 文件夹下新建user2dir并将其主目录指定为user2dir (somedir文件夹必须存在，无法用上述命令直接新建)\n</div>\n\n##### 2. 给用户添加/修改密码\n<span class=\"strong\">passwd [可选参数] [用户名]</span>\n不写用户名则会修改当前账户密码，输入密码时不会显示在终端上,可选参数：\n\n+ -l &emsp;锁定口令，禁止用户自行修改(参数为小写L)\n+ -u &emsp;解锁口令，允许用户自行修改\n+ -S &emsp;显示密码信息\n+ -d &emsp;删除账户口令\n+ -f &emsp;强迫用户下次登录时必须修改口令\n+ -x &emsp;指定口令最长存活期\n+ -k &emsp;\t保留即将过期的用户在期满后能仍能使用\n\n##### 3. 删除用户\n只能在root账户下删除用户\n+ <span class=\"strong\">userdel 用户名</span>&emsp;删除用户但保留用户的主目录\n+  <span class=\"strong\">userdel -r 用户名</span>&emsp;删除用户且不保留用户主目录\n\n##### 4. 查询用户信息\n<span class=\"strong\">id 用户名</span>\n查询是否有该用户，有则返回用户号(uid)、组号(gid)、所属组名\n\n##### 5. 切换用户\n<span class=\"strong\">su [可选参数] 用户名</span>\n从权限高的账户切换到权限低的用户不需要输入密码，反之需要。切换完用户后，可通过 <span class=\"tips\">exit</span> 命令返回原来的用户\n+ -&emsp; 使用\"-\"在切换用户时会连带切换用户环境，如:家目录，用户邮箱等\n+ -c 命令 &emsp;仅切换到该用户执行一次-c后的命令\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n仅使用 <span class=\"tips\">su 用户名</span> 不会切换用户环境，在很多使用场景中会报错，推荐使用<span class=\"tips\">su - 用户名</span>命令</div>\n\n##### 6. 修改用户信息\n<span class=\"strong\">usermod [可选参数] 用户名</span>\n\n+ -u UID &emsp;修改用户UID\n+ -c 用户说明 &emsp;修改用户说明信息\n+ -G 组名 &emsp; 修改用户附加组\n+ -L &emsp;&emsp;临时锁定用户\n+ -U &emsp;&emsp;解锁用户\n\n##### 7. 修改用户密码状态\n<span class=\"strong\">chage [可选参数] 用户名</span>\n\n+ -l  &emsp;&emsp;列出用户详细密码状态\n+ -d 日期 &emsp;修改密码最后一次修改日期(修改shadow文件字段3)\n+ -m 天数 &emsp; 两次密码修改间隔(字段4)\n+ -M 天数 &emsp;&emsp;密码有效期(字段5)\n+ -W 天数 &emsp;&emsp;密码过期前警告天数(字段6)\n+ -I 天数 &emsp;&emsp;密码过期后宽限天数(字段7)\n+ -E 日期 &emsp;&emsp;账号失效时间(字段8)\n<div class=\"show\">使用：\n# chage -d 0 user1\n强制用户user1下次登录修改密码\n</div>\n\n##### 8. 查看当前所有登录用户\n###### 8.1 查看当前使用的账户\n<span class=\"strong\">whoami 或 who am i</span>\n\n###### 8.2 查看当前登录的用户\n<p><span class=\"strong\">who</span></p>\n<p>会返回登录用户名、登录终端、登陆时间(远程登录还有IP地址)，登录终端中tty表示本地登录终端，pts一般为远程登录。</p>\n\n<p> <span class=\"strong\">w</span></p>\n<p>会返回更详细的登录信息。</p>\n<div class=\"show\">w命令返回值解析：\n15:20:10 up 25 days, 15:25,  1 user,  load average: 0.00, 0.00, 0.00\nUSER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT\nroot     pts/0    180.129.129.129  10:09    0.00s  0.04s  0.04s -bash\n第一行为登录时间，up后为linux运行时间，用户数量，服务器负载情况\n第二行IDLE为用户已经空闲时间，JCPU为用户累计CPU占用时间，PCPU为用户当前命令操作占用CPU时间，WHAT为用户操作\n</div>\n\n#### 用户的相关文件\nLinux通过用户配置文件来查看和修改用户信息\n##### 1. 用户的信息文件\n文件位于<span class=\"tips\">/etc/passwd</span>，每一行代表一个用户，并且以\n<div class=\"show\"><span class=\"tips\">用户名:密码标识:用户UID:用户初始组GID:用户说明:家目录:登录的Shell</span></div>\n格式书写用户信息\n\n+ 密码标识中，有 X 表示用户有密码，用户登录时linux会前往/etc/shadow查找密码\n+ 用户UID：0 为超级管理员用户，1-1000为系统用户，系统用户为ftp等由linux调用的用户，无法登录，修改可能会导致系统无法启动，1000以上为普通用户(旧版本的linux可能1-500为系统用户)\n+ 用户说明可以为空\n+ 用户登录shell一般默认为/bin/bash，系统用户为/sbin/nologin,可以将普通用户的shell更改为/sbin/nologin来禁止用户登录\n#### 2. 用户的密码文件\n文件位于<span class=\"tips\">/etc/shadow</span>，保存了加密后的用户密码等信息，每一行代表一个用户，如：\n<div class=\"show\">swv:$6$hPQczrTV$urGtx/wXaOtfIKdyuD/aUO.tHogxBM7uie4ioSbyVgcpNS3Po.:19032:0:99999:7:::</div>\n\n+ 字段一：用户名\n+ 字段二：加密后的密码，如果为\"!!\"或\"*\"表示没有密码，无法登录\n+ 字段三：密码最后一次修改日期，以1970年1月1日作为标准时间，每天+1\n+ 字段四：允许的两次密码修改间隔，如：10为只允许每10天修改一次密码\n+ 字段五：密码有效期\n+ 字段六：密码到期提前警告时间\n+ 字段七：密码到期后仍然可使用时间，如：3为还可以使用3天，其中0代表到期立马失效，-1代表到期后仍然能永久使用\n+ 字段八：账号失效时间，使用时间戳(到期时间与1970-1-1的间隔天数)表示\n+ 字段九：保留字段(未使用)\n\n#### 3. 用户的邮箱文件\n文件位于<span class=\"tips\">/var/spool/mail/用户名/</span>，Linux用户可以相互发送内部邮件\n\n#### 4. 用户模板目录\n文件位于<span class=\"tips\">/etc/skel/</span>，用于制作一个模板文件，在新注册用户时会在用户家目录下自动生成该文件。如：给每个账户生成一个用户操作手册。\n\n#### 用户组管理\n用户组方便系统对同一类型的用户进行管理，对用户组的修改实际上就是对/etc/group文件的更新。\n##### 1. 增加组\n<span class=\"strong\">groupadd [可选参数] 组名</span>\n可选参数：\n+ -g GID &emsp;指定新用户组的组标识号（GID）\n+ -o &emsp;&emsp;&emsp;一般与-g参数同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n##### 2.修改用户组\n<span class=\"strong\">groupmod [可选参数] 组名</sapn>\n\n+ -g GID &emsp;修改组ID\n+ -n 新组名&emsp;修改组名\n\n##### 3. 删除用户组\n<span class=\"strong\">groupdel 组名</span>\n如果组中有初始用户，该组无法删除(以避免用户不属于任何一个组，想删除该组可以先删除该初始用户的账户)，若组中都为附加用户则可以删除。\n\n##### 4. 把用户添加入组或从组中删除\n<span class=\"strong\">gpasswd 必选参数 组名</sapn>\n\n+ -a 用户名&emsp;把用户加入组中\n+ -d 用户名&emsp;把用户从组中删除\n\n#### 用户组的配置文件\n##### 1. 用户组的信息文件\n组信息文件位于<span class=\"tips\">/etc/group</span>，信息格式为：\n<div class=\"show\"><span class=\"tips\">组名:组密码标识:组GID:组中的附加用户</span></div>\n字段说明同用户配置文件类似\n\n##### 2. 组密码文件\n文件位于<span class=\"tips\">/etc/gshadow</span>，密码文件书写格式为：\n<div class=\"show\"><span class=\"tips\">组名:组密码:组管理员用户名:组中的附加用户</span></div>\n配置如上,该文件不常用\n\n\n","tags":["Linux","command"]},{"title":"vim笔记","url":"/blog/2021/06/15/vim编辑器/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n第一次接触到vim时连字都不会打...后来在某管乱逛的时候看到两个Google的<del> 秃头 </del>工程师用vim花式结对编程时，vim就深深折服了我，那效率真是芜湖~，谁不想有个这样的<del> jiyou </del>普通朋友来次愉快的多线程交流呢<span  style=\"white-space: nowrap;\">๑乛◡乛๑</span>\n</div>\n\n### vi 与 vim 简介\n<span class=\"strong\">vi:</span>为 visual interface 的简称，是<span class=\"tips\">Linux</span>操作系统中最经典的文本编辑器。\n<p><span class=\"strong\">vim:</span>全称为vi improved，从vi 发展而来的文本编辑器，支持代码补全、编译、错误跳转等功能。在很多Linux发行版中，直接预装有vim编辑器，vim本身也发布了支持Windows、Unix、MacOS等不同操作系统的编辑器版本，并且很多优秀的IDE都有支持vim的插件，因此使用vim命令可以在各种操作系统环境下高效编辑代码/文本。</p>\n<p><span class=\"tips\">vim官方网站：<a href=\"https://www.vim.org/\" target=\"_blank\">https://www.vim.org/</a></span></p>\n<ul>\nvim的特点:\n<li>熟练掌握vim以后可以极大地提高编辑速率</li>\n<li>所有操作可以靠键盘完成，免去了键盘鼠标来回切换的时间</li>\n<li>甚至于在部分终端中不支持鼠标操作，无UI界面，所有操作靠命令</li>\n<li>无花里胡哨的排版功能，但有很多花里胡哨的的插件可以玩</li>\n<li>命令操作一切</li>\n<li>大多数服务器默认安装</li>\n</ul>\n\n### vim 的三种工作模式\n不同文档对命令、工作模式的翻译可能不同，不过在vim中操作是一样的\n##### 命令模式\n\n打开文件会首先进入命令模式，是 vim 使用的入口。该模式下可对文件内容进行基本的快捷操作，如：定位、翻页、复制、粘贴、删除等\n\n<p>在命令模式下输入<span class=\"tips\">i</span>进入编辑模式，进入编辑模式后按下<span class=\"tips\">esc</span>返回命令模式</p>\n<p>在命令模式下输入<span class=\"tips\">:</span>进入末行模式，进入末行模式后按下<span class=\"tips\">esc</span>返回命令模式</p>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n使用I、o、a等命令也可进入编辑模式，具体用法详见插入命令。</div>\n\n##### 末行模式\n在vim最底部输入命令的模式，也是vim 的出口，当要退出 vim 返回控制台时，需要在末行模式下输入命令。该模式下可对文件整体进行基本的操作，如：保存、退出、另存、搜索与替换等操作。\n<p>末行模式下输入<span class=\"tips\">wq</span>可快速保存并关闭文件</p>\n\n##### 编辑模式\n用于编辑文件具体内容的模式\n\n##### 此外\n还有<span class=\"tips\">可视模式</span>、<span class=\"tips\">替换模式</span>两个用于选取字符、替换内容等具体操作的模式\n\n### 基本命令\n#### 打开与新建文件\n<ul>\n<li><span class=\"strong\">vim 文件名</span> 打开/新建文件</li>\n<li><span class=\"strong\">vim 文件名 +行号</span> 打开文件并跳转到对应行号</li>\n<li><span class=\"strong\">vim 文件名 +</span>打开文件并跳转到文件末尾</li>\n<li><span class=\"strong\">vim 文件名1 文件名2 ... </span>同时打开多个文件</li>\n</ul>\n<p>使用命令时，若文件名对应的文件存在，则会用vim编辑器打开该文件，若文件不存在，则会新建一个文件。打开多个文件时，默认显示第一个文件，可以通过命令<span class=\"tips\">:ls</span>让vim列出所有打开的文件，使用<span class=\"tips\">:b数字</span>来使对应序号的文件显示在屏幕上。</p>\n\n#### 保存与退出(末行模式下)\n需要先切换到末行模式下，因此下述命令前的<span class=\"tips\"> : </span>号用于换到末行模式\n<ul>\n<li><span class=\"strong\">:w </span>保存</li>\n<li><span class=\"strong\">:w! </span>强制保存</li>\n<li><span class=\"strong\">:q </span>退出，如果没有保存则不允许退出</li>\n<li><span class=\"strong\">:q! </span>不保存，强制退出</li>\n<li><span class=\"strong\">:wq </span>保存并退出</li>\n<li><span class=\"strong\">:x </span>保存并退出</li>\n</ul>\n<p>更多末行模式下的命令在末行模式下的命令小节</p>\n\n#### 异常退出\n如果 vim 异常退出，会为当前编辑但尚未保存的文件创建一个后缀名为<span class=\"tips\">.swp</span>的<span class=\"tips\">交换文件</span>,该文件默认隐藏，下次打开未保存的文件会询问如何进行操作，可以根据vim提示选择恢复、直接编辑等操作。\n\n\n### 常用命令\n\n#### 移动光标与选取文本\n\n##### 上上下下左左右右 BABA\n\n<ul>\n<li><span class=\"strong\">h&emsp;&emsp;向左</span></li>\n<li><span class=\"strong\">j &emsp;&emsp;向下</span></li>\n<li><span class=\"strong\">k&emsp;&emsp;向上</span></li>\n<li><span class=\"strong\">l &emsp;&emsp;向右</span></li>\n</ul>\n\n##### 行内移动\n\n<ul>\n<li><span class=\"strong\">w&emsp;&emsp;移动到下一个单词开头</span>(word)</li>\n<li><span class=\"strong\">b &emsp;&emsp;向前移动一个单词</span>(back)</li>\n<li><span class=\"strong\">0 &emsp;&emsp;行首</span></li>\n<li><span class=\"strong\">^ &emsp;&emsp;行首，第一个不是空白的字符位置</span></li>\n<li><span class=\"strong\">$ &emsp;&emsp;行尾</span></li>\n<li><span class=\"strong\">g_ &emsp;&emsp;行尾,最后一个不是空白的字符位置</span></li>\n<li>&nbsp; e &emsp;&emsp;下一个单词结尾</li>\n<li>&nbsp; f字符&emsp;&emsp;下一个对应字符位置</li>\n<li>&nbsp; nf字符&emsp;&emsp;下n个对应字符位置</li>\n<li>&nbsp; F字符&emsp;&emsp;上一个对应字符位置</li>\n<li>&nbsp; nF字符&emsp;&emsp;上n个对应字符位置</li>\n<li>&nbsp; t字符&emsp;&emsp;下一个该字符的前一个字符位置</li>\n<li>&nbsp; nt字符&emsp;&emsp;下n个该字符的前一个字符位置</li>\n<li>&nbsp; T字符&emsp;&emsp;上一个该字符的后一个字符位置</li>\n<li>&nbsp; nT字符&emsp;&emsp;上n个字符的后一个字符位置</li>\n</ul>\n<p>当使用f、F、t、T关键字跳转时，使用 ; 可以快速跳转到下一个指定字符，使用 , 可以跳转到上一个指定字符。</p>\n\n##### 行间移动\n\n<ul>\n<li><span class=\"strong\">gg&emsp;&emsp;&emsp;&emsp;跳转到文件第一行行首</span></li>\n<li><span class=\"strong\">G &emsp;&emsp;&emsp;&emsp;&nbsp;跳转到文件最后一行行首</span></li>\n<li><span class=\"strong\">数字gg&emsp;&emsp;跳转到数字对应行数</span></li>\n<li><span class=\"strong\">数字G &emsp;&emsp;&nbsp;跳转到数字对应行的行首</span></li>\n<li><span class=\"strong\">: 数字 &emsp;&emsp;&emsp;跳转到数字对应行数</span></li>\n</ul>\n\n##### 屏幕内移动\n\n<ul>\n<li><span class=\"strong\">Ctrl+b&emsp;&emsp;&emsp;向上翻页</span>(back)</li>\n<li><span class=\"strong\">Ctrl+f &emsp;&emsp;&emsp;向下翻页</span>(forward)</li>\n<li><span class=\"strong\">H &emsp; &emsp;&emsp;&emsp;&emsp;当前屏幕第一行行首</span>(Head)</li>\n<li><span class=\"strong\">M&emsp; &emsp;&emsp;&emsp;&emsp;屏幕中间</span>(Middle)</li>\n<li><span class=\"strong\">L &emsp; &emsp; &emsp;&emsp;&emsp;屏幕底部</span>(Low)</li>\n<li><span class=\"strong\">zt &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕顶部</span></li>\n<li><span class=\"strong\">zz &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕中央</span></li>\n<li><span class=\"strong\">zb &emsp; &emsp;&emsp;&emsp;&emsp;把当前行移动到屏幕尾部</span></li>\n</ul>\n\n##### 段落切换\n\nvim 中以<span class=\"tips\">空白行</span>来区分段落，开发程序时将同一个功能相关的代码写在一起，不留空行。而在不同功能间留下空白行方便切换。\n\n<ul>\n<li><span class=\"strong\">{&emsp;&emsp;上一个段落</span></li>\n<li><span class=\"strong\">}&emsp;&emsp;下一个段落</span></li>\n</ul>\n\n##### 括号间切换\n用于在程序中出现频率很高的<span class=\"tips\">( )</span>、<span class=\"tips\">[ ]</span>、<span class=\"tips\">{ }</span>间切换，需要先把光标移动到其中一个括号上，然后使用%可切换到与其匹配的另外一边括号\n\n<ul>\n<li><span class=\"strong\">%&emsp;&emsp;括号匹配及切换</span></li>\n</ul>\n\n##### 添加标记与跳转\n在开发时，某段代码可能需要稍后处理，此时可用标记功能并在稍后快速跳转。\n<ul>\n<li><span class=\"strong\">m字母&emsp;&emsp; &emsp; &emsp;添加标记，字母可用a-z或A-Z间的任意字母</span>(mark)</li>\n<li><span class=\"strong\">' 标记的字母&emsp;&emsp;跳转到该字母标记的行首</span>(英文单引号)</li>\n<li><span class=\"strong\">`标记的字母&emsp;&emsp;跳转到该字母标记处</span>(esc下的撇号)</li>\n<li><span class=\"strong\">:marks&emsp;&emsp;列出所有标记</span></li>\n<li><span class=\"strong\">:delmarks 标记名 标记名....&emsp;&emsp;删除对应标记名</span>(可单个删除可多个删除)</li>\n<li><span class=\"strong\">:delmarks!&emsp;&emsp;删除所有小写字母标记</span></li>\n</ul>\n<p><span class=\"tips\">大写字母标记符可以实现文件间的跳转,因此大写字母通常用于文件间的标记</span></p>\n<p><span class=\"tips\">如果添加标记的行被删除，标记也将被删除。</span></p>\n<p><span class=\"tips\">如果其他行添加了同名标记，之前添加的标记将被替换掉。</span></p>\n\n##### 选中文本(可视模式)\n\n在命令模式下使用下列命令可切换到<span class=\"tips\">可视模式</span>，vim 有三种可视模式。\n\n<p>可视模式通过与光标移动命令搭配使用来选取文本，如：<span class=\"tips\">ggVG</span>可用于选中所有文本，选取的文本可通过<span class=\"tips\">esc</span>放弃选中并返回命令模式。</p>\n<ul>\n<li><span class=\"strong\">v(常规可视模式)&emsp;&emsp; &emsp;选中光标经过的所有文本</span></li>\n<li><span class=\"strong\">V(可视行模式)&emsp;&emsp;&emsp;&emsp;整行选中光标经过的所有文本</span></li>\n<li><span class=\"strong\">Ctrl+v(可视块模式)&emsp;&emsp;垂直方向选中文本</span>(类似于vscode的shift+Alt+鼠标点击，用于多行输入/删除)</li>\n</ul>\n\n#### 编辑命令\n\n##### 撤销与恢复撤销\n\n用于撤销错误的编辑操作，或者恢复撤销的命令,<span class=\"tips\">可用多次使用!</span>\n\n<ul>\n<li><span class=\"strong\">u&emsp;&emsp; &emsp; &emsp;撤销上一个命令</span>(undo)</li>\n<li><span class=\"strong\">Ctrl+r&emsp;&emsp;恢复撤销的命令</span>(redo)</li>\n</ul>\n\n##### 删除文本\n\n<ul>\n<li><span class=\"strong\">x&emsp; &emsp; &emsp; &emsp; &emsp;删除光标所在字符或选中的文本</span>(cut)</li>\n<li><span class=\"strong\">d移动命令&emsp;&emsp;删除移动命令对应的内容</span>(delete)</li>\n<li><span class=\"strong\">dd&emsp;&emsp;&emsp;&emsp; &emsp;删除光标所在行</span></li>\n<li><span class=\"strong\">D&emsp; &emsp; &emsp;&emsp; &emsp;删除光标至行尾间的内容</span></li>\n<li><span class=\"strong\">:n1,n2d&emsp;&emsp;&emsp;多行删除,n1为起始行号，n2为结束行号</span>(末行模式下)</li>\n</ul>\n<p>删除命令与移动命令的常用组合</p>\n<ul>\n<li>dw &emsp; &emsp;&emsp; 从光标位置删除到单词末尾</li>\n<li>dnw &emsp; &emsp;&emsp; 删除n个单词</li>\n<li>df字符 &emsp; &emsp;从光标处删除到下一个该字符处</li>\n<li>d$ &emsp; &emsp;&emsp; 删除光标到本行末尾</li>\n<li>d0 &emsp; &emsp; &emsp;从光标位置删除到该行起始位置(光标前该行的所有内容)</li>\n<li>d} &emsp; &emsp; &emsp; 从光标位置删除到段落结尾</li>\n<li>ndd &emsp; &emsp;&emsp;从光标位置向下连续删除 n 行</li>\n<li>d行号G &emsp;&emsp;删除光标所在行到指定代码行之间的所有内容</li>\n<li>d'标记符&emsp;&emsp;从光标所在行删除到标记符之间的所有代码</li>\n<li>dH &emsp; &emsp;&emsp; 删除屏幕第一行到光标所在行</li>\n<li>dG &emsp; &emsp;&emsp; 删除光标所在行到文件结束</li>\n</ul>\n\n##### 复制粘贴\nvim提供一个用于保存被复制、删除文本的缓冲区\n<p> <span class=\"tips\">复制</span>命令会将选中的文字保存在该缓冲区<p>\n<p> <span class=\"tips\">删除</span>命令会将删除内容保存在该缓冲区<p>\n<p> <span class=\"tips\">粘贴</span>命令会将缓冲区内容插入光标所在位置<p>\n<ul>\n<li><span class=\"strong\">y移动命令&emsp;&emsp;复制</span>(copy)</li>\n<li><span class=\"strong\">yy &emsp;&emsp;&emsp;&emsp;&emsp;复制一行,nyy会复制n行</span>(copy)</li>\n<li><span class=\"strong\">y$ &emsp;&emsp;&emsp;&emsp;&emsp;复制光标到本行结尾</span></li>\n<li><span class=\"strong\">yH &emsp;&emsp;&emsp;&emsp;&emsp;复制屏幕第一行到光标所在行</span></li>\n<li><span class=\"strong\">yG &emsp;&emsp;&emsp;&emsp;&emsp;复制光标所在行到文件结束</span></li>\n<li><span class=\"strong\">p &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之后</span>(paste)</li>\n<li><span class=\"strong\">P &emsp; &emsp;&emsp;&emsp;&emsp;粘贴于光标之前</span>(paste)</li>\n</ul>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\nvim中的文本缓冲区只有一个，后续做过复制、删除命令操作后，之前缓冲区中的内容会被替换</div>\n\n##### 输入替换(替换模式)\n<span class=\"tips\">r</span>命令用于轻量级修改,不需要进入替换模式\n<p><span class=\"tips\">R</span>可进入替换模式，修改完成后通过<span class=\"tips\">esc</span>返回命令模式</p>\n<ul>\n<li><span class=\"strong\">r &emsp;&emsp;替换当前字符</span>(replace)命令模式</li>\n<li><span class=\"strong\">R&emsp;&emsp;替换当前行光标后的所有字符</span>(replace)替换模式</li>\n</ul>\n\n##### 缩排和重复执行\n用于编排代码格式\n<ul>\n<li><span class=\"strong\">&gt;&gt; &emsp;&emsp;向右增加缩进</span>(增加4个空格)</li>\n<li><span class=\"strong\">&lt;&lt; &emsp;&emsp;向左减少缩进</span>(减少4个空格)</li>\n<li><span class=\"strong\"> . &emsp;&emsp;&emsp;重复上次命令</span></li>\n</ul>\n<p>在<span class=\"tips\">可视模式</span>下，缩排命令只需一个<span class=\"tips\">&gt;</span>、<span class=\"tips\">&lt;</span>即可。缩排一次后，用<span class=\"tips\"> . </span>命令执行多次缩排快速进行排版</p>\n\n##### 查找\n###### 1.指定字符查找\n<ul>\n<li><span class=\"strong\">/字符 &emsp;&emsp;查找指定的字符</span></li>\n</ul>\n<p>输入查找内容后回车，vim会高亮找到的内容，此时可使用<span class=\"tips\">n/N</span>命令跳转</p>\n<ul>\n<li><span class=\"strong\">n &emsp;&emsp;查找上一个</span>(next)</li>\n<li><span class=\"strong\">N &emsp;&emsp;查找下一个</span>(next)</li>\n</ul>\n\n###### 2.快速匹配单词\n<ul>\n<li><span class=\"strong\">* &emsp;&emsp;向后查找光标所在单词</span></li>\n<li><span class=\"strong\">N &emsp;&emsp;向前查找光标所在单词</span></li>\n</ul>\n<P></P>\n直接按上述键，vim会识别当前光标所在的单词，然后查找相同的单词\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\nvim会高亮显示查找到的内容，若想取消高亮显示，使用<span class=\"tips\">/字符</span>命令查找一个不存在的字符串将取消高亮显示。<span class=\"tips\">搜索支持正则表达式 !</span></div>\n\n##### 查找并替换\n替换指定的内容，vim中查找并替换命令需要在<span class=\"tips\">末行模式</span>下执行，语法组成为<span class=\"tips\">:作用范围s/替换内容/新内容/标识符</span>,标识符可由下列3类自由组成。\n<p><span class=\"tips\">i</span>表示大小写不敏感查找</p>\n<p><span class=\"tips\">I</span>表示大小写敏感查找</p>\n<p><span class=\"tips\">g</span>指定区域中找到的所有目标</p>\n<p><span class=\"tips\">c</span>替换前需确认</p>\n\n###### 1.仅替换第一个目标\n<ul>\n<li><span class=\"strong\">:s/替换内容/新内容&emsp;&emsp;仅替换当前行中的第一个目标内容</span></li>\n<li><span class=\"strong\">:%s/替换内容/新内容&emsp;&emsp;替换文件中所有行的第一个目标内容</span></li>\n</ul>\n\n###### 2.文件全局替换\n<ul>\n<li><span class=\"strong\">:%s/替换内容/新内容/g&emsp;&emsp;全局替换</span></li>\n</ul>\n一次性替换整个文件中的所有指定内容\n\n###### 3.局部替换\n<ul>\n<li><span class=\"strong\">:s/替换内容/新内容/g&emsp;&emsp;替换当前行中的所有目标内容</span></li>\n<li><span class=\"strong\">:行号1,行号2s/替换内容/新内容/g&emsp;&emsp;替换行号1到行号2之间的所有目标内容</span></li>\n</ul>\n\n###### 4.在选取内容中替换(可视模式下)\n只替换选中区域中的指定内容，需要在可视模式下先选中需要替换的区域，选取区域后输入<span class=\"tips\">:</span>,vim会自动补全为<span class=\"tips\">:'<,>'</span>，完整语法为:\n<ul>\n<li><span class=\"strong\">:'<,>'s/替换内容/新内容/g&emsp;&emsp;替换选择区域中的所有目标</span></li>\n</ul>\n\n###### 5.确认替换(使用标识符c时)\n进行替换操作时会依次询问每一个内容是否要替换，可依次选择每个目标是否替换然后退出，或执行全部替换。\n<ul>\n<li><span class=\"strong\">:s/替换内容/新内容/gc&emsp;&emsp;确认替换</span>(comfirm)</li>\n</ul>\n<p>确认/取消替换命令:</p>\n<ol>\n<li><span class=\"strong\">y&emsp;&emsp;替换</span>(yes)</li>\n<li><span class=\"strong\">n&emsp;&emsp;不替换</span>(no)</li>\n<li><span class=\"strong\">a&emsp;&emsp;替换所有</span>(all)</li>\n<li><span class=\"strong\">q&emsp;&emsp;退出替换</span>(quit)</li>\n<li> l &emsp;&emsp;最后一个，并把光标移动到行首(last)</li>\n<li>^E&emsp;&emsp;向下滚屏</li>\n<li>^Y&emsp;&emsp;向上滚屏</li>\n</ol>\n\n##### 插入命令\n用于进入编辑模式\n<ul>\n<li><span class=\"strong\">i&emsp;&emsp;在当前字符前插入文本</span>(insert)</li>\n<li><span class=\"strong\">I&emsp;&emsp;在行首插入文本</span>(insert)</li>\n<li><span class=\"strong\">a&emsp;&emsp;在当前字符后插入文本</span>(append)</li>\n<li><span class=\"strong\">A&emsp;&emsp;在行末插入文本</span>(append)</li>\n<li><span class=\"strong\">o&emsp;&emsp;在当前行后插入一个空行</span></li>\n<li><span class=\"strong\">O&emsp;&emsp;在当前行前插入一个空行</span></li>\n<li><span class=\"strong\">s&emsp;&emsp;删除光标所在字符然后插入文本</span></li>\n<li><span class=\"strong\">S&emsp;&emsp;删除光标所行然后插入文本</span></li>\n<li><span class=\"strong\">cw&emsp;&emsp;删除光标所在单词然后插入文本</span></li>\n</ul>\n\n##### 大小写转换\n<ul>\n<li><span class=\"strong\">~&emsp;&emsp;改变光标所在字母大小写</span></li>\n<li><span class=\"strong\">n~&emsp;&emsp;改变光标开始的n个字母大小写</span></li>\n<li><span class=\"strong\">g~~&emsp;&emsp;改变当前行字母大小写</span></li>\n<li><span class=\"strong\">gUU&emsp;&emsp;将当前行字母改成大写</span></li>\n<li><span class=\"strong\">guu&emsp;&emsp;将当前行字母改成小写</span></li>\n<li><span class=\"strong\">ngUU&emsp;&emsp;将光标所在行开始的后n行改成大写</span></li>\n<li><span class=\"strong\">gUw&emsp;&emsp;将光标所处单词改成大写</span></li>\n<li><span class=\"strong\">guw&emsp;&emsp;将光标所处单词改成小写</span></li>\n</ul>\n\n\n\n### 重复执行命令\n##### <span class=\"tips\">数字+命令的组合会让部分命令执行指定次数</span>\n\n\n<div class=\"code\">如：\n10x  删除光标后的10个字符\n10>>  让光标后的10行文本进行缩进\n10yy  复制10行内容</div>\n\n<div class=\"show\">如：输入10个相同的字符串\n执行步骤\n1. 在命令模式下输入10\n2. 输入i进入编辑模式\n3. 输入需要重复的字符串\n4. 输入完毕后esc返回命令模式，vim会把输入字符这个命令执行10次\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n以上原因，在进入编辑模式前，尽量不要触碰数字，否则可能导致命令的重复执行</div>\n\n##### <span class=\"tips\">执行某个命令后使用 . 号可重复执行该命令</span>\n<div class=\"code\">如：\ndd 删除光标当前所在行后\n之后每使用一次 . 会删除一行</div>\n\n##### 运用举例\n\n<div class=\"show\">利用可视块将多行文本改为注释(注释符号为:#)\n执行步骤\n1. 移动光标到要添加注释的第一行代码，使用^定位到行首\n2. 使用Ctrl+v进入可视块模式\n3. 使用I进入编辑模式,并输入#。注：可视块模式下使用i插入无效\n4. 输入完毕后esc返回命令模式，vim会把选中的每一行文本前都插入#\n</div>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\">注意</div>\n重复执行只对部分命令有效，而对如 u(撤销)命令无效，vim依旧会重复执行u 命令前执行的命令。</div>\n\n### 末行模式下的命令\n#### 文件操作\n末行命令主要用于文件的保存、退出、搜索与替换，以及浏览、新建、另存文件等操作\n<ul>\n<li><span class=\"strong\">:e.&emsp;&emsp;打开内置文件浏览器，浏览当前目录下的文件</span></li>\n<li><span class=\"strong\">:e 文件名&emsp;&emsp;打开另外一个文件并切换到其中</span>(edit)</li>\n<li><span class=\"strong\">:e!&emsp;&emsp;放弃对所有文件的修改，恢复文件到上次保存的位置</span></li>\n<li><span class=\"strong\">:n 文件名&emsp;&emsp;新建文件</span>(new)</li>\n<li><span class=\"strong\">:w 文件名&emsp;&emsp;保存当前文件修改到对应文件中(没有时会新建)</span>(write)</li>\n<li><span class=\"strong\">:saveas 文件名 &emsp;另存为新文件</span></li>\n<li><span class=\"strong\">:bn&emsp;切换到上一个文件</span>(打开多个文件时)</li>\n<li><span class=\"strong\">:bp&emsp;切换到下一个文件</span>(打开多个文件时)</li>\n</ul>\n<p>切换文件时若当前文件未保存时不能切换，但可用!强制执行。文件另存为操作不会将编辑界面跳转到新另存的文件里，依旧会在当前文件编辑界面中。</p>\n<p>输入文件名时，输入部分文件名后按下<span class=\"tips\">Tab</span>键，vim会提示文件名</p>\n\n#### 设置\n<ul>\n<li><span class=\"strong\">:set nu&emsp;&emsp;显示行号</span></li>\n<li><span class=\"strong\">:set nonu&emsp;&emsp;取消行号显示</span></li>\n<li><span class=\"strong\">:数字&emsp;&emsp;定位到对应的行</span></li>\n<li><span class=\"strong\">:set ic&emsp;&emsp;不区分大小写</span></li>\n<li><span class=\"strong\">:set noic&emsp;&emsp;区分大小写</span></li>\n</ul>\n\n\n### 分屏命令\n#### 分屏打开多个文件\n<ul>\n<li><span class=\"strong\">vim -On 文件名1 文件名2 ...&emsp;&emsp;横向分屏打开文件，从左到右依次显示</span></li>\n<li><span class=\"strong\">vim -on 文件名1 文件名2 ...&emsp;&emsp;竖向分屏打开文件，从上到下依次显示</span></li>\n</ul>\n\n#### 拆分当前屏幕\n方便同时编辑、浏览多个文件\n<ul>\n<li><span class=\"strong\">:sp [文件名]&emsp;&emsp;增加横向分屏</span>(split)</li>\n<li><span class=\"strong\">:vsp [文件名]&emsp;&emsp;增加竖向分屏</span>(vertical split)</li>\n</ul>\n<p>可以不跟文件名，当无文件名时分屏命令会将当前文件也显示在分屏上。输入文件名忘记全称时，使用<span class=\"tips\">Tab</span>键，vim会提示文件名</p>\n<p>上述命令不添加文件名时，功能同如下两个命令，但下面两个命令使用前需先执行<span class=\"tips\">Ctrl+w</span>命令</p>\n<ul>\n<li>s&emsp;&emsp;上下屏幕同时显示当前文件</li>\n<li>v&emsp;&emsp;左右屏幕同时显示当前文件</li>\n</ul>\n\n#### 切换分屏窗口\n切换分屏窗口都是基于<span class=\"tips\">Ctrl+w</span>命令，使用下述命令前都要先执行该命令。\n##### 光标在分屏窗口中切换\n<ul>\n<li><span class=\"strong\">w&emsp;&emsp;按顺序切换到下一个窗口</span>(window)(从上到下从左到右)</li>\n<li><span class=\"strong\">W&emsp;&emsp;逆顺序切换到下一个窗口</span>(window)(从下到上从右到左)</li>\n<li><span class=\"strong\">h&emsp;&emsp;切换到左边的窗口</span></li>\n<li><span class=\"strong\">l&emsp;&emsp;切换到右边的窗口</span></li>\n<li><span class=\"strong\">j&emsp;&emsp;切换到下面的窗口</span></li>\n<li><span class=\"strong\">k&emsp;&emsp;切换到上面的窗口</span></li>\n</ul>\n\n##### 移动分屏窗口\n<ul>\n<li><span class=\"strong\">r&emsp;&emsp;按顺序互换窗口</span>(reverse)</li>\n<li><span class=\"strong\">R&emsp;&emsp;逆顺序互换窗口</span>(reverse)</li>\n<li><span class=\"strong\">H&emsp;&emsp;将当前分屏移动到左边</span></li>\n<li><span class=\"strong\">L&emsp;&emsp;将当前分屏移动到右边</span></li>\n<li><span class=\"strong\">J&emsp;&emsp;关将当前分屏移动到下面</span></li>\n<li><span class=\"strong\">K&emsp;&emsp;将当前分屏移动到上面</span></li>\n</ul>\n<p>以从上到下的窗口分布为例，将7个窗口比作7个楼层，按顺序互换窗口指顶楼7楼变6楼，6楼变5楼，依次往下，而1楼移动到7楼变成顶楼。而当4楼还分割了左右多个窗口时，无法将窗口上下移动，使用命令vim报错。但仍可以将光标切换到4楼以后，在4楼内部移动4楼分割的左右窗口。</p>\n<p>窗口左右分布时类似，窗口可以在左右间移动，而某个窗口内部还分割了上下窗口时，使用命令报错。逆顺序类似，移动方向相反。</p>\n\n##### 关闭分屏\n<ul>\n<li><span class=\"strong\">c&emsp;&emsp;关闭当前窗口，只剩一个时无法使用</span>(close)</li>\n<li><span class=\"strong\">q&emsp;&emsp;关闭当前窗口，只剩一个时退出vim</span>(quit)</li>\n<li><span class=\"strong\">o&emsp;&emsp;关闭其他窗口</span>(other)</li>\n</ul>\n\n### 标签(tab)\n标签类似于在浏览器中打开多个网页,会在窗口顶部列出各个标签,标签相当于一个vim\n<ul>\n<li><span class=\"strong\">:tabnew [标签名]&emsp;&emsp;创建一个对应名字的新标签</span>(标签名省略时创建一个无名标签)</li>\n<li><span class=\"strong\">:tabc&emsp;&emsp;关闭当前标签</span></li>\n<li><span class=\"strong\">:tabn&emsp;&emsp;切换到下一个标签</span></li>\n<li><span class=\"strong\">:tabp&emsp;&emsp;切换到上一个标签</span></li>\n<li><span class=\"strong\">:tabs&emsp;&emsp;查看一共有几个标签</span></li>\n<li><span class=\"strong\">gt&emsp;&emsp;依次在标签间切换</span>(在命令模式下)</li>\n<li><span class=\"strong\">数字gt&emsp;&emsp;切换到对应顺序的标签中</span></li>\n</ul>\n\n\n### 执行Linux命令\n<ul>\n<li><span class=\"strong\">:!Linux命令&emsp;&emsp;让vim执行Linux命令</span>(执行完Enter会返回文件)</li>\n<li><span class=\"strong\">:r&nbsp;!Linux命令&emsp;&emsp;让vim执行Linux命令并添加执行结果到光标处</span></li>\n</ul>\n\n### 定义字符串快捷输入(ab)\n用于需要频繁输入某个长字符串时，使用一个较短的字符串快速打出该长字符串\n<ul>\n<li><span class=\"strong\">:ab 短字符 长字符串&emsp;&emsp;定义一个长字符串快捷输入</span></li>\n</ul>\n<div class=\"show\" style=\"word-break: break-all;\"><code>如：当需要频繁输入邮箱时，可以用一个短字符串定义邮箱地址\n:ab gmail sheiyoubingbayouxiangxiezhemechang@Gmail.com\n之后只需输入gmail空格或者回车，vim会自动补全该长字符串</code></div>\n\n### 使用寄存器\n使用复制粘贴时，vim是将内容缓存在寄存器中。用户可以自定义寄存器，vim中使用<span class=\"tips\">\"字母</span>来定义一个该字母(大小写均可)命名的寄存器，寄存器后往往加上具体命令，空定义寄存器无效。\n<ul>\n<li><span class=\"strong\">\"字母yy&emsp;&emsp;复制当前行到该寄存器中</span></li>\n<li><span class=\"strong\">\"字母p&emsp;&emsp;从该寄存器中取出内容并粘贴</span></li>\n<li><span class=\"strong\">:reg&emsp;&emsp;列出所有寄存器</span></li>\n<li><span class=\"strong\">:reg 字母&emsp;&emsp;查看对应寄存器中内容</span></li>\n<li><span class=\"strong\">“”&emsp;&emsp;定义一个无名寄存器</span>(使用复制粘贴时vim启用的是该寄存器)</li>\n</ul>\n\n### 定义快捷键\n自定义一个用于某个操作的快捷键\n<ul>\n<li><span class=\"strong\">:map key value&emsp;&emsp;使用快捷键key快速执行value的步骤</span></li>\n</ul>\n快捷键通常使用<span class=\"tips\">Ctrl+某个不冲突的按键</span>，而定义时该组合按键时需要通过<span class=\"tips\">Ctrl+v+该按键</span>来输入\n\n<div class=\"show\" style=\"word-break: break-all;\"><code>如：将某行代码注释掉\n输入的命令为 :map Ctrl+v+/ I#&lt;esc&gt;\n命令就会定义Ctrl+/为快捷键,执行的操作为:在行首插入(I的功能)#号,然后esc退出编辑模式,即以后只需要按下Ctrl+/就可以在当前行首插入#号把当前行注释掉(同vscode里的注释快捷键)</code></div>\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n:map 命令的应用很广</div>\n\n### 结语\nvim还有其他诸如宏定义、运用插件等能显著提升效率和编程体验的功能，再展开文章就显得有点冗长了，边写边设计样式人麻了，文中可能存在错误。","tags":["Linux","vim"]},{"title":"听歌软件推荐-Spotify","url":"/blog/2021/06/01/spotify推荐/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\nSpotify官方信息可能随时会变化，本文部分信息可能过时，请以官方信息为准，但是注册、使用步骤都是大同小异的</div>\n<h3>关于Spotify</h3>\n<p>Spotify创立于瑞典，是目前全球最大的在线音乐流服务商,得到了华纳音乐集团、环球音乐集团、索尼音乐娱乐、Kakao M和腾讯音乐娱乐集团等唱片公司的合作授权，所以曲库非常齐全。Spotify暂未进入中国大陆市场，不过不妨碍软件的正常使用。</p>\n<h3>与国内音乐软件比对</h3>\n<p>先来说说Spotify的优点吧</p>\n<h5>1. 齐全的曲库</h5>\n<p>国内的歌很容易出现版权被某家平台买断的情况，想听喜欢的歌可能得好几个平台才能找齐，听歌时还得好几个APP切来切去，甚至要在好几个平台开VIP。平台自己的恶性竞争还要消费者来买单，这能惯着他们？\n另外一方面，国内的音乐也很容易出现被人恶意举报而惨遭下架的情况。比如说嘻哈音乐，在diss某些流量idol后，会出现被其粉丝恶意举报后惨遭下架的情况。\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n“DISS不过是种切磋但那些明星雇佣的水军总想方设法要把对方逼死”</div>\n<p>对于Spotify就不存在这个问题了，很多国内下架的专辑你仍然可以在Spotify上找到，拥有极为齐全的版权和曲库。如果你是嘻哈音乐，欧美音乐爱好者，Spotify绝对不会让你失望。当然，Spotify本身没有进入大陆市场，很多小众的华语音乐还是只能在国内APP上找到。</p>\n<h5>2. 开通Premium后就不用再买专辑</h5>\n<p>Premium相当于开通Spotify的VIP，国内在开通VIP后，很多专辑还需要单独付费购买才能听，在Spotify中无需再购买专辑，专辑费用不用额外出了。</p>\n<h5>3. 优秀的音乐推荐算法</h5>\n<p>Spotify的音乐推荐算法也是网上经常被人称赞的闪光点，它会定期制作made for you歌单推荐音乐，国内的音乐软件也有类似的功能，但国内的推荐老会有奇奇怪怪的歌混在里面，感觉Spotify的推荐算法更精准点。</p>\n<h5>4. 支持手机端和PC端相互操控</h5>\n<p>当使用电脑听歌时，打开手机端的Spotify会同步电脑端的状态，反过来也如此。你可以使用手机来控制电脑端进行切歌，调节音量等操作，有些鸡肋，可能我没学会正确的打开方式......在家搞家务使用电脑的音箱外放时，就不用跑到电脑面前切歌了。</p>\n<h5>5. 没有乱七八糟的直播、短视频推送</h5>\n<p>作为音乐软件，Spotify拥有的就是安安静静听歌，没有什么直播、小视频、商店等乱七八糟的功能，也不会有那些乱七八糟的主播推荐。不过不开VIP的话每隔15分钟会推送一次广告，这个后面详细说付费和免费的区别。</p>\n<h5>6. 舒适的UI界面</h5>\n<p>不得不说，歪果仁对于UI设计、无障碍设计还是很有心得的，Spotify的界面用的是真的很舒服。</p>\n<h6>其他优点自己去体验一下吧，接下来再说说用惯了国内的软件可能会觉得不习惯的点</h6>\n<h5>1. 部分地区不支持显示歌词</h5>\n<p>日区、港区可以显示歌词，但是美区账号没有歌词显示功能，只能借助Musixmatch、LyricsX等软件，Musixmatch会自动识别Spotify当前播放的音乐自动匹配歌词。Musixmatch本身是免费的，付费版支持更多花里胡哨的歌词显示方式，1美元可以永久解锁付费版。</p>\n<h5>2. 不支持评论</h5>\n<p>不能到点上号开哭了。</p>\n<h5>3. 注册、登录账号时需要魔法工具加持</h5>\n<p>Spotify没有进入大陆市场，而且注册账号时官方使用的是谷歌的人机验证，而国内的网络无法加载谷歌的服务，所以注册账号的时候会有点麻烦，但注册完以后听歌是全程可以用国内的网络环境的。</p>\n<h5>4. 官方开通Premium贵</h5>\n<p>印度、菲律宾等东南亚区的账号开通Premium比较便宜，美区账号每个月的费用是$9.99美刀，折合人民币大约64.4元每个月，情侣套餐包含两个账号12.99美元一个月，折合人民币83.7元一个月，一个账号就是42块左右，家庭组包含6个账号15.99美元每个月，折合人民币103元每个月，一个账号均摊下来17块左右，另外有学生套餐，但是天朝的学生不能用。这价格相较于国内的平台来说就有点贵了。</p>\n<p>所以很多人一般都是开通的东南亚国家的Premium，开通美区账号一般都是组队开家庭组。</p>\n<h3>注册与使用</h3>\n\n<h5>1. 注册账号</h5>\n<p>因为Spotify没有进入大陆的市场，所以注册时需要魔法工具，如果不使用魔法工具当他检测到你的IP地址是来源于中国大陆，就会提示<span class=\"tips\"> \"Spotify is currently not available in your country\"</span>，所以需要魔法将我们的IP地址伪装成其他地区，国内香港、澳门、台湾都行，国外随便一个国家都行。</p>\n<p>传送过去后，登录Spotify的官网 <a href=\"https://www.spotify.com\" target=\"_blank\">https://www.spotify.com</a>，然后点右上角的Log in，然后点击注册一个账号，填写邮箱、密码、用户名、生日等信息(生日可以乱填但记得填18岁以上，不然有些带脏标的歌会听不了)，填完有个google的reCAPTCHA人机验证，这个服务的域名在国内是被墙的，同样需要魔法工具才能打开。网上好像也有不需要魔法工具就能打开reCAPTCHA的教程，我没自己试过，不知道在Spotify里有没有效，没有魔法工具的找身边有的人帮忙注册一下。去Spotify的贴吧、豆瓣小组好像有好心人帮人免费注册，但注意防骗，要钱的就不要理了。最省事的方法就是某宝某多买个号(基本上去他们那里买Premium就会送号)，然后改邮箱就行，注意防骗！！！！！</p>\n<p>注册后官方会发一封邮件验证邮箱,点一下<span class=\"tips\"> CONFIRM YOUR ACCOUNT </span>完成认证即可，注册完的账号有7天体验期可以任意听歌、切歌。</p>\n<p>在使用魔法工具时，有些魔法工具会被提示Spotify检测到正在使用代理工具，要求关闭代理再进行操作。这估计是以前有哪个憨皮拿这个IP批量注册过Spotify账号，IP被官方记录了，把工具切换到全局模式再试试，或者把广播IP地址换成原生IP，如果还是不行那只能换个IP了。</p>\n<h5>2. 分区</h5>\n<p>Spotify为全球很多国家和地区提供服务，所以他的账号是分区的，国内常用的区域有美区、日区、港区、菲律宾区、俄区、马来西亚、印度的一些东南亚的区,账户区域不同，曲库内容、歌单、界面UI、付费价格也不同。</p>\n<p>注册账号时，如果挂的美国的代理，就会进美区的官网，其他同理。具体进了什么区看页面语言，或者地址栏URL路径就可以了，如美区URL为：\n<div class=\"code\">https://www.spotify.com/us/</div>\n<p>但这个后期可以改的，所以注册时哪个区都无所谓，但是买Premium时，买完就不能改了，所以想好买哪个区的Premium，给个常用的几个区对比：</p>\n</p>\n<ul>\n<li><h6>曲库</h6>\n美区的曲库相对较全，但如果喜欢ACG音乐、日语歌那肯定去日区，其他同理。但Spotify的曲库判定有点迷，有些日语歌或者韩语歌你无法在日区找到，但是美区或其他区却有，不过这毕竟还是少数。\n</li>\n<li><h6>歌词</h6>\n美区是没有歌词的，得借助其他软件，日区、港区、俄区还有一些东南亚区有歌词。</li>\n<li><h6>订阅价格</h6>\n下面是部分区折算成人民币后的价格，一般东南亚区的比较便宜\n <div class=\"table\">\n    <table>\n        <thead>\n            <tr>\n                <th>区</th>\n                <th>个人</th>\n                <th>家庭组(6个账号)</th>\n            </tr>\n        </thead>\n        <tbody>\n          <tr>\n              <td>香港</td>\n              <td>51元</td>\n              <td>77.5元</td>\n          </tr>  \n          <tr>\n            <td>美区</td>\n            <td>65元</td>\n            <td>102.5元</td>\n        </tr>\n        <tr>\n            <td>日区</td>\n            <td>63元</td>\n            <td>95元</td>\n        </tr>\n        <tr>\n            <td>菲律宾</td>\n            <td>17元</td>\n            <td>26元</td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n\n   <div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n仅作参考，实际价格以Spotify官网发布的价格为准</div>\n</li>\n</ul>\n<h5>2. 关于Premium</h5>\n<p>即付费版，新注册的账号有7天的付费版体验期。如果第一次开Premium则会送一个月的体验期，免费版和付费版的区别在于\n<ul>\n<li>手机端免费版只能随机播放，而且只能切6次歌，即你不能想听啥就点啥听，只能听它随机播放的，听一半不想听了想点下一曲只有6次机会，6次以后就只能等它放完(不知道那个天才想出来的设定，真想给他寄点土特产)，网页版和PC端的好一点，能切歌但只能随机播放(老式收音机)，付费版可以任意播放、切换歌</li>\n<li>免费版在听歌过程中会有广告，付费版没有</li>\n<li>音质有区别，免费版比特率在160kbit/s，付费版的比特率在320kbit/s</li>\n</ul></p>\n<h5>3. 开通Premium的小tips</h5>\n<p>直接开个人账号太贵了，常见的方法就是去贴吧、豆瓣小组找人一起开家庭组，这里常年会有车队等着拉人，注意防骗！！！因为一个家庭组里有一个管理员账号，他可以随时把家庭成员踢出去，交了钱隔天就被踢很常见。要是周围用的人多，熟人约好几个人一起开稳妥一点。</p>\n<p>还有一个方法就是去某宝续费，注册有问题的也可以直接在他们手上买号，然后把邮箱换成自己的，同样要注意防骗问题。费用大概是15、20块三个月这样，每家店都不一样。</p>\n<div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n一定要去开店年份较高，回头客多的店铺买，开店时间短、评论没几个那种很有可能是以前跑路了，开家新店铺再来割一波韭菜，指不定哪天就找不到店家了</div>\n<h5>4. 踩过的坑</h5>\n<p>某宝的方法也是拉家庭组，然后利用绑信用卡免费1个月等官方优惠赚取差价。但是经常会遇到你买完以后没几个星期就把你踢出家庭组，然后商家跑路，连店铺都找不到那种.....所以在某宝续费，要选那些开店年份长的的店铺，至少说明人家不跑路。</p>\n<p>跑路的最坏结果就是，如果你多次买了家庭组，然后被踢，又买再被踢，官方检测到你的账号短期内加入了众多不同的家庭组，可能会被封禁。并且有些店家的家庭组，是盗取了国外的账号然后拉你进家庭组，一旦国外的号主发现了，向官方反馈后可能直接会被封禁。\n我的上一个账号就是在某宝续费之后，某天登录时提示无效的账户，去某宝看店家已经跑路了，汤都没留一口.......找Spotify客服客服表示需要提供付费账单才能提供帮助......可是我的付费都付给了某个天萨的卖家，哪有什么账单.......无奈只能放弃那个账号了，可惜了收藏多年的广场舞神曲。。</p>\n\n### 总结\n注册：\n1.自己有魔法工具自己注册；\n2.没有魔法工具就去贴吧、豆瓣看看能不能找人帮忙注册；\n3.或直接去某宝、某多直接买Premium让店家帮忙注册；\n4.都不行可以写邮件给我，让我看看是谁这么笨；\n可以先注册用一个星期体验一下，spotify有一个星期的新号体验期，觉得好用再去某宝开Premium或去贴吧、豆瓣找人合作开家庭组。\n<div class=\"broadcast color-purple\">\n<div class=\"iconfont icon-fengche\"></div>\n注册或者使用中有啥问题，可以去Spotify贴吧，或者去豆瓣小组找找攻略，需要帮忙可以给我写邮件</div>\n","tags":["life","Music"]},{"title":"一款毫米波不等分功分器","url":"/blog/2021/05/29/5G功分器/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n和普通的微波器件相比，5G通讯系统中微波器件的结构参数都是毫米级的，改一点点模型参数结果就完全不一样了，带宽又难做大，每一个参数需要重复优化很久才能满足5G通信的需求。\n</div>\n\n### 5G通讯系统\n现在有越来越多的数字终端接入到移动网络中，比如手机、平板、车载AI、远程监控设备等等，全球对移动通信的需求和要求也越来越高了。为了满足未来的更多需求，5G通讯系统中，毫米波成为了传输高质量数据流的主要载体，毫米波频段在30GHz到300GHz之间，世界无线电通信大会提议使用24GHz—86GHz之间的频段作为5G通信频率。\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n数据来源：Hidayat Ullah. Further Notice of Proposed Rulemaking in the Matter of Use of Spectrum Bands Above 24 GHz for Mobile Radio Services [C]. Int. Telecommun. Union-Radiocom Sector. 2016.</div>\n<p>但是，毫米波能实现高速率传输带来的代价就是，由于其频率高、波长短等特性，其对应的微波器件尺寸很小，微小的尺寸差异都会为通信系统带来巨大影响，因此用在毫米波通讯系统中的器件对设计要求和加工工艺要求都很高。并且，毫米波在传播过程中损耗很大，信号衰减较快，并且易受阻挡，地形、建筑物、丛林甚至于雨水都会使毫米波的传输产生很大的衰减，因此5G天线的设计既要有大带宽保证通讯速率，还要有高增益保证毫米波的有效传输，并满足其他电参数性能。如此苛刻的要求，单独的天线单元往往是做不到的，现实生活中通讯系统中的天线往往由天线阵列组成。一款5G手机中的天线数量往往多达十多根，用于负责蓝牙、WLAN、NFC、2-5G等不同频段的通讯，而负责5G通讯的天线也往往是一组天线阵列，将手机信号传输到天线阵列就需要用到功分器的设计了。</p>\n\n### 功分器\n功分器是一种主要用于无线电技术领域的无源设备，在微波、射频电路中，有时需要将功率按一定的比例分成两路或多路输出，此时就需要用功率分配器来实现。功率分配器的技术指标主要包括工作频率范围、分配损耗、插入损耗、隔离度等，这几个常用参数的大致定义如下：\n\n<span class=\"strong\">分配损耗：</span>定义P<sub>in</sub>为功分器的输入功率，P<sub>out</sub>为功分器某一输出端口的输出功率，则该端口的分配损耗为:\n<div class=\"formula\">A<sub>d</sub>=10 lg(P<sub>in</sub>/P<sub>out</sub>)</div>\n<p><span class=\"strong\">插入损耗：</span>由输入端驻波比带来的损耗，一般是由于微带线导体介质不理想等因素造成的，设实际测量值为A，则插入损耗A<sub>i</sub>为:</p>\n<div class=\"formula\">A<sub>i</sub>=A-A<sub>d</sub></div>\n<p><span class=\"strong\">隔离度：</span>一般情况下，若信号从支路端口的输入，应当从主路端口输出，若大部分能量能从主路端口输出出来，说明功分器的隔离度较好。i端口与j端口的隔离度定义为：</p>\n<div class=\"formula\">A<sub>ij</sub>=10 lg(P<sub>ini</sub>/P<sub>outj</sub>)</div>\n<p><span class=\"strong\">驻波比：</span>电压驻波比指驻波波腹电压与波节电压幅度之比，又称为驻波系数。当驻波比等于1时，表明端口输入输出阻抗匹配，此时高频能量完全输入到了电路中，没有能量的反射损耗，一般为理想情况，实际的驻波比应尽量接近1。</p>\n\n### 威尔金森功分器\n在微波电路中，阻抗不匹配会导致信号反射，反射的信号会干扰其他正常信号的传输，比如1端口的信号会反射到2端口来，影响2端口的信号传输，衡量这一现象的参数是上面提到的隔离度，1-2端口隔离度越好，说明这个两个端口越不容易相互干扰。一般的功分器结构隔离度有可能不太理想，而威尔金森功分器就是为了解决这一问题而设计出来的，功率分配器可由不同的元件组合成不同的形式，威尔金森功分器的原始模型是同轴线形式，因具有良好的隔离度在微带和带状线结构上得到了广泛应用，如下为两路威尔金森功分器示意图：\n\n<img data-src=\"/blog/images/wilkinson.jpg\" src=\"#\" tlt=\"威尔金森功分器\" title=\"威尔金森功分器\">\n<p>威尔金森功分器的设计需要借助微带线尺寸计算工具，根据功分器各部分阻抗值计算各部分的结构尺寸。多路功率分配器的设计，可以直接设计为多路输出，也可以采用两路功率分配器的级联形式，即一分二，二分四……上下两级的功分器之间一般需要加上阻抗匹配元件。</p>\n\n### C语言计算威尔金森功分器尺寸\n对于规模较大的天线阵列，往往需要使用多路威尔金森功分器。为了保证通讯系统的稳定性，阵列的带宽、增益、主瓣宽度、副瓣电平等电性能参数都要满足一定的指标，因此阵列往往需要切比雪夫等算法加持，由此设计出来的激励分布往往也是不等分的，因此相应的功分器分配比也要是不等分的，再使用两路功率分配器的级联形式，组合成功分器网络。\n<p>根据功率分配比计算阻抗的过程需要重复用到威尔金森(Wiljinson)功率分配器的设计步骤和计算过程，计算过程繁杂且容易出错，借助C语言来简化这个过程。</p>\n<pre><code class=\"hljs language-c\">#include&lt;stdio.h&gt;\n#include&lt;float.h&gt;\n#include&lt;math.h&gt;\n#define Z0 50//输入阻抗\ntypedef struct design {\n\tfloat ants[8];//阵列\n\tstruct data {//介质板参数\n\t\tfloat Er;\n\t\tfloat Mur;\n\t\tfloat H;\n\t\tfloat Hu;\n\t\tfloat T;\n\t\tfloat TanD;\n\t};\n }antenna;\n int main(void) {\n\tantenna Yagi;\n\tYagi.Er = 2.2;\n\tYagi.Mur = 1;\n\tYagi.H = 0.254;\n\tfloat num1, num2,k2,k3,result1,z02,z03,R;\n loop:printf(\"输入功率分配比:\\n\");\n\tprintf(\"p1值：\");\n\tscanf_s(\"%f\", &num1);\n\tprintf(\"p2值：\");\n\tscanf_s(\"%f\", &num2);\n\tprintf(\"验算过程：\\n\");\n\tprintf(\"--------------\\n\");\n\tprintf(\"功率分配比：  %.2f:%.2f\\n\", num1, num2);\n\tk2 = num2 / num1;\n\tprintf(\"k方值为:%f\\n\", k2);\n\tresult1 = 1 + k2;\n\tprintf(\"非归一化比值为:%f\\n\", result1);\n\tk3 = (float)pow(k2, 1.5);\n\tprintf(\"非归一化比值验算分母:%f\\n\", k3);\n\tprintf(\"开根:%f\\n\", result1/k3);\n\tz03= (float)(pow(result1 / k3,0.5)) * Z0;\n\tz02= (float)(pow(pow(k2, 0.5) * result1, 0.5)) * Z0;\n\tR = result1 / pow(k2, 0.5) * Z0;\n\tprintf(\"--------------\\n\");\n\tprintf(\"计算得的阻抗值为\\n\");\n\tprintf(\"Z03=%.2fΩ  Z02=%.2fΩ\\n\", z03, z02);\n\tprintf(\"隔离电阻:\");\n\tprintf(\"R=%.2fΩ\\n\", R);\n\tprintf(\"**************************************\\n\");\n\tgoto loop;\n\treturn 0;\n }\n    </code></pre>\n<p>由代码可分别计算出每一级功分器支节的阻抗值与输出端口的输出阻抗，而由阻抗值借助微波仿真软件的微带线尺寸计算工具，可以计算出各级功分器的结构参数，但该结构参数仅作为初始数据，根据初始参数所建模型的仿真测试结果往往和预期目标相差巨大，需要利用仿真软件进行多次迭代优化。为了和阵列结构相匹配，功分器网络的结构需要进行拐角、切角等处理，整体设计完的功分器网络可能长这样</p>\n<img data-src=\"/blog/images/wilkin.jpg\" src=\"#\" alt=\"不等分功分器馈电网络\">\n<p>经过上百次的迭代优化后，利用微波仿真软件查看功分器馈电网络各输出端口的相位，低频时输出端口的相位基本保持一致，高频时会产生部分频偏，但相位偏移不大，并且该部分已经超出天线的有效带宽范围，因此基本能保证功分器输出端口的同相输出。</p>\n<img data-src=\"/blog/images/phase.jpg\" alt=\"相位差\" src=\"#\">\n<p>由于威尔金森功分器加装了隔离电阻，能很好保证各端口间的隔离度基本保持在-15dB以下，所以能确保器件工作时各端口间微波信号的反射干扰不会影响天线阵列的正常工作。</p>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\n当初做这个设计的时候，我的一个博士生学长和指导老师都给了我很多帮助，查了很多资料，最后也获得了很不错的成果。\n</div>","tags":["硬件","RF"]},{"title":"正则表达式","url":"/blog/2021/04/13/正则表达式/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n文中所声明对象和语法基于Java和JavaScript</div>\n\n### 正则表达式\n正则表达式，又称为规则表达式（Regular Expression，在代码中常简写为regex、regexp或RE），用于描述字符串的某种特殊规则，它可以用来检测某个字符串是否满足该规则，或对符合该规则的字符串进行提取、删除、替换等操作。\n##### 常见的运用\n<ul>\n<li>设置密码时：\"请至少设置8位以上且同时包含数字、大小写字母和特殊字符\"(限制用户所输入字符串的复杂度以提高密码强度)</li>\n<li>从爬虫中提取有效手机号、邮箱号等有效信息</li>\n<li>.........</li>\n</ul>\n\n\n### 语法\n#### 方括号 [ ]\n方括号用于查找某个范围内的字符，括号内内容是<span class=\"tips\">或</span>的关系\n<div class=\"show\"><code>[a-z]   是否含有任意的小写字母\n[A-Z]   是否含有任意的大写字母\n[A-z]   是否含有任意字母\n[0-9]   任意数字\na[bde]c 检查是否含有abc或adc或aec</code>\n</div>\n\n\n#### 与(&&)、或(|)、非(^)\n逻辑运算符\n##### 与 &&\n单个的<span class=\"tips\">&</span>代表检测字符串中是否含有 \"&\" 这个符号，短路运算符<span class=\"tips\">&&</span>才是将前后两个表达式做与运算\n<div class=\"show\"><code>[a-z&&[def]]  仅匹配d或e或f字符\n[a-z&[def]]  匹配a-z和&字符\n[a-z&&[^m-p]]  a-z且不包含m-p的集合(等同于[a-lq-z])\n</code></div>\n\n##### 或 |\n由于使用<span class=\"tips\">[ ]</span>也表示逻辑或，因此当或符号位于 [ ] 内时 | 可以省略\n\n<div class=\"show\"><code>a|b等同于[ab]   查询字符串内是否含有a或b字符\n(\\d|X|x)等同于[\\dXx]   匹配身份证号最后一位(数字或者X、x)，在Java中由于\\转义，需要写为[\\\\dXx]\n[a-c|e-g]可简写为[a-ce-g],也可写为[a-c[e-g]]\n</code></div>\n\n<div class=\"show\"><code>0[1-9]|1[0-2]  匹配月份01-09,10-12\n0[1-9]|[12]\\d|3[01] 匹配日期01-09,11-29,30,31\n</code></div>\n\n##### 非 ^\n取反运算\n<div class=\"show\"><code>[^abc]  代表abc以外的任意字符\n[a-z&&[^m-p]]  a-z且不包含m-p的集合(等同于[a-lq-z])\n</code></div>\n\n\n### 量词\n#### n? 0个或1个n\nn?匹配只能包含0个或1个n的字符串，字符串中要么没有n，要么只能有一个n\n<div class=\"show\"><code>let reg=/ab?c/;    //只能匹配ac、abc\n</code></div>\n\n#### n*  0个、1个或多个n\nn*匹配包含0个、1个或多个n的字符串，即有无n都可以，相当于<span class=\"tips\">{0,}n</span>\n<div class=\"show\"><code>let reg=/ab*c/;    //匹配ac、abc、abbbbbc等b可有可无，或包含多个b的字符串</code></div>\n\n#### n+ 至少1个n\n匹配包含至少有一个字符n的字符串，相当于<span class=\"tips\">{1,}n</span>\n<div class=\"show\"><code>let reg=/ab+c/;    //匹配abc等b出现1次及1次以上的字符串</code></div>\n\n#### {x} 匹配出现x次的字符串\n指定一个内容出现的次数，注意：它只对它之前的一个内容起作用，多个内容重复应该使用<span class=\"tips\">( )</span>包裹\n<div class=\"show\"><code>let reg=/a{3}/;    //匹配aaa\nlet reg2=/ab{3}/;  //匹配abbb\nlet reg3=/(ab){3}/; //匹配ababab\n</code></div>\n\n#### {x,y} 匹配出现x至y次的字符串\n<div class=\"show\"><code>let reg=/ab{1,3}c/;    //匹配abc、abbc、abbbc</code></div>\n\n#### {x,} 匹配出现的字符串大于等于x次的字符串\n<div class=\"show\"><code>let reg=/ab{3,}c/;    //匹配abbbc等b出现3次及3次以上的字符串</code></div>\n\n### 元字符与转义\n#### 元字符\n元字符即正则表达式中一些用于特殊用途的字符\n<div class=\"table\">\n<table>\n    <thead>\n        <tr>\n            <th>元字符</th>\n            <th>描述</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td><span class=\"strong\">.</span></td>\n            <td><span class=\"strong\">查找单个任意字符，除了换行和行结束符</span></td>\n        </tr>\n         <tr>\n            <td><span class=\"strong\">\\w</span></td>\n            <td><span class=\"strong\">查找单词字符</span>(任意字母、数字、下划线_)</td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\W</span></td>\n            <td><span class=\"strong\">查找非单词字符</span>(除字母、数字、下划线_以外的字符)</td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\d</span></td>\n            <td><span class=\"strong\">查找数字</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\D</span></td>\n            <td><span class=\"strong\">查找非数字字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\s</span></td>\n            <td><span class=\"strong\">查找空白字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\S</span></td>\n            <td><span class=\"strong\">查找非空白字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\b</span></td>\n            <td><span class=\"strong\">匹配单词边界</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\B</span></td>\n            <td><span class=\"strong\">匹配非单词边界</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\o</span></td>\n            <td><span class=\"strong\">查找 NUL 字符(字符串结束字符)</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\n</span></td>\n            <td><span class=\"strong\">查找换行符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\f</span></td>\n            <td><span class=\"strong\">查找换页符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\r</span></td>\n            <td><span class=\"strong\">查找回车符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\t</span></td>\n            <td><span class=\"strong\">查找制表符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\v</span></td>\n            <td><span class=\"strong\">查找垂直制表符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\xxx</span></td>\n            <td><span class=\"strong\">查找以八进制数 xxx 规定的字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\xdd</span></td>\n            <td><span class=\"strong\">查找以十六进制数 dd 规定的字符</span></td>\n        </tr>\n        <tr>\n            <td><span class=\"strong\">\\uxxxx</span></td>\n            <td><span class=\"strong\">查找以十六进制数 xxxx 规定的 Unicode 字符</span></td>\n        </tr>\n    </tbody>\n</table>\n</div>\n\n#### 转义字符\n由于<span class=\"tips\">.|^&?*+</span>等字符已作为关键字使用，因此如匹配小数点等功能需要用到转义，正则表达式中使用<span class=\"tips\">&#92;</span>作为转义字符。此外，由于Java中的正则表达式规则以字符串形式表示，而字符串中<span class=\"tips\">&#92;</span>也为转义字符，因此往往需要两个转义字符<span class=\"tips\">\\\\\\\\</span>进行二次转义，如：查找数字 \\d，在Java的正则表达式中需要写为<span class=\"tips\">\\\\\\\\d</span>，其他元字符同理。\n\n\n\n<div class=\"show\"><code>let reg=/\\./;  //使用转义字符匹配字符串中的.号，如匹配小数点</code></div>\n\n### 字符串位置\n#### 常用位置\n<ul>\n<li><span class=\"strong\">^n &emsp;&emsp;匹配以 n 开头的字符串</span></li>\n<li><span class=\"strong\">n$ &emsp;&emsp;匹配以 n 结尾的字符串</span></li>\n<li><span class=\"strong\">^n|n$ &emsp;匹配以n开头或以n结尾的字符串</span></li>\n<li><span class=\"strong\">^n$ &emsp;&emsp;以n开头马上以n结尾,因此只能匹配到\"n\"</span></li>\n<li><span class=\"strong\">?=n &emsp;&emsp;匹配所有其后紧接指定字符串 n 的字符串，但不存储 n 的值</span></li>\n<li><span class=\"strong\">?:n &emsp;&emsp;匹配所有其后紧接指定字符串 n 的字符串，并存储 n 的值</span></li>\n<li><span class=\"strong\">?!n &emsp;&emsp;匹配所有其后没有紧接指定字符串 n 的字符串</span></li>\n</ul>\n\n<div class=\"show\"><code>let str=\"java自从95年问世以来，经历了很多版本，如：Java5,Java6...其中用的最多的是JAva8和JAva11，下一个长期支持版本是JAVA17\";\nlet reg12=/java(?=8|11|17)/ig;\nlet reg13=/java(?:8|11|17)/ig;\nlet reg14=/java(?!8|11|17)/ig;\nconsole.log(str.match(reg12)) //[ 'JAva', 'JAva', 'JAVA' ]\nconsole.log(str.match(reg13)) //[ 'JAva8', 'JAva11', 'JAVA17' ]\nconsole.log(str.match(reg14)) //[ 'java', 'Java', 'Java' ]\n</code></div>\n\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\n^n和n$可理解为开头后紧接字符n,结束前紧接字符n,因此^n$表示开头后紧接这字符n，马上紧接这结束符号，因此只能匹配字符n自己</div>\n\n#### 前瞻断言与后顾断言\n\n+ <span class=\"strong\">x(?=n) &emsp;&emsp;查找n前的x</span><span class=\"tips\">(前瞻)</span>\n+ <span class=\"strong\">(?<=n)x &emsp;查找n后的x</span><span class=\"tips\">(后顾)</span>\n+ <span class=\"strong\">x(?!n) &emsp;&emsp;查找后面不是n的x</span><span class=\"tips\">(负前瞻)</span>\n+ <span class=\"strong\">(?&lt;!n)x &emsp;查找前面不是n的x</span><span class=\"tips\">(负后顾)</span>\n\n<pre><code>import java.util.regex.Pattern;\npublic class RegexTest {\n    public static void main(String[] args) {\n        String str=\"java自从95年问世以来，经历了很多版本，如：Java5,Java6...其中用的最多的是JAva8和JAva11，\" +\n                \"下一个长期支持版本是JAVA17\";\n        String reg1=\"(?i)java(?:\\\\d*)\";\n        String reg2=\"(?i)(?<=java)\\\\d*\";\n        Pattern p1=Pattern.compile(reg1);\n        Pattern p2=Pattern.compile(reg2);\n        Matcher m1=p1.matcher(str);\n        Matcher m2=p2.matcher(str);\n        while(m1.find()){\n            System.out.println(m1.group());//java,Java5,Java6,JAva8,JAva11,JAVA17\n        }\n        System.out.println(\"------------M2\");\n        while(m2.find()){\n            System.out.println(m2.group());// 5,6,8,11,17\n        }\n    }\n}\n</code></pre>\n\n\n\n\n#### 单词边界\n\n+ <span class=\"strong\">\\b</span>&emsp;&emsp;匹配一个单词边界\n+ <span class=\"strong\">\\B</span>&emsp;&emsp;匹配一个非单词边界\n\n\n当一个字符串本身刚好是另外一个字符串一部分时，如：child为children的一部分，需要使用单词边界来进行限定\n\n<div class=\"show\"><code>let reg=/\\bchild\\b/;\nconsole.log(reg.test(\"eg children\")); //false </code></div>\n\n定义中单词的组成可以为字母、数字、下划线，即元字符中的<span class=\"tips\">\\w</span>，非单词为字母、数字、下划线以外的字符，即元字符中的<span class=\"tips\">\\W</span>。而边界为一个抽象的概念，并非实际字符，任意两个字符之间都可以视为一个边界。\n\n+ <span class=\"strong\"><span class=\"tips\">\\b</span>用于匹配左右字符类型不相同的边界，即一边字符为\\w，另一边字符为[^\\w]</span>\n\n+ <span class=\"strong\"><span class=\"tips\">\\B</span>用于匹配左右字符类型相同的边界，即两边都是\\w，或者两边都不是\\w</span>\n\n<div class=\"show\"><code>let string=\" at fat sat ate ato _at %at 9at %at& cate _at_ 0at0 \";\nlet re1=/.\\bat\\b./ig;\nlet re2=/.\\Bat\\b./ig;\nlet re3=/.\\Bat\\B./ig;\nlet re4=/.\\bat\\B./ig;\nconsole.log(string.match(re1)) // [ ' at ', '%at ', '%at&' ]\nconsole.log(string.match(re2)) // [ 'fat ', 'sat ', '_at ', '9at ' ]\nconsole.log(string.match(re3)) // [ 'cate', '_at_', '0at0' ]\nconsole.log(string.match(re4)) // [ ' ate', ' ato' ]\n</code></div>\n\n+ 第一个正则表达式中，第一个\\b由于右侧at属于\\w，因此左侧只能为非\\w的字符(包括空格符)，第二个\\b由于左侧at属于\\w，因此右侧也只能为非\\w的字符\n+ 第二个正则表达式中，表达式中\\B由于右侧at属于\\w，因此左侧也需要为属于\\w的字符，表达式中\\b由于左侧at属于\\w，因此右侧只能为非\\w的字符\n+ 第三个正则表达式中，第一个\\B由于右侧at属于\\w，因此左侧也需要为\\w，第二个\\B由于左侧at属于\\w，因此右侧也需要为\\w\n+ 第四个正则表达式中，\\b由于右侧at属于\\w，因此左侧只能为[^\\w]，\\B由于左侧at属于\\w，因此右侧也需要为\\w\n\n\n其他特殊符号同理\n<div class=\"show\"><code>let string=\" &  a&a 0&0 #&#\"\nlet re1=/.\\b&\\b./ig; //由于&为[^\\w]，因此&两侧都需要为\\w\nlet re2=/.\\B&\\B./ig; //由于&为[^\\w]，因此&两侧都需要为[^\\w]\nconsole.log(string.match(re1)) // [ 'a&a', '0&0' ]\nconsole.log(string.match(re2)) // [ ' & ', '#&#' ]\n</code></div>\n\n### 匹配模式\n 匹配模式可以忽略，默认情况下正则匹配会区分大小写，并且将在匹配到第一个结果后停止匹配并返回结果。正则表达式有六个参数用于指定匹配模式，这些参数既可以单独使用也可以任意顺序一起使用。\n\n <ul>\n <li><span class=\"strong\">g &emsp;&emsp;全局搜索</span></li>\n <li><span class=\"strong\">i &emsp;&emsp;忽略大小写</span></li>\n  <li><span class=\"strong\">(?i) &emsp;&emsp;忽略大小写<span class=\"tips\">(java)</span></span></li>\n <li><span class=\"strong\">m&emsp;&emsp;多行搜索</span></li>\n <li><span class=\"strong\">s &emsp;&emsp;允许<span class=\"tips\">.</span>号匹配换行符</span></li>\n <li><span class=\"strong\">u &emsp;&emsp;使用unicode码的模式进行匹配。</span></li>\n <li><span class=\"strong\">y &emsp;&emsp;执行“粘性”搜索,匹配从目标字符串的当前位置开始。</span></li>\n </ul>\n\n<div class=\"show\"><span class=\"tips\">java支持，而javaScript不支持下述写法</span>\n<code>a(?i)bc   忽略bc的大小写\na((?i)b)c  只忽略b的大小写</span></code>\n</div>\n\n### 贪婪爬取与非贪婪爬取\n<span class=\"strong\">贪婪爬取：</span>尽可能多地爬取数据\n\n<span class=\"strong\">非贪婪爬取：</span>尽可能少地爬取数据，一般情况下\n\nJava、JavaScript均默认为贪婪爬取，我们可以在数量词<span class=\"tips\">+</span>、<span class=\"tips\">*</span>后加上<span class=\"tips trong\">?</span>将爬取模式修改为非贪婪爬取\n<pre><code>package regex;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MainTest {\n    public static void main(String[] args) {\n        String str=\"abbbbbbbbbbbcc\";\n        //贪婪爬取\n        String reg1=\"ab+\";\n        Pattern p1= Pattern.compile(reg1);\n        Matcher m1=p1.matcher(str);\n        while (m1.find()){\n            System.out.println(m1.group());//abbbbbbbbbbb\n        }\n        //非贪婪爬取\n        String reg2=\"ab+?\";\n        Pattern p2= Pattern.compile(reg2);\n        Matcher m2=p2.matcher(str);\n        while (m2.find()){\n            System.out.println(m2.group());//ab\n        }\n    }\n}</code></pre>\n\n<pre><code>let str=\"abbbbbbbccccccccc\";\nlet reg1=/ab+/g;\nlet reg2=/ab+?/g;\nconsole.log(str.match(reg1)); //[ 'abbbbbbb' ]\nconsole.log(str.match(reg2)); //[ 'ab' ]\n</code></pre>\n\n### 捕获分组与非捕获分组\n#### 捕获分组\n在正则表达式中，可以使用<span class=\"tips\">( )</span>将语句分组，组号从1开始，分组以左括号为基准，最左边为第一组，其次为第二组，以此类推。\n\n##### 正则表达式内部调用\n\n在正则表达式内部可以使用<span class=\"tips\">\\组号</span>将数据捕获出来，再次调用\n\n<div class=\"show\"><code>(.+).+\\1  匹配诸如 abc123abc、b45b 之类头尾相同的字符串\n((.)\\2*).+\\1    匹配诸如 aa123aa 之类开头字符完全相同，且结尾字符等同于开头字符的字符串\n</code></div>\n\n##### 正则表达式外部调用\n在正则表达式外部可以使用<span class=\"tips\">$组号</span>再次调用捕获的数据，如：在替换语句中调用捕获的数据，将重复的字符替换为单个字符\n\n<div class=\"code\"><code>package regex;\npublic class outRegex {\n    public static void main(String[] args) {\n        String str=\"abbbccccccccdddddddd\";\n        System.out.println(str.replaceAll(\"(.)\\\\1+\",\"$1\")); //abcd\n    }\n}</code></div>\n\n#### 非捕获分组\n使用<span class=\"tips\">(?:)</span>、<span class=\"tips\">(?:)</span>、<span class=\"tips\">(?:)</span>时，()仅用于囊括数据，无法通过<span class=\"tips\">\\组号</span>、<span class=\"tips\">$组号</span>方式调用本组数据，并且非捕获分组不会占用组号\n\n\n### Java中的正则表达式\nJava中的正则表达式规则以字符串形式表示，因此转义字符往往需要两个<span class=\"tips\">\\\\\\\\</span>。此外，Java还提供了<span class=\"tips\">Pattern类</span>和 <span class=\"tips\">Matcher类</span>用于提供正则表达式支持。\n\n#### String类与正则表达式有关的常用方法\n##### public boolean matches(String regex)\n返回boolean值，检测字符串是否匹配该正则表达式\n\n<div class=\"code\"><code>package regex;\npublic class Matches {\n    public static void main(String[] args) {\n        String str=\"(&\\\\*)\\\\1{2}\\\\d+\";\n        System.out.println(\"aaaa\".matches(str)); //false\n        System.out.println(\"&*22\".matches(str)); //false\n        System.out.println(\"&*&*&*222\".matches(str)); //true\n        System.out.println(\"&*&*211\".matches(str)); //false\n    }\n }  \n</code></div>\n\n##### public String replaceAll(String regex,String replacement)\n返回一个String，将字符中所有满足该正则表达式的子字符串替换为指定内容。\n\n与之类似的还有<span class=\"strong\">public String replaceFirst(String regex,String replacement)</span>，用给定的内容替换字符串中第一个满足该正则的子字符串\n\n<div class=\"code\"><code>//字符去重\npackage regex;\npublic class RegexReplaceAll {\n    public static void main(String[] args) {\n        String str=\"abbbccccccccdddddddd\";\n        System.out.println(str.replaceAll(\"(.)\\\\1+\",\"$1\"));\n    }\n}\n</code></div>\n\n##### public String[] split(String regex)\n返回一个String数组，按正则匹配的内容分割字符串，并将剩余内容返回为一个String数组\n\n#### Pattern类与Matcher类\n这两个类位于<span class=\"tips\">java.util.regex</span>包下\n\n<span class=\"strong\">Pattern</span>(模式)类用于将正则表达式编译为此类的实例，即正则表达式的编译表示，该类的构造方法私有，需要通过调用其静态方法<span class=\"tips\">compile(String regex)</span>来创建对象，将给定的正则表达式编译Pattern对象并返回，该类被final修饰，无法被继承。\n\n<span class=\"strong\">Matcher</span>(匹配器)类用于创建文本匹配器对象，执行匹配操作，该类也没有公共构造方法，需要通过Pattern对象的<span class=\"tips\">matcher(String)</span>方法来获得一个Matcher对象，且该类也被final修饰，无法被继承。\n\nMatcher类下常用的方法\n+ <span class=\"strong\">public boolean find()</span> 搜索与正则匹配的目标字符串，返回boolean值\n+ <span class=\"strong\">public String group()</span> 返回上一个匹配的字符串子序列\n\n<pre><code>package regex;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n/**\n*   爬取所有带有java与其版本的信息\n*/\npublic class PatternAndMatcher {\n    public static void main(String[] args) {\n        String str=\"java自从95年问世以来，经历了很多版本，如：Java5,Java6...其中用的最多的是JAva8和JAva11，\" +\n                \"下一个长期支持版本是JAVA17\";\n        String reg=\"(?i)java(?:\\\\d*)\";\n        Pattern p= Pattern.compile(reg);\n        Matcher m=p.matcher(str);\n        while(m.find()){\n            System.out.println(m.group());//java Java5 Java6 JAva8 JAva11 JAVA17\n        }\n    }\n}</code></pre>\n\n\n### JavaScript中的正则表达式\n#### 创建RegExp正则表达式对象\n ###### 1.字面量\n 由斜杠<span class=\"tips\">/</span>包围，语法：<span class=\"strong\">/正则表达式/匹配模式</span>\n <div class=\"show\"><code>let reg=/ab/i</code></div>\n\n###### 2.利用构造函数\n 由引号<span class=\"tips\">\" </span>包围，语法：<span class=\"strong\">let 变量=new RegExp(\"正则表达式\",\"匹配模式\")</span>\n 匹配模式可直接省略，默认情况下匹配到一个结果就返回\n <pre><code>let reg=new RegExp(\"ab\",\"i\")</code></pre>\n\n###### 构造函数中的转义\n由于构造函数中接收的参数为字符串，而字符串中<span class=\"tips\">&#92;</span>也为转义字符，因此在构造函数中使用<span class=\"tips\">&#92;</span>符号需要进行二次转义。如\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\.\"); //编译后的正则表达式为/\\./,即用于匹配小数点</code></div>\n\n\n##### 匹配字符串中是否有<span class=\"tips\">&#92;</span>\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\\\\\\"); //编译后的正则表达式为/\\\\/</code></div>\n<p>错误的语法</p>\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\\");\n //编译后的正则表达式为/\\/，表达式将\\作为转义符号,转义后面的/符号，从而导致正则表达式缺少完整//符号而报错</code></div>\n<p>测试字符串中是否有<span class=\"tips\">&#92;</span>完整代码</p>\n<div class=\"code\"><code>let reg=new RegExp(\"\\\\\\\\\");\n let str=\"abcd\\\\\";\n console.log(reg); //输出/\\\\/\n console.log(str); //输出abcd\\\n console.log(reg.test(str)); //输出true</code></div>\n\n\n#### RegExp对象的常用方法\n##### test() \n在字符串中查找是否有满足正则表达式的值，有则返回<span class=\"tips\">true</span>,无则返回<span class=\"tips\">false</span>。\n<div class=\"code\"><code>let reg=/hello/;\nconsole.log(reg.test(\"xxhelloxx\")); //true</code></div>\n\n在全局匹配模式下，同语句多次调用test()可能会出现返回的boolean值不同的情况\n<div class=\"show\"><code>let reg=/^1[345678][0-9]{9}$/g;\nconsole.log(reg.lastIndex,reg11.test(\"13456789000\")) //0 true\nconsole.log(reg.lastIndex,reg11.test(\"13456789000\")) //11 false\n</code>这是由于RegRxp的lastIndex属性用于保存索引开始位置，第二个语句中lastIndex指向了11，解决方法为：\n    1. 不使用全局匹配\n    2. 在每次匹配前将lastIndex设置为0\n<code>let reg=/^1[345678][0-9]{9}$/g;\nconsole.log(reg.lastIndex,reg.test(\"13228207602\")) //0 true\nreg.lastIndex=0;\nconsole.log(reg.lastIndex,reg.test(\"13228207602\")) //0 true\n</code></div>\n\n##### exec() \n搜索出字符串中与正则表达式匹配的值，如果找到了，返回一个存放了匹配结果、匹配结果的第一个字符位置等信息的数组，如果未找到返回 null 。该方法不常用，搜索字符串常用String对象的match()方法。\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n更多RegExp对象的属性和方法详见W3C标准或MDN的官方文档</div>\n\n#### String对象支持正则表达式的方法\n##### split() 字符串拆分为数组\n按所写正则表达式表达式规则将一个字符串拆分成数组，拆分处字符将丢弃,该方法即使不指定全局匹配，也会自动进行全局匹配，返回数据类型为<span class=\"tips\">Object数组<span>。\n<div class=\"code\"><code>var str=\"1a2b3c4d\";\nconsole.log(str.split(/[A-z]/));//返回['1','2','3','4']</code></div>\n\n##### search() 搜索匹配值\n搜索字符串是否含有指定内容，有则返回第一次出现的索引值(即使为全局匹配也只返回第一次出现的索引值)，没有则返回-1。返回数据类型为<span class=\"tips\">Number<span>\n<div class=\"code\"><code>var str=\"never forget ever\";\nconsole.log(str.search(/ever/));//返回1\nconsole.log(str.search(/f/));//返回6</code></div>\n\n##### match() 找到一个或多个正则表达式匹配\n将符合正则表达式的内容提取出来,默认情况下找到第一个符合的字符就会返回，因此经常配合全局匹配模式。返回数据类型为<span class=\"tips\">Object数组<span>\n<div class=\"code\"><code>var str=\"1a2b3c4d\";\nconsole.log(str.match(/[a-z]/ig));//返回['a','b','c','d']\nconsole.log(str.search(/[0-9]/g));//返回['1','2','3','4']</code></div>\n\n##### replace() 将符合表达式的字符串替换成指定字符串\n用于屏蔽、替换内容，接收两个参数：被替换的内容、新内容，语法为<span class=\"strong\">replace(字符或正则表达式,\"新内容\")</span>。默认只替换第一个符合表达式的内容。返回数据类型为<span class=\"tips\">String<span>\n<div class=\"code\"><code>var str=\"1a2b3c4d\";\nconsole.log(str.replace(/[a-z]/ig,\"*\"));//返回1*2*3*4*\nconsole.log(str.replace(/[0-9]/g,\"\"));//返回abcd</code></div>\n\n#### JavaScript去除空格\n##### 去除字符串中的所有空格\n表达式：<span class=\"strong\">/\\s/g</span>\n<div class=\"code\"><code>let str=\" xxx  xxx \";\nlet str1=str.replace(/\\s/g,\"\"); //输出xxxxxx</code></div>\n\n##### 去除字符串前后的空格，保留字符之间的空格\n表达式：<span class=\"strong\">/^\\s+|\\s+$/g</span>若只去除前或后的空格，取表达式一半\n<div class=\"code\"><code>let str=\" xxx  xxx \";\nlet str1=str.replace(/^\\s+|\\s+$/g,\"\"); //输出xxx  xxx</code></div>\n\n ### 常用正则表达式\n <div class=\"broadcast color-red\">\n<div class=\"iconfont icon-gantanhao\"></div>\n来源于网课资料，可能存在错误</div>\n<h5>校验数字</h5>\n<p style=\"white-space:pre-wrap;text-indent:0;\">1. 数字：^[0-9]*$\n2. n位的数字：^\\d{n}$\n3. 至少n位的数字：^\\d{n,}$\n4. m-n位的数字：^\\d{m,n}$\n5. 零和非零开头的数字：^(0|[1-9][0-9]*)$\n6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n7. 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\n8. 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n11. 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\n12. 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$\n13. 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n14. 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n15. 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\n16. 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\n17. 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n18. 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n19. 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n</p>\n<h5>校验字符</h5>\n<p style=\"white-space:pre-wrap;text-indent:0;\">1. 汉字：^[\\u4e00-\\u9fa5]{0,}$\n2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n3. 长度为3-20的所有字符：^.{3,20}$\n4. 由26个英文字母组成的字符串：^[A-Za-z]+$\n5. 由26个大写英文字母组成的字符串：^[A-Z]+$\n6. 由26个小写英文字母组成的字符串：^[a-z]+$\n7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n8. 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n9. 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n10. 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n11. 可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+ 12 禁止输入含有~的字符：[^~\\x22]+</p>\n<h5>信息</h5>\n<p style=\"white-space:pre-wrap;text-indent:0;\">1. Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\n3. InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n5. 电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\n6. 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n7. 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$\n8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\n12. 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$\n15. 金额的输入格式：\n    1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$\n    2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$\n    3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$\n    4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$\n    5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$\n    6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$\n    7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$\n    8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$\n16. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n17. 中文字符的正则表达式：[\\u4e00-\\u9fa5]\n18. 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n19. 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\n20. HTML标记的正则表达式：<(\\S*?)[^>]*>.*?</\\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n21. 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n22. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n23. 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\n24. IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)\n25. IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))</p>\n","tags":["笔记","regex"]},{"title":"JavaScript异步与AJAX","url":"/blog/2021/04/01/JavaScript异步与AJAX/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n文中所声明对象和语法基于javaScript</div>\n\n\n### 迭代器\n迭代器(iterator)是一种可以为各种不同的数据结构提供统一遍历操作的接口，JAVA、C++、Python、PHP等很多语言都有迭代器的概念，对象只要部署了iterator接口，就可以进行遍历操作(如用for语句进行遍历)。\n \n### 迭代器的遍历\n迭代器遍历的原理是这样的：\n<ol>\n<li>创建一个指针对象，指向当前数据结构的起始位置;</li>\n<li>调用指针对象的next方法，指针指向数据结构的第一个成员;</li>\n<li>重复调用next方法，指针后移动，直至指向最后一个成员;</li>\n</ol>\n<p>以最常见的遍历数组为例：我们可以用for…of等语句对其进行遍历，是因为数组中原生内置了iterator接口。</p>\n<pre><code> const songs=['夜曲','手写的从前','反方向的钟','晴天','最长的电影'];\n    console.log(songs);</code></pre>\n    <img data-src=\"/blog/images/iterator01.jpg\" src=\"#\" alt=\"iterator接口\">\n<p>按照其原理，先定义一个对象来获取该Symbol.iterator属性，找到该对象中包含的next方法。调用这个next()方法，它会返回一个包含done和value属性的对象。</p>\n<pre><code>const songs=['夜曲','手写的从前','最长的电影','晴天','明明就'];\n        // console.log(songs);\n        let iterator=songs[Symbol.iterator]();\n        console.log(iterator);\n        console.log(iterator.next());</code></pre>\n        <img data-src=\"/blog/images/iterator02.jpg\" src=\"#\" alt=\"iterator中的next方法\">\n<p>重复调用next()方法，该方法会依次遍历数组成员并返回多个包含done和value属性的对象，遍历完数组后，再返回一个done属性值为true,value属性值为undefined的对象，表示数组遍历结束。</p>\n<img data-src=\"/blog/images/iterator03.jpg\" src=\"#\" alt=\"遍历结束\">\n<p>在JavaScript中，原生自带iterator接口的数据结构有：<br/>\n<span class=\"tips\">Array</span>、<span class=\"tips\">Map</span>、<span class=\"tips\">Set</span>、<span class=\"tips\">String</span>、<span class=\"tips\">TypedArray</span>、<span class=\"tips\">函数的 arguments 对象</span>、<span class=\"tips\">NodeList 对象</span>\n</p>\n\n### 自定义遍历对象\n对于没有内置iterator接口的数据结构，可以仿照其原理，手写一个iterator接口，并且自定义需要遍历或者允许被遍历的内容。\n<p>按照其原理，添加iterator接口的步骤分为:</p>\n<ol>\n<li>添加Symbol.iterator属性,它是以一个函数的形式包含；</li>\n<li>在其中添加next()方法;</li>\n<li>next()方法会依次返回一个包含done和value属性的对象；</li>\n<li>如果遍历结束，则返回一个done属性值为true,value属性值为undefined的对象;</li>\n</ol>\n完整代码：\n<pre><code> //遍历输出对象的songs属性\n        const Rapper={\n            name:'王以太',\n            shows:['Chengdu','Hangzhou','Shenzhen'],\n            songs:['三思而后行','阿司匹林','童言无忌','目不转睛','人间天堂'],\n            [Symbol.iterator](){\n                let index=0;//索引号\n                return{\n                    next: ()=>{\n                        if(index< this.songs.length){\n                            const result={\n                                value:this.songs[index],\n                                done:false};\n                                index++;\n                                return result;\n                            }\n                            else{\n                                return{\n                                    value:undefined,\n                                    done:true\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n      \t//遍历输出\n\t\tfor(let m of Rapper){\n    \tconsole.log(m);\n    }\n</code></pre>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\npython、C++写个类似的接口也很简单，不过对复杂点的数据结构比较麻烦</div>\n\n### 生成器函数\n生成器函数允许我们定义一个包含自有迭代算法的函数，返回一种称为 Generator 的迭代器，生成器函数需要使用<span class=\"tips\">function *</span>语法声明\n\n<div class=\"show\"> function * gen(){\n            console.log(\"执行生成器\");\n        }\n        const g=gen();//返回一个名为Generator的迭代器，但不执行console.log语句\n        console.log(g);\n        g.next();//需要执行迭代器的next的方法才会执行生成器，才开始执行生成器中的console.log语句\n</div>\n\n#### yield关键字\nyield 关键字用于生成器函数的暂停和恢复，当执行Generator迭代器的next()方法时，开始执行生成器中的代码，一旦遇到 yield 表达式，生成器的代码将被暂停运行，直到生成器的 next() 方法再次被调用，暂停时yield 关键字后面的表达式的值返回给生成器的调用者，类似于一个基于生成器的版本的 return 关键字\n\n<span class=\"strong\">[rv] = yield [expression];</span>\n+ rv 返回传递给生成器的 next() 方法的可选值，以恢复其执行\n+ expression:定义通过迭代器协议从生成器函数返回的值。如果省略，则返回 undefined\n\n<div class=\"show\">function * gen(){\n    console.log(\"第一次执行\");\n    yield 111;\n    console.log(\"第二次执行\");\n    yield 222;\n    console.log(\"第三次执行\");\n    yield 333;\n    console.log(\"第四次执行\");\n    yield 444;\n}\nconst iterator=gen();\nconsole.log(iterator.next());//第一次执行next()方法，输出\"第一次执行\"，并返回第一个yield表达式的值111\niterator.next();//第二次执行next()方法，执行到第二个yield表达式为止\niterator.next();\niterator.next();</div>\n\n#### next()方法传参\n next() 方法接受一个参数用于修改生成器内部状态，传递给 next() 的参数值会被 yield 接收。传递给第一个 next() 的值会被忽略，而传递给第二个 next() 的值会被第一个 yield 接收，依此类推\n\n<div class=\"show\">function * gen(arg){\n    console.log(arg);//生成器函数本身的实参\n    let first=yield 111;\n    console.log(first);//\"BBB\"\n    let second=yield 222;\n    console.log(second);//\"CCC\"\n    let third=yield 333;\n    console.log(third);//\"DDD\"\n    yield 444;\n}\nconst iterator=gen(\"生成器实参\");\niterator.next();//第一个 next() 的实参会被忽略，不传参\niterator.next(\"BBB\");\niterator.next(\"CCC\");\niterator.next(\"DDD\");</div>\n\n#### 异步调用\n由于生成器函数每次执行到yield语句就会暂停，利用这个特性我们可以进行对资源的异步顺序加载，\n\n<div class=\"show\">实现：先加载\"用户数据\"，等待\"用户数据\"加载完毕再加载\"订单数据\"，最后加载\"商品数据\"，案列使用定时器模拟异步环境\nfunction getUsers(){\n    setTimeout(()=>{\n        let user=\"用户数据\";\n        iterator.next(user);//加载完的数据通过next()方法传给生成器函数，并开始加载下一项数据\n    },1000)\n}\nfunction getOrders(){\n    setTimeout(()=>{\n        let order=\"订单数据\";\n        iterator.next(order);\n    },1000)\n}\nfunction getGoods(){\n    setTimeout(()=>{\n        let goods=\"商品数据\";\n        iterator.next(goods);\n    },1000)\n}\nfunction * gen(){\n    let users=yield getUsers();\n    console.log(users);//处理数据\n    let order=yield getOrders();\n    console.log(order);\n    let goods=yield getGoods();\n    console.log(goods);\n}\nconst iterator=gen();\niterator.next();//初次执行next()方法\n</div>\n\n### Promise\nPromise是ES6新增的异步编程解决方案，用于封装异步任务，并且可以根据异步任务的成功/失败，对结果和数据进行灵活处理，此外，Promise支持链式调用，能很好地解决回调地狱问题\n\n#### Promise对象\nPromise本质上是一个函数返回的对象，代表了一个异步操作的成功或者失败，该对象中有两个关键属性：<span class=\"tips\">PromiseState</span>和<span class=\"tips\">PromiseResult</span>\n\n<span class=\"strong\">PromiseState</span> 即Promise的状态，Promise有三种状态:\n+ pending 未决定的\n+ resolved/fulfilled 决定的,符合的(成功)\n+ rejected 拒绝的(失败)\n\n该属性只能被修改一次，并且修改完毕后也只有一个结果(resolved或rejected)和结果数据\n\n<span class=\"strong\">PromiseResult</span>即Promise封装的异步任务成功/失败的结果数据，只能通过<span class=\"tips\">resolve()</span>或<span class=\"tips\">reject()</span>函数修改，并且可以传递给<span class=\"tips\">then()</span>方法，Promise成功时结果数据一般使用value为实参名，失败则使用reason作为实参名\n\n\n#### 实例化\n使用<span class=\"tips\">new</span>关键字进行实例化，实例化时接收一个函数类型的参数，该函数又接收两个函数类型的形参，<span class=\"tips\">resolve()</span>用于异步任务执行成功时调用，<span class=\"tips\">reject()</span>用于异步任务执行失败时调用\n\n<div class=\"show\"><span class=\"strong\" style=\"white-space:pre;\">const p=new Promise((resolve,reject)=>{\n                        //封装异步任务\n                         if(异步任务执行成功){\n                            resolve(data);\n                        }\n                        else{\n                            reject(data);\n                     }\n            });</span></div>\n\n\n当resolve被调用后，Promise状态会被修改为成功，随后执行<span class=\"tips\">then()</span>方法的第一个回调函数。reject则会将Promise状态会被修改为失败，随后执行<span class=\"tips\">then()</span>方法的第二个回调函数\n<div class=\"show\"><span class=\"strong\" style=\"white-space:pre;\">p.then((value)=>{\n            //Promise状态为成功时执行\n    },(reason)=>{\n            //Promise状态为失败时执行\n});</span></div>\n<div class=\"show\"><span class=\"strong\" style=\"white-space:pre;\">p.catch(resaon=>{\n            //只会在Promise状态为失败时执行\n});</span></div>\n此外，Promise状态为失败时也可以使用<span class=\"tips\">catch()</span>方法，该方法被单独封装用于处理失败情况，底层依旧调用了then()方法\n\n#### API\n##### 执行流程\n通过new创建Promise对象，对象初始状态为pending状态，然后执行内部的异步操作，执行成功则调用resolve()函数，将Promise对象状态修改为resolved状态，此时如果调用了then()方法，则将执行then()方法中的第一个回调函数，执行完该回调函数后返回一个新的promise()对象。如果异步任务执行失败，则调用reject()函数，将Promise对象状态修改为rejected状态，此时如果调用了then()方法，则将执行then()方法中的第二个回调函数，执行完该回调函数后返回一个新的promise()对象\n\n##### 构造函数\nPromise((excutor){})\n该构造函数接收一个执行器函数，内部定义了resolve()和reject()函数，这两个函数不属于Promise对象内部，执行器函数会在对象创建后立即执行(同步调用)\n\n##### 快速获取Promise对象\n以下方法属于Promise函数对象，可以直接调用\n+ Promise.resolve(value)\nvalue可以为任意类型的数据，或者一个Promise对象\n返回一个成功的Promise对象，但如果传入了一个Promise对象，则其状态取决于传入对象的状态，如果传入的Promise对象为成功，则返回的对象也为成功状态，反之亦然。该方法用于快速将一个数据转换为一个状态为成功的Promise对象\n<div class=\"show\">\nconst p1=Promise.resolve(100);//\nconst p2=Promise.resolve(new Promise((resolve,reject)=>{\n    reject();//由于传入的Promise对象状态为rejected，依次p2也为rejected状态\n}))\n</div>\n\n\n+ Promise.reject(value)\n永远返回一个rejected状态的Promise对象，即便传入的值是成功状态的Promise\n\n+ Promise.all(promise[])\n参数为一个Promise数组，只有当该数组中的所有Promise对象状态都为resolved时，该方法才返回一个resolve状态的Promise对象，且该对象的PromiseResult为数组中的Promise对象成功结果组成的数组。如果该数组中有任意一个Promise对象状态为rejected，则该方法返回的Promise对象状态将修改为rejected，且该对象的PromiseResult为数组中第一个失败成员的返回的PromiseResult\n<div class=\"show\">let p1=Promise.resolve(123)\n        let p2=Promise.reject(\"aaa\")\n        let p3=Promise.reject({test:0})\n        let p=Promise.all([p1,p2,p3]);\n        console.log(p);//p对象的PromiseResult为\"aaa\"\n        \n        p2.catch(reason=>{});\n        p3.catch(reason=>{});\n        p.catch(reason=>{});</div>\n\n\n否则返回一个rejected状态的Promise\n\n+ Promise.race(promise[])\n参数为一个Promise数组，该方法返回的Promise对象的状态取决中传入数组中第一个执行完异步任务的Promise对象状态，且值也为其PromiseResult\n\n##### 修改Promise状态的方法\n+ resolve函数\n+ reject函数\n+ throw 函数\n\n##### 执行多个回调\nPromise允许指定多个回调，即可以指定多个then()方法\n<div class=\"show\">let p=new Promise((resolve,reject)=>{\n     resolve(\"go\");\n});\np.then(value=>{\n    console.log(\"第一个回调\"+value);\n});\np.then(value=>{\n    console.log(\"第二个回调\"+value);\n});</div>\n\n##### then()方法返回值\nthen()方法会返回一个新的Promise对象，该对象的状态和值取决于then()方法所执行的回调函数\n+ 如果该回调函数返回一个Promise对象，则then()方法返回的Promise对象状态与其相同\n+ 如果该回调函数无return语句(默认返回undefined)，或者返回一个非Promise对象的值(如：返回字符串等)，则总是返回一个fulfilled状态的Promise\n+ 如果该回调函数throw异常，则返回rejected状态的Promise对象\n\n<div class=\"show\">let p=new Promise((resolve,reject)=>{\n            resolve();\n        })\n        let result1=p.then(value=>{throw '异常'});//状态为rejected\n        let result2=p.then(value=>{return 'aaa'});//状态为fulfilled\n        let result3=p.then(value=>{\n            return new Promise((resolve,reject)=>{\n            reject('error');\n        })\n        });//状态为rejected\n</div>\n\n##### 链式调用\n由于then()方法返回了一个新的Promise对象，因此该对象也可以调用then()方法，而该then()方法又返回一个新的Promise对象，又能调用then()方法，因此then()方法可以链式调用\n<div class=\"show\"> let p=new Promise((resolve,reject)=>{\n            resolve('success');\n        })\n        p.then(value=>{\n            console.log(value);//success\n        }).then(value=>{\n            console.log(value);//由于上一个then()无返回值，因此其返回的Promise对象的PromiseResult为undefined，因此输出undefined\n        })</div>\n\n##### 异常穿透\n当then()方法进行链式调用时，只需要在最后进行异常处理，前面的链式调用出现的任何异常，都会被传到最后处理异常的回调函数中进行处理(异常穿透特性)\n\n<div class=\"show\"> let p=new Promise((resolve,reject)=>{\n            resolve('success');\n        })\n        p.then(value=>{\n            console.log(value);\n            throw '异常'  //抛出异常\n        }).then(value=>{\n            console.log(value);//由于上一个Promise状态为rejected，then()方法第一个回调不执行\n        }).then(value=>{\n            console.log(value);//同上，不执行\n        }).then(value=>{\n            console.log(value);//同上，不执行\n        }).catch(reason=>{\n            console.warn(reason);//在链式最后进行异常处理\n        })</div>\n\n##### 中断Promise链\n当then()方法进行链式调用时，如果想在某个节点中断Promise链，只需要在该节点返回一个<span class=\"tips\">pending</span>状态的Promise对象，因为处于pending状态的Promise对象不会触发then()方法的执行，而其他任何返回值、异常抛出等操作都会使链式继续进行。注意：中断以后的Promise链，最后的异常捕获会依旧执行\n<div class=\"show\">let p=new Promise((resolve,reject)=>{\n            resolve('success');\n        })\n        p.then(value=>{\n            console.log(111);//输出111\n            throw 'error'\n        }).then(value=>{\n            return new Promise(()=>{});//返回pending状态的Promise对象\n        }).then(value=>{\n            console.log(222);//上一个Promise对象为pending状态，不执行then()方法\n        }).catch(reason=>{\n            console.warn(reason);//但由于异常穿透，该语句会继续执行\n        })</div>\n\n\n### async与await\n#### async函数\nasync函数可以帮助我们用更简洁的方式写出基于 Promise 的异步行为，用于包裹await表达式，该函数会返回一个Promise对象，对象的状态取决于async函数的返回值：\n+ 如果该函数无return语句(默认返回undefined)，或者返回一个非Promise对象的值(如：返回字符串等)，则返回一个fulfilled状态的Promise对象\n+ 如果该函数返回一个Promise对象，则async函数返回的Promise对象状态与其相同\n+ 如果该函数throw异常，则返回rejected状态的Promise对象\n\n#### await表达式\nawait表达式必须用async函数包裹，其右侧一般为Promise对象，也可以为其他值\n+ 如果为其他值，则await返回值与其相同\n+ 如果为Promise对象，则返回值为该对象fulfilled状态下的PromiseResult属性值\n+ 如果为Promise对象，且状态为rejected，则必须用<span class=\"tips\">try...catch</span>进行异常捕获处理\n\n<div class=\"show\"> async function main(){\n            try{\n                let result=await new Promise((resolve,reject)=>{\n                setTimeout(()=>{\n                    resolve('success')\n                },1000)\n            })\n            console.log(result);\n            }\n            catch(e){\n                console.warn(e)\n            }\n        }\n        main();</div>\n\n### AJAX\n#### 简介\nAJAX为Asynchronous JavaScript And XML的缩写，即异步 JavaScript 和 XML，用于更新数据，而不需要重载(刷新)整个页面\n\n#### XMLHttpRequest对象\nAjax 需要依赖于 XMLHttpRequest 对象，主流浏览器都支持 XMLHttpRequest 对象，只需要new即可\n<span class=\"strong\">let xmlhttp=new XMLHttpRequest();</span>\n\nE5和IE6等低版本IE浏览器不支持XMLHttpRequest 对象，而需要使用ActiveX 对象，因此如果需要兼顾低版本IE浏览器，则需要做兼容性检查\n<div class=\"show\">var xmlhttp;\n       if (window.XMLHttpRequest) {\n            xmlhttp = new XMLHttpRequest();//主流浏览器\n } else {\n         xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");//低版本IE浏览器\n}</div>\n\n#### XMLHttpRequest对象方法\n\n+ <span class=\"strong\">open(请求类型,url,async,user,psw)</span> 书写一个请求\n>>+ 请求类型：GET 或POST\n>>+ url为文件位置\n>>+ async：是否异步，值为true(异步)或 false(同步)\n>>+ user：用户名称(可选)\n>>+ psw: 用户密码(可选)\n+ <span class=\"strong\">send()</span> 发送请求，用于GET请求\n+ <span class=\"strong\">send(string)</span>发送请求，用于POST请求\n+ <span class=\"strong\">abort()</span>取消当前请求\n+ setRequestHeader()  向要发送的报头添加标签/值对\n+ getResponseHeader()\t返回特定的头部信息\n+ getAllResponseHeaders()\t返回头部信息\n\n#### XMLHttpRequest对象属性\n+ <span class=\"strong\">onreadystatechange</span> 定义当 readyState 属性发生变化时被调用的函数\n+ <span class=\"strong\">readyState</span> 表示当前 XMLHttpRequest 的状态\n>>+ 0：UNSET，尚未调用open方法，请求未初始化，\n>>+ 1：OPEND，open方法被调用，服务器连接已建立\n>>+ 2：HEADERS_RECEIVED，send()方法被调用，请求已收到\n>>+ 3：LOADING，正在处理请求，response属性已经包含部分数据\n>>+ 4：DONW，请求已完成且响应已就绪\n+ responseText\t以字符串返回响应数据\n+ responseXML\t以 XML 数据返回响应数据\n+ statusText    返回状态文本（比如 \"OK\" 或 \"Not Found\"）\n+ status        返回请求的状态号\n\n#### 发起请求\n##### 发起get请求\n如果get请求需要携带参数，可以直接在URL地址后以键值对的形式拼接<span class=\"tips\">查询字符串</span>，多个参数使用<span class=\"tips\">&</span>拼接\n<div class=\"show\">xhr.open('GET','http://shiwivi.com')</div>\n<div class=\"show\">xhr.open('GET','http://shiwivi.com?id=1&author=shiwivi')</div>\n\n\n<div class=\"show\"> let xhr=new XMLHttpRequest();\n    xhr.open('GET','http://shiwivi.com')\n    xhr.send();\n    xhr.onreadystatechange=function(){\n        if(xhr.readyState===4&&xhr.status===200){\n            console.log(xhr.responseText)\n        }\n    }</div>\n\n\n\n##### 发起post请求\nAJAX发起post请求主要需要如下流程：\n1. 创建xhr对象\n2. 调用open()方法初始化请求\n3. 设置content-type属性，指定请求头所含数据MIME类型为application/x-www-form-urlencoded，即进行了URL编码的二进制数据\n4. 调用send()方法，并指定请求所需要包含的数据\n5. 监听onreadystatechange事件\n\n<div class=\"show\">var xhr=new XMLHttpRequest();\n    xhr.open('POST','http://shiwivi.com');\n    xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded')\n    xhr.send('id=1&author=shiwivi');\n    xhr.onreadystatechange=function(){\n        if(xhr.readyState===4&&xhr.status===200){\n            console.log(xhr.responseText)\n        }\n    }</div>\n<div class=\"broadcast color-pink\">\n<div class=\"iconfont icon-yinle1\"></div>\nURL中只允许出现英文字母、数字、标点符号，在拼接查询字符串时，如果我们在URL中拼接了中文字符，或者其他被预定义的字符，则浏览器会对其进行URL编码，其中中文字符会被编码为%xx%xx%xx形式(x为16进制数)，JavaScript中可以使用encodeURI('字符串')对该字符串进行编码，使用decodeURI('%xx%xx')对该字符串进行解码</div>\n\n#### JQuery中的Ajax\nJQuery对XMLHttpRequest进行了封装\n##### 发起get请求\n<span class=\"strong\">$.get(url,[data],[function(){...}])</span> 发起get请求\n+ url为请求地址，必须\n+ data为请求所携带的参数，非必须，参数也可以以查询字符串的形式拼接到URL后\n+ function可以指定请求成功执行的回调，非必须\n\n<div class=\"show\">$(function(){\n                $.get('http://shiwivi.com',function(res){\n                    console.log(res)//res用于接收返回的数据\n                })\n})</div>\n\n<div class=\"show\">$.get('http://shiwivi.com',{id:1,author:''shiwivi},function(res){...})\n//等价于\n$.get('http://shiwivi.com?id=1&author=shiwivi',function(res){...})\n</div>\n\n##### 发起post请求\n<span class=\"strong\">$.post(url,[data],[function(){...}])</span> 发起post请求\n+ url为提交数据地址，必须\n+ data为所要提交的数据，非必须\n+ function可以指定请求成功执行的回调，非必须\n\n<div class=\"show\"> $(function(){\n             $.post('http://xxxx.com',{name:'shiwivi',type:'blog'},function(res){\n                    console.log(res)\n                })\n        })</div>\n\n##### get与post通用\n<span class=\"strong\" style=\"white-space:pre;\">$.ajax({\n            type:'get/post/put/delete',\n            url:'',\n            data:{ },\n            dataType:'html/text/json/xml/script/jsonp',\n            success:function(res,textStatus,jqXHR){ },\n            error:function(jqXHR,textStatus,error){ }\n})</span> \n\n+ type为请求方式，可选get/post/put/delete，默认get\n+ url为请求地址\n+ data为请求携带的数据\n+ dataType为请求数据类型\n+ success为请求成功执行的回调函数，参数依次为响应内容(根据dataType作了处理)、文本形式的响应状态、jqXHR对象(里面包含状态码等信息)\n+ error为请求失败执行的回调函数，参数依次为jqXHR对象、文本形式的错误信息(eg:error、timeout、abort)、捕获的异常对象(对于http请求为http状态的文本部分eg:Not Found)\n\n<div class=\"show\">$.ajax({\n                type:'GET',\n                url:'http://shiwivi.com',\n                data:{id:1},\n                success:function(res,textStatus,jqXHR){\n                    console.log(res);//服务器返回的数据\n                    console.log(textStatus);//success\n                    console.log(jqXHR.status);//200\n                },\n                error:function(jqXHR,textStatus,error){\n                    console.error(jqXHR.status);//404\n                    console.log(textStatus);//error\n                    console.log(error);//Not Found\n                }\n             })\n        </div>","tags":["javaScript","数据结构"]},{"title":"Git与Github","url":"/blog/2021/03/23/git与github/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n记录一下git的常用命令</div>\n <h3> 1.git与github </h3><p>git是由Linux之父Linus运用c语言开发的一款分布式版本控制工具，支持Linux命令。github是全球最大的社交编程与代码托管网站，托管了数以百万的开源项目。\n                    <ul>\n                    <li>保存所有提交过的文件历史状态</li>\n                    <li>将文件回退到任意历史版本</li>\n                    <li>多人并行修改同一文件，并推送到服务器端</li>\n                    <li>创建多条支线同时推进开发任务</li>\n                    <li>邀请团队外的人员参与开发并进行审核</li>\n                    <li>对团队成员进行权限限制</li>\n                    <li>查看团队成员的修改内容、时间、日志</li>\n                </ul>\n                    </p><h3>2.本地仓库操作</h3>\n              <h4>2.1 初始化 git init</h4>\n              <p>生成.git文件夹(默认隐藏)，文件夹中包含了配置文件等本地库相关的目录和文件，如config文件中包含用户签名等信息</p>\n               <h4>2.2 设置签名</h4> \n               <p>用户名和Email地址可随意，仅用于区分开发者身份</p>\n               <h6>项目级别(仓库级别)：</h6>\n               <p>仅在当前本地仓库范围内有效</p>\n               <div class=\"code\">git config user.name xxx\ngit config user.email xxx@xxx.com</div>\n               <p> 配置文件保存在该项目下.git文件夹中的config里</p>\n               <h6>系统用户级别：</h6>\n               <p>登录当前操作系统的用户范围</p>\n               <div class=\"code\">git config --global user.name xxx\ngit config --global user.email xxx@xxx.com</div>\n               <p>\n                配置文件位于C:\\Users\\Administrator\\.gitconfig\n                当二者用户签名都存在时，会优先使用项目级别的签名。\n               </p>\n               <h4>2.3 git本地操作</h4>\n               <h6>2.3.1 将文件加入暂存区\\从暂存区去除</h6>\n              <ul>\n                  <li>将文件加入暂存区 <span class=\"strong\">git add 文件名</span></li>\n                  <li>将所有文件加入暂存区<span class=\"strong\">git add *</span></li>\n                  <li>将文件从暂存区去除<span class=\"strong\">git rm --cached 文件名</span></li>\n                  <li>查看当前状态<span class=\"strong\">git status</span></li>\n              </ul>\n            <h6>2.3.2 将文件提交到本地库</h6>\n            <ul>\n                <li>将文件快速提交到本地库 <span class=\"strong\">git commit -m \"提交标识语句\" 文件名</span></li>\n                <li>将文件提交到本地库 <span class=\"strong\">git commit 文件名</span> </li>\n                不使用快速提交会打开vim编辑器，要求添加提交标识语句\n            </ul>\n            <h6>2.3.3 查看提交的日志</h6>\n            <ul>\n                <li>完整查看历史记录 <span class=\"strong\">git log</span></li>\n                <li>简洁版 <span class=\"strong\">git log --pretty=oneline</span> </li>\n                <li>简洁版并缩短了哈希值 <span class=\"strong\"> git log --oneline</span></li>\n                <li>在oneline基础上添加了回退版本指针需要移动的次数 <span class=\"strong\">git reflog</span></li>\n            </ul>\n            <h6>2.3.4 版本回退</h6>\n            <ul>\n                <li>基于索引值 <span class=\"strong\">git reset --hard 哈希值</span> </li>\n                <li>基于^符号：只能后退 <span class=\"strong\">git reset --hard HEAD^</span> \n                    一个^表示回退一个版本，n个^即回退n个版本</li>\n                <li>基于~符号：只能后退 <span class=\"strong\">git reset --hard HEAD~回退数</span> </li>\n            </ul>\n            <h6>2.3.5 reset的参数</h6>\n            <ul>\n                <li><span class=\"strong\">--soft  </span> 仅在本地库移动 HEAD 指针,不修改工作区和暂存区内容,工作区和暂存区内容仍为版本回退前的内容,因为本地库和暂存区内容不同了,此时git status会提示有新内容可提交(不常用)</li>\n                <li><span class=\"strong\">--mixed  </span>在本地库移动 HEAD 指针,同时暂存区也会回退到历史版本(不常用)</li>\n                <li><span class=\"strong\">--hard </span>在本地库移动 HEAD 指针，暂存区、工作区也会一同被重置回历史版本</li>\n            </ul>\n            <h6>2.3.6 文件删除与找回</h6>\n            <p>文件删除同样需要git add添加和git commit提交，将删除记录提交到本地库，以备版本回退。</p>\n<span class=\"strong\">找回文件将版本回退到删除前的版本即可</span>\n<p>若删除文件后只添加到了缓存区，没有提交到本地库，此时本地库中是没有提交记录，但可以用<span class=\"strong\"> git reset --hard HEAD </span>命令将暂存区、工作区一起回退到没有删除文件和添加缓存的那个版本。</p>\n\n即：\n<ul>\n    <li>删除操作已经提交到本地库  <span class=\"strong\"> git reset --hard 哈希值</span></li>\n    <li>删除操作未提交到本地库<span class=\"strong\">  &emsp;git reset --hard HEAD</span></li>\n</ul>\n<h6>2.3.7  文件比较</h6>\n<ul>\n    <li>将工作区和暂存区的文件进行比较 <span class=\"strong\"> git diff 文件名</span></li>\n     若无文件名则将比较所有文件\n删除内容将以红色表示，新增文件绿色标识\n    <li>将工作区文件和历史版本进行比较  <span class=\"strong\"> git diff 历史版本 文件名</span></li>\neg：git diff HEAD new1.txt 和当前版本进行比较<br/>\neg：git diff HEAD^^ new1.txt 和上上个版本比较<br/>\neg：git diff 哈希值 new1.txt 和该哈希值对应的版本进行比较\n</ul>\n<h4>2.4 分支</h4>\n<h6>2.4.1 创建与切换分支</h6>\n<ul>\n    <li>创建分支 <span class=\"strong\"> git branch 分支名</span></li>\n    <li>切换分支 <span class=\"strong\"> git checkout 分支名</span></li>\n    <li>这两个代码可以合并，创建并切换到新建的分支 <span class=\"strong\"> git checkout -b 分支名</span></li>\n    <li>不能创建两个同名的分支，使用 <span class=\"strong\"> git checkout -B 分支名 </span>强制创建会重置原有的分支</li>\n    <li>查看所有分支 <span class=\"strong\"> git branch -v</span></li>\n</ul>\n<h6>2.4.2 合并分支</h6>\n<p>1.先切换到需要待修改的分支上  <span class=\"strong\"> git checkout 分支名</span></p>\n<p>2.执行合并 <span class=\"strong\">  git merge 有新内容的分支名</span></p>\n<h6>2.4.3 解决冲突</h6>\n<p>当两个分支同一文件同一内容进行了不同修改，git将提示自动合并失败，打开文件会标识出冲突位置和内容</p>\n<div class=\"code\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD\n当前分支修改内容\n=========\n被合并分支修改内容\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;分支名</div>\n并且状态显示为正在合并，直接打开文件修改冲突内容后保存\n然后使用\n<p> <span class=\"strong\"> git add 文件名</span></p>\n<p> <span class=\"strong\">git commit -m “提交说明”</span></p>\n完成合并<br/>\n注意！！git commit 命令后不跟文件名，否则会提示合并状态下无法进行提交\n\n<h4>2.5 创建标签</h4>\n<p>可以为github的项目添加标签，方便查找不同的版本。较为规范的版本格式应该为<span class=\"tips\">主版本号.次版本号.修订号</span>各版本号应该依次递增，版本号递增应该遵循：</p>\n<ul>\n    <li><span class=\"strong\">主版本号</span>重大调整、大型不兼容的API修改</li>\n    <li><span class=\"strong\">次版本号</span>新增功能、小型功能性修改</li>\n    <li><span class=\"strong\">修订号</span>修复bug</li>\n    <li>每当次版本号递增时，修订号必须归零。每当主版本号递增时，次版本号和修订号必须归零</li>\n    <li>先行版本号可以标注在修订号之后，使用连接号再加上一连串以句点分隔的标识符来修饰，如：1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92</li>\n</ul>\n<div class=\"broadcast color-blue\">\n<div class=\"iconfont icon-yinhao\"></div>\n关于版本控制规范，github上有更详细的说明 <a href=\"https://semver.org/lang/zh-CN/\" target=\"_blank\"> https://semver.org/lang/zh-CN/</a></div>\n<h5>2.5.1 查看tag</h5>\n<p>查看已创建的标签</p>\n<ul>\n    <li>查看所有标签<span class=\"strong\"> git tag </span></li>\n    <li>查看指定版本的标签 <span class=\"strong\"> git tag -l v1.1.*</span></li>\n     <li>显示tag信息 <span class=\"strong\"> git show v1.1.1</span></li>\n</ul>\n<h5>2.5.2 创建tag</h5>\n<ul>\n    <li>轻量级tag，无任何附带信息<span class=\"strong\"> git tag 标签名</span></li>\n    <li>附带说明的tag<span class=\"strong\"> git tag -a 标签名 -m \"说明\"</span></li>\n   <li>带有签名的tag，需要GPG私钥<span class=\"strong\"> git tag -s 标签名 -m \"说明\"</span></li>\n</ul>\n<h5>2.5.3 删除tag</h5>\n<ul>\n    <li>删除本地tag<span class=\"strong\"> git tag -d 标签名</span></li>\n    <li>删除远程tag<span class=\"strong\"> git push origin --delete 标签名</span></li>\n   <li>删除远程tag<span class=\"strong\"> git push origin :refs/tags/标签名</span></li>\n</ul>\n<h5>2.5.4 验证tag</h5>\n拥有GPG私钥时可以验证tag\n<ul>\n    <li>验证tag<span class=\"strong\"> git tag -v 标签名</span></li>\n</ul>\n<h5>2.5.5 推送本地tag到远程仓库</h5>\n<ul>\n    <li>推送指定tag<span class=\"strong\"> git push 远程仓库别名 标签名</span></li>\n    <li>推送所有tag<span class=\"strong\"> git push 远程仓库别名 --tags</span></li>\n</ul>\n\n\n<h3>3.远程仓库</h3>\n<h4>3.1 push与clone</h4>\n在github创建仓库，并复制仓库地址\ngit init 在本地初始化文件夹，建立本地仓库\n<ul>\n    <li>创建远程仓库别名<span class=\"strong\"> git remote add 别名 远程仓库地址</span>(别名常用origin)</li>\n    <li>查看当前所有仓库别名<span class=\"strong\"> git remote -v</span></li>\n    <li>推到远程仓库<span class=\"strong\"> git push 别名 分支名</span></li>\n    <li>克隆到本地<span class=\"strong\"> git clone 远程仓库地址</span></li>\n</ul>\n<h4>3.2 拉取</h4>\n<ul>\n    <li>拉取并直接合并<span class=\"strong\">git pull 别名 远程分支名</span></li>\n    <li>仅拉取远程库<span class=\"strong\">git fetch 别名 远程分支名</span></li>\n    <li>合并<span class=\"strong\">git merge 远程库地址别名 / 远程分支名</span></li>\n    <li>即 pull=fetch+merge</li>\n</ul>\n<h4>3.3 冲突解决</h4>\n<p>  当团队不同成员对同一文件进行了修改，后push 的人会被要求将本地库更新到最新版本，需先 pull 到本地，而当拉取的远程库内容和本地库有冲突时，会直接进入待合并状态，需解决冲突位置。 即如果不是基于Github 远程库最新版本进行的修改，会无法进行push操作</p>\n<h3>4. 跨团队开发与fork操作</h3>\n<p>团队外的成员,可用 Github 中的 fork 将心仪的仓库复制一份到自己的仓库中，fork的仓库会保留来源。 在自己的仓库中编辑完后，可用 Github 中的 Pull requests 将修改提交给原作者。 原作者可通过 Merge pull request 合并代码，书写合并操作日志后 Confirm merge完成合并。</p>\n<h3>5. ssh免密登录设置</h3>\n<h4>5.1 生成.ssh密钥目录</h4>\n<p>1.返回根目录<span class=\"strong\">cd ~ </span></p>\n<p>2.使用命令<span class=\"strong\">ssh-keygen -t rsa -C github账号</span>生成.ssh密钥目录，密钥文件夹在win10中默认路径为C:\\Users\\当前登录win10的用户名\\.ssh</p>\n<p>3. 文件夹中默认生成 id_rsa 和 id_rsa.pub文件,使用命令<span class=\"strong\">cat id_rsa.p </span>或直接用记事本打开id_rsa.pub文件，复制内容</p>\n<p>4. 打开github的头像→Settings→SSH and GPG keys 位置，New SSH Key 后进行粘贴</p>\n<h4>5.2 配置ssh</h4>\n<p>1.创建远程仓库别名 <span class=\"strong\">git remote 别名 远程仓库ssh</span></p>\n<p>2.此时使用<span class=\"strong\">git remote -v </span>查看列表中将新增ssh地址，此时即可用<span class=\"strong\">push ssh别名 远程分支</span>使用ssh进行操作。</p>\n<h3>6. Github常见报错</h3>\n<h4>6.1 无法连接</h4>\n<p>\n    fatal: unable to access 'https://github.com/xxxxx.git/'之类的错误\n</p>\n<p>将链接中的https改为git</p>\n<h4>6.2 git push 时报错 error 10054</h4>\n最常见的问题，有时候是网络问题，还有个原因是push的文件太大，缓存默认只有1M，将缓存改为500M\n<div class=\"code\">git config http.postBuffer 524288000 </div>","tags":["笔记","git"]},{"title":"Markdown语法","url":"/blog/2021/03/22/Markd语法/","content":"<div class=\"broadcast color-yellow\">\n<div class=\"iconfont icon-dengpao14hao\"></div>\n写博客文章、说明文档究极好用的语法，适配最漂亮的写作工具Typora写文档</div>\n<h3>关于Markdown</h3>\n<p>Markdown是一种轻量级标记语言,被广泛用于创建网站、文档、电子书，<span class=\"tips\"> .md </span>文件就是用Markdown语法书写的文件</p>\n<h3>基本语法</h3>\n<h5>标题</h5>\n<p>一共支持六级标题，严格模式下 # 号后需要添加空格符</p>\n<div class=\"code\"># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</div>\n<h5>删除线</h5>\n<p>语法：<span class=\"strong\">\n~~删除线~~\n</span></p>\n<div class=\"show\"><s>&emsp;删除线&emsp; </s></div>\n<h5>斜体</h5>\n<p>语法：<span class=\"strong\">\n*斜体*\n</span></p>\n<div class=\"show\"><i>&emsp;斜体&emsp; </i></div>\n<h5>加粗</h5>\n<p>语法：<span class=\"strong\">\n**加粗**\n</span></p>\n\n<div class=\"show\"><strong>&emsp;加粗&emsp; </strong></div>\n<h5>使用斜体并加粗</h5>\n<p>语法：<span class=\"strong\">\n***文字斜体并加粗***\n</span></p>\n<div class=\"show\"><i><strong>&emsp;斜体并加粗&emsp; </strong></i></div>\n<h5>文本高亮</h5>\n<p>语法：<span class=\"strong\">\n==文本高亮==\n</span></p>\n<div class=\"show\"><span style=\"background-color:#f8f840;\">文本高亮</span></div>\n<h5>下标</h5>\n<p>语法：<span class=\"strong\">\nC~7~H~5~N~3~O~6\n</span></p>\n<div class=\"show\">C<sub>7</sub>H<sub>5</sub>N<sub>3</sub>O<sub>6</sub></div>\n<h5>上标</h5>\n<p>语法：<span class=\"strong\">\ncm^2^\n</span></p>\n<div class=\"show\">cm<sup>2</sup></div>\n<h5>表格</h5>\n<div class=\"code\">表头 | 表头 | 表头\n--- | --- | ---\n单元格 | 单元格 | 单元格</div>\n</br>\n<div class=\"table\">\n <table>\n        <thead>\n            <tr>\n                <th>表头</th>\n                <th>表头</th>\n                <th>表头</th>\n            </tr>\n        </thead>\n        <tbody>\n          <tr>\n              <td>单元格</td>\n              <td>单元格</td>\n              <td>单元格</td>\n          </tr>  \n        </tbody>\n    </table>\n</div>\n\n<p>在表头下的分隔线中加入 <span class=\"tips\"> : </span>可以设置下方单元格对齐方式，并且可以在左右两侧都使⽤ | 来标记单元格边界，并用空格对其单元格使表格看起来更美观，更为美观的语法可以写为</p>\n<div class=\"code\">|  歌手&emsp;|  类型&emsp; | 代表作&emsp; |\n| :------ | :-------: | -------: |\n| 周杰伦   | 流行乐 | 《夜曲》|\n| Jony J  |  嘻哈&emsp; | 《顽家》 |\n</div>\n<div class=\"table\">\n<table>\n        <thead>\n            <tr>\n                <th style=\"text-align:left;\">歌手</th>\n                <th>类型</th>\n                <th style=\"text-align:right;\">代表作</th>\n            </tr>\n        </thead>\n        <tbody>\n          <tr>\n              <td style=\"text-align:left;\">周杰伦</td>\n              <td>流行乐</td>\n              <td style=\"text-align:right;\">《夜曲》</td>\n          </tr>  \n           <tr>\n              <td style=\"text-align:left;\">Jony J</td>\n              <td>嘻哈</td>\n              <td style=\"text-align:right;\">《顽家》</td>\n          </tr>\n        </tbody>\n    </table>\n</div>\n<h5>引用</h5>\n<div class=\"code\">>引用\n>>嵌套的引用\n</div>\n\n<div style=\"margin:10px 0px 5px 10px;border-left:5px solid #dcdde1;padding-left:8px;\">\n引用\n<div style=\"border-left:5px solid #dcdde1;padding-left:8px;\">嵌套引用</div>\n</div>\n<h5>无序列表</h5>\n<p>标识符用<span class=\"tips\">*</span>、<span class=\"tips\">+</span>、<span class=\"tips\">-</span>均可</p>\n<div class=\"code\">* 第一点\n* 第二点\n* 第三点</div>\n<div class=\"show\">\n<ul><li>第一点</li><li>第二点</li><li>第三点</li></ul>\n</div>\n<h5>有序列表</h5>\n<p>以数字与 . 组成</p>\n<div class=\"code\">1. 第一点\n2. 第二点\n3. 第三点</div>\n<div class=\"show\">\n<ol><li> 第一点</li><li> 第二点</li><li> 第三点</li></ol>\n</div>\n<h5>代码块</h5>\n<div class=\"code\">&#96;&#96;&#96; 语言名称\n代码部分\n&#96;&#96;&#96;</div>\n<br/>\n<div class=\"code\"><code>&#96;&#96;&#96; javaScript\n<span style=\"color:#c678dd;\">let</span>&nbsp;<span style=\"color:#ff6b6b;\">dance</span><span style=\"color:#7bed9f;\">=</span>&nbsp;<span style=\"color:#61aeee;\">setInterval</span><span>(()</span><span style=\"color:#c678dd;\">=></span><span>{</span>\n&#96;&#96;&#96;</code></div>\n<h5>行内代码</h5>\n<p>语法：<span class=\"strong\">\n&#96;代码&#96;\n</span></p>\n<div class=\"code\">&#96;void main()&#96;</div>\n&emsp;<span class=\"tips\">\nvoid main()\n</span>\n<h5>分隔线</h5>\n<p>使用三个或三个以上<span class=\"tips\">*</span>、<span class=\"tips\">-</span>、<span class=\"tips\">_</span></p>\n<div class=\"code\">***\n--------\n_________</div>\n<p>分隔线表现为</p>\n<br/>\n<hr/>\n<br/>\n<h5>链接</h5>\n<p>效果同&lt;a&gt;标签</p>\n<div class=\"code\">[链接文字](链接url)</div>\n<div class=\"show\">跳转到\n<a href=\"http://markdown.p2hp.com/\" target=\"_blank\" style=\"text-decoration:underline;\">Markdown中文网</a>\n</div>\n<h5>直接插入链接</h5>\n<p>被&lt;&gt;包裹的邮箱地址、URL会被转为链接</p>\n<div class=\"code\">&lt;url&gt;\n</div>\n<div class=\"show\">Markdown中文网：\n<a href=\"http://markdown.p2hp.com/\" target=\"_blank\" style=\"text-decoration:underline;\">http://markdown.p2hp.com/</a>\n</div>\n<h5>图片</h5>\n\n<div class=\"code\">![图片描述](url)</div>\n<p>其中，感叹号后[]中的内容将会在图片无法加载显示的时候显示出来，相当于&lt;img&gt;标签的<span class=\"tips\">alt</span>属性，但不知道是否如alt属性一样支持无障碍阅读。</p>\n<div class=\"broadcast color-green\">\n<div class=\"iconfont icon-qiqiu\"></div>\nMarkdown还有进阶的画图技巧，用它画流程图是真的好用，只是很多Markdown编辑器并不支持。\n</div>\n\n#### 特殊\n在markdown中输出两个连续的短横线，需要在两个短横线中间使用零宽不连字<span class=\"tips\">`&zwnj;`</span>(zero width non joiner) ","tags":["笔记","编辑器"]}]